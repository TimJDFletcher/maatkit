---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...hecksum/mk-table-checksum   45.5   30.1   27.1   56.7    n/a  100.0   39.8
Total                          45.5   30.1   27.1   56.7    n/a  100.0   39.8
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:34:31 2010
Finish:       Thu Feb 11 18:34:31 2010

Run:          ./101_basics.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:34:32 2010
Finish:       Thu Feb 11 18:34:34 2010

Run:          ./102_since.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:34:37 2010
Finish:       Thu Feb 11 18:34:40 2010

Run:          ./103_schema.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:34:43 2010
Finish:       Thu Feb 11 18:34:50 2010

Run:          ./104_resume.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:34:54 2010
Finish:       Thu Feb 11 18:34:56 2010

Run:          ./105_chunk_size.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:35:00 2010
Finish:       Thu Feb 11 18:35:01 2010

Run:          ./106_float_precision.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:35:04 2010
Finish:       Thu Feb 11 18:35:05 2010

Run:          ./107_probability.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:35:09 2010
Finish:       Thu Feb 11 18:35:10 2010

Run:          ./108_arg_table.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:35:13 2010
Finish:       Thu Feb 11 18:35:15 2010

Run:          ./109_offset_modulo.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:35:19 2010
Finish:       Thu Feb 11 18:35:19 2010

Run:          ./110_force_index.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:35:23 2010
Finish:       Thu Feb 11 18:35:23 2010

Run:          ./111_create_replicate_table.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:35:27 2010
Finish:       Thu Feb 11 18:35:28 2010

Run:          ./112_ignore_columns.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:35:32 2010
Finish:       Thu Feb 11 18:35:32 2010

Run:          ./113_checksum.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:35:36 2010
Finish:       Thu Feb 11 18:35:37 2010

Run:          ./114_standard_options.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:35:40 2010
Finish:       Thu Feb 11 18:35:41 2010

Run:          ./115_replicate.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:35:44 2010
Finish:       Thu Feb 11 18:35:45 2010

Run:          ./116_fnv_64.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:35:49 2010
Finish:       Thu Feb 11 18:35:50 2010

Run:          ./117_filters.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:35:53 2010
Finish:       Thu Feb 11 18:35:53 2010

Run:          ./201_issue_35.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:35:57 2010
Finish:       Thu Feb 11 18:35:58 2010

Run:          ./202_issue_21.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:36:01 2010
Finish:       Thu Feb 11 18:36:04 2010

Run:          ./203_issue_69.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:36:07 2010
Finish:       Thu Feb 11 18:36:09 2010

Run:          ./204_issue_81.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:36:12 2010
Finish:       Thu Feb 11 18:36:13 2010

Run:          ./205_issue_47.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:36:17 2010
Finish:       Thu Feb 11 18:36:17 2010

Run:          ./206_issue_122.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:36:20 2010
Finish:       Thu Feb 11 18:36:21 2010

Run:          ./207_issue_51.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:36:25 2010
Finish:       Thu Feb 11 18:36:25 2010

Run:          ./mk-checksum-filter.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Feb 11 18:36:29 2010
Finish:       Thu Feb 11 18:36:29 2010

/home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This program checksums MySQL tables efficiently on one or more servers.
4                                                     #
5                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
6                                                     # Feedback and improvements are welcome.
7                                                     #
8                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
9                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
10                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
11                                                    #
12                                                    # This program is free software; you can redistribute it and/or modify it under
13                                                    # the terms of the GNU General Public License as published by the Free Software
14                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
15                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
16                                                    # licenses.
17                                                    #
18                                                    # You should have received a copy of the GNU General Public License along with
19                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
20                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
21                                                    
22            24                   24           145   use strict;
              24                                 60   
              24                                168   
23            24                   24           146   use warnings FATAL => 'all';
              24                                 61   
              24                                166   
24                                                    
25                                                    our $VERSION = '@VERSION@';
26                                                    our $DISTRIB = '@DISTRIB@';
27                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5719 $ =~ m/(\d+)/g, 0));
28                                                    
29                                                    # ###########################################################################
30                                                    # TableParser package 5266
31                                                    # ###########################################################################
32                                                    package TableParser;
33                                                    
34            24                   24           168   use strict;
              24                                 63   
              24                                113   
35            24                   24           144   use warnings FATAL => 'all';
              24                                 66   
              24                                111   
36            24                   24           161   use English qw(-no_match_vars);
              24                                 64   
              24                                156   
37            24                   24           159   use Data::Dumper;
              24                                 58   
              24                                185   
38                                                    $Data::Dumper::Indent    = 1;
39                                                    $Data::Dumper::Sortkeys  = 1;
40                                                    $Data::Dumper::Quotekeys = 0;
41                                                    
42    ***     24            50     24           165   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              24                                 59   
              24                                351   
43                                                    
44                                                    
45                                                    sub new {
46             9                    9            54      my ( $class, %args ) = @_;
47             9                                 44      my @required_args = qw(Quoter);
48             9                                 40      foreach my $arg ( @required_args ) {
49    ***      9     50                          55         die "I need a $arg argument" unless $args{$arg};
50                                                       }
51             9                                 47      my $self = { %args };
52             9                                 77      return bless $self, $class;
53                                                    }
54                                                    
55                                                    
56                                                    sub parse {
57             9                    9            47      my ( $self, $ddl, $opts ) = @_;
58    ***      9     50                          45      return unless $ddl;
59    ***      9     50                          52      if ( ref $ddl eq 'ARRAY' ) {
60    ***      9     50                          51         if ( lc $ddl->[0] eq 'table' ) {
61             9                                 37            $ddl = $ddl->[1];
62                                                          }
63                                                          else {
64                                                             return {
65    ***      0                                  0               engine => 'VIEW',
66                                                             };
67                                                          }
68                                                       }
69                                                    
70    ***      9     50                         100      if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
71    ***      0                                  0         die "Cannot parse table definition; is ANSI quoting "
72                                                             . "enabled or SQL_QUOTE_SHOW_CREATE disabled?";
73                                                       }
74                                                    
75             9                                 97      my ($name)     = $ddl =~ m/CREATE (?:TEMPORARY )?TABLE\s+(`.+?`)/;
76    ***      9     50                          96      (undef, $name) = $self->{Quoter}->split_unquote($name) if $name;
77                                                    
78             9                                183      $ddl =~ s/(`[^`]+`)/\L$1/g;
79                                                    
80             9                                 62      my $engine = $self->get_engine($ddl);
81                                                    
82             9                                129      my @defs   = $ddl =~ m/^(\s+`.*?),?$/gm;
83             9                                 39      my @cols   = map { $_ =~ m/`([^`]+)`/ } @defs;
               9                                 66   
84             9                                 24      MKDEBUG && _d('Columns:', join(', ', @cols));
85                                                    
86             9                                 28      my %def_for;
87             9                                 53      @def_for{@cols} = @defs;
88                                                    
89             9                                 30      my (@nums, @null);
90             9                                 30      my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
91             9                                 40      foreach my $col ( @cols ) {
92             9                                 33         my $def = $def_for{$col};
93             9                                 66         my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
94    ***      9     50                          45         die "Can't determine column type for $def" unless $type;
95             9                                 38         $type_for{$col} = $type;
96    ***      9     50                          64         if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
97             9                                 38            push @nums, $col;
98             9                                 38            $is_numeric{$col} = 1;
99                                                          }
100            9    100                          52         if ( $def !~ m/NOT NULL/ ) {
101            1                                  4            push @null, $col;
102            1                                  4            $is_nullable{$col} = 1;
103                                                         }
104            9    100                          73         $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
105                                                      }
106                                                   
107            9                                 89      my ($keys, $clustered_key) = $self->get_keys($ddl, $opts, \%is_nullable);
108                                                   
109                                                      return {
110            9                                 68         name           => $name,
111                                                         cols           => \@cols,
112            9                                183         col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
113            9                                103         is_col         => { map { $_ => 1 } @cols },
114                                                         null_cols      => \@null,
115                                                         is_nullable    => \%is_nullable,
116                                                         is_autoinc     => \%is_autoinc,
117                                                         clustered_key  => $clustered_key,
118                                                         keys           => $keys,
119                                                         defs           => \%def_for,
120                                                         numeric_cols   => \@nums,
121                                                         is_numeric     => \%is_numeric,
122                                                         engine         => $engine,
123                                                         type_for       => \%type_for,
124                                                      };
125                                                   }
126                                                   
127                                                   sub sort_indexes {
128   ***      0                    0             0      my ( $self, $tbl ) = @_;
129                                                   
130                                                      my @indexes
131   ***      0                                  0         = sort {
132   ***      0                                  0            (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
133                                                            || ( !$tbl->{keys}->{$a}->{is_unique} <=> !$tbl->{keys}->{$b}->{is_unique} )
134                                                            || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
135   ***      0      0      0                    0            || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      ***      0             0                    0   
136                                                         }
137                                                         grep {
138   ***      0                                  0            $tbl->{keys}->{$_}->{type} eq 'BTREE'
139                                                         }
140   ***      0                                  0         sort keys %{$tbl->{keys}};
141                                                   
142   ***      0                                  0      MKDEBUG && _d('Indexes sorted best-first:', join(', ', @indexes));
143   ***      0                                  0      return @indexes;
144                                                   }
145                                                   
146                                                   sub find_best_index {
147   ***      0                    0             0      my ( $self, $tbl, $index ) = @_;
148   ***      0                                  0      my $best;
149   ***      0      0                           0      if ( $index ) {
150   ***      0                                  0         ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
      ***      0                                  0   
      ***      0                                  0   
151                                                      }
152   ***      0      0                           0      if ( !$best ) {
153   ***      0      0                           0         if ( $index ) {
154   ***      0                                  0            die "Index '$index' does not exist in table";
155                                                         }
156                                                         else {
157   ***      0                                  0            ($best) = $self->sort_indexes($tbl);
158                                                         }
159                                                      }
160   ***      0                                  0      MKDEBUG && _d('Best index found is', $best);
161   ***      0                                  0      return $best;
162                                                   }
163                                                   
164                                                   sub find_possible_keys {
165   ***      0                    0             0      my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
166   ***      0      0                           0      return () unless $where;
167   ***      0                                  0      my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
168                                                         . ' WHERE ' . $where;
169   ***      0                                  0      MKDEBUG && _d($sql);
170   ***      0                                  0      my $expl = $dbh->selectrow_hashref($sql);
171   ***      0                                  0      $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
      ***      0                                  0   
172   ***      0      0                           0      if ( $expl->{possible_keys} ) {
173   ***      0                                  0         MKDEBUG && _d('possible_keys =', $expl->{possible_keys});
174   ***      0                                  0         my @candidates = split(',', $expl->{possible_keys});
175   ***      0                                  0         my %possible   = map { $_ => 1 } @candidates;
      ***      0                                  0   
176   ***      0      0                           0         if ( $expl->{key} ) {
177   ***      0                                  0            MKDEBUG && _d('MySQL chose', $expl->{key});
178   ***      0                                  0            unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
      ***      0                                  0   
179   ***      0                                  0            MKDEBUG && _d('Before deduping:', join(', ', @candidates));
180   ***      0                                  0            my %seen;
181   ***      0                                  0            @candidates = grep { !$seen{$_}++ } @candidates;
      ***      0                                  0   
182                                                         }
183   ***      0                                  0         MKDEBUG && _d('Final list:', join(', ', @candidates));
184   ***      0                                  0         return @candidates;
185                                                      }
186                                                      else {
187   ***      0                                  0         MKDEBUG && _d('No keys in possible_keys');
188   ***      0                                  0         return ();
189                                                      }
190                                                   }
191                                                   
192                                                   sub check_table {
193   ***      0                    0             0      my ( $self, %args ) = @_;
194   ***      0                                  0      my @required_args = qw(dbh db tbl);
195   ***      0                                  0      foreach my $arg ( @required_args ) {
196   ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
197                                                      }
198   ***      0                                  0      my ($dbh, $db, $tbl) = @args{@required_args};
199   ***      0                                  0      my $q      = $self->{Quoter};
200   ***      0                                  0      my $db_tbl = $q->quote($db, $tbl);
201   ***      0                                  0      MKDEBUG && _d('Checking', $db_tbl);
202                                                   
203   ***      0                                  0      my $sql = "SHOW TABLES FROM " . $q->quote($db)
204                                                              . ' LIKE ' . $q->literal_like($tbl);
205   ***      0                                  0      MKDEBUG && _d($sql);
206   ***      0                                  0      my $row;
207   ***      0                                  0      eval {
208   ***      0                                  0         $row = $dbh->selectrow_arrayref($sql);
209                                                      };
210   ***      0      0                           0      if ( $EVAL_ERROR ) {
211   ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
212   ***      0                                  0         return 0;
213                                                      }
214   ***      0      0      0                    0      if ( !$row->[0] || $row->[0] ne $tbl ) {
215   ***      0                                  0         MKDEBUG && _d('Table does not exist');
216   ***      0                                  0         return 0;
217                                                      }
218                                                   
219   ***      0                                  0      MKDEBUG && _d('Table exists; no privs to check');
220   ***      0      0                           0      return 1 unless $args{all_privs};
221                                                   
222   ***      0                                  0      $sql = "SHOW FULL COLUMNS FROM $db_tbl";
223   ***      0                                  0      MKDEBUG && _d($sql);
224   ***      0                                  0      eval {
225   ***      0                                  0         $row = $dbh->selectrow_hashref($sql);
226                                                      };
227   ***      0      0                           0      if ( $EVAL_ERROR ) {
228   ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
229   ***      0                                  0         return 0;
230                                                      }
231   ***      0      0                           0      if ( !scalar keys %$row ) {
232   ***      0                                  0         MKDEBUG && _d('Table has no columns:', Dumper($row));
233   ***      0                                  0         return 0;
234                                                      }
235   ***      0             0                    0      my $privs = $row->{privileges} || $row->{Privileges};
236                                                   
237   ***      0                                  0      $sql = "DELETE FROM $db_tbl LIMIT 0";
238   ***      0                                  0      MKDEBUG && _d($sql);
239   ***      0                                  0      eval {
240   ***      0                                  0         $dbh->do($sql);
241                                                      };
242   ***      0      0                           0      my $can_delete = $EVAL_ERROR ? 0 : 1;
243                                                   
244   ***      0                                  0      MKDEBUG && _d('User privs on', $db_tbl, ':', $privs,
245                                                         ($can_delete ? 'delete' : ''));
246                                                   
247   ***      0      0      0                    0      if ( !($privs =~ m/select/ && $privs =~ m/insert/ && $privs =~ m/update/
      ***                    0                        
      ***                    0                        
248                                                             && $can_delete) ) {
249   ***      0                                  0         MKDEBUG && _d('User does not have all privs');
250   ***      0                                  0         return 0;
251                                                      }
252                                                   
253   ***      0                                  0      MKDEBUG && _d('User has all privs');
254   ***      0                                  0      return 1;
255                                                   }
256                                                   
257                                                   sub get_engine {
258           18                   18            92      my ( $self, $ddl, $opts ) = @_;
259           18                                217      my ( $engine ) = $ddl =~ m/\).*?(?:ENGINE|TYPE)=(\w+)/;
260           18                                 50      MKDEBUG && _d('Storage engine:', $engine);
261   ***     18            50                  102      return $engine || undef;
262                                                   }
263                                                   
264                                                   sub get_keys {
265            9                    9            51      my ( $self, $ddl, $opts, $is_nullable ) = @_;
266            9                                 40      my $engine        = $self->get_engine($ddl);
267            9                                 29      my $keys          = {};
268            9                                 27      my $clustered_key = undef;
269                                                   
270                                                      KEY:
271            9                                 89      foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {
272                                                   
273   ***      8     50                          38         next KEY if $key =~ m/FOREIGN/;
274                                                   
275            8                                 25         my $key_ddl = $key;
276            8                                 23         MKDEBUG && _d('Parsed key:', $key_ddl);
277                                                   
278   ***      8     50                          58         if ( $engine !~ m/MEMORY|HEAP/ ) {
279            8                                 35            $key =~ s/USING HASH/USING BTREE/;
280                                                         }
281                                                   
282            8                                 75         my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
283            8                                 41         my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
284   ***      8            33                  121         $type = $type || $special || 'BTREE';
      ***                   50                        
285   ***      8     50     33                   73         if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
      ***                   33                        
286                                                            && $engine =~ m/HEAP|MEMORY/i )
287                                                         {
288   ***      0                                  0            $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
289                                                         }
290                                                   
291            8                                208         my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
292   ***      8     50                          63         my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
293            8                                 21         my @cols;
294            8                                 24         my @col_prefixes;
295            8                                 44         foreach my $col_def ( split(',', $cols) ) {
296            8                                 64            my ($name, $prefix) = $col_def =~ m/`([^`]+)`(?:\((\d+)\))?/;
297            8                                 32            push @cols, $name;
298            8                                 37            push @col_prefixes, $prefix;
299                                                         }
300            8                                 30         $name =~ s/`//g;
301                                                   
302            8                                 19         MKDEBUG && _d('Key', $name, 'cols:', join(', ', @cols));
303                                                   
304            8                                 45         $keys->{$name} = {
305                                                            name         => $name,
306                                                            type         => $type,
307                                                            colnames     => $cols,
308                                                            cols         => \@cols,
309                                                            col_prefixes => \@col_prefixes,
310                                                            is_unique    => $unique,
311            8                                101            is_nullable  => scalar(grep { $is_nullable->{$_} } @cols),
312            8                                 51            is_col       => { map { $_ => 1 } @cols },
313                                                            ddl          => $key_ddl,
314                                                         };
315                                                   
316   ***      8     50     33                   72         if ( $engine =~ m/InnoDB/i && !$clustered_key ) {
317   ***      0                                  0            my $this_key = $keys->{$name};
318   ***      0      0      0                    0            if ( $this_key->{name} eq 'PRIMARY' ) {
      ***             0                               
319   ***      0                                  0               $clustered_key = 'PRIMARY';
320                                                            }
321                                                            elsif ( $this_key->{is_unique} && !$this_key->{is_nullable} ) {
322   ***      0                                  0               $clustered_key = $this_key->{name};
323                                                            }
324   ***      0                                  0            MKDEBUG && $clustered_key && _d('This key is the clustered key');
325                                                         }
326                                                      }
327                                                   
328            9                                 50      return $keys, $clustered_key;
329                                                   }
330                                                   
331                                                   sub get_fks {
332   ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
333   ***      0                                  0      my $fks = {};
334                                                   
335   ***      0                                  0      foreach my $fk (
336                                                         $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg )
337                                                      {
338   ***      0                                  0         my ( $name ) = $fk =~ m/CONSTRAINT `(.*?)`/;
339   ***      0                                  0         my ( $cols ) = $fk =~ m/FOREIGN KEY \(([^\)]+)\)/;
340   ***      0                                  0         my ( $parent, $parent_cols ) = $fk =~ m/REFERENCES (\S+) \(([^\)]+)\)/;
341                                                   
342   ***      0      0      0                    0         if ( $parent !~ m/\./ && $opts->{database} ) {
343   ***      0                                  0            $parent = "`$opts->{database}`.$parent";
344                                                         }
345                                                   
346   ***      0                                  0         $fks->{$name} = {
347                                                            name           => $name,
348                                                            colnames       => $cols,
349   ***      0                                  0            cols           => [ map { s/[ `]+//g; $_; } split(',', $cols) ],
      ***      0                                  0   
350                                                            parent_tbl     => $parent,
351                                                            parent_colnames=> $parent_cols,
352   ***      0                                  0            parent_cols    => [ map { s/[ `]+//g; $_; } split(',', $parent_cols) ],
      ***      0                                  0   
353                                                            ddl            => $fk,
354                                                         };
355                                                      }
356                                                   
357   ***      0                                  0      return $fks;
358                                                   }
359                                                   
360                                                   sub remove_auto_increment {
361   ***      0                    0             0      my ( $self, $ddl ) = @_;
362   ***      0                                  0      $ddl =~ s/(^\).*?) AUTO_INCREMENT=\d+\b/$1/m;
363   ***      0                                  0      return $ddl;
364                                                   }
365                                                   
366                                                   sub remove_secondary_indexes {
367   ***      0                    0             0      my ( $self, $ddl ) = @_;
368   ***      0                                  0      my $sec_indexes_ddl;
369   ***      0                                  0      my $tbl_struct = $self->parse($ddl);
370                                                   
371   ***      0      0      0                    0      if ( ($tbl_struct->{engine} || '') =~ m/InnoDB/i ) {
372   ***      0                                  0         my $clustered_key = $tbl_struct->{clustered_key};
373   ***      0             0                    0         $clustered_key  ||= '';
374                                                   
375   ***      0                                  0         my @sec_indexes   = map {
376   ***      0                                  0            my $key_def = $_->{ddl};
377   ***      0                                  0            $key_def =~ s/([\(\)])/\\$1/g;
378   ***      0                                  0            $ddl =~ s/\s+$key_def//;
379   ***      0                                  0            "ADD $_->{ddl}";
380                                                         }
381   ***      0                                  0         grep { $_->{name} ne $clustered_key }
382   ***      0                                  0         values %{$tbl_struct->{keys}};
383   ***      0                                  0         MKDEBUG && _d('Secondary indexes:', Dumper(\@sec_indexes));
384                                                   
385   ***      0      0                           0         if ( @sec_indexes ) {
386   ***      0                                  0            $sec_indexes_ddl = join(' ', @sec_indexes);
387   ***      0                                  0            $sec_indexes_ddl =~ s/,$//;
388                                                         }
389                                                   
390   ***      0                                  0         $ddl =~ s/,(\n\) )/$1/s;
391                                                      }
392                                                      else {
393   ***      0                                  0         MKDEBUG && _d('Not removing secondary indexes from',
394                                                            $tbl_struct->{engine}, 'table');
395                                                      }
396                                                   
397   ***      0                                  0      return $ddl, $sec_indexes_ddl, $tbl_struct;
398                                                   }
399                                                   
400                                                   sub _d {
401   ***      0                    0             0      my ($package, undef, $line) = caller 0;
402   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
403   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
404                                                           @_;
405   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
406                                                   }
407                                                   
408                                                   1;
409                                                   
410                                                   # ###########################################################################
411                                                   # End TableParser package
412                                                   # ###########################################################################
413                                                   
414                                                   # ###########################################################################
415                                                   # TableChecksum package 5266
416                                                   # ###########################################################################
417                                                   package TableChecksum;
418                                                   
419           24                   24           216   use strict;
              24                                 68   
              24                                148   
420           24                   24           148   use warnings FATAL => 'all';
              24                                 70   
              24                                144   
421           24                   24           149   use English qw(-no_match_vars);
              24                                 62   
              24                                179   
422           24                   24           175   use List::Util qw(max);
              24                                 67   
              24                                265   
423                                                   
424   ***     24            50     24           200   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              24                                 57   
              24                                348   
425                                                   
426                                                   our %ALGOS = (
427                                                      CHECKSUM => { pref => 0, hash => 0 },
428                                                      BIT_XOR  => { pref => 2, hash => 1 },
429                                                      ACCUM    => { pref => 3, hash => 1 },
430                                                   );
431                                                   
432                                                   sub new {
433            9                    9            60      my ( $class, %args ) = @_;
434            9                                 42      foreach my $arg ( qw(Quoter VersionParser) ) {
435   ***     18     50                         100         die "I need a $arg argument" unless defined $args{$arg};
436                                                      }
437            9                                 46      my $self = { %args };
438            9                                 73      return bless $self, $class;
439                                                   }
440                                                   
441                                                   sub crc32 {
442   ***      0                    0             0      my ( $self, $string ) = @_;
443   ***      0                                  0      my $poly = 0xEDB88320;
444   ***      0                                  0      my $crc  = 0xFFFFFFFF;
445   ***      0                                  0      foreach my $char ( split(//, $string) ) {
446   ***      0                                  0         my $comp = ($crc ^ ord($char)) & 0xFF;
447   ***      0                                  0         for ( 1 .. 8 ) {
448   ***      0      0                           0            $comp = $comp & 1 ? $poly ^ ($comp >> 1) : $comp >> 1;
449                                                         }
450   ***      0                                  0         $crc = (($crc >> 8) & 0x00FFFFFF) ^ $comp;
451                                                      }
452   ***      0                                  0      return $crc ^ 0xFFFFFFFF;
453                                                   }
454                                                   
455                                                   sub get_crc_wid {
456            7                    7            33      my ( $self, $dbh, $func ) = @_;
457            7                                 21      my $crc_wid = 16;
458   ***      7     50     33                   68      if ( uc $func ne 'FNV_64' && uc $func ne 'FNV1A_64' ) {
459            7                                 18         eval {
460            7                                 19            my ($val) = $dbh->selectrow_array("SELECT $func('a')");
461            7                                796            $crc_wid = max(16, length($val));
462                                                         };
463                                                      }
464            7                                 35      return $crc_wid;
465                                                   }
466                                                   
467                                                   sub get_crc_type {
468            7                    7            34      my ( $self, $dbh, $func ) = @_;
469            7                                 22      my $type   = '';
470            7                                 20      my $length = 0;
471            7                                 28      my $sql    = "SELECT $func('a')";
472            7                                 31      my $sth    = $dbh->prepare($sql);
473            7                                 36      eval {
474            7                                697         $sth->execute();
475            7                                 67         $type   = $sth->{mysql_type_name}->[0];
476            7                                 42         $length = $sth->{mysql_length}->[0];
477            7                                 35         MKDEBUG && _d($sql, $type, $length);
478   ***      7    100     66                   53         if ( $type eq 'bigint' && $length < 20 ) {
479            1                                  3            $type = 'int';
480                                                         }
481                                                      };
482            7                                 64      $sth->finish;
483            7                                 17      MKDEBUG && _d('crc_type:', $type, 'length:', $length);
484            7                                112      return ($type, $length);
485                                                   }
486                                                   
487                                                   sub best_algorithm {
488            9                    9            79      my ( $self, %args ) = @_;
489            9                                 58      my ( $alg, $dbh ) = @args{ qw(algorithm dbh) };
490            9                                 38      my $vp = $self->{VersionParser};
491            9                                 20      my @choices = sort { $ALGOS{$a}->{pref} <=> $ALGOS{$b}->{pref} } keys %ALGOS;
              27                                146   
492   ***      9     50     66                  121      die "Invalid checksum algorithm $alg"
493                                                         if $alg && !$ALGOS{$alg};
494                                                   
495   ***      9     50     33                  173      if (
      ***                   33                        
      ***                   33                        
496                                                         $args{where} || $args{chunk}        # CHECKSUM does whole table
497                                                         || $args{replicate}                 # CHECKSUM can't do INSERT.. SELECT
498                                                         || !$vp->version_ge($dbh, '4.1.1')) # CHECKSUM doesn't exist
499                                                      {
500   ***      0                                  0         MKDEBUG && _d('Cannot use CHECKSUM algorithm');
501   ***      0                                  0         @choices = grep { $_ ne 'CHECKSUM' } @choices;
      ***      0                                  0   
502                                                      }
503                                                   
504   ***      9     50                          43      if ( !$vp->version_ge($dbh, '4.1.1') ) {
505   ***      0                                  0         MKDEBUG && _d('Cannot use BIT_XOR algorithm because MySQL < 4.1.1');
506   ***      0                                  0         @choices = grep { $_ ne 'BIT_XOR' } @choices;
      ***      0                                  0   
507                                                      }
508                                                   
509   ***      9    100     66                   73      if ( $alg && grep { $_ eq $alg } @choices ) {
              21                                100   
510            7                                 18         MKDEBUG && _d('User requested', $alg, 'algorithm');
511            7                                 46         return $alg;
512                                                      }
513                                                   
514   ***      2     50     33                   19      if ( $args{count} && grep { $_ ne 'CHECKSUM' } @choices ) {
      ***      0                                  0   
515   ***      0                                  0         MKDEBUG && _d('Not using CHECKSUM algorithm because COUNT desired');
516   ***      0                                  0         @choices = grep { $_ ne 'CHECKSUM' } @choices;
      ***      0                                  0   
517                                                      }
518                                                   
519            2                                  5      MKDEBUG && _d('Algorithms, in order:', @choices);
520            2                                 27      return $choices[0];
521                                                   }
522                                                   
523                                                   sub is_hash_algorithm {
524            9                    9            45      my ( $self, $algorithm ) = @_;
525   ***      9            66                  113      return $ALGOS{$algorithm} && $ALGOS{$algorithm}->{hash};
526                                                   }
527                                                   
528                                                   sub choose_hash_func {
529            7                    7            40      my ( $self, %args ) = @_;
530            7                                 40      my @funcs = qw(CRC32 FNV1A_64 FNV_64 MD5 SHA1);
531   ***      7     50                          32      if ( $args{function} ) {
532            7                                 28         unshift @funcs, $args{function};
533                                                      }
534            7                                 22      my ($result, $error);
535   ***      7            33                   21      do {
536            7                                 17         my $func;
537            7                                 18         eval {
538            7                                 24            $func = shift(@funcs);
539            7                                 29            my $sql = "SELECT $func('test-string')";
540            7                                 16            MKDEBUG && _d($sql);
541            7                                854            $args{dbh}->do($sql);
542            7                                 29            $result = $func;
543                                                         };
544   ***      7     50     33                  100         if ( $EVAL_ERROR && $EVAL_ERROR =~ m/failed: (.*?) at \S+ line/ ) {
545   ***      0                                  0            $error .= qq{$func cannot be used because "$1"\n};
546   ***      0                                  0            MKDEBUG && _d($func, 'cannot be used because', $1);
547                                                         }
548                                                      } while ( @funcs && !$result );
549                                                   
550   ***      7     50                          28      die $error unless $result;
551            7                                 15      MKDEBUG && _d('Chosen hash func:', $result);
552            7                                 53      return $result;
553                                                   }
554                                                   
555                                                   sub optimize_xor {
556            2                    2            14      my ( $self, %args ) = @_;
557            2                                 12      my ($dbh, $func) = @args{qw(dbh function)};
558                                                   
559   ***      2     50                          11      die "$func never needs the BIT_XOR optimization"
560                                                         if $func =~ m/^(?:FNV1A_64|FNV_64|CRC32)$/i;
561                                                   
562            2                                  7      my $opt_slice = 0;
563            2                                  4      my $unsliced  = uc $dbh->selectall_arrayref("SELECT $func('a')")->[0]->[0];
564            2                                219      my $sliced    = '';
565            2                                  7      my $start     = 1;
566   ***      2     50                          10      my $crc_wid   = length($unsliced) < 16 ? 16 : length($unsliced);
567                                                   
568   ***      2            66                    7      do { # Try different positions till sliced result equals non-sliced.
569            5                                 10         MKDEBUG && _d('Trying slice', $opt_slice);
570            5                                446         $dbh->do('SET @crc := "", @cnt := 0');
571            5                                 34         my $slices = $self->make_xor_slices(
572                                                            query     => "\@crc := $func('a')",
573                                                            crc_wid   => $crc_wid,
574                                                            opt_slice => $opt_slice,
575                                                         );
576                                                   
577            5                                 21         my $sql = "SELECT CONCAT($slices) AS TEST FROM (SELECT NULL) AS x";
578            5                                  9         $sliced = ($dbh->selectrow_array($sql))[0];
579            5    100                        1138         if ( $sliced ne $unsliced ) {
580            3                                  6            MKDEBUG && _d('Slice', $opt_slice, 'does not work');
581            3                                 10            $start += 16;
582            3                                 38            ++$opt_slice;
583                                                         }
584                                                      } while ( $start < $crc_wid && $sliced ne $unsliced );
585                                                   
586   ***      2     50                           9      if ( $sliced eq $unsliced ) {
587            2                                  5         MKDEBUG && _d('Slice', $opt_slice, 'works');
588            2                                 13         return $opt_slice;
589                                                      }
590                                                      else {
591   ***      0                                  0         MKDEBUG && _d('No slice works');
592   ***      0                                  0         return undef;
593                                                      }
594                                                   }
595                                                   
596                                                   sub make_xor_slices {
597            8                    8            67      my ( $self, %args ) = @_;
598            8                                 42      foreach my $arg ( qw(query crc_wid) ) {
599   ***     16     50                          78         die "I need a $arg argument" unless defined $args{$arg};
600                                                      }
601            8                                 43      my ( $query, $crc_wid, $opt_slice ) = @args{qw(query crc_wid opt_slice)};
602                                                   
603            8                                 20      my @slices;
604                                                      for ( my $start = 1; $start <= $crc_wid; $start += 16 ) {
605           21                                 71         my $len = $crc_wid - $start + 1;
606           21    100                          75         if ( $len > 16 ) {
607           13                                 34            $len = 16;
608                                                         }
609           21                                178         push @slices,
610                                                            "LPAD(CONV(BIT_XOR("
611                                                            . "CAST(CONV(SUBSTRING(\@crc, $start, $len), 16, 10) AS UNSIGNED))"
612                                                            . ", 10, 16), $len, '0')";
613            8                                 22      }
614                                                   
615   ***      8    100     66                   71      if ( defined $opt_slice && $opt_slice < @slices ) {
616            7                                 64         $slices[$opt_slice] =~ s/\@crc/\@crc := $query/;
617                                                      }
618                                                      else {
619            1                                  3         map { s/\@crc/$query/ } @slices;
               3                                 20   
620                                                      }
621                                                   
622            8                                 59      return join(', ', @slices);
623                                                   }
624                                                   
625                                                   sub make_row_checksum {
626            7                    7            78      my ( $self, %args ) = @_;
627            7                                 47      my ( $tbl_struct, $func ) = @args{ qw(tbl_struct function) };
628            7                                 25      my $q = $self->{Quoter};
629                                                   
630   ***      7            50                   33      my $sep = $args{sep} || '#';
631            7                                 48      $sep =~ s/'//g;
632   ***      7            50                   28      $sep ||= '#';
633                                                   
634            7                                 22      my %ignorecols = map { $_ => 1 } @{$args{ignorecols}};
      ***      0                                  0   
               7                                 33   
635                                                   
636            7                                 43      my %cols = map { lc($_) => 1 }
               7                                 29   
637   ***      0                                  0                 grep { !exists $ignorecols{$_} }
638   ***      7     50                          35                 ($args{cols} ? @{$args{cols}} : @{$tbl_struct->{cols}});
               7                                 35   
639            7                                 31      my @cols =
640                                                         map {
641            7                                 28            my $type = $tbl_struct->{type_for}->{$_};
642            7                                 30            my $result = $q->quote($_);
643   ***      7     50     33                   70            if ( $type eq 'timestamp' ) {
      ***            50     33                        
      ***            50                               
644   ***      0                                  0               $result .= ' + 0';
645                                                            }
646                                                            elsif ( $type =~ m/float|double/ && $args{float_precision} ) {
647   ***      0                                  0               $result = "ROUND($result, $args{float_precision})";
648                                                            }
649                                                            elsif ( $type =~ m/varchar/ && $args{trim} ) {
650   ***      0                                  0               $result = "TRIM($result)";
651                                                            }
652            7                                 28            $result;
653                                                         }
654                                                         grep {
655            7                                 29            $cols{$_}
656                                                         }
657            7                                 27         @{$tbl_struct->{cols}};
658                                                   
659            7                                 21      my $query;
660   ***      7     50     33                   64      if ( uc $func ne 'FNV_64' && uc $func ne 'FNV1A_64' ) {
661            7                                 26         my @nulls = grep { $cols{$_} } @{$tbl_struct->{null_cols}};
      ***      0                                  0   
               7                                 32   
662   ***      7     50                          29         if ( @nulls ) {
663   ***      0                                  0            my $bitmap = "CONCAT("
664   ***      0                                  0               . join(', ', map { 'ISNULL(' . $q->quote($_) . ')' } @nulls)
665                                                               . ")";
666   ***      0                                  0            push @cols, $bitmap;
667                                                         }
668                                                   
669   ***      7     50                          42         $query = @cols > 1
670                                                                ? "$func(CONCAT_WS('$sep', " . join(', ', @cols) . '))'
671                                                                : "$func($cols[0])";
672                                                      }
673                                                      else {
674   ***      0                                  0         my $fnv_func = uc $func;
675   ***      0                                  0         $query = "$fnv_func(" . join(', ', @cols) . ')';
676                                                      }
677                                                   
678            7                                 44      return $query;
679                                                   }
680                                                   
681                                                   sub make_checksum_query {
682            9                    9           150      my ( $self, %args ) = @_;
683            9                                 71      my @required_args = qw(db tbl tbl_struct algorithm crc_wid crc_type);
684            9                                 42      foreach my $arg( @required_args ) {
685   ***     54     50                         253         die "I need a $arg argument" unless $args{$arg};
686                                                      }
687            9                                 65      my ( $db, $tbl, $tbl_struct, $algorithm,
688                                                           $crc_wid, $crc_type) = @args{@required_args};
689            9                                 32      my $func = $args{function};
690            9                                 33      my $q = $self->{Quoter};
691            9                                 26      my $result;
692                                                   
693   ***      9     50     33                   99      die "Invalid or missing checksum algorithm"
694                                                         unless $algorithm && $ALGOS{$algorithm};
695                                                   
696            9    100                          43      if ( $algorithm eq 'CHECKSUM' ) {
697            2                                 13         return "CHECKSUM TABLE " . $q->quote($db, $tbl);
698                                                      }
699                                                   
700            7                                 61      my $expr = $self->make_row_checksum(%args);
701                                                   
702            7    100                          36      if ( $algorithm eq 'BIT_XOR' ) {
703   ***      3     50                          15         if ( $crc_type =~ m/int$/ ) {
704   ***      0                                  0            $result = "LOWER(CONV(BIT_XOR(CAST($expr AS UNSIGNED)), 10, 16)) AS crc ";
705                                                         }
706                                                         else {
707            3                                 22            my $slices = $self->make_xor_slices( query => $expr, %args );
708            3                                 19            $result = "LOWER(CONCAT($slices)) AS crc ";
709                                                         }
710                                                      }
711                                                      else {
712            4    100                          24         if ( $crc_type =~ m/int$/ ) {
713            1                                  9            $result = "RIGHT(MAX("
714                                                               . "\@crc := CONCAT(LPAD(\@cnt := \@cnt + 1, 16, '0'), "
715                                                               . "CONV(CAST($func(CONCAT(\@crc, $expr)) AS UNSIGNED), 10, 16))"
716                                                               . "), $crc_wid) AS crc ";
717                                                         }
718                                                         else {
719            3                                 20            $result = "RIGHT(MAX("
720                                                               . "\@crc := CONCAT(LPAD(\@cnt := \@cnt + 1, 16, '0'), "
721                                                               . "$func(CONCAT(\@crc, $expr)))"
722                                                               . "), $crc_wid) AS crc ";
723                                                         }
724                                                      }
725   ***      7     50                          29      if ( $args{replicate} ) {
726   ***      0                                  0         $result = "REPLACE /*PROGRESS_COMMENT*/ INTO $args{replicate} "
727                                                            . "(db, tbl, chunk, boundaries, this_cnt, this_crc) "
728                                                            . "SELECT ?, ?, /*CHUNK_NUM*/ ?, COUNT(*) AS cnt, $result";
729                                                      }
730                                                      else {
731   ***      7     50                          47         $result = "SELECT "
732                                                            . ($args{buffer} ? 'SQL_BUFFER_RESULT ' : '')
733                                                            . "/*PROGRESS_COMMENT*//*CHUNK_NUM*/ COUNT(*) AS cnt, $result";
734                                                      }
735            7                                 55      return $result . "FROM /*DB_TBL*//*INDEX_HINT*//*WHERE*/";
736                                                   }
737                                                   
738                                                   sub find_replication_differences {
739   ***      0                    0             0      my ( $self, $dbh, $table ) = @_;
740                                                   
741   ***      0                                  0      (my $sql = <<"   EOF") =~ s/\s+/ /gm;
742                                                         SELECT db, tbl, chunk, boundaries,
743                                                            COALESCE(this_cnt-master_cnt, 0) AS cnt_diff,
744                                                            COALESCE(
745                                                               this_crc <> master_crc OR ISNULL(master_crc) <> ISNULL(this_crc),
746                                                               0
747                                                            ) AS crc_diff,
748                                                            this_cnt, master_cnt, this_crc, master_crc
749                                                         FROM $table
750                                                         WHERE master_cnt <> this_cnt OR master_crc <> this_crc
751                                                         OR ISNULL(master_crc) <> ISNULL(this_crc)
752                                                      EOF
753                                                   
754   ***      0                                  0      MKDEBUG && _d($sql);
755   ***      0                                  0      my $diffs = $dbh->selectall_arrayref($sql, { Slice => {} });
756   ***      0                                  0      return @$diffs;
757                                                   }
758                                                   
759                                                   sub _d {
760   ***      0                    0             0      my ($package, undef, $line) = caller 0;
761   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
762   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
763                                                           @_;
764   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
765                                                   }
766                                                   
767                                                   1;
768                                                   
769                                                   # ###########################################################################
770                                                   # End TableChecksum package
771                                                   # ###########################################################################
772                                                   
773                                                   # ###########################################################################
774                                                   # OptionParser package 5568
775                                                   # ###########################################################################
776                                                   package OptionParser;
777                                                   
778           24                   24           201   use strict;
              24                                 69   
              24                                139   
779           24                   24           153   use warnings FATAL => 'all';
              24                                 63   
              24                                137   
780                                                   
781           24                   24           288   use Getopt::Long;
              24                                 79   
              24                                257   
782           24                   24           221   use List::Util qw(max);
              24                                 66   
              24                                143   
783           24                   24           152   use English qw(-no_match_vars);
              24                                 55   
              24                                171   
784                                                   
785   ***     24            50     24           165   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              24                                 59   
              24                                372   
786                                                   
787                                                   my $POD_link_re = '[LC]<"?([^">]+)"?>';
788                                                   
789                                                   my %attributes = (
790                                                      'type'       => 1,
791                                                      'short form' => 1,
792                                                      'group'      => 1,
793                                                      'default'    => 1,
794                                                      'cumulative' => 1,
795                                                      'negatable'  => 1,
796                                                   );
797                                                   
798                                                   sub new {
799            9                    9           118      my ( $class, %args ) = @_;
800            9                                 55      foreach my $arg ( qw(description) ) {
801   ***      9     50                          80         die "I need a $arg argument" unless $args{$arg};
802                                                      }
803            9                                120      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
804   ***      9            33                   51      $program_name ||= $PROGRAM_NAME;
805   ***      9            33                  108      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                   33                        
      ***                   50                        
806                                                   
807   ***      9     50     50                  368      my $self = {
      ***                   50                        
808                                                         description    => $args{description},
809                                                         prompt         => $args{prompt} || '<options>',
810                                                         strict         => (exists $args{strict} ? $args{strict} : 1),
811                                                         dp             => $args{dp}     || undef,
812                                                         program_name   => $program_name,
813                                                         opts           => {},
814                                                         got_opts       => 0,
815                                                         short_opts     => {},
816                                                         defaults       => {},
817                                                         groups         => {},
818                                                         allowed_groups => {},
819                                                         errors         => [],
820                                                         rules          => [],  # desc of rules for --help
821                                                         mutex          => [],  # rule: opts are mutually exclusive
822                                                         atleast1       => [],  # rule: at least one opt is required
823                                                         disables       => {},  # rule: opt disables other opts 
824                                                         defaults_to    => {},  # rule: opt defaults to value of other opt
825                                                         default_files  => [
826                                                            "/etc/maatkit/maatkit.conf",
827                                                            "/etc/maatkit/$program_name.conf",
828                                                            "$home/.maatkit.conf",
829                                                            "$home/.$program_name.conf",
830                                                         ],
831                                                      };
832            9                                134      return bless $self, $class;
833                                                   }
834                                                   
835                                                   sub get_specs {
836            9                    9            43      my ( $self, $file ) = @_;
837            9                                 57      my @specs = $self->_pod_to_specs($file);
838            9                                271      $self->_parse_specs(@specs);
839            9                                 64      return;
840                                                   }
841                                                   
842                                                   sub get_defaults_files {
843            9                    9            43      my ( $self ) = @_;
844            9                                 29      return @{$self->{default_files}};
               9                                103   
845                                                   }
846                                                   
847                                                   sub _pod_to_specs {
848            9                    9            47      my ( $self, $file ) = @_;
849   ***      9            50                   62      $file ||= __FILE__;
850   ***      9     50                         399      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
851                                                   
852            9                                155      my %types = (
853                                                         string => 's', # standard Getopt type
854                                                         'int'  => 'i', # standard Getopt type
855                                                         float  => 'f', # standard Getopt type
856                                                         Hash   => 'H', # hash, formed from a comma-separated list
857                                                         hash   => 'h', # hash as above, but only if a value is given
858                                                         Array  => 'A', # array, similar to Hash
859                                                         array  => 'a', # array, similar to hash
860                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
861                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
862                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
863                                                      );
864            9                                 39      my @specs = ();
865            9                                 32      my @rules = ();
866            9                                 26      my $para;
867                                                   
868            9                                 68      local $INPUT_RECORD_SEPARATOR = '';
869            9                                414      while ( $para = <$fh> ) {
870         6822    100                       55898         next unless $para =~ m/^=head1 OPTIONS/;
871            9                                 44         last;
872                                                      }
873                                                   
874            9                                 81      while ( $para = <$fh> ) {
875           18    100                         107         last if $para =~ m/^=over/;
876            9                                 39         chomp $para;
877            9                                100         $para =~ s/\s+/ /g;
878            9                                275         $para =~ s/$POD_link_re/$1/go;
879            9                                 29         MKDEBUG && _d('Option rule:', $para);
880            9                                 85         push @rules, $para;
881                                                      }
882                                                   
883   ***      9     50                          48      die 'POD has no OPTIONS section' unless $para;
884                                                   
885            9                                 38      do {
886          558    100                        4529         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
887          549                               1783            chomp $para;
888          549                               1508            MKDEBUG && _d($para);
889          549                               2070            my %attribs;
890                                                   
891          549                               2376            $para = <$fh>; # read next paragraph, possibly attributes
892                                                   
893          549    100                        2551            if ( $para =~ m/: / ) { # attributes
894          441                               2467               $para =~ s/\s+\Z//g;
895          729                               4257               %attribs = map {
896          441                               2394                     my ( $attrib, $val) = split(/: /, $_);
897   ***    729     50                        3779                     die "Unrecognized attribute for --$option: $attrib"
898                                                                        unless $attributes{$attrib};
899          729                               4256                     ($attrib, $val);
900                                                                  } split(/; /, $para);
901          441    100                        2357               if ( $attribs{'short form'} ) {
902           90                                502                  $attribs{'short form'} =~ s/-//;
903                                                               }
904          441                               2298               $para = <$fh>; # read next paragraph, probably short help desc
905                                                            }
906                                                            else {
907          108                                297               MKDEBUG && _d('Option has no attributes');
908                                                            }
909                                                   
910          549                               4002            $para =~ s/\s+\Z//g;
911          549                               4161            $para =~ s/\s+/ /g;
912          549                               3924            $para =~ s/$POD_link_re/$1/go;
913                                                   
914          549                               2658            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
915          549                               1373            MKDEBUG && _d('Short help:', $para);
916                                                   
917   ***    549     50                        2554            die "No description after option spec $option" if $para =~ m/^=item/;
918                                                   
919          549    100                        3080            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
920           36                                117               $option = $base_option;
921           36                                147               $attribs{'negatable'} = 1;
922                                                            }
923                                                   
924          549    100                       11230            push @specs, {
                    100                               
      ***            50                               
                    100                               
                    100                               
                    100                               
925                                                               spec  => $option
926                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
927                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
928                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
929                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
930                                                               desc  => $para
931                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
932                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
933                                                            };
934                                                         }
935          558                               4641         while ( $para = <$fh> ) {
936   ***   1458     50                        5866            last unless $para;
937                                                   
938                                                   
939         1458    100                        6525            if ( $para =~ m/^=head1/ ) {
940            9                                 35               $para = undef; # Can't 'last' out of a do {} block.
941            9                                 51               last;
942                                                            }
943         1449    100                       11714            last if $para =~ m/^=item --/;
944                                                         }
945                                                      } while ( $para );
946                                                   
947   ***      9     50                          43      die 'No valid specs in POD OPTIONS' unless @specs;
948                                                   
949            9                                140      close $fh;
950            9                                 41      return @specs, @rules;
951                                                   }
952                                                   
953                                                   sub _parse_specs {
954            9                    9           136      my ( $self, @specs ) = @_;
955            9                                 52      my %disables; # special rule that requires deferred checking
956                                                   
957            9                                 45      foreach my $opt ( @specs ) {
958          558    100                        2227         if ( ref $opt ) { # It's an option spec, not a rule.
959                                                            MKDEBUG && _d('Parsing opt spec:',
960          549                               1291               map { ($_, '=>', $opt->{$_}) } keys %$opt);
961                                                   
962          549                               4039            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
963   ***    549     50                        2540            if ( !$long ) {
964   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
965                                                            }
966          549                               2105            $opt->{long} = $long;
967                                                   
968   ***    549     50                        2721            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
969          549                               2560            $self->{opts}->{$long} = $opt;
970                                                   
971   ***    549     50                        2983            if ( length $long == 1 ) {
972   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
973   ***      0                                  0               $self->{short_opts}->{$long} = $long;
974                                                            }
975                                                   
976          549    100                        1935            if ( $short ) {
977   ***     90     50                         458               die "Duplicate short option -$short"
978                                                                  if exists $self->{short_opts}->{$short};
979           90                                430               $self->{short_opts}->{$short} = $long;
980           90                                348               $opt->{short} = $short;
981                                                            }
982                                                            else {
983          459                               1724               $opt->{short} = undef;
984                                                            }
985                                                   
986          549    100                        3129            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
987   ***    549     50                        2892            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
988   ***    549     50                        3335            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
989                                                   
990   ***    549            50                 2449            $opt->{group} ||= 'default';
991          549                               3059            $self->{groups}->{ $opt->{group} }->{$long} = 1;
992                                                   
993          549                               2083            $opt->{value} = undef;
994          549                               1912            $opt->{got}   = 0;
995                                                   
996          549                               3042            my ( $type ) = $opt->{spec} =~ m/=(.)/;
997          549                               2097            $opt->{type} = $type;
998          549                               1295            MKDEBUG && _d($long, 'type:', $type);
999                                                   
1000  ***    549     50     66                 5078            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                   33                        
1001  ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
1002                                                                 . "was given when this OptionParser object was created";
1003                                                           }
1004                                                  
1005         549    100    100                 4176            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
1006                                                  
1007         549    100                        3476            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
1008  ***     81     50                         505               $self->{defaults}->{$long} = defined $def ? $def : 1;
1009          81                                218               MKDEBUG && _d($long, 'default:', $def);
1010                                                           }
1011                                                  
1012         549    100                        2290            if ( $long eq 'config' ) {
1013           9                                 68               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
1014                                                           }
1015                                                  
1016         549    100                        3067            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
1017          18                                 70               $disables{$long} = $dis;
1018          18                                 53               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
1019                                                           }
1020                                                  
1021         549                               2840            $self->{opts}->{$long} = $opt;
1022                                                        }
1023                                                        else { # It's an option rule, not a spec.
1024           9                                 28            MKDEBUG && _d('Parsing rule:', $opt); 
1025           9                                 26            push @{$self->{rules}}, $opt;
               9                                 56   
1026           9                                 60            my @participants = $self->_get_participants($opt);
1027           9                                 38            my $rule_ok = 0;
1028                                                  
1029  ***      9     50                         100            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
1030  ***      0                                  0               $rule_ok = 1;
1031  ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
1032  ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
1033                                                           }
1034  ***      9     50                          68            if ( $opt =~ m/at least one|one and only one/ ) {
1035  ***      0                                  0               $rule_ok = 1;
1036  ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
1037  ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
1038                                                           }
1039  ***      9     50                          53            if ( $opt =~ m/default to/ ) {
1040  ***      0                                  0               $rule_ok = 1;
1041  ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
1042  ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
1043                                                           }
1044  ***      9     50                          62            if ( $opt =~ m/restricted to option groups/ ) {
1045           9                                 45               $rule_ok = 1;
1046           9                                 73               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
1047           9                                 82               my @groups = split(',', $groups);
1048           9                                109               %{$self->{allowed_groups}->{$participants[0]}} = map {
              45                                157   
1049           9                                 47                  s/\s+//;
1050          45                                181                  $_ => 1;
1051                                                              } @groups;
1052                                                           }
1053                                                  
1054  ***      9     50                          73            die "Unrecognized option rule: $opt" unless $rule_ok;
1055                                                        }
1056                                                     }
1057                                                  
1058           9                                 62      foreach my $long ( keys %disables ) {
1059          18                                 97         my @participants = $self->_get_participants($disables{$long});
1060          18                                103         $self->{disables}->{$long} = \@participants;
1061          18                                 63         MKDEBUG && _d('Option', $long, 'disables', @participants);
1062                                                     }
1063                                                  
1064           9                                 72      return; 
1065                                                  }
1066                                                  
1067                                                  sub _get_participants {
1068          27                   27           135      my ( $self, $str ) = @_;
1069          27                                 83      my @participants;
1070          27                                219      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
1071  ***     27     50                         163         die "Option --$long does not exist while processing rule $str"
1072                                                           unless exists $self->{opts}->{$long};
1073          27                                131         push @participants, $long;
1074                                                     }
1075          27                                 80      MKDEBUG && _d('Participants for', $str, ':', @participants);
1076          27                                147      return @participants;
1077                                                  }
1078                                                  
1079                                                  sub opts {
1080  ***      0                    0             0      my ( $self ) = @_;
1081  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1082  ***      0                                  0      return %opts;
1083                                                  }
1084                                                  
1085                                                  sub short_opts {
1086  ***      0                    0             0      my ( $self ) = @_;
1087  ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
1088  ***      0                                  0      return %short_opts;
1089                                                  }
1090                                                  
1091                                                  sub set_defaults {
1092  ***      0                    0             0      my ( $self, %defaults ) = @_;
1093  ***      0                                  0      $self->{defaults} = {};
1094  ***      0                                  0      foreach my $long ( keys %defaults ) {
1095  ***      0      0                           0         die "Cannot set default for nonexistent option $long"
1096                                                           unless exists $self->{opts}->{$long};
1097  ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
1098  ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
1099                                                     }
1100  ***      0                                  0      return;
1101                                                  }
1102                                                  
1103                                                  sub get_defaults {
1104  ***      0                    0             0      my ( $self ) = @_;
1105  ***      0                                  0      return $self->{defaults};
1106                                                  }
1107                                                  
1108                                                  sub get_groups {
1109  ***      0                    0             0      my ( $self ) = @_;
1110  ***      0                                  0      return $self->{groups};
1111                                                  }
1112                                                  
1113                                                  sub _set_option {
1114          52                   52           246      my ( $self, $opt, $val ) = @_;
1115  ***     52      0                         444      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
1116                                                              : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
1117                                                              : die "Getopt::Long gave a nonexistent option: $opt";
1118                                                  
1119          52                                107      $opt = $self->{opts}->{$long};
1120  ***     52     50                         312      if ( $opt->{is_cumulative} ) {
1121  ***      0                                  0         $opt->{value}++;
1122                                                     }
1123                                                     else {
1124          52                                198         $opt->{value} = $val;
1125                                                     }
1126          52                                172      $opt->{got} = 1;
1127          52                                201      MKDEBUG && _d('Got option', $long, '=', $val);
1128                                                  }
1129                                                  
1130                                                  sub get_opts {
1131           9                    9            45      my ( $self ) = @_; 
1132                                                  
1133           9                                 31      foreach my $long ( keys %{$self->{opts}} ) {
               9                                158   
1134         549                               2398         $self->{opts}->{$long}->{got} = 0;
1135  ***    549     50                        4888         $self->{opts}->{$long}->{value}
                    100                               
1136                                                           = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
1137                                                           : $self->{opts}->{$long}->{is_cumulative} ? 0
1138                                                           : undef;
1139                                                     }
1140           9                                 74      $self->{got_opts} = 0;
1141                                                  
1142           9                                 41      $self->{errors} = [];
1143                                                  
1144  ***      9     50     33                  123      if ( @ARGV && $ARGV[0] eq "--config" ) {
1145  ***      0                                  0         shift @ARGV;
1146  ***      0                                  0         $self->_set_option('config', shift @ARGV);
1147                                                     }
1148  ***      9     50                          62      if ( $self->has('config') ) {
1149           9                                 36         my @extra_args;
1150           9                                 61         foreach my $filename ( split(',', $self->get('config')) ) {
1151          36                                112            eval {
1152          36                                189               push @extra_args, $self->_read_config_file($filename);
1153                                                           };
1154  ***     36     50                         218            if ( $EVAL_ERROR ) {
1155  ***     36     50                         173               if ( $self->got('config') ) {
1156  ***      0                                  0                  die $EVAL_ERROR;
1157                                                              }
1158                                                              elsif ( MKDEBUG ) {
1159                                                                 _d($EVAL_ERROR);
1160                                                              }
1161                                                           }
1162                                                        }
1163           9                                 52         unshift @ARGV, @extra_args;
1164                                                     }
1165                                                  
1166           9                                 82      Getopt::Long::Configure('no_ignore_case', 'bundling');
1167                                                     GetOptions(
1168         540                   52          3913         map    { $_->{spec} => sub { $self->_set_option(@_); } }
              52                                948   
             549                               2774   
1169           9                                 84         grep   { $_->{long} ne 'config' } # --config is handled specially above.
1170  ***      9     50                          50         values %{$self->{opts}}
1171                                                     ) or $self->save_error('Error parsing options');
1172                                                  
1173  ***      9     50     33                  966      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
1174  ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
1175                                                           $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
1176                                                              or die "Cannot print: $OS_ERROR";
1177  ***      0                                  0         exit 0;
1178                                                     }
1179                                                  
1180  ***      9     50     33                  108      if ( @ARGV && $self->{strict} ) {
1181  ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
1182                                                     }
1183                                                  
1184           9                                 31      foreach my $mutex ( @{$self->{mutex}} ) {
               9                                 63   
1185  ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
1186  ***      0      0                           0         if ( @set > 1 ) {
1187  ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
1188  ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
1189                                                                   . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
1190                                                                   . ' are mutually exclusive.';
1191  ***      0                                  0            $self->save_error($err);
1192                                                        }
1193                                                     }
1194                                                  
1195           9                                 31      foreach my $required ( @{$self->{atleast1}} ) {
               9                                 48   
1196  ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
1197  ***      0      0                           0         if ( @set == 0 ) {
1198  ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
1199  ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
1200                                                                   .' or --'.$self->{opts}->{$required->[-1]}->{long};
1201  ***      0                                  0            $self->save_error("Specify at least one of $err");
1202                                                        }
1203                                                     }
1204                                                  
1205           9                                 30      foreach my $long ( keys %{$self->{opts}} ) {
               9                                140   
1206         549                               2247         my $opt = $self->{opts}->{$long};
1207         549    100                        3389         if ( $opt->{got} ) {
      ***            50                               
1208          52    100                         251            if ( exists $self->{disables}->{$long} ) {
1209           8                                 28               my @disable_opts = @{$self->{disables}->{$long}};
               8                                 60   
1210           8                                 32               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
               8                                 45   
1211           8                                 23               MKDEBUG && _d('Unset options', @disable_opts,
1212                                                                 'because', $long,'disables them');
1213                                                           }
1214                                                  
1215  ***     52     50                         257            if ( exists $self->{allowed_groups}->{$long} ) {
1216                                                  
1217  ***      0                                  0               my @restricted_groups = grep {
1218  ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
1219  ***      0                                  0               } keys %{$self->{groups}};
1220                                                  
1221  ***      0                                  0               my @restricted_opts;
1222  ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
1223  ***      0                                  0                  RESTRICTED_OPT:
1224  ***      0                                  0                  foreach my $restricted_opt (
1225                                                                    keys %{$self->{groups}->{$restricted_group}} )
1226                                                                 {
1227  ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
1228  ***      0      0                           0                     push @restricted_opts, $restricted_opt
1229                                                                       if $self->{opts}->{$restricted_opt}->{got};
1230                                                                 }
1231                                                              }
1232                                                  
1233  ***      0      0                           0               if ( @restricted_opts ) {
1234  ***      0                                  0                  my $err;
1235  ***      0      0                           0                  if ( @restricted_opts == 1 ) {
1236  ***      0                                  0                     $err = "--$restricted_opts[0]";
1237                                                                 }
1238                                                                 else {
1239  ***      0                                  0                     $err = join(', ',
1240  ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
1241  ***      0                                  0                               grep { $_ } 
1242                                                                              @restricted_opts[0..scalar(@restricted_opts) - 2]
1243                                                                           )
1244                                                                         . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
1245                                                                 }
1246  ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
1247                                                              }
1248                                                           }
1249                                                  
1250                                                        }
1251                                                        elsif ( $opt->{is_required} ) { 
1252  ***      0                                  0            $self->save_error("Required option --$long must be specified");
1253                                                        }
1254                                                  
1255         549                               2220         $self->_validate_type($opt);
1256                                                     }
1257                                                  
1258           9                                 79      $self->{got_opts} = 1;
1259           9                                 34      return;
1260                                                  }
1261                                                  
1262                                                  sub _validate_type {
1263         549                  549          2096      my ( $self, $opt ) = @_;
1264  ***    549    100     66                 5369      return unless $opt && $opt->{type};
1265         342                               1174      my $val = $opt->{value};
1266                                                  
1267         342    100    100                 8955      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***            50     66                        
      ***            50     66                        
                    100    100                        
                    100    100                        
      ***                   66                        
      ***                   66                        
1268          18                                 44         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
1269          18                                206         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
1270  ***     18     50                          92         if ( !$suffix ) {
1271  ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
1272  ***      0             0                    0            $suffix = $s || 's';
1273  ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
1274                                                              $opt->{long}, '(value:', $val, ')');
1275                                                        }
1276  ***     18     50                          96         if ( $suffix =~ m/[smhd]/ ) {
1277  ***     18      0                          79            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***            50                               
1278                                                                : $suffix eq 'm' ? $num * 60       # Minutes
1279                                                                : $suffix eq 'h' ? $num * 3600     # Hours
1280                                                                :                  $num * 86400;   # Days
1281  ***     18            50                  184            $opt->{value} = ($prefix || '') . $val;
1282          18                                 58            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
1283                                                        }
1284                                                        else {
1285  ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
1286                                                        }
1287                                                     }
1288                                                     elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
1289  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
1290  ***      0                                  0         my $prev = {};
1291  ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
1292  ***      0      0                           0         if ( $from_key ) {
1293  ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
1294  ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
1295                                                        }
1296  ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
1297  ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
1298                                                     }
1299                                                     elsif ( $val && $opt->{type} eq 'z' ) {  # type size
1300  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
1301  ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
1302  ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
1303  ***      0      0                           0         if ( defined $num ) {
1304  ***      0      0                           0            if ( $factor ) {
1305  ***      0                                  0               $num *= $factor_for{$factor};
1306  ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
1307                                                                 'to num', $num, '* factor', $factor);
1308                                                           }
1309  ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
1310                                                        }
1311                                                        else {
1312  ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
1313                                                        }
1314                                                     }
1315                                                     elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
1316  ***     27            50                  185         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
              36                                220   
1317                                                     }
1318                                                     elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
1319  ***      9            50                  148         $opt->{value} = [ split(/(?<!\\),\s*/, ($val || '')) ];
1320                                                     }
1321                                                     else {
1322         288                                732         MKDEBUG && _d('Nothing to validate for option',
1323                                                           $opt->{long}, 'type', $opt->{type}, 'value', $val);
1324                                                     }
1325                                                  
1326         342                               1309      return;
1327                                                  }
1328                                                  
1329                                                  sub get {
1330         751                  751          3028      my ( $self, $opt ) = @_;
1331         751    100                        3354      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1332  ***    751     50     33                 6846      die "Option $opt does not exist"
1333                                                        unless $long && exists $self->{opts}->{$long};
1334         751                               6424      return $self->{opts}->{$long}->{value};
1335                                                  }
1336                                                  
1337                                                  sub got {
1338          36                   36           179      my ( $self, $opt ) = @_;
1339  ***     36     50                         184      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1340  ***     36     50     33                  388      die "Option $opt does not exist"
1341                                                        unless $long && exists $self->{opts}->{$long};
1342          36                                274      return $self->{opts}->{$long}->{got};
1343                                                  }
1344                                                  
1345                                                  sub has {
1346         359                  359          1391      my ( $self, $opt ) = @_;
1347         359    100                        1645      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1348         359    100                        2756      return defined $long ? exists $self->{opts}->{$long} : 0;
1349                                                  }
1350                                                  
1351                                                  sub set {
1352           8                    8            40      my ( $self, $opt, $val ) = @_;
1353  ***      8     50                          44      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1354  ***      8     50     33                   82      die "Option $opt does not exist"
1355                                                        unless $long && exists $self->{opts}->{$long};
1356           8                                 38      $self->{opts}->{$long}->{value} = $val;
1357           8                                 28      return;
1358                                                  }
1359                                                  
1360                                                  sub save_error {
1361  ***      0                    0             0      my ( $self, $error ) = @_;
1362  ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
1363                                                  }
1364                                                  
1365                                                  sub errors {
1366  ***      0                    0             0      my ( $self ) = @_;
1367  ***      0                                  0      return $self->{errors};
1368                                                  }
1369                                                  
1370                                                  sub prompt {
1371  ***      0                    0             0      my ( $self ) = @_;
1372  ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
1373                                                  }
1374                                                  
1375                                                  sub descr {
1376  ***      0                    0             0      my ( $self ) = @_;
1377  ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
1378                                                                . "  For more details, please use the --help option, "
1379                                                                . "or try 'perldoc $PROGRAM_NAME' "
1380                                                                . "for complete documentation.";
1381  ***      0      0                           0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g)
1382                                                        unless $ENV{DONT_BREAK_LINES};
1383  ***      0                                  0      $descr =~ s/ +$//mg;
1384  ***      0                                  0      return $descr;
1385                                                  }
1386                                                  
1387                                                  sub usage_or_errors {
1388           9                    9            39      my ( $self ) = @_;
1389  ***      9     50                          57      if ( $self->{opts}->{help}->{got} ) {
      ***      9     50                          52   
1390  ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
1391  ***      0                                  0         exit 0;
1392                                                     }
1393                                                     elsif ( scalar @{$self->{errors}} ) {
1394  ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
1395  ***      0                                  0         exit 0;
1396                                                     }
1397           9                                 25      return;
1398                                                  }
1399                                                  
1400                                                  sub print_errors {
1401  ***      0                    0             0      my ( $self ) = @_;
1402  ***      0                                  0      my $usage = $self->prompt() . "\n";
1403  ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
1404  ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
1405                                                                . "\n";
1406                                                     }
1407  ***      0                                  0      return $usage . "\n" . $self->descr();
1408                                                  }
1409                                                  
1410                                                  sub print_usage {
1411  ***      0                    0             0      my ( $self ) = @_;
1412  ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
1413  ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
1414                                                  
1415  ***      0      0                           0      my $maxl = max(
1416  ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
1417                                                        @opts);
1418                                                  
1419  ***      0      0                           0      my $maxs = max(0,
1420  ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
1421  ***      0                                  0         values %{$self->{short_opts}});
1422                                                  
1423  ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
1424  ***      0                                  0      my $rcol = 80 - $lcol - 6;
1425  ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
1426                                                  
1427  ***      0                                  0      $maxs = max($lcol - 3, $maxs);
1428                                                  
1429  ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
1430                                                  
1431  ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
1432  ***      0                                  0      push @groups, 'default';
1433                                                  
1434  ***      0                                  0      foreach my $group ( reverse @groups ) {
1435  ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
1436  ***      0                                  0         foreach my $opt (
      ***      0                                  0   
1437  ***      0                                  0            sort { $a->{long} cmp $b->{long} }
1438                                                           grep { $_->{group} eq $group }
1439                                                           @opts )
1440                                                        {
1441  ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
1442  ***      0                                  0            my $short = $opt->{short};
1443  ***      0                                  0            my $desc  = $opt->{desc};
1444  ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
1445  ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
1446  ***      0             0                    0               $s    ||= 's';
1447  ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
1448  ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
1449                                                                     . "d=days; if no suffix, $s is used.";
1450                                                           }
1451  ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
1452  ***      0                                  0            $desc =~ s/ +$//mg;
1453  ***      0      0                           0            if ( $short ) {
1454  ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
1455                                                           }
1456                                                           else {
1457  ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
1458                                                           }
1459                                                        }
1460                                                     }
1461                                                  
1462  ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
1463  ***      0                                  0         $usage .= "\nRules:\n\n";
1464  ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
1465                                                     }
1466  ***      0      0                           0      if ( $self->{dp} ) {
1467  ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
1468                                                     }
1469  ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
1470  ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
1471  ***      0                                  0         my $val   = $opt->{value};
1472  ***      0             0                    0         my $type  = $opt->{type} || '';
1473  ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
1474  ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
1475                                                                  : !defined $val             ? '(No value)'
1476                                                                  : $type eq 'd'              ? $self->{dp}->as_string($val)
1477                                                                  : $type =~ m/H|h/           ? join(',', sort keys %$val)
1478                                                                  : $type =~ m/A|a/           ? join(',', @$val)
1479                                                                  :                             $val;
1480  ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
1481                                                     }
1482  ***      0                                  0      return $usage;
1483                                                  }
1484                                                  
1485                                                  sub prompt_noecho {
1486  ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
1487  ***      0                                  0      my ( $prompt ) = @_;
1488  ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
1489  ***      0      0                           0      print $prompt
1490                                                        or die "Cannot print: $OS_ERROR";
1491  ***      0                                  0      my $response;
1492  ***      0                                  0      eval {
1493  ***      0                                  0         require Term::ReadKey;
1494  ***      0                                  0         Term::ReadKey::ReadMode('noecho');
1495  ***      0                                  0         chomp($response = <STDIN>);
1496  ***      0                                  0         Term::ReadKey::ReadMode('normal');
1497  ***      0      0                           0         print "\n"
1498                                                           or die "Cannot print: $OS_ERROR";
1499                                                     };
1500  ***      0      0                           0      if ( $EVAL_ERROR ) {
1501  ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
1502                                                     }
1503  ***      0                                  0      return $response;
1504                                                  }
1505                                                  
1506                                                  if ( MKDEBUG ) {
1507                                                     print '# ', $^X, ' ', $], "\n";
1508                                                     my $uname = `uname -a`;
1509                                                     if ( $uname ) {
1510                                                        $uname =~ s/\s+/ /g;
1511                                                        print "# $uname\n";
1512                                                     }
1513                                                     printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
1514                                                        $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
1515                                                        ($main::SVN_REV || ''), __LINE__);
1516                                                     print('# Arguments: ',
1517                                                        join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
1518                                                  }
1519                                                  
1520                                                  sub _read_config_file {
1521          36                   36           161      my ( $self, $filename ) = @_;
1522  ***     36     50                         106      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
1523  ***      0                                  0      my @args;
1524  ***      0                                  0      my $prefix = '--';
1525  ***      0                                  0      my $parse  = 1;
1526                                                  
1527                                                     LINE:
1528  ***      0                                  0      while ( my $line = <$fh> ) {
1529  ***      0                                  0         chomp $line;
1530  ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
1531  ***      0                                  0         $line =~ s/\s+#.*$//g;
1532  ***      0                                  0         $line =~ s/^\s+|\s+$//g;
1533  ***      0      0                           0         if ( $line eq '--' ) {
1534  ***      0                                  0            $prefix = '';
1535  ***      0                                  0            $parse  = 0;
1536  ***      0                                  0            next LINE;
1537                                                        }
1538  ***      0      0      0                    0         if ( $parse
      ***             0                               
1539                                                           && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
1540                                                        ) {
1541  ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
1542                                                        }
1543                                                        elsif ( $line =~ m/./ ) {
1544  ***      0                                  0            push @args, $line;
1545                                                        }
1546                                                        else {
1547  ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
1548                                                        }
1549                                                     }
1550  ***      0                                  0      close $fh;
1551  ***      0                                  0      return @args;
1552                                                  }
1553                                                  
1554                                                  sub read_para_after {
1555           9                    9            55      my ( $self, $file, $regex ) = @_;
1556  ***      9     50                         434      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
1557           9                                 73      local $INPUT_RECORD_SEPARATOR = '';
1558           9                                 28      my $para;
1559           9                                220      while ( $para = <$fh> ) {
1560        5814    100                       46057         next unless $para =~ m/^=pod$/m;
1561           9                                 34         last;
1562                                                     }
1563           9                                 61      while ( $para = <$fh> ) {
1564        1179    100                        8604         next unless $para =~ m/$regex/;
1565           9                                 27         last;
1566                                                     }
1567           9                                 34      $para = <$fh>;
1568           9                                 34      chomp($para);
1569  ***      9     50                         115      close $fh or die "Can't close $file: $OS_ERROR";
1570           9                                 32      return $para;
1571                                                  }
1572                                                  
1573                                                  sub clone {
1574           9                    9            38      my ( $self ) = @_;
1575                                                  
1576          27                                113      my %clone = map {
1577           9                                 41         my $hashref  = $self->{$_};
1578          27                                 86         my $val_copy = {};
1579          27                                306         foreach my $key ( keys %$hashref ) {
1580         729                               2555            my $ref = ref $hashref->{$key};
1581         549                               6737            $val_copy->{$key} = !$ref           ? $hashref->{$key}
1582  ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
1583  ***    729      0                        3477                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***            50                               
                    100                               
1584                                                                             : $hashref->{$key};
1585                                                        }
1586          27                                192         $_ => $val_copy;
1587                                                     } qw(opts short_opts defaults);
1588                                                  
1589           9                                 45      foreach my $scalar ( qw(got_opts) ) {
1590           9                                 63         $clone{$scalar} = $self->{$scalar};
1591                                                     }
1592                                                  
1593           9                                 76      return bless \%clone;     
1594                                                  }
1595                                                  
1596                                                  sub _d {
1597  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1598  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1599  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1600                                                          @_;
1601  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1602                                                  }
1603                                                  
1604                                                  1;
1605                                                  
1606                                                  # ###########################################################################
1607                                                  # End OptionParser package
1608                                                  # ###########################################################################
1609                                                  
1610                                                  # ###########################################################################
1611                                                  # DSNParser package 5266
1612                                                  # ###########################################################################
1613                                                  package DSNParser;
1614                                                  
1615          24                   24           263   use strict;
              24                                 78   
              24                                205   
1616          24                   24           249   use warnings FATAL => 'all';
              24                                 66   
              24                                187   
1617          24                   24           149   use English qw(-no_match_vars);
              24                                 67   
              24                                148   
1618          24                   24           166   use Data::Dumper;
              24                                 58   
              24                                173   
1619                                                  $Data::Dumper::Indent    = 0;
1620                                                  $Data::Dumper::Quotekeys = 0;
1621                                                  
1622                                                  eval {
1623                                                     require DBI;
1624                                                  };
1625                                                  my $have_dbi = $EVAL_ERROR ? 0 : 1;
1626                                                  
1627  ***     24            50     24           169   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              24                                 67   
              24                                376   
1628                                                  
1629                                                  sub new {
1630          32                   32           202      my ( $class, @opts ) = @_;
1631          32                                864      my $self = {
1632                                                        opts => {
1633                                                           A => {
1634                                                              desc => 'Default character set',
1635                                                              dsn  => 'charset',
1636                                                              copy => 1,
1637                                                           },
1638                                                           D => {
1639                                                              desc => 'Database to use',
1640                                                              dsn  => 'database',
1641                                                              copy => 1,
1642                                                           },
1643                                                           F => {
1644                                                              desc => 'Only read default options from the given file',
1645                                                              dsn  => 'mysql_read_default_file',
1646                                                              copy => 1,
1647                                                           },
1648                                                           h => {
1649                                                              desc => 'Connect to host',
1650                                                              dsn  => 'host',
1651                                                              copy => 1,
1652                                                           },
1653                                                           p => {
1654                                                              desc => 'Password to use when connecting',
1655                                                              dsn  => 'password',
1656                                                              copy => 1,
1657                                                           },
1658                                                           P => {
1659                                                              desc => 'Port number to use for connection',
1660                                                              dsn  => 'port',
1661                                                              copy => 1,
1662                                                           },
1663                                                           S => {
1664                                                              desc => 'Socket file to use for connection',
1665                                                              dsn  => 'mysql_socket',
1666                                                              copy => 1,
1667                                                           },
1668                                                           u => {
1669                                                              desc => 'User for login if not current user',
1670                                                              dsn  => 'user',
1671                                                              copy => 1,
1672                                                           },
1673                                                        },
1674                                                     };
1675          32                                183      foreach my $opt ( @opts ) {
1676  ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
1677  ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
1678                                                     }
1679          32                                385      return bless $self, $class;
1680                                                  }
1681                                                  
1682                                                  sub prop {
1683         150                  150           717      my ( $self, $prop, $value ) = @_;
1684         150    100                         760      if ( @_ > 2 ) {
1685           9                                 27         MKDEBUG && _d('Setting', $prop, 'property');
1686           9                                 42         $self->{$prop} = $value;
1687                                                     }
1688         150                               1066      return $self->{$prop};
1689                                                  }
1690                                                  
1691                                                  sub parse {
1692          50                   50          1914      my ( $self, $dsn, $prev, $defaults ) = @_;
1693  ***     50     50                         315      if ( !$dsn ) {
1694  ***      0                                  0         MKDEBUG && _d('No DSN to parse');
1695  ***      0                                  0         return;
1696                                                     }
1697          50                                132      MKDEBUG && _d('Parsing', $dsn);
1698  ***     50            50                  247      $prev     ||= {};
1699          50           100                 1360      $defaults ||= {};
1700          50                                254      my %given_props;
1701          50                                135      my %final_props;
1702          50                                155      my %opts = %{$self->{opts}};
              50                                505   
1703                                                  
1704          50                                418      foreach my $dsn_part ( split(/,/, $dsn) ) {
1705         146    100                        1209         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1706         138                                632            $given_props{$prop_key} = $prop_val;
1707                                                        }
1708                                                        else {
1709           8                                 21            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1710           8                                 44            $given_props{h} = $dsn_part;
1711                                                        }
1712                                                     }
1713                                                  
1714          50                                280      foreach my $key ( keys %opts ) {
1715         400                                869         MKDEBUG && _d('Finding value for', $key);
1716         400                               1359         $final_props{$key} = $given_props{$key};
1717  ***    400     50     66                 3480         if (   !defined $final_props{$key}
      ***                   33                        
1718                                                             && defined $prev->{$key} && $opts{$key}->{copy} )
1719                                                        {
1720  ***      0                                  0            $final_props{$key} = $prev->{$key};
1721  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1722                                                        }
1723         400    100                        1718         if ( !defined $final_props{$key} ) {
1724         254                                878            $final_props{$key} = $defaults->{$key};
1725         254                                950            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1726                                                        }
1727                                                     }
1728                                                  
1729          50                                271      foreach my $key ( keys %given_props ) {
1730  ***    146     50                         667         die "Unrecognized DSN part '$key' in '$dsn'\n"
1731                                                           unless exists $opts{$key};
1732                                                     }
1733  ***     50     50                         270      if ( (my $required = $self->prop('required')) ) {
1734  ***      0                                  0         foreach my $key ( keys %$required ) {
1735  ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1736                                                        }
1737                                                     }
1738                                                  
1739          50                                370      return \%final_props;
1740                                                  }
1741                                                  
1742                                                  sub parse_options {
1743           9                    9            41      my ( $self, $o ) = @_;
1744  ***      9     50                          59      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1745           9                                 45      my $dsn_string
1746                                                        = join(',',
1747          72    100                         271             map  { "$_=".$o->get($_); }
1748           9                                 91             grep { $o->has($_) && $o->get($_) }
1749           9                                 32             keys %{$self->{opts}}
1750                                                          );
1751           9                                 35      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1752           9                                 51      return $self->parse($dsn_string);
1753                                                  }
1754                                                  
1755                                                  sub as_string {
1756  ***      0                    0             0      my ( $self, $dsn ) = @_;
1757  ***      0      0                           0      return $dsn unless ref $dsn;
1758  ***      0      0                           0      return join(',',
1759  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1760  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1761                                                        sort keys %$dsn );
1762                                                  }
1763                                                  
1764                                                  sub usage {
1765  ***      0                    0             0      my ( $self ) = @_;
1766  ***      0                                  0      my $usage
1767                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1768                                                        . "  KEY  COPY  MEANING\n"
1769                                                        . "  ===  ====  =============================================\n";
1770  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1771  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1772  ***      0      0      0                    0         $usage .= "  $key    "
1773                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1774                                                               .  ($opts{$key}->{desc} || '[No description]')
1775                                                               . "\n";
1776                                                     }
1777  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1778  ***      0                                  0      return $usage;
1779                                                  }
1780                                                  
1781                                                  sub get_cxn_params {
1782          41                   41           460      my ( $self, $info ) = @_;
1783          41                                127      my $dsn;
1784          41                                123      my %opts = %{$self->{opts}};
              41                                338   
1785  ***     41            50                  213      my $driver = $self->prop('dbidriver') || '';
1786  ***     41     50                         209      if ( $driver eq 'Pg' ) {
1787  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1788  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1789  ***      0             0                    0                        grep { defined $info->{$_} }
1790                                                                       qw(h P));
1791                                                     }
1792                                                     else {
1793          82                                599         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1794         205                                802            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1795  ***     41            50                  503                        grep { defined $info->{$_} }
1796                                                                       qw(F h P S A))
1797                                                           . ';mysql_read_default_group=client';
1798                                                     }
1799          41                                128      MKDEBUG && _d($dsn);
1800          41                                364      return ($dsn, $info->{u}, $info->{p});
1801                                                  }
1802                                                  
1803                                                  sub fill_in_dsn {
1804  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1805  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1806  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1807  ***      0                                  0      $user =~ s/@.*//;
1808  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1809  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1810  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1811  ***      0             0                    0      $dsn->{u} ||= $user;
1812  ***      0             0                    0      $dsn->{D} ||= $db;
1813                                                  }
1814                                                  
1815                                                  sub get_dbh {
1816          41                   41           271      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1817  ***     41            50                  199      $opts ||= {};
1818  ***     41     50                         395      my $defaults = {
1819                                                        AutoCommit         => 0,
1820                                                        RaiseError         => 1,
1821                                                        PrintError         => 0,
1822                                                        ShowErrorStatement => 1,
1823                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1824                                                     };
1825          41                                213      @{$defaults}{ keys %$opts } = values %$opts;
              41                                173   
1826                                                  
1827  ***     41     50                         193      if ( !$have_dbi ) {
1828  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1829                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1830                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1831                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1832                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1833                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1834                                                  
1835                                                     }
1836                                                  
1837          41                                121      my $dbh;
1838          41                                125      my $tries = 2;
1839  ***     41            66                  446      while ( !$dbh && $tries-- ) {
1840                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1841          41                                104            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1842                                                  
1843          41                                127         eval {
1844          41                                318            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1845                                                  
1846  ***     41     50                         417            if ( $cxn_string =~ m/mysql/i ) {
1847          41                                118               my $sql;
1848                                                  
1849          41                                167               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1850                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1851          41                                100               MKDEBUG && _d($dbh, ':', $sql);
1852          41                               4776               $dbh->do($sql);
1853                                                  
1854  ***     41     50                         350               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1855  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1856  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1857  ***      0                                  0                  $dbh->do($sql);
1858  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1859  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1860  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1861                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1862                                                                 }
1863                                                                 else {
1864  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1865                                                                 }
1866                                                              }
1867                                                  
1868          41    100                         251               if ( $self->prop('set-vars') ) {
1869           9                                 44                  $sql = "SET " . $self->prop('set-vars');
1870           9                                 22                  MKDEBUG && _d($dbh, ':', $sql);
1871           9                                806                  $dbh->do($sql);
1872                                                              }
1873                                                           }
1874                                                        };
1875  ***     41     50     33                  438         if ( !$dbh && $EVAL_ERROR ) {
1876  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1877  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1878  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1879  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1880                                                           }
1881                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1882  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1883                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1884                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1885                                                                 . "DBD::mysql is not installed, try:\n"
1886                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1887                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1888                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1889                                                           }
1890  ***      0      0                           0            if ( !$tries ) {
1891  ***      0                                  0               die $EVAL_ERROR;
1892                                                           }
1893                                                        }
1894                                                     }
1895                                                  
1896          41                                103      MKDEBUG && _d('DBH info: ',
1897                                                        $dbh,
1898                                                        Dumper($dbh->selectrow_hashref(
1899                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1900                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1901                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1902                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1903                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1904                                                        '$DBI::VERSION:',        $DBI::VERSION,
1905                                                     );
1906                                                  
1907          41                                266      return $dbh;
1908                                                  }
1909                                                  
1910                                                  sub get_hostname {
1911  ***      0                    0             0      my ( $self, $dbh ) = @_;
1912  ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1913  ***      0                                  0         return $host;
1914                                                     }
1915  ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
1916                                                        'SELECT /*!50038 @@hostname, */ 1');
1917  ***      0                                  0      return $hostname;
1918                                                  }
1919                                                  
1920                                                  sub disconnect {
1921  ***      0                    0             0      my ( $self, $dbh ) = @_;
1922  ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
1923  ***      0                                  0      $dbh->disconnect;
1924                                                  }
1925                                                  
1926                                                  sub print_active_handles {
1927  ***      0                    0             0      my ( $self, $thing, $level ) = @_;
1928  ***      0             0                    0      $level ||= 0;
1929  ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1930                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1931                                                        or die "Cannot print: $OS_ERROR";
1932  ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
1933  ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
1934                                                     }
1935                                                  }
1936                                                  
1937                                                  sub copy {
1938  ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1939  ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
1940  ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
1941  ***      0                                  0      my %new_dsn = map {
1942  ***      0                                  0         my $key = $_;
1943  ***      0                                  0         my $val;
1944  ***      0      0                           0         if ( $args{overwrite} ) {
1945  ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1946                                                        }
1947                                                        else {
1948  ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1949                                                        }
1950  ***      0                                  0         $key => $val;
1951  ***      0                                  0      } keys %{$self->{opts}};
1952  ***      0                                  0      return \%new_dsn;
1953                                                  }
1954                                                  
1955                                                  sub _d {
1956  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1957  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1958  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1959                                                          @_;
1960  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1961                                                  }
1962                                                  
1963                                                  1;
1964                                                  
1965                                                  # ###########################################################################
1966                                                  # End DSNParser package
1967                                                  # ###########################################################################
1968                                                  
1969                                                  # ###########################################################################
1970                                                  # VersionParser package 5266
1971                                                  # ###########################################################################
1972                                                  package VersionParser;
1973                                                  
1974          24                   24           191   use strict;
              24                                 65   
              24                                151   
1975          24                   24           151   use warnings FATAL => 'all';
              24                                 65   
              24                                129   
1976                                                  
1977          24                   24           145   use English qw(-no_match_vars);
              24                                 68   
              24                                127   
1978                                                  
1979  ***     24            50     24           161   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              24                                 73   
              24                                573   
1980                                                  
1981                                                  sub new {
1982          11                   11            89      my ( $class ) = @_;
1983          11                                 90      bless {}, $class;
1984                                                  }
1985                                                  
1986                                                  sub parse {
1987          37                   37          1511      my ( $self, $str ) = @_;
1988          37                                389      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
1989          37                                104      MKDEBUG && _d($str, 'parses to', $result);
1990          37                                220      return $result;
1991                                                  }
1992                                                  
1993                                                  sub version_ge {
1994          27                   27          1111      my ( $self, $dbh, $target ) = @_;
1995          27    100                         155      if ( !$self->{$dbh} ) {
1996          10                                 25         $self->{$dbh} = $self->parse(
1997                                                           $dbh->selectrow_array('SELECT VERSION()'));
1998                                                     }
1999  ***     27     50                         269      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
2000          27                                 65      MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
2001          27                                191      return $result;
2002                                                  }
2003                                                  
2004                                                  sub _d {
2005  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2006  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2007  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2008                                                          @_;
2009  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2010                                                  }
2011                                                  
2012                                                  1;
2013                                                  
2014                                                  # ###########################################################################
2015                                                  # End VersionParser package
2016                                                  # ###########################################################################
2017                                                  
2018                                                  # ###########################################################################
2019                                                  # MySQLDump package 5266
2020                                                  # ###########################################################################
2021                                                  package MySQLDump;
2022                                                  
2023          24                   24           166   use strict;
              24                                 65   
              24                                125   
2024          24                   24           162   use warnings FATAL => 'all';
              24                                 70   
              24                                117   
2025                                                  
2026          24                   24           145   use English qw(-no_match_vars);
              24                                 66   
              24                                381   
2027                                                  
2028  ***     24            50     24           154   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              24                                 67   
              24                               3830   
2029                                                  
2030                                                  ( our $before = <<'EOF') =~ s/^   //gm;
2031                                                     /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
2032                                                     /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
2033                                                     /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
2034                                                     /*!40101 SET NAMES utf8 */;
2035                                                     /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
2036                                                     /*!40103 SET TIME_ZONE='+00:00' */;
2037                                                     /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
2038                                                     /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
2039                                                     /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
2040                                                     /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
2041                                                  EOF
2042                                                  
2043                                                  ( our $after = <<'EOF') =~ s/^   //gm;
2044                                                     /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
2045                                                     /*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
2046                                                     /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
2047                                                     /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
2048                                                     /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
2049                                                     /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
2050                                                     /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
2051                                                     /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
2052                                                  EOF
2053                                                  
2054                                                  sub new {
2055           9                    9            61      my ( $class, %args ) = @_;
2056  ***      9     50                          50      $args{cache} = 1 unless defined $args{cache};
2057           9                                 60      my $self = bless \%args, $class;
2058           9                                 35      return $self;
2059                                                  }
2060                                                  
2061                                                  sub dump {
2062  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl, $what ) = @_;
2063                                                  
2064  ***      0      0                           0      if ( $what eq 'table' ) {
      ***             0                               
      ***             0                               
2065  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
2066  ***      0      0                           0         return unless $ddl;
2067  ***      0      0                           0         if ( $ddl->[0] eq 'table' ) {
2068  ***      0                                  0            return $before
2069                                                              . 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
2070                                                              . $ddl->[1] . ";\n";
2071                                                        }
2072                                                        else {
2073  ***      0                                  0            return 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
2074                                                              . '/*!50001 DROP VIEW IF EXISTS '
2075                                                              . $quoter->quote($tbl) . "*/;\n/*!50001 "
2076                                                              . $self->get_tmp_table($dbh, $quoter, $db, $tbl) . "*/;\n";
2077                                                        }
2078                                                     }
2079                                                     elsif ( $what eq 'triggers' ) {
2080  ***      0                                  0         my $trgs = $self->get_triggers($dbh, $quoter, $db, $tbl);
2081  ***      0      0      0                    0         if ( $trgs && @$trgs ) {
2082  ***      0                                  0            my $result = $before . "\nDELIMITER ;;\n";
2083  ***      0                                  0            foreach my $trg ( @$trgs ) {
2084  ***      0      0                           0               if ( $trg->{sql_mode} ) {
2085  ***      0                                  0                  $result .= qq{/*!50003 SET SESSION SQL_MODE='$trg->{sql_mode}' */;;\n};
2086                                                              }
2087  ***      0                                  0               $result .= "/*!50003 CREATE */ ";
2088  ***      0      0                           0               if ( $trg->{definer} ) {
2089  ***      0                                  0                  my ( $user, $host )
2090  ***      0                                  0                     = map { s/'/''/g; "'$_'"; }
      ***      0                                  0   
2091                                                                      split('@', $trg->{definer}, 2);
2092  ***      0                                  0                  $result .= "/*!50017 DEFINER=$user\@$host */ ";
2093                                                              }
2094  ***      0                                  0               $result .= sprintf("/*!50003 TRIGGER %s %s %s ON %s\nFOR EACH ROW %s */;;\n\n",
2095                                                                 $quoter->quote($trg->{trigger}),
2096  ***      0                                  0                  @{$trg}{qw(timing event)},
2097                                                                 $quoter->quote($trg->{table}),
2098                                                                 $trg->{statement});
2099                                                           }
2100  ***      0                                  0            $result .= "DELIMITER ;\n\n/*!50003 SET SESSION SQL_MODE=\@OLD_SQL_MODE */;\n\n";
2101  ***      0                                  0            return $result;
2102                                                        }
2103                                                        else {
2104  ***      0                                  0            return undef;
2105                                                        }
2106                                                     }
2107                                                     elsif ( $what eq 'view' ) {
2108  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
2109  ***      0                                  0         return '/*!50001 DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
2110                                                           . '/*!50001 DROP VIEW IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
2111                                                           . '/*!50001 ' . $ddl->[1] . "*/;\n";
2112                                                     }
2113                                                     else {
2114  ***      0                                  0         die "You didn't say what to dump.";
2115                                                     }
2116                                                  }
2117                                                  
2118                                                  sub _use_db {
2119          18                   18            97      my ( $self, $dbh, $quoter, $new ) = @_;
2120          18    100                         104      if ( !$new ) {
2121           9                                 22         MKDEBUG && _d('No new DB to use');
2122           9                                 30         return;
2123                                                     }
2124           9                                 32      my $sql = 'SELECT DATABASE()';
2125           9                                 30      MKDEBUG && _d($sql);
2126           9                                 27      my $curr = $dbh->selectrow_array($sql);
2127  ***      9     50     33                 1464      if ( $curr && $new && $curr eq $new ) {
      ***                   33                        
2128  ***      0                                  0         MKDEBUG && _d('Current and new DB are the same');
2129  ***      0                                  0         return $curr;
2130                                                     }
2131           9                                 55      $sql = 'USE ' . $quoter->quote($new);
2132           9                                 22      MKDEBUG && _d($sql);
2133           9                                980      $dbh->do($sql);
2134           9                                 54      return $curr;
2135                                                  }
2136                                                  
2137                                                  sub get_create_table {
2138           9                    9            58      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2139  ***      9     50     33                   72      if ( !$self->{cache} || !$self->{tables}->{$db}->{$tbl} ) {
2140           9                                 40         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
2141                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
2142                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
2143                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
2144           9                                 24         MKDEBUG && _d($sql);
2145           9                                 23         eval { $dbh->do($sql); };
               9                               1690   
2146           9                                 31         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2147           9                                 65         my $curr_db = $self->_use_db($dbh, $quoter, $db);
2148           9                                 46         $sql = "SHOW CREATE TABLE " . $quoter->quote($db, $tbl);
2149           9                                 28         MKDEBUG && _d($sql);
2150           9                                 22         my $href;
2151           9                                 27         eval { $href = $dbh->selectrow_hashref($sql); };
               9                                 23   
2152  ***      9     50                          71         if ( $EVAL_ERROR ) {
2153  ***      0                                  0            warn "Failed to $sql.  The table may be damaged.\nError: $EVAL_ERROR";
2154  ***      0                                  0            return;
2155                                                        }
2156           9                                 44         $self->_use_db($dbh, $quoter, $curr_db);
2157           9                                 32         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
2158                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
2159           9                                 22         MKDEBUG && _d($sql);
2160           9                                914         $dbh->do($sql);
2161           9                                 61         my ($key) = grep { m/create table/i } keys %$href;
              18                                131   
2162  ***      9     50                          47         if ( $key ) {
2163           9                                 24            MKDEBUG && _d('This table is a base table');
2164           9                                103            $self->{tables}->{$db}->{$tbl} = [ 'table', $href->{$key} ];
2165                                                        }
2166                                                        else {
2167  ***      0                                  0            MKDEBUG && _d('This table is a view');
2168  ***      0                                  0            ($key) = grep { m/create view/i } keys %$href;
      ***      0                                  0   
2169  ***      0                                  0            $self->{tables}->{$db}->{$tbl} = [ 'view', $href->{$key} ];
2170                                                        }
2171                                                     }
2172           9                                 59      return $self->{tables}->{$db}->{$tbl};
2173                                                  }
2174                                                  
2175                                                  sub get_columns {
2176  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2177  ***      0                                  0      MKDEBUG && _d('Get columns for', $db, $tbl);
2178  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{columns}->{$db}->{$tbl} ) {
2179  ***      0                                  0         my $curr_db = $self->_use_db($dbh, $quoter, $db);
2180  ***      0                                  0         my $sql = "SHOW COLUMNS FROM " . $quoter->quote($db, $tbl);
2181  ***      0                                  0         MKDEBUG && _d($sql);
2182  ***      0                                  0         my $cols = $dbh->selectall_arrayref($sql, { Slice => {} });
2183  ***      0                                  0         $self->_use_db($dbh, $quoter, $curr_db);
2184  ***      0                                  0         $self->{columns}->{$db}->{$tbl} = [
2185                                                           map {
2186  ***      0                                  0               my %row;
2187  ***      0                                  0               @row{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
2188  ***      0                                  0               \%row;
2189                                                           } @$cols
2190                                                        ];
2191                                                     }
2192  ***      0                                  0      return $self->{columns}->{$db}->{$tbl};
2193                                                  }
2194                                                  
2195                                                  sub get_tmp_table {
2196  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2197  ***      0                                  0      my $result = 'CREATE TABLE ' . $quoter->quote($tbl) . " (\n";
2198  ***      0                                  0      $result .= join(",\n",
2199  ***      0                                  0         map { '  ' . $quoter->quote($_->{field}) . ' ' . $_->{type} }
2200  ***      0                                  0         @{$self->get_columns($dbh, $quoter, $db, $tbl)});
2201  ***      0                                  0      $result .= "\n)";
2202  ***      0                                  0      MKDEBUG && _d($result);
2203  ***      0                                  0      return $result;
2204                                                  }
2205                                                  
2206                                                  sub get_triggers {
2207  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2208  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{triggers}->{$db} ) {
2209  ***      0                                  0         $self->{triggers}->{$db} = {};
2210  ***      0                                  0         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
2211                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
2212                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
2213                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
2214  ***      0                                  0         MKDEBUG && _d($sql);
2215  ***      0                                  0         eval { $dbh->do($sql); };
      ***      0                                  0   
2216  ***      0                                  0         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2217  ***      0                                  0         $sql = "SHOW TRIGGERS FROM " . $quoter->quote($db);
2218  ***      0                                  0         MKDEBUG && _d($sql);
2219  ***      0                                  0         my $sth = $dbh->prepare($sql);
2220  ***      0                                  0         $sth->execute();
2221  ***      0      0                           0         if ( $sth->rows ) {
2222  ***      0                                  0            my $trgs = $sth->fetchall_arrayref({});
2223  ***      0                                  0            foreach my $trg (@$trgs) {
2224  ***      0                                  0               my %trg;
2225  ***      0                                  0               @trg{ map { lc $_ } keys %$trg } = values %$trg;
      ***      0                                  0   
2226  ***      0                                  0               push @{ $self->{triggers}->{$db}->{ $trg{table} } }, \%trg;
      ***      0                                  0   
2227                                                           }
2228                                                        }
2229  ***      0                                  0         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
2230                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
2231  ***      0                                  0         MKDEBUG && _d($sql);
2232  ***      0                                  0         $dbh->do($sql);
2233                                                     }
2234  ***      0      0                           0      if ( $tbl ) {
2235  ***      0                                  0         return $self->{triggers}->{$db}->{$tbl};
2236                                                     }
2237  ***      0                                  0      return values %{$self->{triggers}->{$db}};
      ***      0                                  0   
2238                                                  }
2239                                                  
2240                                                  sub get_databases {
2241  ***      0                    0             0      my ( $self, $dbh, $quoter, $like ) = @_;
2242  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{databases} || $like ) {
      ***                    0                        
2243  ***      0                                  0         my $sql = 'SHOW DATABASES';
2244  ***      0                                  0         my @params;
2245  ***      0      0                           0         if ( $like ) {
2246  ***      0                                  0            $sql .= ' LIKE ?';
2247  ***      0                                  0            push @params, $like;
2248                                                        }
2249  ***      0                                  0         my $sth = $dbh->prepare($sql);
2250  ***      0                                  0         MKDEBUG && _d($sql, @params);
2251  ***      0                                  0         $sth->execute( @params );
2252  ***      0                                  0         my @dbs = map { $_->[0] } @{$sth->fetchall_arrayref()};
      ***      0                                  0   
      ***      0                                  0   
2253  ***      0      0                           0         $self->{databases} = \@dbs unless $like;
2254  ***      0                                  0         return @dbs;
2255                                                     }
2256  ***      0                                  0      return @{$self->{databases}};
      ***      0                                  0   
2257                                                  }
2258                                                  
2259                                                  sub get_table_status {
2260  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
2261  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_status}->{$db} || $like ) {
      ***                    0                        
2262  ***      0                                  0         my $sql = "SHOW TABLE STATUS FROM " . $quoter->quote($db);
2263  ***      0                                  0         my @params;
2264  ***      0      0                           0         if ( $like ) {
2265  ***      0                                  0            $sql .= ' LIKE ?';
2266  ***      0                                  0            push @params, $like;
2267                                                        }
2268  ***      0                                  0         MKDEBUG && _d($sql, @params);
2269  ***      0                                  0         my $sth = $dbh->prepare($sql);
2270  ***      0                                  0         $sth->execute(@params);
2271  ***      0                                  0         my @tables = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
2272  ***      0                                  0         @tables = map {
2273  ***      0                                  0            my %tbl; # Make a copy with lowercased keys
2274  ***      0                                  0            @tbl{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
2275  ***      0             0                    0            $tbl{engine} ||= $tbl{type} || $tbl{comment};
      ***                    0                        
2276  ***      0                                  0            delete $tbl{type};
2277  ***      0                                  0            \%tbl;
2278                                                        } @tables;
2279  ***      0      0                           0         $self->{table_status}->{$db} = \@tables unless $like;
2280  ***      0                                  0         return @tables;
2281                                                     }
2282  ***      0                                  0      return @{$self->{table_status}->{$db}};
      ***      0                                  0   
2283                                                  }
2284                                                  
2285                                                  sub get_table_list {
2286  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
2287  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_list}->{$db} || $like ) {
      ***                    0                        
2288  ***      0                                  0         my $sql = "SHOW /*!50002 FULL*/ TABLES FROM " . $quoter->quote($db);
2289  ***      0                                  0         my @params;
2290  ***      0      0                           0         if ( $like ) {
2291  ***      0                                  0            $sql .= ' LIKE ?';
2292  ***      0                                  0            push @params, $like;
2293                                                        }
2294  ***      0                                  0         MKDEBUG && _d($sql, @params);
2295  ***      0                                  0         my $sth = $dbh->prepare($sql);
2296  ***      0                                  0         $sth->execute(@params);
2297  ***      0                                  0         my @tables = @{$sth->fetchall_arrayref()};
      ***      0                                  0   
2298  ***      0      0      0                    0         @tables = map {
2299  ***      0                                  0            my %tbl = (
2300                                                              name   => $_->[0],
2301                                                              engine => ($_->[1] || '') eq 'VIEW' ? 'VIEW' : '',
2302                                                           );
2303  ***      0                                  0            \%tbl;
2304                                                        } @tables;
2305  ***      0      0                           0         $self->{table_list}->{$db} = \@tables unless $like;
2306  ***      0                                  0         return @tables;
2307                                                     }
2308  ***      0                                  0      return @{$self->{table_list}->{$db}};
      ***      0                                  0   
2309                                                  }
2310                                                  
2311                                                  sub _d {
2312  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2313  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2314  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2315                                                          @_;
2316  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2317                                                  }
2318                                                  
2319                                                  1;
2320                                                  
2321                                                  # ###########################################################################
2322                                                  # End MySQLDump package
2323                                                  # ###########################################################################
2324                                                  
2325                                                  # ###########################################################################
2326                                                  # TableChunker package 5266
2327                                                  # ###########################################################################
2328          24                   24           913   use strict;
              24                               1037   
              24                                146   
2329          24                   24           148   use warnings FATAL => 'all';
              24                                 52   
              24                                131   
2330                                                  
2331                                                  package TableChunker;
2332                                                  
2333          24                   24           145   use English qw(-no_match_vars);
              24                                 56   
              24                                124   
2334          24                   24           154   use POSIX qw(ceil);
              24                                 62   
              24                                170   
2335          24                   24           151   use List::Util qw(min max);
              24                                 61   
              24                                147   
2336          24                   24           149   use Data::Dumper;
              24                                 54   
              24                                132   
2337                                                  $Data::Dumper::Indent    = 1;
2338                                                  $Data::Dumper::Sortkeys  = 1;
2339                                                  $Data::Dumper::Quotekeys = 0;
2340                                                  
2341  ***     24            50     24           150   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              24                                 51   
              24                                329   
2342                                                  
2343                                                  sub new {
2344           9                    9            59      my ( $class, %args ) = @_;
2345           9                                 43      foreach my $arg ( qw(Quoter MySQLDump) ) {
2346  ***     18     50                          94         die "I need a $arg argument" unless $args{$arg};
2347                                                     }
2348           9                                 46      my $self = { %args };
2349           9                                 83      return bless $self, $class;
2350                                                  }
2351                                                  
2352                                                  my $EPOCH      = '1970-01-01';
2353                                                  my %int_types  = map { $_ => 1 }
2354                                                     qw(bigint date datetime int mediumint smallint time timestamp tinyint year);
2355                                                  my %real_types = map { $_ => 1 }
2356                                                     qw(decimal double float);
2357                                                  
2358                                                  sub find_chunk_columns {
2359           9                    9            51      my ( $self, %args ) = @_;
2360           9                                 42      foreach my $arg ( qw(tbl_struct) ) {
2361  ***      9     50                          58         die "I need a $arg argument" unless $args{$arg};
2362                                                     }
2363           9                                 32      my $tbl_struct = $args{tbl_struct};
2364                                                  
2365           9                                 26      my @possible_indexes;
2366           9                                 28      foreach my $index ( values %{ $tbl_struct->{keys} } ) {
               9                                 57   
2367                                                  
2368  ***      8     50                          51         next unless $index->{type} eq 'BTREE';
2369                                                  
2370  ***      8            33                   20         defined $_ && next for @{ $index->{col_prefixes} };
               8                                 26   
               8                                 76   
2371                                                  
2372  ***      8     50                          44         if ( $args{exact} ) {
2373  ***      0      0      0                    0            next unless $index->{is_unique} && @{$index->{cols}} == 1;
      ***      0                                  0   
2374                                                        }
2375                                                  
2376           8                                 35         push @possible_indexes, $index;
2377                                                     }
2378                                                     MKDEBUG && _d('Possible chunk indexes in order:',
2379           9                                 26         join(', ', map { $_->{name} } @possible_indexes));
2380                                                  
2381           9                                 28      my $can_chunk_exact = 0;
2382           9                                 25      my @candidate_cols;
2383           9                                 34      foreach my $index ( @possible_indexes ) { 
2384           8                                 34         my $col = $index->{cols}->[0];
2385                                                  
2386  ***      8     50     33                   65         next unless ( $int_types{$tbl_struct->{type_for}->{$col}}
2387                                                                      || $real_types{$tbl_struct->{type_for}->{$col}} );
2388                                                  
2389           8                                 76         push @candidate_cols, { column => $col, index => $index->{name} };
2390                                                     }
2391                                                  
2392  ***      9     50     50                   59      $can_chunk_exact = 1 if $args{exact} && scalar @candidate_cols;
2393                                                  
2394           9                                 25      if ( MKDEBUG ) {
2395                                                        my $chunk_type = $args{exact} ? 'Exact' : 'Inexact';
2396                                                        _d($chunk_type, 'chunkable:',
2397                                                           join(', ', map { "$_->{column} on $_->{index}" } @candidate_cols));
2398                                                     }
2399                                                  
2400           9                                 23      my @result;
2401           9                                 23      MKDEBUG && _d('Ordering columns by order in tbl, PK first');
2402           9    100                          64      if ( $tbl_struct->{keys}->{PRIMARY} ) {
2403           8                                 45         my $pk_first_col = $tbl_struct->{keys}->{PRIMARY}->{cols}->[0];
2404           8                                 25         @result          = grep { $_->{column} eq $pk_first_col } @candidate_cols;
               8                                 48   
2405           8                                 31         @candidate_cols  = grep { $_->{column} ne $pk_first_col } @candidate_cols;
               8                                 43   
2406                                                     }
2407           9                                 28      my $i = 0;
2408           9                                 30      my %col_pos = map { $_ => $i++ } @{$tbl_struct->{cols}};
               9                                 50   
               9                                 40   
2409           9                                 63      push @result, sort { $col_pos{$a->{column}} <=> $col_pos{$b->{column}} }
      ***      0                                  0   
2410                                                                      @candidate_cols;
2411                                                  
2412           9                                 24      if ( MKDEBUG ) {
2413                                                        _d('Chunkable columns:',
2414                                                           join(', ', map { "$_->{column} on $_->{index}" } @result));
2415                                                        _d('Can chunk exactly:', $can_chunk_exact);
2416                                                     }
2417                                                  
2418           9                                 54      return ($can_chunk_exact, @result);
2419                                                  }
2420                                                  
2421                                                  sub calculate_chunks {
2422  ***      0                    0             0      my ( $self, %args ) = @_;
2423  ***      0                                  0      foreach my $arg ( qw(dbh tbl_struct chunk_col min max rows_in_range
2424                                                                          chunk_size dbh) ) {
2425  ***      0      0                           0         die "I need a $arg argument" unless defined $args{$arg};
2426                                                     }
2427  ***      0                                  0      MKDEBUG && _d('Calculate chunks for', Dumper(\%args));
2428  ***      0                                  0      my $dbh = $args{dbh};
2429                                                  
2430  ***      0                                  0      my @chunks;
2431  ***      0                                  0      my ($range_func, $start_point, $end_point);
2432  ***      0                                  0      my $col_type = $args{tbl_struct}->{type_for}->{$args{chunk_col}};
2433  ***      0                                  0      MKDEBUG && _d('chunk col type:', $col_type);
2434                                                  
2435                                                  
2436  ***      0      0                           0      if ( $col_type =~ m/(?:int|year|float|double|decimal)$/ ) {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
2437  ***      0                                  0         $start_point = $args{min};
2438  ***      0                                  0         $end_point   = $args{max};
2439  ***      0                                  0         $range_func  = 'range_num';
2440                                                     }
2441                                                     elsif ( $col_type eq 'timestamp' ) {
2442  ***      0                                  0         my $sql = "SELECT UNIX_TIMESTAMP('$args{min}'), UNIX_TIMESTAMP('$args{max}')";
2443  ***      0                                  0         MKDEBUG && _d($sql);
2444  ***      0                                  0         ($start_point, $end_point) = $dbh->selectrow_array($sql);
2445  ***      0                                  0         $range_func  = 'range_timestamp';
2446                                                     }
2447                                                     elsif ( $col_type eq 'date' ) {
2448  ***      0                                  0         my $sql = "SELECT TO_DAYS('$args{min}'), TO_DAYS('$args{max}')";
2449  ***      0                                  0         MKDEBUG && _d($sql);
2450  ***      0                                  0         ($start_point, $end_point) = $dbh->selectrow_array($sql);
2451  ***      0                                  0         $range_func  = 'range_date';
2452                                                     }
2453                                                     elsif ( $col_type eq 'time' ) {
2454  ***      0                                  0         my $sql = "SELECT TIME_TO_SEC('$args{min}'), TIME_TO_SEC('$args{max}')";
2455  ***      0                                  0         MKDEBUG && _d($sql);
2456  ***      0                                  0         ($start_point, $end_point) = $dbh->selectrow_array($sql);
2457  ***      0                                  0         $range_func  = 'range_time';
2458                                                     }
2459                                                     elsif ( $col_type eq 'datetime' ) {
2460  ***      0                                  0         $start_point = $self->timestampdiff($dbh, $args{min});
2461  ***      0                                  0         $end_point   = $self->timestampdiff($dbh, $args{max});
2462  ***      0                                  0         $range_func  = 'range_datetime';
2463                                                     }
2464                                                     else {
2465  ***      0                                  0         die "I don't know how to chunk $col_type\n";
2466                                                     }
2467                                                  
2468  ***      0      0                           0      if ( !defined $start_point ) {
2469  ***      0                                  0         MKDEBUG && _d('Start point is undefined');
2470  ***      0                                  0         $start_point = 0;
2471                                                     }
2472  ***      0      0      0                    0      if ( !defined $end_point || $end_point < $start_point ) {
2473  ***      0                                  0         MKDEBUG && _d('End point is undefined or before start point');
2474  ***      0                                  0         $end_point = 0;
2475                                                     }
2476  ***      0                                  0      MKDEBUG && _d('Start and end of chunk range:',$start_point,',', $end_point);
2477                                                  
2478  ***      0                                  0      my $interval = $args{chunk_size}
2479                                                                  * ($end_point - $start_point)
2480                                                                  / $args{rows_in_range};
2481  ***      0      0                           0      if ( $int_types{$col_type} ) {
2482  ***      0                                  0         $interval = ceil($interval);
2483                                                     }
2484  ***      0             0                    0      $interval ||= $args{chunk_size};
2485  ***      0      0                           0      if ( $args{exact} ) {
2486  ***      0                                  0         $interval = $args{chunk_size};
2487                                                     }
2488  ***      0                                  0      MKDEBUG && _d('Chunk interval:', $interval, 'units');
2489                                                  
2490  ***      0                                  0      my $col = $self->{Quoter}->quote($args{chunk_col});
2491  ***      0      0                           0      if ( $start_point < $end_point ) {
2492  ***      0                                  0         my ( $beg, $end );
2493  ***      0                                  0         my $iter = 0;
2494                                                        for ( my $i = $start_point; $i < $end_point; $i += $interval ) {
2495  ***      0                                  0            ( $beg, $end ) = $self->$range_func($dbh, $i, $interval, $end_point);
2496                                                  
2497  ***      0      0                           0            if ( $iter++ == 0 ) {
2498  ***      0                                  0               push @chunks, "$col < " . $self->quote($end);
2499                                                           }
2500                                                           else {
2501  ***      0                                  0               push @chunks, "$col >= " . $self->quote($beg) . " AND $col < " . $self->quote($end);
2502                                                           }
2503  ***      0                                  0         }
2504                                                  
2505  ***      0                                  0         my $nullable = $args{tbl_struct}->{is_nullable}->{$args{chunk_col}};
2506  ***      0                                  0         pop @chunks;
2507  ***      0      0                           0         if ( @chunks ) {
2508  ***      0                                  0            push @chunks, "$col >= " . $self->quote($beg);
2509                                                        }
2510                                                        else {
2511  ***      0      0                           0            push @chunks, $nullable ? "$col IS NOT NULL" : '1=1';
2512                                                        }
2513  ***      0      0                           0         if ( $nullable ) {
2514  ***      0                                  0            push @chunks, "$col IS NULL";
2515                                                        }
2516                                                  
2517                                                     }
2518                                                     else {
2519  ***      0                                  0         MKDEBUG && _d('No chunks; using single chunk 1=1');
2520  ***      0                                  0         push @chunks, '1=1';
2521                                                     }
2522                                                  
2523  ***      0                                  0      return @chunks;
2524                                                  }
2525                                                  
2526                                                  sub get_first_chunkable_column {
2527           9                    9            54      my ( $self, %args ) = @_;
2528           9                                 43      foreach my $arg ( qw(tbl_struct) ) {
2529  ***      9     50                          59         die "I need a $arg argument" unless $args{$arg};
2530                                                     }
2531           9                                 61      my ($exact, @cols) = $self->find_chunk_columns(%args);
2532           9                                 75      return ( $cols[0]->{column}, $cols[0]->{index} );
2533                                                  }
2534                                                  
2535                                                  sub size_to_rows {
2536  ***      0                    0             0      my ( $self, %args ) = @_;
2537  ***      0                                  0      my @required_args = qw(dbh db tbl chunk_size);
2538  ***      0                                  0      foreach my $arg ( @required_args ) {
2539  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
2540                                                     }
2541  ***      0                                  0      my ($dbh, $db, $tbl, $chunk_size) = @args{@required_args};
2542  ***      0                                  0      my $q  = $self->{Quoter};
2543  ***      0                                  0      my $du = $self->{MySQLDump};
2544                                                  
2545  ***      0                                  0      my ($n_rows, $avg_row_length);
2546                                                  
2547  ***      0                                  0      my ( $num, $suffix ) = $chunk_size =~ m/^(\d+)([MGk])?$/;
2548  ***      0      0                           0      if ( $suffix ) { # Convert to bytes.
      ***             0                               
2549  ***      0      0                           0         $chunk_size = $suffix eq 'k' ? $num * 1_024
      ***             0                               
2550                                                                    : $suffix eq 'M' ? $num * 1_024 * 1_024
2551                                                                    :                  $num * 1_024 * 1_024 * 1_024;
2552                                                     }
2553                                                     elsif ( $num ) {
2554  ***      0                                  0         $n_rows = $num;
2555                                                     }
2556                                                     else {
2557  ***      0                                  0         die "Invalid chunk size $chunk_size; must be an integer "
2558                                                           . "with optional suffix kMG";
2559                                                     }
2560                                                  
2561  ***      0      0      0                    0      if ( $suffix || $args{avg_row_length} ) {
2562  ***      0                                  0         my ($status) = $du->get_table_status($dbh, $q, $db, $tbl);
2563  ***      0                                  0         $avg_row_length = $status->{avg_row_length};
2564  ***      0      0                           0         if ( !defined $n_rows ) {
2565  ***      0      0                           0            $n_rows = $avg_row_length ? ceil($chunk_size / $avg_row_length) : undef;
2566                                                        }
2567                                                     }
2568                                                  
2569  ***      0      0                           0      return wantarray ? ($n_rows, $avg_row_length) : $n_rows;
2570                                                  }
2571                                                  
2572                                                  sub get_range_statistics {
2573  ***      0                    0             0      my ( $self, %args ) = @_;
2574  ***      0                                  0      my @required_args = qw(dbh db tbl chunk_col);
2575  ***      0                                  0      foreach my $arg ( @required_args ) {
2576  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
2577                                                     }
2578  ***      0                                  0      my ($dbh, $db, $tbl, $col) = @args{@required_args};
2579  ***      0                                  0      my $where = $args{where};
2580  ***      0                                  0      my $q = $self->{Quoter};
2581  ***      0      0                           0      my $sql = "SELECT MIN(" . $q->quote($col) . "), MAX(" . $q->quote($col)
2582                                                        . ") FROM " . $q->quote($db, $tbl)
2583                                                        . ($where ? " WHERE $where" : '');
2584  ***      0                                  0      MKDEBUG && _d($sql);
2585  ***      0                                  0      my ( $min, $max );
2586  ***      0                                  0      eval {
2587  ***      0                                  0         ( $min, $max ) = $dbh->selectrow_array($sql);
2588                                                     };
2589  ***      0      0                           0      if ( $EVAL_ERROR ) {
2590  ***      0                                  0         chomp $EVAL_ERROR;
2591  ***      0      0                           0         if ( $EVAL_ERROR =~ m/in your SQL syntax/ ) {
2592  ***      0                                  0            die "$EVAL_ERROR (WHERE clause: $where)";
2593                                                        }
2594                                                        else {
2595  ***      0                                  0            die $EVAL_ERROR;
2596                                                        }
2597                                                     }
2598  ***      0      0                           0      $sql = "EXPLAIN SELECT * FROM " . $q->quote($db, $tbl)
2599                                                        . ($where ? " WHERE $where" : '');
2600  ***      0                                  0      MKDEBUG && _d($sql);
2601  ***      0                                  0      my $expl = $dbh->selectrow_hashref($sql);
2602                                                     return (
2603  ***      0                                  0         min           => $min,
2604                                                        max           => $max,
2605                                                        rows_in_range => $expl->{rows},
2606                                                     );
2607                                                  }
2608                                                  
2609                                                  sub quote {
2610  ***      0                    0             0      my ( $self, $val ) = @_;
2611  ***      0      0                           0      return $val =~ m/\d[:-]/ ? qq{"$val"} : $val;
2612                                                  }
2613                                                  
2614                                                  sub inject_chunks {
2615           7                    7            77      my ( $self, %args ) = @_;
2616           7                                 38      foreach my $arg ( qw(database table chunks chunk_num query) ) {
2617  ***     35     50                         154         die "I need a $arg argument" unless defined $args{$arg};
2618                                                     }
2619           7                                 14      MKDEBUG && _d('Injecting chunk', $args{chunk_num});
2620           7                                 24      my $query   = $args{query};
2621           7                                 55      my $comment = sprintf("/*%s.%s:%d/%d*/",
2622                                                        $args{database}, $args{table},
2623           7                                 37         $args{chunk_num} + 1, scalar @{$args{chunks}});
2624           7                                 63      $query =~ s!/\*PROGRESS_COMMENT\*/!$comment!;
2625           7                                 38      my $where = "WHERE (" . $args{chunks}->[$args{chunk_num}] . ')';
2626  ***      7     50     33                   45      if ( $args{where} && grep { $_ } @{$args{where}} ) {
              14                                 67   
               7                                 28   
2627  ***      0                                  0         $where .= " AND ("
2628  ***      0                                  0            . join(" AND ", map { "($_)" } grep { $_ } @{$args{where}} )
      ***      0                                  0   
      ***      0                                  0   
2629                                                           . ")";
2630                                                     }
2631           7                                 46      my $db_tbl     = $self->{Quoter}->quote(@args{qw(database table)});
2632  ***      7            50                   35      my $index_hint = $args{index_hint} || '';
2633                                                  
2634           7                                 16      MKDEBUG && _d('Parameters:',
2635                                                        Dumper({WHERE => $where, DB_TBL => $db_tbl, INDEX_HINT => $index_hint}));
2636           7                                 47      $query =~ s!/\*WHERE\*/! $where!;
2637           7                                 36      $query =~ s!/\*DB_TBL\*/!$db_tbl!;
2638           7                                 38      $query =~ s!/\*INDEX_HINT\*/! $index_hint!;
2639           7                                 44      $query =~ s!/\*CHUNK_NUM\*/! $args{chunk_num} AS chunk_num,!;
2640                                                  
2641           7                                 39      return $query;
2642                                                  }
2643                                                  
2644                                                  sub range_num {
2645  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
2646  ***      0                                  0      my $end = min($max, $start + $interval);
2647                                                  
2648                                                  
2649  ***      0      0                           0      $start = sprintf('%.17f', $start) if $start =~ /e/;
2650  ***      0      0                           0      $end   = sprintf('%.17f', $end)   if $end   =~ /e/;
2651                                                  
2652  ***      0                                  0      $start =~ s/\.(\d{5}).*$/.$1/;
2653  ***      0                                  0      $end   =~ s/\.(\d{5}).*$/.$1/;
2654                                                  
2655  ***      0      0                           0      if ( $end > $start ) {
2656  ***      0                                  0         return ( $start, $end );
2657                                                     }
2658                                                     else {
2659  ***      0                                  0         die "Chunk size is too small: $end !> $start\n";
2660                                                     }
2661                                                  }
2662                                                  
2663                                                  sub range_time {
2664  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
2665  ***      0                                  0      my $sql = "SELECT SEC_TO_TIME($start), SEC_TO_TIME(LEAST($max, $start + $interval))";
2666  ***      0                                  0      MKDEBUG && _d($sql);
2667  ***      0                                  0      return $dbh->selectrow_array($sql);
2668                                                  }
2669                                                  
2670                                                  sub range_date {
2671  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
2672  ***      0                                  0      my $sql = "SELECT FROM_DAYS($start), FROM_DAYS(LEAST($max, $start + $interval))";
2673  ***      0                                  0      MKDEBUG && _d($sql);
2674  ***      0                                  0      return $dbh->selectrow_array($sql);
2675                                                  }
2676                                                  
2677                                                  sub range_datetime {
2678  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
2679  ***      0                                  0      my $sql = "SELECT DATE_ADD('$EPOCH', INTERVAL $start SECOND), "
2680                                                         . "DATE_ADD('$EPOCH', INTERVAL LEAST($max, $start + $interval) SECOND)";
2681  ***      0                                  0      MKDEBUG && _d($sql);
2682  ***      0                                  0      return $dbh->selectrow_array($sql);
2683                                                  }
2684                                                  
2685                                                  sub range_timestamp {
2686  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
2687  ***      0                                  0      my $sql = "SELECT FROM_UNIXTIME($start), FROM_UNIXTIME(LEAST($max, $start + $interval))";
2688  ***      0                                  0      MKDEBUG && _d($sql);
2689  ***      0                                  0      return $dbh->selectrow_array($sql);
2690                                                  }
2691                                                  
2692                                                  sub timestampdiff {
2693  ***      0                    0             0      my ( $self, $dbh, $time ) = @_;
2694  ***      0                                  0      my $sql = "SELECT (COALESCE(TO_DAYS('$time'), 0) * 86400 + TIME_TO_SEC('$time')) "
2695                                                        . "- TO_DAYS('$EPOCH 00:00:00') * 86400";
2696  ***      0                                  0      MKDEBUG && _d($sql);
2697  ***      0                                  0      my ( $diff ) = $dbh->selectrow_array($sql);
2698  ***      0                                  0      $sql = "SELECT DATE_ADD('$EPOCH', INTERVAL $diff SECOND)";
2699  ***      0                                  0      MKDEBUG && _d($sql);
2700  ***      0                                  0      my ( $check ) = $dbh->selectrow_array($sql);
2701  ***      0      0                           0      die <<"   EOF"
2702                                                     Incorrect datetime math: given $time, calculated $diff but checked to $check.
2703                                                     This is probably because you are using a version of MySQL that overflows on
2704                                                     large interval values to DATE_ADD().  If not, please report this as a bug.
2705                                                     EOF
2706                                                        unless $check eq $time;
2707  ***      0                                  0      return $diff;
2708                                                  }
2709                                                  
2710                                                  sub _d {
2711  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2712  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2713  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2714                                                          @_;
2715  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2716                                                  }
2717                                                  
2718                                                  1;
2719                                                  
2720                                                  # ###########################################################################
2721                                                  # End TableChunker package
2722                                                  # ###########################################################################
2723                                                  
2724                                                  # ###########################################################################
2725                                                  # Quoter package 5266
2726                                                  # ###########################################################################
2727          24                   24           201   use strict;
              24                                 64   
              24                                142   
2728          24                   24           148   use warnings FATAL => 'all';
              24                                 59   
              24                                152   
2729                                                  
2730                                                  package Quoter;
2731                                                  
2732          24                   24           146   use English qw(-no_match_vars);
              24                                 56   
              24                                135   
2733                                                  
2734  ***     24            50     24           194   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              24                                 75   
              24                                472   
2735                                                  
2736                                                  sub new {
2737           9                    9            47      my ( $class ) = @_;
2738           9                                 87      bless {}, $class;
2739                                                  }
2740                                                  
2741                                                  sub quote {
2742          61                   61           317      my ( $self, @vals ) = @_;
2743          61                                242      foreach my $val ( @vals ) {
2744          80                                369         $val =~ s/`/``/g;
2745                                                     }
2746          61                                243      return join('.', map { '`' . $_ . '`' } @vals);
              80                               1726   
2747                                                  }
2748                                                  
2749                                                  sub quote_val {
2750  ***      0                    0             0      my ( $self, $val, $is_numeric ) = @_;
2751                                                  
2752  ***      0      0                           0      return 'NULL' unless defined $val;  # undef = NULL
2753  ***      0      0                           0      return "''" if $val eq '';          # blank string = ''
2754                                                  
2755  ***      0      0                           0      if ( !defined $is_numeric ) {
2756  ***      0      0                           0         $is_numeric = $val =~ m/^0|\D/ ? 0 : 1;
2757                                                     }
2758                                                  
2759  ***      0      0                           0      return $val if $is_numeric;
2760                                                  
2761  ***      0                                  0      $val =~ s/(['\\])/\\$1/g;
2762  ***      0                                  0      return "'$val'";
2763                                                  }
2764                                                  
2765                                                  sub split_unquote {
2766           9                    9            47      my ( $self, $db_tbl, $default_db ) = @_;
2767           9                                 59      $db_tbl =~ s/`//g;
2768           9                                 63      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
2769  ***      9     50                          49      if ( !$tbl ) {
2770           9                                 26         $tbl = $db;
2771           9                                 28         $db  = $default_db;
2772                                                     }
2773           9                                 46      return ($db, $tbl);
2774                                                  }
2775                                                  
2776                                                  sub literal_like {
2777  ***      0                    0             0      my ( $self, $like ) = @_;
2778  ***      0      0                           0      return unless $like;
2779  ***      0                                  0      $like =~ s/([%_])/\\$1/g;
2780  ***      0                                  0      return "'$like'";
2781                                                  }
2782                                                  
2783                                                  1;
2784                                                  
2785                                                  # ###########################################################################
2786                                                  # End Quoter package
2787                                                  # ###########################################################################
2788                                                  
2789                                                  # ###########################################################################
2790                                                  # MasterSlave package 5362
2791                                                  # ###########################################################################
2792          24                   24           171   use strict;
              24                                 65   
              24                                299   
2793          24                   24           150   use warnings FATAL => 'all';
              24                                 54   
              24                                119   
2794                                                  
2795                                                  package MasterSlave;
2796                                                  
2797          24                   24           139   use English qw(-no_match_vars);
              24                                 64   
              24                                118   
2798          24                   24           165   use List::Util qw(min max);
              24                                 58   
              24                                125   
2799          24                   24           150   use Data::Dumper;
              24                                 75   
              24                                194   
2800                                                  $Data::Dumper::Quotekeys = 0;
2801                                                  $Data::Dumper::Indent    = 0;
2802                                                  
2803  ***     24            50     24           153   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              24                                 67   
              24                                318   
2804                                                  
2805                                                  sub new {
2806           9                    9            79      bless {}, shift;
2807                                                  }
2808                                                  
2809                                                  sub recurse_to_slaves {
2810  ***      0                    0             0      my ( $self, $args, $level ) = @_;
2811  ***      0             0                    0      $level ||= 0;
2812  ***      0                                  0      my $dp   = $args->{dsn_parser};
2813  ***      0                                  0      my $dsn  = $args->{dsn};
2814                                                  
2815  ***      0                                  0      my $dbh;
2816  ***      0                                  0      eval {
2817  ***      0             0                    0         $dbh = $args->{dbh} || $dp->get_dbh(
2818                                                           $dp->get_cxn_params($dsn), { AutoCommit => 1 });
2819  ***      0                                  0         MKDEBUG && _d('Connected to', $dp->as_string($dsn));
2820                                                     };
2821  ***      0      0                           0      if ( $EVAL_ERROR ) {
2822  ***      0      0                           0         print STDERR "Cannot connect to ", $dp->as_string($dsn), "\n"
2823                                                           or die "Cannot print: $OS_ERROR";
2824  ***      0                                  0         return;
2825                                                     }
2826                                                  
2827  ***      0                                  0      my $sql  = 'SELECT @@SERVER_ID';
2828  ***      0                                  0      MKDEBUG && _d($sql);
2829  ***      0                                  0      my ($id) = $dbh->selectrow_array($sql);
2830  ***      0                                  0      MKDEBUG && _d('Working on server ID', $id);
2831  ***      0                                  0      my $master_thinks_i_am = $dsn->{server_id};
2832  ***      0      0      0                    0      if ( !defined $id
      ***                    0                        
      ***                    0                        
2833                                                         || ( defined $master_thinks_i_am && $master_thinks_i_am != $id )
2834                                                         || $args->{server_ids_seen}->{$id}++
2835                                                     ) {
2836  ***      0                                  0         MKDEBUG && _d('Server ID seen, or not what master said');
2837  ***      0      0                           0         if ( $args->{skip_callback} ) {
2838  ***      0                                  0            $args->{skip_callback}->($dsn, $dbh, $level, $args->{parent});
2839                                                        }
2840  ***      0                                  0         return;
2841                                                     }
2842                                                  
2843  ***      0                                  0      $args->{callback}->($dsn, $dbh, $level, $args->{parent});
2844                                                  
2845  ***      0      0      0                    0      if ( !defined $args->{recurse} || $level < $args->{recurse} ) {
2846                                                  
2847  ***      0      0                           0         my @slaves =
2848  ***      0                                  0            grep { !$_->{master_id} || $_->{master_id} == $id } # Only my slaves.
2849                                                           $self->find_slave_hosts($dp, $dbh, $dsn, $args->{method});
2850                                                  
2851  ***      0                                  0         foreach my $slave ( @slaves ) {
2852  ***      0                                  0            MKDEBUG && _d('Recursing from',
2853                                                              $dp->as_string($dsn), 'to', $dp->as_string($slave));
2854  ***      0                                  0            $self->recurse_to_slaves(
2855                                                              { %$args, dsn => $slave, dbh => undef, parent => $dsn }, $level + 1 );
2856                                                        }
2857                                                     }
2858                                                  }
2859                                                  
2860                                                  sub find_slave_hosts {
2861  ***      0                    0             0      my ( $self, $dsn_parser, $dbh, $dsn, $method ) = @_;
2862                                                  
2863  ***      0                                  0      my @methods = qw(processlist hosts);
2864  ***      0      0                           0      if ( $method ) {
2865  ***      0                                  0         @methods = grep { $_ ne $method } @methods;
      ***      0                                  0   
2866  ***      0                                  0         unshift @methods, $method;
2867                                                     }
2868                                                     else {
2869  ***      0      0      0                    0         if ( ($dsn->{P} || 3306) != 3306 ) {
2870  ***      0                                  0            MKDEBUG && _d('Port number is non-standard; using only hosts method');
2871  ***      0                                  0            @methods = qw(hosts);
2872                                                        }
2873                                                     }
2874  ***      0                                  0      MKDEBUG && _d('Looking for slaves on', $dsn_parser->as_string($dsn),
2875                                                        'using methods', @methods);
2876                                                  
2877  ***      0                                  0      my @slaves;
2878                                                     METHOD:
2879  ***      0                                  0      foreach my $method ( @methods ) {
2880  ***      0                                  0         my $find_slaves = "_find_slaves_by_$method";
2881  ***      0                                  0         MKDEBUG && _d('Finding slaves with', $find_slaves);
2882  ***      0                                  0         @slaves = $self->$find_slaves($dsn_parser, $dbh, $dsn);
2883  ***      0      0                           0         last METHOD if @slaves;
2884                                                     }
2885                                                  
2886  ***      0                                  0      MKDEBUG && _d('Found', scalar(@slaves), 'slaves');
2887  ***      0                                  0      return @slaves;
2888                                                  }
2889                                                  
2890                                                  sub _find_slaves_by_processlist {
2891  ***      0                    0             0      my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
2892                                                  
2893  ***      0                                  0      my @slaves = map  {
2894  ***      0                                  0         my $slave        = $dsn_parser->parse("h=$_", $dsn);
2895  ***      0                                  0         $slave->{source} = 'processlist';
2896  ***      0                                  0         $slave;
2897                                                     }
2898  ***      0                                  0      grep { $_ }
2899                                                     map  {
2900  ***      0                                  0         my ( $host ) = $_->{host} =~ m/^([^:]+):/;
2901  ***      0      0                           0         if ( $host eq 'localhost' ) {
2902  ***      0                                  0            $host = '127.0.0.1'; # Replication never uses sockets.
2903                                                        }
2904  ***      0                                  0         $host;
2905                                                     } $self->get_connected_slaves($dbh);
2906                                                  
2907  ***      0                                  0      return @slaves;
2908                                                  }
2909                                                  
2910                                                  sub _find_slaves_by_hosts {
2911  ***      0                    0             0      my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
2912                                                  
2913  ***      0                                  0      my @slaves;
2914  ***      0                                  0      my $sql = 'SHOW SLAVE HOSTS';
2915  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
2916  ***      0                                  0      @slaves = @{$dbh->selectall_arrayref($sql, { Slice => {} })};
      ***      0                                  0   
2917                                                  
2918  ***      0      0                           0      if ( @slaves ) {
2919  ***      0                                  0         MKDEBUG && _d('Found some SHOW SLAVE HOSTS info');
2920  ***      0                                  0         @slaves = map {
2921  ***      0                                  0            my %hash;
2922  ***      0                                  0            @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
2923  ***      0      0                           0            my $spec = "h=$hash{host},P=$hash{port}"
      ***             0                               
2924                                                              . ( $hash{user} ? ",u=$hash{user}" : '')
2925                                                              . ( $hash{password} ? ",p=$hash{password}" : '');
2926  ***      0                                  0            my $dsn           = $dsn_parser->parse($spec, $dsn);
2927  ***      0                                  0            $dsn->{server_id} = $hash{server_id};
2928  ***      0                                  0            $dsn->{master_id} = $hash{master_id};
2929  ***      0                                  0            $dsn->{source}    = 'hosts';
2930  ***      0                                  0            $dsn;
2931                                                        } @slaves;
2932                                                     }
2933                                                  
2934  ***      0                                  0      return @slaves;
2935                                                  }
2936                                                  
2937                                                  sub get_connected_slaves {
2938  ***      0                    0             0      my ( $self, $dbh ) = @_;
2939                                                  
2940  ***      0                                  0      my $proc =
2941  ***      0                                  0         grep { m/ALL PRIVILEGES.*?\*\.\*|PROCESS/ }
2942  ***      0                                  0         @{$dbh->selectcol_arrayref('SHOW GRANTS')};
2943  ***      0      0                           0      if ( !$proc ) {
2944  ***      0                                  0         die "You do not have the PROCESS privilege";
2945                                                     }
2946                                                  
2947  ***      0                                  0      my $sql = 'SHOW PROCESSLIST';
2948  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
2949  ***      0                                  0      grep { $_->{command} =~ m/Binlog Dump/i }
      ***      0                                  0   
2950                                                     map  { # Lowercase the column names
2951  ***      0                                  0         my %hash;
2952  ***      0                                  0         @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
2953  ***      0                                  0         \%hash;
2954                                                     }
2955  ***      0                                  0      @{$dbh->selectall_arrayref($sql, { Slice => {} })};
2956                                                  }
2957                                                  
2958                                                  sub is_master_of {
2959  ***      0                    0             0      my ( $self, $master, $slave ) = @_;
2960  ***      0      0                           0      my $master_status = $self->get_master_status($master)
2961                                                        or die "The server specified as a master is not a master";
2962  ***      0      0                           0      my $slave_status  = $self->get_slave_status($slave)
2963                                                        or die "The server specified as a slave is not a slave";
2964  ***      0      0                           0      my @connected     = $self->get_connected_slaves($master)
2965                                                        or die "The server specified as a master has no connected slaves";
2966  ***      0                                  0      my (undef, $port) = $master->selectrow_array('SHOW VARIABLES LIKE "port"');
2967                                                  
2968  ***      0      0                           0      if ( $port != $slave_status->{master_port} ) {
2969  ***      0                                  0         die "The slave is connected to $slave_status->{master_port} "
2970                                                           . "but the master's port is $port";
2971                                                     }
2972                                                  
2973  ***      0      0                           0      if ( !grep { $slave_status->{master_user} eq $_->{user} } @connected ) {
      ***      0                                  0   
2974  ***      0                                  0         die "I don't see any slave I/O thread connected with user "
2975                                                           . $slave_status->{master_user};
2976                                                     }
2977                                                  
2978  ***      0      0      0                    0      if ( ($slave_status->{slave_io_state} || '')
2979                                                        eq 'Waiting for master to send event' )
2980                                                     {
2981  ***      0                                  0         my ( $master_log_name, $master_log_num )
2982                                                           = $master_status->{file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
2983  ***      0                                  0         my ( $slave_log_name, $slave_log_num )
2984                                                           = $slave_status->{master_log_file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
2985  ***      0      0      0                    0         if ( $master_log_name ne $slave_log_name
2986                                                           || abs($master_log_num - $slave_log_num) > 1 )
2987                                                        {
2988  ***      0                                  0            die "The slave thinks it is reading from "
2989                                                              . "$slave_status->{master_log_file},  but the "
2990                                                              . "master is writing to $master_status->{file}";
2991                                                        }
2992                                                     }
2993  ***      0                                  0      return 1;
2994                                                  }
2995                                                  
2996                                                  sub get_master_dsn {
2997  ***      0                    0             0      my ( $self, $dbh, $dsn, $dsn_parser ) = @_;
2998  ***      0      0                           0      my $master = $self->get_slave_status($dbh) or return undef;
2999  ***      0                                  0      my $spec   = "h=$master->{master_host},P=$master->{master_port}";
3000  ***      0                                  0      return       $dsn_parser->parse($spec, $dsn);
3001                                                  }
3002                                                  
3003                                                  sub get_slave_status {
3004  ***      0                    0             0      my ( $self, $dbh ) = @_;
3005  ***      0      0                           0      if ( !$self->{not_a_slave}->{$dbh} ) {
3006  ***      0             0                    0         my $sth = $self->{sths}->{$dbh}->{SLAVE_STATUS}
3007                                                              ||= $dbh->prepare('SHOW SLAVE STATUS');
3008  ***      0                                  0         MKDEBUG && _d($dbh, 'SHOW SLAVE STATUS');
3009  ***      0                                  0         $sth->execute();
3010  ***      0                                  0         my ($ss) = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
3011                                                  
3012  ***      0      0      0                    0         if ( $ss && %$ss ) {
3013  ***      0                                  0            $ss = { map { lc($_) => $ss->{$_} } keys %$ss }; # lowercase the keys
      ***      0                                  0   
3014  ***      0                                  0            return $ss;
3015                                                        }
3016                                                  
3017  ***      0                                  0         MKDEBUG && _d('This server returns nothing for SHOW SLAVE STATUS');
3018  ***      0                                  0         $self->{not_a_slave}->{$dbh}++;
3019                                                     }
3020                                                  }
3021                                                  
3022                                                  sub get_master_status {
3023  ***      0                    0             0      my ( $self, $dbh ) = @_;
3024  ***      0      0                           0      if ( !$self->{not_a_master}->{$dbh} ) {
3025  ***      0             0                    0         my $sth = $self->{sths}->{$dbh}->{MASTER_STATUS}
3026                                                              ||= $dbh->prepare('SHOW MASTER STATUS');
3027  ***      0                                  0         MKDEBUG && _d($dbh, 'SHOW MASTER STATUS');
3028  ***      0                                  0         $sth->execute();
3029  ***      0                                  0         my ($ms) = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
3030                                                  
3031  ***      0      0      0                    0         if ( $ms && %$ms ) {
3032  ***      0                                  0            $ms = { map { lc($_) => $ms->{$_} } keys %$ms }; # lowercase the keys
      ***      0                                  0   
3033  ***      0      0      0                    0            if ( $ms->{file} && $ms->{position} ) {
3034  ***      0                                  0               return $ms;
3035                                                           }
3036                                                        }
3037                                                  
3038  ***      0                                  0         MKDEBUG && _d('This server returns nothing for SHOW MASTER STATUS');
3039  ***      0                                  0         $self->{not_a_master}->{$dbh}++;
3040                                                     }
3041                                                  }
3042                                                  
3043                                                  sub wait_for_master {
3044  ***      0                    0             0      my ( $self, $master, $slave, $time, $timeoutok, $ms ) = @_;
3045  ***      0                                  0      my $result;
3046  ***      0      0                           0      $time = 60 unless defined $time;
3047  ***      0                                  0      MKDEBUG && _d('Waiting for slave to catch up to master timeout ok:',
3048                                                        $timeoutok);
3049  ***      0             0                    0      $ms ||= $self->get_master_status($master);
3050  ***      0      0                           0      if ( $ms ) {
3051  ***      0                                  0         my $query = "SELECT MASTER_POS_WAIT('$ms->{file}', $ms->{position}, $time)";
3052  ***      0                                  0         MKDEBUG && _d($slave, $query);
3053  ***      0                                  0         ($result) = $slave->selectrow_array($query);
3054  ***      0      0                           0         my $stat = defined $result ? $result : 'NULL';
3055  ***      0                                  0         MKDEBUG && _d('Result of waiting:', $stat);
3056  ***      0      0      0                    0         if ( $stat eq 'NULL' || $stat < 0 && !$timeoutok ) {
      ***                    0                        
3057  ***      0                                  0            die "MASTER_POS_WAIT returned $stat";
3058                                                        }
3059                                                     }
3060                                                     else {
3061  ***      0                                  0         MKDEBUG && _d('Not waiting: this server is not a master');
3062                                                     }
3063  ***      0                                  0      return $result;
3064                                                  }
3065                                                  
3066                                                  sub stop_slave {
3067  ***      0                    0             0      my ( $self, $dbh ) = @_;
3068  ***      0             0                    0      my $sth = $self->{sths}->{$dbh}->{STOP_SLAVE}
3069                                                           ||= $dbh->prepare('STOP SLAVE');
3070  ***      0                                  0      MKDEBUG && _d($dbh, $sth->{Statement});
3071  ***      0                                  0      $sth->execute();
3072                                                  }
3073                                                  
3074                                                  sub start_slave {
3075  ***      0                    0             0      my ( $self, $dbh, $pos ) = @_;
3076  ***      0      0                           0      if ( $pos ) {
3077  ***      0                                  0         my $sql = "START SLAVE UNTIL MASTER_LOG_FILE='$pos->{file}', "
3078                                                                . "MASTER_LOG_POS=$pos->{position}";
3079  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
3080  ***      0                                  0         $dbh->do($sql);
3081                                                     }
3082                                                     else {
3083  ***      0             0                    0         my $sth = $self->{sths}->{$dbh}->{START_SLAVE}
3084                                                              ||= $dbh->prepare('START SLAVE');
3085  ***      0                                  0         MKDEBUG && _d($dbh, $sth->{Statement});
3086  ***      0                                  0         $sth->execute();
3087                                                     }
3088                                                  }
3089                                                  
3090                                                  sub catchup_to_master {
3091  ***      0                    0             0      my ( $self, $slave, $master, $time ) = @_;
3092  ***      0                                  0      $self->stop_slave($master);
3093  ***      0                                  0      $self->stop_slave($slave);
3094  ***      0                                  0      my $slave_status  = $self->get_slave_status($slave);
3095  ***      0                                  0      my $slave_pos     = $self->repl_posn($slave_status);
3096  ***      0                                  0      my $master_status = $self->get_master_status($master);
3097  ***      0                                  0      my $master_pos    = $self->repl_posn($master_status);
3098  ***      0                                  0      MKDEBUG && _d('Master position:', $self->pos_to_string($master_pos),
3099                                                        'Slave position:', $self->pos_to_string($slave_pos));
3100  ***      0      0                           0      if ( $self->pos_cmp($slave_pos, $master_pos) < 0 ) {
3101  ***      0                                  0         MKDEBUG && _d('Waiting for slave to catch up to master');
3102  ***      0                                  0         $self->start_slave($slave, $master_pos);
3103  ***      0                                  0         eval {
3104  ***      0                                  0            $self->wait_for_master($master, $slave, $time, 0, $master_status);
3105                                                        };
3106  ***      0      0                           0         if ( $EVAL_ERROR ) {
3107  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
3108  ***      0      0                           0            if ( $EVAL_ERROR =~ m/MASTER_POS_WAIT returned NULL/ ) {
3109  ***      0                                  0               $slave_status = $self->get_slave_status($slave);
3110  ***      0      0                           0               if ( !$self->slave_is_running($slave_status) ) {
3111  ***      0                                  0                  MKDEBUG && _d('Master position:',
3112                                                                    $self->pos_to_string($master_pos),
3113                                                                    'Slave position:', $self->pos_to_string($slave_pos));
3114  ***      0                                  0                  $slave_pos = $self->repl_posn($slave_status);
3115  ***      0      0                           0                  if ( $self->pos_cmp($slave_pos, $master_pos) != 0 ) {
3116  ***      0                                  0                     die "$EVAL_ERROR but slave has not caught up to master";
3117                                                                 }
3118  ***      0                                  0                  MKDEBUG && _d('Slave is caught up to master and stopped');
3119                                                              }
3120                                                              else {
3121  ***      0                                  0                  die "$EVAL_ERROR but slave was still running";
3122                                                              }
3123                                                           }
3124                                                           else {
3125  ***      0                                  0               die $EVAL_ERROR;
3126                                                           }
3127                                                        }
3128                                                     }
3129                                                  }
3130                                                  
3131                                                  sub catchup_to_same_pos {
3132  ***      0                    0             0      my ( $self, $s1_dbh, $s2_dbh ) = @_;
3133  ***      0                                  0      $self->stop_slave($s1_dbh);
3134  ***      0                                  0      $self->stop_slave($s2_dbh);
3135  ***      0                                  0      my $s1_status = $self->get_slave_status($s1_dbh);
3136  ***      0                                  0      my $s2_status = $self->get_slave_status($s2_dbh);
3137  ***      0                                  0      my $s1_pos    = $self->repl_posn($s1_status);
3138  ***      0                                  0      my $s2_pos    = $self->repl_posn($s2_status);
3139  ***      0      0                           0      if ( $self->pos_cmp($s1_pos, $s2_pos) < 0 ) {
      ***             0                               
3140  ***      0                                  0         $self->start_slave($s1_dbh, $s2_pos);
3141                                                     }
3142                                                     elsif ( $self->pos_cmp($s2_pos, $s1_pos) < 0 ) {
3143  ***      0                                  0         $self->start_slave($s2_dbh, $s1_pos);
3144                                                     }
3145                                                  
3146  ***      0                                  0      $s1_status = $self->get_slave_status($s1_dbh);
3147  ***      0                                  0      $s2_status = $self->get_slave_status($s2_dbh);
3148  ***      0                                  0      $s1_pos    = $self->repl_posn($s1_status);
3149  ***      0                                  0      $s2_pos    = $self->repl_posn($s2_status);
3150                                                  
3151  ***      0      0      0                    0      if ( $self->slave_is_running($s1_status)
      ***                    0                        
3152                                                       || $self->slave_is_running($s2_status)
3153                                                       || $self->pos_cmp($s1_pos, $s2_pos) != 0)
3154                                                     {
3155  ***      0                                  0         die "The servers aren't both stopped at the same position";
3156                                                     }
3157                                                  
3158                                                  }
3159                                                  
3160                                                  sub change_master_to {
3161  ***      0                    0             0      my ( $self, $dbh, $master_dsn, $master_pos ) = @_;
3162  ***      0                                  0      $self->stop_slave($dbh);
3163  ***      0                                  0      MKDEBUG && _d(Dumper($master_dsn), Dumper($master_pos));
3164  ***      0                                  0      my $sql = "CHANGE MASTER TO MASTER_HOST='$master_dsn->{h}', "
3165                                                        . "MASTER_PORT= $master_dsn->{P}, MASTER_LOG_FILE='$master_pos->{file}', "
3166                                                        . "MASTER_LOG_POS=$master_pos->{position}";
3167  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
3168  ***      0                                  0      $dbh->do($sql);
3169                                                  }
3170                                                  
3171                                                  sub make_sibling_of_master {
3172  ***      0                    0             0      my ( $self, $slave_dbh, $slave_dsn, $dsn_parser, $timeout) = @_;
3173                                                  
3174  ***      0      0                           0      my $master_dsn  = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3175                                                        or die "This server is not a slave";
3176  ***      0                                  0      my $master_dbh  = $dsn_parser->get_dbh(
3177                                                        $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
3178  ***      0      0                           0      my $gmaster_dsn
3179                                                        = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
3180                                                        or die "This server's master is not a slave";
3181  ***      0                                  0      my $gmaster_dbh = $dsn_parser->get_dbh(
3182                                                        $dsn_parser->get_cxn_params($gmaster_dsn), { AutoCommit => 1 });
3183  ***      0      0                           0      if ( $self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn) ) {
3184  ***      0                                  0         die "The slave's master's master is the slave: master-master replication";
3185                                                     }
3186                                                  
3187  ***      0                                  0      $self->stop_slave($master_dbh);
3188  ***      0                                  0      $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
3189  ***      0                                  0      $self->stop_slave($slave_dbh);
3190                                                  
3191  ***      0                                  0      my $master_status = $self->get_master_status($master_dbh);
3192  ***      0                                  0      my $mslave_status = $self->get_slave_status($master_dbh);
3193  ***      0                                  0      my $slave_status  = $self->get_slave_status($slave_dbh);
3194  ***      0                                  0      my $master_pos    = $self->repl_posn($master_status);
3195  ***      0                                  0      my $slave_pos     = $self->repl_posn($slave_status);
3196                                                  
3197  ***      0      0      0                    0      if ( !$self->slave_is_running($mslave_status)
      ***                    0                        
3198                                                       && !$self->slave_is_running($slave_status)
3199                                                       && $self->pos_cmp($master_pos, $slave_pos) == 0)
3200                                                     {
3201  ***      0                                  0         $self->change_master_to($slave_dbh, $gmaster_dsn,
3202                                                           $self->repl_posn($mslave_status)); # Note it's not $master_pos!
3203                                                     }
3204                                                     else {
3205  ***      0                                  0         die "The servers aren't both stopped at the same position";
3206                                                     }
3207                                                  
3208  ***      0                                  0      $mslave_status = $self->get_slave_status($master_dbh);
3209  ***      0                                  0      $slave_status  = $self->get_slave_status($slave_dbh);
3210  ***      0                                  0      my $mslave_pos = $self->repl_posn($mslave_status);
3211  ***      0                                  0      $slave_pos     = $self->repl_posn($slave_status);
3212  ***      0      0      0                    0      if ( $self->short_host($mslave_status) ne $self->short_host($slave_status)
3213                                                       || $self->pos_cmp($mslave_pos, $slave_pos) != 0)
3214                                                     {
3215  ***      0                                  0         die "The servers don't have the same master/position after the change";
3216                                                     }
3217                                                  }
3218                                                  
3219                                                  sub make_slave_of_sibling {
3220  ***      0                    0             0      my ( $self, $slave_dbh, $slave_dsn, $sib_dbh, $sib_dsn,
3221                                                          $dsn_parser, $timeout) = @_;
3222                                                  
3223  ***      0      0                           0      if ( $self->short_host($slave_dsn) eq $self->short_host($sib_dsn) ) {
3224  ***      0                                  0         die "You are trying to make the slave a slave of itself";
3225                                                     }
3226                                                  
3227  ***      0      0                           0      my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3228                                                        or die "This server is not a slave";
3229  ***      0                                  0      my $master_dbh1 = $dsn_parser->get_dbh(
3230                                                        $dsn_parser->get_cxn_params($master_dsn1), { AutoCommit => 1 });
3231  ***      0      0                           0      my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3232                                                        or die "The sibling is not a slave";
3233  ***      0      0                           0      if ( $self->short_host($master_dsn1) ne $self->short_host($master_dsn2) ) {
3234  ***      0                                  0         die "This server isn't a sibling of the slave";
3235                                                     }
3236  ***      0      0                           0      my $sib_master_stat = $self->get_master_status($sib_dbh)
3237                                                        or die "Binary logging is not enabled on the sibling";
3238  ***      0      0                           0      die "The log_slave_updates option is not enabled on the sibling"
3239                                                        unless $self->has_slave_updates($sib_dbh);
3240                                                  
3241  ***      0                                  0      $self->catchup_to_same_pos($slave_dbh, $sib_dbh);
3242                                                  
3243  ***      0                                  0      $sib_master_stat = $self->get_master_status($sib_dbh);
3244  ***      0                                  0      $self->change_master_to($slave_dbh, $sib_dsn,
3245                                                           $self->repl_posn($sib_master_stat));
3246                                                  
3247  ***      0                                  0      my $slave_status = $self->get_slave_status($slave_dbh);
3248  ***      0                                  0      my $slave_pos    = $self->repl_posn($slave_status);
3249  ***      0                                  0      $sib_master_stat = $self->get_master_status($sib_dbh);
3250  ***      0      0      0                    0      if ( $self->short_host($slave_status) ne $self->short_host($sib_dsn)
3251                                                       || $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
3252                                                     {
3253  ***      0                                  0         die "After changing the slave's master, it isn't a slave of the sibling, "
3254                                                           . "or it has a different replication position than the sibling";
3255                                                     }
3256                                                  }
3257                                                  
3258                                                  sub make_slave_of_uncle {
3259  ***      0                    0             0      my ( $self, $slave_dbh, $slave_dsn, $unc_dbh, $unc_dsn,
3260                                                          $dsn_parser, $timeout) = @_;
3261                                                  
3262  ***      0      0                           0      if ( $self->short_host($slave_dsn) eq $self->short_host($unc_dsn) ) {
3263  ***      0                                  0         die "You are trying to make the slave a slave of itself";
3264                                                     }
3265                                                  
3266  ***      0      0                           0      my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3267                                                        or die "This server is not a slave";
3268  ***      0                                  0      my $master_dbh = $dsn_parser->get_dbh(
3269                                                        $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
3270  ***      0      0                           0      my $gmaster_dsn
3271                                                        = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
3272                                                        or die "The master is not a slave";
3273  ***      0      0                           0      my $unc_master_dsn
3274                                                        = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
3275                                                        or die "The uncle is not a slave";
3276  ***      0      0                           0      if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn)) {
3277  ***      0                                  0         die "The uncle isn't really the slave's uncle";
3278                                                     }
3279                                                  
3280  ***      0      0                           0      my $unc_master_stat = $self->get_master_status($unc_dbh)
3281                                                        or die "Binary logging is not enabled on the uncle";
3282  ***      0      0                           0      die "The log_slave_updates option is not enabled on the uncle"
3283                                                        unless $self->has_slave_updates($unc_dbh);
3284                                                  
3285  ***      0                                  0      $self->catchup_to_same_pos($master_dbh, $unc_dbh);
3286  ***      0                                  0      $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
3287                                                  
3288  ***      0                                  0      my $slave_status  = $self->get_slave_status($slave_dbh);
3289  ***      0                                  0      my $master_status = $self->get_master_status($master_dbh);
3290  ***      0      0                           0      if ( $self->pos_cmp(
3291                                                           $self->repl_posn($slave_status),
3292                                                           $self->repl_posn($master_status)) != 0 )
3293                                                     {
3294  ***      0                                  0         die "The slave is not caught up to its master";
3295                                                     }
3296                                                  
3297  ***      0                                  0      $unc_master_stat = $self->get_master_status($unc_dbh);
3298  ***      0                                  0      $self->change_master_to($slave_dbh, $unc_dsn,
3299                                                        $self->repl_posn($unc_master_stat));
3300                                                  
3301                                                  
3302  ***      0                                  0      $slave_status    = $self->get_slave_status($slave_dbh);
3303  ***      0                                  0      my $slave_pos    = $self->repl_posn($slave_status);
3304  ***      0      0      0                    0      if ( $self->short_host($slave_status) ne $self->short_host($unc_dsn)
3305                                                       || $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
3306                                                     {
3307  ***      0                                  0         die "After changing the slave's master, it isn't a slave of the uncle, "
3308                                                           . "or it has a different replication position than the uncle";
3309                                                     }
3310                                                  }
3311                                                  
3312                                                  sub detach_slave {
3313  ***      0                    0             0      my ( $self, $dbh ) = @_;
3314  ***      0                                  0      $self->stop_slave($dbh);
3315  ***      0      0                           0      my $stat = $self->get_slave_status($dbh)
3316                                                        or die "This server is not a slave";
3317  ***      0                                  0      $dbh->do('CHANGE MASTER TO MASTER_HOST=""');
3318  ***      0                                  0      $dbh->do('RESET SLAVE'); # Wipes out master.info, etc etc
3319  ***      0                                  0      return $stat;
3320                                                  }
3321                                                  
3322                                                  sub slave_is_running {
3323  ***      0                    0             0      my ( $self, $slave_status ) = @_;
3324  ***      0             0                    0      return ($slave_status->{slave_sql_running} || 'No') eq 'Yes';
3325                                                  }
3326                                                  
3327                                                  sub has_slave_updates {
3328  ***      0                    0             0      my ( $self, $dbh ) = @_;
3329  ***      0                                  0      my $sql = q{SHOW VARIABLES LIKE 'log_slave_updates'};
3330  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
3331  ***      0                                  0      my ($name, $value) = $dbh->selectrow_array($sql);
3332  ***      0             0                    0      return $value && $value =~ m/^(1|ON)$/;
3333                                                  }
3334                                                  
3335                                                  sub repl_posn {
3336  ***      0                    0             0      my ( $self, $status ) = @_;
3337  ***      0      0      0                    0      if ( exists $status->{file} && exists $status->{position} ) {
3338                                                        return {
3339  ***      0                                  0            file     => $status->{file},
3340                                                           position => $status->{position},
3341                                                        };
3342                                                     }
3343                                                     else {
3344                                                        return {
3345  ***      0                                  0            file     => $status->{relay_master_log_file},
3346                                                           position => $status->{exec_master_log_pos},
3347                                                        };
3348                                                     }
3349                                                  }
3350                                                  
3351                                                  sub get_slave_lag {
3352  ***      0                    0             0      my ( $self, $dbh ) = @_;
3353  ***      0                                  0      my $stat = $self->get_slave_status($dbh);
3354  ***      0                                  0      return $stat->{seconds_behind_master};
3355                                                  }
3356                                                  
3357                                                  sub pos_cmp {
3358  ***      0                    0             0      my ( $self, $a, $b ) = @_;
3359  ***      0                                  0      return $self->pos_to_string($a) cmp $self->pos_to_string($b);
3360                                                  }
3361                                                  
3362                                                  sub short_host {
3363  ***      0                    0             0      my ( $self, $dsn ) = @_;
3364  ***      0                                  0      my ($host, $port);
3365  ***      0      0                           0      if ( $dsn->{master_host} ) {
3366  ***      0                                  0         $host = $dsn->{master_host};
3367  ***      0                                  0         $port = $dsn->{master_port};
3368                                                     }
3369                                                     else {
3370  ***      0                                  0         $host = $dsn->{h};
3371  ***      0                                  0         $port = $dsn->{P};
3372                                                     }
3373  ***      0      0      0                    0      return ($host || '[default]') . ( ($port || 3306) == 3306 ? '' : ":$port" );
      ***                    0                        
3374                                                  }
3375                                                  
3376                                                  sub pos_to_string {
3377  ***      0                    0             0      my ( $self, $pos ) = @_;
3378  ***      0                                  0      my $fmt  = '%s/%020d';
3379  ***      0                                  0      return sprintf($fmt, @{$pos}{qw(file position)});
      ***      0                                  0   
3380                                                  }
3381                                                  
3382                                                  sub _d {
3383  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3384  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3385  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3386                                                          @_;
3387  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3388                                                  }
3389                                                  
3390                                                  1;
3391                                                  
3392                                                  # ###########################################################################
3393                                                  # End MasterSlave package
3394                                                  # ###########################################################################
3395                                                  
3396                                                  # ###########################################################################
3397                                                  # Daemon package 5266
3398                                                  # ###########################################################################
3399                                                  
3400                                                  package Daemon;
3401                                                  
3402          24                   24           229   use strict;
              24                                 73   
              24                                161   
3403          24                   24           164   use warnings FATAL => 'all';
              24                                 62   
              24                                147   
3404                                                  
3405          24                   24           153   use POSIX qw(setsid);
              24                                 57   
              24                                147   
3406          24                   24           234   use English qw(-no_match_vars);
              24                                 61   
              24                                145   
3407                                                  
3408  ***     24            50     24           161   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              24                                 59   
              24                                347   
3409                                                  
3410                                                  sub new {
3411  ***      0                    0             0      my ( $class, %args ) = @_;
3412  ***      0                                  0      foreach my $arg ( qw(o) ) {
3413  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3414                                                     }
3415  ***      0                                  0      my $o = $args{o};
3416  ***      0      0                           0      my $self = {
      ***             0                               
3417                                                        o        => $o,
3418                                                        log_file => $o->has('log') ? $o->get('log') : undef,
3419                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
3420                                                     };
3421                                                  
3422  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
3423                                                  
3424  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
3425  ***      0                                  0      return bless $self, $class;
3426                                                  }
3427                                                  
3428                                                  sub daemonize {
3429  ***      0                    0             0      my ( $self ) = @_;
3430                                                  
3431  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
3432  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
3433  ***      0      0                           0      if ( $pid ) {
3434  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
3435  ***      0                                  0         exit;
3436                                                     }
3437                                                  
3438  ***      0                                  0      $self->{child} = 1;
3439                                                  
3440  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
3441  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
3442                                                  
3443  ***      0                                  0      $self->_make_PID_file();
3444                                                  
3445  ***      0                                  0      $OUTPUT_AUTOFLUSH = 1;
3446                                                  
3447  ***      0      0                           0      if ( -t STDIN ) {
3448  ***      0                                  0         close STDIN;
3449  ***      0      0                           0         open  STDIN, '/dev/null'
3450                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
3451                                                     }
3452                                                  
3453  ***      0      0                           0      if ( $self->{log_file} ) {
3454  ***      0                                  0         close STDOUT;
3455  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
3456                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
3457                                                  
3458  ***      0                                  0         close STDERR;
3459  ***      0      0                           0         open  STDERR, ">&STDOUT"
3460                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
3461                                                     }
3462                                                     else {
3463  ***      0      0                           0         if ( -t STDOUT ) {
3464  ***      0                                  0            close STDOUT;
3465  ***      0      0                           0            open  STDOUT, '>', '/dev/null'
3466                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
3467                                                        }
3468  ***      0      0                           0         if ( -t STDERR ) {
3469  ***      0                                  0            close STDERR;
3470  ***      0      0                           0            open  STDERR, '>', '/dev/null'
3471                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
3472                                                        }
3473                                                     }
3474                                                  
3475  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
3476  ***      0                                  0      return;
3477                                                  }
3478                                                  
3479                                                  sub check_PID_file {
3480  ***      0                    0             0      my ( $self, $file ) = @_;
3481  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
3482  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
3483  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
3484  ***      0                                  0         my $pid;
3485  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
3486  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
3487  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
3488  ***      0      0                           0         if ( $pid ) {
3489  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
3490  ***      0      0                           0            if ( $pid_is_alive ) {
3491  ***      0                                  0               die "The PID file $PID_file already exists "
3492                                                                 . " and the PID that it contains, $pid, is running";
3493                                                           }
3494                                                           else {
3495  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
3496                                                                 . "contains, $pid, is not running";
3497                                                           }
3498                                                        }
3499                                                        else {
3500  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
3501                                                              . "contain a PID";
3502                                                        }
3503                                                     }
3504                                                     else {
3505  ***      0                                  0         MKDEBUG && _d('No PID file');
3506                                                     }
3507  ***      0                                  0      return;
3508                                                  }
3509                                                  
3510                                                  sub make_PID_file {
3511  ***      0                    0             0      my ( $self ) = @_;
3512  ***      0      0                           0      if ( exists $self->{child} ) {
3513  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
3514                                                     }
3515  ***      0                                  0      $self->_make_PID_file();
3516  ***      0                                  0      $self->{rm_PID_file} = 1;
3517  ***      0                                  0      return;
3518                                                  }
3519                                                  
3520                                                  sub _make_PID_file {
3521  ***      0                    0             0      my ( $self ) = @_;
3522                                                  
3523  ***      0                                  0      my $PID_file = $self->{PID_file};
3524  ***      0      0                           0      if ( !$PID_file ) {
3525  ***      0                                  0         MKDEBUG && _d('No PID file to create');
3526  ***      0                                  0         return;
3527                                                     }
3528                                                  
3529  ***      0                                  0      $self->check_PID_file();
3530                                                  
3531  ***      0      0                           0      open my $PID_FH, '>', $PID_file
3532                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
3533  ***      0      0                           0      print $PID_FH $PID
3534                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
3535  ***      0      0                           0      close $PID_FH
3536                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
3537                                                  
3538  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
3539  ***      0                                  0      return;
3540                                                  }
3541                                                  
3542                                                  sub _remove_PID_file {
3543  ***      0                    0             0      my ( $self ) = @_;
3544  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
3545  ***      0      0                           0         unlink $self->{PID_file}
3546                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
3547  ***      0                                  0         MKDEBUG && _d('Removed PID file');
3548                                                     }
3549                                                     else {
3550  ***      0                                  0         MKDEBUG && _d('No PID to remove');
3551                                                     }
3552  ***      0                                  0      return;
3553                                                  }
3554                                                  
3555                                                  sub DESTROY {
3556  ***      0                    0             0      my ( $self ) = @_;
3557  ***      0      0      0                    0      $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
3558  ***      0                                  0      return;
3559                                                  }
3560                                                  
3561                                                  sub _d {
3562  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3563  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3564  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3565                                                          @_;
3566  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3567                                                  }
3568                                                  
3569                                                  1;
3570                                                  
3571                                                  # ###########################################################################
3572                                                  # End Daemon package
3573                                                  # ###########################################################################
3574                                                  
3575                                                  # ###########################################################################
3576                                                  # SchemaIterator package 5473
3577                                                  # ###########################################################################
3578                                                  package SchemaIterator;
3579                                                  
3580          24                   24           176   use strict;
              24                                 62   
              24                                125   
3581          24                   24           148   use warnings FATAL => 'all';
              24                                 58   
              24                                128   
3582                                                  
3583          24                   24           146   use English qw(-no_match_vars);
              24                                 58   
              24                                122   
3584          24                   24           158   use Data::Dumper;
              24                                 70   
              24                                126   
3585                                                  $Data::Dumper::Indent    = 1;
3586                                                  $Data::Dumper::Sortkeys  = 1;
3587                                                  $Data::Dumper::Quotekeys = 0;
3588                                                  
3589  ***     24            50     24           150   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              24                                 62   
              24                                466   
3590                                                  
3591                                                  sub new {
3592           9                    9            61      my ( $class, %args ) = @_;
3593           9                                 41      foreach my $arg ( qw(Quoter) ) {
3594  ***      9     50                          60         die "I need a $arg argument" unless $args{$arg};
3595                                                     }
3596           9                                 71      my $self = {
3597                                                        %args,
3598                                                        filter => undef,
3599                                                        dbs    => [],
3600                                                     };
3601           9                                105      return bless $self, $class;
3602                                                  }
3603                                                  
3604                                                  sub make_filter {
3605           9                    9            44      my ( $self, $o ) = @_;
3606           9                                 53      my @lines = (
3607                                                        'sub {',
3608                                                        '   my ( $dbh, $db, $tbl ) = @_;',
3609                                                        '   my $engine = undef;',
3610                                                     );
3611                                                  
3612                                                  
3613  ***      9     50                          50      my @permit_dbs = _make_filter('unless', '$db', $o->get('databases'))
3614                                                        if $o->has('databases');
3615  ***      9     50                          44      my @reject_dbs = _make_filter('if', '$db', $o->get('ignore-databases'))
3616                                                        if $o->has('ignore-databases');
3617           9                                 26      my @dbs_regex;
3618  ***      9     50     33                   45      if ( $o->has('databases-regex') && (my $p = $o->get('databases-regex')) ) {
3619  ***      0                                  0         push @dbs_regex, "      return 0 unless \$db && (\$db =~ m/$p/o);";
3620                                                     }
3621           9                                 30      my @reject_dbs_regex;
3622  ***      9     50     33                   45      if ( $o->has('ignore-databases-regex')
3623                                                          && (my $p = $o->get('ignore-databases-regex')) ) {
3624  ***      0                                  0         push @reject_dbs_regex, "      return 0 if \$db && (\$db =~ m/$p/o);";
3625                                                     }
3626  ***      9     50     33                   87      if ( @permit_dbs || @reject_dbs || @dbs_regex || @reject_dbs_regex ) {
      ***                   33                        
      ***                   33                        
3627  ***      9     50                          79         push @lines,
      ***            50                               
      ***            50                               
      ***            50                               
3628                                                           '   if ( $db ) {',
3629                                                              (@permit_dbs        ? @permit_dbs       : ()),
3630                                                              (@reject_dbs        ? @reject_dbs       : ()),
3631                                                              (@dbs_regex         ? @dbs_regex        : ()),
3632                                                              (@reject_dbs_regex  ? @reject_dbs_regex : ()),
3633                                                           '   }';
3634                                                     }
3635                                                  
3636  ***      9     50     33                   42      if ( $o->has('tables') || $o->has('ignore-tables')
      ***                   33                        
3637                                                          || $o->has('ignore-tables-regex') ) {
3638                                                  
3639           9                                 30         my $have_qtbl       = 0;
3640           9                                 25         my $have_only_qtbls = 0;
3641           9                                 25         my %qtbls;
3642                                                  
3643           9                                 22         my @permit_tbls;
3644           9                                 25         my @permit_qtbls;
3645           9                                 33         my %permit_qtbls;
3646           9    100                          39         if ( $o->get('tables') ) {
3647           8                                 44            my %tbls;
3648                                                           map {
3649  ***      8     50                          54               if ( $_ =~ m/\./ ) {
               8                                 37   
3650  ***      0                                  0                  $permit_qtbls{$_} = 1;
3651                                                              }
3652                                                              else {
3653           8                                 39                  $tbls{$_} = 1;
3654                                                              }
3655           8                                 25            } keys %{ $o->get('tables') };
3656           8                                 40            @permit_tbls  = _make_filter('unless', '$tbl', \%tbls);
3657           8                                 44            @permit_qtbls = _make_filter('unless', '$qtbl', \%permit_qtbls);
3658                                                  
3659  ***      8     50                          45            if ( @permit_qtbls ) {
3660  ***      0                                  0               push @lines,
3661                                                                 '   my $qtbl   = ($db ? "$db." : "") . ($tbl ? $tbl : "");';
3662  ***      0                                  0               $have_qtbl = 1;
3663                                                           }
3664                                                        }
3665                                                  
3666           9                                 24         my @reject_tbls;
3667           9                                 27         my @reject_qtbls;
3668           9                                 22         my %reject_qtbls;
3669  ***      9     50                          40         if ( $o->get('ignore-tables') ) {
3670  ***      0                                  0            my %tbls;
3671                                                           map {
3672  ***      0      0                           0               if ( $_ =~ m/\./ ) {
      ***      0                                  0   
3673  ***      0                                  0                  $reject_qtbls{$_} = 1;
3674                                                              }
3675                                                              else {
3676  ***      0                                  0                  $tbls{$_} = 1;
3677                                                              }
3678  ***      0                                  0            } keys %{ $o->get('ignore-tables') };
3679  ***      0                                  0            @reject_tbls= _make_filter('if', '$tbl', \%tbls);
3680  ***      0                                  0            @reject_qtbls = _make_filter('if', '$qtbl', \%reject_qtbls);
3681                                                  
3682  ***      0      0      0                    0            if ( @reject_qtbls && !$have_qtbl ) {
3683  ***      0                                  0               push @lines,
3684                                                                 '   my $qtbl   = ($db ? "$db." : "") . ($tbl ? $tbl : "");';
3685                                                           }
3686                                                        }
3687                                                  
3688  ***      9     50     33                   50         if ( keys %permit_qtbls  && !@permit_dbs ) {
3689  ***      0                                  0            my $dbs = {};
3690  ***      0                                  0            map {
3691  ***      0                                  0               my ($db, undef) = split(/\./, $_);
3692  ***      0                                  0               $dbs->{$db} = 1;
3693                                                           } keys %permit_qtbls;
3694  ***      0                                  0            MKDEBUG && _d('Adding restriction "--databases',
3695                                                                 (join(',', keys %$dbs) . '"'));
3696  ***      0      0                           0            if ( keys %$dbs ) {
3697  ***      0                                  0               $o->set('databases', $dbs);
3698  ***      0                                  0               return $self->make_filter($o);
3699                                                           }
3700                                                        }
3701                                                  
3702           9                                 26         my @tbls_regex;
3703  ***      9     50     33                   41         if ( $o->has('tables-regex') && (my $p = $o->get('tables-regex')) ) {
3704  ***      0                                  0            push @tbls_regex, "      return 0 unless \$tbl && (\$tbl =~ m/$p/o);";
3705                                                        }
3706           9                                 26         my @reject_tbls_regex;
3707  ***      9     50     33                   37         if ( $o->has('ignore-tables-regex')
3708                                                             && (my $p = $o->get('ignore-tables-regex')) ) {
3709  ***      0                                  0            push @reject_tbls_regex,
3710                                                              "      return 0 if \$tbl && (\$tbl =~ m/$p/o);";
3711                                                        }
3712                                                  
3713           9                                 28         my @get_eng;
3714           9                                 23         my @permit_engs;
3715           9                                 26         my @reject_engs;
3716  ***      9     50     66                   39         if ( ($o->has('engines') && $o->get('engines'))
      ***                   33                        
      ***                   66                        
3717                                                             || ($o->has('ignore-engines') && $o->get('ignore-engines')) ) {
3718           9                                 69            push @get_eng,
3719                                                              '      my $sql = "SHOW TABLE STATUS "',
3720                                                              '              . ($db ? "FROM `$db`" : "")',
3721                                                              '              . " LIKE \'$tbl\'";',
3722                                                              '      MKDEBUG && _d($sql);',
3723                                                              '      eval {',
3724                                                              '         $engine = $dbh->selectrow_hashref($sql)->{engine};',
3725                                                              '      };',
3726                                                              '      MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);',
3727                                                              '      MKDEBUG && _d($tbl, "uses engine", $engine);',
3728                                                              '      $engine = lc $engine if $engine;',
3729                                                           @permit_engs
3730                                                              = _make_filter('unless', '$engine', $o->get('engines'), 1);
3731                                                           @reject_engs
3732           9                                 49               = _make_filter('if', '$engine', $o->get('ignore-engines'), 1)
3733                                                        }
3734                                                  
3735  ***      9     50     66                  127         if ( @permit_tbls || @reject_tbls || @tbls_regex || @reject_tbls_regex
      ***                   66                        
      ***                   66                        
      ***                   66                        
      ***                   33                        
3736                                                             || @permit_engs || @reject_engs ) {
3737           9    100                         179            push @lines,
      ***            50                               
      ***            50                               
      ***            50                               
      ***            50                               
      ***            50                               
      ***            50                               
                    100                               
      ***            50                               
3738                                                              '   if ( $tbl ) {',
3739                                                                 (@permit_tbls       ? @permit_tbls        : ()),
3740                                                                 (@reject_tbls       ? @reject_tbls        : ()),
3741                                                                 (@tbls_regex        ? @tbls_regex         : ()),
3742                                                                 (@reject_tbls_regex ? @reject_tbls_regex  : ()),
3743                                                                 (@permit_qtbls      ? @permit_qtbls       : ()),
3744                                                                 (@reject_qtbls      ? @reject_qtbls       : ()),
3745                                                                 (@get_eng           ? @get_eng            : ()),
3746                                                                 (@permit_engs       ? @permit_engs        : ()),
3747                                                                 (@reject_engs       ? @reject_engs        : ()),
3748                                                              '   }';
3749                                                        }
3750                                                     }
3751                                                  
3752           9                                 52      push @lines,
3753                                                        '   MKDEBUG && _d(\'Passes filters:\', $db, $tbl, $engine, $dbh);',
3754                                                        '   return 1;',  '}';
3755                                                  
3756           9                                 74      my $code = join("\n", @lines);
3757           9                                 21      MKDEBUG && _d('filter sub:', $code);
3758  ***      9     50                        2594      my $filter_sub= eval $code
3759                                                        or die "Error compiling subroutine code:\n$code\n$EVAL_ERROR";
3760                                                  
3761           9                                 81      return $filter_sub;
3762                                                  }
3763                                                  
3764                                                  sub set_filter {
3765           9                    9            44      my ( $self, $filter_sub ) = @_;
3766           9                                 40      $self->{filter} = $filter_sub;
3767           9                                 19      MKDEBUG && _d('Set filter sub');
3768           9                                 24      return;
3769                                                  }
3770                                                  
3771                                                  sub get_db_itr {
3772           9                    9            50      my ( $self, %args ) = @_;
3773           9                                 40      my @required_args = qw(dbh);
3774           9                                 41      foreach my $arg ( @required_args ) {
3775  ***      9     50                          56         die "I need a $arg argument" unless $args{$arg};
3776                                                     }
3777           9                                 43      my ($dbh) = @args{@required_args};
3778                                                  
3779           9                                 34      my $filter = $self->{filter};
3780           9                                 29      my @dbs;
3781           9                                 28      eval {
3782           9                                 28         my $sql = 'SHOW DATABASES';
3783           9                                 26         MKDEBUG && _d($sql);
3784  ***     44     50                         276         @dbs =  grep {
3785           9                                 22            my $ok = $filter ? $filter->($dbh, $_, undef) : 1;
3786          44    100                         271            $ok = 0 if $_ =~ m/information_schema|lost\+found/;
3787          44                                153            $ok;
3788           9                                 27         } @{ $dbh->selectcol_arrayref($sql) };
3789           9                                 35         MKDEBUG && _d('Found', scalar @dbs, 'databases');
3790                                                     };
3791           9                                 25      MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
3792                                                     return sub {
3793          18                   18           108         return shift @dbs;
3794           9                                 83      };
3795                                                  }
3796                                                  
3797                                                  sub get_tbl_itr {
3798           9                    9            73      my ( $self, %args ) = @_;
3799           9                                 48      my @required_args = qw(dbh db);
3800           9                                 46      foreach my $arg ( @required_args ) {
3801  ***     18     50                          93         die "I need a $arg argument" unless $args{$arg};
3802                                                     }
3803           9                                 52      my ($dbh, $db, $views) = @args{@required_args, 'views'};
3804                                                  
3805           9                                 34      my $filter = $self->{filter};
3806           9                                 24      my @tbls;
3807  ***      9     50                          39      if ( $db ) {
3808           9                                 27         eval {
3809           9                                 61            my $sql = 'SHOW /*!50002 FULL*/ TABLES FROM '
3810                                                                   . $self->{Quoter}->quote($db);
3811           9                                 23            MKDEBUG && _d($sql);
3812           9                                 64            @tbls = map {
3813          58                               2931               $_->[0]
3814                                                           }
3815                                                           grep {
3816           9                                 25               my ($tbl, $type) = @$_;
3817  ***     58     50                         335               my $ok = $filter ? $filter->($dbh, $db, $tbl) : 1;
3818  ***     58     50                         250               if ( !$views ) {
3819  ***     58     50     50                  317                  $ok = 0 if ($type || '') eq 'VIEW';
3820                                                              }
3821          58                                185               $ok;
3822                                                           }
3823           9                                 42            @{ $dbh->selectall_arrayref($sql) };
3824           9                                154            MKDEBUG && _d('Found', scalar @tbls, 'tables in', $db);
3825                                                        };
3826           9                                 27         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
3827                                                     }
3828                                                     else {
3829  ***      0                                  0         MKDEBUG && _d('No db given so no tables');
3830                                                     }
3831                                                     return sub {
3832          18                   18           178         return shift @tbls;
3833           9                                103      };
3834                                                  }
3835                                                  
3836                                                  sub _make_filter {
3837          52                   52           253      my ( $cond, $var_name, $objs, $lc ) = @_;
3838          52                                143      my @lines;
3839          52    100                         243      if ( scalar keys %$objs ) {
3840          36    100                         267         my $test = join(' || ',
3841          27                                120            map { "$var_name eq '" . ($lc ? lc $_ : $_) ."'" } keys %$objs);
3842          27                                165         push @lines, "      return 0 $cond $var_name && ($test);",
3843                                                     }
3844          52                                296      return @lines;
3845                                                  }
3846                                                  
3847                                                  sub _d {
3848  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3849  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3850  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3851                                                          @_;
3852  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3853                                                  }
3854                                                  
3855                                                  1;
3856                                                  
3857                                                  # ###########################################################################
3858                                                  # End SchemaIterator package
3859                                                  # ###########################################################################
3860                                                  
3861                                                  # ###########################################################################
3862                                                  # This is a combination of modules and programs in one -- a runnable module.
3863                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
3864                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
3865                                                  #
3866                                                  # Check at the end of this package for the call to main() which actually runs
3867                                                  # the program.
3868                                                  # ###########################################################################
3869                                                  package mk_table_checksum;
3870                                                  
3871          24                   24           175   use English qw(-no_match_vars);
              24                                 62   
              24                                139   
3872          24                   24           173   use List::Util qw(max maxstr);
              24                                 57   
              24                                141   
3873          24                   24           155   use Time::HiRes qw(gettimeofday sleep);
              24                                 56   
              24                                166   
3874          24                   24           150   use Data::Dumper;
              24                                 59   
              24                                122   
3875                                                  $Data::Dumper::Indent    = 0;
3876                                                  $Data::Dumper::Quotekeys = 0;
3877                                                  
3878  ***     24            50     24           155   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              24                                 57   
              24                                358   
3879                                                  
3880                                                  $OUTPUT_AUTOFLUSH = 1;
3881                                                  
3882                                                  # Global variables.
3883                                                  my $exit_status = 0;
3884                                                  my $checksum_table_data;
3885                                                  my ( $fetch_sth, $update_sth, $savesince_sth );
3886                                                  my ( $crc_wid, $md5sum_fmt );
3887                                                  my $already_checksummed;
3888                                                  # %tables_to_checksum has the following structure:
3889                                                  #    database => [
3890                                                  #       { table },
3891                                                  #       ...
3892                                                  #    ],
3893                                                  #    ...
3894                                                  my %tables_to_checksum;
3895                                                  
3896                                                  sub main {
3897           9                    9         16185      @ARGV = @_;  # set global ARGV for this package
3898                                                  
3899                                                     # Reset global vars else tests which run this tool as a module
3900                                                     # will have strange, overlapping results.
3901           9                                 46      $exit_status                                = 0;
3902           9                                 37      $checksum_table_data                        = undef;
3903           9                                 42      ( $fetch_sth, $update_sth, $savesince_sth ) = (undef, undef, undef);
3904           9                                 42      ( $crc_wid, $md5sum_fmt )                   = (undef, undef);
3905           9                                 29      $already_checksummed                        = undef;
3906           9                               1011      %tables_to_checksum                         = ();
3907                                                  
3908                                                  
3909                                                     # ########################################################################
3910                                                     # Get configuration information.
3911                                                     # ########################################################################
3912           9                                136      my $dp = new DSNParser();
3913                                                  
3914                                                     # Because of --arg-table, $final_o is the OptionParser obj used to get
3915                                                     # most options (see my $final_o below).
3916           9                                123      my $o = new OptionParser(
3917                                                        dp          => $dp,
3918                                                        strict      => 0,
3919                                                        prompt      => '[OPTION]... HOST_DSN [HOST_DSN]...',
3920                                                        description => 'checksums MySQL tables efficiently on one or more hosts. '
3921                                                                     . ' Each host is specified as a DSN and missing values are '
3922                                                                     . 'inherited from the first host.  If you specify multiple '
3923                                                                     . 'hosts, the first is assumed to be the master.',
3924                                                     );
3925           9                                 52      $o->get_specs();
3926           9                                 74      $o->get_opts();
3927                                                  
3928           9                                 59      $dp->prop('set-vars', $o->get('set-vars'));
3929                                                  
3930                                                     # This list contains all the command-line arguments that can be overridden
3931                                                     # by a table that contains arguments for each table to be checksummed.
3932                                                     # The long form of each argument is given.  The values are read from the
3933                                                     # POD by finding the magical token.
3934           9                                 30      my %overridable_args;
3935                                                     {
3936           9                                 24         my $para = $o->read_para_after(
               9                                133   
3937                                                           __FILE__, qr/MAGIC_overridable_args/);
3938           9                                315         foreach my $arg ( $para =~ m/([\w-]+)/g ) {
3939  ***    198     50                         731            die "Magical argument $arg mentioned in POD is not a "
3940                                                              . "command-line argument" unless $o->has($arg);
3941         198                                798            $overridable_args{$arg} = 1;
3942                                                        }
3943                                                     };
3944                                                  
3945                                                     # Post-process command-line options and arguments.
3946  ***      9     50                          56      $o->set('lock', 1)      if $o->get('wait');
3947           9    100                          44      $o->set('slave-lag', 1) if $o->get('lock');
3948                                                  
3949  ***      9     50                          46      if ( !@ARGV ) {
3950  ***      0                                  0         $o->save_error("No hosts specified.");
3951                                                     }
3952                                                  
3953           9                                 28      my @hosts; 
3954           9                                 62      my $dsn_defaults = $dp->parse_options($o);
3955                                                     {
3956           9                                 28         foreach my $arg ( unique(@ARGV) ) {
               9                                 63   
3957           9                                 63            push @hosts, $dp->parse($arg, $hosts[0], $dsn_defaults);
3958                                                        }
3959                                                     }
3960                                                  
3961  ***      9     50                          46      if ( $o->get('explain-hosts') ) {
3962  ***      0                                  0         foreach my $host ( @hosts ) {
3963  ***      0                                  0            print "Server $host->{h}:\n   ", $dp->as_string($host), "\n";
3964                                                        }
3965  ***      0                                  0         return 0;
3966                                                     }
3967                                                  
3968                                                     # Checksumming table data is the normal operation. But if we're only to
3969                                                     # compare schemas, then we can skip a lot of work, like selecting an algo,
3970                                                     # replication stuff, etc.
3971  ***      9     50                          40      $checksum_table_data = $o->get('schema') ? 0 : 1;
3972                                                  
3973           9    100                          36      if ( $o->get('checksum') ) {
3974           7                                 38         $o->set('count', 0);
3975                                                     }
3976                                                  
3977           9    100                          40      if ( $o->get('explain') ) {
3978           1                                  4         @hosts = $hosts[0];
3979                                                     }
3980                                                  
3981  ***      9     50                          44      if ( !$o->get('help') ) {
3982  ***      9     50     33                   53         if ( $o->get('replicate-check') && !$o->get('replicate') ) {
3983  ***      0                                  0            $o->save_error("--replicate-check requires --replicate.");
3984                                                        }
3985  ***      9     50     33                   48         if ( $o->get('save-since') && !$o->get('arg-table') ) {
      ***            50     33                        
3986  ***      0                                  0            $o->save_error("--save-since requires --arg-table.");
3987                                                        }
3988                                                        elsif ( $o->get('replicate') && @hosts > 1 ) {
3989  ***      0                                  0            $o->save_error("You can only specify one host with --replicate.");
3990                                                        }
3991                                                  
3992  ***      9     50     33                   36         if ( $o->get('resume-replicate') && !$o->get('replicate') ) {
3993  ***      0                                  0            $o->save_error("--resume-replicate requires --replicate.");
3994                                                        }
3995  ***      9     50     33                   44         if ( $o->get('resume') && $o->get('replicate') ) {
3996  ***      0                                  0            $o->save_error('--resume does not work with --replicate.  '
3997                                                              . 'Use --resume-replicate instead.');
3998                                                        }
3999                                                     }
4000                                                  
4001           9                                 52      $o->usage_or_errors();
4002                                                  
4003                                                     # ########################################################################
4004                                                     # If --pid, check it first since we'll die if it already exits.
4005                                                     # ########################################################################
4006           9                                 32      my $daemon;
4007  ***      9     50                          39      if ( $o->get('pid') ) {
4008                                                        # We're not daemoninzing, it just handles PID stuff.  Keep $daemon
4009                                                        # in the the scope of main() because when it's destroyed it automatically
4010                                                        # removes the PID file.
4011  ***      0                                  0         $daemon = new Daemon(o=>$o);
4012  ***      0                                  0         $daemon->make_PID_file();
4013                                                     }
4014                                                  
4015                                                     # ########################################################################
4016                                                     # Ready to work now.
4017                                                     # ########################################################################
4018           9                                107      my $q  = new Quoter();
4019           9                                 79      my $vp = new VersionParser();
4020           9                                101      my $tp = new TableParser(Quoter => $q);
4021           9                                 91      my $tc = new TableChecksum(Quoter=> $q, VersionParser => $vp);
4022           9                                 82      my $ms = new MasterSlave();
4023           9                                 79      my $du = new MySQLDump(cache => 0);
4024           9                                 82      my $ch = new TableChunker(Quoter => $q, MySQLDump => $du); 
4025           9                                106      my %common_modules = (
4026                                                        ch => $ch,
4027                                                        dp => $dp,
4028                                                        du => $du,
4029                                                        o  => $o,
4030                                                        ms => $ms,
4031                                                        q  => $q,
4032                                                        tc => $tc,
4033                                                        tp => $tp,
4034                                                        vp => $vp,
4035                                                     );
4036                                                  
4037           9                                 79      my $main_dbh = get_cxn($hosts[0], %common_modules);
4038                                                  
4039           9                                 36      my $lag_dbh;
4040                                                     {
4041  ***      9     50                          26         if ( $o->get('check-slave-lag') ) {
               9                                 52   
4042  ***      0                                  0            my $dsn = $dp->parse($o->get('check-slave-lag'), $hosts[0], $dsn_defaults);
4043  ***      0                                  0            $lag_dbh = get_cxn($dsn, %common_modules);
4044                                                        }
4045                                                     }
4046                                                  
4047                                                     # ########################################################################
4048                                                     # Load --arg-table information.
4049                                                     # ########################################################################
4050           9                               1850      my %args_for;
4051  ***      9     50                          46      if ( my $arg_tbl = $o->get('arg-table') ) {
4052  ***      0                                  0         my %col_in_argtable;
4053  ***      0                                  0         my $rows = $main_dbh->selectall_arrayref(
4054                                                           "SELECT * FROM $arg_tbl", { Slice => {} });
4055  ***      0                                  0         foreach my $row ( @$rows ) {
4056  ***      0      0      0                    0            die "Invalid entry in --arg-table: db and tbl must be set"
4057                                                              unless $row->{db} && $row->{tbl};
4058  ***      0                                  0            $args_for{$row->{db}}->{$row->{tbl}} = {
4059  ***      0      0                           0               map  { $_ => $row->{$_} }
4060  ***      0                                  0               grep { $overridable_args{$_} && defined $row->{$_} }
4061                                                              keys %$row
4062                                                           };
4063  ***      0      0                           0            if ( !%col_in_argtable ) { # do only once
4064  ***      0                                  0               foreach my $key ( keys %$row ) {
4065  ***      0      0                           0                  next if $key =~ m/^(db|tbl|ts)$/;
4066  ***      0      0                           0                  die "Column $key (from $arg_tbl given by --arg-table) is not "
4067                                                                    . "an overridable argument" unless $overridable_args{$key};
4068  ***      0                                  0                  $col_in_argtable{$key} = 1;
4069                                                              }
4070                                                           }
4071                                                        }
4072  ***      0      0                           0         if ( $col_in_argtable{since} ) {
4073  ***      0                                  0            $savesince_sth = $main_dbh->prepare(
4074                                                             "UPDATE $arg_tbl SET since=COALESCE(?, NOW()) WHERE db=? AND tbl=?");
4075                                                        }
4076                                                     }
4077                                                  
4078                                                     # ########################################################################
4079                                                     # Check replication slaves if desired.  If only --replicate-check is given,
4080                                                     # then we will exit here.  If --recheck is also given, then we'll continue
4081                                                     # through the entire script but checksum only the inconsistent tables found
4082                                                     # here.
4083                                                     # ########################################################################
4084  ***      9     50                          45      if ( $o->get('replicate-check') ) {
4085  ***      0      0                           0         my $callback = $o->get('recheck')
4086                                                                     ? \&save_inconsistent_tbls
4087                                                                     : \&print_inconsistent_tbls;
4088                                                        $ms->recurse_to_slaves(
4089                                                           {  dbh        => $main_dbh,
4090                                                              dsn        => $hosts[0],
4091                                                              dsn_parser => $dp,
4092                                                              recurse    => $o->get('replicate-check'),
4093                                                              callback   => sub {
4094  ***      0                    0             0                  my ( $dsn, $dbh, $level, $parent ) = @_;
4095  ***      0                                  0                  my @tbls = $tc->find_replication_differences(
4096                                                                    $dbh, $o->get('replicate'));
4097  ***      0      0                           0                  return unless @tbls;
4098  ***      0                                  0                  $exit_status = 1;
4099                                                                 # Call the callback that does something useful with
4100                                                                 # the inconsistent tables.
4101                                                                 # o dbh db tbl args_for
4102  ***      0                                  0                  $callback->(
4103                                                                    dsn      => $dsn,
4104                                                                    dbh      => $dbh,
4105                                                                    level    => $level,
4106                                                                    parent   => $parent,
4107                                                                    tbls     => \@tbls,
4108                                                                    args_for => \%args_for,
4109                                                                    %common_modules
4110                                                                 );
4111                                                              },
4112  ***      0                                  0               method => $o->get('recursion-method'),
4113                                                           }
4114                                                        );
4115  ***      0      0                           0         return $exit_status unless $o->get('recheck');
4116                                                     }
4117                                                  
4118                                                     # ########################################################################
4119                                                     # Otherwise get ready to checksum table data, unless we have only to check
4120                                                     # schemas in which case we can skip all such work, knowing already that we
4121                                                     # will use CRC32.
4122                                                     # ########################################################################
4123  ***      9     50                          53      if ( $checksum_table_data ) {
4124                                                        # Verify that CONCAT_WS is compatible across all servers. On older
4125                                                        # versions of MySQL it skips both empty strings and NULL; on newer
4126                                                        # just NULL.
4127  ***      9     50     33                   37         if ( $o->get('verify') && @hosts > 1 ) {
4128  ***      0                                  0            verify_checksum_compat(hosts=>\@hosts, %common_modules);
4129                                                        }
4130                                                  
4131           9                                 97         ($fetch_sth, $update_sth)
4132                                                           = check_repl_table(dbh=>$main_dbh, %common_modules);
4133                                                     }
4134                                                     else {
4135  ***      0                                  0         $crc_wid = 16; # Wider than the widest CRC32.
4136                                                     } 
4137                                                  
4138                                                     # ########################################################################
4139                                                     # If resuming a previous run, figure out what the previous run finished.
4140                                                     # ######################################################################## 
4141  ***      9     50     33                   41      if ( $o->get('replicate') && $o->get('resume-replicate') ) {
      ***            50                               
4142  ***      0                                  0         $already_checksummed = read_repl_table(
4143                                                           dbh  => $main_dbh,
4144                                                           host => $hosts[0]->{h},
4145                                                           %common_modules,
4146                                                        );
4147                                                     } 
4148                                                     elsif ( $o->get('resume') ) {
4149  ***      0                                  0         $already_checksummed = parse_resume_file($o->get('resume'));
4150                                                     }
4151                                                  
4152                                                     # ########################################################################
4153                                                     # Iterate through databases and tables and do the checksums.
4154                                                     # ########################################################################
4155                                                  
4156                                                     # Get table info for all hosts, all slaves, unless we're in the special
4157                                                     # "repl-re-check" mode in which case %tables_to_checksum has already the
4158                                                     # inconsistent tables that we need to re-checksum.
4159                                                     get_all_tbls_info(
4160  ***      9     50     33                   45         dbh      => $main_dbh,
4161                                                        args_for => \%args_for,
4162                                                        %common_modules,
4163                                                     ) unless ($o->get('replicate-check') && $o->get('recheck'));
4164                                                  
4165                                                     # Finally, checksum the tables.
4166           9                                 68      foreach my $database ( keys %tables_to_checksum ) {
4167           9                                 31         my $tables = $tables_to_checksum{$database};
4168           9                                 94         checksum_tables(
4169                                                           dbh     => $main_dbh,
4170                                                           db      => $database,
4171                                                           tbls    => $tables,
4172                                                           hosts   => \@hosts,
4173                                                           lag_dbh => $lag_dbh,
4174                                                           %common_modules
4175                                                        );
4176                                                     }
4177                                                  
4178           9                               2328      return $exit_status;
4179                                                  }
4180                                                  
4181                                                  # ############################################################################
4182                                                  # Subroutines
4183                                                  # ############################################################################
4184                                                  
4185                                                  sub get_all_tbls_info {
4186           9                    9            90      my ( %args ) = @_;
4187           9                                 61      foreach my $arg ( qw(o dbh q tp du ch args_for) ) {
4188  ***     63     50                         281         die "I need a $arg argument" unless $args{$arg};
4189                                                     }
4190           9                                 32      my $o      = $args{o};
4191           9                                 51      my $dbh    = $args{dbh};
4192                                                  
4193           9                                104      my $si = new SchemaIterator(
4194                                                        Quoter => $args{q},
4195                                                     );
4196           9                                 63      $si->set_filter($si->make_filter($o));
4197                                                  
4198           9                                 51      my $next_db = $si->get_db_itr(dbh => $dbh);
4199           9                                 39      while ( my $db = $next_db->() ) {
4200           9                                 63         my $next_tbl = $si->get_tbl_itr(
4201                                                           dbh   => $dbh,
4202                                                           db    => $db,
4203                                                           views => 0,
4204                                                        );
4205           9                                 43         while ( my $tbl = $next_tbl->() ) {
4206           9                                 22            MKDEBUG && _d("Examining", $db, '.', $tbl);
4207           9                                111            my $final_o = get_final_opts(
4208                                                              %args,
4209                                                              db  => $db,
4210                                                              tbl => $tbl,
4211                                                           );
4212           9                                 79            save_tbl_to_checksum(
4213                                                              %args,
4214                                                              db      => $db,
4215                                                              tbl     => $tbl,
4216                                                              final_o => $final_o,
4217                                                           );
4218                                                        }
4219                                                     }
4220                                                  
4221           9                                358      return;
4222                                                  }
4223                                                  
4224                                                  sub save_tbl_to_checksum {
4225           9                    9            92      my ( %args ) = @_;
4226           9                                 66      foreach my $arg ( qw(q ch du final_o tp dbh db tbl du tp ch vp) ) {
4227  ***    108     50                         476         die "I need a $arg argument" unless $args{$arg};
4228                                                     }
4229           9                                 34      my $du      = $args{du};
4230           9                                 29      my $tp      = $args{tp};
4231           9                                 29      my $ch      = $args{ch};
4232           9                                 31      my $final_o = $args{final_o};
4233           9                                 32      my $dbh     = $args{dbh};
4234           9                                 29      my $db      = $args{db};
4235           9                                 39      my $tbl     = $args{tbl};
4236           9                                 29      my $q       = $args{q};
4237           9                                 28      my $vp      = $args{vp};
4238                                                  
4239                                                     # Skip the table in which checksums are stored.
4240  ***      9     50     33                   40      return if ($final_o->get('replicate')
4241                                                        && $final_o->get('replicate') eq "$db.$tbl");
4242                                                  
4243           9                                 29      eval { # Catch errors caused by tables being dropped during work.
4244                                                  
4245                                                        # Parse the table and determine a column that's chunkable.  This is
4246                                                        # used not only for chunking, but also for --since.
4247           9                                 72         my $create        = $du->get_create_table($dbh, $q, $db, $tbl);
4248           9                                 70         my $struct        = $tp->parse($create);
4249           9                                 82         my ( $col, $idx ) = $ch->get_first_chunkable_column(tbl_struct=>$struct);
4250                                                  
4251  ***      9     50                          57         $idx = undef if $final_o->get('no-use-index');
4252           9    100                          49         if ( $idx ) {
4253  ***      8     50                          56            my $hint = $vp->version_ge($dbh, '4.0.9') ? 'FORCE' : 'USE';
4254           8                                 47            $idx     = "$hint INDEX (" . $q->quote($idx) . ")";
4255                                                        }
4256           9                                 23         MKDEBUG && _d('Index hint:', $idx);
4257                                                  
4258           9                                 35         my @chunks = '1=1'; # Default.
4259           9                                 27         my $maxval = undef;
4260  ***      9     50                          45         if ( $args{given_chunks} ) {
4261  ***      0                                  0            @chunks = @{$args{given_chunks}};
      ***      0                                  0   
4262                                                        }
4263                                                        else {      
4264  ***      9     50     33                   46            if ( $final_o->get('chunk-size') && $col ) {
4265  ***      0                                  0               my $rows_per_chunk = $ch->size_to_rows(
4266                                                                 dbh        => $dbh,
4267                                                                 db         => $db,
4268                                                                 tbl        => $tbl,
4269                                                                 chunk_size => $final_o->get('chunk-size'),
4270                                                              );
4271                                                  
4272                                                              # Calculate chunks for this table.
4273  ***      0                                  0               my %params = $ch->get_range_statistics(
4274                                                                 dbh       => $dbh,
4275                                                                 db        => $db,
4276                                                                 tbl       => $tbl,
4277                                                                 chunk_col => $col
4278                                                              );
4279  ***      0      0                           0               if ( !grep { !defined $params{$_} } qw(min max rows_in_range) ) {
      ***      0                                  0   
4280  ***      0                                  0                  @chunks = $ch->calculate_chunks(
4281                                                                    dbh        => $dbh,
4282                                                                    tbl_struct => $struct,
4283                                                                    chunk_col  => $col,
4284                                                                    chunk_size => $rows_per_chunk,
4285                                                                    %params,
4286                                                                 );
4287  ***      0                                  0                  $maxval = $params{max};
4288                                                              }
4289                                                           }
4290                                                        }
4291                                                  
4292           9                                 29         push @{ $tables_to_checksum{$db} }, {
               9                                152   
4293                                                           struct   => $struct,
4294                                                           create   => $create,
4295                                                           database => $db,
4296                                                           table    => $tbl,
4297                                                           column   => $col,
4298                                                           maxval   => $maxval,
4299                                                           index    => $idx,
4300                                                           chunks   => \@chunks,
4301                                                           final_o  => $final_o,
4302                                                        };
4303                                                     };
4304  ***      9     50                          46      if ( $EVAL_ERROR ) {
4305  ***      0                                  0         print_err($final_o, $EVAL_ERROR, $db, $tbl);
4306                                                     }
4307                                                  
4308           9                                 98      return;
4309                                                  }
4310                                                  
4311                                                  # Checksum the tables in the given database.
4312                                                  # A separate report for each database and its tables is printed.
4313                                                  sub checksum_tables {
4314           9                    9           114      my ( %args ) = @_;
4315           9                                 61      foreach my $arg ( qw(tc du o q db dbh hosts tbls) ) {
4316  ***     72     50                         336         die "I need a $arg argument" unless $args{$arg};
4317                                                     }
4318           9                                 33      my $tc    = $args{tc};
4319           9                                 35      my $du    = $args{du};
4320           9                                 29      my $o     = $args{o};
4321           9                                 30      my $db    = $args{db};
4322           9                                 29      my $dbh   = $args{dbh};
4323           9                                 30      my $hosts = $args{hosts};
4324           9                                 29      my $tbls  = $args{tbls};
4325           9                                 27      my $q     = $args{q};
4326                                                  
4327           9                                 28      my ($hdr, $explain);
4328                                                  
4329                                                     # NOTE: remember, you can't 'next TABLE' inside the eval{}.
4330                                                     # NOTE: remember to use the final_o embedded within each $table, not $o
4331           9                                 36      foreach my $table ( @$tbls ) {
4332           9                                 27         eval {
4333           9                                 35            my $final_o  = $table->{final_o};
4334           9                                 37            my $do_table = 1;
4335           9                                 22            MKDEBUG && _d("Doing", $db, '.', $table->{table});
4336           9                                 19            MKDEBUG && _d("Table:", Dumper($table));
4337                                                  
4338                                                           # Determine the checksum strategy for every table because it
4339                                                           # might change given various --arg-table opts for each table.
4340           9                                 26            my $strat_ref;
4341           9                                 35            my ( $strat, $crc_type, $func, $opt_slice );
4342  ***      9     50     33                  103            if ( $checksum_table_data && $do_table ) {
4343           9                                 61               $strat_ref = determine_checksum_strat(
4344                                                                 dbh => $dbh,
4345                                                                 tc  => $tc,
4346                                                                 o   => $final_o,
4347                                                              );
4348           9                                 72               ( $strat, $crc_wid, $crc_type, $func, $opt_slice )
4349                                                                 = @$strat_ref{ qw(strat crc_wid crc_type func opt_slice) };
4350           9                                 29               MKDEBUG && _d("Checksum strat:", Dumper($strat_ref));
4351                                                           }
4352                                                           else {
4353                                                              # --schema doesn't use a checksum strategy, but do_tbl()
4354                                                              # requires a start arg.
4355  ***      0                                  0               $strat = '--schema';
4356                                                           }
4357           9                                 41            $md5sum_fmt = "%-${crc_wid}s  %s.%s.%s.%d\n";
4358                                                  
4359                                                           # Design and print header unless we are resuming in which case
4360                                                           # we should have already re-printed the partial output of the
4361                                                           # resume file in parse_resume_file().  This only has to be done
4362                                                           # once and done here because we need $crc_wid which is determined
4363                                                           # by the checksum strat above.
4364  ***      9     50                          44            if ( !$hdr ) {
4365  ***      9     50                          45               if ( $o->get('tab') ) {
4366  ***      0                                  0                  $hdr = "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n";
4367  ***      0                                  0                  $explain = "%s\t%s\t%s\n";
4368                                                              }
4369                                                              else {
4370           9                                 44                  my $max_tbl  = max(5, map { length($_->{table}) } @$tbls);
               9                                 81   
4371           9                                 51                  my $max_db   = max(8, length($db));
4372           9                                 42                  my $max_host = max(4, map { length($_->{h}) } @$hosts);
               9                                 56   
4373           9                                 63                  $hdr         = "%-${max_db}s %-${max_tbl}s %5s "
4374                                                                              . "%-${max_host}s %-6s %10s %${crc_wid}s %4s %4s %4s %4s\n";
4375           9                                 43                  $explain     = "%-${max_db}s %-${max_tbl}s %s\n";
4376                                                              }
4377           9                                 78               my @hdr_args = qw(DATABASE TABLE CHUNK HOST ENGINE
4378                                                                                COUNT CHECKSUM TIME WAIT STAT LAG);
4379  ***      9    100     66                   39               unless ( $o->get('quiet')
                           100                        
      ***                   66                        
4380                                                                       || $o->get('explain')
4381                                                                       || $o->get('checksum')
4382                                                                       || $o->get('resume') )
4383                                                              {
4384  ***      1     50                          47                  printf($hdr, @hdr_args)
4385                                                                    or die "Cannot print: $OS_ERROR";
4386                                                              }
4387                                                           }
4388                                                  
4389                                                           # Clean out the replication table entry for this table.
4390  ***      9     50     33                   47            if ( (my $replicate_table = $final_o->get('replicate'))
4391                                                                && !$final_o->get('explain') ) {
4392  ***      0                                  0               my $del_sql = "DELETE FROM $replicate_table WHERE db=? AND tbl=?";
4393  ***      0                                  0               MKDEBUG && _d($dbh, $del_sql, $db, $table->{table});
4394  ***      0                                  0               $dbh->do($del_sql, {}, $db, $table->{table});
4395                                                           }
4396                                                  
4397                                                           # If --since is given, figure out either
4398                                                           # 1) for temporal sinces, if the table has an update time and that
4399                                                           #    time is newer than --since, then checksum the whole table,
4400                                                           #    otherwise skip it; or
4401                                                           # 2) for "numerical" sinces, which column to use: either the
4402                                                           #    specified column (--sincecolumn) or the auto-discovered one,
4403                                                           #    whichever exists in the table, in that order.
4404                                                           # Then, if --savesince is given, save either 1) the current timestamp
4405                                                           # or 2) the resulting WHERE clause.
4406  ***      9     50                          38            if ( $final_o->get('since') ) {
4407  ***      0      0                           0               if ( is_temporal($final_o->get('since')) ) {
4408  ***      0                                  0                  MKDEBUG && _d('--since is temporal');
4409  ***      0                                  0                  my ( $stat )
4410                                                                    = $du->get_table_status($dbh, $q, $db, $table->{table});
4411  ***      0                                  0                  my $time = $stat->{update_time};
4412  ***      0      0      0                    0                  if ( $time && $time lt $final_o->get('since') ) {
4413  ***      0                                  0                     MKDEBUG && _d("Skipping table because --since value",
4414                                                                       $final_o->get('since'), "is newer than", $time);
4415  ***      0                                  0                     $do_table = 0;
4416  ***      0                                  0                     $table->{chunks} = [];
4417                                                                 }
4418                                                              }
4419                                                              else {
4420  ***      0                                  0                  MKDEBUG && _d('--since is numerical');
4421                                                                 # For numerical sinces, choose the column to apply --since to.
4422                                                                 # It may not be the column the user said to use! If the user
4423                                                                 # didn't specify a column that's good to chunk on, we'll use
4424                                                                 # something else instead.
4425                                                  
4426                                                                 # $table->{column} is the first chunkable column returned from
4427                                                                 # the call to get_first_chunkable_column() in
4428                                                                 # save_tbl_to_checksum().
4429  ***      0      0                           0                  my ( $sincecol ) =
4430  ***      0                                  0                     grep { $_ && $table->{struct}->{is_col}->{$_} }
4431                                                                       ( $table->{column}, $final_o->get('since-column') );
4432                                                  
4433  ***      0      0                           0                  if ( $sincecol ) {
4434  ***      0                                  0                     MKDEBUG && _d('Column for numerical --since:',
4435                                                                       $db, '.', $table->{table}, '.', $sincecol);
4436                                                                    # This ends up being an additional WHERE clause.
4437  ***      0                                  0                     $table->{since} = $q->quote($sincecol)
4438                                                                       . '>=' .  $q->quote_val($final_o->get('since'));
4439                                                                 }
4440                                                                 else {
4441  ***      0                                  0                     MKDEBUG && _d('No column for numerical --since for',
4442                                                                       $db, '.', $table->{table});
4443                                                                 }
4444                                                              }
4445                                                           }
4446                                                  
4447                                                           # ##################################################################
4448                                                           # The query is independent of the chunk, so I make it once for every
4449                                                           # one.
4450                                                           # ##################################################################
4451           9                                 29            my $query;
4452  ***      9     50     33                   88            if ( $checksum_table_data && $do_table ) {
4453           9                                 85               $query = $tc->make_checksum_query(
4454                                                                 db              => $db,
4455                                                                 tbl             => $table->{table},
4456                                                                 tbl_struct      => $table->{struct},
4457                                                                 algorithm       => $strat,
4458                                                                 function        => $func,
4459                                                                 crc_wid         => $crc_wid,
4460                                                                 crc_type        => $crc_type,
4461                                                                 opt_slice       => $opt_slice,
4462                                                                 cols            => $final_o->get('columns'),
4463                                                                 sep             => $final_o->get('separator'),
4464                                                                 replicate       => $final_o->get('replicate'),
4465                                                                 float_precision => $final_o->get('float-precision'),
4466                                                                 trim            => $final_o->get('trim'),
4467                                                                 ignorecols      => $final_o->get('ignore-columns'),
4468                                                              );
4469                                                           }
4470                                                           else { # --schema
4471  ***      0                                  0               $query = undef;
4472                                                           }
4473                                                  
4474           9                                 95            checksum_chunks(
4475                                                              %args,
4476                                                              tbl     => $table,
4477                                                              query   => $query,
4478                                                              hdr     => $hdr,
4479                                                              explain => $explain,
4480                                                              final_o => $final_o,
4481                                                              strat   => $strat,
4482                                                           );
4483                                                  
4484                                                           # Save the --since value if
4485                                                           #    1) it's temporal and the tbl had changed since --since; or
4486                                                           #    2) it's "numerical" and it had a chunkable or nibble-able
4487                                                           #       column and it wasn't empty
4488                                                           # See issues 121 and 122.
4489  ***      9     50     33                   71            if ( $final_o->get('save-since') && $savesince_sth ) {
4490  ***      0      0                           0               if ( is_temporal($final_o->get('since')) ) {
      ***             0                               
4491  ***      0                                  0                  MKDEBUG && _d(
4492                                                                    "Saving temporal --since value: current timestamp for",
4493                                                                    $db, '.', $table->{table});
4494  ***      0                                  0                  $savesince_sth->execute(undef,
4495                                                                    $db, $table->{table});
4496                                                              }
4497                                                              elsif ( defined $table->{maxval} ) {
4498  ***      0                                  0                  MKDEBUG && _d("Saving numerical --since value:",
4499                                                                    $table->{maxval}, "for", $db, '.', $table->{table});
4500  ***      0                                  0                  $savesince_sth->execute($table->{maxval},
4501                                                                    $db, $table->{table});
4502                                                              }
4503                                                              else {
4504  ***      0                                  0                  MKDEBUG && _d("Cannot save --since value:",
4505                                                                    $table->{maxval}, "for", $db, '.', $table->{table});
4506                                                              }
4507                                                           }
4508                                                        };
4509  ***      9     50                          58         if ( $EVAL_ERROR ) {
4510  ***      0                                  0            print_err($o, $EVAL_ERROR, $db, $table->{table});
4511                                                        }
4512                                                     }
4513                                                  
4514           9                                 87      return;
4515                                                  }
4516                                                  
4517                                                  sub checksum_chunks {
4518           9                    9           152      my ( %args ) = @_;
4519           9                                 73      foreach my $arg ( qw(dp final_o ms o q db tbl hosts hdr explain) ) {
4520  ***     90     50                         408         die "I need a $arg argument" unless $args{$arg};
4521                                                     }
4522           9                                 36      my $dp      = $args{dp};
4523           9                                 30      my $du      = $args{du};
4524           9                                 31      my $final_o = $args{final_o};
4525           9                                 30      my $ms      = $args{ms};
4526           9                                 27      my $o       = $args{o};
4527           9                                 30      my $q       = $args{q};
4528           9                                 33      my $db      = $args{db};
4529           9                                 31      my $dbh     = $args{dbh};
4530           9                                 26      my @hosts   = @{$args{hosts}};
               9                                 37   
4531           9                                 33      my $tbl     = $args{tbl}; 
4532                                                  
4533                                                     # ##################################################################
4534                                                     # This loop may seem suboptimal, because it causes a new child to be
4535                                                     # forked for each table, for each host, for each chunk.  It also
4536                                                     # causes the program to parallelize only within the chunk; that is,
4537                                                     # no two child processes are running on different chunks at a time.
4538                                                     # This is by design. It lets me unlock the table on the master
4539                                                     # between chunks.
4540                                                     # ##################################################################
4541           9                                 34      my $num_chunks = scalar(@{$tbl->{chunks}});
               9                                 41   
4542           9                                 27      MKDEBUG && _d('Checksumming', $num_chunks, 'chunks');
4543                                                     CHUNK:
4544           9                                 49      foreach my $chunk_num ( 0 .. $num_chunks - 1 ) {
4545                                                  
4546  ***      9     50                          50         if ( my $lag_dbh = $args{lag_dbh} ) {
4547  ***      0                                  0            my $lag = $ms->get_slave_lag($lag_dbh);
4548  ***      0             0                    0            while ( !defined $lag || $lag > $final_o->get('max-lag') ) {
4549  ***      0                                  0               MKDEBUG && _d('Sleeping: slave lag is', $lag);
4550  ***      0                                  0               sleep($o->get('check-interval'));
4551  ***      0                                  0               $lag = $ms->get_slave_lag($lag_dbh);
4552                                                           }
4553                                                        }
4554                                                  
4555  ***      9     50     33                   76         if (    ($num_chunks > 1 || $final_o->get('single-chunk'))
      ***                   33                        
      ***                   33                        
      ***                   33                        
4556                                                             && $checksum_table_data
4557                                                             && defined $final_o->get('probability')
4558                                                             && rand(100) >= $final_o->get('probability') ) {
4559  ***      0                                  0            MKDEBUG && _d('Skipping chunk because of --probability');
4560  ***      0                                  0            next CHUNK;
4561                                                        }
4562                                                  
4563  ***      9     50     33                   80         if (    $num_chunks > 1
      ***                   33                        
      ***                   33                        
4564                                                             && $checksum_table_data
4565                                                             && $final_o->get('modulo')
4566                                                             && ($chunk_num % $final_o->get('modulo') != $final_o->get('offset')))
4567                                                        {
4568  ***      0                                  0            MKDEBUG && _d('Skipping chunk', $chunk_num, 'because of --modulo');
4569  ***      0                                  0            next CHUNK;
4570                                                        }
4571                                                  
4572           9                                 93         my $chunk_start_time = gettimeofday();
4573           9                                 26         MKDEBUG && _d('Starting chunk', $chunk_num, 'at', $chunk_start_time);
4574                                                  
4575  ***      9     50                          39         if ( $final_o->get('replicate') ) {
4576                                                           # We're in --replicate mode.
4577                                                  
4578                                                           # If resuming, check if this db.tbl.chunk.host can be skipped.
4579  ***      0      0                           0            if ( $o->get('resume-replicate') ) {
4580  ***      0      0                           0               if ( already_checksummed($tbl->{database},
4581                                                                                       $tbl->{table},
4582                                                                                       $chunk_num,
4583                                                                                       $hosts[0]->{h}) ) {
4584  ***      0      0                           0                  print "# already checksummed:"
4585                                                                    . " $tbl->{database}"
4586                                                                    . " $tbl->{table}"
4587                                                                    . " $chunk_num "
4588                                                                    . $hosts[0]->{h} 
4589                                                                    . "\n"
4590                                                                    unless $o->get('quiet');
4591  ***      0                                  0                  next CHUNK;
4592                                                              }
4593                                                           }
4594                                                  
4595  ***      0             0                    0            $hosts[0]->{dbh} ||= $dbh;
4596                                                  
4597  ***      0                                  0            do_tbl_replicate(
4598                                                              $chunk_num,
4599                                                              %args,
4600                                                              host => $hosts[0],
4601                                                           );
4602                                                        }
4603                                                        else {
4604                                                           # We're in "normal" mode. Lock table and get position on the master.
4605                                                  
4606           9    100                          41            if ( !$final_o->get('explain') ) {
4607           8    100                          41               if ( $final_o->get('lock') ) {
4608           1                                  5                  my $sql = "LOCK TABLES "
4609                                                                         . $q->quote($db, $tbl->{table}) . " READ";
4610           1                                  3                  MKDEBUG && _d($sql);
4611           1                                103                  $dbh->do($sql);
4612                                                              }
4613  ***      8     50                          40               if ( $final_o->get('wait') ) {
4614  ***      0                                  0                  $tbl->{master_status} = $ms->get_master_status($dbh);
4615                                                              }
4616                                                           }
4617                                                  
4618           9                                 28            my %children;
4619                                                           HOST:
4620           9                                 70            foreach my $i ( 0 .. $#hosts ) {
4621           9                                 37               my $is_master = $i == 0; # First host is assumed to be master.
4622           9                                 30               my $host      = $hosts[$i];
4623                                                  
4624                                                              # Open a single connection for each host.  Re-use the
4625                                                              # connection for the master/single host.
4626  ***      9     50                          42               if ( $is_master ) {
4627           9                                 85                  $dbh->{InactiveDestroy} = 1;  # Ensure that this is set.
4628  ***      9            33                   88                  $host->{dbh} ||= $dbh;
4629                                                              }
4630                                                              else {
4631  ***      0             0                    0                  $host->{dbh} ||= get_cxn($host, %args);
4632                                                              }
4633                                                  
4634                                                              # If resuming, check if this db.tbl.chunk.host can be skipped.
4635  ***      9     50                          39               if ( $final_o->get('resume') ) {
4636  ***      0      0                           0                  next HOST if already_checksummed($tbl->{database},
4637                                                                                                  $tbl->{table},
4638                                                                                                  $chunk_num,
4639                                                                                                  $host->{h});
4640                                                              }
4641                                                  
4642                                                              # Fork, but only if there's more than one host.
4643  ***      9     50                          50               my $pid = @hosts > 1 ? fork() : undef;
4644                                                  
4645  ***      9     50      0                   55               if ( @hosts == 1 || (defined($pid) && $pid == 0) ) {
      ***             0     33                        
      ***                    0                        
4646                                                                 # Do the work (I'm a child, or there's only one host)
4647                                                                 
4648           9                                 29                  eval {
4649           9                                102                     do_tbl(
4650                                                                       $chunk_num,
4651                                                                       $is_master,
4652                                                                       %args,
4653                                                                       dbh  => $host->{dbh},
4654                                                                       host => $host,
4655                                                                    );
4656                                                                 };
4657  ***      9     50                          56                  if ( $EVAL_ERROR ) {
4658  ***      0                                  0                     print_err($o, $EVAL_ERROR, $db, $tbl->{table},
4659                                                                              $dp->as_string($host));
4660  ***      0      0                           0                     exit(1) if @hosts > 1; # exit only if I'm a child
4661                                                                 }
4662                                                                 
4663  ***      9     50                          49                  exit(0) if @hosts > 1; # exit only if I'm a child
4664                                                              }
4665                                                              elsif ( @hosts > 1 && !defined($pid) ) {
4666  ***      0                                  0                  die("Unable to fork!");
4667                                                              }
4668                                                              
4669                                                              # I already exited if I'm a child, so I'm the parent.
4670  ***      9     50                          58               $children{$host->{h}} = $pid if @hosts > 1;
4671                                                           }
4672                                                  
4673                                                           # Wait for the children to exit.
4674           9                                 49            foreach my $host ( keys %children ) {
4675  ***      0                                  0               my $pid = waitpid($children{$host}, 0);
4676  ***      0                                  0               MKDEBUG && _d("Child", $pid, "exited with", $CHILD_ERROR);
4677  ***      0             0                    0               $exit_status ||= $CHILD_ERROR >> 8;
4678                                                           }
4679  ***      9    100     66                   44            if ( ($final_o->get('lock') && !$final_o->get('explain')) ) {
4680           1                                  4               my $sql = "UNLOCK TABLES";
4681           1                                  3               MKDEBUG && _d($dbh, $sql);
4682           1                                 89               $dbh->do($sql);
4683                                                           }
4684                                                        }
4685                                                  
4686           9                                 64         my $chunk_stop_time = gettimeofday();
4687           9                                 20         MKDEBUG && _d('Finished chunk at', $chunk_stop_time);
4688                                                  
4689  ***      9     50     33                   42         if ( $final_o->get('sleep') && !$final_o->get('explain') ) {
      ***            50     33                        
4690  ***      0                                  0            MKDEBUG && _d('Sleeping', $final_o->get('sleep'));
4691  ***      0                                  0            sleep($final_o->get('sleep'));
4692                                                        }
4693                                                        elsif ( $final_o->get('sleep-coef') && !$final_o->get('explain') ) {
4694  ***      0                                  0            my $sleep_time
4695                                                              = ($chunk_stop_time - $chunk_start_time)
4696                                                              * $final_o->get('sleep-coef');
4697  ***      0                                  0            MKDEBUG && _d('Sleeping', $sleep_time);
4698  ***      0                                  0            sleep($sleep_time);
4699                                                        }
4700                                                     } # End foreach CHUNK
4701                                                  
4702           9                                 75      return;
4703                                                  }
4704                                                  
4705                                                  # Override the command-line arguments with those from --arg-table
4706                                                  # if necessary.  Returns a cloned OptionParser object ($final_o).
4707                                                  # This clone is only a partial OptionParser object.
4708                                                  sub get_final_opts {
4709           9                    9           108      my ( %args ) = @_;
4710           9                                 67      foreach my $arg ( qw(o dbh db tbl args_for) ) {
4711  ***     45     50                         211         die "I need a $arg argument" unless $args{$arg};
4712                                                     }
4713           9                                 36      my $o        = $args{o};
4714           9                                 30      my $dbh      = $args{dbh};
4715           9                                 34      my $db       = $args{db};
4716           9                                 31      my $tbl      = $args{tbl};
4717           9                                 30      my $args_for = $args{args_for};
4718                                                  
4719           9                                 55      my $final_o = $o->clone();
4720  ***      9     50                          68      if ( my $override = $args_for->{$db}->{$tbl} ) {
4721  ***      0                                  0         map { $final_o->set($_, $override->{$_}); } keys %$override;
      ***      0                                  0   
4722                                                     }
4723                                                  
4724                                                     # --since and --offset are potentially expressions that should be
4725                                                     # evaluated by the DB server. This has to be done after the override
4726                                                     # from the --arg-table table.
4727           9                                 38      foreach my $opt ( qw(since offset) ) {
4728                                                        # Don't get MySQL to evaluate if it's temporal, as 2008-08-01 --> 1999
4729          18                                 96         my $val = $final_o->get($opt);
4730  ***     18     50     33                  121         if ( $val && !is_temporal($val) ) {
4731  ***      0                                  0            $final_o->set($opt, eval_expr($opt, $val, $dbh));
4732                                                        }
4733                                                     }
4734                                                  
4735           9                                 59      return $final_o;
4736                                                  }
4737                                                  
4738                                                  sub is_temporal {
4739  ***      0                    0             0      my ( $val ) = @_;
4740  ***      0             0                    0      return $val && $val =~ m/^\d{4}-\d{2}-\d{2}(?:.[0-9:]+)?/;
4741                                                  }
4742                                                  
4743                                                  sub print_inconsistent_tbls {
4744  ***      0                    0             0      my ( %args ) = @_;
4745  ***      0                                  0      foreach my $arg ( qw(o dp dsn tbls) ) {
4746  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
4747                                                     }
4748  ***      0                                  0      my $o      = $args{o};
4749  ***      0                                  0      my $dp     = $args{dp};
4750  ***      0                                  0      my $dsn    = $args{dsn};
4751  ***      0                                  0      my $tbls   = $args{tbls};
4752                                                  
4753  ***      0      0                           0      return if $o->get('quiet');
4754                                                  
4755  ***      0                                  0      my @headers = qw(db tbl chunk cnt_diff crc_diff boundaries);
4756  ***      0                                  0      print "Differences on " . $dp->as_string($dsn) . "\n";
4757  ***      0                                  0      my $max_db   = max(5, map { length($_->{db})  } @$tbls);
      ***      0                                  0   
4758  ***      0                                  0      my $max_tbl  = max(5, map { length($_->{tbl}) } @$tbls);
      ***      0                                  0   
4759  ***      0                                  0      my $fmt      = "%-${max_db}s %-${max_tbl}s %5s %8s %8s %s\n";
4760  ***      0      0                           0      printf($fmt, map { uc } @headers) or die "Cannot print: $OS_ERROR";
      ***      0                                  0   
4761  ***      0                                  0      foreach my $tbl ( @$tbls ) {
4762  ***      0      0                           0         printf($fmt, @{$tbl}{@headers}) or die "Cannot print: $OS_ERROR";
      ***      0                                  0   
4763                                                     }
4764  ***      0      0                           0      print "\n" or die "Cannot print: $OS_ERROR";
4765                                                  
4766  ***      0                                  0      return;
4767                                                  }
4768                                                  
4769                                                  sub save_inconsistent_tbls {
4770  ***      0                    0             0      my ( %args ) = @_;
4771  ***      0                                  0      foreach my $arg ( qw(dbh tbls) ) {
4772  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
4773                                                     }
4774  ***      0                                  0      my $dbh  = $args{dbh};
4775  ***      0                                  0      my $tbls = $args{tbls};
4776                                                  
4777  ***      0                                  0      foreach my $tbl ( @$tbls ) {
4778  ***      0                                  0         MKDEBUG && _d("Will recheck", $tbl->{db}, '.', $tbl->{tbl},
4779                                                                      "(chunk:", $tbl->{boundaries}, ')');
4780  ***      0                                  0         my $final_o = get_final_opts(
4781                                                           %args,
4782                                                           db  => $tbl->{db},
4783                                                           tbl => $tbl->{tbl},
4784                                                        );
4785  ***      0                                  0         my $chunks = [ $tbl->{boundaries} ];
4786  ***      0                                  0         save_tbl_to_checksum(
4787                                                           %args,
4788                                                           db      => $tbl->{db},
4789                                                           tbl     => $tbl->{tbl},
4790                                                           final_o => $final_o,
4791                                                        );
4792                                                     }
4793  ***      0                                  0      return;
4794                                                  }
4795                                                  
4796                                                  # The value may be an expression like 'NOW() - INTERVAL 7 DAY'
4797                                                  # and we should evaluate it.
4798                                                  sub eval_expr {
4799  ***      0                    0             0      my ( $name, $val, $dbh ) = @_;
4800  ***      0                                  0      my $result = $val;
4801  ***      0                                  0      eval {
4802  ***      0                                  0         ($result) = $dbh->selectrow_array("SELECT $val");
4803  ***      0                                  0         MKDEBUG && _d("option", $name, "evaluates to:", $result);
4804                                                     };
4805  ***      0      0      0                    0      if ( $EVAL_ERROR && MKDEBUG ) {
4806  ***      0                                  0         chomp $EVAL_ERROR;
4807  ***      0                                  0         _d("Error evaluating option", $name, $EVAL_ERROR);
4808                                                     }
4809  ***      0                                  0      return $result;
4810                                                  }
4811                                                  
4812                                                  sub determine_checksum_strat {
4813           9                    9            56      my ( %args ) = @_;
4814           9                                 47      foreach my $arg ( qw(o dbh tc) ) {
4815  ***     27     50                         131         die "I need a $arg argument" unless $args{$arg};
4816                                                     }
4817           9                                 34      my $o   = $args{o};
4818           9                                 29      my $dbh = $args{dbh};
4819           9                                 31      my $tc  = $args{tc};
4820                                                  
4821           9                                 69      my $ret = {  # return vals in easy-to-swallow hash form
4822                                                        strat      => undef,
4823                                                        crc_type   => 'varchar',
4824                                                        crc_wid    => 16,
4825                                                        func       => undef,
4826                                                        opt_slice  => undef,
4827                                                     };
4828                                                  
4829  ***      9            33                   48      $ret->{strat} = $tc->best_algorithm(
4830                                                        algorithm   => $o->get('algorithm'),
4831                                                        dbh         => $dbh,
4832                                                        where       => $o->get('where') || $o->get('since'),
4833                                                        chunk       => $o->get('chunk-size'),
4834                                                        replicate   => $o->get('replicate'),
4835                                                        count       => $o->get('count'),
4836                                                     );
4837                                                  
4838  ***      9     50     66                   47      if ( $o->get('algorithm') && $o->get('algorithm') ne $ret->{strat} ) {
4839  ***      0                                  0         warn "--algorithm=".$o->get('algorithm')." can't be used; "
4840                                                           . "falling back to $ret->{strat}\n";
4841                                                     }
4842                                                  
4843                                                     # If using a cryptographic hash strategy, decide what hash function to use,
4844                                                     # and if using BIT_XOR whether and which slice to place the user variable in.
4845           9    100                          59      if ( $tc->is_hash_algorithm( $ret->{strat} ) ) {
4846           7                                 33         $ret->{func} = $tc->choose_hash_func(
4847                                                           function => $o->get('function'),
4848                                                           dbh      => $dbh,
4849                                                        );
4850  ***      7     50     33                   33         if ( $o->get('function') && $o->get('function') ne $ret->{func} ) {
4851  ***      0                                  0            warn "Checksum function ".$o->get('function')." cannot be used; "
4852                                                              . "using $ret->{func}\n";
4853                                                        }
4854           7                                 44         $ret->{crc_wid}    = $tc->get_crc_wid($dbh, $ret->{func});
4855           7                                 42         ($ret->{crc_type}) = $tc->get_crc_type($dbh, $ret->{func});
4856                                                  
4857           7    100    100                   35         if ( $o->get('optimize-xor') && $ret->{strat} eq 'BIT_XOR' ) {
4858  ***      2     50                          21            if ( $ret->{crc_type} !~ m/int$/ ) {
4859           2                                 16               $ret->{opt_slice}
4860                                                                 = $tc->optimize_xor(dbh => $dbh, function => $ret->{func});
4861  ***      2     50                          12               if ( !defined $ret->{opt_slice} ) {
4862  ***      0                                  0                  warn "Cannot use --optimize-xor, disabling";
4863  ***      0                                  0                  $o->set('optimize-xor', 0);
4864                                                              }
4865                                                           }
4866                                                           else {
4867                                                              # FNV_64 doesn't need the optimize_xor gizmo.
4868  ***      0                                  0               $o->get('optimize-xor', 0);
4869                                                           }
4870                                                        }
4871                                                     }
4872                                                  
4873           9                                 49      return $ret;
4874                                                  }
4875                                                  
4876                                                  sub verify_checksum_compat {
4877  ***      0                    0             0      my ( %args ) = @_;
4878  ***      0                                  0      foreach my $arg ( qw(o hosts) ) {
4879  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
4880                                                     }
4881  ***      0                                  0      my $o     = $args{o};
4882  ***      0                                  0      my $hosts = $args{hosts};
4883                                                  
4884  ***      0                                  0      my @verify_sums;
4885  ***      0                                  0      foreach my $host ( @$hosts ) {
4886  ***      0                                  0         my $dbh = get_cxn($host, %args);
4887  ***      0                                  0         my $sql = "SELECT MD5(CONCAT_WS(',', '1', ''))";
4888  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
4889  ***      0                                  0         my $cks = $dbh->selectall_arrayref($sql)->[0]->[0];
4890  ***      0                                  0         push @verify_sums, {
4891                                                           host => $host->{h},
4892                                                           ver  => $dbh->{mysql_serverinfo},
4893                                                           sum  => $cks,
4894                                                        };
4895                                                     }
4896  ***      0      0                           0      if ( unique(map { $_->{sum} } @verify_sums ) > 1 ) {
      ***      0                                  0   
4897  ***      0                                  0         my $max = max(map { length($_->{h}) } @$hosts);
      ***      0                                  0   
4898  ***      0                                  0         die "Not all servers have compatible versions.  Some return different\n"
4899                                                           . "checksum values for the same query, and cannot be compared.  This\n"
4900                                                           . "behavior changed in MySQL 4.0.14.  Here is info on each host:\n\n"
4901                                                           . join("\n",
4902  ***      0                                  0                 map { sprintf("%-${max}s %-32s %s", @{$_}{qw(host sum ver)}) }
      ***      0                                  0   
4903                                                                   { host => 'HOST', sum => 'CHECKSUM', ver => 'VERSION'},
4904                                                                @verify_sums
4905                                                             )
4906                                                           . "\n\nYou can disable this check with --no-verify.\n";
4907                                                     }
4908  ***      0                                  0      return;
4909                                                  }
4910                                                  
4911                                                  # Check for existence and privileges on the replication table before
4912                                                  # starting, and prepare the statements that will be used to update it.
4913                                                  # Also clean out the checksum table.  And create it if needed.
4914                                                  # Returns fetch and update statement handles.
4915                                                  sub check_repl_table {
4916           9                    9            94      my ( %args ) = @_;
4917           9                                 62      foreach my $arg ( qw(o dbh tp q) ) {
4918  ***     36     50                         170         die "I need a $arg argument" unless $args{$arg};
4919                                                     }
4920           9                                 38      my $o   = $args{o};
4921           9                                 29      my $dbh = $args{dbh};
4922           9                                 29      my $tp  = $args{tp};
4923           9                                 29      my $q   = $args{q};
4924                                                  
4925           9                                 38      my $replicate_table = $o->get('replicate');
4926  ***      9     50                          70      return unless $replicate_table;
4927                                                  
4928                                                     # Check that the replicate table exists and that we can access it.
4929  ***      0                                  0      my ($db, $tbl) = $q->split_unquote($replicate_table);
4930  ***      0                                  0      my $tbl_exists = $tp->check_table(
4931                                                        dbh => $dbh,
4932                                                        db  => $db,
4933                                                        tbl => $tbl,
4934                                                     );
4935                                                  
4936  ***      0      0                           0      if ( !$tbl_exists ) {
4937  ***      0      0                           0         if ( $o->get('create-replicate-table') ) {
4938  ***      0      0                           0            create_repl_table(%args)
4939                                                              or die "--create-replicate-table failed to create "
4940                                                                 . $replicate_table;
4941                                                        }
4942                                                        else {
4943  ***      0                                  0            die  "--replicate table $replicate_table does not exist; "
4944                                                              . "read the documentation or use --create-replicate-table "
4945                                                              . "to create it.";
4946                                                        }
4947                                                     }
4948                                                     else {
4949  ***      0                                  0         MKDEBUG && _d('--replicate table', $replicate_table, 'already exists');
4950                                                        # Check it again but this time check the privs.
4951  ***      0                                  0         my $have_tbl_privs = $tp->check_table(
4952                                                           dbh       => $dbh,
4953                                                           db        => $db,
4954                                                           tbl       => $tbl,
4955                                                           all_privs => 1,
4956                                                        );
4957  ***      0      0                           0         die "User does not have all necessary privileges on $replicate_table"
4958                                                           unless $have_tbl_privs;
4959                                                     }
4960                                                  
4961                                                     # Clean out the replicate table globally.
4962  ***      0      0                           0      if ( $o->get('empty-replicate-table') ) {
4963  ***      0                                  0         my $del_sql = "DELETE FROM $replicate_table";
4964  ***      0                                  0         MKDEBUG && _d($dbh, $del_sql);
4965  ***      0                                  0         $dbh->do($del_sql);
4966                                                     }
4967                                                  
4968  ***      0                                  0      my $fetch_sth = $dbh->prepare(
4969                                                        "SELECT this_crc, this_cnt FROM $replicate_table "
4970                                                        . "WHERE db = ? AND tbl = ? AND chunk = ?");
4971  ***      0                                  0      my $update_sth = $dbh->prepare(
4972                                                        "UPDATE $replicate_table SET master_crc = ?, master_cnt = ? "
4973                                                        . "WHERE db = ? AND tbl = ? AND chunk = ?");
4974                                                  
4975  ***      0                                  0      return ($fetch_sth, $update_sth);
4976                                                  }
4977                                                  
4978                                                  # Returns 1 on successful creation of the replicate table,
4979                                                  # or 0 on failure.
4980                                                  sub create_repl_table {
4981  ***      0                    0             0      my ( %args ) = @_;
4982  ***      0                                  0      foreach my $arg ( qw(o dbh) ) {
4983  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
4984                                                     }
4985  ***      0                                  0      my $o   = $args{o};
4986  ***      0                                  0      my $dbh = $args{dbh};
4987                                                  
4988  ***      0                                  0      my $replicate_table = $o->get('replicate');
4989                                                  
4990  ***      0                                  0      my $sql = $o->read_para_after(
4991                                                        __FILE__, qr/MAGIC_create_replicate/);
4992  ***      0                                  0      $sql =~ s/CREATE TABLE checksum/CREATE TABLE $replicate_table/;
4993  ***      0                                  0      $sql =~ s/;$//;
4994  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
4995  ***      0                                  0      eval {
4996  ***      0                                  0         $dbh->do($sql);
4997                                                     };
4998  ***      0      0                           0      if ( $EVAL_ERROR ) {
4999  ***      0                                  0         MKDEBUG && _d('--create-replicate-table failed:', $EVAL_ERROR);
5000  ***      0                                  0         return 0;
5001                                                     }
5002                                                  
5003  ***      0                                  0      return 1;
5004                                                  }
5005                                                  
5006                                                  sub read_repl_table {
5007  ***      0                    0             0      my ( %args ) = @_;
5008  ***      0                                  0      foreach my $arg ( qw(o dbh host) ) {
5009  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
5010                                                     }
5011  ***      0                                  0      my $o    = $args{o};
5012  ***      0                                  0      my $dbh  = $args{dbh};
5013  ***      0                                  0      my $host = $args{host};
5014                                                  
5015  ***      0                                  0      my $replicate_table = $o->get('replicate');
5016  ***      0      0                           0      die "Cannot read replicate table because --replicate was not specified"
5017                                                        unless $replicate_table;
5018                                                  
5019                                                     # Read checksums from replicate table.
5020  ***      0                                  0      my $already_checksummed;
5021  ***      0                                  0      my $checksums
5022                                                        = $dbh->selectall_arrayref("SELECT db, tbl, chunk FROM $replicate_table");
5023                                                  
5024                                                     # Save each finished checksum.
5025  ***      0                                  0      foreach my $checksum ( @$checksums ) {
5026  ***      0                                  0         my ( $db, $tbl, $chunk ) = @$checksum[0..2];
5027  ***      0                                  0         $already_checksummed->{$db}->{$tbl}->{$chunk}->{$host} = 1;
5028                                                     }
5029                                                  
5030  ***      0                                  0      return $already_checksummed;
5031                                                  }
5032                                                  
5033                                                  sub parse_resume_file {
5034  ***      0                    0             0      my ( $resume_file ) = @_;
5035                                                  
5036  ***      0      0                           0      open my $resume_fh, '<', $resume_file
5037                                                        or die "Cannot open resume file $resume_file: $OS_ERROR";
5038                                                  
5039                                                     # The resume file, being the output from a previous run, should
5040                                                     # have the columns DATABASE TABLE CHUNK HOST ... (in that order).
5041                                                     # We only need those first 4 columns. We re-print every line of
5042                                                     # the resume file so the end result will be the whole, finished
5043                                                     # output: what the previous run got done plus what we are about
5044                                                     # to resume and finish.
5045  ***      0                                  0      my $already_checksummed;
5046  ***      0                                  0      while ( my $line = <$resume_fh> ) {
5047                                                        # Re-print every line.
5048  ***      0                                  0         print $line;
5049                                                  
5050                                                        # If the line is a checksum line, parse from it the db, tbl,
5051                                                        # checksum and host.
5052  ***      0      0                           0         if ( $line =~ m/^\S+\s+\S+\s+\d+\s+/ ) {
5053  ***      0                                  0            my ( $db, $tbl, $chunk, $host ) = $line =~ m/(\S+)/g;
5054  ***      0                                  0            $already_checksummed->{$db}->{$tbl}->{$chunk}->{$host} = 1;
5055                                                        }
5056                                                     }
5057                                                  
5058  ***      0                                  0      close $resume_fh;
5059  ***      0                                  0      MKDEBUG && _d("Already checksummed:", Dumper($already_checksummed));
5060                                                  
5061  ***      0                                  0      return $already_checksummed;
5062                                                  }
5063                                                  
5064                                                  sub already_checksummed {
5065  ***      0                    0             0      my ( $d, $t, $c, $h ) = @_; # db, tbl, chunk num, host
5066  ***      0      0                           0      if ( exists $already_checksummed->{$d}->{$t}->{$c}->{$h} ) {
5067  ***      0                                  0         MKDEBUG && _d("Skipping chunk because of --resume:", $d, $t, $c, $h);
5068  ***      0                                  0         return 1;
5069                                                     }
5070  ***      0                                  0      return 0;
5071                                                  }
5072                                                  
5073                                                  sub do_tbl_replicate {
5074  ***      0                    0             0      my ( $chunk_num, %args ) = @_;
5075  ***      0                                  0      foreach my $arg ( qw(q host query tbl hdr explain final_o ch) ) {
5076  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
5077                                                     }
5078  ***      0                                  0      my $ch      = $args{ch};
5079  ***      0                                  0      my $final_o = $args{final_o};
5080  ***      0                                  0      my $q       = $args{q};
5081  ***      0                                  0      my $host    = $args{host};
5082  ***      0                                  0      my $hdr     = $args{hdr};
5083  ***      0                                  0      my $explain = $args{explain};
5084  ***      0                                  0      my $tbl     = $args{tbl};
5085                                                  
5086  ***      0                                  0      MKDEBUG && _d('Replicating chunk', $chunk_num,
5087                                                        'of table', $tbl->{database}, '.', $tbl->{table},
5088                                                        'on', $host->{h}, ':', $host->{P});
5089                                                  
5090  ***      0                                  0      my $dbh = $host->{dbh};
5091  ***      0                                  0      $dbh->do("USE " . $q->quote($tbl->{database}));
5092                                                  
5093  ***      0                                  0      my $cnt = 'NULL';
5094  ***      0                                  0      my $crc = 'NULL';
5095  ***      0                                  0      my $beg = time();
5096  ***      0                                  0      my $sql = $ch->inject_chunks(
5097                                                        query      => $args{query},
5098                                                        database   => $tbl->{database},
5099                                                        table      => $tbl->{table},
5100                                                        chunks     => $tbl->{chunks},
5101                                                        chunk_num  => $chunk_num,
5102                                                        where      => [$final_o->get('where'), $tbl->{since}],
5103                                                        index_hint => $tbl->{index},
5104                                                     );
5105                                                  
5106  ***      0                                  0      if ( MKDEBUG && $chunk_num == 0 ) {
5107                                                        _d("SQL for inject chunk 0:", $sql);
5108                                                     }
5109                                                  
5110  ***      0                                  0      my $where = $tbl->{chunks}->[$chunk_num];
5111  ***      0      0                           0      if ( $final_o->get('explain') ) {
5112  ***      0      0                           0         if ( $chunk_num == 0 ) {
5113  ***      0      0                           0            printf($explain, @{$tbl}{qw(database table)}, $sql)
      ***      0                                  0   
5114                                                              or die "Cannot print: $OS_ERROR";
5115                                                        }
5116  ***      0      0                           0         printf($explain, @{$tbl}{qw(database table)}, $where)
      ***      0                                  0   
5117                                                           or die "Cannot print: $OS_ERROR";
5118  ***      0                                  0         return;
5119                                                     }
5120                                                  
5121                                                     # Actually run the checksum query
5122  ***      0                                  0      $dbh->do('SET @crc := "", @cnt := 0 /*!50108 , '
5123                                                            . '@@binlog_format := "STATEMENT"*/');
5124  ***      0                                  0      $dbh->do($sql, {}, @{$tbl}{qw(database table)}, $where);
      ***      0                                  0   
5125                                                  
5126                                                     # Catch any warnings thrown....
5127  ***      0                                  0      $sql = 'SHOW WARNINGS';
5128  ***      0                                  0      MKDEBUG && _d($sql);
5129  ***      0                                  0      my $warnings = $dbh->selectall_arrayref($sql, { Slice => {} } );
5130  ***      0                                  0      foreach my $warning ( @$warnings ) {
5131  ***      0      0                           0         if ( $warning->{message} =~ m/Data truncated for column 'boundaries'/ ) {
5132  ***      0                                  0            _d("Warning: WHERE clause too large for boundaries column; ",
5133                                                              "mk-table-sync may fail; value:", $where);
5134                                                        }
5135                                                        else {
5136  ***      0                                  0            die Dumper($warning);
5137                                                        }
5138                                                     }
5139                                                  
5140                                                     # Update the master_crc etc columns
5141  ***      0                                  0      $fetch_sth->execute(@{$tbl}{qw(database table)}, $chunk_num);
      ***      0                                  0   
5142  ***      0                                  0      ( $crc, $cnt ) = $fetch_sth->fetchrow_array();
5143  ***      0                                  0      $update_sth->execute($crc, $cnt, @{$tbl}{qw(database table)}, $chunk_num);
      ***      0                                  0   
5144                                                  
5145  ***      0                                  0      my $end = time();
5146  ***      0             0                    0      $crc  ||= 'NULL';
5147  ***      0      0      0                    0      if ( !$final_o->get('quiet') && !$final_o->get('explain') ) {
5148  ***      0      0                           0         if ( $final_o->get('checksum') ) {
5149  ***      0                                  0            printf($md5sum_fmt, $crc, $host->{h},
5150  ***      0      0                           0               @{$tbl}{qw(database table)}, $chunk_num)
5151                                                              or die "Cannot print: $OS_ERROR";
5152                                                        }
5153                                                        else {
5154  ***      0                                  0            printf($hdr,
5155  ***      0      0                           0               @{$tbl}{qw(database table)}, $chunk_num,
5156                                                              $host->{h}, $tbl->{struct}->{engine}, $cnt, $crc,
5157                                                              $end - $beg, 'NULL', 'NULL', 'NULL')
5158                                                                 or die "Cannot print: $OS_ERROR";
5159                                                        }
5160                                                     }
5161                                                  
5162  ***      0                                  0      return;
5163                                                  }
5164                                                  
5165                                                  sub do_tbl {
5166           9                    9           169      my ( $chunk_num, $is_master, %args ) = @_;
5167           9                                 77      foreach my $arg ( qw(du final_o ms q tc dbh host tbl hdr explain strat) ) {
5168  ***     99     50                         440         die "I need a $arg argument" unless $args{$arg};
5169                                                     }
5170           9                                 34      my $du      = $args{du};
5171           9                                 30      my $final_o = $args{final_o};
5172           9                                 29      my $ms      = $args{ms};
5173           9                                 32      my $tc      = $args{tc};
5174           9                                 28      my $tp      = $args{tp};
5175           9                                 28      my $q       = $args{q};
5176           9                                 27      my $host    = $args{host};
5177           9                                 28      my $tbl     = $args{tbl};
5178           9                                 31      my $explain = $args{explain};
5179           9                                 30      my $hdr     = $args{hdr};
5180           9                                 32      my $strat   = $args{strat};
5181                                                  
5182           9                                 23      MKDEBUG && _d('Checksumming chunk', $chunk_num,
5183                                                        'of table', $tbl->{database}, '.', $tbl->{table},
5184                                                        'on', $host->{h}, ':', $host->{P},
5185                                                        'using algorithm', $strat);
5186                                                  
5187           9                                 41      my $dbh = $host->{dbh};
5188           9                                 50      $dbh->do("USE " . $q->quote($tbl->{database}));
5189                                                  
5190           9                                 49      my $cnt = 'NULL';
5191           9                                 27      my $crc = 'NULL';
5192           9                                 28      my $sta = 'NULL';
5193           9                                 32      my $lag = 'NULL';
5194           9                                 47      my $beg = time();
5195                                                  
5196                                                     # I'm a slave.  Wait to catch up to the master.  Calculate slave lag.
5197  ***      9     50     33                   72      if ( !$is_master
      ***                   33                        
5198                                                          && $final_o->get('wait')
5199                                                          && !$final_o->get('explain') )
5200                                                     {
5201  ***      0                                  0         MKDEBUG && _d('Waiting to catch up to master', $args{dbh}->{h},
5202                                                           ':', $args{dbh}->{P});
5203  ***      0                                  0         $sta = $ms->wait_for_master(
5204                                                           $args{dbh}, $dbh, $final_o->get('wait'), 1, $tbl->{master_status});
5205  ***      0      0                           0         $sta = 'NULL' unless defined $sta;
5206                                                     }
5207  ***      9     50     33                   73      if ( !$is_master
      ***                   33                        
5208                                                          && $final_o->get('slave-lag')
5209                                                          && !$final_o->get('explain') )
5210                                                     {
5211  ***      0                                  0         my $res = $ms->get_slave_status($dbh);
5212  ***      0      0      0                    0         $lag = $res && defined $res->{seconds_behind_master}
5213                                                             ? $res->{seconds_behind_master}
5214                                                             : 'NULL';
5215                                                     }
5216                                                  
5217                                                     # Check that table exists on slave.
5218           9                                 28      my $have_table = 1;
5219  ***      9     50     33                   89      if ( !$is_master || !$checksum_table_data ) {
5220  ***      0                                  0         $have_table = $tp->check_table(
5221                                                           dbh => $dbh,
5222                                                           db  => $tbl->{database},
5223                                                           tbl => $tbl->{table},
5224                                                        );
5225  ***      0      0                           0         warn "$tbl->{database}.$tbl->{table} does not exist on slave"
      ***             0                               
      ***             0                               
5226                                                           . ($host->{h} ? " $host->{h}" : '')
5227                                                           . ($host->{P} ? ":$host->{P}" : '')
5228                                                           unless $have_table;
5229                                                     }
5230                                                  
5231                                                     # Time the checksum operation and the wait-for-master operation separately.
5232           9                                 40      my $mid = time();
5233                                                  
5234  ***      9     50                          39      if ( $have_table ) {
5235                                                        # Do the checksum operation.
5236  ***      9     50                          37         if ( $checksum_table_data ) {
5237           9    100                          59            if ( $strat eq 'CHECKSUM' ) {
      ***            50                               
5238  ***      2     50                          18               if ( $final_o->get('crc') ) {
5239           2                                 32                  $crc = do_checksum(%args);
5240                                                              }
5241  ***      2     50                          16               if ( $final_o->get('count') ) {
5242  ***      0                                  0                  $cnt = do_count($chunk_num, %args);
5243                                                              }
5244                                                           }
5245                                                           elsif ( $final_o->get('crc') ) {
5246           7                                 63               ( $cnt, $crc ) = do_var_crc($chunk_num, %args);
5247  ***      7            50                   45               $crc ||= 'NULL';
5248                                                           }
5249                                                           else {
5250  ***      0                                  0               $cnt = do_count($chunk_num, %args);
5251                                                           }
5252                                                        }
5253                                                        else { # Checksum SHOW CREATE TABLE for --schema.
5254  ***      0                                  0            my $create
5255                                                              = $du->get_create_table($dbh, $q, $tbl->{database}, $tbl->{table});
5256  ***      0                                  0            $create = $create->[1];
5257  ***      0                                  0            $create = $tp->remove_auto_increment($create);
5258  ***      0                                  0            $crc    = $tc->crc32($create);
5259                                                        }
5260                                                     }
5261                                                  
5262           9                                 46      my $end = time();
5263                                                  
5264  ***      9    100     66                   46      if ( !$final_o->get('quiet') && !$final_o->get('explain') ) {
5265           8    100                          35         if ( $final_o->get('checksum') ) {
5266           7                                101            printf($md5sum_fmt, $crc, $host->{h},
5267  ***      7     50                          32               @{$tbl}{qw(database table)}, $chunk_num)
5268                                                              or die "Cannot print: $OS_ERROR";
5269                                                        }
5270                                                        else {
5271           1                                 37            printf($hdr,
5272  ***      1     50                           6               @{$tbl}{qw(database table)}, $chunk_num,
5273                                                              $host->{h}, $tbl->{struct}->{engine}, $cnt, $crc,
5274                                                              $end - $mid, $mid - $beg, $sta, $lag)
5275                                                              or die "Cannot print: $OS_ERROR";
5276                                                        }
5277                                                     }
5278                                                  
5279           9                                 72      return;
5280                                                  }
5281                                                  
5282                                                  sub get_cxn {
5283           9                    9            76      my ( $dsn, %args ) = @_;
5284           9                                 49      foreach my $arg ( qw(o dp) ) {
5285  ***     18     50                          97         die "I need a $arg argument" unless $args{$arg};
5286                                                     }
5287           9                                 33      my $dp  = $args{dp};
5288           9                                 34      my $o   = $args{o};
5289                                                  
5290  ***      9     50     33                   45      if ( $o->get('ask-pass') && !defined $dsn->{p} ) {
5291  ***      0                                  0         $dsn->{p} = OptionParser::prompt_noecho("Enter password for $dsn->{h}: ");
5292                                                     }
5293                                                  
5294           9    100                          41      my $ac  = $o->get('lock') ? 0 : 1;
5295           9                                 66      my $dbh = $dp->get_dbh(
5296                                                        $dp->get_cxn_params($dsn), { AutoCommit => $ac });
5297           9                                 60      $dbh->{InactiveDestroy}  = 1; # Prevent destroying on fork.
5298           9                                 52      $dbh->{FetchHashKeyName} = 'NAME_lc';
5299           9                                 74      return $dbh;
5300                                                  }
5301                                                  
5302                                                  sub do_var_crc {
5303           7                    7            98      my ( $chunk_num, %args ) = @_;
5304           7                                 49      foreach my $arg ( qw(ch dbh query tbl explain final_o) ) {
5305  ***     42     50                         177         die "I need a $arg argument" unless $args{$arg};
5306                                                     }
5307           7                                 24      my $final_o = $args{final_o};
5308           7                                 22      my $ch      = $args{ch};
5309           7                                 22      my $tbl     = $args{tbl};
5310           7                                 22      my $explain = $args{explain};
5311           7                                 22      my $dbh     = $args{dbh};
5312                                                  
5313           7                                 22      MKDEBUG && _d("do_var_crc for", $tbl->{table});
5314                                                  
5315           7                                 57      my $sql = $ch->inject_chunks(
5316                                                        query      => $args{query},
5317                                                        database   => $tbl->{database},
5318                                                        table      => $tbl->{table},
5319                                                        chunks     => $tbl->{chunks},
5320                                                        chunk_num  => $chunk_num,
5321                                                        where      => [$final_o->get('where'), $tbl->{since}],
5322                                                        index_hint => $tbl->{index},
5323                                                     );
5324                                                  
5325           7                                 21      if ( MKDEBUG && $chunk_num == 0 ) {
5326                                                        _d("SQL for chunk 0:", $sql);
5327                                                     }
5328                                                  
5329  ***      7     50                          27      if ( $final_o->get('explain') ) {
5330  ***      0      0                           0         if ( $chunk_num == 0 ) {
5331  ***      0      0                           0            printf($explain, @{$tbl}{qw(database table)}, $sql)
      ***      0                                  0   
5332                                                              or die "Cannot print: $OS_ERROR";
5333                                                        }
5334  ***      0      0                           0         printf($explain, @{$tbl}{qw(database table)},$tbl->{chunks}->[$chunk_num])
      ***      0                                  0   
5335                                                           or die "Cannot print: $OS_ERROR";
5336  ***      0                                  0         return;
5337                                                     }
5338                                                  
5339           7                                659      $dbh->do('set @crc := "", @cnt := 0');
5340           7                                 76      my $res = $dbh->selectall_arrayref($sql, { Slice => {} })->[0];
5341           7                                109      return ($res->{cnt}, $res->{crc});
5342                                                  }
5343                                                  
5344                                                  sub do_checksum {
5345           2                    2            54      my ( %args ) = @_;
5346           2                                 22      foreach my $arg ( qw(dbh query tbl explain final_o) ) {
5347  ***     10     50                          61         die "I need a $arg argument" unless $args{$arg};
5348                                                     }
5349           2                                 10      my $dbh     = $args{dbh};
5350           2                                  8      my $final_o = $args{final_o};
5351           2                                  8      my $tbl     = $args{tbl};
5352           2                                  9      my $query   = $args{query};
5353           2                                  9      my $explain = $args{explain};
5354                                                  
5355           2                                  7      MKDEBUG && _d("do_checksum for", $tbl->{table});
5356                                                  
5357           2    100                          11      if ( $final_o->get('explain') ) {
5358  ***      1     50                           3         printf($explain, @{$tbl}{qw(database table)}, $query)
               1                                 24   
5359                                                           or die "Cannot print: $OS_ERROR";
5360                                                     }
5361                                                     else {
5362           1                                  4         my $res = $dbh->selectrow_hashref($query);
5363  ***      1     50                          16         if ( $res ) {
5364           1                                  8            my ($key) = grep { m/checksum/i } keys %$res;
               2                                 24   
5365  ***      1     50                          21            return defined $res->{$key} ? $res->{$key} : 'NULL';
5366                                                        }
5367                                                     }
5368                                                  
5369           1                                  7      return;
5370                                                  }
5371                                                  
5372                                                  sub do_count {
5373  ***      0                    0             0      my ( $chunk_num, %args ) = @_;
5374  ***      0                                  0      foreach my $arg ( qw(q dbh tbl explain final_o) ) {
5375  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
5376                                                     }
5377  ***      0                                  0      my $final_o = $args{final_o};
5378  ***      0                                  0      my $tbl     = $args{tbl};
5379  ***      0                                  0      my $explain = $args{explain};
5380  ***      0                                  0      my $dbh     = $args{dbh};
5381  ***      0                                  0      my $q       = $args{q};
5382                                                  
5383  ***      0                                  0      MKDEBUG && _d("do_count for", $tbl->{table});
5384                                                  
5385  ***      0                                  0      my $sql = "SELECT COUNT(*) FROM "
5386  ***      0                                  0         . $q->quote(@{$tbl}{qw(database table)});
5387  ***      0      0      0                    0      if ( $final_o->get('where') || $final_o->get('since') ) {
5388  ***      0                                  0         my $where_since = ($final_o->get('where'), $final_o->get('since'));
5389  ***      0                                  0         $sql .= " WHERE ("
5390  ***      0                                  0               . join(" AND ", map { "($_)" } grep { $_ } @$where_since )
      ***      0                                  0   
5391                                                              . ")";
5392                                                     }
5393  ***      0      0                           0      if ( $final_o->get('explain') ) {
5394  ***      0      0                           0         printf($explain, @{$tbl}{qw(database table)}, $sql)
      ***      0                                  0   
5395                                                           or die "Cannot print: $OS_ERROR";
5396                                                     }
5397                                                     else {
5398  ***      0                                  0         return $dbh->selectall_arrayref($sql)->[0]->[0];
5399                                                     }
5400                                                  
5401  ***      0                                  0      return;
5402                                                  }
5403                                                  
5404                                                  sub unique {
5405           9                    9            30      my %seen;
5406           9                                 36      grep { !$seen{$_}++ } @_;
               9                                 78   
5407                                                  }
5408                                                  
5409                                                  # Tries to extract the MySQL error message and print it
5410                                                  sub print_err {
5411  ***      0                    0                    my ( $o, $msg, $db, $tbl, $host ) = @_;
5412  ***      0      0      0                           return if !defined $msg
      ***                    0                        
5413                                                        # Honor --quiet in the (common?) event of dropped tables or deadlocks
5414                                                        or ($o->get('quiet')
5415                                                           && $EVAL_ERROR =~ m/: Table .*? doesn't exist|Deadlock found/);
5416  ***      0                                         $msg =~ s/^.*?failed: (.*?) at \S+ line (\d+).*$/$1 at line $2/s;
5417  ***      0                                         $msg =~ s/\s+/ /g;
5418  ***      0      0      0                           if ( $db && $tbl ) {
5419  ***      0                                            $msg .= " while doing $db.$tbl";
5420                                                     }
5421  ***      0      0                                  if ( $host ) {
5422  ***      0                                            $msg .= " on $host";
5423                                                     }
5424  ***      0                                         print STDERR $msg, "\n";
5425                                                  }
5426                                                  
5427                                                  sub _d {
5428  ***      0                    0                    my ($package, undef, $line) = caller 0;
5429  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
5430  ***      0                                              map { defined $_ ? $_ : 'undef' }
5431                                                          @_;
5432  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
5433                                                  }
5434                                                  
5435                                                  # ############################################################################
5436                                                  # Run the program.
5437                                                  # ############################################################################
5438                                                  if ( !caller ) { exit main(@ARGV); }
5439                                                  
5440                                                  1; # Because this is a module as well as a script.
5441                                                  
5442                                                  # ############################################################################
5443                                                  # Documentation
5444                                                  # ############################################################################
5445                                                  =pod
5446                                                  
5447                                                  =head1 NAME
5448                                                  
5449                                                  mk-table-checksum - Perform an online replication consistency check, or
5450                                                  checksum MySQL tables efficiently on one or many servers.
5451                                                  
5452                                                  =head1 SYNOPSIS
5453                                                  
5454                                                  STOP! Are you checksumming a slave(s) against its master?  Then be sure to learn
5455                                                  what L<"--replicate"> does.  It is probably the option you want to use.
5456                                                  
5457                                                     mk-table-checksum --replicate=mydb.checksum master-host
5458                                                     ... time passses, replication catches up ...
5459                                                     mk-table-checksum --replicate=mydb.checksum --replicate-check 2 master-host
5460                                                  
5461                                                  Or,
5462                                                  
5463                                                     mk-table-checksum h=host1,u=user,p=password h=host2 ...
5464                                                  
5465                                                  Or,
5466                                                  
5467                                                     mk-table-checksum host1 host2 ... hostN | mk-checksum-filter
5468                                                  
5469                                                  See L<"SPECIFYING HOSTS"> for more on the syntax of the host arguments.
5470                                                  
5471                                                  =head1 RISKS
5472                                                  
5473                                                  The following section is included to inform users about the potential risks,
5474                                                  whether known or unknown, of using this tool.  The two main categories of risks
5475                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
5476                                                  tools) and those created by bugs.
5477                                                  
5478                                                  mk-table-checksum executes queries that cause the MySQL server to checksum its
5479                                                  data.  This can cause significant server load.  It is read-only unless you use
5480                                                  the L<"--replicate"> option, in which case it inserts a small amount of data
5481                                                  into the specified table.
5482                                                  
5483                                                  At the time of this release, we know of no bugs that could cause serious harm to
5484                                                  users.  There are miscellaneous bugs that might be annoying.
5485                                                  
5486                                                  The authoritative source for updated information is always the online issue
5487                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
5488                                                  see a list of such issues at the following URL:
5489                                                  L<http://www.maatkit.org/bugs/mk-table-checksum>.
5490                                                  
5491                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
5492                                                  
5493                                                  =head1 DESCRIPTION
5494                                                  
5495                                                  mk-table-checksum generates table checksums for MySQL tables, typically
5496                                                  useful for verifying your slaves are in sync with the master.  The checksums
5497                                                  are generated by a query on the server, and there is very little network
5498                                                  traffic as a result.
5499                                                  
5500                                                  Checksums typically take about twice as long as COUNT(*) on very large InnoDB
5501                                                  tables in my tests.  For smaller tables, COUNT(*) is a good bit faster than
5502                                                  the checksums.  See L<"--algorithm"> for more details on performance.
5503                                                  
5504                                                  If you specify more than one server, mk-table-checksum assumes the first
5505                                                  server is the master and others are slaves.  Checksums are parallelized for
5506                                                  speed, forking off a child process for each table.  Duplicate server names are
5507                                                  ignored, but if you want to checksum a server against itself you can use two
5508                                                  different forms of the hostname (for example, "localhost 127.0.0.1", or
5509                                                  "h=localhost,P=3306 h=localhost,P=3307").
5510                                                  
5511                                                  If you want to compare the tables in one database to those in another database
5512                                                  on the same server, just checksum both databases:
5513                                                  
5514                                                     mk-table-checksum --databases db1,db2
5515                                                  
5516                                                  You can then use L<mk-checksum-filter> to compare the results in both databases
5517                                                  easily.
5518                                                  
5519                                                  mk-table-checksum examines table structure only on the first host specified,
5520                                                  so if anything differs on the others, it won't notice.  It ignores views.
5521                                                  
5522                                                  The checksums work on MySQL version 3.23.58 through 6.0-alpha.  They will not
5523                                                  necessarily produce the same values on all versions.  Differences in
5524                                                  formatting and/or space-padding between 4.1 and 5.0, for example, will cause
5525                                                  the checksums to be different.
5526                                                  
5527                                                  =head1 SPECIFYING HOSTS
5528                                                  
5529                                                  mk-table-checksum connects to a theoretically unlimited number of MySQL
5530                                                  servers.  You specify a list of one or more host definitions on the command
5531                                                  line, such as "host1 host2".  Each host definition can be just a hostname, or it
5532                                                  can be a complex string that specifies connection options as well.  You can
5533                                                  specify connection options two ways:
5534                                                  
5535                                                  =over
5536                                                  
5537                                                  =item *
5538                                                  
5539                                                  Format a host definition in a key=value,key=value form.  If an argument on the
5540                                                  command line contains the letter '=', mk-table-checksum will parse it into
5541                                                  its component parts.  Examine the L<"--help"> output for details on the allowed
5542                                                  keys.
5543                                                  
5544                                                  Specifying a list of simple host definitions "host1 host2" is equivalent to the
5545                                                  more complicated "h=host1 h=host2" format.
5546                                                  
5547                                                  =item *
5548                                                  
5549                                                  With the command-line options such as L<"--user"> and L<"--password">.  These
5550                                                  options, if given, apply globally to all host definitions.
5551                                                  
5552                                                  =back
5553                                                  
5554                                                  In addition to specifying connection options this way, mk-table-checksum
5555                                                  allows shortcuts.  Any options specified for the first host definition on the
5556                                                  command line fill in missing values in subsequent ones.  Any options that are
5557                                                  still missing after this are filled in from the command-line options if
5558                                                  possible.
5559                                                  
5560                                                  In other words, the places you specify connection options have precedence:
5561                                                  highest precedence is the option specified directly in the host definition, next
5562                                                  is the option specified in the first host definition, and lowest is the
5563                                                  command-line option.
5564                                                  
5565                                                  You can mix simple and complex host definitions and/or command-line arguments.
5566                                                  For example, if all your servers except one of your slaves uses a non-standard
5567                                                  port number:
5568                                                  
5569                                                     mk-table-checksum --port 4500 master h=slave1,P=3306 slave2 slave3
5570                                                  
5571                                                  If you are confused about how mk-table-checksum will connect to your servers,
5572                                                  give the L<"--explain-hosts"> option and it will tell you.
5573                                                  
5574                                                  =head1 HOW FAST IS IT?
5575                                                  
5576                                                  Speed and efficiency are important, because the typical use case is checksumming
5577                                                  large amounts of data.
5578                                                  
5579                                                  C<mk-table-checksum> is designed to do very little work itself, and generates
5580                                                  very little network traffic aside from inspecting table structures with C<SHOW
5581                                                  CREATE TABLE>.  The results of checksum queries are typically 40-character or
5582                                                  shorter strings.
5583                                                  
5584                                                  The MySQL server does the bulk of the work, in the form of the checksum queries.
5585                                                  The following benchmarks show the checksum query times for various checksum
5586                                                  algorithms.  The first two results are simply running C<COUNT(col8)> and
5587                                                  C<CHECKSUM TABLE> on the table.  C<CHECKSUM TABLE> is just C<CRC32> under the
5588                                                  hood, but it's implemented inside the storage engine layer instead of at the
5589                                                  MySQL layer.
5590                                                  
5591                                                   ALGORITHM       HASH FUNCTION  EXTRA           TIME
5592                                                   ==============  =============  ==============  =====
5593                                                   COUNT(col8)                                    2.3
5594                                                   CHECKSUM TABLE                                 5.3
5595                                                   BIT_XOR         FNV_64                         12.7
5596                                                   ACCUM           FNV_64                         42.4
5597                                                   BIT_XOR         MD5            --optimize-xor  80.0
5598                                                   ACCUM           MD5                            87.4
5599                                                   BIT_XOR         SHA1           --optimize-xor  90.1
5600                                                   ACCUM           SHA1                           101.3
5601                                                   BIT_XOR         MD5                            172.0
5602                                                   BIT_XOR         SHA1                           197.3
5603                                                  
5604                                                  The tests are entirely CPU-bound.  The sample data is an InnoDB table with the
5605                                                  following structure:
5606                                                  
5607                                                   CREATE TABLE test (
5608                                                     col1 int NOT NULL,
5609                                                     col2 date NOT NULL,
5610                                                     col3 int NOT NULL,
5611                                                     col4 int NOT NULL,
5612                                                     col5 int,
5613                                                     col6 decimal(3,1),
5614                                                     col7 smallint unsigned NOT NULL,
5615                                                     col8 timestamp NOT NULL,
5616                                                     PRIMARY KEY  (col2, col1),
5617                                                     KEY (col7),
5618                                                     KEY (col1)
5619                                                   ) ENGINE=InnoDB
5620                                                  
5621                                                  The table has 4303585 rows, 365969408 bytes of data and 173457408 bytes of
5622                                                  indexes.  The server is a Dell PowerEdge 1800 with dual 32-bit Xeon 2.8GHz
5623                                                  processors and 2GB of RAM.  The tests are fully CPU-bound, and the server is
5624                                                  otherwise idle.  The results are generally consistent to within a tenth of a
5625                                                  second on repeated runs.
5626                                                  
5627                                                  C<CRC32> is the default checksum function to use, and should be enough for most
5628                                                  cases.  If you need stronger guarantees that your data is identical, you should
5629                                                  use one of the other functions.
5630                                                  
5631                                                  =head1 ALGORITHM SELECTION
5632                                                  
5633                                                  The L<"--algorithm"> option allows you to specify which algorithm you would
5634                                                  like to use, but it does not guarantee that mk-table-checksum will use this
5635                                                  algorithm.  mk-table-checksum will ultimately select the best algorithm possible
5636                                                  given various factors such as the MySQL version and other command line options.
5637                                                  
5638                                                  The three basic algorithms in descending order of preference are CHECKSUM,
5639                                                  BIT_XOR and ACCUM.  CHECKSUM cannot be used if any one of these criteria
5640                                                  is true:
5641                                                  
5642                                                    * L<"--where"> is used.
5643                                                    * L<"--since"> is used.
5644                                                    * L<"--chunk-size"> is used.
5645                                                    * L<"--replicate"> is used.
5646                                                    * L<"--count"> is used.
5647                                                    * MySQL version less than 4.1.1.
5648                                                  
5649                                                  The BIT_XOR algorithm also requires MySQL version 4.1.1 or later.
5650                                                  
5651                                                  After checking these criteria, if the requested L<"--algorithm"> remains then it
5652                                                  is used, otherwise the first remaining algorithm with the highest preference
5653                                                  is used.
5654                                                  
5655                                                  =head1 CONSISTENT CHECKSUMS
5656                                                  
5657                                                  If you are using this tool to verify your slaves still have the same data as the
5658                                                  master, which is why I wrote it, you should read this section.
5659                                                  
5660                                                  The best way to do this with replication is to use the L<"--replicate"> option.
5661                                                  When the queries are finished running on the master and its slaves, you can go
5662                                                  to the slaves and issue SQL queries to see if any tables are different from the
5663                                                  master.  Try the following:
5664                                                  
5665                                                    SELECT db, tbl, chunk, this_cnt-master_cnt AS cnt_diff,
5666                                                       this_crc <> master_crc OR ISNULL(master_crc) <> ISNULL(this_crc)
5667                                                          AS crc_diff
5668                                                    FROM checksum
5669                                                    WHERE master_cnt <> this_cnt OR master_crc <> this_crc
5670                                                       OR ISNULL(master_crc) <> ISNULL(this_crc);
5671                                                  
5672                                                  The L<"--replicate-check"> option can do this query for you.  If you can't use
5673                                                  this method, try the following:
5674                                                  
5675                                                  =over
5676                                                  
5677                                                  =item *
5678                                                  
5679                                                  If your servers are not being written to, you can just run the tool with no
5680                                                  further ado:
5681                                                  
5682                                                    mk-table-checksum server1 server2 ... serverN
5683                                                  
5684                                                  =item *
5685                                                  
5686                                                  If the servers are being written to, you need some way to make sure they are
5687                                                  consistent at the moment you run the checksums.  For situations other than
5688                                                  master-slave replication, you will have to figure this out yourself.  You may be
5689                                                  able to use the L<"--where"> option with a date or time column to only checksum
5690                                                  data that's not recent.
5691                                                  
5692                                                  =item *
5693                                                  
5694                                                  If you are checksumming a master and slaves, you can do a fast parallel
5695                                                  checksum and assume the slaves are caught up to the master.  In practice, this
5696                                                  tends to work well except for tables which are constantly updated.  You can
5697                                                  use the L<"--slave-lag"> option to see how far behind each slave was when it
5698                                                  checksummed a given table.  This can help you decide whether to investigate
5699                                                  further.
5700                                                  
5701                                                  =item *
5702                                                  
5703                                                  The next most disruptive technique is to lock the table on the master, then take
5704                                                  checksums.  This should prevent changes from propagating to the slaves.  You can
5705                                                  just lock on the master (with L<"--lock">), or you can both lock on the master
5706                                                  and wait on the slaves till they reach that point in the master's binlog
5707                                                  (L<"--wait">).  Which is better depends on your workload; only you know that.
5708                                                  
5709                                                  =item *
5710                                                  
5711                                                  If you decide to make the checksums on the slaves wait until they're guaranteed
5712                                                  to be caught up to the master, the algorithm looks like this:
5713                                                  
5714                                                   For each table,
5715                                                     Master: lock table
5716                                                     Master: get pos
5717                                                     In parallel,
5718                                                       Master: checksum
5719                                                       Slave(s): wait for pos, then checksum
5720                                                     End
5721                                                     Master: unlock table
5722                                                   End
5723                                                  
5724                                                  =back
5725                                                  
5726                                                  What I typically do when I'm not using the L<"--replicate"> option is simply run
5727                                                  the tool on all servers with no further options.  This runs fast, parallel,
5728                                                  non-blocking checksums simultaneously.  If there are tables that look different,
5729                                                  I re-run with L<"--wait">=600 on the tables in question.  This makes the tool
5730                                                  lock on the master as explained above.
5731                                                  
5732                                                  =head1 OUTPUT
5733                                                  
5734                                                  Output is to STDOUT, one line per server and table, with header lines for each
5735                                                  database.  I tried to make the output easy to process with awk.  For this reason
5736                                                  columns are always present.  If there's no value, mk-table-checksum prints
5737                                                  'NULL'.
5738                                                  
5739                                                  The default is column-aligned output for human readability, but you can change
5740                                                  it to tab-separated if you want.  Use the L<"--tab"> option for this.
5741                                                  
5742                                                  Output is unsorted, though all lines for one table should be output together.
5743                                                  For speed, all checksums are done in parallel (as much as possible) and may
5744                                                  complete out of the order in which they were started.  You might want to run
5745                                                  them through another script or command-line utility to make sure they are in the
5746                                                  order you want.  If you pipe the output through L<mk-checksum-filter>, you
5747                                                  can sort the output and/or avoid seeing output about tables that have no
5748                                                  differences.
5749                                                  
5750                                                  The columns in the output are as follows.  The database, table, and chunk come
5751                                                  first so you can sort by them easily (they are the "primary key").
5752                                                  
5753                                                  Output from L<"--replicate-check"> and L<"--checksum"> are different.
5754                                                  
5755                                                  =over
5756                                                  
5757                                                  =item DATABASE
5758                                                  
5759                                                  The database the table is in.
5760                                                  
5761                                                  =item TABLE
5762                                                  
5763                                                  The table name.
5764                                                  
5765                                                  =item CHUNK
5766                                                  
5767                                                  The chunk (see L<"--chunk-size">).  Zero if you are not doing chunked checksums.
5768                                                  
5769                                                  =item HOST
5770                                                  
5771                                                  The server's hostname.
5772                                                  
5773                                                  =item ENGINE
5774                                                  
5775                                                  The table's storage engine.
5776                                                  
5777                                                  =item COUNT
5778                                                  
5779                                                  The table's row count, unless you specified to skip it.
5780                                                  
5781                                                  =item CHECKSUM
5782                                                  
5783                                                  The table's checksum, unless you specified to skip it or the table has no rows.
5784                                                  some types of checksums will be 0 if there are no rows; others will print NULL.
5785                                                  
5786                                                  =item TIME
5787                                                  
5788                                                  The time the actual checksum and/or counting took.
5789                                                  
5790                                                  =item WAIT
5791                                                  
5792                                                  How long the checksum blocked before beginning.
5793                                                  
5794                                                  =item STAT
5795                                                  
5796                                                  The return value of MASTER_POS_WAIT().
5797                                                  
5798                                                  =item LAG
5799                                                  
5800                                                  How far the slave lags the master, as reported by SHOW SLAVE STATUS.
5801                                                  
5802                                                  =back
5803                                                  
5804                                                  =head1 EXIT STATUS
5805                                                  
5806                                                  A successful exit status is 0.  If there is an error checksumming any table,
5807                                                  the exit status is 1.
5808                                                  
5809                                                  When running L<"--replicate-check">, if any slave has chunks that differ from
5810                                                  the master, the exit status is 1.
5811                                                  
5812                                                  =head1 QUERIES
5813                                                  
5814                                                  If you are using innotop (see L<http://code.google.com/p/innotop>),
5815                                                  mytop, or another tool to watch currently running MySQL queries, you may see
5816                                                  the checksum queries.  They look similar to this:
5817                                                  
5818                                                    REPLACE /*test.test_tbl:'2'/'5'*/ INTO test.checksum(db, ...
5819                                                  
5820                                                  Since mk-table-checksum's queries run for a long time and tend to be
5821                                                  textually very long, and thus won't fit on one screen of these monitoring
5822                                                  tools, I've been careful to place a comment at the beginning of the query so
5823                                                  you can see what it is and what it's doing.  The comment contains the name of
5824                                                  the table that's being checksummed, the chunk it is currently checksumming,
5825                                                  and how many chunks will be checksummed.  In the case above, it is
5826                                                  checksumming chunk 2 of 5 in table test.test_tbl.
5827                                                  
5828                                                  =head1 OPTIONS
5829                                                  
5830                                                  L<"--schema"> is restricted to option groups Connection, Filter, Output, Help, Config.
5831                                                  
5832                                                  =over
5833                                                  
5834                                                  =item --algorithm
5835                                                  
5836                                                  type: string
5837                                                  
5838                                                  Checksum algorithm (ACCUM|CHECKSUM|BIT_XOR).
5839                                                  
5840                                                  Specifies which checksum algorithm to use.  Valid arguments are CHECKSUM,
5841                                                  BIT_XOR and ACCUM.  The latter two do cryptographic hash checksums.
5842                                                  See also L<"ALGORITHM SELECTION">.
5843                                                  
5844                                                  CHECKSUM is built into MySQL, but has some disadvantages.  BIT_XOR and ACCUM are
5845                                                  implemented by SQL queries.  They use a cryptographic hash of all columns
5846                                                  concatenated together with a separator, followed by a bitmap of each nullable
5847                                                  column that is NULL (necessary because CONCAT_WS() skips NULL columns).
5848                                                  
5849                                                  CHECKSUM is the default.  This method uses MySQL's built-in CHECKSUM TABLE
5850                                                  command, which is a CRC32 behind the scenes.  It cannot be used before MySQL
5851                                                  4.1.1, and various options disable it as well.  It does not simultaneously count
5852                                                  rows; that requires an extra COUNT(*) query.  This is a good option when you are
5853                                                  using MyISAM tables with live checksums enabled; in this case both the COUNT(*)
5854                                                  and CHECKSUM queries will run very quickly.
5855                                                  
5856                                                  The BIT_XOR algorithm is available for MySQL 4.1.1 and newer.  It uses
5857                                                  BIT_XOR(), which is order-independent, to reduce all the rows to a single
5858                                                  checksum.
5859                                                  
5860                                                  ACCUM uses a user variable as an accumulator.  It reduces each row to a single
5861                                                  checksum, which is concatenated with the accumulator and re-checksummed.  This
5862                                                  technique is order-dependent.  If the table has a primary key, it will be used
5863                                                  to order the results for consistency; otherwise it's up to chance.
5864                                                  
5865                                                  The pathological worst case is where identical rows will cancel each other out
5866                                                  in the BIT_XOR.  In this case you will not be able to distinguish a table full
5867                                                  of one value from a table full of another value.  The ACCUM algorithm will
5868                                                  distinguish them.
5869                                                  
5870                                                  However, the ACCUM algorithm is order-dependent, so if you have two tables
5871                                                  with identical data but the rows are out of order, you'll get different
5872                                                  checksums with ACCUM.
5873                                                  
5874                                                  If a given algorithm won't work for some reason, mk-table-checksum falls back to
5875                                                  another.  The least common denominator is ACCUM, which works on MySQL 3.23.2 and
5876                                                  newer.
5877                                                  
5878                                                  =item --arg-table
5879                                                  
5880                                                  type: string
5881                                                  
5882                                                  The database.table with arguments for each table to checksum.
5883                                                  
5884                                                  This table may be named anything you wish.  It must contain at least the
5885                                                  following columns:
5886                                                  
5887                                                    CREATE TABLE checksum_args (
5888                                                       db         char(64)     NOT NULL,
5889                                                       tbl        char(64)     NOT NULL,
5890                                                       -- other columns as desired
5891                                                       PRIMARY KEY (db, tbl)
5892                                                    );
5893                                                  
5894                                                  In addition to the columns shown, it may contain any of the other columns listed
5895                                                  here (Note: this list is used by the code, MAGIC_overridable_args):
5896                                                  
5897                                                    algorithm chunk-size columns count crc function lock modulo no-use-index
5898                                                    offset optimize-xor probability separator save-since single-chunk since
5899                                                    since-column sleep sleep-coef trim wait where
5900                                                  
5901                                                  Each of these columns corresponds to the long form of a command-line option.
5902                                                  Each column should be NULL-able.  Column names with hyphens should be enclosed
5903                                                  in backticks (e.g. `chunk-size`) when the table is created.  The data type does
5904                                                  not matter, but it's suggested you use a sensible data type to prevent garbage
5905                                                  data.
5906                                                  
5907                                                  When C<mk-table-checksum> checksums a table, it will look for a matching entry
5908                                                  in this table.  Any column that has a defined value will override the
5909                                                  corresponding command-line argument for the table being currently processed.
5910                                                  In this way it is possible to specify custom command-line arguments for any
5911                                                  table.
5912                                                  
5913                                                  If you add columns to the table that aren't in the above list of allowable
5914                                                  columns, it's an error.  The exceptions are C<db>, C<tbl>, and C<ts>.  The C<ts>
5915                                                  column can be used as a timestamp for easy visibility into the last time the
5916                                                  C<since> column was updated with L<"--save-since">.
5917                                                  
5918                                                  This table is assumed to be located on the first server given on the
5919                                                  command-line.
5920                                                  
5921                                                  =item --ask-pass
5922                                                  
5923                                                  group: Connection
5924                                                  
5925                                                  Prompt for a password when connecting to MySQL.
5926                                                  
5927                                                  =item --check-interval
5928                                                  
5929                                                  type: time; default: 1s
5930                                                  
5931                                                  How often to check for slave lag if L<"--check-slave-lag"> is given.
5932                                                  
5933                                                  =item --check-slave-lag
5934                                                  
5935                                                  type: string
5936                                                  
5937                                                  Pause checksumming each chunk until the specified DSN's slave lag is less than
5938                                                  L<"--max-lag">.
5939                                                  
5940                                                  =item --checksum
5941                                                  
5942                                                  group: Output
5943                                                  
5944                                                  Print checksums and table names in the style of md5sum (disables
5945                                                  L<"--[no]count">).
5946                                                  
5947                                                  Makes the output behave more like the output of C<md5sum>.  The checksum is
5948                                                  first on the line, followed by the host, database, table, and chunk number,
5949                                                  concatenated with dots.
5950                                                  
5951                                                  =item --chunk-size
5952                                                  
5953                                                  type: string
5954                                                  
5955                                                  Approximate number of rows or size of data to checksum at a time.  Allowable
5956                                                  suffixes are k, M, G. Disallows C<--algorithm CHECKSUM>.
5957                                                  
5958                                                  If you specify a chunk size, mk-table-checksum will try to find an index that
5959                                                  will let it split the table into ranges of approximately L<"--chunk-size">
5960                                                  rows, based on the table's index statistics.  Currently only numeric and date
5961                                                  types can be chunked.
5962                                                  
5963                                                  If the table is chunkable, mk-table-checksum will checksum each range separately
5964                                                  with parameters in the checksum query's WHERE clause.  If mk-table-checksum
5965                                                  cannot find a suitable index, it will do the entire table in one chunk as though
5966                                                  you had not specified L<"--chunk-size"> at all.  Each table is handled
5967                                                  individually, so some tables may be chunked and others not.
5968                                                  
5969                                                  The chunks will be approximately sized, and depending on the distribution of
5970                                                  values in the indexed column, some chunks may be larger than the value you
5971                                                  specify.
5972                                                  
5973                                                  If you specify a suffix (one of k, M or G), the parameter is treated as a data
5974                                                  size rather than a number of rows.  The output of SHOW TABLE STATUS is then used
5975                                                  to estimate the amount of data the table contains, and convert that to a number
5976                                                  of rows.
5977                                                  
5978                                                  =item --columns
5979                                                  
5980                                                  type: array; group: Filter
5981                                                  
5982                                                  Checksum only this comma-separated list of columns.
5983                                                  
5984                                                  =item --config
5985                                                  
5986                                                  type: Array; group: Config
5987                                                  
5988                                                  Read this comma-separated list of config files; if specified, this must be the
5989                                                  first option on the command line.
5990                                                  
5991                                                  =item --[no]count
5992                                                  
5993                                                  Count rows in tables.  This is built into ACCUM and BIT_XOR, but requires an
5994                                                  extra query for CHECKSUM.
5995                                                  
5996                                                  This is disabled by default to avoid an extra COUNT(*) query when
5997                                                  L<"--algorithm"> is CHECKSUM.  If you have only MyISAM tables and live checksums
5998                                                  are enabled, both CHECKSUM and COUNT will be very fast, but otherwise you may
5999                                                  want to use one of the other algorithms.
6000                                                  
6001                                                  =item --[no]crc
6002                                                  
6003                                                  default: yes
6004                                                  
6005                                                  Do a CRC (checksum) of tables.
6006                                                  
6007                                                  Take the checksum of the rows as well as their count.  This is enabled by
6008                                                  default.  If you disable it, you'll just get COUNT(*) queries.
6009                                                  
6010                                                  =item --create-replicate-table
6011                                                  
6012                                                  Create the replicate table given by L<"--replicate"> if it does not exist.
6013                                                  
6014                                                  Normally, if the replicate table given by L<"--replicate"> does not exist,
6015                                                  C<mk-table-checksum> will die. With this option, however, C<mk-table-checksum>
6016                                                  will create the replicate table for you, using the database.table name given to
6017                                                  L<"--replicate">.
6018                                                  
6019                                                  The structure of the replicate table is the same as the suggested table
6020                                                  mentioned in L<"--replicate">. Note that since ENGINE is not specified, the
6021                                                  replicate table will use the server's default storage engine.  If you want to
6022                                                  use a different engine, you need to create the table yourself.
6023                                                  
6024                                                  =item --databases
6025                                                  
6026                                                  short form: -d; type: hash; group: Filter
6027                                                  
6028                                                  Only checksum this comma-separated list of databases.
6029                                                  
6030                                                  =item --defaults-file
6031                                                  
6032                                                  short form: -F; type: string; group: Connection
6033                                                  
6034                                                  Only read mysql options from the given file.  You must give an absolute
6035                                                  pathname.
6036                                                  
6037                                                  =item --empty-replicate-table
6038                                                  
6039                                                  Empty table given by L<"--replicate"> before starting.
6040                                                  
6041                                                  Issues a DELETE against the table given by L<"--replicate"> before beginning
6042                                                  work.  Ignored if L<"--replicate"> is not specified.  This can be useful to
6043                                                  remove entries related to tables that no longer exist, or just to clean out the
6044                                                  results of a previous run.
6045                                                  
6046                                                  =item --engines
6047                                                  
6048                                                  short form: -e; type: hash; group: Filter
6049                                                  
6050                                                  Do only this comma-separated list of storage engines.
6051                                                  
6052                                                  =item --explain
6053                                                  
6054                                                  group: Output
6055                                                  
6056                                                  Show, but do not execute, checksum queries (disables L<"--empty-replicate-table">).
6057                                                  
6058                                                  =item --explain-hosts
6059                                                  
6060                                                  group: Help
6061                                                  
6062                                                  Print connection information and exit.
6063                                                  
6064                                                  Print out a list of hosts to which mk-table-checksum will connect, with all
6065                                                  the various connection options, and exit.  See L<"SPECIFYING HOSTS">.
6066                                                  
6067                                                  =item --float-precision
6068                                                  
6069                                                  type: int
6070                                                  
6071                                                  Precision for C<FLOAT> and C<DOUBLE> column comparisons.
6072                                                  
6073                                                  If you specify this option, FLOAT and DOUBLE columns will be rounded to the
6074                                                  specified number of digits after the decimal point for the checksum.  This can
6075                                                  avoid checksum mismatches due to different floating-point representations of
6076                                                  the same values on different MySQL versions and hardware.
6077                                                  
6078                                                  =item --function
6079                                                  
6080                                                  type: string
6081                                                  
6082                                                  Hash function for checksums (FNV1A_64, MURMUR_HASH, SHA1, MD5, CRC32, etc).
6083                                                  
6084                                                  You can use this option to choose the cryptographic hash function used for
6085                                                  L<"--algorithm">=ACCUM or L<"--algorithm">=BIT_XOR.  The default is to use
6086                                                  C<CRC32>, but C<MD5> and C<SHA1> also work, and you can use your own function,
6087                                                  such as a compiled UDF, if you wish.  Whatever function you specify is run in
6088                                                  SQL, not in Perl, so it must be available to MySQL.
6089                                                  
6090                                                  The C<FNV1A_64> UDF mentioned in the benchmarks is much faster than C<MD5>.  The
6091                                                  C++ source code is distributed with Maatkit.  It is very simple to compile and
6092                                                  install; look at the header in the source code for instructions.  If it is
6093                                                  installed, it is preferred over C<MD5>.  You can also use the MURMUR_HASH
6094                                                  function if you compile and install that as a UDF; the source is also
6095                                                  distributed with Maatkit, and it is faster and has better distribution
6096                                                  than FNV1A_64.
6097                                                  
6098                                                  =item --help
6099                                                  
6100                                                  group: Help
6101                                                  
6102                                                  Show help and exit.
6103                                                  
6104                                                  =item --ignore-columns
6105                                                  
6106                                                  type: array; group: Filter
6107                                                  
6108                                                  Ignore this comma-separated list of columns when calculating the checksum.
6109                                                  
6110                                                  This option only affects the checksum when using the ACCUM or BIT_XOR
6111                                                  L<"--algorithm">.
6112                                                  
6113                                                  =item --ignore-databases
6114                                                  
6115                                                  type: hash; group: Filter
6116                                                  
6117                                                  Ignore this comma-separated list of databases.
6118                                                  
6119                                                  =item --ignore-engines
6120                                                  
6121                                                  type: Hash; default: FEDERATED,MRG_MyISAM; group: Filter
6122                                                  
6123                                                  Ignore this comma-separated list of storage engines.
6124                                                  
6125                                                  =item --ignore-tables
6126                                                  
6127                                                  type: hash; group: Filter
6128                                                  
6129                                                  Ignore this comma-separated list of tables.
6130                                                  
6131                                                  Table names may be qualified with the database name.
6132                                                  
6133                                                  =item --lock
6134                                                  
6135                                                  Lock on master until done on slaves (implies L<"--slave-lag">).
6136                                                  
6137                                                  This option can help you to get a consistent read on a master and many slaves.
6138                                                  If you specify this option, mk-table-checksum will lock the table on the
6139                                                  first server on the command line, which it assumes to be the master.  It will
6140                                                  keep this lock until the checksums complete on the other servers.
6141                                                  
6142                                                  This option isn't very useful by itself, so you probably want to use L<"--wait">
6143                                                  instead.
6144                                                  
6145                                                  Note: if you're checksumming a slave against its master, you should use
6146                                                  L<"--replicate">.  In that case, there's no need for locking, waiting, or any of
6147                                                  that.
6148                                                  
6149                                                  =item --max-lag
6150                                                  
6151                                                  type: time; default: 1s
6152                                                  
6153                                                  Suspend checksumming if the slave given by L<"--check-slave-lag"> lags.
6154                                                  
6155                                                  This option causes mk-table-checksum to look at the slave every time it's about
6156                                                  to checksum a chunk.  If the slave's lag is greater than the option's value, or
6157                                                  if the slave isn't running (so its lag is NULL), mk-table-checksum sleeps for
6158                                                  L<"--check-interval"> seconds and then looks at the lag again.  It repeats until
6159                                                  the slave is caught up, then proceeds to checksum the chunk.
6160                                                  
6161                                                  This option is useful to let you checksum data as fast as the slaves can handle
6162                                                  it, assuming the slave you directed mk-table-checksum to monitor is
6163                                                  representative of all the slaves that may be replicating from this server.  It
6164                                                  should eliminate the need for L<"--sleep"> or L<"--sleep-coef">.
6165                                                  
6166                                                  =item --modulo
6167                                                  
6168                                                  type: int
6169                                                  
6170                                                  Do only every Nth chunk on chunked tables.
6171                                                  
6172                                                  This option lets you checksum only some chunks of the table.  This is a useful
6173                                                  alternative to L<"--probability"> when you want to be sure you get full coverage
6174                                                  in some specified number of runs; for example, you can do only every 7th chunk,
6175                                                  and then use L<"--offset"> to rotate the modulo every day of the week.
6176                                                  
6177                                                  Just like with L<"--probability">, a table that cannot be chunked is done every
6178                                                  time.
6179                                                  
6180                                                  =item --no-use-index
6181                                                  
6182                                                  Do not add USE INDEX hint to SQL statements.
6183                                                  
6184                                                  By default C<mk-table-checksum> adds a C<USE INDEX> hint to each SQL statement
6185                                                  to coerce MySQL into using the index for the column by which a table will be
6186                                                  chunked.  This option causes C<mk-table-checksum> to omit C<USE INDEX> hints.
6187                                                  
6188                                                  =item --offset
6189                                                  
6190                                                  type: string; default: 0
6191                                                  
6192                                                  Modulo offset expression for use with L<"--modulo">.
6193                                                  
6194                                                  The argument may be an SQL expression, such as C<WEEKDAY(NOW())> (which returns
6195                                                  a number from 0 through 6).  The argument is evaluated by MySQL.  The result is
6196                                                  used as follows: if chunk_num % L<"--modulo"> == L<"--offset">, the chunk will
6197                                                  be checksummed.
6198                                                  
6199                                                  =item --[no]optimize-xor
6200                                                  
6201                                                  default: yes
6202                                                  
6203                                                  Optimize BIT_XOR with user variables.
6204                                                  
6205                                                  This option specifies to use user variables to reduce the number of times each
6206                                                  row must be passed through the cryptographic hash function when you are using
6207                                                  the BIT_XOR algorithm.
6208                                                  
6209                                                  With the optimization, the queries look like this in pseudo-code:
6210                                                  
6211                                                    SELECT CONCAT(
6212                                                       BIT_XOR(SLICE_OF(@user_variable)),
6213                                                       BIT_XOR(SLICE_OF(@user_variable)),
6214                                                       ...
6215                                                       BIT_XOR(SLICE_OF(@user_variable := HASH(col1, col2... colN))));
6216                                                  
6217                                                  The exact positioning of user variables and calls to the hash function is
6218                                                  determined dynamically, and will vary between MySQL versions.  Without the
6219                                                  optimization, it looks like this:
6220                                                  
6221                                                    SELECT CONCAT(
6222                                                       BIT_XOR(SLICE_OF(MD5(col1, col2... colN))),
6223                                                       BIT_XOR(SLICE_OF(MD5(col1, col2... colN))),
6224                                                       ...
6225                                                       BIT_XOR(SLICE_OF(MD5(col1, col2... colN))));
6226                                                  
6227                                                  The difference is the number of times all the columns must be mashed together
6228                                                  and fed through the hash function.  If you are checksumming really large
6229                                                  columns, such as BLOB or TEXT columns, this might make a big difference.
6230                                                  
6231                                                  =item --password
6232                                                  
6233                                                  short form: -p; type: string; group: Connection
6234                                                  
6235                                                  Password to use when connecting.
6236                                                  
6237                                                  =item --pid
6238                                                  
6239                                                  type: string
6240                                                  
6241                                                  Create the given PID file.  The file contains the process ID of the script.
6242                                                  The PID file is removed when the script exits.  Before starting, the script
6243                                                  checks if the PID file already exists.  If it does not, then the script creates
6244                                                  and writes its own PID to it.  If it does, then the script checks the following:
6245                                                  if the file contains a PID and a process is running with that PID, then
6246                                                  the script dies; or, if there is no process running with that PID, then the
6247                                                  script overwrites the file with its own PID and starts; else, if the file
6248                                                  contains no PID, then the script dies.
6249                                                  
6250                                                  =item --port
6251                                                  
6252                                                  short form: -P; type: int; group: Connection
6253                                                  
6254                                                  Port number to use for connection.
6255                                                  
6256                                                  =item --probability
6257                                                  
6258                                                  type: int; default: 100
6259                                                  
6260                                                  Checksums will be run with this percent probability.
6261                                                  
6262                                                  This is an integer between 1 and 100.  If 100, every chunk of every table will
6263                                                  certainly be checksummed.  If less than that, there is a chance that some chunks
6264                                                  of some tables will be skipped.  This is useful for routine jobs designed to
6265                                                  randomly sample bits of tables without checksumming the whole server.  By
6266                                                  default, if a table is not chunkable, it will be checksummed every time even
6267                                                  when the probability is less than 100.  You can override this with
6268                                                  L<"--single-chunk">.
6269                                                  
6270                                                  See also L<"--modulo">.
6271                                                  
6272                                                  =item --quiet
6273                                                  
6274                                                  short form: -q; group: Output
6275                                                  
6276                                                  Do not print checksum results.
6277                                                  
6278                                                  =item --recheck
6279                                                  
6280                                                  Re-checksum chunks that L<"--replicate-check"> found to be different.
6281                                                  
6282                                                  =item --recursion-method
6283                                                  
6284                                                  type: string
6285                                                  
6286                                                  Preferred recursion method used to find slaves for L<"--replicate-check">.
6287                                                  
6288                                                  Possible methods are:
6289                                                  
6290                                                    METHOD       USES
6291                                                    ===========  ================
6292                                                    processlist  SHOW PROCESSLIST
6293                                                    hosts        SHOW SLAVE HOSTS
6294                                                  
6295                                                  The processlist method is preferred because SHOW SLAVE HOSTS is not reliable.
6296                                                  However, the hosts method is required if the server uses a non-standard
6297                                                  port (not 3306).  Usually mk-table-checksum does the right thing and finds
6298                                                  the slaves, but you may give a preferred method and it will be used first.
6299                                                  If it doesn't find any slaves, the other methods will be tried.
6300                                                  
6301                                                  =item --replicate
6302                                                  
6303                                                  type: string
6304                                                  
6305                                                  Replicate checksums to slaves (disallows --algorithm CHECKSUM).
6306                                                  
6307                                                  This option enables a completely different checksum strategy for a consistent,
6308                                                  lock-free checksum across a master and its slaves.  This works only with
6309                                                  statement-based replication (mk-table-checksum will switch the binlog format
6310                                                  to STATEMENT for the duration of the session if your server uses row-based
6311                                                  replication).  Instead of running the checksum queries on each server, you run
6312                                                  it only on the master.  You specify a table to insert the results into.  The
6313                                                  query will insert directly into the table, so it will be replicated through the
6314                                                  binlog to the slaves.
6315                                                  
6316                                                  The argument to the option is the table (fully qualified: db.table) in which the
6317                                                  checksums should be stored. The table must have at least these columns: db, tbl,
6318                                                  chunk, boundaries, this_crc, master_crc, this_cnt, master_cnt.  The table may be
6319                                                  named anything you wish.  Here is a suggested table structure, which is
6320                                                  automatically used for L<"--create-replicate-table"> (MAGIC_create_replicate):
6321                                                  
6322                                                    CREATE TABLE checksum (
6323                                                       db         char(64)     NOT NULL,
6324                                                       tbl        char(64)     NOT NULL,
6325                                                       chunk      int          NOT NULL,
6326                                                       boundaries char(100)    NOT NULL,
6327                                                       this_crc   char(40)     NOT NULL,
6328                                                       this_cnt   int          NOT NULL,
6329                                                       master_crc char(40)         NULL,
6330                                                       master_cnt int              NULL,
6331                                                       ts         timestamp    NOT NULL,
6332                                                       PRIMARY KEY (db, tbl, chunk)
6333                                                    );
6334                                                  
6335                                                  Be sure to choose an appropriate storage engine for the checksum table.  If you
6336                                                  are checksumming InnoDB tables, for instance, a deadlock will break replication
6337                                                  if the checksum table is non-transactional, because the transaction will still
6338                                                  be written to the binlog.  It will then replay without a deadlock on the
6339                                                  slave and break replication with "different error on master and slave."  This
6340                                                  is not a problem with mk-table-checksum, it's a problem with MySQL
6341                                                  replication, and you can read more about it in the MySQL manual.
6342                                                  
6343                                                  When the queries are finished replicating, you can run a simple query on each
6344                                                  slave to see which tables have differences from the master.  See L<"CONSISTENT
6345                                                  CHECKSUMS"> for details.  If you find tables that have differences, you can use
6346                                                  the chunk boundaries in a WHERE clause with L<mk-table-sync> to help repair
6347                                                  them more efficiently.  See L<mk-table-sync> for details.
6348                                                  
6349                                                  This option eliminates the need to do complicated locking and unlocking, waiting
6350                                                  for master binlog positions, and so on.  It disables L<"--lock">, L<"--wait">,
6351                                                  and L<"--slave-lag">.
6352                                                  
6353                                                  The checksum queries actually do a REPLACE into this table, so existing rows
6354                                                  need not be removed before running.  However, you may wish to do this anyway to
6355                                                  remove rows related to tables that don't exist anymore.  The
6356                                                  L<"--empty-replicate-table"> option does this for you.
6357                                                  
6358                                                  Since mk-table-checksum uses USE to select the table's database as its
6359                                                  default database before executing the checksum query, the checksum queries
6360                                                  should replicate to slaves even if --binlog-do-db settings on the master filter
6361                                                  out the checksum table's database.  For more information on how --binlog-do-db
6362                                                  works, see L<http://dev.mysql.com/doc/en/binary-log.html>.
6363                                                  
6364                                                  If the slaves have any --replicate-do-X or replicate-ignore-X options, you
6365                                                  should be careful not to checksum any databases or tables that exist on the
6366                                                  master and not the slaves.  Changes to such tables may not normally be executed
6367                                                  on the slaves because of the --replicate-X options, but the checksum queries
6368                                                  change the checksum table, not the tables they checksum.  Therefore these
6369                                                  queries will be executed on the slave, and if the table or database does not
6370                                                  exist, they will cause replication to fail.  For more information on replication
6371                                                  rules, see L<http://dev.mysql.com/doc/en/replication-rules.html>.
6372                                                  
6373                                                  The table specified by L<"--replicate"> will never be checksummed itself.
6374                                                  
6375                                                  =item --replicate-check
6376                                                  
6377                                                  type: int
6378                                                  
6379                                                  Check results in L<"--replicate"> table, to the specified depth.
6380                                                  
6381                                                  Recursively finds differences recorded in the table given by L<"--replicate">.
6382                                                  Recurses to the depth you specify: 0 is no recursion (check only the server
6383                                                  you specify), 1 is check the server and its slaves, 2 is check the slaves of
6384                                                  its slaves, and so on.
6385                                                  
6386                                                  It finds differences by running the query shown in L<"CONSISTENT CHECKSUMS">,
6387                                                  and prints results.  Exits after printing.  This is just a convenient way of
6388                                                  running the query so you don't have to do it manually.
6389                                                  
6390                                                  The output is one informational line per slave host, followed by the results
6391                                                  of the query, if any.  If L<"--quiet"> is specified, there is no output.
6392                                                  
6393                                                  This option makes C<mk-table-checksum> looks for slaves by running C<SHOW
6394                                                  PROCESSLIST>.  If it finds connections that appear to be from slaves, it
6395                                                  derives
6396                                                  connection information for each slave the same default-and-override method
6397                                                  described in L<"SPECIFYING HOSTS">.
6398                                                  
6399                                                  If C<SHOW PROCESSLIST> doesn't return any rows, C<mk-table-checksum> looks at
6400                                                  C<SHOW SLAVE HOSTS> instead.  The host and port, and user and password if
6401                                                  available, from C<SHOW SLAVE HOSTS> are combined into a DSN and used as the
6402                                                  argument.  This requires slaves to be configured with C<report-host>,
6403                                                  C<report-port> and so on.
6404                                                  
6405                                                  This requires the @@SERVER_ID system variable, so it works only on MySQL
6406                                                  3.23.26 or newer.
6407                                                  
6408                                                  If any slave has chunks that differ from the master, mk-table-checksum's
6409                                                  exit status is 1; otherwise it is 0.
6410                                                  
6411                                                  =item --resume
6412                                                  
6413                                                  type: string
6414                                                  
6415                                                  Resume checksum using given output file from a previously interrupted run.
6416                                                  
6417                                                  The given output file should be the literal output from a previous run of
6418                                                  C<mk-table-checksum>.  For example:
6419                                                  
6420                                                     mk-table-checksum host1 host2 -C 100 > checksum_results.txt
6421                                                     mk-table-checksum host1 host2 -C 100 --resume checksum_results.txt
6422                                                  
6423                                                  The command line options given to the first run and the resumed run must
6424                                                  be identical (except, of course, for --resume).  If they are not, the result
6425                                                  will be unpredictible and probably wrong.
6426                                                  
6427                                                  L<"--resume"> does not work with L<"--replicate">; for that, use
6428                                                  L<"--resume-replicate">.
6429                                                  
6430                                                  =item --resume-replicate
6431                                                  
6432                                                  Resume L<"--replicate">.
6433                                                  
6434                                                  This option resumes a previous checksum operation using L<"--replicate">.
6435                                                  It is like L<"--resume"> but does not require an output file.  Instead,
6436                                                  it uses the checksum table given to L<"--replicate"> to determine where to
6437                                                  resume the checksum operation.
6438                                                  
6439                                                  =item --save-since
6440                                                  
6441                                                  When L<"--arg-table"> and L<"--since"> are given, save the current L<"--since">
6442                                                  value into that table's C<since> column after checksumming.  In this way you can
6443                                                  incrementally checksum tables by starting where the last one finished.
6444                                                  
6445                                                  The value to be saved could be the current timestamp, or it could be the maximum
6446                                                  existing value of the column given by L<"--since-column">.  It depends on what
6447                                                  options are in effect.  See the description of L<"--since"> to see how
6448                                                  timestamps are different from ordinary values.
6449                                                  
6450                                                  =item --schema
6451                                                  
6452                                                  Checksum C<SHOW CREATE TABLE> intead of table data.
6453                                                  
6454                                                  =item --separator
6455                                                  
6456                                                  type: string; default: #
6457                                                  
6458                                                  The separator character used for CONCAT_WS().
6459                                                  
6460                                                  This character is used to join the values of columns when checksumming with
6461                                                  L<"--algorithm"> of BIT_XOR or ACCUM.
6462                                                  
6463                                                  =item --set-vars
6464                                                  
6465                                                  type: string; default: wait_timeout=10000; group: Connection
6466                                                  
6467                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this
6468                                                  string will be appended to SET and executed.
6469                                                  
6470                                                  =item --since
6471                                                  
6472                                                  type: string
6473                                                  
6474                                                  Checksum only data newer than this value.
6475                                                  
6476                                                  If the table is chunk-able or nibble-able, this value will apply to the first
6477                                                  column of the chunked or nibbled index.
6478                                                  
6479                                                  This is not too different to L<"--where">, but instead of universally applying a
6480                                                  WHERE clause to every table, it selectively finds the right column to use and
6481                                                  applies it only if such a column is found.  See also L<"--since-column">.
6482                                                  
6483                                                  The argument may be an expression, which is evaluated by MySQL.  For example,
6484                                                  you can specify C<CURRENT_DATE - INTERVAL 7 DAY> to get the date of one week
6485                                                  ago.
6486                                                  
6487                                                  A special bit of extra magic: if the value is temporal (looks like a date or
6488                                                  datetime), then the table is checksummed only if the create time (or last
6489                                                  modified time, for tables that report the last modified time, such as MyISAM
6490                                                  tables) is newer than the value.  In this sense it's not applied as a WHERE
6491                                                  clause at all.
6492                                                  
6493                                                  =item --since-column
6494                                                  
6495                                                  type: string
6496                                                  
6497                                                  The column name to be used for L<"--since">.
6498                                                  
6499                                                  The default is for the tool to choose the best one automatically.  If you
6500                                                  specify a value, that will be used if possible; otherwise the best
6501                                                  auto-determined one; otherwise none.  If the column doesn't exist in the table,
6502                                                  it is just ignored.
6503                                                  
6504                                                  =item --single-chunk
6505                                                  
6506                                                  Permit skipping with L<"--probability"> if there is only one chunk.
6507                                                  
6508                                                  Normally, if a table isn't split into many chunks, it will always be
6509                                                  checksummed regardless of L<"--probability">.  This setting lets the
6510                                                  probabilistic behavior apply to tables that aren't divided into chunks.
6511                                                  
6512                                                  =item --slave-lag
6513                                                  
6514                                                  Report how far slaves lag master.
6515                                                  
6516                                                  If this option is enabled, the output will show how many seconds behind the
6517                                                  master each slave is.  This can be useful when you want a fast, parallel,
6518                                                  non-blocking checksum, and you know your slaves might lag the master.  You can
6519                                                  inspect the results and make an educated guess whether any discrepancies on the
6520                                                  slave are due to slave lag instead of corrupt data.
6521                                                  
6522                                                  If you're using L<"--replicate">, slave lag is a non-issue and you don't need to
6523                                                  worry about this.
6524                                                  
6525                                                  =item --sleep
6526                                                  
6527                                                  type: int
6528                                                  
6529                                                  Sleep time between checksums.
6530                                                  
6531                                                  If this option is specified, mk-table-checksum will sleep the specified
6532                                                  number of seconds between checksums.  That is, it will sleep between every
6533                                                  table, and if you specify L<"--chunk-size">, it will also sleep between chunks.
6534                                                  
6535                                                  This is a very crude way to throttle checksumming; see L<"--sleep-coef"> and
6536                                                  L<"--check-slave-lag">.
6537                                                  
6538                                                  =item --sleep-coef
6539                                                  
6540                                                  type: float
6541                                                  
6542                                                  Calculate L<"--sleep"> as a multiple of the last checksum time.
6543                                                  
6544                                                  If this option is specified, mk-table-checksum will sleep the amount of
6545                                                  time elapsed during the previous checksum, multiplied by the specified
6546                                                  coefficient.  This option is ignored if L<"--sleep"> is specified.
6547                                                  
6548                                                  This is a slightly more sophisticated way to throttle checksum speed: sleep a
6549                                                  varying amount of time between chunks, depending on how long the chunks are
6550                                                  taking.  Even better is to use L<"--check-slave-lag"> if you're checksumming
6551                                                  master/slave replication.
6552                                                  
6553                                                  =item --socket
6554                                                  
6555                                                  short form: -S; type: string; group: Connection
6556                                                  
6557                                                  Socket file to use for connection.
6558                                                  
6559                                                  =item --tab
6560                                                  
6561                                                  group: Output
6562                                                  
6563                                                  Print tab-separated output, not column-aligned output.
6564                                                  
6565                                                  =item --tables
6566                                                  
6567                                                  short form: -t; type: hash; group: Filter
6568                                                  
6569                                                  Do only this comma-separated list of tables.
6570                                                  
6571                                                  Table names may be qualified with the database name.
6572                                                  
6573                                                  =item --trim
6574                                                  
6575                                                  Trim C<VARCHAR> columns (helps when comparing 4.1 to >= 5.0).
6576                                                  
6577                                                  This option adds a C<TRIM()> to C<VARCHAR> columns in C<BIT_XOR> and C<ACCUM>
6578                                                  modes.
6579                                                  
6580                                                  This is useful when you don't care about the trailing space differences between
6581                                                  MySQL versions which vary in their handling of trailing spaces. MySQL 5.0 and 
6582                                                  later all retain trailing spaces in C<VARCHAR>, while previous versions would 
6583                                                  remove them.
6584                                                  
6585                                                  =item --user
6586                                                  
6587                                                  short form: -u; type: string; group: Connection
6588                                                  
6589                                                  User for login if not current user.
6590                                                  
6591                                                  =item --[no]verify
6592                                                  
6593                                                  default: yes
6594                                                  
6595                                                  Verify checksum compatibility across servers.
6596                                                  
6597                                                  This option runs a trivial checksum on all servers to ensure they have
6598                                                  compatible CONCAT_WS() and cryptographic hash functions.
6599                                                  
6600                                                  Versions of MySQL before 4.0.14 will skip empty strings and NULLs in
6601                                                  CONCAT_WS, and others will only skip NULLs.  The two kinds of behavior will
6602                                                  produce different results if you have any columns containing the empty string
6603                                                  in your table.  If you know you don't (for instance, all columns are
6604                                                  integers), you can safely disable this check and you will get a reliable
6605                                                  checksum even on servers with different behavior.
6606                                                  
6607                                                  =item --version
6608                                                  
6609                                                  group: Help
6610                                                  
6611                                                  Show version and exit.
6612                                                  
6613                                                  =item --wait
6614                                                  
6615                                                  short form: -w; type: time
6616                                                  
6617                                                  Wait this long for slaves to catch up to their master (implies L<"--lock">
6618                                                  L<"--slave-lag">).
6619                                                  
6620                                                  Note: the best way to verify that a slave is in sync with its master is to use
6621                                                  L<"--replicate"> instead.  The L<"--wait"> option is really only useful if
6622                                                  you're trying to compare masters and slaves without using L<"--replicate">,
6623                                                  which is possible but complex and less efficient in some ways.
6624                                                  
6625                                                  This option helps you get a consistent checksum across a master server and its
6626                                                  slaves.  It combines locking and waiting to accomplish this.  First it locks the
6627                                                  table on the master (the first server on the command line).  Then it finds the
6628                                                  master's binlog position.  Checksums on slaves will be deferred until they reach
6629                                                  the same binlog position.
6630                                                  
6631                                                  The argument to the option is the number of seconds to wait for the slaves to
6632                                                  catch up to the master.  It is actually the argument to MASTER_POS_WAIT().  If
6633                                                  the slaves don't catch up to the master within this time, they will unblock
6634                                                  and go ahead with the checksum.  You can tell whether this happened by
6635                                                  examining the STAT column in the output, which is the return value of
6636                                                  MASTER_POS_WAIT().
6637                                                  
6638                                                  =item --where
6639                                                  
6640                                                  type: string
6641                                                  
6642                                                  Do only rows matching this C<WHERE> clause (disallows L<"--algorithm"> CHECKSUM).
6643                                                  
6644                                                  You can use this option to limit the checksum to only part of the table.  This
6645                                                  is particularly useful if you have append-only tables and don't want to
6646                                                  constantly re-check all rows; you could run a daily job to just check
6647                                                  yesterday's rows, for instance.
6648                                                  
6649                                                  This option is much like the -w option to mysqldump.  Do not specify the WHERE
6650                                                  keyword.  You may need to quote the value.  Here is an example:
6651                                                  
6652                                                    mk-table-checksum --where "foo=bar"
6653                                                  
6654                                                  =back
6655                                                  
6656                                                  =head1 DOWNLOADING
6657                                                  
6658                                                  You can download Maatkit from Google Code at
6659                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
6660                                                  easily with a command like the following:
6661                                                  
6662                                                     wget http://www.maatkit.org/get/toolname
6663                                                     or
6664                                                     wget http://www.maatkit.org/trunk/toolname
6665                                                  
6666                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
6667                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
6668                                                  needed.  The first URL gets the latest released version of the tool, and the
6669                                                  second gets the latest trunk code from Subversion.
6670                                                  
6671                                                  =head1 ENVIRONMENT
6672                                                  
6673                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
6674                                                  the Maatkit tools:
6675                                                  
6676                                                     MKDEBUG=1 mk-....
6677                                                  
6678                                                  =head1 SYSTEM REQUIREMENTS
6679                                                  
6680                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
6681                                                  installed in any reasonably new version of Perl.
6682                                                  
6683                                                  =head1 BUGS
6684                                                  
6685                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-table-checksum>.
6686                                                  
6687                                                  Please use Google Code Issues and Groups to report bugs or request support:
6688                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
6689                                                  discuss Maatkit.
6690                                                  
6691                                                  Please include the complete command-line used to reproduce the problem you are
6692                                                  seeing, the version of all MySQL servers involved, the complete output of the
6693                                                  tool when run with L<"--version">, and if possible, debugging output produced by
6694                                                  running with the C<MKDEBUG=1> environment variable.
6695                                                  
6696                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
6697                                                  
6698                                                  This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
6699                                                  Feedback and improvements are welcome.
6700                                                  
6701                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
6702                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
6703                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
6704                                                  
6705                                                  This program is free software; you can redistribute it and/or modify it under
6706                                                  the terms of the GNU General Public License as published by the Free Software
6707                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
6708                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
6709                                                  licenses.
6710                                                  
6711                                                  You should have received a copy of the GNU General Public License along with
6712                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
6713                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
6714                                                  
6715                                                  =head1 SEE ALSO
6716                                                  
6717                                                  See also L<mk-checksum-filter> and L<mk-table-sync>.
6718                                                  
6719                                                  =head1 AUTHOR
6720                                                  
6721                                                  Baron "Xaprb" Schwartz
6722                                                  
6723                                                  =head1 ABOUT MAATKIT
6724                                                  
6725                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
6726                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
6727                                                  code contributors.  Both are employed by Percona.  Financial support for
6728                                                  Maatkit development is primarily provided by Percona and its clients. 
6729                                                  
6730                                                  =head1 ACKNOWLEDGEMENTS
6731                                                  
6732                                                  This is an incomplete list.  My apologies for omissions or misspellings.
6733                                                  
6734                                                  Claus Jeppesen,
6735                                                  Francois Saint-Jacques,
6736                                                  Giuseppe Maxia,
6737                                                  Heikki Tuuri,
6738                                                  James Briggs,
6739                                                  Martin Friebe,
6740                                                  Sergey Zhuravlev,
6741                                                  
6742                                                  =head1 VERSION
6743                                                  
6744                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5719 $.
6745                                                  
6746                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
49    ***     50      0      9   unless $args{$arg}
58    ***     50      0      9   unless $ddl
59    ***     50      9      0   if (ref $ddl eq 'ARRAY')
60    ***     50      9      0   if (lc $$ddl[0] eq 'table') { }
70    ***     50      0      9   if (not $ddl =~ /CREATE (?:TEMPORARY )?TABLE `/)
76    ***     50      9      0   if $name
94    ***     50      0      9   unless $type
96    ***     50      9      0   if ($type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/)
100          100      1      8   if (not $def =~ /NOT NULL/)
104          100      8      1   $def =~ /AUTO_INCREMENT/i ? :
135   ***      0      0      0   unless ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
149   ***      0      0      0   if ($index)
152   ***      0      0      0   if (not $best)
153   ***      0      0      0   if ($index) { }
166   ***      0      0      0   unless $where
172   ***      0      0      0   if ($$expl{'possible_keys'}) { }
176   ***      0      0      0   if ($$expl{'key'})
196   ***      0      0      0   unless $args{$arg}
210   ***      0      0      0   if ($EVAL_ERROR)
214   ***      0      0      0   if (not $$row[0] or $$row[0] ne $tbl)
220   ***      0      0      0   unless $args{'all_privs'}
227   ***      0      0      0   if ($EVAL_ERROR)
231   ***      0      0      0   if (not scalar keys %$row)
242   ***      0      0      0   $EVAL_ERROR ? :
247   ***      0      0      0   if (not $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete)
273   ***     50      0      8   if $key =~ /FOREIGN/
278   ***     50      8      0   if (not $engine =~ /MEMORY|HEAP/)
285   ***     50      0      8   if ($$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i)
292   ***     50      8      0   $key =~ /PRIMARY|UNIQUE/ ? :
316   ***     50      0      8   if ($engine =~ /InnoDB/i and not $clustered_key)
318   ***      0      0      0   if ($$this_key{'name'} eq 'PRIMARY') { }
      ***      0      0      0   elsif ($$this_key{'is_unique'} and not $$this_key{'is_nullable'}) { }
342   ***      0      0      0   if (not $parent =~ /\./ and $$opts{'database'})
371   ***      0      0      0   if (($$tbl_struct{'engine'} || '') =~ /InnoDB/i) { }
385   ***      0      0      0   if (@sec_indexes)
402   ***      0      0      0   defined $_ ? :
435   ***     50      0     18   unless defined $args{$arg}
448   ***      0      0      0   $comp & 1 ? :
458   ***     50      7      0   if (uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64')
478          100      1      6   if ($type eq 'bigint' and $length < 20)
492   ***     50      0      9   if $alg and not $ALGOS{$alg}
495   ***     50      0      9   if ($args{'where'} or $args{'chunk'} or $args{'replicate'} or not $vp->version_ge($dbh, '4.1.1'))
504   ***     50      0      9   if (not $vp->version_ge($dbh, '4.1.1'))
509          100      7      2   if ($alg and grep {$_ eq $alg;} @choices)
514   ***     50      0      2   if ($args{'count'} and grep {$_ ne 'CHECKSUM';} @choices)
531   ***     50      7      0   if ($args{'function'})
544   ***     50      0      7   if ($EVAL_ERROR and $EVAL_ERROR =~ /failed: (.*?) at \S+ line/)
550   ***     50      0      7   unless $result
559   ***     50      0      2   if $func =~ /^(?:FNV1A_64|FNV_64|CRC32)$/i
566   ***     50      0      2   length $unsliced < 16 ? :
579          100      3      2   if ($sliced ne $unsliced)
586   ***     50      2      0   if ($sliced eq $unsliced) { }
599   ***     50      0     16   unless defined $args{$arg}
606          100     13      8   if ($len > 16)
615          100      7      1   if (defined $opt_slice and $opt_slice < @slices) { }
638   ***     50      0      7   $args{'cols'} ? :
643   ***     50      0      7   if ($type eq 'timestamp') { }
      ***     50      0      7   elsif ($type =~ /float|double/ and $args{'float_precision'}) { }
      ***     50      0      7   elsif ($type =~ /varchar/ and $args{'trim'}) { }
660   ***     50      7      0   if (uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64') { }
662   ***     50      0      7   if (@nulls)
669   ***     50      0      7   @cols > 1 ? :
685   ***     50      0     54   unless $args{$arg}
693   ***     50      0      9   unless $algorithm and $ALGOS{$algorithm}
696          100      2      7   if ($algorithm eq 'CHECKSUM')
702          100      3      4   if ($algorithm eq 'BIT_XOR') { }
703   ***     50      0      3   if ($crc_type =~ /int$/) { }
712          100      1      3   if ($crc_type =~ /int$/) { }
725   ***     50      0      7   if ($args{'replicate'}) { }
731   ***     50      0      7   $args{'buffer'} ? :
761   ***      0      0      0   defined $_ ? :
801   ***     50      0      9   unless $args{$arg}
807   ***     50      9      0   exists $args{'strict'} ? :
850   ***     50      0      9   unless open my $fh, '<', $file
870          100   6813      9   unless $para =~ /^=head1 OPTIONS/
875          100      9      9   if $para =~ /^=over/
883   ***     50      0      9   unless $para
886          100    549      9   if (my($option) = $para =~ /^=item --(.*)/)
893          100    441    108   if ($para =~ /: /) { }
897   ***     50      0    729   unless $attributes{$attrib}
901          100     90    351   if ($attribs{'short form'})
917   ***     50      0    549   if $para =~ /^=item/
919          100     36    513   if (my($base_option) = $option =~ /^\[no\](.*)/)
924          100     90    459   $attribs{'short form'} ? :
             100     36    513   $attribs{'negatable'} ? :
      ***     50      0    549   $attribs{'cumulative'} ? :
             100    342    207   $attribs{'type'} ? :
             100     81    468   $attribs{'default'} ? :
             100    207    342   $attribs{'group'} ? :
936   ***     50      0   1458   unless $para
939          100      9   1449   if ($para =~ /^=head1/)
943          100    549    900   if $para =~ /^=item --/
947   ***     50      0      9   unless @specs
958          100    549      9   if (ref $opt) { }
963   ***     50      0    549   if (not $long)
968   ***     50      0    549   if exists $$self{'opts'}{$long}
971   ***     50      0    549   if (length $long == 1)
976          100     90    459   if ($short) { }
977   ***     50      0     90   if exists $$self{'short_opts'}{$short}
986          100     36    513   $$opt{'spec'} =~ /!/ ? :
987   ***     50      0    549   $$opt{'spec'} =~ /\+/ ? :
988   ***     50      0    549   $$opt{'desc'} =~ /required/ ? :
1000  ***     50      0    549   if ($type and $type eq 'd' and not $$self{'dp'})
1005         100    108    441   if $type and $type =~ /[HhAadzm]/
1007         100     81    468   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
1008  ***     50     81      0   defined $def ? :
1012         100      9    540   if ($long eq 'config')
1016         100     18    531   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
1029  ***     50      0      9   if ($opt =~ /mutually exclusive|one and only one/)
1034  ***     50      0      9   if ($opt =~ /at least one|one and only one/)
1039  ***     50      0      9   if ($opt =~ /default to/)
1044  ***     50      9      0   if ($opt =~ /restricted to option groups/)
1054  ***     50      0      9   unless $rule_ok
1071  ***     50      0     27   unless exists $$self{'opts'}{$long}
1095  ***      0      0      0   unless exists $$self{'opts'}{$long}
1115  ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50     52      0   exists $$self{'opts'}{$opt} ? :
1120  ***     50      0     52   if ($$opt{'is_cumulative'}) { }
1135  ***     50      0    459   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100     90    459   exists $$self{'defaults'}{$long} ? :
1144  ***     50      0      9   if (@ARGV and $ARGV[0] eq '--config')
1148  ***     50      9      0   if ($self->has('config'))
1154  ***     50     36      0   if ($EVAL_ERROR)
1155  ***     50      0     36   $self->got('config') ? :
1170  ***     50      0      9   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
1173  ***     50      0      9   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
1174  ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
1180  ***     50      0      9   if (@ARGV and $$self{'strict'})
1186  ***      0      0      0   if (@set > 1)
1197  ***      0      0      0   if (@set == 0)
1207         100     52    497   if ($$opt{'got'}) { }
      ***     50      0    497   elsif ($$opt{'is_required'}) { }
1208         100      8     44   if (exists $$self{'disables'}{$long})
1215  ***     50      0     52   if (exists $$self{'allowed_groups'}{$long})
1227  ***      0      0      0   if $restricted_opt eq $long
1228  ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
1233  ***      0      0      0   if (@restricted_opts)
1235  ***      0      0      0   if (@restricted_opts == 1) { }
1264         100    207    342   unless $opt and $$opt{'type'}
1267         100     18    324   if ($val and $$opt{'type'} eq 'm') { }
      ***     50      0    324   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0    324   elsif ($val and $$opt{'type'} eq 'z') { }
             100     27    297   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100      9    288   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
1270  ***     50      0     18   if (not $suffix)
1276  ***     50     18      0   if ($suffix =~ /[smhd]/) { }
1277  ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***     50     18      0   $suffix eq 's' ? :
1292  ***      0      0      0   if ($from_key)
1303  ***      0      0      0   if (defined $num) { }
1304  ***      0      0      0   if ($factor)
1331         100     54    697   length $opt == 1 ? :
1332  ***     50      0    751   unless $long and exists $$self{'opts'}{$long}
1339  ***     50      0     36   length $opt == 1 ? :
1340  ***     50      0     36   unless $long and exists $$self{'opts'}{$long}
1347         100     72    287   length $opt == 1 ? :
1348         100    332     27   defined $long ? :
1353  ***     50      0      8   length $opt == 1 ? :
1354  ***     50      0      8   unless $long and exists $$self{'opts'}{$long}
1381  ***      0      0      0   unless $ENV{'DONT_BREAK_LINES'}
1389  ***     50      0      9   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0      9   elsif (scalar @{$$self{'errors'};}) { }
1390  ***      0      0      0   unless print $self->print_usage
1394  ***      0      0      0   unless print $self->print_errors
1403  ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
1412  ***      0      0      0   unless $$self{'got_opts'}
1415  ***      0      0      0   $$_{'is_negatable'} ? :
1419  ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
1435  ***      0      0      0   $group eq 'default' ? :
1441  ***      0      0      0   $$opt{'is_negatable'} ? :
1444  ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
1453  ***      0      0      0   if ($short) { }
1462  ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
1466  ***      0      0      0   if ($$self{'dp'})
1474  ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
1486  ***      0      0      0   if ref $_[0] eq 'OptionParser'
1489  ***      0      0      0   unless print $prompt
1497  ***      0      0      0   unless print "\n"
1500  ***      0      0      0   if ($EVAL_ERROR)
1522  ***     50     36      0   unless open my $fh, '<', $filename
1530  ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
1533  ***      0      0      0   if ($line eq '--')
1538  ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
1556  ***     50      0      9   unless open my $fh, '<', $file
1560         100   5805      9   unless $para =~ /^=pod$/m
1564         100   1170      9   unless $para =~ /$regex/
1569  ***     50      0      9   unless close $fh
1583  ***      0      0      0   $ref eq 'ARRAY' ? :
      ***     50    549      0   $ref eq 'HASH' ? :
             100    180    549   !$ref ? :
1598  ***      0      0      0   defined $_ ? :
1684         100      9    141   if (@_ > 2)
1693  ***     50      0     50   if (not $dsn)
1705         100    138      8   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1717  ***     50      0    400   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1723         100    254    146   if (not defined $final_props{$key})
1730  ***     50      0    146   unless exists $opts{$key}
1733  ***     50      0     50   if (my $required = $self->prop('required'))
1735  ***      0      0      0   unless $final_props{$key}
1744  ***     50      0      9   unless ref $o eq 'OptionParser'
1747         100     45     27   if $o->has($_)
1757  ***      0      0      0   unless ref $dsn
1758  ***      0      0      0   $_ eq 'p' ? :
1759  ***      0      0      0   if defined $$dsn{$_}
1772  ***      0      0      0   $opts{$key}{'copy'} ? :
1786  ***     50      0     41   if ($driver eq 'Pg') { }
1818  ***     50      0     41   $cxn_string =~ /charset=utf8/ ? :
1827  ***     50      0     41   if (not $have_dbi)
1846  ***     50     41      0   if ($cxn_string =~ /mysql/i)
1854  ***     50      0     41   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1859  ***      0      0      0   if ($charset eq 'utf8') { }
1860  ***      0      0      0   unless binmode STDOUT, ':utf8'
1864  ***      0      0      0   unless binmode STDOUT
1868         100      9     32   if ($self->prop('set-vars'))
1875  ***     50      0     41   if (not $dbh and $EVAL_ERROR)
1877  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1890  ***      0      0      0   if (not $tries)
1912  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1929  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1939  ***      0      0      0   unless $dsn_1
1940  ***      0      0      0   unless $dsn_2
1944  ***      0      0      0   if ($args{'overwrite'}) { }
1945  ***      0      0      0   defined $$dsn_1{$key} ? :
1948  ***      0      0      0   defined $$dsn_2{$key} ? :
1957  ***      0      0      0   defined $_ ? :
1995         100     10     17   if (not $$self{$dbh})
1999  ***     50     27      0   $$self{$dbh} ge $self->parse($target) ? :
2006  ***      0      0      0   defined $_ ? :
2056  ***     50      0      9   unless defined $args{'cache'}
2064  ***      0      0      0   if ($what eq 'table') { }
      ***      0      0      0   elsif ($what eq 'triggers') { }
      ***      0      0      0   elsif ($what eq 'view') { }
2066  ***      0      0      0   unless $ddl
2067  ***      0      0      0   if ($$ddl[0] eq 'table') { }
2081  ***      0      0      0   if ($trgs and @$trgs) { }
2084  ***      0      0      0   if ($$trg{'sql_mode'})
2088  ***      0      0      0   if ($$trg{'definer'})
2120         100      9      9   if (not $new)
2127  ***     50      0      9   if ($curr and $new and $curr eq $new)
2139  ***     50      9      0   if (not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl})
2152  ***     50      0      9   if ($EVAL_ERROR)
2162  ***     50      9      0   if ($key) { }
2178  ***      0      0      0   if (not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl})
2208  ***      0      0      0   if (not $$self{'cache'} or not $$self{'triggers'}{$db})
2221  ***      0      0      0   if ($sth->rows)
2234  ***      0      0      0   if ($tbl)
2242  ***      0      0      0   if (not $$self{'cache'} or not $$self{'databases'} or $like)
2245  ***      0      0      0   if ($like)
2253  ***      0      0      0   unless $like
2261  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_status'}{$db} or $like)
2264  ***      0      0      0   if ($like)
2279  ***      0      0      0   unless $like
2287  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_list'}{$db} or $like)
2290  ***      0      0      0   if ($like)
2298  ***      0      0      0   ($$_[1] || '') eq 'VIEW' ? :
2305  ***      0      0      0   unless $like
2313  ***      0      0      0   defined $_ ? :
2346  ***     50      0     18   unless $args{$arg}
2361  ***     50      0      9   unless $args{$arg}
2368  ***     50      0      8   unless $$index{'type'} eq 'BTREE'
2372  ***     50      0      8   if ($args{'exact'})
2373  ***      0      0      0   unless $$index{'is_unique'} and @{$$index{'cols'};} == 1
2386  ***     50      0      8   unless $int_types{$$tbl_struct{'type_for'}{$col}} or $real_types{$$tbl_struct{'type_for'}{$col}}
2392  ***     50      0      9   if $args{'exact'} and scalar @candidate_cols
2402         100      8      1   if ($$tbl_struct{'keys'}{'PRIMARY'})
2425  ***      0      0      0   unless defined $args{$arg}
2436  ***      0      0      0   if ($col_type =~ /(?:int|year|float|double|decimal)$/) { }
      ***      0      0      0   elsif ($col_type eq 'timestamp') { }
      ***      0      0      0   elsif ($col_type eq 'date') { }
      ***      0      0      0   elsif ($col_type eq 'time') { }
      ***      0      0      0   elsif ($col_type eq 'datetime') { }
2468  ***      0      0      0   if (not defined $start_point)
2472  ***      0      0      0   if (not defined $end_point or $end_point < $start_point)
2481  ***      0      0      0   if ($int_types{$col_type})
2485  ***      0      0      0   if ($args{'exact'})
2491  ***      0      0      0   if ($start_point < $end_point) { }
2497  ***      0      0      0   if ($iter++ == 0) { }
2507  ***      0      0      0   if (@chunks) { }
2511  ***      0      0      0   $nullable ? :
2513  ***      0      0      0   if ($nullable)
2529  ***     50      0      9   unless $args{$arg}
2539  ***      0      0      0   unless $args{$arg}
2548  ***      0      0      0   if ($suffix) { }
      ***      0      0      0   elsif ($num) { }
2549  ***      0      0      0   $suffix eq 'M' ? :
      ***      0      0      0   $suffix eq 'k' ? :
2561  ***      0      0      0   if ($suffix or $args{'avg_row_length'})
2564  ***      0      0      0   if (not defined $n_rows)
2565  ***      0      0      0   $avg_row_length ? :
2569  ***      0      0      0   wantarray ? :
2576  ***      0      0      0   unless $args{$arg}
2581  ***      0      0      0   $where ? :
2589  ***      0      0      0   if ($EVAL_ERROR)
2591  ***      0      0      0   if ($EVAL_ERROR =~ /in your SQL syntax/) { }
2598  ***      0      0      0   $where ? :
2611  ***      0      0      0   $val =~ /\d[:-]/ ? :
2617  ***     50      0     35   unless defined $args{$arg}
2626  ***     50      0      7   if ($args{'where'} and grep {$_;} @{$args{'where'};})
2649  ***      0      0      0   if $start =~ /e/
2650  ***      0      0      0   if $end =~ /e/
2655  ***      0      0      0   if ($end > $start) { }
2701  ***      0      0      0   unless $check eq $time
2712  ***      0      0      0   defined $_ ? :
2752  ***      0      0      0   unless defined $val
2753  ***      0      0      0   if $val eq ''
2755  ***      0      0      0   if (not defined $is_numeric)
2756  ***      0      0      0   $val =~ /^0|\D/ ? :
2759  ***      0      0      0   if $is_numeric
2769  ***     50      9      0   if (not $tbl)
2778  ***      0      0      0   unless $like
2821  ***      0      0      0   if ($EVAL_ERROR)
2822  ***      0      0      0   unless print STDERR 'Cannot connect to ', $dp->as_string($dsn), "\n"
2832  ***      0      0      0   if (not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++)
2837  ***      0      0      0   if ($$args{'skip_callback'})
2845  ***      0      0      0   if (not defined $$args{'recurse'} or $level < $$args{'recurse'})
2847  ***      0      0      0   unless not $$_{'master_id'}
2864  ***      0      0      0   if ($method) { }
2869  ***      0      0      0   if (($$dsn{'P'} || 3306) != 3306)
2883  ***      0      0      0   if @slaves
2901  ***      0      0      0   if ($host eq 'localhost')
2918  ***      0      0      0   if (@slaves)
2923  ***      0      0      0   $hash{'user'} ? :
      ***      0      0      0   $hash{'password'} ? :
2943  ***      0      0      0   if (not $proc)
2960  ***      0      0      0   unless my $master_status = $self->get_master_status($master)
2962  ***      0      0      0   unless my $slave_status = $self->get_slave_status($slave)
2964  ***      0      0      0   unless my(@connected) = $self->get_connected_slaves($master)
2968  ***      0      0      0   if ($port != $$slave_status{'master_port'})
2973  ***      0      0      0   if (not grep {$$slave_status{'master_user'} eq $$_{'user'};} @connected)
2978  ***      0      0      0   if (($$slave_status{'slave_io_state'} || '') eq 'Waiting for master to send event')
2985  ***      0      0      0   if ($master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1)
2998  ***      0      0      0   unless my $master = $self->get_slave_status($dbh)
3005  ***      0      0      0   if (not $$self{'not_a_slave'}{$dbh})
3012  ***      0      0      0   if ($ss and %$ss)
3024  ***      0      0      0   if (not $$self{'not_a_master'}{$dbh})
3031  ***      0      0      0   if ($ms and %$ms)
3033  ***      0      0      0   if ($$ms{'file'} and $$ms{'position'})
3046  ***      0      0      0   unless defined $time
3050  ***      0      0      0   if ($ms) { }
3054  ***      0      0      0   defined $result ? :
3056  ***      0      0      0   if ($stat eq 'NULL' or $stat < 0 and not $timeoutok)
3076  ***      0      0      0   if ($pos) { }
3100  ***      0      0      0   if ($self->pos_cmp($slave_pos, $master_pos) < 0)
3106  ***      0      0      0   if ($EVAL_ERROR)
3108  ***      0      0      0   if ($EVAL_ERROR =~ /MASTER_POS_WAIT returned NULL/) { }
3110  ***      0      0      0   if (not $self->slave_is_running($slave_status)) { }
3115  ***      0      0      0   if ($self->pos_cmp($slave_pos, $master_pos) != 0)
3139  ***      0      0      0   if ($self->pos_cmp($s1_pos, $s2_pos) < 0) { }
      ***      0      0      0   elsif ($self->pos_cmp($s2_pos, $s1_pos) < 0) { }
3151  ***      0      0      0   if ($self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0)
3174  ***      0      0      0   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3178  ***      0      0      0   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
3183  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn))
3197  ***      0      0      0   if (not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0) { }
3212  ***      0      0      0   if ($self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0)
3223  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($sib_dsn))
3227  ***      0      0      0   unless my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3231  ***      0      0      0   unless my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3233  ***      0      0      0   if ($self->short_host($master_dsn1) ne $self->short_host($master_dsn2))
3236  ***      0      0      0   unless my $sib_master_stat = $self->get_master_status($sib_dbh)
3238  ***      0      0      0   unless $self->has_slave_updates($sib_dbh)
3250  ***      0      0      0   if ($self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
3262  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($unc_dsn))
3266  ***      0      0      0   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3270  ***      0      0      0   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
3273  ***      0      0      0   unless my $unc_master_dsn = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
3276  ***      0      0      0   if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn))
3280  ***      0      0      0   unless my $unc_master_stat = $self->get_master_status($unc_dbh)
3282  ***      0      0      0   unless $self->has_slave_updates($unc_dbh)
3290  ***      0      0      0   if ($self->pos_cmp($self->repl_posn($slave_status), $self->repl_posn($master_status)) != 0)
3304  ***      0      0      0   if ($self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
3315  ***      0      0      0   unless my $stat = $self->get_slave_status($dbh)
3337  ***      0      0      0   if (exists $$status{'file'} and exists $$status{'position'}) { }
3365  ***      0      0      0   if ($$dsn{'master_host'}) { }
3373  ***      0      0      0   ($port || 3306) == 3306 ? :
3384  ***      0      0      0   defined $_ ? :
3413  ***      0      0      0   unless $args{$arg}
3416  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
3432  ***      0      0      0   unless defined(my $pid = fork)
3433  ***      0      0      0   if ($pid)
3440  ***      0      0      0   unless POSIX::setsid()
3441  ***      0      0      0   unless chdir '/'
3447  ***      0      0      0   if (-t STDIN)
3449  ***      0      0      0   unless open STDIN, '/dev/null'
3453  ***      0      0      0   if ($$self{'log_file'}) { }
3455  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
3459  ***      0      0      0   unless open STDERR, '>&STDOUT'
3463  ***      0      0      0   if (-t STDOUT)
3465  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
3468  ***      0      0      0   if (-t STDERR)
3470  ***      0      0      0   unless open STDERR, '>', '/dev/null'
3481  ***      0      0      0   $self ? :
3483  ***      0      0      0   if ($PID_file and -f $PID_file) { }
3486  ***      0      0      0   if $EVAL_ERROR
3488  ***      0      0      0   if ($pid) { }
3490  ***      0      0      0   if ($pid_is_alive) { }
3512  ***      0      0      0   if (exists $$self{'child'})
3524  ***      0      0      0   if (not $PID_file)
3531  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
3533  ***      0      0      0   unless print $PID_FH $PID
3535  ***      0      0      0   unless close $PID_FH
3544  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
3545  ***      0      0      0   unless unlink $$self{'PID_file'}
3557  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
3563  ***      0      0      0   defined $_ ? :
3594  ***     50      0      9   unless $args{$arg}
3613  ***     50      9      0   if $o->has('databases')
3615  ***     50      9      0   if $o->has('ignore-databases')
3618  ***     50      0      9   if ($o->has('databases-regex') and my $p = $o->get('databases-regex'))
3622  ***     50      0      9   if ($o->has('ignore-databases-regex') and my $p = $o->get('ignore-databases-regex'))
3626  ***     50      9      0   if (@permit_dbs or @reject_dbs or @dbs_regex or @reject_dbs_regex)
3627  ***     50      9      0   @permit_dbs ? :
      ***     50      0      9   @reject_dbs ? :
      ***     50      0      9   @dbs_regex ? :
      ***     50      0      9   @reject_dbs_regex ? :
3636  ***     50      9      0   if ($o->has('tables') or $o->has('ignore-tables') or $o->has('ignore-tables-regex'))
3646         100      8      1   if ($o->get('tables'))
3649  ***     50      0      8   if ($_ =~ /\./) { }
3659  ***     50      0      8   if (@permit_qtbls)
3669  ***     50      0      9   if ($o->get('ignore-tables'))
3672  ***      0      0      0   if ($_ =~ /\./) { }
3682  ***      0      0      0   if (@reject_qtbls and not $have_qtbl)
3688  ***     50      0      9   if (keys %permit_qtbls and not @permit_dbs)
3696  ***      0      0      0   if (keys %$dbs)
3703  ***     50      0      9   if ($o->has('tables-regex') and my $p = $o->get('tables-regex'))
3707  ***     50      0      9   if ($o->has('ignore-tables-regex') and my $p = $o->get('ignore-tables-regex'))
3716  ***     50      9      0   if ($o->has('engines') and $o->get('engines') or $o->has('ignore-engines') and $o->get('ignore-engines'))
3735  ***     50      9      0   if (@permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs or @reject_engs)
3737         100      8      1   @permit_tbls ? :
      ***     50      0      9   @reject_tbls ? :
      ***     50      0      9   @tbls_regex ? :
      ***     50      0      9   @reject_tbls_regex ? :
      ***     50      0      9   @permit_qtbls ? :
      ***     50      0      9   @reject_qtbls ? :
      ***     50      9      0   @get_eng ? :
             100      1      8   @permit_engs ? :
      ***     50      9      0   @reject_engs ? :
3758  ***     50      0      9   unless my $filter_sub = eval $code
3775  ***     50      0      9   unless $args{$arg}
3784  ***     50     44      0   $filter ? :
3786         100      9     35   if $_ =~ /information_schema|lost\+found/
3801  ***     50      0     18   unless $args{$arg}
3807  ***     50      9      0   if ($db) { }
3817  ***     50     58      0   $filter ? :
3818  ***     50     58      0   if (not $views)
3819  ***     50      0     58   if ($type || '') eq 'VIEW'
3839         100     27     25   if (scalar keys %$objs)
3840         100     19     17   $lc ? :
3849  ***      0      0      0   defined $_ ? :
3939  ***     50      0    198   unless $o->has($arg)
3946  ***     50      0      9   if $o->get('wait')
3947         100      1      8   if $o->get('lock')
3949  ***     50      0      9   if (not @ARGV)
3961  ***     50      0      9   if ($o->get('explain-hosts'))
3971  ***     50      0      9   $o->get('schema') ? :
3973         100      7      2   if ($o->get('checksum'))
3977         100      1      8   if ($o->get('explain'))
3981  ***     50      9      0   if (not $o->get('help'))
3982  ***     50      0      9   if ($o->get('replicate-check') and not $o->get('replicate'))
3985  ***     50      0      9   if ($o->get('save-since') and not $o->get('arg-table')) { }
      ***     50      0      9   elsif ($o->get('replicate') and @hosts > 1) { }
3992  ***     50      0      9   if ($o->get('resume-replicate') and not $o->get('replicate'))
3995  ***     50      0      9   if ($o->get('resume') and $o->get('replicate'))
4007  ***     50      0      9   if ($o->get('pid'))
4041  ***     50      0      9   if ($o->get('check-slave-lag'))
4051  ***     50      0      9   if (my $arg_tbl = $o->get('arg-table'))
4056  ***      0      0      0   unless $$row{'db'} and $$row{'tbl'}
4059  ***      0      0      0   if $overridable_args{$_}
4063  ***      0      0      0   if (not %col_in_argtable)
4065  ***      0      0      0   if $key =~ /^(db|tbl|ts)$/
4066  ***      0      0      0   unless $overridable_args{$key}
4072  ***      0      0      0   if ($col_in_argtable{'since'})
4084  ***     50      0      9   if ($o->get('replicate-check'))
4085  ***      0      0      0   $o->get('recheck') ? :
4097  ***      0      0      0   unless @tbls
4115  ***      0      0      0   unless $o->get('recheck')
4123  ***     50      9      0   if ($checksum_table_data) { }
4127  ***     50      0      9   if ($o->get('verify') and @hosts > 1)
4141  ***     50      0      9   if ($o->get('replicate') and $o->get('resume-replicate')) { }
      ***     50      0      9   elsif ($o->get('resume')) { }
4160  ***     50      9      0   unless $o->get('replicate-check') and $o->get('recheck')
4188  ***     50      0     63   unless $args{$arg}
4227  ***     50      0    108   unless $args{$arg}
4240  ***     50      0      9   if $final_o->get('replicate') and $final_o->get('replicate') eq "$db.$tbl"
4251  ***     50      0      9   if $final_o->get('no-use-index')
4252         100      8      1   if ($idx)
4253  ***     50      8      0   $vp->version_ge($dbh, '4.0.9') ? :
4260  ***     50      0      9   if ($args{'given_chunks'}) { }
4264  ***     50      0      9   if ($final_o->get('chunk-size') and $col)
4279  ***      0      0      0   if (not grep {not defined $params{$_};} 'min', 'max', 'rows_in_range')
4304  ***     50      0      9   if ($EVAL_ERROR)
4316  ***     50      0     72   unless $args{$arg}
4342  ***     50      9      0   if ($checksum_table_data and $do_table) { }
4364  ***     50      9      0   if (not $hdr)
4365  ***     50      0      9   if ($o->get('tab')) { }
4379         100      1      8   unless ($o->get('quiet') or $o->get('explain') or $o->get('checksum') or $o->get('resume'))
4384  ***     50      0      1   unless printf $hdr, @hdr_args
4390  ***     50      0      9   if (my $replicate_table = $final_o->get('replicate') and not $final_o->get('explain'))
4406  ***     50      0      9   if ($final_o->get('since'))
4407  ***      0      0      0   if (is_temporal($final_o->get('since'))) { }
4412  ***      0      0      0   if ($time and $time lt $final_o->get('since'))
4429  ***      0      0      0   if $_
4433  ***      0      0      0   if ($sincecol) { }
4452  ***     50      9      0   if ($checksum_table_data and $do_table) { }
4489  ***     50      0      9   if ($final_o->get('save-since') and $savesince_sth)
4490  ***      0      0      0   if (is_temporal($final_o->get('since'))) { }
      ***      0      0      0   elsif (defined $$table{'maxval'}) { }
4509  ***     50      0      9   if ($EVAL_ERROR)
4520  ***     50      0     90   unless $args{$arg}
4546  ***     50      0      9   if (my $lag_dbh = $args{'lag_dbh'})
4555  ***     50      0      9   if ($num_chunks > 1 || $final_o->get('single-chunk') and $checksum_table_data and defined $final_o->get('probability') and rand 100 >= $final_o->get('probability'))
4563  ***     50      0      9   if ($num_chunks > 1 and $checksum_table_data and $final_o->get('modulo') and $chunk_num % $final_o->get('modulo') != $final_o->get('offset'))
4575  ***     50      0      9   if ($final_o->get('replicate')) { }
4579  ***      0      0      0   if ($o->get('resume-replicate'))
4580  ***      0      0      0   if (already_checksummed($$tbl{'database'}, $$tbl{'table'}, $chunk_num, $hosts[0]{'h'}))
4584  ***      0      0      0   unless $o->get('quiet')
4606         100      8      1   if (not $final_o->get('explain'))
4607         100      1      7   if ($final_o->get('lock'))
4613  ***     50      0      8   if ($final_o->get('wait'))
4626  ***     50      9      0   if ($is_master) { }
4635  ***     50      0      9   if ($final_o->get('resume'))
4636  ***      0      0      0   if already_checksummed($$tbl{'database'}, $$tbl{'table'}, $chunk_num, $$host{'h'})
4643  ***     50      0      9   @hosts > 1 ? :
4645  ***     50      9      0   if (@hosts == 1 or defined $pid and $pid == 0) { }
      ***      0      0      0   elsif (@hosts > 1 and not defined $pid) { }
4657  ***     50      0      9   if ($EVAL_ERROR)
4660  ***      0      0      0   if @hosts > 1
4663  ***     50      0      9   if @hosts > 1
4670  ***     50      0      9   if @hosts > 1
4679         100      1      8   if ($final_o->get('lock') and not $final_o->get('explain'))
4689  ***     50      0      9   if ($final_o->get('sleep') and not $final_o->get('explain')) { }
      ***     50      0      9   elsif ($final_o->get('sleep-coef') and not $final_o->get('explain')) { }
4711  ***     50      0     45   unless $args{$arg}
4720  ***     50      0      9   if (my $override = $$args_for{$db}{$tbl})
4730  ***     50      0     18   if ($val and not is_temporal($val))
4746  ***      0      0      0   unless $args{$arg}
4753  ***      0      0      0   if $o->get('quiet')
4760  ***      0      0      0   unless printf $fmt, map({uc $_;} @headers)
4762  ***      0      0      0   unless printf $fmt, @{$tbl;}{@headers}
4764  ***      0      0      0   unless print "\n"
4772  ***      0      0      0   unless $args{$arg}
4805  ***      0      0      0   if ($EVAL_ERROR and 0)
4815  ***     50      0     27   unless $args{$arg}
4838  ***     50      0      9   if ($o->get('algorithm') and $o->get('algorithm') ne $$ret{'strat'})
4845         100      7      2   if ($tc->is_hash_algorithm($$ret{'strat'}))
4850  ***     50      0      7   if ($o->get('function') and $o->get('function') ne $$ret{'func'})
4857         100      2      5   if ($o->get('optimize-xor') and $$ret{'strat'} eq 'BIT_XOR')
4858  ***     50      2      0   if (not $$ret{'crc_type'} =~ /int$/) { }
4861  ***     50      0      2   if (not defined $$ret{'opt_slice'})
4879  ***      0      0      0   unless $args{$arg}
4896  ***      0      0      0   if (unique(map({$$_{'sum'};} @verify_sums)) > 1)
4918  ***     50      0     36   unless $args{$arg}
4926  ***     50      9      0   unless $replicate_table
4936  ***      0      0      0   if (not $tbl_exists) { }
4937  ***      0      0      0   if ($o->get('create-replicate-table')) { }
4938  ***      0      0      0   unless create_repl_table(%args)
4957  ***      0      0      0   unless $have_tbl_privs
4962  ***      0      0      0   if ($o->get('empty-replicate-table'))
4983  ***      0      0      0   unless $args{$arg}
4998  ***      0      0      0   if ($EVAL_ERROR)
5009  ***      0      0      0   unless $args{$arg}
5016  ***      0      0      0   unless $replicate_table
5036  ***      0      0      0   unless open my $resume_fh, '<', $resume_file
5052  ***      0      0      0   if ($line =~ /^\S+\s+\S+\s+\d+\s+/)
5066  ***      0      0      0   if (exists $$already_checksummed{$d}{$t}{$c}{$h})
5076  ***      0      0      0   unless $args{$arg}
5111  ***      0      0      0   if ($final_o->get('explain'))
5112  ***      0      0      0   if ($chunk_num == 0)
5113  ***      0      0      0   unless printf $explain, @{$tbl;}{'database', 'table'}, $sql
5116  ***      0      0      0   unless printf $explain, @{$tbl;}{'database', 'table'}, $where
5131  ***      0      0      0   if ($$warning{'message'} =~ /Data truncated for column 'boundaries'/) { }
5147  ***      0      0      0   if (not $final_o->get('quiet') and not $final_o->get('explain'))
5148  ***      0      0      0   if ($final_o->get('checksum')) { }
5150  ***      0      0      0   unless printf $md5sum_fmt, $crc, $$host{'h'}, @{$tbl;}{'database', 'table'}, $chunk_num
5155  ***      0      0      0   unless printf $hdr, @{$tbl;}{'database', 'table'}, $chunk_num, $$host{'h'}, $$tbl{'struct'}{'engine'}, $cnt, $crc, $end - $beg, 'NULL', 'NULL', 'NULL'
5168  ***     50      0     99   unless $args{$arg}
5197  ***     50      0      9   if (not $is_master and $final_o->get('wait') and not $final_o->get('explain'))
5205  ***      0      0      0   unless defined $sta
5207  ***     50      0      9   if (not $is_master and $final_o->get('slave-lag') and not $final_o->get('explain'))
5212  ***      0      0      0   $res && defined $$res{'seconds_behind_master'} ? :
5219  ***     50      0      9   if (not $is_master or not $checksum_table_data)
5225  ***      0      0      0   $$host{'h'} ? :
      ***      0      0      0   $$host{'P'} ? :
      ***      0      0      0   unless $have_table
5234  ***     50      9      0   if ($have_table)
5236  ***     50      9      0   if ($checksum_table_data) { }
5237         100      2      7   if ($strat eq 'CHECKSUM') { }
      ***     50      7      0   elsif ($final_o->get('crc')) { }
5238  ***     50      2      0   if ($final_o->get('crc'))
5241  ***     50      0      2   if ($final_o->get('count'))
5264         100      8      1   if (not $final_o->get('quiet') and not $final_o->get('explain'))
5265         100      7      1   if ($final_o->get('checksum')) { }
5267  ***     50      0      7   unless printf $md5sum_fmt, $crc, $$host{'h'}, @{$tbl;}{'database', 'table'}, $chunk_num
5272  ***     50      0      1   unless printf $hdr, @{$tbl;}{'database', 'table'}, $chunk_num, $$host{'h'}, $$tbl{'struct'}{'engine'}, $cnt, $crc, $end - $mid, $mid - $beg, $sta, $lag
5285  ***     50      0     18   unless $args{$arg}
5290  ***     50      0      9   if ($o->get('ask-pass') and not defined $$dsn{'p'})
5294         100      1      8   $o->get('lock') ? :
5305  ***     50      0     42   unless $args{$arg}
5329  ***     50      0      7   if ($final_o->get('explain'))
5330  ***      0      0      0   if ($chunk_num == 0)
5331  ***      0      0      0   unless printf $explain, @{$tbl;}{'database', 'table'}, $sql
5334  ***      0      0      0   unless printf $explain, @{$tbl;}{'database', 'table'}, $$tbl{'chunks'}[$chunk_num]
5347  ***     50      0     10   unless $args{$arg}
5357         100      1      1   if ($final_o->get('explain')) { }
5358  ***     50      0      1   unless printf $explain, @{$tbl;}{'database', 'table'}, $query
5363  ***     50      1      0   if ($res)
5365  ***     50      1      0   defined $$res{$key} ? :
5375  ***      0      0      0   unless $args{$arg}
5387  ***      0      0      0   if ($final_o->get('where') or $final_o->get('since'))
5393  ***      0      0      0   if ($final_o->get('explain')) { }
5394  ***      0      0      0   unless printf $explain, @{$tbl;}{'database', 'table'}, $sql
5412  ***      0      0      0   if not defined $msg or $o->get('quiet') and $EVAL_ERROR =~ /: Table .*? doesn't exist|Deadlock found/
5418  ***      0      0      0   if ($db and $tbl)
5421  ***      0      0      0   if ($host)
5429  ***      0      0      0   defined $_ ? :


Conditions
----------

and 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
2370  ***     33      8      0   0
2392  ***     50      9      0   $args{'exact'} and scalar @candidate_cols
4805  ***      0      0      0   $EVAL_ERROR and 0

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
247   ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete
285   ***     33      8      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000'
      ***     33      8      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i
316   ***     33      8      0      0   $engine =~ /InnoDB/i and not $clustered_key
318   ***      0      0      0      0   $$this_key{'is_unique'} and not $$this_key{'is_nullable'}
342   ***      0      0      0      0   not $parent =~ /\./ and $$opts{'database'}
458   ***     33      0      0      7   uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64'
478   ***     66      6      0      1   $type eq 'bigint' and $length < 20
492   ***     66      2      7      0   $alg and not $ALGOS{$alg}
509   ***     66      2      0      7   $alg and grep {$_ eq $alg;} @choices
514   ***     33      2      0      0   $args{'count'} and grep {$_ ne 'CHECKSUM';} @choices
525   ***     66      0      2      7   $ALGOS{$algorithm} && $ALGOS{$algorithm}{'hash'}
535   ***     33      0      7      0   @funcs and not $result
544   ***     33      7      0      0   $EVAL_ERROR and $EVAL_ERROR =~ /failed: (.*?) at \S+ line/
568   ***     66      0      2      3   $start < $crc_wid and $sliced ne $unsliced
615   ***     66      1      0      7   defined $opt_slice and $opt_slice < @slices
643   ***     33      7      0      0   $type =~ /float|double/ and $args{'float_precision'}
      ***     33      7      0      0   $type =~ /varchar/ and $args{'trim'}
660   ***     33      0      0      7   uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64'
693   ***     33      0      0      9   $algorithm and $ALGOS{$algorithm}
1000  ***     66    207    342      0   $type and $type eq 'd'
      ***     33    549      0      0   $type and $type eq 'd' and not $$self{'dp'}
1005         100    207    234    108   $type and $type =~ /[HhAadzm]/
1144  ***     33      0      9      0   @ARGV and $ARGV[0] eq '--config'
1173  ***     33      0      9      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
1180  ***     33      0      9      0   @ARGV and $$self{'strict'}
1264  ***     66      0    207    342   $opt and $$opt{'type'}
1267         100    238     86     18   $val and $$opt{'type'} eq 'm'
      ***     66    238     86      0   $val and $$opt{'type'} eq 'd'
      ***     66    238     86      0   $val and $$opt{'type'} eq 'z'
             100    238     59     18   defined $val and $$opt{'type'} eq 'h'
      ***     66    238     50      0   defined $val and $$opt{'type'} eq 'a'
1332  ***     33      0      0    751   $long and exists $$self{'opts'}{$long}
1340  ***     33      0      0     36   $long and exists $$self{'opts'}{$long}
1354  ***     33      0      0      8   $long and exists $$self{'opts'}{$long}
1444  ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
1538  ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1717  ***     66    146    254      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33    400      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1839  ***     66     41      0     41   not $dbh and $tries--
1875  ***     33     41      0      0   not $dbh and $EVAL_ERROR
2081  ***      0      0      0      0   $trgs and @$trgs
2127  ***     33      9      0      0   $curr and $new
      ***     33      9      0      0   $curr and $new and $curr eq $new
2373  ***      0      0      0      0   $$index{'is_unique'} and @{$$index{'cols'};} == 1
2626  ***     33      0      7      0   $args{'where'} and grep {$_;} @{$args{'where'};}
2832  ***      0      0      0      0   defined $master_thinks_i_am and $master_thinks_i_am != $id
3012  ***      0      0      0      0   $ss and %$ss
3031  ***      0      0      0      0   $ms and %$ms
3033  ***      0      0      0      0   $$ms{'file'} and $$ms{'position'}
3056  ***      0      0      0      0   $stat < 0 and not $timeoutok
3197  ***      0      0      0      0   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status)
      ***      0      0      0      0   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0
3332  ***      0      0      0      0   $value && $value =~ /^(1|ON)$/
3337  ***      0      0      0      0   exists $$status{'file'} and exists $$status{'position'}
3483  ***      0      0      0      0   $PID_file and -f $PID_file
3544  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
3618  ***     33      9      0      0   $o->has('databases-regex') and my $p = $o->get('databases-regex')
3622  ***     33      9      0      0   $o->has('ignore-databases-regex') and my $p = $o->get('ignore-databases-regex')
3682  ***      0      0      0      0   @reject_qtbls and not $have_qtbl
3688  ***     33      9      0      0   keys %permit_qtbls and not @permit_dbs
3703  ***     33      9      0      0   $o->has('tables-regex') and my $p = $o->get('tables-regex')
3707  ***     33      9      0      0   $o->has('ignore-tables-regex') and my $p = $o->get('ignore-tables-regex')
3716  ***     66      0      8      1   $o->has('engines') and $o->get('engines')
      ***     33      0      0      8   $o->has('ignore-engines') and $o->get('ignore-engines')
3982  ***     33      9      0      0   $o->get('replicate-check') and not $o->get('replicate')
3985  ***     33      9      0      0   $o->get('save-since') and not $o->get('arg-table')
      ***     33      9      0      0   $o->get('replicate') and @hosts > 1
3992  ***     33      9      0      0   $o->get('resume-replicate') and not $o->get('replicate')
3995  ***     33      9      0      0   $o->get('resume') and $o->get('replicate')
4056  ***      0      0      0      0   $$row{'db'} and $$row{'tbl'}
4127  ***     33      0      9      0   $o->get('verify') and @hosts > 1
4141  ***     33      9      0      0   $o->get('replicate') and $o->get('resume-replicate')
4160  ***     33      9      0      0   $o->get('replicate-check') and $o->get('recheck')
4240  ***     33      9      0      0   $final_o->get('replicate') and $final_o->get('replicate') eq "$db.$tbl"
4264  ***     33      9      0      0   $final_o->get('chunk-size') and $col
4342  ***     33      0      0      9   $checksum_table_data and $do_table
4390  ***     33      9      0      0   my $replicate_table = $final_o->get('replicate') and not $final_o->get('explain')
4412  ***      0      0      0      0   $time and $time lt $final_o->get('since')
4452  ***     33      0      0      9   $checksum_table_data and $do_table
4489  ***     33      9      0      0   $final_o->get('save-since') and $savesince_sth
4555  ***     33      9      0      0   $num_chunks > 1 || $final_o->get('single-chunk') and $checksum_table_data
      ***     33      9      0      0   $num_chunks > 1 || $final_o->get('single-chunk') and $checksum_table_data and defined $final_o->get('probability')
      ***     33      9      0      0   $num_chunks > 1 || $final_o->get('single-chunk') and $checksum_table_data and defined $final_o->get('probability') and rand 100 >= $final_o->get('probability')
4563  ***     33      9      0      0   $num_chunks > 1 and $checksum_table_data
      ***     33      9      0      0   $num_chunks > 1 and $checksum_table_data and $final_o->get('modulo')
      ***     33      9      0      0   $num_chunks > 1 and $checksum_table_data and $final_o->get('modulo') and $chunk_num % $final_o->get('modulo') != $final_o->get('offset')
4645  ***      0      0      0      0   defined $pid and $pid == 0
      ***      0      0      0      0   @hosts > 1 and not defined $pid
4679  ***     66      8      0      1   $final_o->get('lock') and not $final_o->get('explain')
4689  ***     33      9      0      0   $final_o->get('sleep') and not $final_o->get('explain')
      ***     33      9      0      0   $final_o->get('sleep-coef') and not $final_o->get('explain')
4730  ***     33     18      0      0   $val and not is_temporal($val)
4740  ***      0      0      0      0   $val && $val =~ /^\d{4}-\d{2}-\d{2}(?:.[0-9:]+)?/
4838  ***     66      2      7      0   $o->get('algorithm') and $o->get('algorithm') ne $$ret{'strat'}
4850  ***     33      0      7      0   $o->get('function') and $o->get('function') ne $$ret{'func'}
4857         100      1      4      2   $o->get('optimize-xor') and $$ret{'strat'} eq 'BIT_XOR'
5147  ***      0      0      0      0   not $final_o->get('quiet') and not $final_o->get('explain')
5197  ***     33      9      0      0   not $is_master and $final_o->get('wait')
      ***     33      9      0      0   not $is_master and $final_o->get('wait') and not $final_o->get('explain')
5207  ***     33      9      0      0   not $is_master and $final_o->get('slave-lag')
      ***     33      9      0      0   not $is_master and $final_o->get('slave-lag') and not $final_o->get('explain')
5212  ***      0      0      0      0   $res && defined $$res{'seconds_behind_master'}
5264  ***     66      0      1      8   not $final_o->get('quiet') and not $final_o->get('explain')
5290  ***     33      9      0      0   $o->get('ask-pass') and not defined $$dsn{'p'}
5412  ***      0      0      0      0   $o->get('quiet') and $EVAL_ERROR =~ /: Table .*? doesn't exist|Deadlock found/
5418  ***      0      0      0      0   $db and $tbl

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
42    ***     50      0     24   $ENV{'MKDEBUG'} || 0
261   ***     50     18      0   $engine || undef
284   ***     50      0      8   $type || $special || 'BTREE'
371   ***      0      0      0   $$tbl_struct{'engine'} || ''
373   ***      0      0      0   $clustered_key ||= ''
424   ***     50      0     24   $ENV{'MKDEBUG'} || 0
630   ***     50      7      0   $args{'sep'} || '#'
632   ***     50      7      0   $sep ||= '#'
785   ***     50      0     24   $ENV{'MKDEBUG'} || 0
804   ***     33      9      0   0
805   ***     50      9      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
807   ***     50      9      0   $args{'prompt'} || '<options>'
      ***     50      9      0   $args{'dp'} || undef
849   ***     50      0      9   $file ||= '/home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum'
990   ***     50    549      0   $$opt{'group'} ||= 'default'
1272  ***      0      0      0   $s || 's'
1281  ***     50      0     18   $prefix || ''
1309  ***      0      0      0   $pre || ''
1316  ***     50     27      0   $val || ''
1319  ***     50      9      0   $val || ''
1377  ***      0      0      0   $$self{'description'} || ''
1446  ***      0      0      0   $s ||= 's'
1472  ***      0      0      0   $$opt{'type'} || ''
1627  ***     50      0     24   $ENV{'MKDEBUG'} || 0
1698  ***     50      0     50   $prev ||= {}
1699         100      9     41   $defaults ||= {}
1772  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1785  ***     50      0     41   $self->prop('dbidriver') || ''
1789  ***      0      0      0   $$info{'D'} || ''
1795  ***     50      0     41   $$info{'D'} || ''
1817  ***     50     41      0   $opts ||= {}
1912  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1928  ***      0      0      0   $level ||= 0
1929  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1979  ***     50      0     24   $ENV{'MKDEBUG'} || 0
2028  ***     50      0     24   $ENV{'MKDEBUG'} || 0
2298  ***      0      0      0   $$_[1] || ''
2341  ***     50      0     24   $ENV{'MKDEBUG'} || 0
2632  ***     50      7      0   $args{'index_hint'} || ''
2734  ***     50      0     24   $ENV{'MKDEBUG'} || 0
2803  ***     50      0     24   $ENV{'MKDEBUG'} || 0
2811  ***      0      0      0   $level ||= 0
2869  ***      0      0      0   $$dsn{'P'} || 3306
2978  ***      0      0      0   $$slave_status{'slave_io_state'} || ''
3324  ***      0      0      0   $$slave_status{'slave_sql_running'} || 'No'
3373  ***      0      0      0   $host || '[default]'
      ***      0      0      0   $port || 3306
3408  ***     50      0     24   $ENV{'MKDEBUG'} || 0
3589  ***     50      0     24   $ENV{'MKDEBUG'} || 0
3819  ***     50     58      0   $type || ''
3878  ***     50      0     24   $ENV{'MKDEBUG'} || 0
4628  ***     33      0      9   0
5146  ***      0      0      0   $crc ||= 'NULL'
5247  ***     50      7      0   $crc ||= 'NULL'

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
135   ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'}
      ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
214   ***      0      0      0      0   not $$row[0] or $$row[0] ne $tbl
235   ***      0      0      0      0   $$row{'privileges'} || $$row{'Privileges'}
284   ***     33      0      0      8   $type || $special
495   ***     33      0      0      9   $args{'where'} or $args{'chunk'}
      ***     33      0      0      9   $args{'where'} or $args{'chunk'} or $args{'replicate'}
      ***     33      0      0      9   $args{'where'} or $args{'chunk'} or $args{'replicate'} or not $vp->version_ge($dbh, '4.1.1')
805   ***     33      9      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***     33      9      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
1267         100      9     18    297   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***     66      9      0    288   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1808  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1809  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1810  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1811  ***      0      0      0      0   $$dsn{'u'} ||= $user
1812  ***      0      0      0      0   $$dsn{'D'} ||= $db
2139  ***     33      9      0      0   not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl}
2178  ***      0      0      0      0   not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl}
2208  ***      0      0      0      0   not $$self{'cache'} or not $$self{'triggers'}{$db}
2242  ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'} or $like
2261  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db} or $like
2275  ***      0      0      0      0   $tbl{'type'} || $tbl{'comment'}
      ***      0      0      0      0   $tbl{'engine'} ||= $tbl{'type'} || $tbl{'comment'}
2287  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db} or $like
2386  ***     33      8      0      0   $int_types{$$tbl_struct{'type_for'}{$col}} or $real_types{$$tbl_struct{'type_for'}{$col}}
2472  ***      0      0      0      0   not defined $end_point or $end_point < $start_point
2484  ***      0      0      0      0   $interval ||= $args{'chunk_size'}
2561  ***      0      0      0      0   $suffix or $args{'avg_row_length'}
2817  ***      0      0      0      0   $$args{'dbh'} || $dp->get_dbh($dp->get_cxn_params($dsn), {'AutoCommit', 1})
2832  ***      0      0      0      0   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id
      ***      0      0      0      0   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++
2845  ***      0      0      0      0   not defined $$args{'recurse'} or $level < $$args{'recurse'}
2985  ***      0      0      0      0   $master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1
3006  ***      0      0      0      0   $$self{'sths'}{$dbh}{'SLAVE_STATUS'} ||= $dbh->prepare('SHOW SLAVE STATUS')
3025  ***      0      0      0      0   $$self{'sths'}{$dbh}{'MASTER_STATUS'} ||= $dbh->prepare('SHOW MASTER STATUS')
3049  ***      0      0      0      0   $ms ||= $self->get_master_status($master)
3056  ***      0      0      0      0   $stat eq 'NULL' or $stat < 0 and not $timeoutok
3068  ***      0      0      0      0   $$self{'sths'}{$dbh}{'STOP_SLAVE'} ||= $dbh->prepare('STOP SLAVE')
3083  ***      0      0      0      0   $$self{'sths'}{$dbh}{'START_SLAVE'} ||= $dbh->prepare('START SLAVE')
3151  ***      0      0      0      0   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status)
      ***      0      0      0      0   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0
3212  ***      0      0      0      0   $self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0
3250  ***      0      0      0      0   $self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0
3304  ***      0      0      0      0   $self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0
3557  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
3626  ***     33      9      0      0   @permit_dbs or @reject_dbs
      ***     33      9      0      0   @permit_dbs or @reject_dbs or @dbs_regex
      ***     33      9      0      0   @permit_dbs or @reject_dbs or @dbs_regex or @reject_dbs_regex
3636  ***     33      9      0      0   $o->has('tables') or $o->has('ignore-tables')
      ***     33      9      0      0   $o->has('tables') or $o->has('ignore-tables') or $o->has('ignore-tables-regex')
3716  ***     66      1      8      0   $o->has('engines') and $o->get('engines') or $o->has('ignore-engines') and $o->get('ignore-engines')
3735  ***     66      8      0      1   @permit_tbls or @reject_tbls
      ***     66      8      0      1   @permit_tbls or @reject_tbls or @tbls_regex
      ***     66      8      0      1   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex
      ***     66      8      1      0   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs
      ***     33      9      0      0   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs or @reject_engs
4379  ***     66      0      1      8   $o->get('quiet') or $o->get('explain')
             100      1      7      1   $o->get('quiet') or $o->get('explain') or $o->get('checksum')
      ***     66      8      0      1   $o->get('quiet') or $o->get('explain') or $o->get('checksum') or $o->get('resume')
4548  ***      0      0      0      0   not defined $lag or $lag > $final_o->get('max-lag')
4555  ***     33      0      0      9   $num_chunks > 1 || $final_o->get('single-chunk')
4595  ***      0      0      0      0   $hosts[0]{'dbh'} ||= $dbh
4631  ***      0      0      0      0   $$host{'dbh'} ||= get_cxn($host, %args)
4645  ***     33      9      0      0   @hosts == 1 or defined $pid and $pid == 0
4677  ***      0      0      0      0   $exit_status ||= $CHILD_ERROR >> 8
4829  ***     33      0      0      9   $o->get('where') || $o->get('since')
5219  ***     33      0      0      9   not $is_master or not $checksum_table_data
5387  ***      0      0      0      0   $final_o->get('where') or $final_o->get('since')
5412  ***      0      0      0      0   not defined $msg or $o->get('quiet') and $EVAL_ERROR =~ /: Table .*? doesn't exist|Deadlock found/


Covered Subroutines
-------------------

Subroutine                   Count Location                                                         
---------------------------- ----- -----------------------------------------------------------------
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1615
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1616
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1617
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1618
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1627
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1974
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1975
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1977
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1979
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2023
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2024
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2026
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2028
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:22  
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:23  
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2328
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2329
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2333
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2334
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2335
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2336
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2341
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2727
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2728
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2732
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2734
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2792
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2793
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2797
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2798
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2799
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2803
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:34  
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3402
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3403
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3405
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3406
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3408
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:35  
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3580
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3581
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3583
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3584
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3589
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:36  
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:37  
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3871
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3872
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3873
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3874
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3878
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:419 
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:42  
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:420 
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:421 
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:422 
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:424 
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:778 
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:779 
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:781 
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:782 
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:783 
BEGIN                           24 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:785 
__ANON__                        52 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1168
__ANON__                        18 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3793
__ANON__                        18 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3832
_get_participants               27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1068
_make_filter                    52 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3837
_parse_specs                     9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:954 
_pod_to_specs                    9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:848 
_read_config_file               36 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1521
_set_option                     52 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1114
_use_db                         18 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2119
_validate_type                 549 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1263
best_algorithm                   9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:488 
check_repl_table                 9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4916
checksum_chunks                  9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4518
checksum_tables                  9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4314
choose_hash_func                 7 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:529 
clone                            9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1574
determine_checksum_strat         9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4813
do_checksum                      2 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5345
do_tbl                           9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5166
do_var_crc                       7 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5303
find_chunk_columns               9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2359
get                            751 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1330
get_all_tbls_info                9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4186
get_crc_type                     7 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:468 
get_crc_wid                      7 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:456 
get_create_table                 9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2138
get_cxn                          9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5283
get_cxn_params                  41 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1782
get_db_itr                       9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3772
get_dbh                         41 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1816
get_defaults_files               9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:843 
get_engine                      18 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:258 
get_final_opts                   9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4709
get_first_chunkable_column       9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2527
get_keys                         9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:265 
get_opts                         9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1131
get_specs                        9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:836 
get_tbl_itr                      9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3798
got                             36 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1338
has                            359 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1346
inject_chunks                    7 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2615
is_hash_algorithm                9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:524 
main                             9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3897
make_checksum_query              9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:682 
make_filter                      9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3605
make_row_checksum                7 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:626 
make_xor_slices                  8 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:597 
new                             32 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1630
new                             11 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1982
new                              9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2055
new                              9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2344
new                              9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2737
new                              9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2806
new                              9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3592
new                              9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:433 
new                              9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:46  
new                              9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:799 
optimize_xor                     2 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:556 
parse                           50 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1692
parse                           37 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1987
parse                            9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:57  
parse_options                    9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1743
prop                           150 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1683
quote                           61 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2742
read_para_after                  9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1555
save_tbl_to_checksum             9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4225
set                              8 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1352
set_filter                       9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3765
split_unquote                    9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2766
unique                           9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5405
usage_or_errors                  9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1388
version_ge                      27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1994

Uncovered Subroutines
---------------------

Subroutine                   Count Location                                                         
---------------------------- ----- -----------------------------------------------------------------
DESTROY                          0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3556
__ANON__                         0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4094
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1597
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1956
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2005
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2312
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2711
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3383
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3562
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3848
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:401 
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5428
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:760 
_find_slaves_by_hosts            0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2911
_find_slaves_by_processlist      0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2891
_make_PID_file                   0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3521
_remove_PID_file                 0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3543
already_checksummed              0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5065
as_string                        0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1756
calculate_chunks                 0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2422
catchup_to_master                0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3091
catchup_to_same_pos              0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3132
change_master_to                 0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3161
check_PID_file                   0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3480
check_table                      0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:193 
copy                             0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1938
crc32                            0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:442 
create_repl_table                0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4981
daemonize                        0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3429
descr                            0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1376
detach_slave                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3313
disconnect                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1921
do_count                         0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5373
do_tbl_replicate                 0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5074
dump                             0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2062
errors                           0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1366
eval_expr                        0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4799
fill_in_dsn                      0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1804
find_best_index                  0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:147 
find_possible_keys               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:165 
find_replication_differences     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:739 
find_slave_hosts                 0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2861
get_columns                      0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2176
get_connected_slaves             0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2938
get_databases                    0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2241
get_defaults                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1104
get_fks                          0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:332 
get_groups                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1109
get_hostname                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1911
get_master_dsn                   0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2997
get_master_status                0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3023
get_range_statistics             0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2573
get_slave_lag                    0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3352
get_slave_status                 0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3004
get_table_list                   0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2286
get_table_status                 0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2260
get_tmp_table                    0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2196
get_triggers                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2207
has_slave_updates                0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3328
is_master_of                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2959
is_temporal                      0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4739
literal_like                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2777
make_PID_file                    0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3511
make_sibling_of_master           0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3172
make_slave_of_sibling            0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3220
make_slave_of_uncle              0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3259
new                              0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3411
opts                             0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1080
parse_resume_file                0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5034
pos_cmp                          0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3358
pos_to_string                    0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3377
print_active_handles             0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1927
print_err                        0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5411
print_errors                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1401
print_inconsistent_tbls          0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4744
print_usage                      0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1411
prompt                           0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1371
prompt_noecho                    0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1486
quote                            0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2610
quote_val                        0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2750
range_date                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2671
range_datetime                   0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2678
range_num                        0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2645
range_time                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2664
range_timestamp                  0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2686
read_repl_table                  0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5007
recurse_to_slaves                0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2810
remove_auto_increment            0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:361 
remove_secondary_indexes         0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:367 
repl_posn                        0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3336
save_error                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1361
save_inconsistent_tbls           0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4770
set_defaults                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1092
short_host                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3363
short_opts                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1086
size_to_rows                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2536
slave_is_running                 0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3323
sort_indexes                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:128 
start_slave                      0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3075
stop_slave                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3067
timestampdiff                    0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2693
usage                            0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1765
verify_checksum_compat           0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4877
wait_for_master                  0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3044


