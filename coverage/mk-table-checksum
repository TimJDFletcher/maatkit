---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...hecksum/mk-table-checksum   52.9   34.3   33.0   61.7    n/a  100.0   46.0
Total                          52.9   34.3   33.0   61.7    n/a  100.0   46.0
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:41:54 2010
Finish:       Sat May  1 00:41:54 2010

Run:          ./101_basics.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:41:55 2010
Finish:       Sat May  1 00:41:57 2010

Run:          ./102_since.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:42:01 2010
Finish:       Sat May  1 00:42:04 2010

Run:          ./103_schema.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:42:08 2010
Finish:       Sat May  1 00:42:15 2010

Run:          ./104_resume.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:42:19 2010
Finish:       Sat May  1 00:42:22 2010

Run:          ./105_chunk_size.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:42:26 2010
Finish:       Sat May  1 00:42:27 2010

Run:          ./106_float_precision.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:42:31 2010
Finish:       Sat May  1 00:42:32 2010

Run:          ./107_probability.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:42:36 2010
Finish:       Sat May  1 00:42:37 2010

Run:          ./108_arg_table.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:42:40 2010
Finish:       Sat May  1 00:42:43 2010

Run:          ./109_offset_modulo.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:42:47 2010
Finish:       Sat May  1 00:42:47 2010

Run:          ./110_force_index.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:42:51 2010
Finish:       Sat May  1 00:42:52 2010

Run:          ./111_create_replicate_table.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:42:55 2010
Finish:       Sat May  1 00:42:57 2010

Run:          ./112_ignore_columns.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:43:01 2010
Finish:       Sat May  1 00:43:01 2010

Run:          ./113_checksum.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:43:05 2010
Finish:       Sat May  1 00:43:06 2010

Run:          ./114_standard_options.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:43:10 2010
Finish:       Sat May  1 00:43:10 2010

Run:          ./115_replicate.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:43:14 2010
Finish:       Sat May  1 00:43:16 2010

Run:          ./116_fnv_64.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:43:19 2010
Finish:       Sat May  1 00:43:21 2010

Run:          ./117_filters.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:43:25 2010
Finish:       Sat May  1 00:43:25 2010

Run:          ./118_throttle.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:43:29 2010
Finish:       Sat May  1 00:43:37 2010

Run:          ./201_issue_35.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:43:40 2010
Finish:       Sat May  1 00:43:42 2010

Run:          ./202_issue_21.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:43:46 2010
Finish:       Sat May  1 00:43:49 2010

Run:          ./203_issue_69.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:43:52 2010
Finish:       Sat May  1 00:43:54 2010

Run:          ./204_issue_81.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:43:58 2010
Finish:       Sat May  1 00:43:59 2010

Run:          ./205_issue_47.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:44:03 2010
Finish:       Sat May  1 00:44:03 2010

Run:          ./206_issue_122.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:44:07 2010
Finish:       Sat May  1 00:44:08 2010

Run:          ./207_issue_51.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:44:11 2010
Finish:       Sat May  1 00:44:12 2010

Run:          ./208_issue_388.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:44:16 2010
Finish:       Sat May  1 00:44:16 2010

Run:          ./209_issue_947.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:44:20 2010
Finish:       Sat May  1 00:44:20 2010

Run:          ./mk-checksum-filter.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sat May  1 00:44:24 2010
Finish:       Sat May  1 00:44:24 2010

/home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This program checksums MySQL tables efficiently on one or more servers.
4                                                     #
5                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
6                                                     # Feedback and improvements are welcome.
7                                                     #
8                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
9                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
10                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
11                                                    #
12                                                    # This program is free software; you can redistribute it and/or modify it under
13                                                    # the terms of the GNU General Public License as published by the Free Software
14                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
15                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
16                                                    # licenses.
17                                                    #
18                                                    # You should have received a copy of the GNU General Public License along with
19                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
20                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
21                                                    
22            27                   27           162   use strict;
              27                                 87   
              27                                184   
23            27                   27           167   use warnings FATAL => 'all';
              27                                 70   
              27                                181   
24                                                    
25                                                    our $VERSION = '@VERSION@';
26                                                    our $DISTRIB = '@DISTRIB@';
27                                                    our $SVN_REV = sprintf("%d", (q$Revision: 6208 $ =~ m/(\d+)/g, 0));
28                                                    
29                                                    # ###########################################################################
30                                                    # TableParser package 5980
31                                                    # This package is a copy without comments from the original.  The original
32                                                    # with comments and its test file can be found in the SVN repository at,
33                                                    #   trunk/common/TableParser.pm
34                                                    #   trunk/common/t/TableParser.t
35                                                    # See http://code.google.com/p/maatkit/wiki/Developers for more information.
36                                                    # ###########################################################################
37                                                    package TableParser;
38                                                    
39            27                   27           169   use strict;
              27                                 69   
              27                                128   
40            27                   27           167   use warnings FATAL => 'all';
              27                                 67   
              27                                133   
41            27                   27           174   use English qw(-no_match_vars);
              27                                 71   
              27                                179   
42            27                   27           183   use Data::Dumper;
              27                                 66   
              27                                230   
43                                                    $Data::Dumper::Indent    = 1;
44                                                    $Data::Dumper::Sortkeys  = 1;
45                                                    $Data::Dumper::Quotekeys = 0;
46                                                    
47    ***     27            50     27           178   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 65   
              27                                401   
48                                                    
49                                                    
50                                                    sub new {
51            15                   15           100      my ( $class, %args ) = @_;
52            15                                 79      my @required_args = qw(Quoter);
53            15                                 62      foreach my $arg ( @required_args ) {
54    ***     15     50                          94         die "I need a $arg argument" unless $args{$arg};
55                                                       }
56            15                                 88      my $self = { %args };
57            15                                137      return bless $self, $class;
58                                                    }
59                                                    
60                                                    
61                                                    sub parse {
62            15                   15            87      my ( $self, $ddl, $opts ) = @_;
63    ***     15     50                          71      return unless $ddl;
64    ***     15     50                          90      if ( ref $ddl eq 'ARRAY' ) {
65    ***     15     50                          88         if ( lc $ddl->[0] eq 'table' ) {
66            15                                 66            $ddl = $ddl->[1];
67                                                          }
68                                                          else {
69                                                             return {
70    ***      0                                  0               engine => 'VIEW',
71                                                             };
72                                                          }
73                                                       }
74                                                    
75    ***     15     50                         170      if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
76    ***      0                                  0         die "Cannot parse table definition; is ANSI quoting "
77                                                             . "enabled or SQL_QUOTE_SHOW_CREATE disabled?";
78                                                       }
79                                                    
80            15                                188      my ($name)     = $ddl =~ m/CREATE (?:TEMPORARY )?TABLE\s+(`.+?`)/;
81    ***     15     50                         147      (undef, $name) = $self->{Quoter}->split_unquote($name) if $name;
82                                                    
83            15                                376      $ddl =~ s/(`[^`]+`)/\L$1/g;
84                                                    
85            15                                 92      my $engine = $self->get_engine($ddl);
86                                                    
87            15                                497      my @defs   = $ddl =~ m/^(\s+`.*?),?$/gm;
88            15                                 75      my @cols   = map { $_ =~ m/`([^`]+)`/ } @defs;
              53                                288   
89            15                                 42      MKDEBUG && _d('Table cols:', join(', ', map { "`$_`" } @cols));
90                                                    
91            15                                 49      my %def_for;
92            15                                117      @def_for{@cols} = @defs;
93                                                    
94            15                                 47      my (@nums, @null);
95            15                                 54      my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
96            15                                 60      foreach my $col ( @cols ) {
97            53                                172         my $def = $def_for{$col};
98            53                                321         my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
99    ***     53     50                         200         die "Can't determine column type for $def" unless $type;
100           53                                187         $type_for{$col} = $type;
101           53    100                         300         if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
102           18                                 71            push @nums, $col;
103           18                                 75            $is_numeric{$col} = 1;
104                                                         }
105           53    100                         232         if ( $def !~ m/NOT NULL/ ) {
106            1                                  3            push @null, $col;
107            1                                  3            $is_nullable{$col} = 1;
108                                                         }
109           53    100                         319         $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
110                                                      }
111                                                   
112           15                                115      my ($keys, $clustered_key) = $self->get_keys($ddl, $opts, \%is_nullable);
113                                                   
114                                                      return {
115           53                                260         name           => $name,
116                                                         cols           => \@cols,
117           53                                462         col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
118           15                                164         is_col         => { map { $_ => 1 } @cols },
119                                                         null_cols      => \@null,
120                                                         is_nullable    => \%is_nullable,
121                                                         is_autoinc     => \%is_autoinc,
122                                                         clustered_key  => $clustered_key,
123                                                         keys           => $keys,
124                                                         defs           => \%def_for,
125                                                         numeric_cols   => \@nums,
126                                                         is_numeric     => \%is_numeric,
127                                                         engine         => $engine,
128                                                         type_for       => \%type_for,
129                                                      };
130                                                   }
131                                                   
132                                                   sub sort_indexes {
133   ***      0                    0             0      my ( $self, $tbl ) = @_;
134                                                   
135                                                      my @indexes
136   ***      0                                  0         = sort {
137   ***      0                                  0            (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
138                                                            || ( !$tbl->{keys}->{$a}->{is_unique} <=> !$tbl->{keys}->{$b}->{is_unique} )
139                                                            || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
140   ***      0      0      0                    0            || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      ***      0             0                    0   
141                                                         }
142                                                         grep {
143   ***      0                                  0            $tbl->{keys}->{$_}->{type} eq 'BTREE'
144                                                         }
145   ***      0                                  0         sort keys %{$tbl->{keys}};
146                                                   
147   ***      0                                  0      MKDEBUG && _d('Indexes sorted best-first:', join(', ', @indexes));
148   ***      0                                  0      return @indexes;
149                                                   }
150                                                   
151                                                   sub find_best_index {
152   ***      0                    0             0      my ( $self, $tbl, $index ) = @_;
153   ***      0                                  0      my $best;
154   ***      0      0                           0      if ( $index ) {
155   ***      0                                  0         ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
      ***      0                                  0   
      ***      0                                  0   
156                                                      }
157   ***      0      0                           0      if ( !$best ) {
158   ***      0      0                           0         if ( $index ) {
159   ***      0                                  0            die "Index '$index' does not exist in table";
160                                                         }
161                                                         else {
162   ***      0                                  0            ($best) = $self->sort_indexes($tbl);
163                                                         }
164                                                      }
165   ***      0                                  0      MKDEBUG && _d('Best index found is', $best);
166   ***      0                                  0      return $best;
167                                                   }
168                                                   
169                                                   sub find_possible_keys {
170   ***      0                    0             0      my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
171   ***      0      0                           0      return () unless $where;
172   ***      0                                  0      my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
173                                                         . ' WHERE ' . $where;
174   ***      0                                  0      MKDEBUG && _d($sql);
175   ***      0                                  0      my $expl = $dbh->selectrow_hashref($sql);
176   ***      0                                  0      $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
      ***      0                                  0   
177   ***      0      0                           0      if ( $expl->{possible_keys} ) {
178   ***      0                                  0         MKDEBUG && _d('possible_keys =', $expl->{possible_keys});
179   ***      0                                  0         my @candidates = split(',', $expl->{possible_keys});
180   ***      0                                  0         my %possible   = map { $_ => 1 } @candidates;
      ***      0                                  0   
181   ***      0      0                           0         if ( $expl->{key} ) {
182   ***      0                                  0            MKDEBUG && _d('MySQL chose', $expl->{key});
183   ***      0                                  0            unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
      ***      0                                  0   
184   ***      0                                  0            MKDEBUG && _d('Before deduping:', join(', ', @candidates));
185   ***      0                                  0            my %seen;
186   ***      0                                  0            @candidates = grep { !$seen{$_}++ } @candidates;
      ***      0                                  0   
187                                                         }
188   ***      0                                  0         MKDEBUG && _d('Final list:', join(', ', @candidates));
189   ***      0                                  0         return @candidates;
190                                                      }
191                                                      else {
192   ***      0                                  0         MKDEBUG && _d('No keys in possible_keys');
193   ***      0                                  0         return ();
194                                                      }
195                                                   }
196                                                   
197                                                   sub check_table {
198           10                   10            87      my ( $self, %args ) = @_;
199           10                                 55      my @required_args = qw(dbh db tbl);
200           10                                 49      foreach my $arg ( @required_args ) {
201   ***     30     50                         159         die "I need a $arg argument" unless $args{$arg};
202                                                      }
203           10                                 62      my ($dbh, $db, $tbl) = @args{@required_args};
204           10                                 41      my $q      = $self->{Quoter};
205           10                                 57      my $db_tbl = $q->quote($db, $tbl);
206           10                                 30      MKDEBUG && _d('Checking', $db_tbl);
207                                                   
208           10                                 45      my $sql = "SHOW TABLES FROM " . $q->quote($db)
209                                                              . ' LIKE ' . $q->literal_like($tbl);
210           10                                 25      MKDEBUG && _d($sql);
211           10                                 30      my $row;
212           10                                 29      eval {
213           10                                 25         $row = $dbh->selectrow_arrayref($sql);
214                                                      };
215   ***     10     50                        2922      if ( $EVAL_ERROR ) {
216   ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
217   ***      0                                  0         return 0;
218                                                      }
219   ***     10     50     33                  148      if ( !$row->[0] || $row->[0] ne $tbl ) {
220   ***      0                                  0         MKDEBUG && _d('Table does not exist');
221   ***      0                                  0         return 0;
222                                                      }
223                                                   
224           10                                 26      MKDEBUG && _d('Table exists; no privs to check');
225           10    100                          73      return 1 unless $args{all_privs};
226                                                   
227            5                                 24      $sql = "SHOW FULL COLUMNS FROM $db_tbl";
228            5                                 14      MKDEBUG && _d($sql);
229            5                                 17      eval {
230            5                                 12         $row = $dbh->selectrow_hashref($sql);
231                                                      };
232   ***      5     50                          53      if ( $EVAL_ERROR ) {
233   ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
234   ***      0                                  0         return 0;
235                                                      }
236   ***      5     50                          37      if ( !scalar keys %$row ) {
237   ***      0                                  0         MKDEBUG && _d('Table has no columns:', Dumper($row));
238   ***      0                                  0         return 0;
239                                                      }
240   ***      5            33                   35      my $privs = $row->{privileges} || $row->{Privileges};
241                                                   
242            5                                 34      $sql = "DELETE FROM $db_tbl LIMIT 0";
243            5                                 12      MKDEBUG && _d($sql);
244            5                                 15      eval {
245            5                                682         $dbh->do($sql);
246                                                      };
247   ***      5     50                          32      my $can_delete = $EVAL_ERROR ? 0 : 1;
248                                                   
249            5                                 15      MKDEBUG && _d('User privs on', $db_tbl, ':', $privs,
250                                                         ($can_delete ? 'delete' : ''));
251                                                   
252   ***      5     50     33                  156      if ( !($privs =~ m/select/ && $privs =~ m/insert/ && $privs =~ m/update/
      ***                   33                        
      ***                   33                        
253                                                             && $can_delete) ) {
254   ***      0                                  0         MKDEBUG && _d('User does not have all privs');
255   ***      0                                  0         return 0;
256                                                      }
257                                                   
258            5                                 17      MKDEBUG && _d('User has all privs');
259            5                                 54      return 1;
260                                                   }
261                                                   
262                                                   sub get_engine {
263           30                   30           157      my ( $self, $ddl, $opts ) = @_;
264           30                                488      my ( $engine ) = $ddl =~ m/\).*?(?:ENGINE|TYPE)=(\w+)/;
265           30                                 86      MKDEBUG && _d('Storage engine:', $engine);
266   ***     30            50                  173      return $engine || undef;
267                                                   }
268                                                   
269                                                   sub get_keys {
270           15                   15            98      my ( $self, $ddl, $opts, $is_nullable ) = @_;
271           15                                 69      my $engine        = $self->get_engine($ddl);
272           15                                 74      my $keys          = {};
273           15                                 43      my $clustered_key = undef;
274                                                   
275                                                      KEY:
276           15                                251      foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {
277                                                   
278   ***     14     50                          75         next KEY if $key =~ m/FOREIGN/;
279                                                   
280           14                                 47         my $key_ddl = $key;
281           14                                 34         MKDEBUG && _d('Parsed key:', $key_ddl);
282                                                   
283   ***     14     50                         102         if ( $engine !~ m/MEMORY|HEAP/ ) {
284           14                                 62            $key =~ s/USING HASH/USING BTREE/;
285                                                         }
286                                                   
287           14                                115         my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
288           14                                 70         my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
289   ***     14            33                  238         $type = $type || $special || 'BTREE';
      ***                   50                        
290   ***     14     50     33                  126         if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
      ***                   33                        
291                                                            && $engine =~ m/HEAP|MEMORY/i )
292                                                         {
293   ***      0                                  0            $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
294                                                         }
295                                                   
296           14                                122         my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
297   ***     14     50                         102         my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
298           14                                 47         my @cols;
299           14                                 40         my @col_prefixes;
300           14                                 98         foreach my $col_def ( $cols =~ m/`[^`]+`(?:\(\d+\))?/g ) {
301           15                                107            my ($name, $prefix) = $col_def =~ m/`([^`]+)`(?:\((\d+)\))?/;
302           15                                 61            push @cols, $name;
303           15                                 68            push @col_prefixes, $prefix;
304                                                         }
305           14                                 68         $name =~ s/`//g;
306                                                   
307           14                                 33         MKDEBUG && _d( $name, 'key cols:', join(', ', map { "`$_`" } @cols));
308                                                   
309           15                                 81         $keys->{$name} = {
310                                                            name         => $name,
311                                                            type         => $type,
312                                                            colnames     => $cols,
313                                                            cols         => \@cols,
314                                                            col_prefixes => \@col_prefixes,
315                                                            is_unique    => $unique,
316           15                                198            is_nullable  => scalar(grep { $is_nullable->{$_} } @cols),
317           14                                100            is_col       => { map { $_ => 1 } @cols },
318                                                            ddl          => $key_ddl,
319                                                         };
320                                                   
321   ***     14    100     66                  175         if ( $engine =~ m/InnoDB/i && !$clustered_key ) {
322            5                                 22            my $this_key = $keys->{$name};
323   ***      5     50     33                   70            if ( $this_key->{name} eq 'PRIMARY' ) {
      ***            50                               
324   ***      0                                  0               $clustered_key = 'PRIMARY';
325                                                            }
326                                                            elsif ( $this_key->{is_unique} && !$this_key->{is_nullable} ) {
327            5                                 20               $clustered_key = $this_key->{name};
328                                                            }
329            5                                 25            MKDEBUG && $clustered_key && _d('This key is the clustered key');
330                                                         }
331                                                      }
332                                                   
333           15                                 84      return $keys, $clustered_key;
334                                                   }
335                                                   
336                                                   sub get_fks {
337   ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
338   ***      0                                  0      my $fks = {};
339                                                   
340   ***      0                                  0      foreach my $fk (
341                                                         $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg )
342                                                      {
343   ***      0                                  0         my ( $name ) = $fk =~ m/CONSTRAINT `(.*?)`/;
344   ***      0                                  0         my ( $cols ) = $fk =~ m/FOREIGN KEY \(([^\)]+)\)/;
345   ***      0                                  0         my ( $parent, $parent_cols ) = $fk =~ m/REFERENCES (\S+) \(([^\)]+)\)/;
346                                                   
347   ***      0      0      0                    0         if ( $parent !~ m/\./ && $opts->{database} ) {
348   ***      0                                  0            $parent = "`$opts->{database}`.$parent";
349                                                         }
350                                                   
351   ***      0                                  0         $fks->{$name} = {
352                                                            name           => $name,
353                                                            colnames       => $cols,
354   ***      0                                  0            cols           => [ map { s/[ `]+//g; $_; } split(',', $cols) ],
      ***      0                                  0   
355                                                            parent_tbl     => $parent,
356                                                            parent_colnames=> $parent_cols,
357   ***      0                                  0            parent_cols    => [ map { s/[ `]+//g; $_; } split(',', $parent_cols) ],
      ***      0                                  0   
358                                                            ddl            => $fk,
359                                                         };
360                                                      }
361                                                   
362   ***      0                                  0      return $fks;
363                                                   }
364                                                   
365                                                   sub remove_auto_increment {
366   ***      0                    0             0      my ( $self, $ddl ) = @_;
367   ***      0                                  0      $ddl =~ s/(^\).*?) AUTO_INCREMENT=\d+\b/$1/m;
368   ***      0                                  0      return $ddl;
369                                                   }
370                                                   
371                                                   sub remove_secondary_indexes {
372   ***      0                    0             0      my ( $self, $ddl ) = @_;
373   ***      0                                  0      my $sec_indexes_ddl;
374   ***      0                                  0      my $tbl_struct = $self->parse($ddl);
375                                                   
376   ***      0      0      0                    0      if ( ($tbl_struct->{engine} || '') =~ m/InnoDB/i ) {
377   ***      0                                  0         my $clustered_key = $tbl_struct->{clustered_key};
378   ***      0             0                    0         $clustered_key  ||= '';
379                                                   
380   ***      0                                  0         my @sec_indexes   = map {
381   ***      0                                  0            my $key_def = $_->{ddl};
382   ***      0                                  0            $key_def =~ s/([\(\)])/\\$1/g;
383   ***      0                                  0            $ddl =~ s/\s+$key_def//i;
384                                                   
385   ***      0                                  0            my $key_ddl = "ADD $_->{ddl}";
386   ***      0      0                           0            $key_ddl   .= ',' unless $key_ddl =~ m/,$/;
387   ***      0                                  0            $key_ddl;
388                                                         }
389   ***      0                                  0         grep { $_->{name} ne $clustered_key }
390   ***      0                                  0         values %{$tbl_struct->{keys}};
391   ***      0                                  0         MKDEBUG && _d('Secondary indexes:', Dumper(\@sec_indexes));
392                                                   
393   ***      0      0                           0         if ( @sec_indexes ) {
394   ***      0                                  0            $sec_indexes_ddl = join(' ', @sec_indexes);
395   ***      0                                  0            $sec_indexes_ddl =~ s/,$//;
396                                                         }
397                                                   
398   ***      0                                  0         $ddl =~ s/,(\n\) )/$1/s;
399                                                      }
400                                                      else {
401   ***      0                                  0         MKDEBUG && _d('Not removing secondary indexes from',
402                                                            $tbl_struct->{engine}, 'table');
403                                                      }
404                                                   
405   ***      0                                  0      return $ddl, $sec_indexes_ddl, $tbl_struct;
406                                                   }
407                                                   
408                                                   sub _d {
409   ***      0                    0             0      my ($package, undef, $line) = caller 0;
410   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
411   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
412                                                           @_;
413   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
414                                                   }
415                                                   
416                                                   1;
417                                                   
418                                                   # ###########################################################################
419                                                   # End TableParser package
420                                                   # ###########################################################################
421                                                   
422                                                   # ###########################################################################
423                                                   # TableChecksum package 6078
424                                                   # This package is a copy without comments from the original.  The original
425                                                   # with comments and its test file can be found in the SVN repository at,
426                                                   #   trunk/common/TableChecksum.pm
427                                                   #   trunk/common/t/TableChecksum.t
428                                                   # See http://code.google.com/p/maatkit/wiki/Developers for more information.
429                                                   # ###########################################################################
430                                                   package TableChecksum;
431                                                   
432           27                   27           234   use strict;
              27                                 81   
              27                                181   
433           27                   27           165   use warnings FATAL => 'all';
              27                                 80   
              27                                174   
434           27                   27           166   use English qw(-no_match_vars);
              27                                 63   
              27                                153   
435           27                   27           200   use List::Util qw(max);
              27                                 71   
              27                                389   
436                                                   
437   ***     27            50     27           173   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 71   
              27                                499   
438                                                   
439                                                   our %ALGOS = (
440                                                      CHECKSUM => { pref => 0, hash => 0 },
441                                                      BIT_XOR  => { pref => 2, hash => 1 },
442                                                      ACCUM    => { pref => 3, hash => 1 },
443                                                   );
444                                                   
445                                                   sub new {
446           15                   15           101      my ( $class, %args ) = @_;
447           15                                 71      foreach my $arg ( qw(Quoter VersionParser) ) {
448   ***     30     50                         193         die "I need a $arg argument" unless defined $args{$arg};
449                                                      }
450           15                                 80      my $self = { %args };
451           15                                129      return bless $self, $class;
452                                                   }
453                                                   
454                                                   sub crc32 {
455   ***      0                    0             0      my ( $self, $string ) = @_;
456   ***      0                                  0      my $poly = 0xEDB88320;
457   ***      0                                  0      my $crc  = 0xFFFFFFFF;
458   ***      0                                  0      foreach my $char ( split(//, $string) ) {
459   ***      0                                  0         my $comp = ($crc ^ ord($char)) & 0xFF;
460   ***      0                                  0         for ( 1 .. 8 ) {
461   ***      0      0                           0            $comp = $comp & 1 ? $poly ^ ($comp >> 1) : $comp >> 1;
462                                                         }
463   ***      0                                  0         $crc = (($crc >> 8) & 0x00FFFFFF) ^ $comp;
464                                                      }
465   ***      0                                  0      return $crc ^ 0xFFFFFFFF;
466                                                   }
467                                                   
468                                                   sub get_crc_wid {
469           12                   12            69      my ( $self, $dbh, $func ) = @_;
470           12                                 41      my $crc_wid = 16;
471   ***     12     50     33                  140      if ( uc $func ne 'FNV_64' && uc $func ne 'FNV1A_64' ) {
472           12                                 40         eval {
473           12                                 33            my ($val) = $dbh->selectrow_array("SELECT $func('a')");
474           12                               1503            $crc_wid = max(16, length($val));
475                                                         };
476                                                      }
477           12                                 65      return $crc_wid;
478                                                   }
479                                                   
480                                                   sub get_crc_type {
481           12                   12            69      my ( $self, $dbh, $func ) = @_;
482           12                                 40      my $type   = '';
483           12                                 35      my $length = 0;
484           12                                 56      my $sql    = "SELECT $func('a')";
485           12                                 28      my $sth    = $dbh->prepare($sql);
486           12                                 64      eval {
487           12                               1281         $sth->execute();
488           12                                127         $type   = $sth->{mysql_type_name}->[0];
489           12                                 82         $length = $sth->{mysql_length}->[0];
490           12                                 62         MKDEBUG && _d($sql, $type, $length);
491   ***     12    100     66                  135         if ( $type eq 'bigint' && $length < 20 ) {
492            6                                 26            $type = 'int';
493                                                         }
494                                                      };
495           12                                121      $sth->finish;
496           12                                 28      MKDEBUG && _d('crc_type:', $type, 'length:', $length);
497           12                                221      return ($type, $length);
498                                                   }
499                                                   
500                                                   sub best_algorithm {
501           15                   15           149      my ( $self, %args ) = @_;
502           15                                 94      my ( $alg, $dbh ) = @args{ qw(algorithm dbh) };
503           15                                 59      my $vp = $self->{VersionParser};
504           15                                 32      my @choices = sort { $ALGOS{$a}->{pref} <=> $ALGOS{$b}->{pref} } keys %ALGOS;
              45                                236   
505   ***     15     50     66                  179      die "Invalid checksum algorithm $alg"
506                                                         if $alg && !$ALGOS{$alg};
507                                                   
508   ***     15    100     33                  338      if (
      ***                   66                        
      ***                   66                        
509                                                         $args{where} || $args{chunk}        # CHECKSUM does whole table
510                                                         || $args{replicate}                 # CHECKSUM can't do INSERT.. SELECT
511                                                         || !$vp->version_ge($dbh, '4.1.1')) # CHECKSUM doesn't exist
512                                                      {
513            5                                 12         MKDEBUG && _d('Cannot use CHECKSUM algorithm');
514            5                                 20         @choices = grep { $_ ne 'CHECKSUM' } @choices;
              15                                 70   
515                                                      }
516                                                   
517   ***     15     50                          77      if ( !$vp->version_ge($dbh, '4.1.1') ) {
518   ***      0                                  0         MKDEBUG && _d('Cannot use BIT_XOR algorithm because MySQL < 4.1.1');
519   ***      0                                  0         @choices = grep { $_ ne 'BIT_XOR' } @choices;
      ***      0                                  0   
520                                                      }
521                                                   
522   ***     15    100     66                  104      if ( $alg && grep { $_ eq $alg } @choices ) {
              21                                100   
523            7                                 16         MKDEBUG && _d('User requested', $alg, 'algorithm');
524            7                                 63         return $alg;
525                                                      }
526                                                   
527   ***      8     50     33                   53      if ( $args{count} && grep { $_ ne 'CHECKSUM' } @choices ) {
      ***      0                                  0   
528   ***      0                                  0         MKDEBUG && _d('Not using CHECKSUM algorithm because COUNT desired');
529   ***      0                                  0         @choices = grep { $_ ne 'CHECKSUM' } @choices;
      ***      0                                  0   
530                                                      }
531                                                   
532            8                                 35      MKDEBUG && _d('Algorithms, in order:', @choices);
533            8                                 56      return $choices[0];
534                                                   }
535                                                   
536                                                   sub is_hash_algorithm {
537           15                   15            76      my ( $self, $algorithm ) = @_;
538   ***     15            66                  197      return $ALGOS{$algorithm} && $ALGOS{$algorithm}->{hash};
539                                                   }
540                                                   
541                                                   sub choose_hash_func {
542           12                   12            75      my ( $self, %args ) = @_;
543           12                                 75      my @funcs = qw(CRC32 FNV1A_64 FNV_64 MD5 SHA1);
544           12    100                          60      if ( $args{function} ) {
545            7                                 33         unshift @funcs, $args{function};
546                                                      }
547           12                                 40      my ($result, $error);
548   ***     12            33                   35      do {
549           12                                 35         my $func;
550           12                                 35         eval {
551           12                                 42            $func = shift(@funcs);
552           12                                 62            my $sql = "SELECT $func('test-string')";
553           12                                 29            MKDEBUG && _d($sql);
554           12                               1820            $args{dbh}->do($sql);
555           12                                 70            $result = $func;
556                                                         };
557   ***     12     50     33                  186         if ( $EVAL_ERROR && $EVAL_ERROR =~ m/failed: (.*?) at \S+ line/ ) {
558   ***      0                                  0            $error .= qq{$func cannot be used because "$1"\n};
559   ***      0                                  0            MKDEBUG && _d($func, 'cannot be used because', $1);
560                                                         }
561                                                      } while ( @funcs && !$result );
562                                                   
563   ***     12     50                          53      die $error unless $result;
564           12                                 31      MKDEBUG && _d('Chosen hash func:', $result);
565           12                                 91      return $result;
566                                                   }
567                                                   
568                                                   sub optimize_xor {
569            2                    2            13      my ( $self, %args ) = @_;
570            2                                 13      my ($dbh, $func) = @args{qw(dbh function)};
571                                                   
572   ***      2     50                          12      die "$func never needs the BIT_XOR optimization"
573                                                         if $func =~ m/^(?:FNV1A_64|FNV_64|CRC32)$/i;
574                                                   
575            2                                  6      my $opt_slice = 0;
576            2                                  6      my $unsliced  = uc $dbh->selectall_arrayref("SELECT $func('a')")->[0]->[0];
577            2                                242      my $sliced    = '';
578            2                                  7      my $start     = 1;
579   ***      2     50                          12      my $crc_wid   = length($unsliced) < 16 ? 16 : length($unsliced);
580                                                   
581   ***      2            66                    7      do { # Try different positions till sliced result equals non-sliced.
582            5                                 10         MKDEBUG && _d('Trying slice', $opt_slice);
583            5                                430         $dbh->do('SET @crc := "", @cnt := 0');
584            5                                 45         my $slices = $self->make_xor_slices(
585                                                            query     => "\@crc := $func('a')",
586                                                            crc_wid   => $crc_wid,
587                                                            opt_slice => $opt_slice,
588                                                         );
589                                                   
590            5                                 23         my $sql = "SELECT CONCAT($slices) AS TEST FROM (SELECT NULL) AS x";
591            5                                 12         $sliced = ($dbh->selectrow_array($sql))[0];
592            5    100                        1323         if ( $sliced ne $unsliced ) {
593            3                                  9            MKDEBUG && _d('Slice', $opt_slice, 'does not work');
594            3                                 10            $start += 16;
595            3                                 42            ++$opt_slice;
596                                                         }
597                                                      } while ( $start < $crc_wid && $sliced ne $unsliced );
598                                                   
599   ***      2     50                          11      if ( $sliced eq $unsliced ) {
600            2                                  5         MKDEBUG && _d('Slice', $opt_slice, 'works');
601            2                                 16         return $opt_slice;
602                                                      }
603                                                      else {
604   ***      0                                  0         MKDEBUG && _d('No slice works');
605   ***      0                                  0         return undef;
606                                                      }
607                                                   }
608                                                   
609                                                   sub make_xor_slices {
610            8                    8            77      my ( $self, %args ) = @_;
611            8                                 44      foreach my $arg ( qw(query crc_wid) ) {
612   ***     16     50                          85         die "I need a $arg argument" unless defined $args{$arg};
613                                                      }
614            8                                 47      my ( $query, $crc_wid, $opt_slice ) = @args{qw(query crc_wid opt_slice)};
615                                                   
616            8                                 24      my @slices;
617                                                      for ( my $start = 1; $start <= $crc_wid; $start += 16 ) {
618           21                                 73         my $len = $crc_wid - $start + 1;
619           21    100                          82         if ( $len > 16 ) {
620           13                                 39            $len = 16;
621                                                         }
622           21                                184         push @slices,
623                                                            "LPAD(CONV(BIT_XOR("
624                                                            . "CAST(CONV(SUBSTRING(\@crc, $start, $len), 16, 10) AS UNSIGNED))"
625                                                            . ", 10, 16), $len, '0')";
626            8                                 21      }
627                                                   
628   ***      8    100     66                   72      if ( defined $opt_slice && $opt_slice < @slices ) {
629            7                                 76         $slices[$opt_slice] =~ s/\@crc/\@crc := $query/;
630                                                      }
631                                                      else {
632            1                                  4         map { s/\@crc/$query/ } @slices;
               3                                 24   
633                                                      }
634                                                   
635            8                                 65      return join(', ', @slices);
636                                                   }
637                                                   
638                                                   sub make_row_checksum {
639           12                   12           180      my ( $self, %args ) = @_;
640           12                                 90      my ( $tbl_struct, $func ) = @args{ qw(tbl_struct function) };
641           12                                 44      my $q = $self->{Quoter};
642                                                   
643   ***     12            50                   64      my $sep = $args{sep} || '#';
644           12                                 62      $sep =~ s/'//g;
645   ***     12            50                   50      $sep ||= '#';
646                                                   
647           12                                 41      my %ignorecols = map { $_ => 1 } @{$args{ignorecols}};
      ***      0                                  0   
              12                                 65   
648                                                   
649           12                                 76      my %cols = map { lc($_) => 1 }
              12                                 57   
650   ***      0                                  0                 grep { !exists $ignorecols{$_} }
651   ***     12     50                          67                 ($args{cols} ? @{$args{cols}} : @{$tbl_struct->{cols}});
              12                                 74   
652           12                                 49      my %seen;
653           12                                 79      my @cols =
654                                                         map {
655   ***     12     50                         186            my $type = $tbl_struct->{type_for}->{$_};
656           12                                 64            my $result = $q->quote($_);
657   ***     12     50     33                  141            if ( $type eq 'timestamp' ) {
      ***            50     33                        
      ***            50                               
658   ***      0                                  0               $result .= ' + 0';
659                                                            }
660                                                            elsif ( $args{float_precision} && $type =~ m/float|double/ ) {
661   ***      0                                  0               $result = "ROUND($result, $args{float_precision})";
662                                                            }
663                                                            elsif ( $args{trim} && $type =~ m/varchar/ ) {
664   ***      0                                  0               $result = "TRIM($result)";
665                                                            }
666           12                                 52            $result;
667                                                         }
668                                                         grep {
669           12                                 54            $cols{$_} && !$seen{$_}++
670                                                         }
671           12                                 40         @{$tbl_struct->{cols}};
672                                                   
673           12                                 38      my $query;
674   ***     12     50                          63      if ( !$args{no_cols} ) {
675   ***      0                                  0         $query = join(', ',
676                                                                     map { 
677   ***      0                                  0                        my $col = $_;
678   ***      0      0                           0                        if ( $col =~ m/\+ 0/ ) {
      ***             0                               
679   ***      0                                  0                           my ($real_col) = /^(\S+)/;
680   ***      0                                  0                           $col .= " AS $real_col";
681                                                                        }
682                                                                        elsif ( $col =~ m/TRIM/ ) {
683   ***      0                                  0                           my ($real_col) = m/TRIM\(([^\)]+)\)/;
684   ***      0                                  0                           $col .= " AS $real_col";
685                                                                        }
686   ***      0                                  0                        $col;
687                                                                     } @cols)
688                                                                . ', ';
689                                                      }
690                                                   
691   ***     12     50     33                  125      if ( uc $func ne 'FNV_64' && uc $func ne 'FNV1A_64' ) {
692           12                                 38         my @nulls = grep { $cols{$_} } @{$tbl_struct->{null_cols}};
      ***      0                                  0   
              12                                 85   
693   ***     12     50                          54         if ( @nulls ) {
694   ***      0                                  0            my $bitmap = "CONCAT("
695   ***      0                                  0               . join(', ', map { 'ISNULL(' . $q->quote($_) . ')' } @nulls)
696                                                               . ")";
697   ***      0                                  0            push @cols, $bitmap;
698                                                         }
699                                                   
700   ***     12     50                          90         $query .= @cols > 1
701                                                                 ? "$func(CONCAT_WS('$sep', " . join(', ', @cols) . '))'
702                                                                 : "$func($cols[0])";
703                                                      }
704                                                      else {
705   ***      0                                  0         my $fnv_func = uc $func;
706   ***      0                                  0         $query .= "$fnv_func(" . join(', ', @cols) . ')';
707                                                      }
708                                                   
709           12                                100      return $query;
710                                                   }
711                                                   
712                                                   sub make_checksum_query {
713           15                   15           283      my ( $self, %args ) = @_;
714           15                                125      my @required_args = qw(db tbl tbl_struct algorithm crc_wid crc_type);
715           15                                287      foreach my $arg( @required_args ) {
716   ***     90     50                         422         die "I need a $arg argument" unless $args{$arg};
717                                                      }
718           15                                113      my ( $db, $tbl, $tbl_struct, $algorithm,
719                                                           $crc_wid, $crc_type) = @args{@required_args};
720           15                                 52      my $func = $args{function};
721           15                                 57      my $q = $self->{Quoter};
722           15                                 42      my $result;
723                                                   
724   ***     15     50     33                  173      die "Invalid or missing checksum algorithm"
725                                                         unless $algorithm && $ALGOS{$algorithm};
726                                                   
727           15    100                          69      if ( $algorithm eq 'CHECKSUM' ) {
728            3                                 16         return "CHECKSUM TABLE " . $q->quote($db, $tbl);
729                                                      }
730                                                   
731           12                                151      my $expr = $self->make_row_checksum(%args, no_cols=>1);
732                                                   
733           12    100                          67      if ( $algorithm eq 'BIT_XOR' ) {
734            8    100                          46         if ( $crc_type =~ m/int$/ ) {
735            5                                 27            $result = "LOWER(CONV(BIT_XOR(CAST($expr AS UNSIGNED)), 10, 16)) AS crc ";
736                                                         }
737                                                         else {
738            3                                 24            my $slices = $self->make_xor_slices( query => $expr, %args );
739            3                                 19            $result = "LOWER(CONCAT($slices)) AS crc ";
740                                                         }
741                                                      }
742                                                      else {
743            4    100                          24         if ( $crc_type =~ m/int$/ ) {
744            1                                  9            $result = "RIGHT(MAX("
745                                                               . "\@crc := CONCAT(LPAD(\@cnt := \@cnt + 1, 16, '0'), "
746                                                               . "CONV(CAST($func(CONCAT(\@crc, $expr)) AS UNSIGNED), 10, 16))"
747                                                               . "), $crc_wid) AS crc ";
748                                                         }
749                                                         else {
750            3                                 21            $result = "RIGHT(MAX("
751                                                               . "\@crc := CONCAT(LPAD(\@cnt := \@cnt + 1, 16, '0'), "
752                                                               . "$func(CONCAT(\@crc, $expr)))"
753                                                               . "), $crc_wid) AS crc ";
754                                                         }
755                                                      }
756           12    100                          55      if ( $args{replicate} ) {
757            5                                 35         $result = "REPLACE /*PROGRESS_COMMENT*/ INTO $args{replicate} "
758                                                            . "(db, tbl, chunk, boundaries, this_cnt, this_crc) "
759                                                            . "SELECT ?, ?, /*CHUNK_NUM*/ ?, COUNT(*) AS cnt, $result";
760                                                      }
761                                                      else {
762   ***      7     50                          51         $result = "SELECT "
763                                                            . ($args{buffer} ? 'SQL_BUFFER_RESULT ' : '')
764                                                            . "/*PROGRESS_COMMENT*//*CHUNK_NUM*/ COUNT(*) AS cnt, $result";
765                                                      }
766           12                                103      return $result . "FROM /*DB_TBL*//*INDEX_HINT*//*WHERE*/";
767                                                   }
768                                                   
769                                                   sub find_replication_differences {
770   ***      0                    0             0      my ( $self, $dbh, $table ) = @_;
771                                                   
772   ***      0                                  0      (my $sql = <<"   EOF") =~ s/\s+/ /gm;
773                                                         SELECT db, tbl, chunk, boundaries,
774                                                            COALESCE(this_cnt-master_cnt, 0) AS cnt_diff,
775                                                            COALESCE(
776                                                               this_crc <> master_crc OR ISNULL(master_crc) <> ISNULL(this_crc),
777                                                               0
778                                                            ) AS crc_diff,
779                                                            this_cnt, master_cnt, this_crc, master_crc
780                                                         FROM $table
781                                                         WHERE master_cnt <> this_cnt OR master_crc <> this_crc
782                                                         OR ISNULL(master_crc) <> ISNULL(this_crc)
783                                                      EOF
784                                                   
785   ***      0                                  0      MKDEBUG && _d($sql);
786   ***      0                                  0      my $diffs = $dbh->selectall_arrayref($sql, { Slice => {} });
787   ***      0                                  0      return @$diffs;
788                                                   }
789                                                   
790                                                   sub _d {
791   ***      0                    0             0      my ($package, undef, $line) = caller 0;
792   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
793   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
794                                                           @_;
795   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
796                                                   }
797                                                   
798                                                   1;
799                                                   
800                                                   # ###########################################################################
801                                                   # End TableChecksum package
802                                                   # ###########################################################################
803                                                   
804                                                   # ###########################################################################
805                                                   # OptionParser package 5985
806                                                   # This package is a copy without comments from the original.  The original
807                                                   # with comments and its test file can be found in the SVN repository at,
808                                                   #   trunk/common/OptionParser.pm
809                                                   #   trunk/common/t/OptionParser.t
810                                                   # See http://code.google.com/p/maatkit/wiki/Developers for more information.
811                                                   # ###########################################################################
812                                                   package OptionParser;
813                                                   
814           27                   27           231   use strict;
              27                                 88   
              27                                161   
815           27                   27           178   use warnings FATAL => 'all';
              27                                 70   
              27                                154   
816                                                   
817           27                   27           342   use Getopt::Long;
              27                                 92   
              27                                194   
818           27                   27           202   use List::Util qw(max);
              27                                 74   
              27                                152   
819           27                   27           173   use English qw(-no_match_vars);
              27                                 73   
              27                                185   
820                                                   
821   ***     27            50     27           194   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                298   
              27                                433   
822                                                   
823                                                   my $POD_link_re = '[LC]<"?([^">]+)"?>';
824                                                   
825                                                   sub new {
826           30                   30           463      my ( $class, %args ) = @_;
827           30                                231      foreach my $arg ( qw(description) ) {
828   ***     30     50                         273         die "I need a $arg argument" unless $args{$arg};
829                                                      }
830                                                   
831           30                                459      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
832   ***     30            33                  186      $program_name ||= $PROGRAM_NAME;
833   ***     30            33                  385      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                   33                        
      ***                   50                        
834                                                   
835           30                                328      my %attributes = (
836                                                         'type'       => 1,
837                                                         'short form' => 1,
838                                                         'group'      => 1,
839                                                         'default'    => 1,
840                                                         'cumulative' => 1,
841                                                         'negatable'  => 1,
842                                                      );
843                                                   
844           30                               1925      my $self = {
845                                                         strict            => 1,
846                                                         prompt            => '<options>',
847                                                         head1             => 'OPTIONS',
848                                                         skip_rules        => 0,
849                                                         item              => '--(.*)',
850                                                         attributes        => \%attributes,
851                                                         parse_attributes  => \&_parse_attribs,
852                                                   
853                                                         %args,
854                                                   
855                                                         program_name      => $program_name,
856                                                         opts              => {},
857                                                         got_opts          => 0,
858                                                         short_opts        => {},
859                                                         defaults          => {},
860                                                         groups            => {},
861                                                         allowed_groups    => {},
862                                                         errors            => [],
863                                                         rules             => [],  # desc of rules for --help
864                                                         mutex             => [],  # rule: opts are mutually exclusive
865                                                         atleast1          => [],  # rule: at least one opt is required
866                                                         disables          => {},  # rule: opt disables other opts 
867                                                         defaults_to       => {},  # rule: opt defaults to value of other opt
868                                                         DSNParser         => undef,
869                                                         default_files     => [
870                                                            "/etc/maatkit/maatkit.conf",
871                                                            "/etc/maatkit/$program_name.conf",
872                                                            "$home/.maatkit.conf",
873                                                            "$home/.$program_name.conf",
874                                                         ],
875                                                         types             => {
876                                                            string => 's', # standard Getopt type
877                                                            int    => 'i', # standard Getopt type
878                                                            float  => 'f', # standard Getopt type
879                                                            Hash   => 'H', # hash, formed from a comma-separated list
880                                                            hash   => 'h', # hash as above, but only if a value is given
881                                                            Array  => 'A', # array, similar to Hash
882                                                            array  => 'a', # array, similar to hash
883                                                            DSN    => 'd', # DSN
884                                                            size   => 'z', # size with kMG suffix (powers of 2^10)
885                                                            time   => 'm', # time, with an optional suffix of s/h/m/d
886                                                         },
887                                                      };
888                                                   
889           30                                414      return bless $self, $class;
890                                                   }
891                                                   
892                                                   sub get_specs {
893           15                   15            81      my ( $self, $file ) = @_;
894   ***     15            50                  103      $file ||= __FILE__;
895           15                                120      my @specs = $self->_pod_to_specs($file);
896           15                                567      $self->_parse_specs(@specs);
897                                                   
898   ***     15     50                         812      open my $fh, "<", $file or die "Cannot open $file: $OS_ERROR";
899           15                                 56      my $contents = do { local $/ = undef; <$fh> };
              15                                145   
              15                               6683   
900           15                                134      close $file;
901   ***     15     50                        1798      if ( $contents =~ m/^=head1 DSN OPTIONS/m ) {
902           15                                 56         MKDEBUG && _d('Parsing DSN OPTIONS');
903           15                                143         my $dsn_attribs = {
904                                                            dsn  => 1,
905                                                            copy => 1,
906                                                         };
907                                                         my $parse_dsn_attribs = sub {
908          120                  120           628            my ( $self, $option, $attribs ) = @_;
909          240                                957            map {
910          120                                692               my $val = $attribs->{$_};
911   ***    240     50                        1310               if ( $val ) {
912   ***    240     50                        1332                  $val    = $val eq 'yes' ? 1
                    100                               
913                                                                          : $val eq 'no'  ? 0
914                                                                          :                 $val;
915          240                               1826                  $attribs->{$_} = $val;
916                                                               }
917                                                            } keys %$attribs;
918                                                            return {
919          120                               1934               key => $option,
920                                                               %$attribs,
921                                                            };
922           15                                221         };
923           15                                242         my $dsn_o = new OptionParser(
924                                                            description       => 'DSN OPTIONS',
925                                                            head1             => 'DSN OPTIONS',
926                                                            dsn               => 0,         # XXX don't infinitely recurse!
927                                                            item              => '\* (.)',  # key opts are a single character
928                                                            skip_rules        => 1,         # no rules before opts
929                                                            attributes        => $dsn_attribs,
930                                                            parse_attributes  => $parse_dsn_attribs,
931                                                         );
932          120                               1586         my @dsn_opts = map {
933           15                                127            my $opts = {
934                                                               key  => $_->{spec}->{key},
935                                                               dsn  => $_->{spec}->{dsn},
936                                                               copy => $_->{spec}->{copy},
937                                                               desc => $_->{desc},
938                                                            };
939          120                                486            $opts;
940                                                         } $dsn_o->_pod_to_specs($file);
941           15                                436         $self->{DSNParser} = DSNParser->new(opts => \@dsn_opts);
942                                                      }
943                                                   
944           15                                 48      return;
945                                                   }
946                                                   
947                                                   sub DSNParser {
948           15                   15            74      my ( $self ) = @_;
949           15                                 86      return $self->{DSNParser};
950                                                   };
951                                                   
952                                                   sub get_defaults_files {
953           15                   15            70      my ( $self ) = @_;
954           15                                 62      return @{$self->{default_files}};
              15                                211   
955                                                   }
956                                                   
957                                                   sub _pod_to_specs {
958           30                   30           643      my ( $self, $file ) = @_;
959   ***     30            50                  163      $file ||= __FILE__;
960   ***     30     50                        1391      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
961                                                   
962           30                                140      my @specs = ();
963           30                                125      my @rules = ();
964           30                                 95      my $para;
965                                                   
966           30                                252      local $INPUT_RECORD_SEPARATOR = '';
967           30                                943      while ( $para = <$fh> ) {
968        27855    100                      295822         next unless $para =~ m/^=head1 $self->{head1}/;
969           30                                137         last;
970                                                      }
971                                                   
972           30                                272      while ( $para = <$fh> ) {
973           60    100                         379         last if $para =~ m/^=over/;
974           30    100                         281         next if $self->{skip_rules};
975           15                                 87         chomp $para;
976           15                                201         $para =~ s/\s+/ /g;
977           15                                505         $para =~ s/$POD_link_re/$1/go;
978           15                                 59         MKDEBUG && _d('Option rule:', $para);
979           15                                171         push @rules, $para;
980                                                      }
981                                                   
982   ***     30     50                         181      die "POD has no $self->{head1} section" unless $para;
983                                                   
984           30                                112      do {
985         1095    100                       12964         if ( my ($option) = $para =~ m/^=item $self->{item}/ ) {
986         1065                               3603            chomp $para;
987         1065                               2743            MKDEBUG && _d($para);
988         1065                               3181            my %attribs;
989                                                   
990         1065                               4948            $para = <$fh>; # read next paragraph, possibly attributes
991                                                   
992         1065    100                        5160            if ( $para =~ m/: / ) { # attributes
993          900                               5535               $para =~ s/\s+\Z//g;
994         1575                               9227               %attribs = map {
995          900                               5607                     my ( $attrib, $val) = split(/: /, $_);
996   ***   1575     50                       10242                     die "Unrecognized attribute for --$option: $attrib"
997                                                                        unless $self->{attributes}->{$attrib};
998         1575                              10254                     ($attrib, $val);
999                                                                  } split(/; /, $para);
1000         900    100                        5309               if ( $attribs{'short form'} ) {
1001         150                                953                  $attribs{'short form'} =~ s/-//;
1002                                                              }
1003         900                               5028               $para = <$fh>; # read next paragraph, probably short help desc
1004                                                           }
1005                                                           else {
1006         165                                497               MKDEBUG && _d('Option has no attributes');
1007                                                           }
1008                                                  
1009        1065                               8110            $para =~ s/\s+\Z//g;
1010        1065                               8149            $para =~ s/\s+/ /g;
1011        1065                               7962            $para =~ s/$POD_link_re/$1/go;
1012                                                  
1013        1065                               5288            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
1014        1065                               2824            MKDEBUG && _d('Short help:', $para);
1015                                                  
1016  ***   1065     50                        5842            die "No description after option spec $option" if $para =~ m/^=item/;
1017                                                  
1018        1065    100                        6501            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
1019          75                                256               $option = $base_option;
1020          75                                332               $attribs{'negatable'} = 1;
1021                                                           }
1022                                                  
1023        1065    100                        7715            push @specs, {
                    100                               
1024                                                              spec  => $self->{parse_attributes}->($self, $option, \%attribs), 
1025                                                              desc  => $para
1026                                                                 . ($attribs{default} ? " (default $attribs{default})" : ''),
1027                                                              group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
1028                                                           };
1029                                                        }
1030        1095                              10823         while ( $para = <$fh> ) {
1031  ***   2700     50                       11420            last unless $para;
1032        2700    100                       12343            if ( $para =~ m/^=head1/ ) {
1033          30                                122               $para = undef; # Can't 'last' out of a do {} block.
1034          30                                195               last;
1035                                                           }
1036        2670    100                       23353            last if $para =~ m/^=item /;
1037                                                        }
1038                                                     } while ( $para );
1039                                                  
1040  ***     30     50                         160      die "No valid specs in $self->{head1}" unless @specs;
1041                                                  
1042          30                                546      close $fh;
1043          30                                142      return @specs, @rules;
1044                                                  }
1045                                                  
1046                                                  sub _parse_specs {
1047          15                   15           268      my ( $self, @specs ) = @_;
1048          15                                 99      my %disables; # special rule that requires deferred checking
1049                                                  
1050          15                                103      foreach my $opt ( @specs ) {
1051         960    100                        4231         if ( ref $opt ) { # It's an option spec, not a rule.
1052                                                           MKDEBUG && _d('Parsing opt spec:',
1053         945                               2454               map { ($_, '=>', $opt->{$_}) } keys %$opt);
1054                                                  
1055         945                               8240            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
1056  ***    945     50                        4952            if ( !$long ) {
1057  ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
1058                                                           }
1059         945                               4072            $opt->{long} = $long;
1060                                                  
1061  ***    945     50                        5393            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
1062         945                               5055            $self->{opts}->{$long} = $opt;
1063                                                  
1064  ***    945     50                        4595            if ( length $long == 1 ) {
1065  ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
1066  ***      0                                  0               $self->{short_opts}->{$long} = $long;
1067                                                           }
1068                                                  
1069         945    100                        3813            if ( $short ) {
1070  ***    150     50                         866               die "Duplicate short option -$short"
1071                                                                 if exists $self->{short_opts}->{$short};
1072         150                                865               $self->{short_opts}->{$short} = $long;
1073         150                                669               $opt->{short} = $short;
1074                                                           }
1075                                                           else {
1076         795                               3426               $opt->{short} = undef;
1077                                                           }
1078                                                  
1079         945    100                        6062            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
1080  ***    945     50                        5690            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
1081  ***    945     50                        6459            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
1082                                                  
1083  ***    945            50                 4851            $opt->{group} ||= 'default';
1084         945                               6096            $self->{groups}->{ $opt->{group} }->{$long} = 1;
1085                                                  
1086         945                               3697            $opt->{value} = undef;
1087         945                               3732            $opt->{got}   = 0;
1088                                                  
1089         945                               6184            my ( $type ) = $opt->{spec} =~ m/=(.)/;
1090         945                               4131            $opt->{type} = $type;
1091         945                               3012            MKDEBUG && _d($long, 'type:', $type);
1092                                                  
1093                                                  
1094         945    100    100                 9494            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
1095                                                  
1096         945    100                        6773            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
1097  ***    135     50                         981               $self->{defaults}->{$long} = defined $def ? $def : 1;
1098         135                                394               MKDEBUG && _d($long, 'default:', $def);
1099                                                           }
1100                                                  
1101         945    100                        4526            if ( $long eq 'config' ) {
1102          15                                139               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
1103                                                           }
1104                                                  
1105         945    100                        6044            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
1106          30                                153               $disables{$long} = $dis;
1107          30                                 89               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
1108                                                           }
1109                                                  
1110         945                               5592            $self->{opts}->{$long} = $opt;
1111                                                        }
1112                                                        else { # It's an option rule, not a spec.
1113          15                                 50            MKDEBUG && _d('Parsing rule:', $opt); 
1114          15                                 50            push @{$self->{rules}}, $opt;
              15                                115   
1115          15                                142            my @participants = $self->_get_participants($opt);
1116          15                                 64            my $rule_ok = 0;
1117                                                  
1118  ***     15     50                         181            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
1119  ***      0                                  0               $rule_ok = 1;
1120  ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
1121  ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
1122                                                           }
1123  ***     15     50                         137            if ( $opt =~ m/at least one|one and only one/ ) {
1124  ***      0                                  0               $rule_ok = 1;
1125  ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
1126  ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
1127                                                           }
1128  ***     15     50                         119            if ( $opt =~ m/default to/ ) {
1129  ***      0                                  0               $rule_ok = 1;
1130  ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
1131  ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
1132                                                           }
1133  ***     15     50                         107            if ( $opt =~ m/restricted to option groups/ ) {
1134          15                                 65               $rule_ok = 1;
1135          15                                145               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
1136          15                                179               my @groups = split(',', $groups);
1137          15                                210               %{$self->{allowed_groups}->{$participants[0]}} = map {
              75                                297   
1138          15                                 89                  s/\s+//;
1139          75                                342                  $_ => 1;
1140                                                              } @groups;
1141                                                           }
1142                                                  
1143  ***     15     50                         144            die "Unrecognized option rule: $opt" unless $rule_ok;
1144                                                        }
1145                                                     }
1146                                                  
1147          15                                128      foreach my $long ( keys %disables ) {
1148          30                                186         my @participants = $self->_get_participants($disables{$long});
1149          30                                201         $self->{disables}->{$long} = \@participants;
1150          30                                130         MKDEBUG && _d('Option', $long, 'disables', @participants);
1151                                                     }
1152                                                  
1153          15                                167      return; 
1154                                                  }
1155                                                  
1156                                                  sub _get_participants {
1157          45                   45           266      my ( $self, $str ) = @_;
1158          45                                150      my @participants;
1159          45                                414      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
1160  ***     45     50                         319         die "Option --$long does not exist while processing rule $str"
1161                                                           unless exists $self->{opts}->{$long};
1162          45                                263         push @participants, $long;
1163                                                     }
1164          45                                132      MKDEBUG && _d('Participants for', $str, ':', @participants);
1165          45                                288      return @participants;
1166                                                  }
1167                                                  
1168                                                  sub opts {
1169  ***      0                    0             0      my ( $self ) = @_;
1170  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1171  ***      0                                  0      return %opts;
1172                                                  }
1173                                                  
1174                                                  sub short_opts {
1175  ***      0                    0             0      my ( $self ) = @_;
1176  ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
1177  ***      0                                  0      return %short_opts;
1178                                                  }
1179                                                  
1180                                                  sub set_defaults {
1181  ***      0                    0             0      my ( $self, %defaults ) = @_;
1182  ***      0                                  0      $self->{defaults} = {};
1183  ***      0                                  0      foreach my $long ( keys %defaults ) {
1184  ***      0      0                           0         die "Cannot set default for nonexistent option $long"
1185                                                           unless exists $self->{opts}->{$long};
1186  ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
1187  ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
1188                                                     }
1189  ***      0                                  0      return;
1190                                                  }
1191                                                  
1192                                                  sub get_defaults {
1193  ***      0                    0             0      my ( $self ) = @_;
1194  ***      0                                  0      return $self->{defaults};
1195                                                  }
1196                                                  
1197                                                  sub get_groups {
1198  ***      0                    0             0      my ( $self ) = @_;
1199  ***      0                                  0      return $self->{groups};
1200                                                  }
1201                                                  
1202                                                  sub _set_option {
1203          86                   86           445      my ( $self, $opt, $val ) = @_;
1204  ***     86      0                         208      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
1205                                                              : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
1206                                                              : die "Getopt::Long gave a nonexistent option: $opt";
1207                                                  
1208          86                                186      $opt = $self->{opts}->{$long};
1209  ***     86     50                         584      if ( $opt->{is_cumulative} ) {
1210  ***      0                                  0         $opt->{value}++;
1211                                                     }
1212                                                     else {
1213          86                                378         $opt->{value} = $val;
1214                                                     }
1215          86                                351      $opt->{got} = 1;
1216          86                                375      MKDEBUG && _d('Got option', $long, '=', $val);
1217                                                  }
1218                                                  
1219                                                  sub get_opts {
1220          15                   15            81      my ( $self ) = @_; 
1221                                                  
1222          15                                 64      foreach my $long ( keys %{$self->{opts}} ) {
              15                                428   
1223         945                               4850         $self->{opts}->{$long}->{got} = 0;
1224  ***    945     50                       10255         $self->{opts}->{$long}->{value}
                    100                               
1225                                                           = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
1226                                                           : $self->{opts}->{$long}->{is_cumulative} ? 0
1227                                                           : undef;
1228                                                     }
1229          15                                155      $self->{got_opts} = 0;
1230                                                  
1231          15                                 80      $self->{errors} = [];
1232                                                  
1233  ***     15     50     33                  254      if ( @ARGV && $ARGV[0] eq "--config" ) {
1234  ***      0                                  0         shift @ARGV;
1235  ***      0                                  0         $self->_set_option('config', shift @ARGV);
1236                                                     }
1237  ***     15     50                         124      if ( $self->has('config') ) {
1238          15                                 50         my @extra_args;
1239          15                                119         foreach my $filename ( split(',', $self->get('config')) ) {
1240          60                                244            eval {
1241          60                                364               push @extra_args, $self->_read_config_file($filename);
1242                                                           };
1243  ***     60     50                         374            if ( $EVAL_ERROR ) {
1244  ***     60     50                         327               if ( $self->got('config') ) {
1245  ***      0                                  0                  die $EVAL_ERROR;
1246                                                              }
1247                                                              elsif ( MKDEBUG ) {
1248                                                                 _d($EVAL_ERROR);
1249                                                              }
1250                                                           }
1251                                                        }
1252          15                                 90         unshift @ARGV, @extra_args;
1253                                                     }
1254                                                  
1255          15                                150      Getopt::Long::Configure('no_ignore_case', 'bundling');
1256                                                     GetOptions(
1257         930                   86          7552         map    { $_->{spec} => sub { $self->_set_option(@_); } }
              86                                471   
             945                               4450   
1258          15                                192         grep   { $_->{long} ne 'config' } # --config is handled specially above.
1259  ***     15     50                          65         values %{$self->{opts}}
1260                                                     ) or $self->save_error('Error parsing options');
1261                                                  
1262  ***     15     50     33                 1930      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
1263  ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
1264                                                           $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
1265                                                              or die "Cannot print: $OS_ERROR";
1266  ***      0                                  0         exit 0;
1267                                                     }
1268                                                  
1269  ***     15     50     33                  186      if ( @ARGV && $self->{strict} ) {
1270  ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
1271                                                     }
1272                                                  
1273          15                                 54      foreach my $mutex ( @{$self->{mutex}} ) {
              15                                114   
1274  ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
1275  ***      0      0                           0         if ( @set > 1 ) {
1276  ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
1277  ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
1278                                                                   . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
1279                                                                   . ' are mutually exclusive.';
1280  ***      0                                  0            $self->save_error($err);
1281                                                        }
1282                                                     }
1283                                                  
1284          15                                 53      foreach my $required ( @{$self->{atleast1}} ) {
              15                                 92   
1285  ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
1286  ***      0      0                           0         if ( @set == 0 ) {
1287  ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
1288  ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
1289                                                                   .' or --'.$self->{opts}->{$required->[-1]}->{long};
1290  ***      0                                  0            $self->save_error("Specify at least one of $err");
1291                                                        }
1292                                                     }
1293                                                  
1294          15                                 59      $self->_check_opts( keys %{$self->{opts}} );
              15                                327   
1295          15                                177      $self->{got_opts} = 1;
1296          15                                 61      return;
1297                                                  }
1298                                                  
1299                                                  sub _check_opts {
1300          15                   15           387      my ( $self, @long ) = @_;
1301          15                                117      my $long_last = scalar @long;
1302          15                                 93      while ( @long ) {
1303          15                                140         foreach my $i ( 0..$#long ) {
1304         945                               3470            my $long = $long[$i];
1305  ***    945     50                        4289            next unless $long;
1306         945                               4346            my $opt  = $self->{opts}->{$long};
1307         945    100                        6161            if ( $opt->{got} ) {
      ***            50                               
1308          86    100                         489               if ( exists $self->{disables}->{$long} ) {
1309           8                                 26                  my @disable_opts = @{$self->{disables}->{$long}};
               8                                 57   
1310           8                                 53                  map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
               8                                 53   
1311           8                                 26                  MKDEBUG && _d('Unset options', @disable_opts,
1312                                                                    'because', $long,'disables them');
1313                                                              }
1314                                                  
1315  ***     86     50                         506               if ( exists $self->{allowed_groups}->{$long} ) {
1316                                                  
1317  ***      0                                  0                  my @restricted_groups = grep {
1318  ***      0                                  0                     !exists $self->{allowed_groups}->{$long}->{$_}
1319  ***      0                                  0                  } keys %{$self->{groups}};
1320                                                  
1321  ***      0                                  0                  my @restricted_opts;
1322  ***      0                                  0                  foreach my $restricted_group ( @restricted_groups ) {
1323  ***      0                                  0                     RESTRICTED_OPT:
1324  ***      0                                  0                     foreach my $restricted_opt (
1325                                                                       keys %{$self->{groups}->{$restricted_group}} )
1326                                                                    {
1327  ***      0      0                           0                        next RESTRICTED_OPT if $restricted_opt eq $long;
1328  ***      0      0                           0                        push @restricted_opts, $restricted_opt
1329                                                                          if $self->{opts}->{$restricted_opt}->{got};
1330                                                                    }
1331                                                                 }
1332                                                  
1333  ***      0      0                           0                  if ( @restricted_opts ) {
1334  ***      0                                  0                     my $err;
1335  ***      0      0                           0                     if ( @restricted_opts == 1 ) {
1336  ***      0                                  0                        $err = "--$restricted_opts[0]";
1337                                                                    }
1338                                                                    else {
1339  ***      0                                  0                        $err = join(', ',
1340  ***      0                                  0                                  map { "--$self->{opts}->{$_}->{long}" }
1341  ***      0                                  0                                  grep { $_ } 
1342                                                                                 @restricted_opts[0..scalar(@restricted_opts) - 2]
1343                                                                              )
1344                                                                            . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
1345                                                                    }
1346  ***      0                                  0                     $self->save_error("--$long is not allowed with $err");
1347                                                                 }
1348                                                              }
1349                                                  
1350                                                           }
1351                                                           elsif ( $opt->{is_required} ) { 
1352  ***      0                                  0               $self->save_error("Required option --$long must be specified");
1353                                                           }
1354                                                  
1355         945                               4044            $self->_validate_type($opt);
1356  ***    945     50                        4061            if ( $opt->{parsed} ) {
1357         945                               4043               delete $long[$i];
1358                                                           }
1359                                                           else {
1360  ***      0                                  0               MKDEBUG && _d('Temporarily failed to parse', $long);
1361                                                           }
1362                                                        }
1363                                                  
1364  ***     15     50                          97         die "Failed to parse options, possibly due to circular dependencies"
1365                                                           if @long == $long_last;
1366          15                                 99         $long_last = @long;
1367                                                     }
1368                                                  
1369          15                                 86      return;
1370                                                  }
1371                                                  
1372                                                  sub _validate_type {
1373         945                  945          3920      my ( $self, $opt ) = @_;
1374  ***    945     50                        4185      return unless $opt;
1375                                                  
1376         945    100                        4887      if ( !$opt->{type} ) {
1377         375                               1412         $opt->{parsed} = 1;
1378         375                               1217         return;
1379                                                     }
1380                                                  
1381         570                               2239      my $val = $opt->{value};
1382                                                  
1383         570    100    100                17242      if ( $val && $opt->{type} eq 'm' ) {  # type time
                    100    100                        
      ***            50     66                        
                    100    100                        
                    100    100                        
      ***                   66                        
      ***                   66                        
1384          30                                 91         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
1385          30                                370         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
1386  ***     30     50                         165         if ( !$suffix ) {
1387  ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
1388  ***      0             0                    0            $suffix = $s || 's';
1389  ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
1390                                                              $opt->{long}, '(value:', $val, ')');
1391                                                        }
1392  ***     30     50                         177         if ( $suffix =~ m/[smhd]/ ) {
1393  ***     30      0                         143            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***            50                               
1394                                                                : $suffix eq 'm' ? $num * 60       # Minutes
1395                                                                : $suffix eq 'h' ? $num * 3600     # Hours
1396                                                                :                  $num * 86400;   # Days
1397  ***     30            50                  328            $opt->{value} = ($prefix || '') . $val;
1398          30                                103            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
1399                                                        }
1400                                                        else {
1401  ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
1402                                                        }
1403                                                     }
1404                                                     elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
1405           2                                  8         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
1406           2                                 10         my $prev = {};
1407           2                                 22         my $from_key = $self->{defaults_to}->{ $opt->{long} };
1408  ***      2     50                          13         if ( $from_key ) {
1409  ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
1410  ***      0      0                           0            if ( $self->{opts}->{$from_key}->{parsed} ) {
1411  ***      0                                  0               $prev = $self->{opts}->{$from_key}->{value};
1412                                                           }
1413                                                           else {
1414  ***      0                                  0               MKDEBUG && _d('Cannot parse', $opt->{long}, 'until',
1415                                                                 $from_key, 'parsed');
1416  ***      0                                  0               return;
1417                                                           }
1418                                                        }
1419           2                                 20         my $defaults = $self->{DSNParser}->parse_options($self);
1420           2                                 16         $opt->{value} = $self->{DSNParser}->parse($val, $prev, $defaults);
1421                                                     }
1422                                                     elsif ( $val && $opt->{type} eq 'z' ) {  # type size
1423  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
1424  ***      0                                  0         $self->_parse_size($opt, $val);
1425                                                     }
1426                                                     elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
1427  ***     45            50                  369         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
              60                                422   
1428                                                     }
1429                                                     elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
1430  ***     15            50                  278         $opt->{value} = [ split(/(?<!\\),\s*/, ($val || '')) ];
1431                                                     }
1432                                                     else {
1433         478                               1304         MKDEBUG && _d('Nothing to validate for option',
1434                                                           $opt->{long}, 'type', $opt->{type}, 'value', $val);
1435                                                     }
1436                                                  
1437         570                               2313      $opt->{parsed} = 1;
1438         570                               1904      return;
1439                                                  }
1440                                                  
1441                                                  sub get {
1442        1316                 1316          5551      my ( $self, $opt ) = @_;
1443        1316    100                        6218      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1444  ***   1316     50     33                12461      die "Option $opt does not exist"
1445                                                        unless $long && exists $self->{opts}->{$long};
1446        1316                              12087      return $self->{opts}->{$long}->{value};
1447                                                  }
1448                                                  
1449                                                  sub got {
1450          65                   65           354      my ( $self, $opt ) = @_;
1451  ***     65     50                         351      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1452  ***     65     50     33                  786      die "Option $opt does not exist"
1453                                                        unless $long && exists $self->{opts}->{$long};
1454          65                                561      return $self->{opts}->{$long}->{got};
1455                                                  }
1456                                                  
1457                                                  sub has {
1458         615                  615          2524      my ( $self, $opt ) = @_;
1459         615    100                        3029      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1460         615    100                        5084      return defined $long ? exists $self->{opts}->{$long} : 0;
1461                                                  }
1462                                                  
1463                                                  sub set {
1464          13                   13            70      my ( $self, $opt, $val ) = @_;
1465  ***     13     50                          77      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1466  ***     13     50     33                  150      die "Option $opt does not exist"
1467                                                        unless $long && exists $self->{opts}->{$long};
1468          13                                 66      $self->{opts}->{$long}->{value} = $val;
1469          13                                 46      return;
1470                                                  }
1471                                                  
1472                                                  sub save_error {
1473  ***      0                    0             0      my ( $self, $error ) = @_;
1474  ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
1475                                                  }
1476                                                  
1477                                                  sub errors {
1478  ***      0                    0             0      my ( $self ) = @_;
1479  ***      0                                  0      return $self->{errors};
1480                                                  }
1481                                                  
1482                                                  sub prompt {
1483  ***      0                    0             0      my ( $self ) = @_;
1484  ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
1485                                                  }
1486                                                  
1487                                                  sub descr {
1488  ***      0                    0             0      my ( $self ) = @_;
1489  ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
1490                                                                . "  For more details, please use the --help option, "
1491                                                                . "or try 'perldoc $PROGRAM_NAME' "
1492                                                                . "for complete documentation.";
1493  ***      0      0                           0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g)
1494                                                        unless $ENV{DONT_BREAK_LINES};
1495  ***      0                                  0      $descr =~ s/ +$//mg;
1496  ***      0                                  0      return $descr;
1497                                                  }
1498                                                  
1499                                                  sub usage_or_errors {
1500          15                   15            75      my ( $self ) = @_;
1501  ***     15     50                          96      if ( $self->{opts}->{help}->{got} ) {
      ***     15     50                         169   
1502  ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
1503  ***      0                                  0         exit 0;
1504                                                     }
1505                                                     elsif ( scalar @{$self->{errors}} ) {
1506  ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
1507  ***      0                                  0         exit 0;
1508                                                     }
1509          15                                 43      return;
1510                                                  }
1511                                                  
1512                                                  sub print_errors {
1513  ***      0                    0             0      my ( $self ) = @_;
1514  ***      0                                  0      my $usage = $self->prompt() . "\n";
1515  ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
1516  ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
1517                                                                . "\n";
1518                                                     }
1519  ***      0                                  0      return $usage . "\n" . $self->descr();
1520                                                  }
1521                                                  
1522                                                  sub print_usage {
1523  ***      0                    0             0      my ( $self ) = @_;
1524  ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
1525  ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
1526                                                  
1527  ***      0      0                           0      my $maxl = max(
1528  ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
1529                                                        @opts);
1530                                                  
1531  ***      0      0                           0      my $maxs = max(0,
1532  ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
1533  ***      0                                  0         values %{$self->{short_opts}});
1534                                                  
1535  ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
1536  ***      0                                  0      my $rcol = 80 - $lcol - 6;
1537  ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
1538                                                  
1539  ***      0                                  0      $maxs = max($lcol - 3, $maxs);
1540                                                  
1541  ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
1542                                                  
1543  ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
1544  ***      0                                  0      push @groups, 'default';
1545                                                  
1546  ***      0                                  0      foreach my $group ( reverse @groups ) {
1547  ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
1548  ***      0                                  0         foreach my $opt (
      ***      0                                  0   
1549  ***      0                                  0            sort { $a->{long} cmp $b->{long} }
1550                                                           grep { $_->{group} eq $group }
1551                                                           @opts )
1552                                                        {
1553  ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
1554  ***      0                                  0            my $short = $opt->{short};
1555  ***      0                                  0            my $desc  = $opt->{desc};
1556  ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
1557  ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
1558  ***      0             0                    0               $s    ||= 's';
1559  ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
1560  ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
1561                                                                     . "d=days; if no suffix, $s is used.";
1562                                                           }
1563  ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
1564  ***      0                                  0            $desc =~ s/ +$//mg;
1565  ***      0      0                           0            if ( $short ) {
1566  ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
1567                                                           }
1568                                                           else {
1569  ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
1570                                                           }
1571                                                        }
1572                                                     }
1573                                                  
1574  ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
1575  ***      0                                  0         $usage .= "\nRules:\n\n";
1576  ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
1577                                                     }
1578  ***      0      0                           0      if ( $self->{DSNParser} ) {
1579  ***      0                                  0         $usage .= "\n" . $self->{DSNParser}->usage();
1580                                                     }
1581  ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
1582  ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
1583  ***      0                                  0         my $val   = $opt->{value};
1584  ***      0             0                    0         my $type  = $opt->{type} || '';
1585  ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
1586  ***      0      0                           0         $val      = $bool              ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
1587                                                                  : !defined $val      ? '(No value)'
1588                                                                  : $type eq 'd'       ? $self->{DSNParser}->as_string($val)
1589                                                                  : $type =~ m/H|h/    ? join(',', sort keys %$val)
1590                                                                  : $type =~ m/A|a/    ? join(',', @$val)
1591                                                                  :                    $val;
1592  ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
1593                                                     }
1594  ***      0                                  0      return $usage;
1595                                                  }
1596                                                  
1597                                                  sub prompt_noecho {
1598  ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
1599  ***      0                                  0      my ( $prompt ) = @_;
1600  ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
1601  ***      0      0                           0      print $prompt
1602                                                        or die "Cannot print: $OS_ERROR";
1603  ***      0                                  0      my $response;
1604  ***      0                                  0      eval {
1605  ***      0                                  0         require Term::ReadKey;
1606  ***      0                                  0         Term::ReadKey::ReadMode('noecho');
1607  ***      0                                  0         chomp($response = <STDIN>);
1608  ***      0                                  0         Term::ReadKey::ReadMode('normal');
1609  ***      0      0                           0         print "\n"
1610                                                           or die "Cannot print: $OS_ERROR";
1611                                                     };
1612  ***      0      0                           0      if ( $EVAL_ERROR ) {
1613  ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
1614                                                     }
1615  ***      0                                  0      return $response;
1616                                                  }
1617                                                  
1618                                                  if ( MKDEBUG ) {
1619                                                     print '# ', $^X, ' ', $], "\n";
1620                                                     my $uname = `uname -a`;
1621                                                     if ( $uname ) {
1622                                                        $uname =~ s/\s+/ /g;
1623                                                        print "# $uname\n";
1624                                                     }
1625                                                     printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
1626                                                        $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
1627                                                        ($main::SVN_REV || ''), __LINE__);
1628                                                     print('# Arguments: ',
1629                                                        join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
1630                                                  }
1631                                                  
1632                                                  sub _read_config_file {
1633          60                   60           329      my ( $self, $filename ) = @_;
1634  ***     60     50                         169      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
1635  ***      0                                  0      my @args;
1636  ***      0                                  0      my $prefix = '--';
1637  ***      0                                  0      my $parse  = 1;
1638                                                  
1639                                                     LINE:
1640  ***      0                                  0      while ( my $line = <$fh> ) {
1641  ***      0                                  0         chomp $line;
1642  ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
1643  ***      0                                  0         $line =~ s/\s+#.*$//g;
1644  ***      0                                  0         $line =~ s/^\s+|\s+$//g;
1645  ***      0      0                           0         if ( $line eq '--' ) {
1646  ***      0                                  0            $prefix = '';
1647  ***      0                                  0            $parse  = 0;
1648  ***      0                                  0            next LINE;
1649                                                        }
1650  ***      0      0      0                    0         if ( $parse
      ***             0                               
1651                                                           && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
1652                                                        ) {
1653  ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
1654                                                        }
1655                                                        elsif ( $line =~ m/./ ) {
1656  ***      0                                  0            push @args, $line;
1657                                                        }
1658                                                        else {
1659  ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
1660                                                        }
1661                                                     }
1662  ***      0                                  0      close $fh;
1663  ***      0                                  0      return @args;
1664                                                  }
1665                                                  
1666                                                  sub read_para_after {
1667          15                   15            93      my ( $self, $file, $regex ) = @_;
1668  ***     15     50                         798      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
1669          15                                137      local $INPUT_RECORD_SEPARATOR = '';
1670          15                                 48      my $para;
1671          15                                413      while ( $para = <$fh> ) {
1672       10095    100                       88578         next unless $para =~ m/^=pod$/m;
1673          15                                 53         last;
1674                                                     }
1675          15                                107      while ( $para = <$fh> ) {
1676        1965    100                       16844         next unless $para =~ m/$regex/;
1677          15                                 52         last;
1678                                                     }
1679          15                                 66      $para = <$fh>;
1680          15                                 62      chomp($para);
1681  ***     15     50                         218      close $fh or die "Can't close $file: $OS_ERROR";
1682          15                                 59      return $para;
1683                                                  }
1684                                                  
1685                                                  sub clone {
1686          15                   15            65      my ( $self ) = @_;
1687                                                  
1688          45                                180      my %clone = map {
1689          15                                 64         my $hashref  = $self->{$_};
1690          45                                142         my $val_copy = {};
1691          45                                557         foreach my $key ( keys %$hashref ) {
1692        1245                               4330            my $ref = ref $hashref->{$key};
1693         945                              11521            $val_copy->{$key} = !$ref           ? $hashref->{$key}
1694  ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
1695  ***   1245      0                        5852                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***            50                               
                    100                               
1696                                                                             : $hashref->{$key};
1697                                                        }
1698          45                                328         $_ => $val_copy;
1699                                                     } qw(opts short_opts defaults);
1700                                                  
1701          15                                 75      foreach my $scalar ( qw(got_opts) ) {
1702          15                                 87         $clone{$scalar} = $self->{$scalar};
1703                                                     }
1704                                                  
1705          15                                129      return bless \%clone;     
1706                                                  }
1707                                                  
1708                                                  sub _parse_size {
1709  ***      0                    0             0      my ( $self, $opt, $val ) = @_;
1710                                                  
1711  ***      0      0      0                    0      if ( lc($val || '') eq 'null' ) {
1712  ***      0                                  0         MKDEBUG && _d('NULL size for', $opt->{long});
1713  ***      0                                  0         $opt->{value} = 'null';
1714  ***      0                                  0         return;
1715                                                     }
1716                                                  
1717  ***      0                                  0      my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
1718  ***      0                                  0      my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
1719  ***      0      0                           0      if ( defined $num ) {
1720  ***      0      0                           0         if ( $factor ) {
1721  ***      0                                  0            $num *= $factor_for{$factor};
1722  ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{y},
1723                                                              'to num', $num, '* factor', $factor);
1724                                                        }
1725  ***      0             0                    0         $opt->{value} = ($pre || '') . $num;
1726                                                     }
1727                                                     else {
1728  ***      0                                  0         $self->save_error("Invalid size for --$opt->{long}");
1729                                                     }
1730  ***      0                                  0      return;
1731                                                  }
1732                                                  
1733                                                  sub _parse_attribs {
1734         945                  945          5082      my ( $self, $option, $attribs ) = @_;
1735         945                               4096      my $types = $self->{types};
1736         945    100                       21468      return $option
                    100                               
      ***            50                               
                    100                               
1737                                                        . ($attribs->{'short form'} ? '|' . $attribs->{'short form'}   : '' )
1738                                                        . ($attribs->{'negatable'}  ? '!'                              : '' )
1739                                                        . ($attribs->{'cumulative'} ? '+'                              : '' )
1740                                                        . ($attribs->{'type'}       ? '=' . $types->{$attribs->{type}} : '' );
1741                                                  }
1742                                                  
1743                                                  sub _d {
1744  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1745  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1746  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1747                                                          @_;
1748  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1749                                                  }
1750                                                  
1751                                                  1;
1752                                                  
1753                                                  # ###########################################################################
1754                                                  # End OptionParser package
1755                                                  # ###########################################################################
1756                                                  
1757                                                  # ###########################################################################
1758                                                  # DSNParser package 6057
1759                                                  # This package is a copy without comments from the original.  The original
1760                                                  # with comments and its test file can be found in the SVN repository at,
1761                                                  #   trunk/common/DSNParser.pm
1762                                                  #   trunk/common/t/DSNParser.t
1763                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1764                                                  # ###########################################################################
1765                                                  package DSNParser;
1766                                                  
1767          27                   27           288   use strict;
              27                               3491   
              27                               2421   
1768          27                   27           715   use warnings FATAL => 'all';
              27                                306   
              27                                434   
1769          27                   27           159   use English qw(-no_match_vars);
              27                                 60   
              27                                170   
1770          27                   27           178   use Data::Dumper;
              27                                105   
              27                                147   
1771                                                  $Data::Dumper::Indent    = 0;
1772                                                  $Data::Dumper::Quotekeys = 0;
1773                                                  
1774                                                  eval {
1775                                                     require DBI;
1776                                                  };
1777                                                  my $have_dbi = $EVAL_ERROR ? 0 : 1;
1778                                                  
1779  ***     27            50     27           168   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 60   
              27                                405   
1780                                                  
1781                                                  sub new {
1782          41                   41           369      my ( $class, %args ) = @_;
1783          41                                243      foreach my $arg ( qw(opts) ) {
1784  ***     41     50                         321         die "I need a $arg argument" unless $args{$arg};
1785                                                     }
1786          41                                201      my $self = {
1787                                                        opts => {}  # h, P, u, etc.  Should come from DSN OPTIONS section in POD.
1788                                                     };
1789          41                                136      foreach my $opt ( @{$args{opts}} ) {
              41                                226   
1790  ***    354     50     33                 3315         if ( !$opt->{key} || !$opt->{desc} ) {
1791  ***      0                                  0            die "Invalid DSN option: ", Dumper($opt);
1792                                                        }
1793                                                        MKDEBUG && _d('DSN option:',
1794                                                           join(', ',
1795         354                                799               map { "$_=" . (defined $opt->{$_} ? ($opt->{$_} || '') : 'undef') }
1796                                                                 keys %$opt
1797                                                           )
1798                                                        );
1799  ***    354            50                 5020         $self->{opts}->{$opt->{key}} = {
1800                                                           dsn  => $opt->{dsn},
1801                                                           desc => $opt->{desc},
1802                                                           copy => $opt->{copy} || 0,
1803                                                        };
1804                                                     }
1805          41                                952      return bless $self, $class;
1806                                                  }
1807                                                  
1808                                                  sub prop {
1809         237                  237          1210      my ( $self, $prop, $value ) = @_;
1810         237    100                        1185      if ( @_ > 2 ) {
1811          15                                 44         MKDEBUG && _d('Setting', $prop, 'property');
1812          15                                 75         $self->{$prop} = $value;
1813                                                     }
1814         237                               1715      return $self->{$prop};
1815                                                  }
1816                                                  
1817                                                  sub parse {
1818          78                   78          2279      my ( $self, $dsn, $prev, $defaults ) = @_;
1819          78    100                         410      if ( !$dsn ) {
1820           1                                  3         MKDEBUG && _d('No DSN to parse');
1821           1                                  4         return;
1822                                                     }
1823          77                                198      MKDEBUG && _d('Parsing', $dsn);
1824          77           100                  396      $prev     ||= {};
1825          77           100                  365      $defaults ||= {};
1826          77                                215      my %given_props;
1827          77                                219      my %final_props;
1828          77                                310      my $opts = $self->{opts};
1829                                                  
1830          77                                560      foreach my $dsn_part ( split(/,/, $dsn) ) {
1831         197    100                        1787         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1832         189                                963            $given_props{$prop_key} = $prop_val;
1833                                                        }
1834                                                        else {
1835           8                                 20            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1836           8                                 44            $given_props{h} = $dsn_part;
1837                                                        }
1838                                                     }
1839                                                  
1840          77                                490      foreach my $key ( keys %$opts ) {
1841         654                               1505         MKDEBUG && _d('Finding value for', $key);
1842         654                               2408         $final_props{$key} = $given_props{$key};
1843         654    100    100                 6119         if (   !defined $final_props{$key}
      ***                   66                        
1844                                                             && defined $prev->{$key} && $opts->{$key}->{copy} )
1845                                                        {
1846          18                                 85            $final_props{$key} = $prev->{$key};
1847          18                                 52            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1848                                                        }
1849         654    100                        2984         if ( !defined $final_props{$key} ) {
1850         439                               1568            $final_props{$key} = $defaults->{$key};
1851         439                               1380            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1852                                                        }
1853                                                     }
1854                                                  
1855          77                                443      foreach my $key ( keys %given_props ) {
1856  ***    197     50                        1007         die "Unknown DSN option '$key' in '$dsn'.  For more details, "
1857                                                              . "please use the --help option, or try 'perldoc $PROGRAM_NAME' "
1858                                                              . "for complete documentation."
1859                                                           unless exists $opts->{$key};
1860                                                     }
1861  ***     77     50                         418      if ( (my $required = $self->prop('required')) ) {
1862  ***      0                                  0         foreach my $key ( keys %$required ) {
1863  ***      0      0                           0            die "Missing required DSN option '$key' in '$dsn'.  For more details, "
1864                                                                 . "please use the --help option, or try 'perldoc $PROGRAM_NAME' "
1865                                                                 . "for complete documentation."
1866                                                              unless $final_props{$key};
1867                                                        }
1868                                                     }
1869                                                  
1870          77                                547      return \%final_props;
1871                                                  }
1872                                                  
1873                                                  sub parse_options {
1874          17                   17            80      my ( $self, $o ) = @_;
1875  ***     17     50                         119      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1876          16                                102      my $dsn_string
1877                                                        = join(',',
1878         136    100                         560             map  { "$_=".$o->get($_); }
1879          17                                179             grep { $o->has($_) && $o->get($_) }
1880          17                                 68             keys %{$self->{opts}}
1881                                                          );
1882          17                                 85      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1883          17                                114      return $self->parse($dsn_string);
1884                                                  }
1885                                                  
1886                                                  sub as_string {
1887  ***      0                    0             0      my ( $self, $dsn, $props ) = @_;
1888  ***      0      0                           0      return $dsn unless ref $dsn;
1889  ***      0      0                           0      my %allowed = $props ? map { $_=>1 } @$props : ();
      ***      0                                  0   
1890  ***      0      0                           0      return join(',',
1891  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_})  }
1892  ***      0      0                           0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1893  ***      0                                  0         grep { !$props || $allowed{$_}                   }
1894                                                        sort keys %$dsn );
1895                                                  }
1896                                                  
1897                                                  sub usage {
1898  ***      0                    0             0      my ( $self ) = @_;
1899  ***      0                                  0      my $usage
1900                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1901                                                        . "  KEY  COPY  MEANING\n"
1902                                                        . "  ===  ====  =============================================\n";
1903  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1904  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1905  ***      0      0      0                    0         $usage .= "  $key    "
1906                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1907                                                               .  ($opts{$key}->{desc} || '[No description]')
1908                                                               . "\n";
1909                                                     }
1910  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1911  ***      0                                  0      return $usage;
1912                                                  }
1913                                                  
1914                                                  sub get_cxn_params {
1915          61                   61           621      my ( $self, $info ) = @_;
1916          61                                180      my $dsn;
1917          61                                186      my %opts = %{$self->{opts}};
              61                                623   
1918  ***     61            50                  353      my $driver = $self->prop('dbidriver') || '';
1919  ***     61     50                         315      if ( $driver eq 'Pg' ) {
1920  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1921  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1922  ***      0             0                    0                        grep { defined $info->{$_} }
1923                                                                       qw(h P));
1924                                                     }
1925                                                     else {
1926         137                               1016         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1927         305                               1227            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1928  ***     61            50                  796                        grep { defined $info->{$_} }
1929                                                                       qw(F h P S A))
1930                                                           . ';mysql_read_default_group=client';
1931                                                     }
1932          61                                201      MKDEBUG && _d($dsn);
1933          61                                586      return ($dsn, $info->{u}, $info->{p});
1934                                                  }
1935                                                  
1936                                                  sub fill_in_dsn {
1937          17                   17            88      my ( $self, $dbh, $dsn ) = @_;
1938          17                                 48      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1939          17                                 46      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1940          17                               3803      $user =~ s/@.*//;
1941  ***     17            66                  124      $dsn->{h} ||= $vars->{hostname}->{Value};
1942  ***     17            66                  131      $dsn->{S} ||= $vars->{'socket'}->{Value};
1943  ***     17            66                  113      $dsn->{P} ||= $vars->{port}->{Value};
1944  ***     17            66                   99      $dsn->{u} ||= $user;
1945  ***     17            33                 2739      $dsn->{D} ||= $db;
1946                                                  }
1947                                                  
1948                                                  sub get_dbh {
1949          61                   61           384      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1950  ***     61            50                  312      $opts ||= {};
1951  ***     61     50                         631      my $defaults = {
1952                                                        AutoCommit         => 0,
1953                                                        RaiseError         => 1,
1954                                                        PrintError         => 0,
1955                                                        ShowErrorStatement => 1,
1956                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1957                                                     };
1958          61                                335      @{$defaults}{ keys %$opts } = values %$opts;
              61                                268   
1959                                                  
1960  ***     61     50                         345      if ( $opts->{mysql_use_result} ) {
1961  ***      0                                  0         $defaults->{mysql_use_result} = 1;
1962                                                     }
1963                                                  
1964  ***     61     50                         286      if ( !$have_dbi ) {
1965  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1966                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1967                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1968                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1969                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1970                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1971                                                  
1972                                                     }
1973                                                  
1974          61                                167      my $dbh;
1975          61                                198      my $tries = 2;
1976  ***     61            66                  687      while ( !$dbh && $tries-- ) {
1977                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1978          61                                153            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1979                                                  
1980          61                                191         eval {
1981          61                                506            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1982                                                  
1983  ***     61     50                         621            if ( $cxn_string =~ m/mysql/i ) {
1984          61                                187               my $sql;
1985                                                  
1986          61                                241               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1987                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1988          61                                153               MKDEBUG && _d($dbh, ':', $sql);
1989          61                               7376               $dbh->do($sql);
1990                                                  
1991  ***     61     50                         520               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1992  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1993  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1994  ***      0                                  0                  $dbh->do($sql);
1995  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1996  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1997  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1998                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1999                                                                 }
2000                                                                 else {
2001  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
2002                                                                 }
2003                                                              }
2004                                                  
2005          61    100                         388               if ( $self->prop('set-vars') ) {
2006          23                                116                  $sql = "SET " . $self->prop('set-vars');
2007          23                                 68                  MKDEBUG && _d($dbh, ':', $sql);
2008          23                               2006                  $dbh->do($sql);
2009                                                              }
2010                                                           }
2011                                                        };
2012  ***     61     50     33                  680         if ( !$dbh && $EVAL_ERROR ) {
2013  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
2014  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
2015  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
2016  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
2017                                                           }
2018                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
2019  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
2020                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
2021                                                                 . "the directories that Perl searches for DBD::mysql.  If "
2022                                                                 . "DBD::mysql is not installed, try:\n"
2023                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
2024                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
2025                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
2026                                                           }
2027  ***      0      0                           0            if ( !$tries ) {
2028  ***      0                                  0               die $EVAL_ERROR;
2029                                                           }
2030                                                        }
2031                                                     }
2032                                                  
2033          61                                160      MKDEBUG && _d('DBH info: ',
2034                                                        $dbh,
2035                                                        Dumper($dbh->selectrow_hashref(
2036                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
2037                                                        'Connection info:',      $dbh->{mysql_hostinfo},
2038                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
2039                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
2040                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
2041                                                        '$DBI::VERSION:',        $DBI::VERSION,
2042                                                     );
2043                                                  
2044          61                                401      return $dbh;
2045                                                  }
2046                                                  
2047                                                  sub get_hostname {
2048  ***      0                    0             0      my ( $self, $dbh ) = @_;
2049  ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
2050  ***      0                                  0         return $host;
2051                                                     }
2052  ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
2053                                                        'SELECT /*!50038 @@hostname, */ 1');
2054  ***      0                                  0      return $hostname;
2055                                                  }
2056                                                  
2057                                                  sub disconnect {
2058  ***      0                    0             0      my ( $self, $dbh ) = @_;
2059  ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
2060  ***      0                                  0      $dbh->disconnect;
2061                                                  }
2062                                                  
2063                                                  sub print_active_handles {
2064  ***      0                    0             0      my ( $self, $thing, $level ) = @_;
2065  ***      0             0                    0      $level ||= 0;
2066  ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
2067                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
2068                                                        or die "Cannot print: $OS_ERROR";
2069  ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
2070  ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
2071                                                     }
2072                                                  }
2073                                                  
2074                                                  sub copy {
2075           2                    2            11      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
2076  ***      2     50                          10      die 'I need a dsn_1 argument' unless $dsn_1;
2077  ***      2     50                          10      die 'I need a dsn_2 argument' unless $dsn_2;
2078          16                                 41      my %new_dsn = map {
2079           2                                 17         my $key = $_;
2080          16                                 37         my $val;
2081  ***     16     50                          58         if ( $args{overwrite} ) {
2082  ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
2083                                                        }
2084                                                        else {
2085          16    100                          74            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
2086                                                        }
2087          16                                 73         $key => $val;
2088           2                                  7      } keys %{$self->{opts}};
2089           2                                 16      return \%new_dsn;
2090                                                  }
2091                                                  
2092                                                  sub _d {
2093  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2094  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2095  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2096                                                          @_;
2097  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2098                                                  }
2099                                                  
2100                                                  1;
2101                                                  
2102                                                  # ###########################################################################
2103                                                  # End DSNParser package
2104                                                  # ###########################################################################
2105                                                  
2106                                                  # ###########################################################################
2107                                                  # VersionParser package 5266
2108                                                  # This package is a copy without comments from the original.  The original
2109                                                  # with comments and its test file can be found in the SVN repository at,
2110                                                  #   trunk/common/VersionParser.pm
2111                                                  #   trunk/common/t/VersionParser.t
2112                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
2113                                                  # ###########################################################################
2114                                                  package VersionParser;
2115                                                  
2116          27                   27           221   use strict;
              27                                 67   
              27                                154   
2117          27                   27           164   use warnings FATAL => 'all';
              27                                 67   
              27                                154   
2118                                                  
2119          27                   27           163   use English qw(-no_match_vars);
              27                                 67   
              27                                145   
2120                                                  
2121  ***     27            50     27           177   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 71   
              27                                379   
2122                                                  
2123                                                  sub new {
2124          18                   18           115      my ( $class ) = @_;
2125          18                                143      bless {}, $class;
2126                                                  }
2127                                                  
2128                                                  sub parse {
2129          57                   57          2770      my ( $self, $str ) = @_;
2130          57                                604      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
2131          57                                150      MKDEBUG && _d($str, 'parses to', $result);
2132          57                                372      return $result;
2133                                                  }
2134                                                  
2135                                                  sub version_ge {
2136          40                   40          1444      my ( $self, $dbh, $target ) = @_;
2137          40    100                         234      if ( !$self->{$dbh} ) {
2138          17                                 49         $self->{$dbh} = $self->parse(
2139                                                           $dbh->selectrow_array('SELECT VERSION()'));
2140                                                     }
2141  ***     40     50                         447      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
2142          40                                 92      MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
2143          40                                254      return $result;
2144                                                  }
2145                                                  
2146                                                  sub _d {
2147  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2148  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2149  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2150                                                          @_;
2151  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2152                                                  }
2153                                                  
2154                                                  1;
2155                                                  
2156                                                  # ###########################################################################
2157                                                  # End VersionParser package
2158                                                  # ###########################################################################
2159                                                  
2160                                                  # ###########################################################################
2161                                                  # MySQLDump package 5998
2162                                                  # This package is a copy without comments from the original.  The original
2163                                                  # with comments and its test file can be found in the SVN repository at,
2164                                                  #   trunk/common/MySQLDump.pm
2165                                                  #   trunk/common/t/MySQLDump.t
2166                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
2167                                                  # ###########################################################################
2168                                                  package MySQLDump;
2169                                                  
2170          27                   27           184   use strict;
              27                                 68   
              27                                145   
2171          27                   27           168   use warnings FATAL => 'all';
              27                                 72   
              27                                137   
2172                                                  
2173          27                   27           161   use English qw(-no_match_vars);
              27                                 69   
              27                                138   
2174                                                  
2175  ***     27            50     27           184   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 66   
              27                                358   
2176                                                  
2177                                                  ( our $before = <<'EOF') =~ s/^   //gm;
2178                                                     /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
2179                                                     /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
2180                                                     /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
2181                                                     /*!40101 SET NAMES utf8 */;
2182                                                     /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
2183                                                     /*!40103 SET TIME_ZONE='+00:00' */;
2184                                                     /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
2185                                                     /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
2186                                                     /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
2187                                                     /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
2188                                                  EOF
2189                                                  
2190                                                  ( our $after = <<'EOF') =~ s/^   //gm;
2191                                                     /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
2192                                                     /*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
2193                                                     /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
2194                                                     /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
2195                                                     /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
2196                                                     /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
2197                                                     /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
2198                                                     /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
2199                                                  EOF
2200                                                  
2201                                                  sub new {
2202          15                   15            76      my ( $class, %args ) = @_;
2203          15                                 74      my $self = {
2204                                                        cache => 0,  # Afaik no script uses this cache any longer because
2205                                                     };
2206          15                                109      return bless $self, $class;
2207                                                  }
2208                                                  
2209                                                  sub dump {
2210  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl, $what ) = @_;
2211                                                  
2212  ***      0      0                           0      if ( $what eq 'table' ) {
      ***             0                               
      ***             0                               
2213  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
2214  ***      0      0                           0         return unless $ddl;
2215  ***      0      0                           0         if ( $ddl->[0] eq 'table' ) {
2216  ***      0                                  0            return $before
2217                                                              . 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
2218                                                              . $ddl->[1] . ";\n";
2219                                                        }
2220                                                        else {
2221  ***      0                                  0            return 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
2222                                                              . '/*!50001 DROP VIEW IF EXISTS '
2223                                                              . $quoter->quote($tbl) . "*/;\n/*!50001 "
2224                                                              . $self->get_tmp_table($dbh, $quoter, $db, $tbl) . "*/;\n";
2225                                                        }
2226                                                     }
2227                                                     elsif ( $what eq 'triggers' ) {
2228  ***      0                                  0         my $trgs = $self->get_triggers($dbh, $quoter, $db, $tbl);
2229  ***      0      0      0                    0         if ( $trgs && @$trgs ) {
2230  ***      0                                  0            my $result = $before . "\nDELIMITER ;;\n";
2231  ***      0                                  0            foreach my $trg ( @$trgs ) {
2232  ***      0      0                           0               if ( $trg->{sql_mode} ) {
2233  ***      0                                  0                  $result .= qq{/*!50003 SET SESSION SQL_MODE='$trg->{sql_mode}' */;;\n};
2234                                                              }
2235  ***      0                                  0               $result .= "/*!50003 CREATE */ ";
2236  ***      0      0                           0               if ( $trg->{definer} ) {
2237  ***      0                                  0                  my ( $user, $host )
2238  ***      0                                  0                     = map { s/'/''/g; "'$_'"; }
      ***      0                                  0   
2239                                                                      split('@', $trg->{definer}, 2);
2240  ***      0                                  0                  $result .= "/*!50017 DEFINER=$user\@$host */ ";
2241                                                              }
2242  ***      0                                  0               $result .= sprintf("/*!50003 TRIGGER %s %s %s ON %s\nFOR EACH ROW %s */;;\n\n",
2243                                                                 $quoter->quote($trg->{trigger}),
2244  ***      0                                  0                  @{$trg}{qw(timing event)},
2245                                                                 $quoter->quote($trg->{table}),
2246                                                                 $trg->{statement});
2247                                                           }
2248  ***      0                                  0            $result .= "DELIMITER ;\n\n/*!50003 SET SESSION SQL_MODE=\@OLD_SQL_MODE */;\n\n";
2249  ***      0                                  0            return $result;
2250                                                        }
2251                                                        else {
2252  ***      0                                  0            return undef;
2253                                                        }
2254                                                     }
2255                                                     elsif ( $what eq 'view' ) {
2256  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
2257  ***      0                                  0         return '/*!50001 DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
2258                                                           . '/*!50001 DROP VIEW IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
2259                                                           . '/*!50001 ' . $ddl->[1] . "*/;\n";
2260                                                     }
2261                                                     else {
2262  ***      0                                  0         die "You didn't say what to dump.";
2263                                                     }
2264                                                  }
2265                                                  
2266                                                  sub _use_db {
2267          30                   30           169      my ( $self, $dbh, $quoter, $new ) = @_;
2268          30    100                         145      if ( !$new ) {
2269          15                                 42         MKDEBUG && _d('No new DB to use');
2270          15                                 51         return;
2271                                                     }
2272          15                                 53      my $sql = 'SELECT DATABASE()';
2273          15                                 40      MKDEBUG && _d($sql);
2274          15                                 43      my $curr = $dbh->selectrow_array($sql);
2275  ***     15     50     33                 2315      if ( $curr && $new && $curr eq $new ) {
      ***                   33                        
2276  ***      0                                  0         MKDEBUG && _d('Current and new DB are the same');
2277  ***      0                                  0         return $curr;
2278                                                     }
2279          15                                145      $sql = 'USE ' . $quoter->quote($new);
2280          15                                 42      MKDEBUG && _d($sql);
2281          15                               1619      $dbh->do($sql);
2282          15                                102      return $curr;
2283                                                  }
2284                                                  
2285                                                  sub get_create_table {
2286          15                   15            89      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2287  ***     15     50     33                  113      if ( !$self->{cache} || !$self->{tables}->{$db}->{$tbl} ) {
2288          15                                 53         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
2289                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
2290                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
2291                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
2292          15                                 34         MKDEBUG && _d($sql);
2293          15                                 50         eval { $dbh->do($sql); };
              15                               3188   
2294          15                                 57         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2295          15                                123         my $curr_db = $self->_use_db($dbh, $quoter, $db);
2296          15                                 85         $sql = "SHOW CREATE TABLE " . $quoter->quote($db, $tbl);
2297          15                                 39         MKDEBUG && _d($sql);
2298          15                                 46         my $href;
2299          15                                 69         eval { $href = $dbh->selectrow_hashref($sql); };
              15                                 33   
2300  ***     15     50                         130         if ( $EVAL_ERROR ) {
2301  ***      0                                  0            warn "Failed to $sql.  The table may be damaged.\nError: $EVAL_ERROR";
2302  ***      0                                  0            return;
2303                                                        }
2304          15                                 78         $self->_use_db($dbh, $quoter, $curr_db);
2305          15                                 50         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
2306                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
2307          15                                 39         MKDEBUG && _d($sql);
2308          15                               1468         $dbh->do($sql);
2309          15                                114         my ($key) = grep { m/create table/i } keys %$href;
              30                                234   
2310  ***     15     50                          75         if ( $key ) {
2311          15                                 39            MKDEBUG && _d('This table is a base table');
2312          15                                183            $self->{tables}->{$db}->{$tbl} = [ 'table', $href->{$key} ];
2313                                                        }
2314                                                        else {
2315  ***      0                                  0            MKDEBUG && _d('This table is a view');
2316  ***      0                                  0            ($key) = grep { m/create view/i } keys %$href;
      ***      0                                  0   
2317  ***      0                                  0            $self->{tables}->{$db}->{$tbl} = [ 'view', $href->{$key} ];
2318                                                        }
2319                                                     }
2320          15                                100      return $self->{tables}->{$db}->{$tbl};
2321                                                  }
2322                                                  
2323                                                  sub get_columns {
2324  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2325  ***      0                                  0      MKDEBUG && _d('Get columns for', $db, $tbl);
2326  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{columns}->{$db}->{$tbl} ) {
2327  ***      0                                  0         my $curr_db = $self->_use_db($dbh, $quoter, $db);
2328  ***      0                                  0         my $sql = "SHOW COLUMNS FROM " . $quoter->quote($db, $tbl);
2329  ***      0                                  0         MKDEBUG && _d($sql);
2330  ***      0                                  0         my $cols = $dbh->selectall_arrayref($sql, { Slice => {} });
2331  ***      0                                  0         $self->_use_db($dbh, $quoter, $curr_db);
2332  ***      0                                  0         $self->{columns}->{$db}->{$tbl} = [
2333                                                           map {
2334  ***      0                                  0               my %row;
2335  ***      0                                  0               @row{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
2336  ***      0                                  0               \%row;
2337                                                           } @$cols
2338                                                        ];
2339                                                     }
2340  ***      0                                  0      return $self->{columns}->{$db}->{$tbl};
2341                                                  }
2342                                                  
2343                                                  sub get_tmp_table {
2344  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2345  ***      0                                  0      my $result = 'CREATE TABLE ' . $quoter->quote($tbl) . " (\n";
2346  ***      0                                  0      $result .= join(",\n",
2347  ***      0                                  0         map { '  ' . $quoter->quote($_->{field}) . ' ' . $_->{type} }
2348  ***      0                                  0         @{$self->get_columns($dbh, $quoter, $db, $tbl)});
2349  ***      0                                  0      $result .= "\n)";
2350  ***      0                                  0      MKDEBUG && _d($result);
2351  ***      0                                  0      return $result;
2352                                                  }
2353                                                  
2354                                                  sub get_triggers {
2355  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2356  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{triggers}->{$db} ) {
2357  ***      0                                  0         $self->{triggers}->{$db} = {};
2358  ***      0                                  0         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
2359                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
2360                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
2361                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
2362  ***      0                                  0         MKDEBUG && _d($sql);
2363  ***      0                                  0         eval { $dbh->do($sql); };
      ***      0                                  0   
2364  ***      0                                  0         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2365  ***      0                                  0         $sql = "SHOW TRIGGERS FROM " . $quoter->quote($db);
2366  ***      0                                  0         MKDEBUG && _d($sql);
2367  ***      0                                  0         my $sth = $dbh->prepare($sql);
2368  ***      0                                  0         $sth->execute();
2369  ***      0      0                           0         if ( $sth->rows ) {
2370  ***      0                                  0            my $trgs = $sth->fetchall_arrayref({});
2371  ***      0                                  0            foreach my $trg (@$trgs) {
2372  ***      0                                  0               my %trg;
2373  ***      0                                  0               @trg{ map { lc $_ } keys %$trg } = values %$trg;
      ***      0                                  0   
2374  ***      0                                  0               push @{ $self->{triggers}->{$db}->{ $trg{table} } }, \%trg;
      ***      0                                  0   
2375                                                           }
2376                                                        }
2377  ***      0                                  0         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
2378                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
2379  ***      0                                  0         MKDEBUG && _d($sql);
2380  ***      0                                  0         $dbh->do($sql);
2381                                                     }
2382  ***      0      0                           0      if ( $tbl ) {
2383  ***      0                                  0         return $self->{triggers}->{$db}->{$tbl};
2384                                                     }
2385  ***      0                                  0      return values %{$self->{triggers}->{$db}};
      ***      0                                  0   
2386                                                  }
2387                                                  
2388                                                  sub get_databases {
2389  ***      0                    0             0      my ( $self, $dbh, $quoter, $like ) = @_;
2390  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{databases} || $like ) {
      ***                    0                        
2391  ***      0                                  0         my $sql = 'SHOW DATABASES';
2392  ***      0                                  0         my @params;
2393  ***      0      0                           0         if ( $like ) {
2394  ***      0                                  0            $sql .= ' LIKE ?';
2395  ***      0                                  0            push @params, $like;
2396                                                        }
2397  ***      0                                  0         my $sth = $dbh->prepare($sql);
2398  ***      0                                  0         MKDEBUG && _d($sql, @params);
2399  ***      0                                  0         $sth->execute( @params );
2400  ***      0                                  0         my @dbs = map { $_->[0] } @{$sth->fetchall_arrayref()};
      ***      0                                  0   
      ***      0                                  0   
2401  ***      0      0                           0         $self->{databases} = \@dbs unless $like;
2402  ***      0                                  0         return @dbs;
2403                                                     }
2404  ***      0                                  0      return @{$self->{databases}};
      ***      0                                  0   
2405                                                  }
2406                                                  
2407                                                  sub get_table_status {
2408  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
2409  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_status}->{$db} || $like ) {
      ***                    0                        
2410  ***      0                                  0         my $sql = "SHOW TABLE STATUS FROM " . $quoter->quote($db);
2411  ***      0                                  0         my @params;
2412  ***      0      0                           0         if ( $like ) {
2413  ***      0                                  0            $sql .= ' LIKE ?';
2414  ***      0                                  0            push @params, $like;
2415                                                        }
2416  ***      0                                  0         MKDEBUG && _d($sql, @params);
2417  ***      0                                  0         my $sth = $dbh->prepare($sql);
2418  ***      0                                  0         $sth->execute(@params);
2419  ***      0                                  0         my @tables = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
2420  ***      0                                  0         @tables = map {
2421  ***      0                                  0            my %tbl; # Make a copy with lowercased keys
2422  ***      0                                  0            @tbl{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
2423  ***      0             0                    0            $tbl{engine} ||= $tbl{type} || $tbl{comment};
      ***                    0                        
2424  ***      0                                  0            delete $tbl{type};
2425  ***      0                                  0            \%tbl;
2426                                                        } @tables;
2427  ***      0      0                           0         $self->{table_status}->{$db} = \@tables unless $like;
2428  ***      0                                  0         return @tables;
2429                                                     }
2430  ***      0                                  0      return @{$self->{table_status}->{$db}};
      ***      0                                  0   
2431                                                  }
2432                                                  
2433                                                  sub get_table_list {
2434  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
2435  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_list}->{$db} || $like ) {
      ***                    0                        
2436  ***      0                                  0         my $sql = "SHOW /*!50002 FULL*/ TABLES FROM " . $quoter->quote($db);
2437  ***      0                                  0         my @params;
2438  ***      0      0                           0         if ( $like ) {
2439  ***      0                                  0            $sql .= ' LIKE ?';
2440  ***      0                                  0            push @params, $like;
2441                                                        }
2442  ***      0                                  0         MKDEBUG && _d($sql, @params);
2443  ***      0                                  0         my $sth = $dbh->prepare($sql);
2444  ***      0                                  0         $sth->execute(@params);
2445  ***      0                                  0         my @tables = @{$sth->fetchall_arrayref()};
      ***      0                                  0   
2446  ***      0      0      0                    0         @tables = map {
2447  ***      0                                  0            my %tbl = (
2448                                                              name   => $_->[0],
2449                                                              engine => ($_->[1] || '') eq 'VIEW' ? 'VIEW' : '',
2450                                                           );
2451  ***      0                                  0            \%tbl;
2452                                                        } @tables;
2453  ***      0      0                           0         $self->{table_list}->{$db} = \@tables unless $like;
2454  ***      0                                  0         return @tables;
2455                                                     }
2456  ***      0                                  0      return @{$self->{table_list}->{$db}};
      ***      0                                  0   
2457                                                  }
2458                                                  
2459                                                  sub _d {
2460  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2461  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2462  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2463                                                          @_;
2464  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2465                                                  }
2466                                                  
2467                                                  1;
2468                                                  
2469                                                  # ###########################################################################
2470                                                  # End MySQLDump package
2471                                                  # ###########################################################################
2472                                                  
2473                                                  # ###########################################################################
2474                                                  # TableChunker package 5955
2475                                                  # This package is a copy without comments from the original.  The original
2476                                                  # with comments and its test file can be found in the SVN repository at,
2477                                                  #   trunk/common/TableChunker.pm
2478                                                  #   trunk/common/t/TableChunker.t
2479                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
2480                                                  # ###########################################################################
2481          27                   27           215   use strict;
              27                                 80   
              27                                149   
2482          27                   27           161   use warnings FATAL => 'all';
              27                                 72   
              27                                158   
2483                                                  
2484                                                  package TableChunker;
2485                                                  
2486          27                   27           182   use English qw(-no_match_vars);
              27                                 66   
              27                                163   
2487          27                   27           181   use POSIX qw(ceil);
              27                                 64   
              27                                246   
2488          27                   27           176   use List::Util qw(min max);
              27                                 73   
              27                                152   
2489          27                   27           172   use Data::Dumper;
              27                                 64   
              27                                142   
2490                                                  $Data::Dumper::Indent    = 1;
2491                                                  $Data::Dumper::Sortkeys  = 1;
2492                                                  $Data::Dumper::Quotekeys = 0;
2493                                                  
2494  ***     27            50     27           172   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 67   
              27                                405   
2495                                                  
2496                                                  sub new {
2497          15                   15           100      my ( $class, %args ) = @_;
2498          15                                 68      foreach my $arg ( qw(Quoter MySQLDump) ) {
2499  ***     30     50                         158         die "I need a $arg argument" unless $args{$arg};
2500                                                     }
2501          15                                 73      my $self = { %args };
2502          15                                128      return bless $self, $class;
2503                                                  }
2504                                                  
2505                                                  my $EPOCH      = '1970-01-01';
2506                                                  my %int_types  = map { $_ => 1 }
2507                                                     qw(bigint date datetime int mediumint smallint time timestamp tinyint year);
2508                                                  my %real_types = map { $_ => 1 }
2509                                                     qw(decimal double float);
2510                                                  
2511                                                  sub find_chunk_columns {
2512          15                   15            81      my ( $self, %args ) = @_;
2513          15                                 72      foreach my $arg ( qw(tbl_struct) ) {
2514  ***     15     50                          91         die "I need a $arg argument" unless $args{$arg};
2515                                                     }
2516          15                                 56      my $tbl_struct = $args{tbl_struct};
2517                                                  
2518          15                                 41      my @possible_indexes;
2519          15                                 50      foreach my $index ( values %{ $tbl_struct->{keys} } ) {
              15                                 88   
2520                                                  
2521  ***     14     50                          84         next unless $index->{type} eq 'BTREE';
2522                                                  
2523  ***     14            33                   31         defined $_ && next for @{ $index->{col_prefixes} };
              14                                 45   
              14                                120   
2524                                                  
2525  ***     14     50                          73         if ( $args{exact} ) {
2526  ***      0      0      0                    0            next unless $index->{is_unique} && @{$index->{cols}} == 1;
      ***      0                                  0   
2527                                                        }
2528                                                  
2529          14                                 65         push @possible_indexes, $index;
2530                                                     }
2531                                                     MKDEBUG && _d('Possible chunk indexes in order:',
2532          15                                 41         join(', ', map { $_->{name} } @possible_indexes));
2533                                                  
2534          15                                 47      my $can_chunk_exact = 0;
2535          15                                 47      my @candidate_cols;
2536          15                                 56      foreach my $index ( @possible_indexes ) { 
2537          14                                 67         my $col = $index->{cols}->[0];
2538                                                  
2539  ***     14    100     66                  137         next unless ( $int_types{$tbl_struct->{type_for}->{$col}}
2540                                                                      || $real_types{$tbl_struct->{type_for}->{$col}} );
2541                                                  
2542          13                                116         push @candidate_cols, { column => $col, index => $index->{name} };
2543                                                     }
2544                                                  
2545  ***     15     50     50                  113      $can_chunk_exact = 1 if $args{exact} && scalar @candidate_cols;
2546                                                  
2547          15                                 39      if ( MKDEBUG ) {
2548                                                        my $chunk_type = $args{exact} ? 'Exact' : 'Inexact';
2549                                                        _d($chunk_type, 'chunkable:',
2550                                                           join(', ', map { "$_->{column} on $_->{index}" } @candidate_cols));
2551                                                     }
2552                                                  
2553          15                                 44      my @result;
2554          15                                 36      MKDEBUG && _d('Ordering columns by order in tbl, PK first');
2555          15    100                          88      if ( $tbl_struct->{keys}->{PRIMARY} ) {
2556           9                                 54         my $pk_first_col = $tbl_struct->{keys}->{PRIMARY}->{cols}->[0];
2557           9                                 30         @result          = grep { $_->{column} eq $pk_first_col } @candidate_cols;
               8                                 43   
2558           9                                 39         @candidate_cols  = grep { $_->{column} ne $pk_first_col } @candidate_cols;
               8                                 40   
2559                                                     }
2560          15                                 53      my $i = 0;
2561          15                                 50      my %col_pos = map { $_ => $i++ } @{$tbl_struct->{cols}};
              53                                230   
              15                                 70   
2562          15                                111      push @result, sort { $col_pos{$a->{column}} <=> $col_pos{$b->{column}} }
      ***      0                                  0   
2563                                                                      @candidate_cols;
2564                                                  
2565          15                                 42      if ( MKDEBUG ) {
2566                                                        _d('Chunkable columns:',
2567                                                           join(', ', map { "$_->{column} on $_->{index}" } @result));
2568                                                        _d('Can chunk exactly:', $can_chunk_exact);
2569                                                     }
2570                                                  
2571          15                                 98      return ($can_chunk_exact, @result);
2572                                                  }
2573                                                  
2574                                                  sub calculate_chunks {
2575  ***      0                    0             0      my ( $self, %args ) = @_;
2576  ***      0                                  0      foreach my $arg ( qw(dbh tbl_struct chunk_col min max rows_in_range
2577                                                                          chunk_size dbh) ) {
2578  ***      0      0                           0         die "I need a $arg argument" unless defined $args{$arg};
2579                                                     }
2580  ***      0                                  0      MKDEBUG && _d('Calculate chunks for', Dumper(\%args));
2581  ***      0                                  0      my $dbh = $args{dbh};
2582                                                  
2583  ***      0                                  0      my @chunks;
2584  ***      0                                  0      my ($range_func, $start_point, $end_point);
2585  ***      0                                  0      my $col_type = $args{tbl_struct}->{type_for}->{$args{chunk_col}};
2586  ***      0                                  0      MKDEBUG && _d('chunk col type:', $col_type);
2587                                                  
2588                                                  
2589  ***      0      0                           0      if ( $col_type =~ m/(?:int|year|float|double|decimal)$/ ) {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
2590  ***      0                                  0         $start_point = $args{min};
2591  ***      0                                  0         $end_point   = $args{max};
2592  ***      0                                  0         $range_func  = 'range_num';
2593                                                     }
2594                                                     elsif ( $col_type eq 'timestamp' ) {
2595  ***      0                                  0         my $sql = "SELECT UNIX_TIMESTAMP('$args{min}'), UNIX_TIMESTAMP('$args{max}')";
2596  ***      0                                  0         MKDEBUG && _d($sql);
2597  ***      0                                  0         ($start_point, $end_point) = $dbh->selectrow_array($sql);
2598  ***      0                                  0         $range_func  = 'range_timestamp';
2599                                                     }
2600                                                     elsif ( $col_type eq 'date' ) {
2601  ***      0                                  0         my $sql = "SELECT TO_DAYS('$args{min}'), TO_DAYS('$args{max}')";
2602  ***      0                                  0         MKDEBUG && _d($sql);
2603  ***      0                                  0         ($start_point, $end_point) = $dbh->selectrow_array($sql);
2604  ***      0                                  0         $range_func  = 'range_date';
2605                                                     }
2606                                                     elsif ( $col_type eq 'time' ) {
2607  ***      0                                  0         my $sql = "SELECT TIME_TO_SEC('$args{min}'), TIME_TO_SEC('$args{max}')";
2608  ***      0                                  0         MKDEBUG && _d($sql);
2609  ***      0                                  0         ($start_point, $end_point) = $dbh->selectrow_array($sql);
2610  ***      0                                  0         $range_func  = 'range_time';
2611                                                     }
2612                                                     elsif ( $col_type eq 'datetime' ) {
2613  ***      0                                  0         $start_point = $self->timestampdiff($dbh, $args{min});
2614  ***      0                                  0         $end_point   = $self->timestampdiff($dbh, $args{max});
2615  ***      0                                  0         $range_func  = 'range_datetime';
2616                                                     }
2617                                                     else {
2618  ***      0                                  0         die "I don't know how to chunk $col_type\n";
2619                                                     }
2620                                                  
2621  ***      0      0                           0      if ( !defined $start_point ) {
2622  ***      0                                  0         MKDEBUG && _d('Start point is undefined');
2623  ***      0                                  0         $start_point = 0;
2624                                                     }
2625  ***      0      0      0                    0      if ( !defined $end_point || $end_point < $start_point ) {
2626  ***      0                                  0         MKDEBUG && _d('End point is undefined or before start point');
2627  ***      0                                  0         $end_point = 0;
2628                                                     }
2629  ***      0                                  0      MKDEBUG && _d('Start and end of chunk range:',$start_point,',', $end_point);
2630                                                  
2631  ***      0                                  0      my $interval = $args{chunk_size}
2632                                                                  * ($end_point - $start_point)
2633                                                                  / $args{rows_in_range};
2634  ***      0      0                           0      if ( $int_types{$col_type} ) {
2635  ***      0                                  0         $interval = ceil($interval);
2636                                                     }
2637  ***      0             0                    0      $interval ||= $args{chunk_size};
2638  ***      0      0                           0      if ( $args{exact} ) {
2639  ***      0                                  0         $interval = $args{chunk_size};
2640                                                     }
2641  ***      0                                  0      MKDEBUG && _d('Chunk interval:', $interval, 'units');
2642                                                  
2643  ***      0                                  0      my $col = $self->{Quoter}->quote($args{chunk_col});
2644  ***      0      0                           0      if ( $start_point < $end_point ) {
2645  ***      0                                  0         my ( $beg, $end );
2646  ***      0                                  0         my $iter = 0;
2647                                                        for ( my $i = $start_point; $i < $end_point; $i += $interval ) {
2648  ***      0                                  0            ( $beg, $end ) = $self->$range_func($dbh, $i, $interval, $end_point);
2649                                                  
2650  ***      0      0                           0            if ( $iter++ == 0 ) {
2651  ***      0                                  0               push @chunks, "$col < " . $self->quote($end);
2652                                                           }
2653                                                           else {
2654  ***      0                                  0               push @chunks, "$col >= " . $self->quote($beg) . " AND $col < " . $self->quote($end);
2655                                                           }
2656  ***      0                                  0         }
2657                                                  
2658  ***      0                                  0         my $nullable = $args{tbl_struct}->{is_nullable}->{$args{chunk_col}};
2659  ***      0                                  0         pop @chunks;
2660  ***      0      0                           0         if ( @chunks ) {
2661  ***      0                                  0            push @chunks, "$col >= " . $self->quote($beg);
2662                                                        }
2663                                                        else {
2664  ***      0      0                           0            push @chunks, $nullable ? "$col IS NOT NULL" : '1=1';
2665                                                        }
2666  ***      0      0                           0         if ( $nullable ) {
2667  ***      0                                  0            push @chunks, "$col IS NULL";
2668                                                        }
2669                                                  
2670                                                     }
2671                                                     else {
2672  ***      0                                  0         MKDEBUG && _d('No chunks; using single chunk 1=1');
2673  ***      0                                  0         push @chunks, '1=1';
2674                                                     }
2675                                                  
2676  ***      0                                  0      return @chunks;
2677                                                  }
2678                                                  
2679                                                  sub get_first_chunkable_column {
2680          15                   15            97      my ( $self, %args ) = @_;
2681          15                                101      foreach my $arg ( qw(tbl_struct) ) {
2682  ***     15     50                          98         die "I need a $arg argument" unless $args{$arg};
2683                                                     }
2684          15                                109      my ($exact, @cols) = $self->find_chunk_columns(%args);
2685          15                                124      return ( $cols[0]->{column}, $cols[0]->{index} );
2686                                                  }
2687                                                  
2688                                                  sub size_to_rows {
2689  ***      0                    0             0      my ( $self, %args ) = @_;
2690  ***      0                                  0      my @required_args = qw(dbh db tbl chunk_size);
2691  ***      0                                  0      foreach my $arg ( @required_args ) {
2692  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
2693                                                     }
2694  ***      0                                  0      my ($dbh, $db, $tbl, $chunk_size) = @args{@required_args};
2695  ***      0                                  0      my $q  = $self->{Quoter};
2696  ***      0                                  0      my $du = $self->{MySQLDump};
2697                                                  
2698  ***      0                                  0      my ($n_rows, $avg_row_length);
2699                                                  
2700  ***      0                                  0      my ( $num, $suffix ) = $chunk_size =~ m/^(\d+)([MGk])?$/;
2701  ***      0      0                           0      if ( $suffix ) { # Convert to bytes.
      ***             0                               
2702  ***      0      0                           0         $chunk_size = $suffix eq 'k' ? $num * 1_024
      ***             0                               
2703                                                                    : $suffix eq 'M' ? $num * 1_024 * 1_024
2704                                                                    :                  $num * 1_024 * 1_024 * 1_024;
2705                                                     }
2706                                                     elsif ( $num ) {
2707  ***      0                                  0         $n_rows = $num;
2708                                                     }
2709                                                     else {
2710  ***      0                                  0         die "Invalid chunk size $chunk_size; must be an integer "
2711                                                           . "with optional suffix kMG";
2712                                                     }
2713                                                  
2714  ***      0      0      0                    0      if ( $suffix || $args{avg_row_length} ) {
2715  ***      0                                  0         my ($status) = $du->get_table_status($dbh, $q, $db, $tbl);
2716  ***      0                                  0         $avg_row_length = $status->{avg_row_length};
2717  ***      0      0                           0         if ( !defined $n_rows ) {
2718  ***      0      0                           0            $n_rows = $avg_row_length ? ceil($chunk_size / $avg_row_length) : undef;
2719                                                        }
2720                                                     }
2721                                                  
2722  ***      0      0                           0      return wantarray ? ($n_rows, $avg_row_length) : $n_rows;
2723                                                  }
2724                                                  
2725                                                  sub get_range_statistics {
2726  ***      0                    0             0      my ( $self, %args ) = @_;
2727  ***      0                                  0      my @required_args = qw(dbh db tbl chunk_col);
2728  ***      0                                  0      foreach my $arg ( @required_args ) {
2729  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
2730                                                     }
2731  ***      0                                  0      my ($dbh, $db, $tbl, $col) = @args{@required_args};
2732  ***      0                                  0      my $where = $args{where};
2733  ***      0                                  0      my $q = $self->{Quoter};
2734  ***      0      0                           0      my $sql = "SELECT MIN(" . $q->quote($col) . "), MAX(" . $q->quote($col)
2735                                                        . ") FROM " . $q->quote($db, $tbl)
2736                                                        . ($where ? " WHERE $where" : '');
2737  ***      0                                  0      MKDEBUG && _d($sql);
2738  ***      0                                  0      my ( $min, $max );
2739  ***      0                                  0      eval {
2740  ***      0                                  0         ( $min, $max ) = $dbh->selectrow_array($sql);
2741                                                     };
2742  ***      0      0                           0      if ( $EVAL_ERROR ) {
2743  ***      0                                  0         chomp $EVAL_ERROR;
2744  ***      0      0                           0         if ( $EVAL_ERROR =~ m/in your SQL syntax/ ) {
2745  ***      0                                  0            die "$EVAL_ERROR (WHERE clause: $where)";
2746                                                        }
2747                                                        else {
2748  ***      0                                  0            die $EVAL_ERROR;
2749                                                        }
2750                                                     }
2751                                                  
2752  ***      0      0                           0      if ( !$args{zero_row} ) {
2753  ***      0      0      0                    0         if ( !$min
      ***                    0                        
      ***                    0                        
2754                                                             || $min eq '0'
2755                                                             || $min eq '0000-00-00'
2756                                                             || $min eq '0000-00-00 00:00:00'
2757                                                           )
2758                                                        {
2759  ***      0                                  0            MKDEBUG && _d('Discarding zero min:', $min);
2760  ***      0      0                           0            $sql = "SELECT MIN(" . $q->quote($col) . ") FROM "
2761                                                                . $q->quote($db, $tbl)
2762                                                                . "WHERE $col > ? "
2763                                                                . ($where ? " AND $where " : '')
2764                                                                . "LIMIT 1";
2765  ***      0                                  0            MKDEBUG && _d($sql);
2766  ***      0                                  0            my $sth = $dbh->prepare($sql);
2767  ***      0                                  0            $sth->execute($min);
2768  ***      0                                  0            ($min) = $sth->fetchrow_array();
2769  ***      0                                  0            MKDEBUG && _d('New min:', $min);
2770                                                        }
2771                                                     }
2772                                                  
2773  ***      0      0                           0      $sql = "EXPLAIN SELECT * FROM " . $q->quote($db, $tbl)
2774                                                        . ($where ? " WHERE $where" : '');
2775  ***      0                                  0      MKDEBUG && _d($sql);
2776  ***      0                                  0      my $expl = $dbh->selectrow_hashref($sql);
2777                                                     return (
2778  ***      0                                  0         min           => $min,
2779                                                        max           => $max,
2780                                                        rows_in_range => $expl->{rows},
2781                                                     );
2782                                                  }
2783                                                  
2784                                                  sub quote {
2785  ***      0                    0             0      my ( $self, $val ) = @_;
2786  ***      0      0                           0      return $val =~ m/\d[:-]/ ? qq{"$val"} : $val;
2787                                                  }
2788                                                  
2789                                                  sub inject_chunks {
2790          10                   10           143      my ( $self, %args ) = @_;
2791          10                                 70      foreach my $arg ( qw(database table chunks chunk_num query) ) {
2792  ***     50     50                         258         die "I need a $arg argument" unless defined $args{$arg};
2793                                                     }
2794          10                                 28      MKDEBUG && _d('Injecting chunk', $args{chunk_num});
2795          10                                 41      my $query   = $args{query};
2796          10                                 84      my $comment = sprintf("/*%s.%s:%d/%d*/",
2797                                                        $args{database}, $args{table},
2798          10                                 63         $args{chunk_num} + 1, scalar @{$args{chunks}});
2799          10                                115      $query =~ s!/\*PROGRESS_COMMENT\*/!$comment!;
2800          10                                 65      my $where = "WHERE (" . $args{chunks}->[$args{chunk_num}] . ')';
2801  ***     10     50     33                   75      if ( $args{where} && grep { $_ } @{$args{where}} ) {
              20                                109   
              10                                 46   
2802  ***      0                                  0         $where .= " AND ("
2803  ***      0                                  0            . join(" AND ", map { "($_)" } grep { $_ } @{$args{where}} )
      ***      0                                  0   
      ***      0                                  0   
2804                                                           . ")";
2805                                                     }
2806          10                                100      my $db_tbl     = $self->{Quoter}->quote(@args{qw(database table)});
2807  ***     10            50                   74      my $index_hint = $args{index_hint} || '';
2808                                                  
2809          10                                 24      MKDEBUG && _d('Parameters:',
2810                                                        Dumper({WHERE => $where, DB_TBL => $db_tbl, INDEX_HINT => $index_hint}));
2811          10                                 93      $query =~ s!/\*WHERE\*/! $where!;
2812          10                                 64      $query =~ s!/\*DB_TBL\*/!$db_tbl!;
2813          10                                 64      $query =~ s!/\*INDEX_HINT\*/! $index_hint!;
2814          10                                 78      $query =~ s!/\*CHUNK_NUM\*/! $args{chunk_num} AS chunk_num,!;
2815                                                  
2816          10                                 73      return $query;
2817                                                  }
2818                                                  
2819                                                  sub range_num {
2820  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
2821  ***      0                                  0      my $end = min($max, $start + $interval);
2822                                                  
2823                                                  
2824  ***      0      0                           0      $start = sprintf('%.17f', $start) if $start =~ /e/;
2825  ***      0      0                           0      $end   = sprintf('%.17f', $end)   if $end   =~ /e/;
2826                                                  
2827  ***      0                                  0      $start =~ s/\.(\d{5}).*$/.$1/;
2828  ***      0                                  0      $end   =~ s/\.(\d{5}).*$/.$1/;
2829                                                  
2830  ***      0      0                           0      if ( $end > $start ) {
2831  ***      0                                  0         return ( $start, $end );
2832                                                     }
2833                                                     else {
2834  ***      0                                  0         die "Chunk size is too small: $end !> $start\n";
2835                                                     }
2836                                                  }
2837                                                  
2838                                                  sub range_time {
2839  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
2840  ***      0                                  0      my $sql = "SELECT SEC_TO_TIME($start), SEC_TO_TIME(LEAST($max, $start + $interval))";
2841  ***      0                                  0      MKDEBUG && _d($sql);
2842  ***      0                                  0      return $dbh->selectrow_array($sql);
2843                                                  }
2844                                                  
2845                                                  sub range_date {
2846  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
2847  ***      0                                  0      my $sql = "SELECT FROM_DAYS($start), FROM_DAYS(LEAST($max, $start + $interval))";
2848  ***      0                                  0      MKDEBUG && _d($sql);
2849  ***      0                                  0      return $dbh->selectrow_array($sql);
2850                                                  }
2851                                                  
2852                                                  sub range_datetime {
2853  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
2854  ***      0                                  0      my $sql = "SELECT DATE_ADD('$EPOCH', INTERVAL $start SECOND), "
2855                                                         . "DATE_ADD('$EPOCH', INTERVAL LEAST($max, $start + $interval) SECOND)";
2856  ***      0                                  0      MKDEBUG && _d($sql);
2857  ***      0                                  0      return $dbh->selectrow_array($sql);
2858                                                  }
2859                                                  
2860                                                  sub range_timestamp {
2861  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
2862  ***      0                                  0      my $sql = "SELECT FROM_UNIXTIME($start), FROM_UNIXTIME(LEAST($max, $start + $interval))";
2863  ***      0                                  0      MKDEBUG && _d($sql);
2864  ***      0                                  0      return $dbh->selectrow_array($sql);
2865                                                  }
2866                                                  
2867                                                  sub timestampdiff {
2868  ***      0                    0             0      my ( $self, $dbh, $time ) = @_;
2869  ***      0                                  0      my $sql = "SELECT (COALESCE(TO_DAYS('$time'), 0) * 86400 + TIME_TO_SEC('$time')) "
2870                                                        . "- TO_DAYS('$EPOCH 00:00:00') * 86400";
2871  ***      0                                  0      MKDEBUG && _d($sql);
2872  ***      0                                  0      my ( $diff ) = $dbh->selectrow_array($sql);
2873  ***      0                                  0      $sql = "SELECT DATE_ADD('$EPOCH', INTERVAL $diff SECOND)";
2874  ***      0                                  0      MKDEBUG && _d($sql);
2875  ***      0                                  0      my ( $check ) = $dbh->selectrow_array($sql);
2876  ***      0      0                           0      die <<"   EOF"
2877                                                     Incorrect datetime math: given $time, calculated $diff but checked to $check.
2878                                                     This is probably because you are using a version of MySQL that overflows on
2879                                                     large interval values to DATE_ADD().  If not, please report this as a bug.
2880                                                     EOF
2881                                                        unless $check eq $time;
2882  ***      0                                  0      return $diff;
2883                                                  }
2884                                                  
2885                                                  sub _d {
2886  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2887  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2888  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2889                                                          @_;
2890  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2891                                                  }
2892                                                  
2893                                                  1;
2894                                                  
2895                                                  # ###########################################################################
2896                                                  # End TableChunker package
2897                                                  # ###########################################################################
2898                                                  
2899                                                  # ###########################################################################
2900                                                  # Quoter package 6079
2901                                                  # This package is a copy without comments from the original.  The original
2902                                                  # with comments and its test file can be found in the SVN repository at,
2903                                                  #   trunk/common/Quoter.pm
2904                                                  #   trunk/common/t/Quoter.t
2905                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
2906                                                  # ###########################################################################
2907                                                  package Quoter;
2908                                                  
2909          27                   27           237   use strict;
              27                                 72   
              27                                170   
2910          27                   27           174   use warnings FATAL => 'all';
              27                                 71   
              27                                170   
2911          27                   27           163   use English qw(-no_match_vars);
              27                                 67   
              27                                160   
2912                                                  
2913  ***     27            50     27           183   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 95   
              27                                547   
2914                                                  
2915                                                  sub new {
2916          15                   15            72      my ( $class ) = @_;
2917          15                                145      return bless {}, $class;
2918                                                  }
2919                                                  
2920                                                  sub quote {
2921         117                  117           647      my ( $self, @vals ) = @_;
2922         117                                472      foreach my $val ( @vals ) {
2923         156                                759         $val =~ s/`/``/g;
2924                                                     }
2925         117                                476      return join('.', map { '`' . $_ . '`' } @vals);
             156                               2706   
2926                                                  }
2927                                                  
2928                                                  sub quote_val {
2929  ***      0                    0             0      my ( $self, $val, $is_numeric ) = @_;
2930                                                  
2931  ***      0      0                           0      return 'NULL' unless defined $val;         # undef = NULL
2932  ***      0      0                           0      return "''" if $val eq '';                 # blank string = ''
2933  ***      0      0                           0      return $val if $val =~ m/^0x[0-9a-fA-F]/;  # hex value like 0xe5f190
2934                                                  
2935  ***      0      0                           0      if ( !defined $is_numeric ) {
2936  ***      0      0                           0         $is_numeric = $val =~ m/^0|\D/ ? 0 : 1;
2937                                                     }
2938                                                  
2939  ***      0      0                           0      return $val if $is_numeric;
2940                                                  
2941  ***      0                                  0      $val =~ s/(['\\])/\\$1/g;
2942  ***      0                                  0      return "'$val'";
2943                                                  }
2944                                                  
2945                                                  sub split_unquote {
2946          20                   20           112      my ( $self, $db_tbl, $default_db ) = @_;
2947          20                                130      $db_tbl =~ s/`//g;
2948          20                                166      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
2949          20    100                         103      if ( !$tbl ) {
2950          15                                 49         $tbl = $db;
2951          15                                 47         $db  = $default_db;
2952                                                     }
2953          20                                106      return ($db, $tbl);
2954                                                  }
2955                                                  
2956                                                  sub literal_like {
2957          10                   10            47      my ( $self, $like ) = @_;
2958  ***     10     50                          49      return unless $like;
2959          10                                 44      $like =~ s/([%_])/\\$1/g;
2960          10                                 59      return "'$like'";
2961                                                  }
2962                                                  
2963                                                  1;
2964                                                  
2965                                                  # ###########################################################################
2966                                                  # End Quoter package
2967                                                  # ###########################################################################
2968                                                  
2969                                                  # ###########################################################################
2970                                                  # MasterSlave package 6184
2971                                                  # This package is a copy without comments from the original.  The original
2972                                                  # with comments and its test file can be found in the SVN repository at,
2973                                                  #   trunk/common/MasterSlave.pm
2974                                                  #   trunk/common/t/MasterSlave.t
2975                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
2976                                                  # ###########################################################################
2977          27                   27           203   use strict;
              27                                 72   
              27                                142   
2978          27                   27           159   use warnings FATAL => 'all';
              27                                 59   
              27                                148   
2979                                                  
2980                                                  package MasterSlave;
2981                                                  
2982          27                   27           192   use English qw(-no_match_vars);
              27                                 82   
              27                                144   
2983          27                   27           183   use List::Util qw(min max);
              27                                 74   
              27                                152   
2984          27                   27           167   use Data::Dumper;
              27                                 69   
              27                                145   
2985                                                  $Data::Dumper::Quotekeys = 0;
2986                                                  $Data::Dumper::Indent    = 0;
2987                                                  
2988  ***     27            50     27           184   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 78   
              27                                363   
2989                                                  
2990                                                  sub new {
2991          15                   15            84      my ( $class, %args ) = @_;
2992          15                                 81      my $self = { %args };
2993          15                                132      return bless $self, $class;
2994                                                  }
2995                                                  
2996                                                  sub recurse_to_slaves {
2997           9                    9            50      my ( $self, $args, $level ) = @_;
2998           9           100                   48      $level ||= 0;
2999           9                                 38      my $dp   = $args->{dsn_parser};
3000           9                                 36      my $dsn  = $args->{dsn};
3001                                                  
3002           9                                 25      my $dbh;
3003           9                                 35      eval {
3004  ***      9            66                   84         $dbh = $args->{dbh} || $dp->get_dbh(
3005                                                           $dp->get_cxn_params($dsn), { AutoCommit => 1 });
3006           9                                 45         MKDEBUG && _d('Connected to', $dp->as_string($dsn));
3007                                                     };
3008  ***      9     50                          52      if ( $EVAL_ERROR ) {
3009  ***      0      0                           0         print STDERR "Cannot connect to ", $dp->as_string($dsn), "\n"
3010                                                           or die "Cannot print: $OS_ERROR";
3011  ***      0                                  0         return;
3012                                                     }
3013                                                  
3014           9                                 42      my $sql  = 'SELECT @@SERVER_ID';
3015           9                                 25      MKDEBUG && _d($sql);
3016           9                                 28      my ($id) = $dbh->selectrow_array($sql);
3017           9                               2758      MKDEBUG && _d('Working on server ID', $id);
3018           9                                 62      my $master_thinks_i_am = $dsn->{server_id};
3019  ***      9     50     66                  277      if ( !defined $id
      ***                   33                        
      ***                   33                        
3020                                                         || ( defined $master_thinks_i_am && $master_thinks_i_am != $id )
3021                                                         || $args->{server_ids_seen}->{$id}++
3022                                                     ) {
3023  ***      0                                  0         MKDEBUG && _d('Server ID seen, or not what master said');
3024  ***      0      0                           0         if ( $args->{skip_callback} ) {
3025  ***      0                                  0            $args->{skip_callback}->($dsn, $dbh, $level, $args->{parent});
3026                                                        }
3027  ***      0                                  0         return;
3028                                                     }
3029                                                  
3030           9                                 81      $args->{callback}->($dsn, $dbh, $level, $args->{parent});
3031                                                  
3032  ***      9     50     33                   85      if ( !defined $args->{recurse} || $level < $args->{recurse} ) {
3033                                                  
3034  ***      6     50                         110         my @slaves =
3035           9                                 92            grep { !$_->{master_id} || $_->{master_id} == $id } # Only my slaves.
3036                                                           $self->find_slave_hosts($dp, $dbh, $dsn, $args->{method});
3037                                                  
3038           9                                 95         foreach my $slave ( @slaves ) {
3039           6                                 14            MKDEBUG && _d('Recursing from',
3040                                                              $dp->as_string($dsn), 'to', $dp->as_string($slave));
3041           6                                125            $self->recurse_to_slaves(
3042                                                              { %$args, dsn => $slave, dbh => undef, parent => $dsn }, $level + 1 );
3043                                                        }
3044                                                     }
3045                                                  }
3046                                                  
3047                                                  sub find_slave_hosts {
3048           9                    9            60      my ( $self, $dsn_parser, $dbh, $dsn, $method ) = @_;
3049                                                  
3050           9                                 78      my @methods = qw(processlist hosts);
3051  ***      9     50                          49      if ( $method ) {
3052  ***      0                                  0         @methods = grep { $_ ne $method } @methods;
      ***      0                                  0   
3053  ***      0                                  0         unshift @methods, $method;
3054                                                     }
3055                                                     else {
3056  ***      9     50     50                   91         if ( ($dsn->{P} || 3306) != 3306 ) {
3057           9                                 29            MKDEBUG && _d('Port number is non-standard; using only hosts method');
3058           9                                 49            @methods = qw(hosts);
3059                                                        }
3060                                                     }
3061           9                                 26      MKDEBUG && _d('Looking for slaves on', $dsn_parser->as_string($dsn),
3062                                                        'using methods', @methods);
3063                                                  
3064           9                                 31      my @slaves;
3065                                                     METHOD:
3066           9                                 55      foreach my $method ( @methods ) {
3067           9                                 45         my $find_slaves = "_find_slaves_by_$method";
3068           9                                 26         MKDEBUG && _d('Finding slaves with', $find_slaves);
3069           9                                 74         @slaves = $self->$find_slaves($dsn_parser, $dbh, $dsn);
3070           9    100                          58         last METHOD if @slaves;
3071                                                     }
3072                                                  
3073           9                                 27      MKDEBUG && _d('Found', scalar(@slaves), 'slaves');
3074           9                                 51      return @slaves;
3075                                                  }
3076                                                  
3077                                                  sub _find_slaves_by_processlist {
3078  ***      0                    0             0      my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
3079                                                  
3080  ***      0                                  0      my @slaves = map  {
3081  ***      0                                  0         my $slave        = $dsn_parser->parse("h=$_", $dsn);
3082  ***      0                                  0         $slave->{source} = 'processlist';
3083  ***      0                                  0         $slave;
3084                                                     }
3085  ***      0                                  0      grep { $_ }
3086                                                     map  {
3087  ***      0                                  0         my ( $host ) = $_->{host} =~ m/^([^:]+):/;
3088  ***      0      0                           0         if ( $host eq 'localhost' ) {
3089  ***      0                                  0            $host = '127.0.0.1'; # Replication never uses sockets.
3090                                                        }
3091  ***      0                                  0         $host;
3092                                                     } $self->get_connected_slaves($dbh);
3093                                                  
3094  ***      0                                  0      return @slaves;
3095                                                  }
3096                                                  
3097                                                  sub _find_slaves_by_hosts {
3098           9                    9            55      my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
3099                                                  
3100           9                                 30      my @slaves;
3101           9                                 33      my $sql = 'SHOW SLAVE HOSTS';
3102           9                                 25      MKDEBUG && _d($dbh, $sql);
3103           9                                 35      @slaves = @{$dbh->selectall_arrayref($sql, { Slice => {} })};
               9                                116   
3104                                                  
3105           9    100                         112      if ( @slaves ) {
3106           6                                 18         MKDEBUG && _d('Found some SHOW SLAVE HOSTS info');
3107           6                                 21         @slaves = map {
3108           6                                 28            my %hash;
3109           6                                 57            @hash{ map { lc $_ } keys %$_ } = values %$_;
              30                                150   
3110  ***      6     50                          86            my $spec = "h=$hash{host},P=$hash{port}"
      ***            50                               
3111                                                              . ( $hash{user} ? ",u=$hash{user}" : '')
3112                                                              . ( $hash{password} ? ",p=$hash{password}" : '');
3113           6                                 42            my $dsn           = $dsn_parser->parse($spec, $dsn);
3114           6                                 38            $dsn->{server_id} = $hash{server_id};
3115           6                                 32            $dsn->{master_id} = $hash{master_id};
3116           6                                 28            $dsn->{source}    = 'hosts';
3117           6                                 46            $dsn;
3118                                                        } @slaves;
3119                                                     }
3120                                                  
3121           9                                 51      return @slaves;
3122                                                  }
3123                                                  
3124                                                  sub get_connected_slaves {
3125  ***      0                    0             0      my ( $self, $dbh ) = @_;
3126                                                  
3127  ***      0                                  0      my $show = "SHOW GRANTS FOR ";
3128  ***      0                                  0      my $user = 'CURRENT_USER()';
3129  ***      0                                  0      my $vp   = $self->{VersionParser};
3130  ***      0      0      0                    0      if ( $vp && !$vp->version_ge($dbh, '4.1.2') ) {
3131  ***      0                                  0         $user = $dbh->selectrow_arrayref('SELECT USER()')->[0];
3132  ***      0                                  0         $user =~ s/([^@]+)@(.+)/'$1'\@'$2'/;
3133                                                     }
3134  ***      0                                  0      my $sql = $show . $user;
3135  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
3136                                                  
3137  ***      0                                  0      my $proc;
3138  ***      0                                  0      eval {
3139  ***      0                                  0         $proc = grep {
3140  ***      0                                  0            m/ALL PRIVILEGES.*?\*\.\*|PROCESS/
3141  ***      0                                  0         } @{$dbh->selectcol_arrayref($sql)};
3142                                                     };
3143  ***      0      0                           0      if ( $EVAL_ERROR ) {
3144                                                  
3145  ***      0      0                           0         if ( $EVAL_ERROR =~ m/no such grant defined for user/ ) {
3146  ***      0                                  0            MKDEBUG && _d('Retrying SHOW GRANTS without host; error:',
3147                                                              $EVAL_ERROR);
3148  ***      0                                  0            ($user) = split('@', $user);
3149  ***      0                                  0            $sql    = $show . $user;
3150  ***      0                                  0            MKDEBUG && _d($sql);
3151  ***      0                                  0            eval {
3152  ***      0                                  0               $proc = grep {
3153  ***      0                                  0                  m/ALL PRIVILEGES.*?\*\.\*|PROCESS/
3154  ***      0                                  0               } @{$dbh->selectcol_arrayref($sql)};
3155                                                           };
3156                                                        }
3157                                                  
3158  ***      0      0                           0         die "Failed to $sql: $EVAL_ERROR" if $EVAL_ERROR;
3159                                                     }
3160  ***      0      0                           0      if ( !$proc ) {
3161  ***      0                                  0         die "You do not have the PROCESS privilege";
3162                                                     }
3163                                                  
3164  ***      0                                  0      $sql = 'SHOW PROCESSLIST';
3165  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
3166  ***      0                                  0      grep { $_->{command} =~ m/Binlog Dump/i }
      ***      0                                  0   
3167                                                     map  { # Lowercase the column names
3168  ***      0                                  0         my %hash;
3169  ***      0                                  0         @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
3170  ***      0                                  0         \%hash;
3171                                                     }
3172  ***      0                                  0      @{$dbh->selectall_arrayref($sql, { Slice => {} })};
3173                                                  }
3174                                                  
3175                                                  sub is_master_of {
3176  ***      0                    0             0      my ( $self, $master, $slave ) = @_;
3177  ***      0      0                           0      my $master_status = $self->get_master_status($master)
3178                                                        or die "The server specified as a master is not a master";
3179  ***      0      0                           0      my $slave_status  = $self->get_slave_status($slave)
3180                                                        or die "The server specified as a slave is not a slave";
3181  ***      0      0                           0      my @connected     = $self->get_connected_slaves($master)
3182                                                        or die "The server specified as a master has no connected slaves";
3183  ***      0                                  0      my (undef, $port) = $master->selectrow_array('SHOW VARIABLES LIKE "port"');
3184                                                  
3185  ***      0      0                           0      if ( $port != $slave_status->{master_port} ) {
3186  ***      0                                  0         die "The slave is connected to $slave_status->{master_port} "
3187                                                           . "but the master's port is $port";
3188                                                     }
3189                                                  
3190  ***      0      0                           0      if ( !grep { $slave_status->{master_user} eq $_->{user} } @connected ) {
      ***      0                                  0   
3191  ***      0                                  0         die "I don't see any slave I/O thread connected with user "
3192                                                           . $slave_status->{master_user};
3193                                                     }
3194                                                  
3195  ***      0      0      0                    0      if ( ($slave_status->{slave_io_state} || '')
3196                                                        eq 'Waiting for master to send event' )
3197                                                     {
3198  ***      0                                  0         my ( $master_log_name, $master_log_num )
3199                                                           = $master_status->{file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
3200  ***      0                                  0         my ( $slave_log_name, $slave_log_num )
3201                                                           = $slave_status->{master_log_file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
3202  ***      0      0      0                    0         if ( $master_log_name ne $slave_log_name
3203                                                           || abs($master_log_num - $slave_log_num) > 1 )
3204                                                        {
3205  ***      0                                  0            die "The slave thinks it is reading from "
3206                                                              . "$slave_status->{master_log_file},  but the "
3207                                                              . "master is writing to $master_status->{file}";
3208                                                        }
3209                                                     }
3210  ***      0                                  0      return 1;
3211                                                  }
3212                                                  
3213                                                  sub get_master_dsn {
3214  ***      0                    0             0      my ( $self, $dbh, $dsn, $dsn_parser ) = @_;
3215  ***      0      0                           0      my $master = $self->get_slave_status($dbh) or return undef;
3216  ***      0                                  0      my $spec   = "h=$master->{master_host},P=$master->{master_port}";
3217  ***      0                                  0      return       $dsn_parser->parse($spec, $dsn);
3218                                                  }
3219                                                  
3220                                                  sub get_slave_status {
3221          12                   12            59      my ( $self, $dbh ) = @_;
3222  ***     12     50                         185      if ( !$self->{not_a_slave}->{$dbh} ) {
3223  ***     12            66                   79         my $sth = $self->{sths}->{$dbh}->{SLAVE_STATUS}
3224                                                              ||= $dbh->prepare('SHOW SLAVE STATUS');
3225          12                                 88         MKDEBUG && _d($dbh, 'SHOW SLAVE STATUS');
3226          12                               3546         $sth->execute();
3227          12                                 53         my ($ss) = @{$sth->fetchall_arrayref({})};
              12                                111   
3228                                                  
3229  ***     12     50     33                  285         if ( $ss && %$ss ) {
3230          12                                159            $ss = { map { lc($_) => $ss->{$_} } keys %$ss }; # lowercase the keys
             456                               2755   
3231          12                                239            return $ss;
3232                                                        }
3233                                                  
3234  ***      0                                  0         MKDEBUG && _d('This server returns nothing for SHOW SLAVE STATUS');
3235  ***      0                                  0         $self->{not_a_slave}->{$dbh}++;
3236                                                     }
3237                                                  }
3238                                                  
3239                                                  sub get_master_status {
3240  ***      0                    0             0      my ( $self, $dbh ) = @_;
3241  ***      0      0                           0      if ( !$self->{not_a_master}->{$dbh} ) {
3242  ***      0             0                    0         my $sth = $self->{sths}->{$dbh}->{MASTER_STATUS}
3243                                                              ||= $dbh->prepare('SHOW MASTER STATUS');
3244  ***      0                                  0         MKDEBUG && _d($dbh, 'SHOW MASTER STATUS');
3245  ***      0                                  0         $sth->execute();
3246  ***      0                                  0         my ($ms) = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
3247                                                  
3248  ***      0      0      0                    0         if ( $ms && %$ms ) {
3249  ***      0                                  0            $ms = { map { lc($_) => $ms->{$_} } keys %$ms }; # lowercase the keys
      ***      0                                  0   
3250  ***      0      0      0                    0            if ( $ms->{file} && $ms->{position} ) {
3251  ***      0                                  0               return $ms;
3252                                                           }
3253                                                        }
3254                                                  
3255  ***      0                                  0         MKDEBUG && _d('This server returns nothing for SHOW MASTER STATUS');
3256  ***      0                                  0         $self->{not_a_master}->{$dbh}++;
3257                                                     }
3258                                                  }
3259                                                  
3260                                                  sub wait_for_master {
3261  ***      0                    0             0      my ( $self, $master, $slave, $time, $timeoutok, $ms ) = @_;
3262  ***      0                                  0      my $result;
3263  ***      0      0                           0      $time = 60 unless defined $time;
3264  ***      0                                  0      MKDEBUG && _d('Waiting', $time, 'seconds for slave to catch up to master;',
3265                                                        'timeout ok:', ($timeoutok ? 'yes' : 'no'));
3266  ***      0             0                    0      $ms ||= $self->get_master_status($master);
3267  ***      0      0                           0      if ( $ms ) {
3268  ***      0                                  0         my $query = "SELECT MASTER_POS_WAIT('$ms->{file}', $ms->{position}, $time)";
3269  ***      0                                  0         MKDEBUG && _d($slave, $query);
3270  ***      0                                  0         ($result) = $slave->selectrow_array($query);
3271  ***      0      0                           0         my $stat = defined $result ? $result : 'NULL';
3272  ***      0                                  0         MKDEBUG && _d('Result of waiting:', $stat);
3273  ***      0      0      0                    0         if ( $stat eq 'NULL' || $stat < 0 && !$timeoutok ) {
      ***                    0                        
3274  ***      0                                  0            die "MASTER_POS_WAIT returned $stat";
3275                                                        }
3276                                                     }
3277                                                     else {
3278  ***      0                                  0         MKDEBUG && _d('Not waiting: this server is not a master');
3279                                                     }
3280  ***      0                                  0      return $result;
3281                                                  }
3282                                                  
3283                                                  sub stop_slave {
3284  ***      0                    0             0      my ( $self, $dbh ) = @_;
3285  ***      0             0                    0      my $sth = $self->{sths}->{$dbh}->{STOP_SLAVE}
3286                                                           ||= $dbh->prepare('STOP SLAVE');
3287  ***      0                                  0      MKDEBUG && _d($dbh, $sth->{Statement});
3288  ***      0                                  0      $sth->execute();
3289                                                  }
3290                                                  
3291                                                  sub start_slave {
3292  ***      0                    0             0      my ( $self, $dbh, $pos ) = @_;
3293  ***      0      0                           0      if ( $pos ) {
3294  ***      0                                  0         my $sql = "START SLAVE UNTIL MASTER_LOG_FILE='$pos->{file}', "
3295                                                                . "MASTER_LOG_POS=$pos->{position}";
3296  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
3297  ***      0                                  0         $dbh->do($sql);
3298                                                     }
3299                                                     else {
3300  ***      0             0                    0         my $sth = $self->{sths}->{$dbh}->{START_SLAVE}
3301                                                              ||= $dbh->prepare('START SLAVE');
3302  ***      0                                  0         MKDEBUG && _d($dbh, $sth->{Statement});
3303  ***      0                                  0         $sth->execute();
3304                                                     }
3305                                                  }
3306                                                  
3307                                                  sub catchup_to_master {
3308  ***      0                    0             0      my ( $self, $slave, $master, $time ) = @_;
3309  ***      0                                  0      $self->stop_slave($master);
3310  ***      0                                  0      $self->stop_slave($slave);
3311  ***      0                                  0      my $slave_status  = $self->get_slave_status($slave);
3312  ***      0                                  0      my $slave_pos     = $self->repl_posn($slave_status);
3313  ***      0                                  0      my $master_status = $self->get_master_status($master);
3314  ***      0                                  0      my $master_pos    = $self->repl_posn($master_status);
3315  ***      0                                  0      MKDEBUG && _d('Master position:', $self->pos_to_string($master_pos),
3316                                                        'Slave position:', $self->pos_to_string($slave_pos));
3317  ***      0      0                           0      if ( $self->pos_cmp($slave_pos, $master_pos) < 0 ) {
3318  ***      0                                  0         MKDEBUG && _d('Waiting for slave to catch up to master');
3319  ***      0                                  0         $self->start_slave($slave, $master_pos);
3320  ***      0                                  0         eval {
3321  ***      0                                  0            $self->wait_for_master($master, $slave, $time, 0, $master_status);
3322                                                        };
3323  ***      0      0                           0         if ( $EVAL_ERROR ) {
3324  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
3325  ***      0      0                           0            if ( $EVAL_ERROR =~ m/MASTER_POS_WAIT returned NULL/ ) {
3326  ***      0                                  0               $slave_status = $self->get_slave_status($slave);
3327  ***      0      0                           0               if ( !$self->slave_is_running($slave_status) ) {
3328  ***      0                                  0                  MKDEBUG && _d('Master position:',
3329                                                                    $self->pos_to_string($master_pos),
3330                                                                    'Slave position:', $self->pos_to_string($slave_pos));
3331  ***      0                                  0                  $slave_pos = $self->repl_posn($slave_status);
3332  ***      0      0                           0                  if ( $self->pos_cmp($slave_pos, $master_pos) != 0 ) {
3333  ***      0                                  0                     die "$EVAL_ERROR but slave has not caught up to master";
3334                                                                 }
3335  ***      0                                  0                  MKDEBUG && _d('Slave is caught up to master and stopped');
3336                                                              }
3337                                                              else {
3338  ***      0                                  0                  die "$EVAL_ERROR but slave was still running";
3339                                                              }
3340                                                           }
3341                                                           else {
3342  ***      0                                  0               die $EVAL_ERROR;
3343                                                           }
3344                                                        }
3345                                                     }
3346                                                  }
3347                                                  
3348                                                  sub catchup_to_same_pos {
3349  ***      0                    0             0      my ( $self, $s1_dbh, $s2_dbh ) = @_;
3350  ***      0                                  0      $self->stop_slave($s1_dbh);
3351  ***      0                                  0      $self->stop_slave($s2_dbh);
3352  ***      0                                  0      my $s1_status = $self->get_slave_status($s1_dbh);
3353  ***      0                                  0      my $s2_status = $self->get_slave_status($s2_dbh);
3354  ***      0                                  0      my $s1_pos    = $self->repl_posn($s1_status);
3355  ***      0                                  0      my $s2_pos    = $self->repl_posn($s2_status);
3356  ***      0      0                           0      if ( $self->pos_cmp($s1_pos, $s2_pos) < 0 ) {
      ***             0                               
3357  ***      0                                  0         $self->start_slave($s1_dbh, $s2_pos);
3358                                                     }
3359                                                     elsif ( $self->pos_cmp($s2_pos, $s1_pos) < 0 ) {
3360  ***      0                                  0         $self->start_slave($s2_dbh, $s1_pos);
3361                                                     }
3362                                                  
3363  ***      0                                  0      $s1_status = $self->get_slave_status($s1_dbh);
3364  ***      0                                  0      $s2_status = $self->get_slave_status($s2_dbh);
3365  ***      0                                  0      $s1_pos    = $self->repl_posn($s1_status);
3366  ***      0                                  0      $s2_pos    = $self->repl_posn($s2_status);
3367                                                  
3368  ***      0      0      0                    0      if ( $self->slave_is_running($s1_status)
      ***                    0                        
3369                                                       || $self->slave_is_running($s2_status)
3370                                                       || $self->pos_cmp($s1_pos, $s2_pos) != 0)
3371                                                     {
3372  ***      0                                  0         die "The servers aren't both stopped at the same position";
3373                                                     }
3374                                                  
3375                                                  }
3376                                                  
3377                                                  sub change_master_to {
3378  ***      0                    0             0      my ( $self, $dbh, $master_dsn, $master_pos ) = @_;
3379  ***      0                                  0      $self->stop_slave($dbh);
3380  ***      0                                  0      MKDEBUG && _d(Dumper($master_dsn), Dumper($master_pos));
3381  ***      0                                  0      my $sql = "CHANGE MASTER TO MASTER_HOST='$master_dsn->{h}', "
3382                                                        . "MASTER_PORT= $master_dsn->{P}, MASTER_LOG_FILE='$master_pos->{file}', "
3383                                                        . "MASTER_LOG_POS=$master_pos->{position}";
3384  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
3385  ***      0                                  0      $dbh->do($sql);
3386                                                  }
3387                                                  
3388                                                  sub make_sibling_of_master {
3389  ***      0                    0             0      my ( $self, $slave_dbh, $slave_dsn, $dsn_parser, $timeout) = @_;
3390                                                  
3391  ***      0      0                           0      my $master_dsn  = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3392                                                        or die "This server is not a slave";
3393  ***      0                                  0      my $master_dbh  = $dsn_parser->get_dbh(
3394                                                        $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
3395  ***      0      0                           0      my $gmaster_dsn
3396                                                        = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
3397                                                        or die "This server's master is not a slave";
3398  ***      0                                  0      my $gmaster_dbh = $dsn_parser->get_dbh(
3399                                                        $dsn_parser->get_cxn_params($gmaster_dsn), { AutoCommit => 1 });
3400  ***      0      0                           0      if ( $self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn) ) {
3401  ***      0                                  0         die "The slave's master's master is the slave: master-master replication";
3402                                                     }
3403                                                  
3404  ***      0                                  0      $self->stop_slave($master_dbh);
3405  ***      0                                  0      $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
3406  ***      0                                  0      $self->stop_slave($slave_dbh);
3407                                                  
3408  ***      0                                  0      my $master_status = $self->get_master_status($master_dbh);
3409  ***      0                                  0      my $mslave_status = $self->get_slave_status($master_dbh);
3410  ***      0                                  0      my $slave_status  = $self->get_slave_status($slave_dbh);
3411  ***      0                                  0      my $master_pos    = $self->repl_posn($master_status);
3412  ***      0                                  0      my $slave_pos     = $self->repl_posn($slave_status);
3413                                                  
3414  ***      0      0      0                    0      if ( !$self->slave_is_running($mslave_status)
      ***                    0                        
3415                                                       && !$self->slave_is_running($slave_status)
3416                                                       && $self->pos_cmp($master_pos, $slave_pos) == 0)
3417                                                     {
3418  ***      0                                  0         $self->change_master_to($slave_dbh, $gmaster_dsn,
3419                                                           $self->repl_posn($mslave_status)); # Note it's not $master_pos!
3420                                                     }
3421                                                     else {
3422  ***      0                                  0         die "The servers aren't both stopped at the same position";
3423                                                     }
3424                                                  
3425  ***      0                                  0      $mslave_status = $self->get_slave_status($master_dbh);
3426  ***      0                                  0      $slave_status  = $self->get_slave_status($slave_dbh);
3427  ***      0                                  0      my $mslave_pos = $self->repl_posn($mslave_status);
3428  ***      0                                  0      $slave_pos     = $self->repl_posn($slave_status);
3429  ***      0      0      0                    0      if ( $self->short_host($mslave_status) ne $self->short_host($slave_status)
3430                                                       || $self->pos_cmp($mslave_pos, $slave_pos) != 0)
3431                                                     {
3432  ***      0                                  0         die "The servers don't have the same master/position after the change";
3433                                                     }
3434                                                  }
3435                                                  
3436                                                  sub make_slave_of_sibling {
3437  ***      0                    0             0      my ( $self, $slave_dbh, $slave_dsn, $sib_dbh, $sib_dsn,
3438                                                          $dsn_parser, $timeout) = @_;
3439                                                  
3440  ***      0      0                           0      if ( $self->short_host($slave_dsn) eq $self->short_host($sib_dsn) ) {
3441  ***      0                                  0         die "You are trying to make the slave a slave of itself";
3442                                                     }
3443                                                  
3444  ***      0      0                           0      my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3445                                                        or die "This server is not a slave";
3446  ***      0                                  0      my $master_dbh1 = $dsn_parser->get_dbh(
3447                                                        $dsn_parser->get_cxn_params($master_dsn1), { AutoCommit => 1 });
3448  ***      0      0                           0      my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3449                                                        or die "The sibling is not a slave";
3450  ***      0      0                           0      if ( $self->short_host($master_dsn1) ne $self->short_host($master_dsn2) ) {
3451  ***      0                                  0         die "This server isn't a sibling of the slave";
3452                                                     }
3453  ***      0      0                           0      my $sib_master_stat = $self->get_master_status($sib_dbh)
3454                                                        or die "Binary logging is not enabled on the sibling";
3455  ***      0      0                           0      die "The log_slave_updates option is not enabled on the sibling"
3456                                                        unless $self->has_slave_updates($sib_dbh);
3457                                                  
3458  ***      0                                  0      $self->catchup_to_same_pos($slave_dbh, $sib_dbh);
3459                                                  
3460  ***      0                                  0      $sib_master_stat = $self->get_master_status($sib_dbh);
3461  ***      0                                  0      $self->change_master_to($slave_dbh, $sib_dsn,
3462                                                           $self->repl_posn($sib_master_stat));
3463                                                  
3464  ***      0                                  0      my $slave_status = $self->get_slave_status($slave_dbh);
3465  ***      0                                  0      my $slave_pos    = $self->repl_posn($slave_status);
3466  ***      0                                  0      $sib_master_stat = $self->get_master_status($sib_dbh);
3467  ***      0      0      0                    0      if ( $self->short_host($slave_status) ne $self->short_host($sib_dsn)
3468                                                       || $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
3469                                                     {
3470  ***      0                                  0         die "After changing the slave's master, it isn't a slave of the sibling, "
3471                                                           . "or it has a different replication position than the sibling";
3472                                                     }
3473                                                  }
3474                                                  
3475                                                  sub make_slave_of_uncle {
3476  ***      0                    0             0      my ( $self, $slave_dbh, $slave_dsn, $unc_dbh, $unc_dsn,
3477                                                          $dsn_parser, $timeout) = @_;
3478                                                  
3479  ***      0      0                           0      if ( $self->short_host($slave_dsn) eq $self->short_host($unc_dsn) ) {
3480  ***      0                                  0         die "You are trying to make the slave a slave of itself";
3481                                                     }
3482                                                  
3483  ***      0      0                           0      my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3484                                                        or die "This server is not a slave";
3485  ***      0                                  0      my $master_dbh = $dsn_parser->get_dbh(
3486                                                        $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
3487  ***      0      0                           0      my $gmaster_dsn
3488                                                        = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
3489                                                        or die "The master is not a slave";
3490  ***      0      0                           0      my $unc_master_dsn
3491                                                        = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
3492                                                        or die "The uncle is not a slave";
3493  ***      0      0                           0      if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn)) {
3494  ***      0                                  0         die "The uncle isn't really the slave's uncle";
3495                                                     }
3496                                                  
3497  ***      0      0                           0      my $unc_master_stat = $self->get_master_status($unc_dbh)
3498                                                        or die "Binary logging is not enabled on the uncle";
3499  ***      0      0                           0      die "The log_slave_updates option is not enabled on the uncle"
3500                                                        unless $self->has_slave_updates($unc_dbh);
3501                                                  
3502  ***      0                                  0      $self->catchup_to_same_pos($master_dbh, $unc_dbh);
3503  ***      0                                  0      $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
3504                                                  
3505  ***      0                                  0      my $slave_status  = $self->get_slave_status($slave_dbh);
3506  ***      0                                  0      my $master_status = $self->get_master_status($master_dbh);
3507  ***      0      0                           0      if ( $self->pos_cmp(
3508                                                           $self->repl_posn($slave_status),
3509                                                           $self->repl_posn($master_status)) != 0 )
3510                                                     {
3511  ***      0                                  0         die "The slave is not caught up to its master";
3512                                                     }
3513                                                  
3514  ***      0                                  0      $unc_master_stat = $self->get_master_status($unc_dbh);
3515  ***      0                                  0      $self->change_master_to($slave_dbh, $unc_dsn,
3516                                                        $self->repl_posn($unc_master_stat));
3517                                                  
3518                                                  
3519  ***      0                                  0      $slave_status    = $self->get_slave_status($slave_dbh);
3520  ***      0                                  0      my $slave_pos    = $self->repl_posn($slave_status);
3521  ***      0      0      0                    0      if ( $self->short_host($slave_status) ne $self->short_host($unc_dsn)
3522                                                       || $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
3523                                                     {
3524  ***      0                                  0         die "After changing the slave's master, it isn't a slave of the uncle, "
3525                                                           . "or it has a different replication position than the uncle";
3526                                                     }
3527                                                  }
3528                                                  
3529                                                  sub detach_slave {
3530  ***      0                    0             0      my ( $self, $dbh ) = @_;
3531  ***      0                                  0      $self->stop_slave($dbh);
3532  ***      0      0                           0      my $stat = $self->get_slave_status($dbh)
3533                                                        or die "This server is not a slave";
3534  ***      0                                  0      $dbh->do('CHANGE MASTER TO MASTER_HOST=""');
3535  ***      0                                  0      $dbh->do('RESET SLAVE'); # Wipes out master.info, etc etc
3536  ***      0                                  0      return $stat;
3537                                                  }
3538                                                  
3539                                                  sub slave_is_running {
3540  ***      0                    0             0      my ( $self, $slave_status ) = @_;
3541  ***      0             0                    0      return ($slave_status->{slave_sql_running} || 'No') eq 'Yes';
3542                                                  }
3543                                                  
3544                                                  sub has_slave_updates {
3545  ***      0                    0             0      my ( $self, $dbh ) = @_;
3546  ***      0                                  0      my $sql = q{SHOW VARIABLES LIKE 'log_slave_updates'};
3547  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
3548  ***      0                                  0      my ($name, $value) = $dbh->selectrow_array($sql);
3549  ***      0             0                    0      return $value && $value =~ m/^(1|ON)$/;
3550                                                  }
3551                                                  
3552                                                  sub repl_posn {
3553  ***      0                    0             0      my ( $self, $status ) = @_;
3554  ***      0      0      0                    0      if ( exists $status->{file} && exists $status->{position} ) {
3555                                                        return {
3556  ***      0                                  0            file     => $status->{file},
3557                                                           position => $status->{position},
3558                                                        };
3559                                                     }
3560                                                     else {
3561                                                        return {
3562  ***      0                                  0            file     => $status->{relay_master_log_file},
3563                                                           position => $status->{exec_master_log_pos},
3564                                                        };
3565                                                     }
3566                                                  }
3567                                                  
3568                                                  sub get_slave_lag {
3569          12                   12            80      my ( $self, $dbh ) = @_;
3570          12                                101      my $stat = $self->get_slave_status($dbh);
3571          12                                219      return $stat->{seconds_behind_master};
3572                                                  }
3573                                                  
3574                                                  sub pos_cmp {
3575  ***      0                    0             0      my ( $self, $a, $b ) = @_;
3576  ***      0                                  0      return $self->pos_to_string($a) cmp $self->pos_to_string($b);
3577                                                  }
3578                                                  
3579                                                  sub short_host {
3580  ***      0                    0             0      my ( $self, $dsn ) = @_;
3581  ***      0                                  0      my ($host, $port);
3582  ***      0      0                           0      if ( $dsn->{master_host} ) {
3583  ***      0                                  0         $host = $dsn->{master_host};
3584  ***      0                                  0         $port = $dsn->{master_port};
3585                                                     }
3586                                                     else {
3587  ***      0                                  0         $host = $dsn->{h};
3588  ***      0                                  0         $port = $dsn->{P};
3589                                                     }
3590  ***      0      0      0                    0      return ($host || '[default]') . ( ($port || 3306) == 3306 ? '' : ":$port" );
      ***                    0                        
3591                                                  }
3592                                                     
3593                                                  sub is_replication_thread {
3594  ***      0                    0             0      my ( $self, $query, $type ) = @_; 
3595  ***      0      0                           0      return unless $query;
3596                                                  
3597  ***      0             0                    0      $type ||= 'all';
3598  ***      0      0                           0      die "Invalid type: $type"
3599                                                        unless $type =~ m/binlog_dump|slave_io|slave_sql|all/i;
3600                                                  
3601  ***      0                                  0      my $match = 0;
3602  ***      0      0                           0      if ( $type =~ m/binlog_dump|all/i ) {
3603  ***      0      0      0                    0         $match = 1
      ***                    0                        
3604                                                           if ($query->{Command} || $query->{command} || '') eq "Binlog Dump";
3605                                                     }
3606  ***      0      0                           0      if ( !$match ) {
3607  ***      0      0      0                    0         if ( ($query->{User} || $query->{user} || '') eq "system user" ) {
      ***                    0                        
3608  ***      0             0                    0            my $state = $query->{State} || $query->{state} || '';
      ***                    0                        
3609  ***      0      0                           0            if ( $type =~ m/slave_io|all/i ) {
3610  ***      0                                  0               ($match) = $state =~ m/
3611                                                                 ^(Waiting\sfor\smaster\supdate
3612                                                                  |Connecting\sto\smaster
3613                                                                  |Waiting\sto\sreconnect\safter\sa\sfailed
3614                                                                  |Reconnecting\safter\sa\sfailed\sbinlog
3615                                                                  |Waiting\sfor\smaster\sto\ssend\sevent
3616                                                                  |Queueing\smaster\sevent\sto\sthe\srelay
3617                                                                  |Waiting\sto\sreconnect\safter\sa\sfailed
3618                                                                  |Reconnecting\safter\sa\sfailed\smaster
3619                                                                  |Waiting\sfor\sthe\sslave\sSQL\sthread)/xi;
3620                                                           }
3621  ***      0      0      0                    0            if ( !$match && $type =~ m/slave_sql|all/i ) {
3622  ***      0                                  0               ($match) = $state =~ m/
3623                                                                 ^(Waiting\sfor\sthe\snext\sevent
3624                                                                  |Reading\sevent\sfrom\sthe\srelay\slog
3625                                                                  |Has\sread\sall\srelay\slog;\swaiting
3626                                                                  |Making\stemp\sfile)/xi; 
3627                                                           }
3628                                                        }
3629                                                        else {
3630  ***      0                                  0            MKDEBUG && _d('Not system user');
3631                                                        }
3632                                                     }
3633  ***      0                                  0      MKDEBUG && _d($type, 'replication thread:', ($match ? 'yes' : 'no'),
3634                                                        '; match:', $match);
3635  ***      0                                  0      return $match;
3636                                                  }
3637                                                  
3638                                                  sub pos_to_string {
3639  ***      0                    0             0      my ( $self, $pos ) = @_;
3640  ***      0                                  0      my $fmt  = '%s/%020d';
3641  ***      0                                  0      return sprintf($fmt, @{$pos}{qw(file position)});
      ***      0                                  0   
3642                                                  }
3643                                                  
3644                                                  sub _d {
3645  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3646  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3647  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3648                                                          @_;
3649  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3650                                                  }
3651                                                  
3652                                                  1;
3653                                                  
3654                                                  # ###########################################################################
3655                                                  # End MasterSlave package
3656                                                  # ###########################################################################
3657                                                  
3658                                                  # ###########################################################################
3659                                                  # Daemon package 5266
3660                                                  # This package is a copy without comments from the original.  The original
3661                                                  # with comments and its test file can be found in the SVN repository at,
3662                                                  #   trunk/common/Daemon.pm
3663                                                  #   trunk/common/t/Daemon.t
3664                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
3665                                                  # ###########################################################################
3666                                                  
3667                                                  package Daemon;
3668                                                  
3669          27                   27           245   use strict;
              27                                 70   
              27                                190   
3670          27                   27           166   use warnings FATAL => 'all';
              27                                 69   
              27                                183   
3671                                                  
3672          27                   27           168   use POSIX qw(setsid);
              27                                 69   
              27                                195   
3673          27                   27           183   use English qw(-no_match_vars);
              27                                 76   
              27                                168   
3674                                                  
3675  ***     27            50     27           185   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 71   
              27                                419   
3676                                                  
3677                                                  sub new {
3678  ***      0                    0             0      my ( $class, %args ) = @_;
3679  ***      0                                  0      foreach my $arg ( qw(o) ) {
3680  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3681                                                     }
3682  ***      0                                  0      my $o = $args{o};
3683  ***      0      0                           0      my $self = {
      ***             0                               
3684                                                        o        => $o,
3685                                                        log_file => $o->has('log') ? $o->get('log') : undef,
3686                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
3687                                                     };
3688                                                  
3689  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
3690                                                  
3691  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
3692  ***      0                                  0      return bless $self, $class;
3693                                                  }
3694                                                  
3695                                                  sub daemonize {
3696  ***      0                    0             0      my ( $self ) = @_;
3697                                                  
3698  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
3699  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
3700  ***      0      0                           0      if ( $pid ) {
3701  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
3702  ***      0                                  0         exit;
3703                                                     }
3704                                                  
3705  ***      0                                  0      $self->{child} = 1;
3706                                                  
3707  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
3708  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
3709                                                  
3710  ***      0                                  0      $self->_make_PID_file();
3711                                                  
3712  ***      0                                  0      $OUTPUT_AUTOFLUSH = 1;
3713                                                  
3714  ***      0      0                           0      if ( -t STDIN ) {
3715  ***      0                                  0         close STDIN;
3716  ***      0      0                           0         open  STDIN, '/dev/null'
3717                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
3718                                                     }
3719                                                  
3720  ***      0      0                           0      if ( $self->{log_file} ) {
3721  ***      0                                  0         close STDOUT;
3722  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
3723                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
3724                                                  
3725  ***      0                                  0         close STDERR;
3726  ***      0      0                           0         open  STDERR, ">&STDOUT"
3727                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
3728                                                     }
3729                                                     else {
3730  ***      0      0                           0         if ( -t STDOUT ) {
3731  ***      0                                  0            close STDOUT;
3732  ***      0      0                           0            open  STDOUT, '>', '/dev/null'
3733                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
3734                                                        }
3735  ***      0      0                           0         if ( -t STDERR ) {
3736  ***      0                                  0            close STDERR;
3737  ***      0      0                           0            open  STDERR, '>', '/dev/null'
3738                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
3739                                                        }
3740                                                     }
3741                                                  
3742  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
3743  ***      0                                  0      return;
3744                                                  }
3745                                                  
3746                                                  sub check_PID_file {
3747  ***      0                    0             0      my ( $self, $file ) = @_;
3748  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
3749  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
3750  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
3751  ***      0                                  0         my $pid;
3752  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
3753  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
3754  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
3755  ***      0      0                           0         if ( $pid ) {
3756  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
3757  ***      0      0                           0            if ( $pid_is_alive ) {
3758  ***      0                                  0               die "The PID file $PID_file already exists "
3759                                                                 . " and the PID that it contains, $pid, is running";
3760                                                           }
3761                                                           else {
3762  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
3763                                                                 . "contains, $pid, is not running";
3764                                                           }
3765                                                        }
3766                                                        else {
3767  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
3768                                                              . "contain a PID";
3769                                                        }
3770                                                     }
3771                                                     else {
3772  ***      0                                  0         MKDEBUG && _d('No PID file');
3773                                                     }
3774  ***      0                                  0      return;
3775                                                  }
3776                                                  
3777                                                  sub make_PID_file {
3778  ***      0                    0             0      my ( $self ) = @_;
3779  ***      0      0                           0      if ( exists $self->{child} ) {
3780  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
3781                                                     }
3782  ***      0                                  0      $self->_make_PID_file();
3783  ***      0                                  0      $self->{rm_PID_file} = 1;
3784  ***      0                                  0      return;
3785                                                  }
3786                                                  
3787                                                  sub _make_PID_file {
3788  ***      0                    0             0      my ( $self ) = @_;
3789                                                  
3790  ***      0                                  0      my $PID_file = $self->{PID_file};
3791  ***      0      0                           0      if ( !$PID_file ) {
3792  ***      0                                  0         MKDEBUG && _d('No PID file to create');
3793  ***      0                                  0         return;
3794                                                     }
3795                                                  
3796  ***      0                                  0      $self->check_PID_file();
3797                                                  
3798  ***      0      0                           0      open my $PID_FH, '>', $PID_file
3799                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
3800  ***      0      0                           0      print $PID_FH $PID
3801                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
3802  ***      0      0                           0      close $PID_FH
3803                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
3804                                                  
3805  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
3806  ***      0                                  0      return;
3807                                                  }
3808                                                  
3809                                                  sub _remove_PID_file {
3810  ***      0                    0             0      my ( $self ) = @_;
3811  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
3812  ***      0      0                           0         unlink $self->{PID_file}
3813                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
3814  ***      0                                  0         MKDEBUG && _d('Removed PID file');
3815                                                     }
3816                                                     else {
3817  ***      0                                  0         MKDEBUG && _d('No PID to remove');
3818                                                     }
3819  ***      0                                  0      return;
3820                                                  }
3821                                                  
3822                                                  sub DESTROY {
3823  ***      0                    0             0      my ( $self ) = @_;
3824  ***      0      0      0                    0      $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
3825  ***      0                                  0      return;
3826                                                  }
3827                                                  
3828                                                  sub _d {
3829  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3830  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3831  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3832                                                          @_;
3833  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3834                                                  }
3835                                                  
3836                                                  1;
3837                                                  
3838                                                  # ###########################################################################
3839                                                  # End Daemon package
3840                                                  # ###########################################################################
3841                                                  
3842                                                  # ###########################################################################
3843                                                  # SchemaIterator package 5473
3844                                                  # This package is a copy without comments from the original.  The original
3845                                                  # with comments and its test file can be found in the SVN repository at,
3846                                                  #   trunk/common/SchemaIterator.pm
3847                                                  #   trunk/common/t/SchemaIterator.t
3848                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
3849                                                  # ###########################################################################
3850                                                  package SchemaIterator;
3851                                                  
3852          27                   27           194   use strict;
              27                                 64   
              27                                143   
3853          27                   27           171   use warnings FATAL => 'all';
              27                                 60   
              27                                146   
3854                                                  
3855          27                   27           188   use English qw(-no_match_vars);
              27                                 74   
              27                                140   
3856          27                   27           178   use Data::Dumper;
              27                                 69   
              27                                149   
3857                                                  $Data::Dumper::Indent    = 1;
3858                                                  $Data::Dumper::Sortkeys  = 1;
3859                                                  $Data::Dumper::Quotekeys = 0;
3860                                                  
3861  ***     27            50     27           170   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 90   
              27                                515   
3862                                                  
3863                                                  sub new {
3864          15                   15           105      my ( $class, %args ) = @_;
3865          15                                 65      foreach my $arg ( qw(Quoter) ) {
3866  ***     15     50                          95         die "I need a $arg argument" unless $args{$arg};
3867                                                     }
3868          15                                134      my $self = {
3869                                                        %args,
3870                                                        filter => undef,
3871                                                        dbs    => [],
3872                                                     };
3873          15                                160      return bless $self, $class;
3874                                                  }
3875                                                  
3876                                                  sub make_filter {
3877          15                   15            68      my ( $self, $o ) = @_;
3878          15                                 90      my @lines = (
3879                                                        'sub {',
3880                                                        '   my ( $dbh, $db, $tbl ) = @_;',
3881                                                        '   my $engine = undef;',
3882                                                     );
3883                                                  
3884                                                  
3885  ***     15     50                          92      my @permit_dbs = _make_filter('unless', '$db', $o->get('databases'))
3886                                                        if $o->has('databases');
3887  ***     15     50                          98      my @reject_dbs = _make_filter('if', '$db', $o->get('ignore-databases'))
3888                                                        if $o->has('ignore-databases');
3889          15                                 47      my @dbs_regex;
3890  ***     15     50     33                   70      if ( $o->has('databases-regex') && (my $p = $o->get('databases-regex')) ) {
3891  ***      0                                  0         push @dbs_regex, "      return 0 unless \$db && (\$db =~ m/$p/o);";
3892                                                     }
3893          15                                 49      my @reject_dbs_regex;
3894  ***     15     50     33                   64      if ( $o->has('ignore-databases-regex')
3895                                                          && (my $p = $o->get('ignore-databases-regex')) ) {
3896  ***      0                                  0         push @reject_dbs_regex, "      return 0 if \$db && (\$db =~ m/$p/o);";
3897                                                     }
3898  ***     15     50     33                  140      if ( @permit_dbs || @reject_dbs || @dbs_regex || @reject_dbs_regex ) {
      ***                   33                        
      ***                   33                        
3899  ***     15     50                         149         push @lines,
      ***            50                               
      ***            50                               
      ***            50                               
3900                                                           '   if ( $db ) {',
3901                                                              (@permit_dbs        ? @permit_dbs       : ()),
3902                                                              (@reject_dbs        ? @reject_dbs       : ()),
3903                                                              (@dbs_regex         ? @dbs_regex        : ()),
3904                                                              (@reject_dbs_regex  ? @reject_dbs_regex : ()),
3905                                                           '   }';
3906                                                     }
3907                                                  
3908  ***     15     50     33                   63      if ( $o->has('tables') || $o->has('ignore-tables')
      ***                   33                        
3909                                                          || $o->has('ignore-tables-regex') ) {
3910                                                  
3911          15                                 59         my $have_qtbl       = 0;
3912          15                                 47         my $have_only_qtbls = 0;
3913          15                                 37         my %qtbls;
3914                                                  
3915          15                                 39         my @permit_tbls;
3916          15                                 43         my @permit_qtbls;
3917          15                                 49         my %permit_qtbls;
3918          15    100                          71         if ( $o->get('tables') ) {
3919          14                                 42            my %tbls;
3920                                                           map {
3921  ***     14     50                         109               if ( $_ =~ m/\./ ) {
              14                                 59   
3922  ***      0                                  0                  $permit_qtbls{$_} = 1;
3923                                                              }
3924                                                              else {
3925          14                                 75                  $tbls{$_} = 1;
3926                                                              }
3927          14                                 47            } keys %{ $o->get('tables') };
3928          14                                 78            @permit_tbls  = _make_filter('unless', '$tbl', \%tbls);
3929          14                                 75            @permit_qtbls = _make_filter('unless', '$qtbl', \%permit_qtbls);
3930                                                  
3931  ***     14     50                          71            if ( @permit_qtbls ) {
3932  ***      0                                  0               push @lines,
3933                                                                 '   my $qtbl   = ($db ? "$db." : "") . ($tbl ? $tbl : "");';
3934  ***      0                                  0               $have_qtbl = 1;
3935                                                           }
3936                                                        }
3937                                                  
3938          15                                 47         my @reject_tbls;
3939          15                                 42         my @reject_qtbls;
3940          15                                 44         my %reject_qtbls;
3941  ***     15     50                          68         if ( $o->get('ignore-tables') ) {
3942  ***      0                                  0            my %tbls;
3943                                                           map {
3944  ***      0      0                           0               if ( $_ =~ m/\./ ) {
      ***      0                                  0   
3945  ***      0                                  0                  $reject_qtbls{$_} = 1;
3946                                                              }
3947                                                              else {
3948  ***      0                                  0                  $tbls{$_} = 1;
3949                                                              }
3950  ***      0                                  0            } keys %{ $o->get('ignore-tables') };
3951  ***      0                                  0            @reject_tbls= _make_filter('if', '$tbl', \%tbls);
3952  ***      0                                  0            @reject_qtbls = _make_filter('if', '$qtbl', \%reject_qtbls);
3953                                                  
3954  ***      0      0      0                    0            if ( @reject_qtbls && !$have_qtbl ) {
3955  ***      0                                  0               push @lines,
3956                                                                 '   my $qtbl   = ($db ? "$db." : "") . ($tbl ? $tbl : "");';
3957                                                           }
3958                                                        }
3959                                                  
3960  ***     15     50     33                   95         if ( keys %permit_qtbls  && !@permit_dbs ) {
3961  ***      0                                  0            my $dbs = {};
3962  ***      0                                  0            map {
3963  ***      0                                  0               my ($db, undef) = split(/\./, $_);
3964  ***      0                                  0               $dbs->{$db} = 1;
3965                                                           } keys %permit_qtbls;
3966  ***      0                                  0            MKDEBUG && _d('Adding restriction "--databases',
3967                                                                 (join(',', keys %$dbs) . '"'));
3968  ***      0      0                           0            if ( keys %$dbs ) {
3969  ***      0                                  0               $o->set('databases', $dbs);
3970  ***      0                                  0               return $self->make_filter($o);
3971                                                           }
3972                                                        }
3973                                                  
3974          15                                 44         my @tbls_regex;
3975  ***     15     50     33                   76         if ( $o->has('tables-regex') && (my $p = $o->get('tables-regex')) ) {
3976  ***      0                                  0            push @tbls_regex, "      return 0 unless \$tbl && (\$tbl =~ m/$p/o);";
3977                                                        }
3978          15                                 46         my @reject_tbls_regex;
3979  ***     15     50     33                   72         if ( $o->has('ignore-tables-regex')
3980                                                             && (my $p = $o->get('ignore-tables-regex')) ) {
3981  ***      0                                  0            push @reject_tbls_regex,
3982                                                              "      return 0 if \$tbl && (\$tbl =~ m/$p/o);";
3983                                                        }
3984                                                  
3985          15                                 43         my @get_eng;
3986          15                                 38         my @permit_engs;
3987          15                                 42         my @reject_engs;
3988  ***     15     50     66                   68         if ( ($o->has('engines') && $o->get('engines'))
      ***                   33                        
      ***                   66                        
3989                                                             || ($o->has('ignore-engines') && $o->get('ignore-engines')) ) {
3990          15                                116            push @get_eng,
3991                                                              '      my $sql = "SHOW TABLE STATUS "',
3992                                                              '              . ($db ? "FROM `$db`" : "")',
3993                                                              '              . " LIKE \'$tbl\'";',
3994                                                              '      MKDEBUG && _d($sql);',
3995                                                              '      eval {',
3996                                                              '         $engine = $dbh->selectrow_hashref($sql)->{engine};',
3997                                                              '      };',
3998                                                              '      MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);',
3999                                                              '      MKDEBUG && _d($tbl, "uses engine", $engine);',
4000                                                              '      $engine = lc $engine if $engine;',
4001                                                           @permit_engs
4002                                                              = _make_filter('unless', '$engine', $o->get('engines'), 1);
4003                                                           @reject_engs
4004          15                                 81               = _make_filter('if', '$engine', $o->get('ignore-engines'), 1)
4005                                                        }
4006                                                  
4007  ***     15     50     66                  247         if ( @permit_tbls || @reject_tbls || @tbls_regex || @reject_tbls_regex
      ***                   66                        
      ***                   66                        
      ***                   66                        
      ***                   33                        
4008                                                             || @permit_engs || @reject_engs ) {
4009          15    100                         309            push @lines,
      ***            50                               
      ***            50                               
      ***            50                               
      ***            50                               
      ***            50                               
      ***            50                               
                    100                               
      ***            50                               
4010                                                              '   if ( $tbl ) {',
4011                                                                 (@permit_tbls       ? @permit_tbls        : ()),
4012                                                                 (@reject_tbls       ? @reject_tbls        : ()),
4013                                                                 (@tbls_regex        ? @tbls_regex         : ()),
4014                                                                 (@reject_tbls_regex ? @reject_tbls_regex  : ()),
4015                                                                 (@permit_qtbls      ? @permit_qtbls       : ()),
4016                                                                 (@reject_qtbls      ? @reject_qtbls       : ()),
4017                                                                 (@get_eng           ? @get_eng            : ()),
4018                                                                 (@permit_engs       ? @permit_engs        : ()),
4019                                                                 (@reject_engs       ? @reject_engs        : ()),
4020                                                              '   }';
4021                                                        }
4022                                                     }
4023                                                  
4024          15                                 69      push @lines,
4025                                                        '   MKDEBUG && _d(\'Passes filters:\', $db, $tbl, $engine, $dbh);',
4026                                                        '   return 1;',  '}';
4027                                                  
4028          15                                116      my $code = join("\n", @lines);
4029          15                                 38      MKDEBUG && _d('filter sub:', $code);
4030  ***     15     50                        4114      my $filter_sub= eval $code
4031                                                        or die "Error compiling subroutine code:\n$code\n$EVAL_ERROR";
4032                                                  
4033          15                                139      return $filter_sub;
4034                                                  }
4035                                                  
4036                                                  sub set_filter {
4037          15                   15            70      my ( $self, $filter_sub ) = @_;
4038          15                                 65      $self->{filter} = $filter_sub;
4039          15                                 35      MKDEBUG && _d('Set filter sub');
4040          15                                 45      return;
4041                                                  }
4042                                                  
4043                                                  sub get_db_itr {
4044          15                   15            87      my ( $self, %args ) = @_;
4045          15                                 72      my @required_args = qw(dbh);
4046          15                                 71      foreach my $arg ( @required_args ) {
4047  ***     15     50                         100         die "I need a $arg argument" unless $args{$arg};
4048                                                     }
4049          15                                 72      my ($dbh) = @args{@required_args};
4050                                                  
4051          15                                 57      my $filter = $self->{filter};
4052          15                                 41      my @dbs;
4053          15                                 52      eval {
4054          15                                 45         my $sql = 'SHOW DATABASES';
4055          15                                 38         MKDEBUG && _d($sql);
4056  ***     67     50                         431         @dbs =  grep {
4057          15                                 39            my $ok = $filter ? $filter->($dbh, $_, undef) : 1;
4058          67    100                         446            $ok = 0 if $_ =~ m/information_schema|lost\+found/;
4059          67                                235            $ok;
4060          15                                 52         } @{ $dbh->selectcol_arrayref($sql) };
4061          15                                 71         MKDEBUG && _d('Found', scalar @dbs, 'databases');
4062                                                     };
4063          15                                 46      MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
4064                                                     return sub {
4065          30                   30           202         return shift @dbs;
4066          15                                155      };
4067                                                  }
4068                                                  
4069                                                  sub get_tbl_itr {
4070          15                   15           121      my ( $self, %args ) = @_;
4071          15                                 82      my @required_args = qw(dbh db);
4072          15                                 67      foreach my $arg ( @required_args ) {
4073  ***     30     50                         218         die "I need a $arg argument" unless $args{$arg};
4074                                                     }
4075          15                                 96      my ($dbh, $db, $views) = @args{@required_args, 'views'};
4076                                                  
4077          15                                 65      my $filter = $self->{filter};
4078          15                                 44      my @tbls;
4079  ***     15     50                          65      if ( $db ) {
4080          15                                 53         eval {
4081          15                                114            my $sql = 'SHOW /*!50002 FULL*/ TABLES FROM '
4082                                                                   . $self->{Quoter}->quote($db);
4083          15                                 39            MKDEBUG && _d($sql);
4084          15                                111            @tbls = map {
4085          91                               5015               $_->[0]
4086                                                           }
4087                                                           grep {
4088          15                                 34               my ($tbl, $type) = @$_;
4089  ***     91     50                         507               my $ok = $filter ? $filter->($dbh, $db, $tbl) : 1;
4090  ***     91     50                         378               if ( !$views ) {
4091  ***     91     50     50                  488                  $ok = 0 if ($type || '') eq 'VIEW';
4092                                                              }
4093          91                                293               $ok;
4094                                                           }
4095          15                                 55            @{ $dbh->selectall_arrayref($sql) };
4096          15                                259            MKDEBUG && _d('Found', scalar @tbls, 'tables in', $db);
4097                                                        };
4098          15                                 47         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
4099                                                     }
4100                                                     else {
4101  ***      0                                  0         MKDEBUG && _d('No db given so no tables');
4102                                                     }
4103                                                     return sub {
4104          30                   30           302         return shift @tbls;
4105          15                                182      };
4106                                                  }
4107                                                  
4108                                                  sub _make_filter {
4109          88                   88           432      my ( $cond, $var_name, $objs, $lc ) = @_;
4110          88                                240      my @lines;
4111          88    100                         437      if ( scalar keys %$objs ) {
4112          60    100                         421         my $test = join(' || ',
4113          45                                210            map { "$var_name eq '" . ($lc ? lc $_ : $_) ."'" } keys %$objs);
4114          45                                278         push @lines, "      return 0 $cond $var_name && ($test);",
4115                                                     }
4116          88                                466      return @lines;
4117                                                  }
4118                                                  
4119                                                  sub _d {
4120  ***      0                    0             0      my ($package, undef, $line) = caller 0;
4121  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
4122  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
4123                                                          @_;
4124  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4125                                                  }
4126                                                  
4127                                                  1;
4128                                                  
4129                                                  # ###########################################################################
4130                                                  # End SchemaIterator package
4131                                                  # ###########################################################################
4132                                                  
4133                                                  # ###########################################################################
4134                                                  # This is a combination of modules and programs in one -- a runnable module.
4135                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
4136                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
4137                                                  #
4138                                                  # Check at the end of this package for the call to main() which actually runs
4139                                                  # the program.
4140                                                  # ###########################################################################
4141                                                  package mk_table_checksum;
4142                                                  
4143          27                   27           221   use English qw(-no_match_vars);
              27                                 71   
              27                                237   
4144          27                   27           208   use List::Util qw(max maxstr);
              27                                 69   
              27                                166   
4145          27                   27           179   use Time::HiRes qw(gettimeofday sleep);
              27                                 69   
              27                                256   
4146          27                   27           174   use Data::Dumper;
              27                                 65   
              27                                141   
4147                                                  $Data::Dumper::Indent    = 0;
4148                                                  $Data::Dumper::Quotekeys = 0;
4149                                                  
4150  ***     27            50     27           169   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              27                                 65   
              27                                396   
4151                                                  
4152                                                  $OUTPUT_AUTOFLUSH = 1;
4153                                                  
4154                                                  # Global variables.
4155                                                  my $exit_status = 0;
4156                                                  my $checksum_table_data;
4157                                                  my ( $fetch_sth, $update_sth, $savesince_sth );
4158                                                  my ( $crc_wid, $md5sum_fmt );
4159                                                  my $already_checksummed;
4160                                                  # %tables_to_checksum has the following structure:
4161                                                  #    database => [
4162                                                  #       { table },
4163                                                  #       ...
4164                                                  #    ],
4165                                                  #    ...
4166                                                  my %tables_to_checksum;
4167                                                  
4168                                                  sub main {
4169          15                   15          8275      @ARGV = @_;  # set global ARGV for this package
4170                                                  
4171                                                     # Reset global vars else tests which run this tool as a module
4172                                                     # will have strange, overlapping results.
4173          15                                166      $exit_status                                = 0;
4174          15                                 58      $checksum_table_data                        = undef;
4175          15                                 86      ( $fetch_sth, $update_sth, $savesince_sth ) = (undef, undef, undef);
4176          15                                870      ( $crc_wid, $md5sum_fmt )                   = (undef, undef);
4177          15                                 60      $already_checksummed                        = undef;
4178          15                               2608      %tables_to_checksum                         = ();
4179                                                  
4180                                                  
4181                                                     # ########################################################################
4182                                                     # Get configuration information.
4183                                                     # ########################################################################
4184                                                     # Because of --arg-table, $final_o is the OptionParser obj used to get
4185                                                     # most options (see my $final_o below).
4186          15                                282      my $o = new OptionParser(
4187                                                        strict      => 0,
4188                                                        prompt      => '[OPTION...] DSN [DSN...]',
4189                                                        description => 'checksums MySQL tables efficiently on one or more hosts. '
4190                                                                     . ' Each host is specified as a DSN and missing values are '
4191                                                                     . 'inherited from the first host.  If you specify multiple '
4192                                                                     . 'hosts, the first is assumed to be the master.',
4193                                                     );
4194          15                                115      $o->get_specs();
4195          15                                403      $o->get_opts();
4196                                                  
4197          15                                116      my $dp = $o->DSNParser();
4198          15                                 95      $dp->prop('set-vars', $o->get('set-vars'));
4199                                                  
4200                                                     # This list contains all the command-line arguments that can be overridden
4201                                                     # by a table that contains arguments for each table to be checksummed.
4202                                                     # The long form of each argument is given.  The values are read from the
4203                                                     # POD by finding the magical token.
4204          15                                 52      my %overridable_args;
4205                                                     {
4206          15                                 49         my $para = $o->read_para_after(
              15                                281   
4207                                                           __FILE__, qr/MAGIC_overridable_args/);
4208          15                                601         foreach my $arg ( $para =~ m/([\w-]+)/g ) {
4209  ***    330     50                        1333            die "Magical argument $arg mentioned in POD is not a "
4210                                                              . "command-line argument" unless $o->has($arg);
4211         330                               1454            $overridable_args{$arg} = 1;
4212                                                        }
4213                                                     };
4214                                                  
4215                                                     # Post-process command-line options and arguments.
4216  ***     15     50                         109      $o->set('lock', 1)      if $o->get('wait');
4217          15    100                          76      $o->set('slave-lag', 1) if $o->get('lock');
4218                                                  
4219  ***     15     50                          83      if ( !@ARGV ) {
4220  ***      0                                  0         $o->save_error("No hosts specified.");
4221                                                     }
4222                                                  
4223          15                                 45      my @hosts; 
4224          15                                104      my $dsn_defaults = $dp->parse_options($o);
4225                                                     {
4226          15                                 55         foreach my $arg ( unique(@ARGV) ) {
              15                                125   
4227          15                                117            push @hosts, $dp->parse($arg, $hosts[0], $dsn_defaults);
4228                                                        }
4229                                                     }
4230                                                  
4231  ***     15     50                          83      if ( $o->get('explain-hosts') ) {
4232  ***      0                                  0         foreach my $host ( @hosts ) {
4233  ***      0                                  0            print "Server $host->{h}:\n   ", $dp->as_string($host), "\n";
4234                                                        }
4235  ***      0                                  0         return 0;
4236                                                     }
4237                                                  
4238                                                     # Checksumming table data is the normal operation. But if we're only to
4239                                                     # compare schemas, then we can skip a lot of work, like selecting an algo,
4240                                                     # replication stuff, etc.
4241  ***     15     50                          85      $checksum_table_data = $o->get('schema') ? 0 : 1;
4242                                                  
4243          15    100                          75      if ( $o->get('checksum') ) {
4244           7                                 42         $o->set('count', 0);
4245                                                     }
4246                                                  
4247          15    100                          70      if ( $o->get('explain') ) {
4248           1                                  7         @hosts = $hosts[0];
4249                                                     }
4250                                                  
4251                                                     # --replicate auto-enables --throttle unless user set --throttle explicitly.
4252  ***     15    100     66                   78      $o->set('throttle', 1) if $o->get('replicate') && !$o->got('throttle');
4253                                                  
4254  ***     15     50                          75      if ( !$o->get('help') ) {
4255  ***     15     50     33                   78         if ( $o->get('replicate-check') && !$o->get('replicate') ) {
4256  ***      0                                  0            $o->save_error("--replicate-check requires --replicate.");
4257                                                        }
4258  ***     15     50     33                   76         if ( $o->get('save-since') && !$o->get('arg-table') ) {
      ***            50     66                        
4259  ***      0                                  0            $o->save_error("--save-since requires --arg-table.");
4260                                                        }
4261                                                        elsif ( $o->get('replicate') && @hosts > 1 ) {
4262  ***      0                                  0            $o->save_error("You can only specify one host with --replicate.");
4263                                                        }
4264                                                  
4265  ***     15     50     33                   70         if ( $o->get('resume-replicate') && !$o->get('replicate') ) {
4266  ***      0                                  0            $o->save_error("--resume-replicate requires --replicate.");
4267                                                        }
4268  ***     15     50     33                   81         if ( $o->get('resume') && $o->get('replicate') ) {
4269  ***      0                                  0            $o->save_error('--resume does not work with --replicate.  '
4270                                                              . 'Use --resume-replicate instead.');
4271                                                        }
4272                                                  
4273  ***     15     50     66                   66         if ( $o->get('check-slave-lag') && !$o->get('throttle') ) {
4274                                                           # User specified --check-slave-lag DSN and --no-throttle.
4275                                                           # They probably meant just --check-slave-lag DSN.
4276  ***      0                                  0            $o->save_error('--no-throttle contradicts --check-slave-lag; '
4277                                                              . '--check-slave-lag alone limits --throttle to that slave');
4278                                                        }
4279  ***     15     50     66                   65         if ( $o->get('throttle') && !$o->get('replicate') ) {
4280                                                           # User did --throttle (explicitly) without --replicate.
4281  ***      0                                  0            $o->save_error('--throttle requires --replicate');
4282                                                        }
4283                                                     }
4284                                                  
4285          15                                117      $o->usage_or_errors();
4286                                                  
4287                                                     # ########################################################################
4288                                                     # If --pid, check it first since we'll die if it already exits.
4289                                                     # ########################################################################
4290          15                                 39      my $daemon;
4291  ***     15     50                          62      if ( $o->get('pid') ) {
4292                                                        # We're not daemoninzing, it just handles PID stuff.  Keep $daemon
4293                                                        # in the the scope of main() because when it's destroyed it automatically
4294                                                        # removes the PID file.
4295  ***      0                                  0         $daemon = new Daemon(o=>$o);
4296  ***      0                                  0         $daemon->make_PID_file();
4297                                                     }
4298                                                  
4299                                                     # ########################################################################
4300                                                     # Ready to work now.
4301                                                     # ########################################################################
4302          15                                191      my $q  = new Quoter();
4303          15                                136      my $vp = new VersionParser();
4304          15                                165      my $tp = new TableParser(Quoter => $q);
4305          15                                162      my $tc = new TableChecksum(Quoter=> $q, VersionParser => $vp);
4306          15                                250      my $ms = new MasterSlave(VersionParser => $vp);
4307          15                                144      my $du = new MySQLDump();
4308          15                                141      my $ch = new TableChunker(Quoter => $q, MySQLDump => $du); 
4309          15                                176      my %common_modules = (
4310                                                        ch => $ch,
4311                                                        dp => $dp,
4312                                                        du => $du,
4313                                                        o  => $o,
4314                                                        ms => $ms,
4315                                                        q  => $q,
4316                                                        tc => $tc,
4317                                                        tp => $tp,
4318                                                        vp => $vp,
4319                                                     );
4320                                                  
4321          15                                156      my $main_dbh = get_cxn($hosts[0], %common_modules);
4322                                                  
4323                                                     # #########################################################################
4324                                                     # Prepare --throttle.
4325                                                     # #########################################################################
4326          15                                 72      my @slaves;
4327          15    100                         116      if ( $o->get('throttle') ) {
4328           5    100                          26         if ( $o->get('check-slave-lag') ) {
4329           2                                  6            MKDEBUG && _d('Using --check-slave-lag DSN for --throttle');
4330                                                           # OptionParser can't auto-copy DSN vals from a cmd line DSN
4331                                                           # to an opt DSN, so we copy them manually.
4332           2                                 13            my $dsn = $dp->copy($hosts[0], $o->get('check-slave-lag'));
4333           2                                 20            push @slaves, { dsn=>$dsn, dbh=>get_cxn($dsn, %common_modules) };
4334                                                        }
4335                                                        else {
4336           3                                 10            MKDEBUG && _d('Recursing to slaves for --throttle');
4337                                                           $ms->recurse_to_slaves(
4338                                                              {  dbh        => $main_dbh,
4339                                                                 dsn        => $hosts[0],
4340                                                                 dsn_parser => $dp,
4341                                                                 recurse    => $o->get('recurse'),
4342                                                                 method     => $o->get('recursion-method'),
4343                                                                 callback   => sub {
4344           9                    9            66                     my ( $dsn, $dbh, $level, $parent ) = @_;
4345           9    100                          56                     return unless $level;
4346           6                                 18                     MKDEBUG && _d('--throttle slave:', $dp->as_string($dsn));
4347           6                                 47                     $dbh->{InactiveDestroy}  = 1; # Prevent destroying on fork.
4348           6                                 44                     $dbh->{FetchHashKeyName} = 'NAME_lc';
4349           6                                 70                     push @slaves, { dsn=>$dsn, dbh=>$dbh };
4350           6                                 25                     return;
4351                                                                 },
4352                                                              }
4353           3                                 25            );
4354                                                        }
4355                                                     }
4356                                                  
4357                                                     # ########################################################################
4358                                                     # Load --arg-table information.
4359                                                     # ########################################################################
4360          15                                 87      my %args_for;
4361  ***     15     50                          89      if ( my $arg_tbl = $o->get('arg-table') ) {
4362  ***      0                                  0         my %col_in_argtable;
4363  ***      0                                  0         my $rows = $main_dbh->selectall_arrayref(
4364                                                           "SELECT * FROM $arg_tbl", { Slice => {} });
4365  ***      0                                  0         foreach my $row ( @$rows ) {
4366  ***      0      0      0                    0            die "Invalid entry in --arg-table: db and tbl must be set"
4367                                                              unless $row->{db} && $row->{tbl};
4368  ***      0                                  0            $args_for{$row->{db}}->{$row->{tbl}} = {
4369  ***      0      0                           0               map  { $_ => $row->{$_} }
4370  ***      0                                  0               grep { $overridable_args{$_} && defined $row->{$_} }
4371                                                              keys %$row
4372                                                           };
4373  ***      0      0                           0            if ( !%col_in_argtable ) { # do only once
4374  ***      0                                  0               foreach my $key ( keys %$row ) {
4375  ***      0      0                           0                  next if $key =~ m/^(db|tbl|ts)$/;
4376  ***      0      0                           0                  die "Column $key (from $arg_tbl given by --arg-table) is not "
4377                                                                    . "an overridable argument" unless $overridable_args{$key};
4378  ***      0                                  0                  $col_in_argtable{$key} = 1;
4379                                                              }
4380                                                           }
4381                                                        }
4382  ***      0      0                           0         if ( $col_in_argtable{since} ) {
4383  ***      0                                  0            $savesince_sth = $main_dbh->prepare(
4384                                                             "UPDATE $arg_tbl SET since=COALESCE(?, NOW()) WHERE db=? AND tbl=?");
4385                                                        }
4386                                                     }
4387                                                  
4388                                                     # ########################################################################
4389                                                     # Check replication slaves if desired.  If only --replicate-check is given,
4390                                                     # then we will exit here.  If --recheck is also given, then we'll continue
4391                                                     # through the entire script but checksum only the inconsistent tables found
4392                                                     # here.
4393                                                     # ########################################################################
4394  ***     15     50                          82      if ( $o->get('replicate-check') ) {
4395  ***      0      0                           0         my $callback = $o->get('recheck')
4396                                                                     ? \&save_inconsistent_tbls
4397                                                                     : \&print_inconsistent_tbls;
4398                                                        $ms->recurse_to_slaves(
4399                                                           {  dbh        => $main_dbh,
4400                                                              dsn        => $hosts[0],
4401                                                              dsn_parser => $dp,
4402                                                              recurse    => $o->get('replicate-check'),
4403                                                              callback   => sub {
4404  ***      0                    0             0                  my ( $dsn, $dbh, $level, $parent ) = @_;
4405  ***      0                                  0                  my @tbls = $tc->find_replication_differences(
4406                                                                    $dbh, $o->get('replicate'));
4407  ***      0      0                           0                  return unless @tbls;
4408  ***      0                                  0                  $exit_status = 1;
4409                                                                 # Call the callback that does something useful with
4410                                                                 # the inconsistent tables.
4411                                                                 # o dbh db tbl args_for
4412  ***      0                                  0                  $callback->(
4413                                                                    dsn      => $dsn,
4414                                                                    dbh      => $dbh,
4415                                                                    level    => $level,
4416                                                                    parent   => $parent,
4417                                                                    tbls     => \@tbls,
4418                                                                    args_for => \%args_for,
4419                                                                    %common_modules
4420                                                                 );
4421                                                              },
4422  ***      0                                  0               method => $o->get('recursion-method'),
4423                                                           }
4424                                                        );
4425  ***      0      0                           0         return $exit_status unless $o->get('recheck');
4426                                                     }
4427                                                  
4428                                                     # ########################################################################
4429                                                     # Otherwise get ready to checksum table data, unless we have only to check
4430                                                     # schemas in which case we can skip all such work, knowing already that we
4431                                                     # will use CRC32.
4432                                                     # ########################################################################
4433  ***     15     50                          76      if ( $checksum_table_data ) {
4434                                                        # Verify that CONCAT_WS is compatible across all servers. On older
4435                                                        # versions of MySQL it skips both empty strings and NULL; on newer
4436                                                        # just NULL.
4437  ***     15     50     33                   76         if ( $o->get('verify') && @hosts > 1 ) {
4438  ***      0                                  0            verify_checksum_compat(hosts=>\@hosts, %common_modules);
4439                                                        }
4440                                                  
4441          15                                173         ($fetch_sth, $update_sth)
4442                                                           = check_repl_table(dbh=>$main_dbh, %common_modules);
4443                                                     }
4444                                                     else {
4445  ***      0                                  0         $crc_wid = 16; # Wider than the widest CRC32.
4446                                                     } 
4447                                                  
4448                                                     # ########################################################################
4449                                                     # If resuming a previous run, figure out what the previous run finished.
4450                                                     # ######################################################################## 
4451  ***     15     50     66                   90      if ( $o->get('replicate') && $o->get('resume-replicate') ) {
      ***            50                               
4452  ***      0                                  0         $already_checksummed = read_repl_table(
4453                                                           dbh  => $main_dbh,
4454                                                           host => $hosts[0]->{h},
4455                                                           %common_modules,
4456                                                        );
4457                                                     } 
4458                                                     elsif ( $o->get('resume') ) {
4459  ***      0                                  0         $already_checksummed = parse_resume_file($o->get('resume'));
4460                                                     }
4461                                                  
4462                                                     # ########################################################################
4463                                                     # Iterate through databases and tables and do the checksums.
4464                                                     # ########################################################################
4465                                                  
4466                                                     # Get table info for all hosts, all slaves, unless we're in the special
4467                                                     # "repl-re-check" mode in which case %tables_to_checksum has already the
4468                                                     # inconsistent tables that we need to re-checksum.
4469                                                     get_all_tbls_info(
4470  ***     15     50     33                   78         dbh      => $main_dbh,
4471                                                        args_for => \%args_for,
4472                                                        %common_modules,
4473                                                     ) unless ($o->get('replicate-check') && $o->get('recheck'));
4474                                                  
4475                                                     # Finally, checksum the tables.
4476          15                                123      foreach my $database ( keys %tables_to_checksum ) {
4477          15                                 71         my $tables = $tables_to_checksum{$database};
4478          15                                165         checksum_tables(
4479                                                           dbh     => $main_dbh,
4480                                                           db      => $database,
4481                                                           tbls    => $tables,
4482                                                           hosts   => \@hosts,
4483                                                           slaves  => \@slaves, 
4484                                                           %common_modules
4485                                                        );
4486                                                     }
4487                                                  
4488          15                               7762      return $exit_status;
4489                                                  }
4490                                                  
4491                                                  # ############################################################################
4492                                                  # Subroutines
4493                                                  # ############################################################################
4494                                                  
4495                                                  sub get_all_tbls_info {
4496          15                   15           508      my ( %args ) = @_;
4497          15                                117      foreach my $arg ( qw(o dbh q tp du ch args_for) ) {
4498  ***    105     50                         475         die "I need a $arg argument" unless $args{$arg};
4499                                                     }
4500          15                                 58      my $o      = $args{o};
4501          15                                 55      my $dbh    = $args{dbh};
4502                                                  
4503          15                                210      my $si = new SchemaIterator(
4504                                                        Quoter => $args{q},
4505                                                     );
4506          15                                111      $si->set_filter($si->make_filter($o));
4507                                                  
4508          15                                 94      my $next_db = $si->get_db_itr(dbh => $dbh);
4509          15                                 75      while ( my $db = $next_db->() ) {
4510          15                                116         my $next_tbl = $si->get_tbl_itr(
4511                                                           dbh   => $dbh,
4512                                                           db    => $db,
4513                                                           views => 0,
4514                                                        );
4515          15                                 73         while ( my $tbl = $next_tbl->() ) {
4516          15                                 41            MKDEBUG && _d("Examining", $db, '.', $tbl);
4517          15                                202            my $final_o = get_final_opts(
4518                                                              %args,
4519                                                              db  => $db,
4520                                                              tbl => $tbl,
4521                                                           );
4522          15                                147            save_tbl_to_checksum(
4523                                                              %args,
4524                                                              db      => $db,
4525                                                              tbl     => $tbl,
4526                                                              final_o => $final_o,
4527                                                           );
4528                                                        }
4529                                                     }
4530                                                  
4531          15                                788      return;
4532                                                  }
4533                                                  
4534                                                  sub save_tbl_to_checksum {
4535          15                   15           167      my ( %args ) = @_;
4536          15                                111      foreach my $arg ( qw(q ch du final_o tp dbh db tbl du tp ch vp) ) {
4537  ***    180     50                         790         die "I need a $arg argument" unless $args{$arg};
4538                                                     }
4539          15                                 63      my $du      = $args{du};
4540          15                                 52      my $tp      = $args{tp};
4541          15                                 52      my $ch      = $args{ch};
4542          15                                 50      my $final_o = $args{final_o};
4543          15                                 49      my $dbh     = $args{dbh};
4544          15                                 57      my $db      = $args{db};
4545          15                                 51      my $tbl     = $args{tbl};
4546          15                                 51      my $q       = $args{q};
4547          15                                 49      my $vp      = $args{vp};
4548                                                  
4549                                                     # Skip the table in which checksums are stored.
4550  ***     15     50     66                   63      return if ($final_o->get('replicate')
4551                                                        && $final_o->get('replicate') eq "$db.$tbl");
4552                                                  
4553          15                                 49      eval { # Catch errors caused by tables being dropped during work.
4554                                                  
4555                                                        # Parse the table and determine a column that's chunkable.  This is
4556                                                        # used not only for chunking, but also for --since.
4557          15                                121         my $create        = $du->get_create_table($dbh, $q, $db, $tbl);
4558          15                                114         my $struct        = $tp->parse($create);
4559          15                                152         my ( $col, $idx ) = $ch->get_first_chunkable_column(tbl_struct=>$struct);
4560                                                  
4561  ***     15     50                          93         $idx = undef if $final_o->get('no-use-index');
4562          15    100                          68         if ( $idx ) {
4563  ***     13     50                          89            my $hint = $vp->version_ge($dbh, '4.0.9') ? 'FORCE' : 'USE';
4564          13                                 79            $idx     = "$hint INDEX (" . $q->quote($idx) . ")";
4565                                                        }
4566          15                                 39         MKDEBUG && _d('Index hint:', $idx);
4567                                                  
4568          15                                 61         my @chunks = '1=1'; # Default.
4569          15                                 50         my $maxval = undef;
4570  ***     15     50                          81         if ( $args{given_chunks} ) {
4571  ***      0                                  0            @chunks = @{$args{given_chunks}};
      ***      0                                  0   
4572                                                        }
4573                                                        else {      
4574  ***     15     50     33                  189            if ( $final_o->get('chunk-size') && $col ) {
4575  ***      0                                  0               my $rows_per_chunk = $ch->size_to_rows(
4576                                                                 dbh        => $dbh,
4577                                                                 db         => $db,
4578                                                                 tbl        => $tbl,
4579                                                                 chunk_size => $final_o->get('chunk-size'),
4580                                                              );
4581                                                  
4582                                                              # Calculate chunks for this table.
4583  ***      0                                  0               my %params = $ch->get_range_statistics(
4584                                                                 dbh       => $dbh,
4585                                                                 db        => $db,
4586                                                                 tbl       => $tbl,
4587                                                                 chunk_col => $col
4588                                                              );
4589  ***      0      0                           0               if ( !grep { !defined $params{$_} } qw(min max rows_in_range) ) {
      ***      0                                  0   
4590  ***      0                                  0                  @chunks = $ch->calculate_chunks(
4591                                                                    dbh        => $dbh,
4592                                                                    tbl_struct => $struct,
4593                                                                    chunk_col  => $col,
4594                                                                    chunk_size => $rows_per_chunk,
4595                                                                    %params,
4596                                                                 );
4597  ***      0                                  0                  $maxval = $params{max};
4598                                                              }
4599                                                           }
4600                                                        }
4601                                                  
4602          15                                 44         push @{ $tables_to_checksum{$db} }, {
              15                                247   
4603                                                           struct   => $struct,
4604                                                           create   => $create,
4605                                                           database => $db,
4606                                                           table    => $tbl,
4607                                                           column   => $col,
4608                                                           maxval   => $maxval,
4609                                                           index    => $idx,
4610                                                           chunks   => \@chunks,
4611                                                           final_o  => $final_o,
4612                                                        };
4613                                                     };
4614  ***     15     50                          70      if ( $EVAL_ERROR ) {
4615  ***      0                                  0         print_err($final_o, $EVAL_ERROR, $db, $tbl);
4616                                                     }
4617                                                  
4618          15                                192      return;
4619                                                  }
4620                                                  
4621                                                  # Checksum the tables in the given database.
4622                                                  # A separate report for each database and its tables is printed.
4623                                                  sub checksum_tables {
4624          15                   15           190      my ( %args ) = @_;
4625          15                                103      foreach my $arg ( qw(tc du o q db dbh hosts tbls) ) {
4626  ***    120     50                         589         die "I need a $arg argument" unless $args{$arg};
4627                                                     }
4628          15                                 60      my $tc    = $args{tc};
4629          15                                 53      my $du    = $args{du};
4630          15                                 50      my $o     = $args{o};
4631          15                                 56      my $db    = $args{db};
4632          15                                 50      my $dbh   = $args{dbh};
4633          15                                 55      my $hosts = $args{hosts};
4634          15                                 49      my $tbls  = $args{tbls};
4635          15                                 46      my $q     = $args{q};
4636                                                  
4637          15                                 52      my ($hdr, $explain);
4638                                                  
4639                                                     # NOTE: remember, you can't 'next TABLE' inside the eval{}.
4640                                                     # NOTE: remember to use the final_o embedded within each $table, not $o
4641          15                                 59      foreach my $table ( @$tbls ) {
4642          15                                 45         eval {
4643          15                                 61            my $final_o  = $table->{final_o};
4644          15                                 43            my $do_table = 1;
4645          15                                 40            MKDEBUG && _d("Doing", $db, '.', $table->{table});
4646          15                                 39            MKDEBUG && _d("Table:", Dumper($table));
4647                                                  
4648                                                           # Determine the checksum strategy for every table because it
4649                                                           # might change given various --arg-table opts for each table.
4650          15                                 43            my $strat_ref;
4651          15                                 55            my ( $strat, $crc_type, $func, $opt_slice );
4652  ***     15     50     33                  184            if ( $checksum_table_data && $do_table ) {
4653          15                                123               $strat_ref = determine_checksum_strat(
4654                                                                 dbh => $dbh,
4655                                                                 tc  => $tc,
4656                                                                 o   => $final_o,
4657                                                              );
4658          15                                124               ( $strat, $crc_wid, $crc_type, $func, $opt_slice )
4659                                                                 = @$strat_ref{ qw(strat crc_wid crc_type func opt_slice) };
4660          15                                 52               MKDEBUG && _d("Checksum strat:", Dumper($strat_ref));
4661                                                           }
4662                                                           else {
4663                                                              # --schema doesn't use a checksum strategy, but do_tbl()
4664                                                              # requires a start arg.
4665  ***      0                                  0               $strat = '--schema';
4666                                                           }
4667          15                                 81            $md5sum_fmt = "%-${crc_wid}s  %s.%s.%s.%d\n";
4668                                                  
4669                                                           # Design and print header unless we are resuming in which case
4670                                                           # we should have already re-printed the partial output of the
4671                                                           # resume file in parse_resume_file().  This only has to be done
4672                                                           # once and done here because we need $crc_wid which is determined
4673                                                           # by the checksum strat above.
4674  ***     15     50                          95            if ( !$hdr ) {
4675  ***     15     50                          71               if ( $o->get('tab') ) {
4676  ***      0                                  0                  $hdr = "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n";
4677  ***      0                                  0                  $explain = "%s\t%s\t%s\n";
4678                                                              }
4679                                                              else {
4680          15                                 72                  my $max_tbl  = max(5, map { length($_->{table}) } @$tbls);
              15                                133   
4681          15                                 71                  my $max_db   = max(8, length($db));
4682          15                                 67                  my $max_host = max(4, map { length($_->{h}) } @$hosts);
              15                                 88   
4683          15                                111                  $hdr         = "%-${max_db}s %-${max_tbl}s %5s "
4684                                                                              . "%-${max_host}s %-6s %10s %${crc_wid}s %4s %4s %4s %4s\n";
4685          15                                 79                  $explain     = "%-${max_db}s %-${max_tbl}s %s\n";
4686                                                              }
4687          15                                134               my @hdr_args = qw(DATABASE TABLE CHUNK HOST ENGINE
4688                                                                                COUNT CHECKSUM TIME WAIT STAT LAG);
4689          15    100    100                   63               unless ( $o->get('quiet')
                           100                        
      ***                   66                        
4690                                                                       || $o->get('explain')
4691                                                                       || $o->get('checksum')
4692                                                                       || $o->get('resume') )
4693                                                              {
4694  ***      2     50                          49                  printf($hdr, @hdr_args)
4695                                                                    or die "Cannot print: $OS_ERROR";
4696                                                              }
4697                                                           }
4698                                                  
4699                                                           # Clean out the replication table entry for this table.
4700  ***     15    100     66                   68            if ( (my $replicate_table = $final_o->get('replicate'))
4701                                                                && !$final_o->get('explain') ) {
4702           5                                 25               my $del_sql = "DELETE FROM $replicate_table WHERE db=? AND tbl=?";
4703           5                                 15               MKDEBUG && _d($dbh, $del_sql, $db, $table->{table});
4704           5                               1468               $dbh->do($del_sql, {}, $db, $table->{table});
4705                                                           }
4706                                                  
4707                                                           # If --since is given, figure out either
4708                                                           # 1) for temporal sinces, if the table has an update time and that
4709                                                           #    time is newer than --since, then checksum the whole table,
4710                                                           #    otherwise skip it; or
4711                                                           # 2) for "numerical" sinces, which column to use: either the
4712                                                           #    specified column (--sincecolumn) or the auto-discovered one,
4713                                                           #    whichever exists in the table, in that order.
4714                                                           # Then, if --savesince is given, save either 1) the current timestamp
4715                                                           # or 2) the resulting WHERE clause.
4716  ***     15     50                          83            if ( $final_o->get('since') ) {
4717  ***      0      0                           0               if ( is_temporal($final_o->get('since')) ) {
4718  ***      0                                  0                  MKDEBUG && _d('--since is temporal');
4719  ***      0                                  0                  my ( $stat )
4720                                                                    = $du->get_table_status($dbh, $q, $db, $table->{table});
4721  ***      0                                  0                  my $time = $stat->{update_time};
4722  ***      0      0      0                    0                  if ( $time && $time lt $final_o->get('since') ) {
4723  ***      0                                  0                     MKDEBUG && _d("Skipping table because --since value",
4724                                                                       $final_o->get('since'), "is newer than", $time);
4725  ***      0                                  0                     $do_table = 0;
4726  ***      0                                  0                     $table->{chunks} = [];
4727                                                                 }
4728                                                              }
4729                                                              else {
4730  ***      0                                  0                  MKDEBUG && _d('--since is numerical');
4731                                                                 # For numerical sinces, choose the column to apply --since to.
4732                                                                 # It may not be the column the user said to use! If the user
4733                                                                 # didn't specify a column that's good to chunk on, we'll use
4734                                                                 # something else instead.
4735                                                  
4736                                                                 # $table->{column} is the first chunkable column returned from
4737                                                                 # the call to get_first_chunkable_column() in
4738                                                                 # save_tbl_to_checksum().
4739  ***      0      0                           0                  my ( $sincecol ) =
4740  ***      0                                  0                     grep { $_ && $table->{struct}->{is_col}->{$_} }
4741                                                                       ( $table->{column}, $final_o->get('since-column') );
4742                                                  
4743  ***      0      0                           0                  if ( $sincecol ) {
4744  ***      0                                  0                     MKDEBUG && _d('Column for numerical --since:',
4745                                                                       $db, '.', $table->{table}, '.', $sincecol);
4746                                                                    # This ends up being an additional WHERE clause.
4747  ***      0                                  0                     $table->{since} = $q->quote($sincecol)
4748                                                                       . '>=' .  $q->quote_val($final_o->get('since'));
4749                                                                 }
4750                                                                 else {
4751  ***      0                                  0                     MKDEBUG && _d('No column for numerical --since for',
4752                                                                       $db, '.', $table->{table});
4753                                                                 }
4754                                                              }
4755                                                           }
4756                                                  
4757                                                           # ##################################################################
4758                                                           # The query is independent of the chunk, so I make it once for every
4759                                                           # one.
4760                                                           # ##################################################################
4761          15                                 53            my $query;
4762  ***     15     50     33                  149            if ( $checksum_table_data && $do_table ) {
4763          15                                126               $query = $tc->make_checksum_query(
4764                                                                 db              => $db,
4765                                                                 tbl             => $table->{table},
4766                                                                 tbl_struct      => $table->{struct},
4767                                                                 algorithm       => $strat,
4768                                                                 function        => $func,
4769                                                                 crc_wid         => $crc_wid,
4770                                                                 crc_type        => $crc_type,
4771                                                                 opt_slice       => $opt_slice,
4772                                                                 cols            => $final_o->get('columns'),
4773                                                                 sep             => $final_o->get('separator'),
4774                                                                 replicate       => $final_o->get('replicate'),
4775                                                                 float_precision => $final_o->get('float-precision'),
4776                                                                 trim            => $final_o->get('trim'),
4777                                                                 ignorecols      => $final_o->get('ignore-columns'),
4778                                                              );
4779                                                           }
4780                                                           else { # --schema
4781  ***      0                                  0               $query = undef;
4782                                                           }
4783                                                  
4784          15                                178            checksum_chunks(
4785                                                              %args,
4786                                                              tbl     => $table,
4787                                                              query   => $query,
4788                                                              hdr     => $hdr,
4789                                                              explain => $explain,
4790                                                              final_o => $final_o,
4791                                                              strat   => $strat,
4792                                                           );
4793                                                  
4794                                                           # Save the --since value if
4795                                                           #    1) it's temporal and the tbl had changed since --since; or
4796                                                           #    2) it's "numerical" and it had a chunkable or nibble-able
4797                                                           #       column and it wasn't empty
4798                                                           # See issues 121 and 122.
4799  ***     13     50     33                   88            if ( $final_o->get('save-since') && $savesince_sth ) {
4800  ***      0      0                           0               if ( is_temporal($final_o->get('since')) ) {
      ***             0                               
4801  ***      0                                  0                  MKDEBUG && _d(
4802                                                                    "Saving temporal --since value: current timestamp for",
4803                                                                    $db, '.', $table->{table});
4804  ***      0                                  0                  $savesince_sth->execute(undef,
4805                                                                    $db, $table->{table});
4806                                                              }
4807                                                              elsif ( defined $table->{maxval} ) {
4808  ***      0                                  0                  MKDEBUG && _d("Saving numerical --since value:",
4809                                                                    $table->{maxval}, "for", $db, '.', $table->{table});
4810  ***      0                                  0                  $savesince_sth->execute($table->{maxval},
4811                                                                    $db, $table->{table});
4812                                                              }
4813                                                              else {
4814  ***      0                                  0                  MKDEBUG && _d("Cannot save --since value:",
4815                                                                    $table->{maxval}, "for", $db, '.', $table->{table});
4816                                                              }
4817                                                           }
4818                                                        };
4819          15    100                         131         if ( $EVAL_ERROR ) {
4820           2                                 47            print_err($o, $EVAL_ERROR, $db, $table->{table});
4821                                                        }
4822                                                     }
4823                                                  
4824          15                                197      return;
4825                                                  }
4826                                                  
4827                                                  sub checksum_chunks {
4828          15                   15           257      my ( %args ) = @_;
4829          15                                122      foreach my $arg ( qw(dp final_o ms o q db tbl hosts hdr explain) ) {
4830  ***    150     50                         658         die "I need a $arg argument" unless $args{$arg};
4831                                                     }
4832          15                                 64      my $dp      = $args{dp};
4833          15                                 52      my $du      = $args{du};
4834          15                                 56      my $final_o = $args{final_o};
4835          15                                 49      my $ms      = $args{ms};
4836          15                                 51      my $o       = $args{o};
4837          15                                 45      my $q       = $args{q};
4838          15                                 54      my $db      = $args{db};
4839          15                                 49      my $dbh     = $args{dbh};
4840          15                                 44      my @hosts   = @{$args{hosts}};
              15                                 75   
4841          15                                 50      my $tbl     = $args{tbl}; 
4842                                                  
4843                                                     # ##################################################################
4844                                                     # This loop may seem suboptimal, because it causes a new child to be
4845                                                     # forked for each table, for each host, for each chunk.  It also
4846                                                     # causes the program to parallelize only within the chunk; that is,
4847                                                     # no two child processes are running on different chunks at a time.
4848                                                     # This is by design. It lets me unlock the table on the master
4849                                                     # between chunks.
4850                                                     # ##################################################################
4851          15                                 39      my $num_chunks = scalar(@{$tbl->{chunks}});
              15                                 66   
4852          15                                 44      MKDEBUG && _d('Checksumming', $num_chunks, 'chunks');
4853                                                     CHUNK:
4854          15                                 94      foreach my $chunk_num ( 0 .. $num_chunks - 1 ) {
4855                                                  
4856          15    100                          70         if ( $o->get('throttle') ) {
4857           5                                 30            wait_for_slaves(
4858                                                              slaves         => $args{slaves},
4859                                                              max_lag        => $o->get('max-lag'),
4860                                                              check_interval => $o->get('check-interval'),
4861                                                              DSNParser      => $dp,
4862                                                              MasterSlave    => $ms,
4863                                                           );
4864                                                        }
4865                                                  
4866  ***     13     50     33                  138         if (    ($num_chunks > 1 || $final_o->get('single-chunk'))
      ***                   33                        
      ***                   33                        
      ***                   33                        
4867                                                             && $checksum_table_data
4868                                                             && defined $final_o->get('probability')
4869                                                             && rand(100) >= $final_o->get('probability') ) {
4870  ***      0                                  0            MKDEBUG && _d('Skipping chunk because of --probability');
4871  ***      0                                  0            next CHUNK;
4872                                                        }
4873                                                  
4874  ***     13     50     33                  129         if (    $num_chunks > 1
      ***                   33                        
      ***                   33                        
4875                                                             && $checksum_table_data
4876                                                             && $final_o->get('modulo')
4877                                                             && ($chunk_num % $final_o->get('modulo') != $final_o->get('offset')))
4878                                                        {
4879  ***      0                                  0            MKDEBUG && _d('Skipping chunk', $chunk_num, 'because of --modulo');
4880  ***      0                                  0            next CHUNK;
4881                                                        }
4882                                                  
4883          13                                157         my $chunk_start_time = gettimeofday();
4884          13                                 40         MKDEBUG && _d('Starting chunk', $chunk_num, 'at', $chunk_start_time);
4885                                                  
4886          13    100                          61         if ( $final_o->get('replicate') ) {
4887                                                           # We're in --replicate mode.
4888                                                  
4889                                                           # If resuming, check if this db.tbl.chunk.host can be skipped.
4890  ***      3     50                          17            if ( $o->get('resume-replicate') ) {
4891  ***      0      0                           0               if ( already_checksummed($tbl->{database},
4892                                                                                       $tbl->{table},
4893                                                                                       $chunk_num,
4894                                                                                       $hosts[0]->{h}) ) {
4895  ***      0      0                           0                  print "# already checksummed:"
4896                                                                    . " $tbl->{database}"
4897                                                                    . " $tbl->{table}"
4898                                                                    . " $chunk_num "
4899                                                                    . $hosts[0]->{h} 
4900                                                                    . "\n"
4901                                                                    unless $o->get('quiet');
4902  ***      0                                  0                  next CHUNK;
4903                                                              }
4904                                                           }
4905                                                  
4906  ***      3            33                   38            $hosts[0]->{dbh} ||= $dbh;
4907                                                  
4908           3                                 61            do_tbl_replicate(
4909                                                              $chunk_num,
4910                                                              %args,
4911                                                              host => $hosts[0],
4912                                                           );
4913                                                        }
4914                                                        else {
4915                                                           # We're in "normal" mode. Lock table and get position on the master.
4916                                                  
4917          10    100                          44            if ( !$final_o->get('explain') ) {
4918           9    100                          38               if ( $final_o->get('lock') ) {
4919           1                                  5                  my $sql = "LOCK TABLES "
4920                                                                         . $q->quote($db, $tbl->{table}) . " READ";
4921           1                                  3                  MKDEBUG && _d($sql);
4922           1                                113                  $dbh->do($sql);
4923                                                              }
4924  ***      9     50                          38               if ( $final_o->get('wait') ) {
4925  ***      0                                  0                  $tbl->{master_status} = $ms->get_master_status($dbh);
4926                                                              }
4927                                                           }
4928                                                  
4929          10                                 34            my %children;
4930                                                           HOST:
4931          10                                 79            foreach my $i ( 0 .. $#hosts ) {
4932          10                                 36               my $is_master = $i == 0; # First host is assumed to be master.
4933          10                                 31               my $host      = $hosts[$i];
4934                                                  
4935                                                              # Open a single connection for each host.  Re-use the
4936                                                              # connection for the master/single host.
4937  ***     10     50                          39               if ( $is_master ) {
4938          10                                117                  $dbh->{InactiveDestroy} = 1;  # Ensure that this is set.
4939  ***     10            33                   98                  $host->{dbh} ||= $dbh;
4940                                                              }
4941                                                              else {
4942  ***      0             0                    0                  $host->{dbh} ||= get_cxn($host, %args);
4943                                                              }
4944                                                  
4945                                                              # If resuming, check if this db.tbl.chunk.host can be skipped.
4946  ***     10     50                          47               if ( $final_o->get('resume') ) {
4947  ***      0      0                           0                  next HOST if already_checksummed($tbl->{database},
4948                                                                                                  $tbl->{table},
4949                                                                                                  $chunk_num,
4950                                                                                                  $host->{h});
4951                                                              }
4952                                                  
4953                                                              # Fork, but only if there's more than one host.
4954  ***     10     50                          50               my $pid = @hosts > 1 ? fork() : undef;
4955                                                  
4956  ***     10     50      0                   57               if ( @hosts == 1 || (defined($pid) && $pid == 0) ) {
      ***             0     33                        
      ***                    0                        
4957                                                                 # Do the work (I'm a child, or there's only one host)
4958                                                                 
4959          10                                 40                  eval {
4960          10                                108                     do_tbl(
4961                                                                       $chunk_num,
4962                                                                       $is_master,
4963                                                                       %args,
4964                                                                       dbh  => $host->{dbh},
4965                                                                       host => $host,
4966                                                                    );
4967                                                                 };
4968  ***     10     50                          61                  if ( $EVAL_ERROR ) {
4969  ***      0                                  0                     print_err($o, $EVAL_ERROR, $db, $tbl->{table},
4970                                                                              $dp->as_string($host));
4971  ***      0      0                           0                     exit(1) if @hosts > 1; # exit only if I'm a child
4972                                                                 }
4973                                                                 
4974  ***     10     50                          55                  exit(0) if @hosts > 1; # exit only if I'm a child
4975                                                              }
4976                                                              elsif ( @hosts > 1 && !defined($pid) ) {
4977  ***      0                                  0                  die("Unable to fork!");
4978                                                              }
4979                                                              
4980                                                              # I already exited if I'm a child, so I'm the parent.
4981  ***     10     50                          68               $children{$host->{h}} = $pid if @hosts > 1;
4982                                                           }
4983                                                  
4984                                                           # Wait for the children to exit.
4985          10                                 54            foreach my $host ( keys %children ) {
4986  ***      0                                  0               my $pid = waitpid($children{$host}, 0);
4987  ***      0                                  0               MKDEBUG && _d("Child", $pid, "exited with", $CHILD_ERROR);
4988  ***      0             0                    0               $exit_status ||= $CHILD_ERROR >> 8;
4989                                                           }
4990  ***     10    100     66                   45            if ( ($final_o->get('lock') && !$final_o->get('explain')) ) {
4991           1                                  4               my $sql = "UNLOCK TABLES";
4992           1                                  2               MKDEBUG && _d($dbh, $sql);
4993           1                                 89               $dbh->do($sql);
4994                                                           }
4995                                                        }
4996                                                  
4997          13                                110         my $chunk_stop_time = gettimeofday();
4998          13                                 35         MKDEBUG && _d('Finished chunk at', $chunk_stop_time);
4999                                                  
5000  ***     13     50     33                   64         if ( $final_o->get('sleep') && !$final_o->get('explain') ) {
      ***            50     33                        
5001  ***      0                                  0            MKDEBUG && _d('Sleeping', $final_o->get('sleep'));
5002  ***      0                                  0            sleep($final_o->get('sleep'));
5003                                                        }
5004                                                        elsif ( $final_o->get('sleep-coef') && !$final_o->get('explain') ) {
5005  ***      0                                  0            my $sleep_time
5006                                                              = ($chunk_stop_time - $chunk_start_time)
5007                                                              * $final_o->get('sleep-coef');
5008  ***      0                                  0            MKDEBUG && _d('Sleeping', $sleep_time);
5009  ***      0      0                           0            if ( $sleep_time < 0 ) {
5010  ***      0                                  0               warn "Calculated invalid sleep time: "
5011                                                                 . "$sleep_time = ($chunk_stop_time - $chunk_start_time) * "
5012                                                                 . $final_o->get('sleep-coef')
5013                                                                 . ". Sleep time set to 1 second instead.";
5014  ***      0                                  0               $sleep_time = 1;
5015                                                           }
5016  ***      0                                  0            sleep($sleep_time);
5017                                                        }
5018                                                     } # End foreach CHUNK
5019                                                  
5020          13                                134      return;
5021                                                  }
5022                                                  
5023                                                  # Override the command-line arguments with those from --arg-table
5024                                                  # if necessary.  Returns a cloned OptionParser object ($final_o).
5025                                                  # This clone is only a partial OptionParser object.
5026                                                  sub get_final_opts {
5027          15                   15           188      my ( %args ) = @_;
5028          15                                118      foreach my $arg ( qw(o dbh db tbl args_for) ) {
5029  ***     75     50                         356         die "I need a $arg argument" unless $args{$arg};
5030                                                     }
5031          15                                 57      my $o        = $args{o};
5032          15                                 52      my $dbh      = $args{dbh};
5033          15                                 53      my $db       = $args{db};
5034          15                                 51      my $tbl      = $args{tbl};
5035          15                                 55      my $args_for = $args{args_for};
5036                                                  
5037          15                                100      my $final_o = $o->clone();
5038  ***     15     50                         110      if ( my $override = $args_for->{$db}->{$tbl} ) {
5039  ***      0                                  0         map { $final_o->set($_, $override->{$_}); } keys %$override;
      ***      0                                  0   
5040                                                     }
5041                                                  
5042                                                     # --since and --offset are potentially expressions that should be
5043                                                     # evaluated by the DB server. This has to be done after the override
5044                                                     # from the --arg-table table.
5045          15                                 63      foreach my $opt ( qw(since offset) ) {
5046                                                        # Don't get MySQL to evaluate if it's temporal, as 2008-08-01 --> 1999
5047          30                                155         my $val = $final_o->get($opt);
5048  ***     30     50     33                  191         if ( $val && !is_temporal($val) ) {
5049  ***      0                                  0            $final_o->set($opt, eval_expr($opt, $val, $dbh));
5050                                                        }
5051                                                     }
5052                                                  
5053          15                                102      return $final_o;
5054                                                  }
5055                                                  
5056                                                  sub is_temporal {
5057  ***      0                    0             0      my ( $val ) = @_;
5058  ***      0             0                    0      return $val && $val =~ m/^\d{4}-\d{2}-\d{2}(?:.[0-9:]+)?/;
5059                                                  }
5060                                                  
5061                                                  sub print_inconsistent_tbls {
5062  ***      0                    0             0      my ( %args ) = @_;
5063  ***      0                                  0      foreach my $arg ( qw(o dp dsn tbls) ) {
5064  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
5065                                                     }
5066  ***      0                                  0      my $o      = $args{o};
5067  ***      0                                  0      my $dp     = $args{dp};
5068  ***      0                                  0      my $dsn    = $args{dsn};
5069  ***      0                                  0      my $tbls   = $args{tbls};
5070                                                  
5071  ***      0      0                           0      return if $o->get('quiet');
5072                                                  
5073  ***      0                                  0      my @headers = qw(db tbl chunk cnt_diff crc_diff boundaries);
5074  ***      0                                  0      print "Differences on " . $dp->as_string($dsn, [qw(h P F)]) . "\n";
5075  ***      0                                  0      my $max_db   = max(5, map { length($_->{db})  } @$tbls);
      ***      0                                  0   
5076  ***      0                                  0      my $max_tbl  = max(5, map { length($_->{tbl}) } @$tbls);
      ***      0                                  0   
5077  ***      0                                  0      my $fmt      = "%-${max_db}s %-${max_tbl}s %5s %8s %8s %s\n";
5078  ***      0      0                           0      printf($fmt, map { uc } @headers) or die "Cannot print: $OS_ERROR";
      ***      0                                  0   
5079  ***      0                                  0      foreach my $tbl ( @$tbls ) {
5080  ***      0      0                           0         printf($fmt, @{$tbl}{@headers}) or die "Cannot print: $OS_ERROR";
      ***      0                                  0   
5081                                                     }
5082  ***      0      0                           0      print "\n" or die "Cannot print: $OS_ERROR";
5083                                                  
5084  ***      0                                  0      return;
5085                                                  }
5086                                                  
5087                                                  sub save_inconsistent_tbls {
5088  ***      0                    0             0      my ( %args ) = @_;
5089  ***      0                                  0      foreach my $arg ( qw(dbh tbls) ) {
5090  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
5091                                                     }
5092  ***      0                                  0      my $dbh  = $args{dbh};
5093  ***      0                                  0      my $tbls = $args{tbls};
5094                                                  
5095  ***      0                                  0      foreach my $tbl ( @$tbls ) {
5096  ***      0                                  0         MKDEBUG && _d("Will recheck", $tbl->{db}, '.', $tbl->{tbl},
5097                                                                      "(chunk:", $tbl->{boundaries}, ')');
5098  ***      0                                  0         my $final_o = get_final_opts(
5099                                                           %args,
5100                                                           db  => $tbl->{db},
5101                                                           tbl => $tbl->{tbl},
5102                                                        );
5103  ***      0                                  0         my $chunks = [ $tbl->{boundaries} ];
5104  ***      0                                  0         save_tbl_to_checksum(
5105                                                           %args,
5106                                                           db      => $tbl->{db},
5107                                                           tbl     => $tbl->{tbl},
5108                                                           final_o => $final_o,
5109                                                        );
5110                                                     }
5111  ***      0                                  0      return;
5112                                                  }
5113                                                  
5114                                                  # The value may be an expression like 'NOW() - INTERVAL 7 DAY'
5115                                                  # and we should evaluate it.
5116                                                  sub eval_expr {
5117  ***      0                    0             0      my ( $name, $val, $dbh ) = @_;
5118  ***      0                                  0      my $result = $val;
5119  ***      0                                  0      eval {
5120  ***      0                                  0         ($result) = $dbh->selectrow_array("SELECT $val");
5121  ***      0                                  0         MKDEBUG && _d("option", $name, "evaluates to:", $result);
5122                                                     };
5123  ***      0      0      0                    0      if ( $EVAL_ERROR && MKDEBUG ) {
5124  ***      0                                  0         chomp $EVAL_ERROR;
5125  ***      0                                  0         _d("Error evaluating option", $name, $EVAL_ERROR);
5126                                                     }
5127  ***      0                                  0      return $result;
5128                                                  }
5129                                                  
5130                                                  sub determine_checksum_strat {
5131          15                   15            92      my ( %args ) = @_;
5132          15                                 77      foreach my $arg ( qw(o dbh tc) ) {
5133  ***     45     50                         236         die "I need a $arg argument" unless $args{$arg};
5134                                                     }
5135          15                                 56      my $o   = $args{o};
5136          15                                 60      my $dbh = $args{dbh};
5137          15                                 52      my $tc  = $args{tc};
5138                                                  
5139          15                                133      my $ret = {  # return vals in easy-to-swallow hash form
5140                                                        strat      => undef,
5141                                                        crc_type   => 'varchar',
5142                                                        crc_wid    => 16,
5143                                                        func       => undef,
5144                                                        opt_slice  => undef,
5145                                                     };
5146                                                  
5147  ***     15            33                   77      $ret->{strat} = $tc->best_algorithm(
5148                                                        algorithm   => $o->get('algorithm'),
5149                                                        dbh         => $dbh,
5150                                                        where       => $o->get('where') || $o->get('since'),
5151                                                        chunk       => $o->get('chunk-size'),
5152                                                        replicate   => $o->get('replicate'),
5153                                                        count       => $o->get('count'),
5154                                                     );
5155                                                  
5156  ***     15     50     66                   76      if ( $o->get('algorithm') && $o->get('algorithm') ne $ret->{strat} ) {
5157  ***      0                                  0         warn "--algorithm=".$o->get('algorithm')." can't be used; "
5158                                                           . "falling back to $ret->{strat}\n";
5159                                                     }
5160                                                  
5161                                                     # If using a cryptographic hash strategy, decide what hash function to use,
5162                                                     # and if using BIT_XOR whether and which slice to place the user variable in.
5163          15    100                          99      if ( $tc->is_hash_algorithm( $ret->{strat} ) ) {
5164          12                                 61         $ret->{func} = $tc->choose_hash_func(
5165                                                           function => $o->get('function'),
5166                                                           dbh      => $dbh,
5167                                                        );
5168  ***     12     50     66                   69         if ( $o->get('function') && $o->get('function') ne $ret->{func} ) {
5169  ***      0                                  0            warn "Checksum function ".$o->get('function')." cannot be used; "
5170                                                              . "using $ret->{func}\n";
5171                                                        }
5172          12                                 97         $ret->{crc_wid}    = $tc->get_crc_wid($dbh, $ret->{func});
5173          12                                 87         ($ret->{crc_type}) = $tc->get_crc_type($dbh, $ret->{func});
5174                                                  
5175          12    100    100                   69         if ( $o->get('optimize-xor') && $ret->{strat} eq 'BIT_XOR' ) {
5176           7    100                          69            if ( $ret->{crc_type} !~ m/int$/ ) {
5177           2                                 18               $ret->{opt_slice}
5178                                                                 = $tc->optimize_xor(dbh => $dbh, function => $ret->{func});
5179  ***      2     50                          14               if ( !defined $ret->{opt_slice} ) {
5180  ***      0                                  0                  warn "Cannot use --optimize-xor, disabling";
5181  ***      0                                  0                  $o->set('optimize-xor', 0);
5182                                                              }
5183                                                           }
5184                                                           else {
5185                                                              # FNV_64 doesn't need the optimize_xor gizmo.
5186           5                                 25               $o->get('optimize-xor', 0);
5187                                                           }
5188                                                        }
5189                                                     }
5190                                                  
5191          15                                 87      return $ret;
5192                                                  }
5193                                                  
5194                                                  sub verify_checksum_compat {
5195  ***      0                    0             0      my ( %args ) = @_;
5196  ***      0                                  0      foreach my $arg ( qw(o hosts) ) {
5197  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
5198                                                     }
5199  ***      0                                  0      my $o     = $args{o};
5200  ***      0                                  0      my $hosts = $args{hosts};
5201                                                  
5202  ***      0                                  0      my @verify_sums;
5203  ***      0                                  0      foreach my $host ( @$hosts ) {
5204  ***      0                                  0         my $dbh = get_cxn($host, %args);
5205  ***      0                                  0         my $sql = "SELECT MD5(CONCAT_WS(',', '1', ''))";
5206  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
5207  ***      0                                  0         my $cks = $dbh->selectall_arrayref($sql)->[0]->[0];
5208  ***      0                                  0         push @verify_sums, {
5209                                                           host => $host->{h},
5210                                                           ver  => $dbh->{mysql_serverinfo},
5211                                                           sum  => $cks,
5212                                                        };
5213                                                     }
5214  ***      0      0                           0      if ( unique(map { $_->{sum} } @verify_sums ) > 1 ) {
      ***      0                                  0   
5215  ***      0                                  0         my $max = max(map { length($_->{h}) } @$hosts);
      ***      0                                  0   
5216  ***      0                                  0         die "Not all servers have compatible versions.  Some return different\n"
5217                                                           . "checksum values for the same query, and cannot be compared.  This\n"
5218                                                           . "behavior changed in MySQL 4.0.14.  Here is info on each host:\n\n"
5219                                                           . join("\n",
5220  ***      0                                  0                 map { sprintf("%-${max}s %-32s %s", @{$_}{qw(host sum ver)}) }
      ***      0                                  0   
5221                                                                   { host => 'HOST', sum => 'CHECKSUM', ver => 'VERSION'},
5222                                                                @verify_sums
5223                                                             )
5224                                                           . "\n\nYou can disable this check with --no-verify.\n";
5225                                                     }
5226  ***      0                                  0      return;
5227                                                  }
5228                                                  
5229                                                  # Check for existence and privileges on the replication table before
5230                                                  # starting, and prepare the statements that will be used to update it.
5231                                                  # Also clean out the checksum table.  And create it if needed.
5232                                                  # Returns fetch and update statement handles.
5233                                                  sub check_repl_table {
5234          15                   15           153      my ( %args ) = @_;
5235          15                                101      foreach my $arg ( qw(o dbh tp q) ) {
5236  ***     60     50                         292         die "I need a $arg argument" unless $args{$arg};
5237                                                     }
5238          15                                 64      my $o   = $args{o};
5239          15                                 57      my $dbh = $args{dbh};
5240          15                                 52      my $tp  = $args{tp};
5241          15                                 52      my $q   = $args{q};
5242                                                  
5243          15                                 67      my $replicate_table = $o->get('replicate');
5244          15    100                         100      return unless $replicate_table;
5245                                                  
5246                                                     # Check that the replicate table exists and that we can access it.
5247           5                                 38      my ($db, $tbl) = $q->split_unquote($replicate_table);
5248           5                                 56      my $tbl_exists = $tp->check_table(
5249                                                        dbh => $dbh,
5250                                                        db  => $db,
5251                                                        tbl => $tbl,
5252                                                     );
5253                                                  
5254  ***      5     50                          24      if ( !$tbl_exists ) {
5255  ***      0      0                           0         if ( $o->get('create-replicate-table') ) {
5256  ***      0      0                           0            create_repl_table(%args)
5257                                                              or die "--create-replicate-table failed to create "
5258                                                                 . $replicate_table;
5259                                                        }
5260                                                        else {
5261  ***      0                                  0            die  "--replicate table $replicate_table does not exist; "
5262                                                              . "read the documentation or use --create-replicate-table "
5263                                                              . "to create it.";
5264                                                        }
5265                                                     }
5266                                                     else {
5267           5                                 16         MKDEBUG && _d('--replicate table', $replicate_table, 'already exists');
5268                                                        # Check it again but this time check the privs.
5269           5                                 36         my $have_tbl_privs = $tp->check_table(
5270                                                           dbh       => $dbh,
5271                                                           db        => $db,
5272                                                           tbl       => $tbl,
5273                                                           all_privs => 1,
5274                                                        );
5275  ***      5     50                          28         die "User does not have all necessary privileges on $replicate_table"
5276                                                           unless $have_tbl_privs;
5277                                                     }
5278                                                  
5279                                                     # Clean out the replicate table globally.
5280  ***      5     50                          39      if ( $o->get('empty-replicate-table') ) {
5281           5                                 26         my $del_sql = "DELETE FROM $replicate_table";
5282           5                                 12         MKDEBUG && _d($dbh, $del_sql);
5283           5                               1106         $dbh->do($del_sql);
5284                                                     }
5285                                                  
5286           5                                 14      my $fetch_sth = $dbh->prepare(
5287                                                        "SELECT this_crc, this_cnt FROM $replicate_table "
5288                                                        . "WHERE db = ? AND tbl = ? AND chunk = ?");
5289           5                                 11      my $update_sth = $dbh->prepare(
5290                                                        "UPDATE $replicate_table SET master_crc = ?, master_cnt = ? "
5291                                                        . "WHERE db = ? AND tbl = ? AND chunk = ?");
5292                                                  
5293           5                                 66      return ($fetch_sth, $update_sth);
5294                                                  }
5295                                                  
5296                                                  # Returns 1 on successful creation of the replicate table,
5297                                                  # or 0 on failure.
5298                                                  sub create_repl_table {
5299  ***      0                    0             0      my ( %args ) = @_;
5300  ***      0                                  0      foreach my $arg ( qw(o dbh) ) {
5301  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
5302                                                     }
5303  ***      0                                  0      my $o   = $args{o};
5304  ***      0                                  0      my $dbh = $args{dbh};
5305                                                  
5306  ***      0                                  0      my $replicate_table = $o->get('replicate');
5307                                                  
5308  ***      0                                  0      my $sql = $o->read_para_after(
5309                                                        __FILE__, qr/MAGIC_create_replicate/);
5310  ***      0                                  0      $sql =~ s/CREATE TABLE checksum/CREATE TABLE $replicate_table/;
5311  ***      0                                  0      $sql =~ s/;$//;
5312  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
5313  ***      0                                  0      eval {
5314  ***      0                                  0         $dbh->do($sql);
5315                                                     };
5316  ***      0      0                           0      if ( $EVAL_ERROR ) {
5317  ***      0                                  0         MKDEBUG && _d('--create-replicate-table failed:', $EVAL_ERROR);
5318  ***      0                                  0         return 0;
5319                                                     }
5320                                                  
5321  ***      0                                  0      return 1;
5322                                                  }
5323                                                  
5324                                                  sub read_repl_table {
5325  ***      0                    0             0      my ( %args ) = @_;
5326  ***      0                                  0      foreach my $arg ( qw(o dbh host) ) {
5327  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
5328                                                     }
5329  ***      0                                  0      my $o    = $args{o};
5330  ***      0                                  0      my $dbh  = $args{dbh};
5331  ***      0                                  0      my $host = $args{host};
5332                                                  
5333  ***      0                                  0      my $replicate_table = $o->get('replicate');
5334  ***      0      0                           0      die "Cannot read replicate table because --replicate was not specified"
5335                                                        unless $replicate_table;
5336                                                  
5337                                                     # Read checksums from replicate table.
5338  ***      0                                  0      my $already_checksummed;
5339  ***      0                                  0      my $checksums
5340                                                        = $dbh->selectall_arrayref("SELECT db, tbl, chunk FROM $replicate_table");
5341                                                  
5342                                                     # Save each finished checksum.
5343  ***      0                                  0      foreach my $checksum ( @$checksums ) {
5344  ***      0                                  0         my ( $db, $tbl, $chunk ) = @$checksum[0..2];
5345  ***      0                                  0         $already_checksummed->{$db}->{$tbl}->{$chunk}->{$host} = 1;
5346                                                     }
5347                                                  
5348  ***      0                                  0      return $already_checksummed;
5349                                                  }
5350                                                  
5351                                                  sub parse_resume_file {
5352  ***      0                    0             0      my ( $resume_file ) = @_;
5353                                                  
5354  ***      0      0                           0      open my $resume_fh, '<', $resume_file
5355                                                        or die "Cannot open resume file $resume_file: $OS_ERROR";
5356                                                  
5357                                                     # The resume file, being the output from a previous run, should
5358                                                     # have the columns DATABASE TABLE CHUNK HOST ... (in that order).
5359                                                     # We only need those first 4 columns. We re-print every line of
5360                                                     # the resume file so the end result will be the whole, finished
5361                                                     # output: what the previous run got done plus what we are about
5362                                                     # to resume and finish.
5363  ***      0                                  0      my $already_checksummed;
5364  ***      0                                  0      while ( my $line = <$resume_fh> ) {
5365                                                        # Re-print every line.
5366  ***      0                                  0         print $line;
5367                                                  
5368                                                        # If the line is a checksum line, parse from it the db, tbl,
5369                                                        # checksum and host.
5370  ***      0      0                           0         if ( $line =~ m/^\S+\s+\S+\s+\d+\s+/ ) {
5371  ***      0                                  0            my ( $db, $tbl, $chunk, $host ) = $line =~ m/(\S+)/g;
5372  ***      0                                  0            $already_checksummed->{$db}->{$tbl}->{$chunk}->{$host} = 1;
5373                                                        }
5374                                                     }
5375                                                  
5376  ***      0                                  0      close $resume_fh;
5377  ***      0                                  0      MKDEBUG && _d("Already checksummed:", Dumper($already_checksummed));
5378                                                  
5379  ***      0                                  0      return $already_checksummed;
5380                                                  }
5381                                                  
5382                                                  sub already_checksummed {
5383  ***      0                    0             0      my ( $d, $t, $c, $h ) = @_; # db, tbl, chunk num, host
5384  ***      0      0                           0      if ( exists $already_checksummed->{$d}->{$t}->{$c}->{$h} ) {
5385  ***      0                                  0         MKDEBUG && _d("Skipping chunk because of --resume:", $d, $t, $c, $h);
5386  ***      0                                  0         return 1;
5387                                                     }
5388  ***      0                                  0      return 0;
5389                                                  }
5390                                                  
5391                                                  sub do_tbl_replicate {
5392           3                    3            69      my ( $chunk_num, %args ) = @_;
5393           3                                 40      foreach my $arg ( qw(q host query tbl hdr explain final_o ch) ) {
5394  ***     24     50                         153         die "I need a $arg argument" unless $args{$arg};
5395                                                     }
5396           3                                 21      my $ch      = $args{ch};
5397           3                                 14      my $final_o = $args{final_o};
5398           3                                 12      my $q       = $args{q};
5399           3                                 14      my $host    = $args{host};
5400           3                                 14      my $hdr     = $args{hdr};
5401           3                                 14      my $explain = $args{explain};
5402           3                                 14      my $tbl     = $args{tbl};
5403                                                  
5404           3                                  9      MKDEBUG && _d('Replicating chunk', $chunk_num,
5405                                                        'of table', $tbl->{database}, '.', $tbl->{table},
5406                                                        'on', $host->{h}, ':', $host->{P});
5407                                                  
5408           3                                 19      my $dbh = $host->{dbh};
5409           3                                 26      $dbh->do("USE " . $q->quote($tbl->{database}));
5410                                                  
5411           3                                 20      my $cnt = 'NULL';
5412           3                                 13      my $crc = 'NULL';
5413           3                                 24      my $beg = time();
5414           3                                 42      my $sql = $ch->inject_chunks(
5415                                                        query      => $args{query},
5416                                                        database   => $tbl->{database},
5417                                                        table      => $tbl->{table},
5418                                                        chunks     => $tbl->{chunks},
5419                                                        chunk_num  => $chunk_num,
5420                                                        where      => [$final_o->get('where'), $tbl->{since}],
5421                                                        index_hint => $tbl->{index},
5422                                                     );
5423                                                  
5424           3                                 11      if ( MKDEBUG && $chunk_num == 0 ) {
5425                                                        _d("SQL for inject chunk 0:", $sql);
5426                                                     }
5427                                                  
5428           3                                 22      my $where = $tbl->{chunks}->[$chunk_num];
5429  ***      3     50                          17      if ( $final_o->get('explain') ) {
5430  ***      0      0                           0         if ( $chunk_num == 0 ) {
5431  ***      0      0                           0            printf($explain, @{$tbl}{qw(database table)}, $sql)
      ***      0                                  0   
5432                                                              or die "Cannot print: $OS_ERROR";
5433                                                        }
5434  ***      0      0                           0         printf($explain, @{$tbl}{qw(database table)}, $where)
      ***      0                                  0   
5435                                                           or die "Cannot print: $OS_ERROR";
5436  ***      0                                  0         return;
5437                                                     }
5438                                                  
5439                                                     # Actually run the checksum query
5440           3                                481      $dbh->do('SET @crc := "", @cnt := 0 /*!50108 , '
5441                                                            . '@@binlog_format := "STATEMENT"*/');
5442           3                                 24      $dbh->do($sql, {}, @{$tbl}{qw(database table)}, $where);
               3                               1683   
5443                                                  
5444                                                     # Catch any warnings thrown....
5445           3                                 30      my $sql_warn = 'SHOW WARNINGS';
5446           3                                  9      MKDEBUG && _d($sql_warn);
5447           3                                 34      my $warnings = $dbh->selectall_arrayref($sql_warn, { Slice => {} } );
5448           3                                 47      foreach my $warning ( @$warnings ) {
5449  ***      0      0      0                    0         if ( $warning->{message} =~ m/Data truncated for column 'boundaries'/ ) {
      ***             0                               
5450  ***      0                                  0            _d("Warning: WHERE clause too large for boundaries column; ",
5451                                                              "mk-table-sync may fail; value:", $where);
5452                                                        }
5453                                                        elsif ( ($warning->{code} || 0) == 1592 ) {
5454                                                           # Error: 1592 SQLSTATE: HY000  (ER_BINLOG_UNSAFE_STATEMENT)
5455                                                           # Message: Statement may not be safe to log in statement format. 
5456                                                           # Ignore this warning because we have purposely set statement-based
5457                                                           # replication.
5458  ***      0                                  0            MKDEBUG && _d('Ignoring warning:', $warning->{message});
5459                                                        }
5460                                                        else {
5461                                                           # die doesn't permit extra line breaks so warn then die.
5462  ***      0      0                           0            warn "\nChecksum query caused a warning:\n"
5463                                                              . join("\n",
5464  ***      0                                  0                    map { "\t$_: " . $warning->{$_} || '' } qw(level code message)
5465                                                                )
5466                                                              . "\n\tquery: $sql\n\n";
5467  ***      0                                  0            die;
5468                                                        }
5469                                                     }
5470                                                  
5471                                                     # Update the master_crc etc columns
5472           3                                 18      $fetch_sth->execute(@{$tbl}{qw(database table)}, $chunk_num);
               3                                910   
5473           3                                 68      ( $crc, $cnt ) = $fetch_sth->fetchrow_array();
5474           3                                 22      $update_sth->execute($crc, $cnt, @{$tbl}{qw(database table)}, $chunk_num);
               3                                980   
5475                                                  
5476           3                                 23      my $end = time();
5477  ***      3            50                   22      $crc  ||= 'NULL';
5478  ***      3     50     33                   29      if ( !$final_o->get('quiet') && !$final_o->get('explain') ) {
5479  ***      0      0                           0         if ( $final_o->get('checksum') ) {
5480  ***      0                                  0            printf($md5sum_fmt, $crc, $host->{h},
5481  ***      0      0                           0               @{$tbl}{qw(database table)}, $chunk_num)
5482                                                              or die "Cannot print: $OS_ERROR";
5483                                                        }
5484                                                        else {
5485  ***      0                                  0            printf($hdr,
5486  ***      0      0                           0               @{$tbl}{qw(database table)}, $chunk_num,
5487                                                              $host->{h}, $tbl->{struct}->{engine}, $cnt, $crc,
5488                                                              $end - $beg, 'NULL', 'NULL', 'NULL')
5489                                                                 or die "Cannot print: $OS_ERROR";
5490                                                        }
5491                                                     }
5492                                                  
5493           3                                 50      return;
5494                                                  }
5495                                                  
5496                                                  sub do_tbl {
5497          10                   10           173      my ( $chunk_num, $is_master, %args ) = @_;
5498          10                                 76      foreach my $arg ( qw(du final_o ms q tc dbh host tbl hdr explain strat) ) {
5499  ***    110     50                         448         die "I need a $arg argument" unless $args{$arg};
5500                                                     }
5501          10                                 35      my $du      = $args{du};
5502          10                                 33      my $final_o = $args{final_o};
5503          10                                 33      my $ms      = $args{ms};
5504          10                                 30      my $tc      = $args{tc};
5505          10                                 31      my $tp      = $args{tp};
5506          10                                 32      my $q       = $args{q};
5507          10                                 31      my $host    = $args{host};
5508          10                                 28      my $tbl     = $args{tbl};
5509          10                                 35      my $explain = $args{explain};
5510          10                                 32      my $hdr     = $args{hdr};
5511          10                                 32      my $strat   = $args{strat};
5512                                                  
5513          10                                 22      MKDEBUG && _d('Checksumming chunk', $chunk_num,
5514                                                        'of table', $tbl->{database}, '.', $tbl->{table},
5515                                                        'on', $host->{h}, ':', $host->{P},
5516                                                        'using algorithm', $strat);
5517                                                  
5518          10                                 38      my $dbh = $host->{dbh};
5519          10                                 57      $dbh->do("USE " . $q->quote($tbl->{database}));
5520                                                  
5521          10                                 43      my $cnt = 'NULL';
5522          10                                 29      my $crc = 'NULL';
5523          10                                 31      my $sta = 'NULL';
5524          10                                 29      my $lag = 'NULL';
5525          10                                 53      my $beg = time();
5526                                                  
5527                                                     # I'm a slave.  Wait to catch up to the master.  Calculate slave lag.
5528  ***     10     50     33                   94      if ( !$is_master
      ***                   33                        
5529                                                          && $final_o->get('wait')
5530                                                          && !$final_o->get('explain') )
5531                                                     {
5532  ***      0                                  0         MKDEBUG && _d('Waiting to catch up to master', $args{dbh}->{h},
5533                                                           ':', $args{dbh}->{P});
5534  ***      0                                  0         $sta = $ms->wait_for_master(
5535                                                           $args{dbh}, $dbh, $final_o->get('wait'), 1, $tbl->{master_status});
5536  ***      0      0                           0         $sta = 'NULL' unless defined $sta;
5537                                                     }
5538  ***     10     50     33                   65      if ( !$is_master
      ***                   33                        
5539                                                          && $final_o->get('slave-lag')
5540                                                          && !$final_o->get('explain') )
5541                                                     {
5542  ***      0                                  0         my $res = $ms->get_slave_status($dbh);
5543  ***      0      0      0                    0         $lag = $res && defined $res->{seconds_behind_master}
5544                                                             ? $res->{seconds_behind_master}
5545                                                             : 'NULL';
5546                                                     }
5547                                                  
5548                                                     # Check that table exists on slave.
5549          10                                 32      my $have_table = 1;
5550  ***     10     50     33                   99      if ( !$is_master || !$checksum_table_data ) {
5551  ***      0                                  0         $have_table = $tp->check_table(
5552                                                           dbh => $dbh,
5553                                                           db  => $tbl->{database},
5554                                                           tbl => $tbl->{table},
5555                                                        );
5556  ***      0      0                           0         warn "$tbl->{database}.$tbl->{table} does not exist on slave"
      ***             0                               
      ***             0                               
5557                                                           . ($host->{h} ? " $host->{h}" : '')
5558                                                           . ($host->{P} ? ":$host->{P}" : '')
5559                                                           unless $have_table;
5560                                                     }
5561                                                  
5562                                                     # Time the checksum operation and the wait-for-master operation separately.
5563          10                                 47      my $mid = time();
5564                                                  
5565  ***     10     50                          41      if ( $have_table ) {
5566                                                        # Do the checksum operation.
5567  ***     10     50                          44         if ( $checksum_table_data ) {
5568          10    100                          74            if ( $strat eq 'CHECKSUM' ) {
      ***            50                               
5569  ***      3     50                          12               if ( $final_o->get('crc') ) {
5570           3                                111                  $crc = do_checksum(%args);
5571                                                              }
5572  ***      3     50                          17               if ( $final_o->get('count') ) {
5573  ***      0                                  0                  $cnt = do_count($chunk_num, %args);
5574                                                              }
5575                                                           }
5576                                                           elsif ( $final_o->get('crc') ) {
5577           7                                 66               ( $cnt, $crc ) = do_var_crc($chunk_num, %args);
5578  ***      7            50                   50               $crc ||= 'NULL';
5579                                                           }
5580                                                           else {
5581  ***      0                                  0               $cnt = do_count($chunk_num, %args);
5582                                                           }
5583                                                        }
5584                                                        else { # Checksum SHOW CREATE TABLE for --schema.
5585  ***      0                                  0            my $create
5586                                                              = $du->get_create_table($dbh, $q, $tbl->{database}, $tbl->{table});
5587  ***      0                                  0            $create = $create->[1];
5588  ***      0                                  0            $create = $tp->remove_auto_increment($create);
5589  ***      0                                  0            $crc    = $tc->crc32($create);
5590                                                        }
5591                                                     }
5592                                                  
5593          10                                 51      my $end = time();
5594                                                  
5595  ***     10    100     66                   48      if ( !$final_o->get('quiet') && !$final_o->get('explain') ) {
5596           9    100                          38         if ( $final_o->get('checksum') ) {
5597           7                                108            printf($md5sum_fmt, $crc, $host->{h},
5598  ***      7     50                          35               @{$tbl}{qw(database table)}, $chunk_num)
5599                                                              or die "Cannot print: $OS_ERROR";
5600                                                        }
5601                                                        else {
5602           2                                 37            printf($hdr,
5603  ***      2     50                          12               @{$tbl}{qw(database table)}, $chunk_num,
5604                                                              $host->{h}, $tbl->{struct}->{engine}, $cnt, $crc,
5605                                                              $end - $mid, $mid - $beg, $sta, $lag)
5606                                                              or die "Cannot print: $OS_ERROR";
5607                                                        }
5608                                                     }
5609                                                  
5610          10                                 79      return;
5611                                                  }
5612                                                  
5613                                                  sub get_cxn {
5614          17                   17           149      my ( $dsn, %args ) = @_;
5615          17                                 94      foreach my $arg ( qw(o dp) ) {
5616  ***     34     50                         177         die "I need a $arg argument" unless $args{$arg};
5617                                                     }
5618          17                                 70      my $dp  = $args{dp};
5619          17                                 55      my $o   = $args{o};
5620                                                  
5621  ***     17     50     33                   72      if ( $o->get('ask-pass') && !defined $dsn->{p} ) {
5622  ***      0                                  0         $dsn->{p} = OptionParser::prompt_noecho("Enter password for $dsn->{h}: ");
5623                                                     }
5624                                                  
5625          17    100                          84      my $ac  = $o->get('lock') ? 0 : 1;
5626          17                                111      my $dbh = $dp->get_dbh(
5627                                                        $dp->get_cxn_params($dsn), { AutoCommit => $ac });
5628          17                                157      $dp->fill_in_dsn($dbh, $dsn);
5629          17                                154      $dbh->{InactiveDestroy}  = 1; # Prevent destroying on fork.
5630          17                                108      $dbh->{FetchHashKeyName} = 'NAME_lc';
5631          17                                188      return $dbh;
5632                                                  }
5633                                                  
5634                                                  sub do_var_crc {
5635           7                    7           119      my ( $chunk_num, %args ) = @_;
5636           7                                 48      foreach my $arg ( qw(ch dbh query tbl explain final_o) ) {
5637  ***     42     50                         187         die "I need a $arg argument" unless $args{$arg};
5638                                                     }
5639           7                                 24      my $final_o = $args{final_o};
5640           7                                 21      my $ch      = $args{ch};
5641           7                                 24      my $tbl     = $args{tbl};
5642           7                                 23      my $explain = $args{explain};
5643           7                                 21      my $dbh     = $args{dbh};
5644                                                  
5645           7                                 19      MKDEBUG && _d("do_var_crc for", $tbl->{table});
5646                                                  
5647           7                                 58      my $sql = $ch->inject_chunks(
5648                                                        query      => $args{query},
5649                                                        database   => $tbl->{database},
5650                                                        table      => $tbl->{table},
5651                                                        chunks     => $tbl->{chunks},
5652                                                        chunk_num  => $chunk_num,
5653                                                        where      => [$final_o->get('where'), $tbl->{since}],
5654                                                        index_hint => $tbl->{index},
5655                                                     );
5656                                                  
5657           7                                 21      if ( MKDEBUG && $chunk_num == 0 ) {
5658                                                        _d("SQL for chunk 0:", $sql);
5659                                                     }
5660                                                  
5661  ***      7     50                          30      if ( $final_o->get('explain') ) {
5662  ***      0      0                           0         if ( $chunk_num == 0 ) {
5663  ***      0      0                           0            printf($explain, @{$tbl}{qw(database table)}, $sql)
      ***      0                                  0   
5664                                                              or die "Cannot print: $OS_ERROR";
5665                                                        }
5666  ***      0      0                           0         printf($explain, @{$tbl}{qw(database table)},$tbl->{chunks}->[$chunk_num])
      ***      0                                  0   
5667                                                           or die "Cannot print: $OS_ERROR";
5668  ***      0                                  0         return;
5669                                                     }
5670                                                  
5671           7                                723      $dbh->do('set @crc := "", @cnt := 0');
5672           7                                 80      my $res = $dbh->selectall_arrayref($sql, { Slice => {} })->[0];
5673           7                                133      return ($res->{cnt}, $res->{crc});
5674                                                  }
5675                                                  
5676                                                  sub do_checksum {
5677           3                    3            49      my ( %args ) = @_;
5678           3                                 24      foreach my $arg ( qw(dbh query tbl explain final_o) ) {
5679  ***     15     50                          65         die "I need a $arg argument" unless $args{$arg};
5680                                                     }
5681           3                                 12      my $dbh     = $args{dbh};
5682           3                                 11      my $final_o = $args{final_o};
5683           3                                 14      my $tbl     = $args{tbl};
5684           3                                 10      my $query   = $args{query};
5685           3                                  9      my $explain = $args{explain};
5686                                                  
5687           3                                 12      MKDEBUG && _d("do_checksum for", $tbl->{table});
5688                                                  
5689           3    100                          88      if ( $final_o->get('explain') ) {
5690  ***      1     50                           4         printf($explain, @{$tbl}{qw(database table)}, $query)
               1                                 24   
5691                                                           or die "Cannot print: $OS_ERROR";
5692                                                     }
5693                                                     else {
5694           2                                  6         my $res = $dbh->selectrow_hashref($query);
5695  ***      2     50                          17         if ( $res ) {
5696           2                                 11            my ($key) = grep { m/checksum/i } keys %$res;
               4                                 25   
5697  ***      2     50                          24            return defined $res->{$key} ? $res->{$key} : 'NULL';
5698                                                        }
5699                                                     }
5700                                                  
5701           1                                  7      return;
5702                                                  }
5703                                                  
5704                                                  sub do_count {
5705  ***      0                    0             0      my ( $chunk_num, %args ) = @_;
5706  ***      0                                  0      foreach my $arg ( qw(q dbh tbl explain final_o) ) {
5707  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
5708                                                     }
5709  ***      0                                  0      my $final_o = $args{final_o};
5710  ***      0                                  0      my $tbl     = $args{tbl};
5711  ***      0                                  0      my $explain = $args{explain};
5712  ***      0                                  0      my $dbh     = $args{dbh};
5713  ***      0                                  0      my $q       = $args{q};
5714                                                  
5715  ***      0                                  0      MKDEBUG && _d("do_count for", $tbl->{table});
5716                                                  
5717  ***      0                                  0      my $sql = "SELECT COUNT(*) FROM "
5718  ***      0                                  0         . $q->quote(@{$tbl}{qw(database table)});
5719  ***      0      0      0                    0      if ( $final_o->get('where') || $final_o->get('since') ) {
5720  ***      0                                  0         my $where_since = ($final_o->get('where'), $final_o->get('since'));
5721  ***      0                                  0         $sql .= " WHERE ("
5722  ***      0                                  0               . join(" AND ", map { "($_)" } grep { $_ } @$where_since )
      ***      0                                  0   
5723                                                              . ")";
5724                                                     }
5725  ***      0      0                           0      if ( $final_o->get('explain') ) {
5726  ***      0      0                           0         printf($explain, @{$tbl}{qw(database table)}, $sql)
      ***      0                                  0   
5727                                                           or die "Cannot print: $OS_ERROR";
5728                                                     }
5729                                                     else {
5730  ***      0                                  0         return $dbh->selectall_arrayref($sql)->[0]->[0];
5731                                                     }
5732                                                  
5733  ***      0                                  0      return;
5734                                                  }
5735                                                  
5736                                                  sub unique {
5737          15                   15            46      my %seen;
5738          15                                 60      grep { !$seen{$_}++ } @_;
              15                                137   
5739                                                  }
5740                                                  
5741                                                  # Tries to extract the MySQL error message and print it
5742                                                  sub print_err {
5743           2                    2            29      my ( $o, $msg, $db, $tbl, $host ) = @_;
5744  ***      2     50     33                   50      return if !defined $msg
      ***                   33                        
5745                                                        # Honor --quiet in the (common?) event of dropped tables or deadlocks
5746                                                        or ($o->get('quiet')
5747                                                           && $EVAL_ERROR =~ m/: Table .*? doesn't exist|Deadlock found/);
5748           2                                 18      $msg =~ s/^.*?failed: (.*?) at \S+ line (\d+).*$/$1 at line $2/s;
5749           2                                 40      $msg =~ s/\s+/ /g;
5750  ***      2     50     33                   36      if ( $db && $tbl ) {
5751           2                                 20         $msg .= " while doing $db.$tbl";
5752                                                     }
5753  ***      2     50                          16      if ( $host ) {
5754  ***      0                                  0         $msg .= " on $host";
5755                                                     }
5756           2                                 84      print STDERR $msg, "\n";
5757                                                  }
5758                                                  
5759                                                  # Returns when Seconds_Behind_Master on all the given slaves
5760                                                  # is < max_lag, waits check_interval seconds between checks
5761                                                  # if a slave is lagging too much.
5762                                                  sub wait_for_slaves {
5763           5                    5            48      my ( %args ) = @_;
5764           5                                 30      my $slaves         = $args{slaves};
5765           5                                 19      my $max_lag        = $args{max_lag};
5766           5                                 17      my $check_interval = $args{check_interval};
5767           5                                 19      my $dp             = $args{DSNParser};
5768           5                                 19      my $ms             = $args{MasterSlave};
5769                                                  
5770  ***      5     50                          30      return unless scalar @$slaves;
5771                                                  
5772           5                                 27      foreach my $slave ( @$slaves ) {
5773           8                                 19         MKDEBUG && _d('Checking slave', $dp->as_string($slave->{dsn}),
5774                                                           'lag for --throttle');
5775           8                                 70         my $lag = $ms->get_slave_lag($slave->{dbh});
5776  ***      8            66                   95         while ( !defined $lag || $lag > $max_lag ) {
5777           6                                 41            MKDEBUG && _d('Slave lag', $lag, '>', $max_lag,
5778                                                              '; sleeping', $check_interval);
5779           6                             4001285            sleep $check_interval;
5780           4                                 88            $lag = $ms->get_slave_lag($slave->{dbh});
5781                                                        }
5782           6                                 29         MKDEBUG && _d('Slave ready, lag', $lag, '<=', $max_lag);
5783                                                     }
5784                                                  
5785           3                                 24      return;
5786                                                  }
5787                                                  
5788                                                  sub _d {
5789  ***      0                    0                    my ($package, undef, $line) = caller 0;
5790  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
5791  ***      0                                              map { defined $_ ? $_ : 'undef' }
5792                                                          @_;
5793  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
5794                                                  }
5795                                                  
5796                                                  # ############################################################################
5797                                                  # Run the program.
5798                                                  # ############################################################################
5799                                                  if ( !caller ) { exit main(@ARGV); }
5800                                                  
5801                                                  1; # Because this is a module as well as a script.
5802                                                  
5803                                                  # ############################################################################
5804                                                  # Documentation
5805                                                  # ############################################################################
5806                                                  =pod
5807                                                  
5808                                                  =head1 NAME
5809                                                  
5810                                                  mk-table-checksum - Perform an online replication consistency check, or
5811                                                  checksum MySQL tables efficiently on one or many servers.
5812                                                  
5813                                                  =head1 SYNOPSIS
5814                                                  
5815                                                  STOP! Are you checksumming a slave(s) against its master?  Then be sure to learn
5816                                                  what L<"--replicate"> does.  It is probably the option you want to use.
5817                                                  
5818                                                     mk-table-checksum --replicate=mydb.checksum master-host
5819                                                     ... time passses, replication catches up ...
5820                                                     mk-table-checksum --replicate=mydb.checksum --replicate-check 2 master-host
5821                                                  
5822                                                  Or,
5823                                                  
5824                                                     mk-table-checksum h=host1,u=user,p=password h=host2 ...
5825                                                  
5826                                                  Or,
5827                                                  
5828                                                     mk-table-checksum host1 host2 ... hostN | mk-checksum-filter
5829                                                  
5830                                                  See L<"SPECIFYING HOSTS"> for more on the syntax of the host arguments.
5831                                                  
5832                                                  =head1 RISKS
5833                                                  
5834                                                  The following section is included to inform users about the potential risks,
5835                                                  whether known or unknown, of using this tool.  The two main categories of risks
5836                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
5837                                                  tools) and those created by bugs.
5838                                                  
5839                                                  mk-table-checksum executes queries that cause the MySQL server to checksum its
5840                                                  data.  This can cause significant server load.  It is read-only unless you use
5841                                                  the L<"--replicate"> option, in which case it inserts a small amount of data
5842                                                  into the specified table.
5843                                                  
5844                                                  At the time of this release, we know of no bugs that could cause serious harm to
5845                                                  users.  There are miscellaneous bugs that might be annoying.
5846                                                  
5847                                                  The authoritative source for updated information is always the online issue
5848                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
5849                                                  see a list of such issues at the following URL:
5850                                                  L<http://www.maatkit.org/bugs/mk-table-checksum>.
5851                                                  
5852                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
5853                                                  
5854                                                  =head1 DESCRIPTION
5855                                                  
5856                                                  mk-table-checksum generates table checksums for MySQL tables, typically
5857                                                  useful for verifying your slaves are in sync with the master.  The checksums
5858                                                  are generated by a query on the server, and there is very little network
5859                                                  traffic as a result.
5860                                                  
5861                                                  Checksums typically take about twice as long as COUNT(*) on very large InnoDB
5862                                                  tables in my tests.  For smaller tables, COUNT(*) is a good bit faster than
5863                                                  the checksums.  See L<"--algorithm"> for more details on performance.
5864                                                  
5865                                                  If you specify more than one server, mk-table-checksum assumes the first
5866                                                  server is the master and others are slaves.  Checksums are parallelized for
5867                                                  speed, forking off a child process for each table.  Duplicate server names are
5868                                                  ignored, but if you want to checksum a server against itself you can use two
5869                                                  different forms of the hostname (for example, "localhost 127.0.0.1", or
5870                                                  "h=localhost,P=3306 h=localhost,P=3307").
5871                                                  
5872                                                  If you want to compare the tables in one database to those in another database
5873                                                  on the same server, just checksum both databases:
5874                                                  
5875                                                     mk-table-checksum --databases db1,db2
5876                                                  
5877                                                  You can then use L<mk-checksum-filter> to compare the results in both databases
5878                                                  easily.
5879                                                  
5880                                                  mk-table-checksum examines table structure only on the first host specified,
5881                                                  so if anything differs on the others, it won't notice.  It ignores views.
5882                                                  
5883                                                  The checksums work on MySQL version 3.23.58 through 6.0-alpha.  They will not
5884                                                  necessarily produce the same values on all versions.  Differences in
5885                                                  formatting and/or space-padding between 4.1 and 5.0, for example, will cause
5886                                                  the checksums to be different.
5887                                                  
5888                                                  =head1 SPECIFYING HOSTS
5889                                                  
5890                                                  mk-table-checksum connects to a theoretically unlimited number of MySQL
5891                                                  servers.  You specify a list of one or more host definitions on the command
5892                                                  line, such as "host1 host2".  Each host definition can be just a hostname, or it
5893                                                  can be a complex string that specifies connection options as well.  You can
5894                                                  specify connection options two ways:
5895                                                  
5896                                                  =over
5897                                                  
5898                                                  =item *
5899                                                  
5900                                                  Format a host definition in a key=value,key=value form.  If an argument on the
5901                                                  command line contains the letter '=', mk-table-checksum will parse it into
5902                                                  its component parts.  Examine the L<"--help"> output for details on the allowed
5903                                                  keys.
5904                                                  
5905                                                  Specifying a list of simple host definitions "host1 host2" is equivalent to the
5906                                                  more complicated "h=host1 h=host2" format.
5907                                                  
5908                                                  =item *
5909                                                  
5910                                                  With the command-line options such as L<"--user"> and L<"--password">.  These
5911                                                  options, if given, apply globally to all host definitions.
5912                                                  
5913                                                  =back
5914                                                  
5915                                                  In addition to specifying connection options this way, mk-table-checksum
5916                                                  allows shortcuts.  Any options specified for the first host definition on the
5917                                                  command line fill in missing values in subsequent ones.  Any options that are
5918                                                  still missing after this are filled in from the command-line options if
5919                                                  possible.
5920                                                  
5921                                                  In other words, the places you specify connection options have precedence:
5922                                                  highest precedence is the option specified directly in the host definition, next
5923                                                  is the option specified in the first host definition, and lowest is the
5924                                                  command-line option.
5925                                                  
5926                                                  You can mix simple and complex host definitions and/or command-line arguments.
5927                                                  For example, if all your servers except one of your slaves uses a non-standard
5928                                                  port number:
5929                                                  
5930                                                     mk-table-checksum --port 4500 master h=slave1,P=3306 slave2 slave3
5931                                                  
5932                                                  If you are confused about how mk-table-checksum will connect to your servers,
5933                                                  give the L<"--explain-hosts"> option and it will tell you.
5934                                                  
5935                                                  =head1 HOW FAST IS IT?
5936                                                  
5937                                                  Speed and efficiency are important, because the typical use case is checksumming
5938                                                  large amounts of data.
5939                                                  
5940                                                  C<mk-table-checksum> is designed to do very little work itself, and generates
5941                                                  very little network traffic aside from inspecting table structures with C<SHOW
5942                                                  CREATE TABLE>.  The results of checksum queries are typically 40-character or
5943                                                  shorter strings.
5944                                                  
5945                                                  The MySQL server does the bulk of the work, in the form of the checksum queries.
5946                                                  The following benchmarks show the checksum query times for various checksum
5947                                                  algorithms.  The first two results are simply running C<COUNT(col8)> and
5948                                                  C<CHECKSUM TABLE> on the table.  C<CHECKSUM TABLE> is just C<CRC32> under the
5949                                                  hood, but it's implemented inside the storage engine layer instead of at the
5950                                                  MySQL layer.
5951                                                  
5952                                                   ALGORITHM       HASH FUNCTION  EXTRA           TIME
5953                                                   ==============  =============  ==============  =====
5954                                                   COUNT(col8)                                    2.3
5955                                                   CHECKSUM TABLE                                 5.3
5956                                                   BIT_XOR         FNV_64                         12.7
5957                                                   ACCUM           FNV_64                         42.4
5958                                                   BIT_XOR         MD5            --optimize-xor  80.0
5959                                                   ACCUM           MD5                            87.4
5960                                                   BIT_XOR         SHA1           --optimize-xor  90.1
5961                                                   ACCUM           SHA1                           101.3
5962                                                   BIT_XOR         MD5                            172.0
5963                                                   BIT_XOR         SHA1                           197.3
5964                                                  
5965                                                  The tests are entirely CPU-bound.  The sample data is an InnoDB table with the
5966                                                  following structure:
5967                                                  
5968                                                   CREATE TABLE test (
5969                                                     col1 int NOT NULL,
5970                                                     col2 date NOT NULL,
5971                                                     col3 int NOT NULL,
5972                                                     col4 int NOT NULL,
5973                                                     col5 int,
5974                                                     col6 decimal(3,1),
5975                                                     col7 smallint unsigned NOT NULL,
5976                                                     col8 timestamp NOT NULL,
5977                                                     PRIMARY KEY  (col2, col1),
5978                                                     KEY (col7),
5979                                                     KEY (col1)
5980                                                   ) ENGINE=InnoDB
5981                                                  
5982                                                  The table has 4303585 rows, 365969408 bytes of data and 173457408 bytes of
5983                                                  indexes.  The server is a Dell PowerEdge 1800 with dual 32-bit Xeon 2.8GHz
5984                                                  processors and 2GB of RAM.  The tests are fully CPU-bound, and the server is
5985                                                  otherwise idle.  The results are generally consistent to within a tenth of a
5986                                                  second on repeated runs.
5987                                                  
5988                                                  C<CRC32> is the default checksum function to use, and should be enough for most
5989                                                  cases.  If you need stronger guarantees that your data is identical, you should
5990                                                  use one of the other functions.
5991                                                  
5992                                                  =head1 ALGORITHM SELECTION
5993                                                  
5994                                                  The L<"--algorithm"> option allows you to specify which algorithm you would
5995                                                  like to use, but it does not guarantee that mk-table-checksum will use this
5996                                                  algorithm.  mk-table-checksum will ultimately select the best algorithm possible
5997                                                  given various factors such as the MySQL version and other command line options.
5998                                                  
5999                                                  The three basic algorithms in descending order of preference are CHECKSUM,
6000                                                  BIT_XOR and ACCUM.  CHECKSUM cannot be used if any one of these criteria
6001                                                  is true:
6002                                                  
6003                                                    * L<"--where"> is used.
6004                                                    * L<"--since"> is used.
6005                                                    * L<"--chunk-size"> is used.
6006                                                    * L<"--replicate"> is used.
6007                                                    * L<"--count"> is used.
6008                                                    * MySQL version less than 4.1.1.
6009                                                  
6010                                                  The BIT_XOR algorithm also requires MySQL version 4.1.1 or later.
6011                                                  
6012                                                  After checking these criteria, if the requested L<"--algorithm"> remains then it
6013                                                  is used, otherwise the first remaining algorithm with the highest preference
6014                                                  is used.
6015                                                  
6016                                                  =head1 CONSISTENT CHECKSUMS
6017                                                  
6018                                                  If you are using this tool to verify your slaves still have the same data as the
6019                                                  master, which is why I wrote it, you should read this section.
6020                                                  
6021                                                  The best way to do this with replication is to use the L<"--replicate"> option.
6022                                                  When the queries are finished running on the master and its slaves, you can go
6023                                                  to the slaves and issue SQL queries to see if any tables are different from the
6024                                                  master.  Try the following:
6025                                                  
6026                                                    SELECT db, tbl, chunk, this_cnt-master_cnt AS cnt_diff,
6027                                                       this_crc <> master_crc OR ISNULL(master_crc) <> ISNULL(this_crc)
6028                                                          AS crc_diff
6029                                                    FROM checksum
6030                                                    WHERE master_cnt <> this_cnt OR master_crc <> this_crc
6031                                                       OR ISNULL(master_crc) <> ISNULL(this_crc);
6032                                                  
6033                                                  The L<"--replicate-check"> option can do this query for you.  If you can't use
6034                                                  this method, try the following:
6035                                                  
6036                                                  =over
6037                                                  
6038                                                  =item *
6039                                                  
6040                                                  If your servers are not being written to, you can just run the tool with no
6041                                                  further ado:
6042                                                  
6043                                                    mk-table-checksum server1 server2 ... serverN
6044                                                  
6045                                                  =item *
6046                                                  
6047                                                  If the servers are being written to, you need some way to make sure they are
6048                                                  consistent at the moment you run the checksums.  For situations other than
6049                                                  master-slave replication, you will have to figure this out yourself.  You may be
6050                                                  able to use the L<"--where"> option with a date or time column to only checksum
6051                                                  data that's not recent.
6052                                                  
6053                                                  =item *
6054                                                  
6055                                                  If you are checksumming a master and slaves, you can do a fast parallel
6056                                                  checksum and assume the slaves are caught up to the master.  In practice, this
6057                                                  tends to work well except for tables which are constantly updated.  You can
6058                                                  use the L<"--slave-lag"> option to see how far behind each slave was when it
6059                                                  checksummed a given table.  This can help you decide whether to investigate
6060                                                  further.
6061                                                  
6062                                                  =item *
6063                                                  
6064                                                  The next most disruptive technique is to lock the table on the master, then take
6065                                                  checksums.  This should prevent changes from propagating to the slaves.  You can
6066                                                  just lock on the master (with L<"--lock">), or you can both lock on the master
6067                                                  and wait on the slaves till they reach that point in the master's binlog
6068                                                  (L<"--wait">).  Which is better depends on your workload; only you know that.
6069                                                  
6070                                                  =item *
6071                                                  
6072                                                  If you decide to make the checksums on the slaves wait until they're guaranteed
6073                                                  to be caught up to the master, the algorithm looks like this:
6074                                                  
6075                                                   For each table,
6076                                                     Master: lock table
6077                                                     Master: get pos
6078                                                     In parallel,
6079                                                       Master: checksum
6080                                                       Slave(s): wait for pos, then checksum
6081                                                     End
6082                                                     Master: unlock table
6083                                                   End
6084                                                  
6085                                                  =back
6086                                                  
6087                                                  What I typically do when I'm not using the L<"--replicate"> option is simply run
6088                                                  the tool on all servers with no further options.  This runs fast, parallel,
6089                                                  non-blocking checksums simultaneously.  If there are tables that look different,
6090                                                  I re-run with L<"--wait">=600 on the tables in question.  This makes the tool
6091                                                  lock on the master as explained above.
6092                                                  
6093                                                  =head1 OUTPUT
6094                                                  
6095                                                  Output is to STDOUT, one line per server and table, with header lines for each
6096                                                  database.  I tried to make the output easy to process with awk.  For this reason
6097                                                  columns are always present.  If there's no value, mk-table-checksum prints
6098                                                  'NULL'.
6099                                                  
6100                                                  The default is column-aligned output for human readability, but you can change
6101                                                  it to tab-separated if you want.  Use the L<"--tab"> option for this.
6102                                                  
6103                                                  Output is unsorted, though all lines for one table should be output together.
6104                                                  For speed, all checksums are done in parallel (as much as possible) and may
6105                                                  complete out of the order in which they were started.  You might want to run
6106                                                  them through another script or command-line utility to make sure they are in the
6107                                                  order you want.  If you pipe the output through L<mk-checksum-filter>, you
6108                                                  can sort the output and/or avoid seeing output about tables that have no
6109                                                  differences.
6110                                                  
6111                                                  The columns in the output are as follows.  The database, table, and chunk come
6112                                                  first so you can sort by them easily (they are the "primary key").
6113                                                  
6114                                                  Output from L<"--replicate-check"> and L<"--checksum"> are different.
6115                                                  
6116                                                  =over
6117                                                  
6118                                                  =item DATABASE
6119                                                  
6120                                                  The database the table is in.
6121                                                  
6122                                                  =item TABLE
6123                                                  
6124                                                  The table name.
6125                                                  
6126                                                  =item CHUNK
6127                                                  
6128                                                  The chunk (see L<"--chunk-size">).  Zero if you are not doing chunked checksums.
6129                                                  
6130                                                  =item HOST
6131                                                  
6132                                                  The server's hostname.
6133                                                  
6134                                                  =item ENGINE
6135                                                  
6136                                                  The table's storage engine.
6137                                                  
6138                                                  =item COUNT
6139                                                  
6140                                                  The table's row count, unless you specified to skip it.
6141                                                  
6142                                                  =item CHECKSUM
6143                                                  
6144                                                  The table's checksum, unless you specified to skip it or the table has no rows.
6145                                                  some types of checksums will be 0 if there are no rows; others will print NULL.
6146                                                  
6147                                                  =item TIME
6148                                                  
6149                                                  The time the actual checksum and/or counting took.
6150                                                  
6151                                                  =item WAIT
6152                                                  
6153                                                  How long the checksum blocked before beginning.
6154                                                  
6155                                                  =item STAT
6156                                                  
6157                                                  The return value of MASTER_POS_WAIT().
6158                                                  
6159                                                  =item LAG
6160                                                  
6161                                                  How far the slave lags the master, as reported by SHOW SLAVE STATUS.
6162                                                  
6163                                                  =back
6164                                                  
6165                                                  =head1 EXIT STATUS
6166                                                  
6167                                                  A successful exit status is 0.  If there is an error checksumming any table,
6168                                                  the exit status is 1.
6169                                                  
6170                                                  When running L<"--replicate-check">, if any slave has chunks that differ from
6171                                                  the master, the exit status is 1.
6172                                                  
6173                                                  =head1 QUERIES
6174                                                  
6175                                                  If you are using innotop (see L<http://code.google.com/p/innotop>),
6176                                                  mytop, or another tool to watch currently running MySQL queries, you may see
6177                                                  the checksum queries.  They look similar to this:
6178                                                  
6179                                                    REPLACE /*test.test_tbl:'2'/'5'*/ INTO test.checksum(db, ...
6180                                                  
6181                                                  Since mk-table-checksum's queries run for a long time and tend to be
6182                                                  textually very long, and thus won't fit on one screen of these monitoring
6183                                                  tools, I've been careful to place a comment at the beginning of the query so
6184                                                  you can see what it is and what it's doing.  The comment contains the name of
6185                                                  the table that's being checksummed, the chunk it is currently checksumming,
6186                                                  and how many chunks will be checksummed.  In the case above, it is
6187                                                  checksumming chunk 2 of 5 in table test.test_tbl.
6188                                                  
6189                                                  =head1 OPTIONS
6190                                                  
6191                                                  L<"--schema"> is restricted to option groups Connection, Filter, Output, Help, Config.
6192                                                  
6193                                                  =over
6194                                                  
6195                                                  =item --algorithm
6196                                                  
6197                                                  type: string
6198                                                  
6199                                                  Checksum algorithm (ACCUM|CHECKSUM|BIT_XOR).
6200                                                  
6201                                                  Specifies which checksum algorithm to use.  Valid arguments are CHECKSUM,
6202                                                  BIT_XOR and ACCUM.  The latter two do cryptographic hash checksums.
6203                                                  See also L<"ALGORITHM SELECTION">.
6204                                                  
6205                                                  CHECKSUM is built into MySQL, but has some disadvantages.  BIT_XOR and ACCUM are
6206                                                  implemented by SQL queries.  They use a cryptographic hash of all columns
6207                                                  concatenated together with a separator, followed by a bitmap of each nullable
6208                                                  column that is NULL (necessary because CONCAT_WS() skips NULL columns).
6209                                                  
6210                                                  CHECKSUM is the default.  This method uses MySQL's built-in CHECKSUM TABLE
6211                                                  command, which is a CRC32 behind the scenes.  It cannot be used before MySQL
6212                                                  4.1.1, and various options disable it as well.  It does not simultaneously count
6213                                                  rows; that requires an extra COUNT(*) query.  This is a good option when you are
6214                                                  using MyISAM tables with live checksums enabled; in this case both the COUNT(*)
6215                                                  and CHECKSUM queries will run very quickly.
6216                                                  
6217                                                  The BIT_XOR algorithm is available for MySQL 4.1.1 and newer.  It uses
6218                                                  BIT_XOR(), which is order-independent, to reduce all the rows to a single
6219                                                  checksum.
6220                                                  
6221                                                  ACCUM uses a user variable as an accumulator.  It reduces each row to a single
6222                                                  checksum, which is concatenated with the accumulator and re-checksummed.  This
6223                                                  technique is order-dependent.  If the table has a primary key, it will be used
6224                                                  to order the results for consistency; otherwise it's up to chance.
6225                                                  
6226                                                  The pathological worst case is where identical rows will cancel each other out
6227                                                  in the BIT_XOR.  In this case you will not be able to distinguish a table full
6228                                                  of one value from a table full of another value.  The ACCUM algorithm will
6229                                                  distinguish them.
6230                                                  
6231                                                  However, the ACCUM algorithm is order-dependent, so if you have two tables
6232                                                  with identical data but the rows are out of order, you'll get different
6233                                                  checksums with ACCUM.
6234                                                  
6235                                                  If a given algorithm won't work for some reason, mk-table-checksum falls back to
6236                                                  another.  The least common denominator is ACCUM, which works on MySQL 3.23.2 and
6237                                                  newer.
6238                                                  
6239                                                  =item --arg-table
6240                                                  
6241                                                  type: string
6242                                                  
6243                                                  The database.table with arguments for each table to checksum.
6244                                                  
6245                                                  This table may be named anything you wish.  It must contain at least the
6246                                                  following columns:
6247                                                  
6248                                                    CREATE TABLE checksum_args (
6249                                                       db         char(64)     NOT NULL,
6250                                                       tbl        char(64)     NOT NULL,
6251                                                       -- other columns as desired
6252                                                       PRIMARY KEY (db, tbl)
6253                                                    );
6254                                                  
6255                                                  In addition to the columns shown, it may contain any of the other columns listed
6256                                                  here (Note: this list is used by the code, MAGIC_overridable_args):
6257                                                  
6258                                                    algorithm chunk-size columns count crc function lock modulo no-use-index
6259                                                    offset optimize-xor probability separator save-since single-chunk since
6260                                                    since-column sleep sleep-coef trim wait where
6261                                                  
6262                                                  Each of these columns corresponds to the long form of a command-line option.
6263                                                  Each column should be NULL-able.  Column names with hyphens should be enclosed
6264                                                  in backticks (e.g. `chunk-size`) when the table is created.  The data type does
6265                                                  not matter, but it's suggested you use a sensible data type to prevent garbage
6266                                                  data.
6267                                                  
6268                                                  When C<mk-table-checksum> checksums a table, it will look for a matching entry
6269                                                  in this table.  Any column that has a defined value will override the
6270                                                  corresponding command-line argument for the table being currently processed.
6271                                                  In this way it is possible to specify custom command-line arguments for any
6272                                                  table.
6273                                                  
6274                                                  If you add columns to the table that aren't in the above list of allowable
6275                                                  columns, it's an error.  The exceptions are C<db>, C<tbl>, and C<ts>.  The C<ts>
6276                                                  column can be used as a timestamp for easy visibility into the last time the
6277                                                  C<since> column was updated with L<"--save-since">.
6278                                                  
6279                                                  This table is assumed to be located on the first server given on the
6280                                                  command-line.
6281                                                  
6282                                                  =item --ask-pass
6283                                                  
6284                                                  group: Connection
6285                                                  
6286                                                  Prompt for a password when connecting to MySQL.
6287                                                  
6288                                                  =item --check-interval
6289                                                  
6290                                                  type: time; group: Throttle; default: 1s
6291                                                  
6292                                                  How often to check for slave lag if L<"--check-slave-lag"> is given.
6293                                                  
6294                                                  =item --check-slave-lag
6295                                                  
6296                                                  type: DSN; group: Throttle
6297                                                  
6298                                                  Pause checksumming until the specified slave's lag is less than L<"--max-lag">.
6299                                                  
6300                                                  If this option is specified, it limits L<"--[no]throttle"> to checking
6301                                                  only this slave.
6302                                                  
6303                                                  =item --checksum
6304                                                  
6305                                                  group: Output
6306                                                  
6307                                                  Print checksums and table names in the style of md5sum (disables
6308                                                  L<"--[no]count">).
6309                                                  
6310                                                  Makes the output behave more like the output of C<md5sum>.  The checksum is
6311                                                  first on the line, followed by the host, database, table, and chunk number,
6312                                                  concatenated with dots.
6313                                                  
6314                                                  =item --chunk-size
6315                                                  
6316                                                  type: string
6317                                                  
6318                                                  Approximate number of rows or size of data to checksum at a time.  Allowable
6319                                                  suffixes are k, M, G. Disallows C<--algorithm CHECKSUM>.
6320                                                  
6321                                                  If you specify a chunk size, mk-table-checksum will try to find an index that
6322                                                  will let it split the table into ranges of approximately L<"--chunk-size">
6323                                                  rows, based on the table's index statistics.  Currently only numeric and date
6324                                                  types can be chunked.
6325                                                  
6326                                                  If the table is chunkable, mk-table-checksum will checksum each range separately
6327                                                  with parameters in the checksum query's WHERE clause.  If mk-table-checksum
6328                                                  cannot find a suitable index, it will do the entire table in one chunk as though
6329                                                  you had not specified L<"--chunk-size"> at all.  Each table is handled
6330                                                  individually, so some tables may be chunked and others not.
6331                                                  
6332                                                  The chunks will be approximately sized, and depending on the distribution of
6333                                                  values in the indexed column, some chunks may be larger than the value you
6334                                                  specify.
6335                                                  
6336                                                  If you specify a suffix (one of k, M or G), the parameter is treated as a data
6337                                                  size rather than a number of rows.  The output of SHOW TABLE STATUS is then used
6338                                                  to estimate the amount of data the table contains, and convert that to a number
6339                                                  of rows.
6340                                                  
6341                                                  =item --columns
6342                                                  
6343                                                  type: array; group: Filter
6344                                                  
6345                                                  Checksum only this comma-separated list of columns.
6346                                                  
6347                                                  =item --config
6348                                                  
6349                                                  type: Array; group: Config
6350                                                  
6351                                                  Read this comma-separated list of config files; if specified, this must be the
6352                                                  first option on the command line.
6353                                                  
6354                                                  =item --[no]count
6355                                                  
6356                                                  Count rows in tables.  This is built into ACCUM and BIT_XOR, but requires an
6357                                                  extra query for CHECKSUM.
6358                                                  
6359                                                  This is disabled by default to avoid an extra COUNT(*) query when
6360                                                  L<"--algorithm"> is CHECKSUM.  If you have only MyISAM tables and live checksums
6361                                                  are enabled, both CHECKSUM and COUNT will be very fast, but otherwise you may
6362                                                  want to use one of the other algorithms.
6363                                                  
6364                                                  =item --[no]crc
6365                                                  
6366                                                  default: yes
6367                                                  
6368                                                  Do a CRC (checksum) of tables.
6369                                                  
6370                                                  Take the checksum of the rows as well as their count.  This is enabled by
6371                                                  default.  If you disable it, you'll just get COUNT(*) queries.
6372                                                  
6373                                                  =item --create-replicate-table
6374                                                  
6375                                                  Create the replicate table given by L<"--replicate"> if it does not exist.
6376                                                  
6377                                                  Normally, if the replicate table given by L<"--replicate"> does not exist,
6378                                                  C<mk-table-checksum> will die. With this option, however, C<mk-table-checksum>
6379                                                  will create the replicate table for you, using the database.table name given to
6380                                                  L<"--replicate">.
6381                                                  
6382                                                  The structure of the replicate table is the same as the suggested table
6383                                                  mentioned in L<"--replicate">. Note that since ENGINE is not specified, the
6384                                                  replicate table will use the server's default storage engine.  If you want to
6385                                                  use a different engine, you need to create the table yourself.
6386                                                  
6387                                                  =item --databases
6388                                                  
6389                                                  short form: -d; type: hash; group: Filter
6390                                                  
6391                                                  Only checksum this comma-separated list of databases.
6392                                                  
6393                                                  =item --defaults-file
6394                                                  
6395                                                  short form: -F; type: string; group: Connection
6396                                                  
6397                                                  Only read mysql options from the given file.  You must give an absolute
6398                                                  pathname.
6399                                                  
6400                                                  =item --empty-replicate-table
6401                                                  
6402                                                  Empty table given by L<"--replicate"> before starting.
6403                                                  
6404                                                  Issues a DELETE against the table given by L<"--replicate"> before beginning
6405                                                  work.  Ignored if L<"--replicate"> is not specified.  This can be useful to
6406                                                  remove entries related to tables that no longer exist, or just to clean out the
6407                                                  results of a previous run.
6408                                                  
6409                                                  =item --engines
6410                                                  
6411                                                  short form: -e; type: hash; group: Filter
6412                                                  
6413                                                  Do only this comma-separated list of storage engines.
6414                                                  
6415                                                  =item --explain
6416                                                  
6417                                                  group: Output
6418                                                  
6419                                                  Show, but do not execute, checksum queries (disables L<"--empty-replicate-table">).
6420                                                  
6421                                                  =item --explain-hosts
6422                                                  
6423                                                  group: Help
6424                                                  
6425                                                  Print connection information and exit.
6426                                                  
6427                                                  Print out a list of hosts to which mk-table-checksum will connect, with all
6428                                                  the various connection options, and exit.  See L<"SPECIFYING HOSTS">.
6429                                                  
6430                                                  =item --float-precision
6431                                                  
6432                                                  type: int
6433                                                  
6434                                                  Precision for C<FLOAT> and C<DOUBLE> column comparisons.
6435                                                  
6436                                                  If you specify this option, FLOAT and DOUBLE columns will be rounded to the
6437                                                  specified number of digits after the decimal point for the checksum.  This can
6438                                                  avoid checksum mismatches due to different floating-point representations of
6439                                                  the same values on different MySQL versions and hardware.
6440                                                  
6441                                                  =item --function
6442                                                  
6443                                                  type: string
6444                                                  
6445                                                  Hash function for checksums (FNV1A_64, MURMUR_HASH, SHA1, MD5, CRC32, etc).
6446                                                  
6447                                                  You can use this option to choose the cryptographic hash function used for
6448                                                  L<"--algorithm">=ACCUM or L<"--algorithm">=BIT_XOR.  The default is to use
6449                                                  C<CRC32>, but C<MD5> and C<SHA1> also work, and you can use your own function,
6450                                                  such as a compiled UDF, if you wish.  Whatever function you specify is run in
6451                                                  SQL, not in Perl, so it must be available to MySQL.
6452                                                  
6453                                                  The C<FNV1A_64> UDF mentioned in the benchmarks is much faster than C<MD5>.  The
6454                                                  C++ source code is distributed with Maatkit.  It is very simple to compile and
6455                                                  install; look at the header in the source code for instructions.  If it is
6456                                                  installed, it is preferred over C<MD5>.  You can also use the MURMUR_HASH
6457                                                  function if you compile and install that as a UDF; the source is also
6458                                                  distributed with Maatkit, and it is faster and has better distribution
6459                                                  than FNV1A_64.
6460                                                  
6461                                                  =item --help
6462                                                  
6463                                                  group: Help
6464                                                  
6465                                                  Show help and exit.
6466                                                  
6467                                                  =item --ignore-columns
6468                                                  
6469                                                  type: array; group: Filter
6470                                                  
6471                                                  Ignore this comma-separated list of columns when calculating the checksum.
6472                                                  
6473                                                  This option only affects the checksum when using the ACCUM or BIT_XOR
6474                                                  L<"--algorithm">.
6475                                                  
6476                                                  =item --ignore-databases
6477                                                  
6478                                                  type: hash; group: Filter
6479                                                  
6480                                                  Ignore this comma-separated list of databases.
6481                                                  
6482                                                  =item --ignore-engines
6483                                                  
6484                                                  type: Hash; default: FEDERATED,MRG_MyISAM; group: Filter
6485                                                  
6486                                                  Ignore this comma-separated list of storage engines.
6487                                                  
6488                                                  =item --ignore-tables
6489                                                  
6490                                                  type: hash; group: Filter
6491                                                  
6492                                                  Ignore this comma-separated list of tables.
6493                                                  
6494                                                  Table names may be qualified with the database name.
6495                                                  
6496                                                  =item --lock
6497                                                  
6498                                                  Lock on master until done on slaves (implies L<"--slave-lag">).
6499                                                  
6500                                                  This option can help you to get a consistent read on a master and many slaves.
6501                                                  If you specify this option, mk-table-checksum will lock the table on the
6502                                                  first server on the command line, which it assumes to be the master.  It will
6503                                                  keep this lock until the checksums complete on the other servers.
6504                                                  
6505                                                  This option isn't very useful by itself, so you probably want to use L<"--wait">
6506                                                  instead.
6507                                                  
6508                                                  Note: if you're checksumming a slave against its master, you should use
6509                                                  L<"--replicate">.  In that case, there's no need for locking, waiting, or any of
6510                                                  that.
6511                                                  
6512                                                  =item --max-lag
6513                                                  
6514                                                  type: time; group: Throttle; default: 1s
6515                                                  
6516                                                  Suspend checksumming if the slave given by L<"--check-slave-lag"> lags.
6517                                                  
6518                                                  This option causes mk-table-checksum to look at the slave every time it's about
6519                                                  to checksum a chunk.  If the slave's lag is greater than the option's value, or
6520                                                  if the slave isn't running (so its lag is NULL), mk-table-checksum sleeps for
6521                                                  L<"--check-interval"> seconds and then looks at the lag again.  It repeats until
6522                                                  the slave is caught up, then proceeds to checksum the chunk.
6523                                                  
6524                                                  This option is useful to let you checksum data as fast as the slaves can handle
6525                                                  it, assuming the slave you directed mk-table-checksum to monitor is
6526                                                  representative of all the slaves that may be replicating from this server.  It
6527                                                  should eliminate the need for L<"--sleep"> or L<"--sleep-coef">.
6528                                                  
6529                                                  =item --modulo
6530                                                  
6531                                                  type: int
6532                                                  
6533                                                  Do only every Nth chunk on chunked tables.
6534                                                  
6535                                                  This option lets you checksum only some chunks of the table.  This is a useful
6536                                                  alternative to L<"--probability"> when you want to be sure you get full coverage
6537                                                  in some specified number of runs; for example, you can do only every 7th chunk,
6538                                                  and then use L<"--offset"> to rotate the modulo every day of the week.
6539                                                  
6540                                                  Just like with L<"--probability">, a table that cannot be chunked is done every
6541                                                  time.
6542                                                  
6543                                                  =item --no-use-index
6544                                                  
6545                                                  Do not add USE INDEX hint to SQL statements.
6546                                                  
6547                                                  By default C<mk-table-checksum> adds a C<USE INDEX> hint to each SQL statement
6548                                                  to coerce MySQL into using the index for the column by which a table will be
6549                                                  chunked.  This option causes C<mk-table-checksum> to omit C<USE INDEX> hints.
6550                                                  
6551                                                  =item --offset
6552                                                  
6553                                                  type: string; default: 0
6554                                                  
6555                                                  Modulo offset expression for use with L<"--modulo">.
6556                                                  
6557                                                  The argument may be an SQL expression, such as C<WEEKDAY(NOW())> (which returns
6558                                                  a number from 0 through 6).  The argument is evaluated by MySQL.  The result is
6559                                                  used as follows: if chunk_num % L<"--modulo"> == L<"--offset">, the chunk will
6560                                                  be checksummed.
6561                                                  
6562                                                  =item --[no]optimize-xor
6563                                                  
6564                                                  default: yes
6565                                                  
6566                                                  Optimize BIT_XOR with user variables.
6567                                                  
6568                                                  This option specifies to use user variables to reduce the number of times each
6569                                                  row must be passed through the cryptographic hash function when you are using
6570                                                  the BIT_XOR algorithm.
6571                                                  
6572                                                  With the optimization, the queries look like this in pseudo-code:
6573                                                  
6574                                                    SELECT CONCAT(
6575                                                       BIT_XOR(SLICE_OF(@user_variable)),
6576                                                       BIT_XOR(SLICE_OF(@user_variable)),
6577                                                       ...
6578                                                       BIT_XOR(SLICE_OF(@user_variable := HASH(col1, col2... colN))));
6579                                                  
6580                                                  The exact positioning of user variables and calls to the hash function is
6581                                                  determined dynamically, and will vary between MySQL versions.  Without the
6582                                                  optimization, it looks like this:
6583                                                  
6584                                                    SELECT CONCAT(
6585                                                       BIT_XOR(SLICE_OF(MD5(col1, col2... colN))),
6586                                                       BIT_XOR(SLICE_OF(MD5(col1, col2... colN))),
6587                                                       ...
6588                                                       BIT_XOR(SLICE_OF(MD5(col1, col2... colN))));
6589                                                  
6590                                                  The difference is the number of times all the columns must be mashed together
6591                                                  and fed through the hash function.  If you are checksumming really large
6592                                                  columns, such as BLOB or TEXT columns, this might make a big difference.
6593                                                  
6594                                                  =item --password
6595                                                  
6596                                                  short form: -p; type: string; group: Connection
6597                                                  
6598                                                  Password to use when connecting.
6599                                                  
6600                                                  =item --pid
6601                                                  
6602                                                  type: string
6603                                                  
6604                                                  Create the given PID file.  The file contains the process ID of the script.
6605                                                  The PID file is removed when the script exits.  Before starting, the script
6606                                                  checks if the PID file already exists.  If it does not, then the script creates
6607                                                  and writes its own PID to it.  If it does, then the script checks the following:
6608                                                  if the file contains a PID and a process is running with that PID, then
6609                                                  the script dies; or, if there is no process running with that PID, then the
6610                                                  script overwrites the file with its own PID and starts; else, if the file
6611                                                  contains no PID, then the script dies.
6612                                                  
6613                                                  =item --port
6614                                                  
6615                                                  short form: -P; type: int; group: Connection
6616                                                  
6617                                                  Port number to use for connection.
6618                                                  
6619                                                  =item --probability
6620                                                  
6621                                                  type: int; default: 100
6622                                                  
6623                                                  Checksums will be run with this percent probability.
6624                                                  
6625                                                  This is an integer between 1 and 100.  If 100, every chunk of every table will
6626                                                  certainly be checksummed.  If less than that, there is a chance that some chunks
6627                                                  of some tables will be skipped.  This is useful for routine jobs designed to
6628                                                  randomly sample bits of tables without checksumming the whole server.  By
6629                                                  default, if a table is not chunkable, it will be checksummed every time even
6630                                                  when the probability is less than 100.  You can override this with
6631                                                  L<"--single-chunk">.
6632                                                  
6633                                                  See also L<"--modulo">.
6634                                                  
6635                                                  =item --quiet
6636                                                  
6637                                                  short form: -q; group: Output
6638                                                  
6639                                                  Do not print checksum results.
6640                                                  
6641                                                  =item --recheck
6642                                                  
6643                                                  Re-checksum chunks that L<"--replicate-check"> found to be different.
6644                                                  
6645                                                  =item --recurse
6646                                                  
6647                                                  group: Throttle
6648                                                  
6649                                                  Number of levels to recurse in the hierarchy for L<"--[no]throttle">.
6650                                                  Default is infinite.
6651                                                  
6652                                                  See L<"--recursion-method">.
6653                                                  
6654                                                  =item --recursion-method
6655                                                  
6656                                                  type: string
6657                                                  
6658                                                  Preferred recursion method for L<"--replicate-check"> and L<"--[no]throttle">.
6659                                                  
6660                                                  Possible methods are:
6661                                                  
6662                                                    METHOD       USES
6663                                                    ===========  ================
6664                                                    processlist  SHOW PROCESSLIST
6665                                                    hosts        SHOW SLAVE HOSTS
6666                                                  
6667                                                  The processlist method is preferred because SHOW SLAVE HOSTS is not reliable.
6668                                                  However, the hosts method is required if the server uses a non-standard
6669                                                  port (not 3306).  Usually mk-table-checksum does the right thing and finds
6670                                                  the slaves, but you may give a preferred method and it will be used first.
6671                                                  If it doesn't find any slaves, the other methods will be tried.
6672                                                  
6673                                                  =item --replicate
6674                                                  
6675                                                  type: string
6676                                                  
6677                                                  Replicate checksums to slaves (disallows --algorithm CHECKSUM).
6678                                                  
6679                                                  This option enables a completely different checksum strategy for a consistent,
6680                                                  lock-free checksum across a master and its slaves.  Instead of running the
6681                                                  checksum queries on each server, you run them only on the master.  You specify a
6682                                                  table, fully qualified in db.table format, to insert the results into.  The
6683                                                  checksum queries will insert directly into the table, so they will be replicated
6684                                                  through the binlog to the slaves.
6685                                                  
6686                                                  When the queries are finished replicating, you can run a simple query on each
6687                                                  slave to see which tables have differences from the master.  With the
6688                                                  L<"--replicate-check"> option, mk-table-checksum can run the query for you to
6689                                                  make it even easier.  See L<"CONSISTENT CHECKSUMS"> for details.  
6690                                                  
6691                                                  If you find tables that have differences, you can use the chunk boundaries in a
6692                                                  WHERE clause with L<mk-table-sync> to help repair them more efficiently.  See
6693                                                  L<mk-table-sync> for details.
6694                                                  
6695                                                  The table must have at least these columns: db, tbl, chunk, boundaries,
6696                                                  this_crc, master_crc, this_cnt, master_cnt.  The table may be named anything you
6697                                                  wish.  Here is a suggested table structure, which is automatically used for
6698                                                  L<"--create-replicate-table"> (MAGIC_create_replicate):
6699                                                  
6700                                                    CREATE TABLE checksum (
6701                                                       db         char(64)     NOT NULL,
6702                                                       tbl        char(64)     NOT NULL,
6703                                                       chunk      int          NOT NULL,
6704                                                       boundaries char(100)    NOT NULL,
6705                                                       this_crc   char(40)     NOT NULL,
6706                                                       this_cnt   int          NOT NULL,
6707                                                       master_crc char(40)         NULL,
6708                                                       master_cnt int              NULL,
6709                                                       ts         timestamp    NOT NULL,
6710                                                       PRIMARY KEY (db, tbl, chunk)
6711                                                    );
6712                                                  
6713                                                  Be sure to choose an appropriate storage engine for the checksum table.  If you
6714                                                  are checksumming InnoDB tables, for instance, a deadlock will break replication
6715                                                  if the checksum table is non-transactional, because the transaction will still
6716                                                  be written to the binlog.  It will then replay without a deadlock on the
6717                                                  slave and break replication with "different error on master and slave."  This
6718                                                  is not a problem with mk-table-checksum, it's a problem with MySQL
6719                                                  replication, and you can read more about it in the MySQL manual.
6720                                                  
6721                                                  This works only with statement-based replication (mk-table-checksum will switch
6722                                                  the binlog format to STATEMENT for the duration of the session if your server
6723                                                  uses row-based replication).  
6724                                                  
6725                                                  In contrast to running the tool against multiple servers at once, using this
6726                                                  option eliminates the complexities of synchronizing checksum queries across
6727                                                  multiple servers, which normally requires locking and unlocking, waiting for
6728                                                  master binlog positions, and so on.  Thus, it disables L<"--lock">, L<"--wait">,
6729                                                  and L<"--slave-lag"> (but not L<"--check-slave-lag">, which is a way to throttle
6730                                                  the execution speed).
6731                                                  
6732                                                  The checksum queries actually do a REPLACE into this table, so existing rows
6733                                                  need not be removed before running.  However, you may wish to do this anyway to
6734                                                  remove rows related to tables that don't exist anymore.  The
6735                                                  L<"--empty-replicate-table"> option does this for you.
6736                                                  
6737                                                  Since mk-table-checksum uses USE to select the table's database as its
6738                                                  default database before executing the checksum query, the checksum queries
6739                                                  should replicate to slaves even if --binlog-do-db settings on the master filter
6740                                                  out the checksum table's database.  For more information on how --binlog-do-db
6741                                                  works, see L<http://dev.mysql.com/doc/en/binary-log.html>.
6742                                                  
6743                                                  If the slaves have any --replicate-do-X or --replicate-ignore-X options, you
6744                                                  should be careful not to checksum any databases or tables that exist on the
6745                                                  master and not the slaves.  Changes to such tables may not normally be executed
6746                                                  on the slaves because of the --replicate options, but the checksum queries
6747                                                  modify the contents of the table that stores the checksums, not the tables whose
6748                                                  data you are checksumming.  Therefore, these queries will be executed on the
6749                                                  slave, and if the table or database you're checksumming does not exist, the
6750                                                  queries will cause replication to fail.  For more information on replication
6751                                                  rules, see L<http://dev.mysql.com/doc/en/replication-rules.html>.
6752                                                  
6753                                                  The table specified by L<"--replicate"> will never be checksummed itself.
6754                                                  
6755                                                  =item --replicate-check
6756                                                  
6757                                                  type: int
6758                                                  
6759                                                  Check results in L<"--replicate"> table, to the specified depth.
6760                                                  
6761                                                  Recursively finds differences recorded in the table given by L<"--replicate">.
6762                                                  Recurses to the depth you specify: 0 is no recursion (check only the server
6763                                                  you specify), 1 is check the server and its slaves, 2 is check the slaves of
6764                                                  its slaves, and so on.
6765                                                  
6766                                                  It finds differences by running the query shown in L<"CONSISTENT CHECKSUMS">,
6767                                                  and prints results.  Exits after printing.  This is just a convenient way of
6768                                                  running the query so you don't have to do it manually.
6769                                                  
6770                                                  The output is one informational line per slave host, followed by the results
6771                                                  of the query, if any.  If L<"--quiet"> is specified, there is no output.
6772                                                  
6773                                                  This option makes C<mk-table-checksum> looks for slaves by running C<SHOW
6774                                                  PROCESSLIST>.  If it finds connections that appear to be from slaves, it
6775                                                  derives
6776                                                  connection information for each slave the same default-and-override method
6777                                                  described in L<"SPECIFYING HOSTS">.
6778                                                  
6779                                                  If C<SHOW PROCESSLIST> doesn't return any rows, C<mk-table-checksum> looks at
6780                                                  C<SHOW SLAVE HOSTS> instead.  The host and port, and user and password if
6781                                                  available, from C<SHOW SLAVE HOSTS> are combined into a DSN and used as the
6782                                                  argument.  This requires slaves to be configured with C<report-host>,
6783                                                  C<report-port> and so on.
6784                                                  
6785                                                  This requires the @@SERVER_ID system variable, so it works only on MySQL
6786                                                  3.23.26 or newer.
6787                                                  
6788                                                  If any slave has chunks that differ from the master, mk-table-checksum's
6789                                                  exit status is 1; otherwise it is 0.
6790                                                  
6791                                                  =item --resume
6792                                                  
6793                                                  type: string
6794                                                  
6795                                                  Resume checksum using given output file from a previously interrupted run.
6796                                                  
6797                                                  The given output file should be the literal output from a previous run of
6798                                                  C<mk-table-checksum>.  For example:
6799                                                  
6800                                                     mk-table-checksum host1 host2 -C 100 > checksum_results.txt
6801                                                     mk-table-checksum host1 host2 -C 100 --resume checksum_results.txt
6802                                                  
6803                                                  The command line options given to the first run and the resumed run must
6804                                                  be identical (except, of course, for --resume).  If they are not, the result
6805                                                  will be unpredictible and probably wrong.
6806                                                  
6807                                                  L<"--resume"> does not work with L<"--replicate">; for that, use
6808                                                  L<"--resume-replicate">.
6809                                                  
6810                                                  =item --resume-replicate
6811                                                  
6812                                                  Resume L<"--replicate">.
6813                                                  
6814                                                  This option resumes a previous checksum operation using L<"--replicate">.
6815                                                  It is like L<"--resume"> but does not require an output file.  Instead,
6816                                                  it uses the checksum table given to L<"--replicate"> to determine where to
6817                                                  resume the checksum operation.
6818                                                  
6819                                                  =item --save-since
6820                                                  
6821                                                  When L<"--arg-table"> and L<"--since"> are given, save the current L<"--since">
6822                                                  value into that table's C<since> column after checksumming.  In this way you can
6823                                                  incrementally checksum tables by starting where the last one finished.
6824                                                  
6825                                                  The value to be saved could be the current timestamp, or it could be the maximum
6826                                                  existing value of the column given by L<"--since-column">.  It depends on what
6827                                                  options are in effect.  See the description of L<"--since"> to see how
6828                                                  timestamps are different from ordinary values.
6829                                                  
6830                                                  =item --schema
6831                                                  
6832                                                  Checksum C<SHOW CREATE TABLE> intead of table data.
6833                                                  
6834                                                  =item --separator
6835                                                  
6836                                                  type: string; default: #
6837                                                  
6838                                                  The separator character used for CONCAT_WS().
6839                                                  
6840                                                  This character is used to join the values of columns when checksumming with
6841                                                  L<"--algorithm"> of BIT_XOR or ACCUM.
6842                                                  
6843                                                  =item --set-vars
6844                                                  
6845                                                  type: string; default: wait_timeout=10000; group: Connection
6846                                                  
6847                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this
6848                                                  string will be appended to SET and executed.
6849                                                  
6850                                                  =item --since
6851                                                  
6852                                                  type: string
6853                                                  
6854                                                  Checksum only data newer than this value.
6855                                                  
6856                                                  If the table is chunk-able or nibble-able, this value will apply to the first
6857                                                  column of the chunked or nibbled index.
6858                                                  
6859                                                  This is not too different to L<"--where">, but instead of universally applying a
6860                                                  WHERE clause to every table, it selectively finds the right column to use and
6861                                                  applies it only if such a column is found.  See also L<"--since-column">.
6862                                                  
6863                                                  The argument may be an expression, which is evaluated by MySQL.  For example,
6864                                                  you can specify C<CURRENT_DATE - INTERVAL 7 DAY> to get the date of one week
6865                                                  ago.
6866                                                  
6867                                                  A special bit of extra magic: if the value is temporal (looks like a date or
6868                                                  datetime), then the table is checksummed only if the create time (or last
6869                                                  modified time, for tables that report the last modified time, such as MyISAM
6870                                                  tables) is newer than the value.  In this sense it's not applied as a WHERE
6871                                                  clause at all.
6872                                                  
6873                                                  =item --since-column
6874                                                  
6875                                                  type: string
6876                                                  
6877                                                  The column name to be used for L<"--since">.
6878                                                  
6879                                                  The default is for the tool to choose the best one automatically.  If you
6880                                                  specify a value, that will be used if possible; otherwise the best
6881                                                  auto-determined one; otherwise none.  If the column doesn't exist in the table,
6882                                                  it is just ignored.
6883                                                  
6884                                                  =item --single-chunk
6885                                                  
6886                                                  Permit skipping with L<"--probability"> if there is only one chunk.
6887                                                  
6888                                                  Normally, if a table isn't split into many chunks, it will always be
6889                                                  checksummed regardless of L<"--probability">.  This setting lets the
6890                                                  probabilistic behavior apply to tables that aren't divided into chunks.
6891                                                  
6892                                                  =item --slave-lag
6893                                                  
6894                                                  group: Output
6895                                                  
6896                                                  Report replication delay on the slaves.
6897                                                  
6898                                                  If this option is enabled, the output will show how many seconds behind the
6899                                                  master each slave is.  This can be useful when you want a fast, parallel,
6900                                                  non-blocking checksum, and you know your slaves might be delayed relative to the
6901                                                  master.  You can inspect the results and make an educated guess whether any
6902                                                  discrepancies on the slave are due to replication delay instead of corrupt data.
6903                                                  
6904                                                  If you're using L<"--replicate">, a slave that is delayed relative to the master
6905                                                  does not invalidate the correctness of the results, so this option is disabled.
6906                                                  
6907                                                  =item --sleep
6908                                                  
6909                                                  type: int; group: Throttle 
6910                                                  
6911                                                  Sleep time between checksums.
6912                                                  
6913                                                  If this option is specified, mk-table-checksum will sleep the specified
6914                                                  number of seconds between checksums.  That is, it will sleep between every
6915                                                  table, and if you specify L<"--chunk-size">, it will also sleep between chunks.
6916                                                  
6917                                                  This is a very crude way to throttle checksumming; see L<"--sleep-coef"> and
6918                                                  L<"--check-slave-lag"> for techniques that permit greater control.
6919                                                  
6920                                                  =item --sleep-coef
6921                                                  
6922                                                  type: float; group: Throttle
6923                                                  
6924                                                  Calculate L<"--sleep"> as a multiple of the last checksum time.
6925                                                  
6926                                                  If this option is specified, mk-table-checksum will sleep the amount of
6927                                                  time elapsed during the previous checksum, multiplied by the specified
6928                                                  coefficient.  This option is ignored if L<"--sleep"> is specified.
6929                                                  
6930                                                  This is a slightly more sophisticated way to throttle checksum speed: sleep a
6931                                                  varying amount of time between chunks, depending on how long the chunks are
6932                                                  taking.  Even better is to use L<"--check-slave-lag"> if you're checksumming
6933                                                  master/slave replication.
6934                                                  
6935                                                  =item --socket
6936                                                  
6937                                                  short form: -S; type: string; group: Connection
6938                                                  
6939                                                  Socket file to use for connection.
6940                                                  
6941                                                  =item --tab
6942                                                  
6943                                                  group: Output
6944                                                  
6945                                                  Print tab-separated output, not column-aligned output.
6946                                                  
6947                                                  =item --tables
6948                                                  
6949                                                  short form: -t; type: hash; group: Filter
6950                                                  
6951                                                  Do only this comma-separated list of tables.
6952                                                  
6953                                                  Table names may be qualified with the database name.
6954                                                  
6955                                                  =item --[no]throttle
6956                                                  
6957                                                  group: Throttle
6958                                                  
6959                                                  Throttle checksumming with L<"--replicate"> by most lagged slave.
6960                                                  
6961                                                  When L<"--replicate"> is used, mk-table-checksum automatically discovers every
6962                                                  slave and throttles checksumming if any slave lags more than L<"--max-lag">.
6963                                                  Specify C<--no-throttle> to disable this behavior completely, or specify
6964                                                  L<"--check-slave-lag"> and mk-table-checksum will only check that slave.
6965                                                  
6966                                                  See also L<"--recurse"> and L<"--recursion-method">.
6967                                                  
6968                                                  =item --trim
6969                                                  
6970                                                  Trim C<VARCHAR> columns (helps when comparing 4.1 to >= 5.0).
6971                                                  
6972                                                  This option adds a C<TRIM()> to C<VARCHAR> columns in C<BIT_XOR> and C<ACCUM>
6973                                                  modes.
6974                                                  
6975                                                  This is useful when you don't care about the trailing space differences between
6976                                                  MySQL versions which vary in their handling of trailing spaces. MySQL 5.0 and 
6977                                                  later all retain trailing spaces in C<VARCHAR>, while previous versions would 
6978                                                  remove them.
6979                                                  
6980                                                  =item --user
6981                                                  
6982                                                  short form: -u; type: string; group: Connection
6983                                                  
6984                                                  User for login if not current user.
6985                                                  
6986                                                  =item --[no]verify
6987                                                  
6988                                                  default: yes
6989                                                  
6990                                                  Verify checksum compatibility across servers.
6991                                                  
6992                                                  This option runs a trivial checksum on all servers to ensure they have
6993                                                  compatible CONCAT_WS() and cryptographic hash functions.
6994                                                  
6995                                                  Versions of MySQL before 4.0.14 will skip empty strings and NULLs in
6996                                                  CONCAT_WS, and others will only skip NULLs.  The two kinds of behavior will
6997                                                  produce different results if you have any columns containing the empty string
6998                                                  in your table.  If you know you don't (for instance, all columns are
6999                                                  integers), you can safely disable this check and you will get a reliable
7000                                                  checksum even on servers with different behavior.
7001                                                  
7002                                                  =item --version
7003                                                  
7004                                                  group: Help
7005                                                  
7006                                                  Show version and exit.
7007                                                  
7008                                                  =item --wait
7009                                                  
7010                                                  short form: -w; type: time
7011                                                  
7012                                                  Wait this long for slaves to catch up to their master (implies L<"--lock">
7013                                                  L<"--slave-lag">).
7014                                                  
7015                                                  Note: the best way to verify that a slave is in sync with its master is to use
7016                                                  L<"--replicate"> instead.  The L<"--wait"> option is really only useful if
7017                                                  you're trying to compare masters and slaves without using L<"--replicate">,
7018                                                  which is possible but complex and less efficient in some ways.
7019                                                  
7020                                                  This option helps you get a consistent checksum across a master server and its
7021                                                  slaves.  It combines locking and waiting to accomplish this.  First it locks the
7022                                                  table on the master (the first server on the command line).  Then it finds the
7023                                                  master's binlog position.  Checksums on slaves will be deferred until they reach
7024                                                  the same binlog position.
7025                                                  
7026                                                  The argument to the option is the number of seconds to wait for the slaves to
7027                                                  catch up to the master.  It is actually the argument to MASTER_POS_WAIT().  If
7028                                                  the slaves don't catch up to the master within this time, they will unblock
7029                                                  and go ahead with the checksum.  You can tell whether this happened by
7030                                                  examining the STAT column in the output, which is the return value of
7031                                                  MASTER_POS_WAIT().
7032                                                  
7033                                                  =item --where
7034                                                  
7035                                                  type: string
7036                                                  
7037                                                  Do only rows matching this C<WHERE> clause (disallows L<"--algorithm"> CHECKSUM).
7038                                                  
7039                                                  You can use this option to limit the checksum to only part of the table.  This
7040                                                  is particularly useful if you have append-only tables and don't want to
7041                                                  constantly re-check all rows; you could run a daily job to just check
7042                                                  yesterday's rows, for instance.
7043                                                  
7044                                                  This option is much like the -w option to mysqldump.  Do not specify the WHERE
7045                                                  keyword.  You may need to quote the value.  Here is an example:
7046                                                  
7047                                                    mk-table-checksum --where "foo=bar"
7048                                                  
7049                                                  =back
7050                                                  
7051                                                  =head1 DSN OPTIONS
7052                                                  
7053                                                  These DSN options are used to create a DSN.  Each option is given like
7054                                                  C<option=value>.  The options are case-sensitive, so P and p are not the
7055                                                  same option.  There cannot be whitespace before or after the C<=> and
7056                                                  if the value contains whitespace it must be quoted.  DSN options are
7057                                                  comma-separated.  See the L<maatkit> manpage for full details.
7058                                                  
7059                                                  =over
7060                                                  
7061                                                  =item * A
7062                                                  
7063                                                  dsn: charset; copy: yes
7064                                                  
7065                                                  Default character set.
7066                                                  
7067                                                  =item * D
7068                                                  
7069                                                  dsn: database; copy: yes
7070                                                  
7071                                                  Default database.
7072                                                  
7073                                                  =item * F
7074                                                  
7075                                                  dsn: mysql_read_default_file; copy: yes
7076                                                  
7077                                                  Only read default options from the given file
7078                                                  
7079                                                  =item * h
7080                                                  
7081                                                  dsn: host; copy: yes
7082                                                  
7083                                                  Connect to host.
7084                                                  
7085                                                  =item * p
7086                                                  
7087                                                  dsn: password; copy: yes
7088                                                  
7089                                                  Password to use when connecting.
7090                                                  
7091                                                  =item * P
7092                                                  
7093                                                  dsn: port; copy: yes
7094                                                  
7095                                                  Port number to use for connection.
7096                                                  
7097                                                  =item * S
7098                                                  
7099                                                  dsn: mysql_socket; copy: yes
7100                                                  
7101                                                  Socket file to use for connection.
7102                                                  
7103                                                  =item * u
7104                                                  
7105                                                  dsn: user; copy: yes
7106                                                  
7107                                                  User for login if not current user.
7108                                                  
7109                                                  =back
7110                                                  
7111                                                  =head1 DOWNLOADING
7112                                                  
7113                                                  You can download Maatkit from Google Code at
7114                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
7115                                                  easily with a command like the following:
7116                                                  
7117                                                     wget http://www.maatkit.org/get/toolname
7118                                                     or
7119                                                     wget http://www.maatkit.org/trunk/toolname
7120                                                  
7121                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
7122                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
7123                                                  needed.  The first URL gets the latest released version of the tool, and the
7124                                                  second gets the latest trunk code from Subversion.
7125                                                  
7126                                                  =head1 ENVIRONMENT
7127                                                  
7128                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
7129                                                  the Maatkit tools:
7130                                                  
7131                                                     MKDEBUG=1 mk-....
7132                                                  
7133                                                  =head1 SYSTEM REQUIREMENTS
7134                                                  
7135                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
7136                                                  installed in any reasonably new version of Perl.
7137                                                  
7138                                                  =head1 BUGS
7139                                                  
7140                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-table-checksum>.
7141                                                  
7142                                                  Please use Google Code Issues and Groups to report bugs or request support:
7143                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
7144                                                  discuss Maatkit.
7145                                                  
7146                                                  Please include the complete command-line used to reproduce the problem you are
7147                                                  seeing, the version of all MySQL servers involved, the complete output of the
7148                                                  tool when run with L<"--version">, and if possible, debugging output produced by
7149                                                  running with the C<MKDEBUG=1> environment variable.
7150                                                  
7151                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
7152                                                  
7153                                                  This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
7154                                                  Feedback and improvements are welcome.
7155                                                  
7156                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
7157                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
7158                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
7159                                                  
7160                                                  This program is free software; you can redistribute it and/or modify it under
7161                                                  the terms of the GNU General Public License as published by the Free Software
7162                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
7163                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
7164                                                  licenses.
7165                                                  
7166                                                  You should have received a copy of the GNU General Public License along with
7167                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
7168                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
7169                                                  
7170                                                  =head1 SEE ALSO
7171                                                  
7172                                                  See also L<mk-checksum-filter> and L<mk-table-sync>.
7173                                                  
7174                                                  =head1 AUTHOR
7175                                                  
7176                                                  Baron "Xaprb" Schwartz
7177                                                  
7178                                                  =head1 ABOUT MAATKIT
7179                                                  
7180                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
7181                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
7182                                                  code contributors.  Both are employed by Percona.  Financial support for
7183                                                  Maatkit development is primarily provided by Percona and its clients. 
7184                                                  
7185                                                  =head1 ACKNOWLEDGEMENTS
7186                                                  
7187                                                  This is an incomplete list.  My apologies for omissions or misspellings.
7188                                                  
7189                                                  Claus Jeppesen,
7190                                                  Francois Saint-Jacques,
7191                                                  Giuseppe Maxia,
7192                                                  Heikki Tuuri,
7193                                                  James Briggs,
7194                                                  Martin Friebe,
7195                                                  Sergey Zhuravlev,
7196                                                  
7197                                                  =head1 VERSION
7198                                                  
7199                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 6208 $.
7200                                                  
7201                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
54    ***     50      0     15   unless $args{$arg}
63    ***     50      0     15   unless $ddl
64    ***     50     15      0   if (ref $ddl eq 'ARRAY')
65    ***     50     15      0   if (lc $$ddl[0] eq 'table') { }
75    ***     50      0     15   if (not $ddl =~ /CREATE (?:TEMPORARY )?TABLE `/)
81    ***     50     15      0   if $name
99    ***     50      0     53   unless $type
101          100     18     35   if ($type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/)
105          100      1     52   if (not $def =~ /NOT NULL/)
109          100      8     45   $def =~ /AUTO_INCREMENT/i ? :
140   ***      0      0      0   unless ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
154   ***      0      0      0   if ($index)
157   ***      0      0      0   if (not $best)
158   ***      0      0      0   if ($index) { }
171   ***      0      0      0   unless $where
177   ***      0      0      0   if ($$expl{'possible_keys'}) { }
181   ***      0      0      0   if ($$expl{'key'})
201   ***     50      0     30   unless $args{$arg}
215   ***     50      0     10   if ($EVAL_ERROR)
219   ***     50      0     10   if (not $$row[0] or $$row[0] ne $tbl)
225          100      5      5   unless $args{'all_privs'}
232   ***     50      0      5   if ($EVAL_ERROR)
236   ***     50      0      5   if (not scalar keys %$row)
247   ***     50      0      5   $EVAL_ERROR ? :
252   ***     50      0      5   if (not $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete)
278   ***     50      0     14   if $key =~ /FOREIGN/
283   ***     50     14      0   if (not $engine =~ /MEMORY|HEAP/)
290   ***     50      0     14   if ($$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i)
297   ***     50     14      0   $key =~ /PRIMARY|UNIQUE/ ? :
321          100      5      9   if ($engine =~ /InnoDB/i and not $clustered_key)
323   ***     50      0      5   if ($$this_key{'name'} eq 'PRIMARY') { }
      ***     50      5      0   elsif ($$this_key{'is_unique'} and not $$this_key{'is_nullable'}) { }
347   ***      0      0      0   if (not $parent =~ /\./ and $$opts{'database'})
376   ***      0      0      0   if (($$tbl_struct{'engine'} || '') =~ /InnoDB/i) { }
386   ***      0      0      0   unless $key_ddl =~ /,$/
393   ***      0      0      0   if (@sec_indexes)
410   ***      0      0      0   defined $_ ? :
448   ***     50      0     30   unless defined $args{$arg}
461   ***      0      0      0   $comp & 1 ? :
471   ***     50     12      0   if (uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64')
491          100      6      6   if ($type eq 'bigint' and $length < 20)
505   ***     50      0     15   if $alg and not $ALGOS{$alg}
508          100      5     10   if ($args{'where'} or $args{'chunk'} or $args{'replicate'} or not $vp->version_ge($dbh, '4.1.1'))
517   ***     50      0     15   if (not $vp->version_ge($dbh, '4.1.1'))
522          100      7      8   if ($alg and grep {$_ eq $alg;} @choices)
527   ***     50      0      8   if ($args{'count'} and grep {$_ ne 'CHECKSUM';} @choices)
544          100      7      5   if ($args{'function'})
557   ***     50      0     12   if ($EVAL_ERROR and $EVAL_ERROR =~ /failed: (.*?) at \S+ line/)
563   ***     50      0     12   unless $result
572   ***     50      0      2   if $func =~ /^(?:FNV1A_64|FNV_64|CRC32)$/i
579   ***     50      0      2   length $unsliced < 16 ? :
592          100      3      2   if ($sliced ne $unsliced)
599   ***     50      2      0   if ($sliced eq $unsliced) { }
612   ***     50      0     16   unless defined $args{$arg}
619          100     13      8   if ($len > 16)
628          100      7      1   if (defined $opt_slice and $opt_slice < @slices) { }
651   ***     50      0     12   $args{'cols'} ? :
655   ***     50     12      0   if $cols{$_}
657   ***     50      0     12   if ($type eq 'timestamp') { }
      ***     50      0     12   elsif ($args{'float_precision'} and $type =~ /float|double/) { }
      ***     50      0     12   elsif ($args{'trim'} and $type =~ /varchar/) { }
674   ***     50      0     12   if (not $args{'no_cols'})
678   ***      0      0      0   if ($col =~ /\+ 0/) { }
      ***      0      0      0   elsif ($col =~ /TRIM/) { }
691   ***     50     12      0   if (uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64') { }
693   ***     50      0     12   if (@nulls)
700   ***     50      0     12   @cols > 1 ? :
716   ***     50      0     90   unless $args{$arg}
724   ***     50      0     15   unless $algorithm and $ALGOS{$algorithm}
727          100      3     12   if ($algorithm eq 'CHECKSUM')
733          100      8      4   if ($algorithm eq 'BIT_XOR') { }
734          100      5      3   if ($crc_type =~ /int$/) { }
743          100      1      3   if ($crc_type =~ /int$/) { }
756          100      5      7   if ($args{'replicate'}) { }
762   ***     50      0      7   $args{'buffer'} ? :
792   ***      0      0      0   defined $_ ? :
828   ***     50      0     30   unless $args{$arg}
898   ***     50      0     15   unless open my $fh, '<', $file
901   ***     50     15      0   if ($contents =~ /^=head1 DSN OPTIONS/m)
911   ***     50    240      0   if ($val)
912   ***     50      0    120   $val eq 'no' ? :
             100    120    120   $val eq 'yes' ? :
960   ***     50      0     30   unless open my $fh, '<', $file
968          100  27825     30   unless $para =~ /^=head1 $$self{'head1'}/
973          100     30     30   if $para =~ /^=over/
974          100     15     15   if $$self{'skip_rules'}
982   ***     50      0     30   unless $para
985          100   1065     30   if (my($option) = $para =~ /^=item $$self{'item'}/)
992          100    900    165   if ($para =~ /: /) { }
996   ***     50      0   1575   unless $$self{'attributes'}{$attrib}
1000         100    150    750   if ($attribs{'short form'})
1016  ***     50      0   1065   if $para =~ /^=item/
1018         100     75    990   if (my($base_option) = $option =~ /^\[no\](.*)/)
1023         100    135    930   $attribs{'default'} ? :
             100    465    600   $attribs{'group'} ? :
1031  ***     50      0   2700   unless $para
1032         100     30   2670   if ($para =~ /^=head1/)
1036         100   1065   1605   if $para =~ /^=item /
1040  ***     50      0     30   unless @specs
1051         100    945     15   if (ref $opt) { }
1056  ***     50      0    945   if (not $long)
1061  ***     50      0    945   if exists $$self{'opts'}{$long}
1064  ***     50      0    945   if (length $long == 1)
1069         100    150    795   if ($short) { }
1070  ***     50      0    150   if exists $$self{'short_opts'}{$short}
1079         100     75    870   $$opt{'spec'} =~ /!/ ? :
1080  ***     50      0    945   $$opt{'spec'} =~ /\+/ ? :
1081  ***     50      0    945   $$opt{'desc'} =~ /required/ ? :
1094         100    195    750   if $type and $type =~ /[HhAadzm]/
1096         100    135    810   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
1097  ***     50    135      0   defined $def ? :
1101         100     15    930   if ($long eq 'config')
1105         100     30    915   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
1118  ***     50      0     15   if ($opt =~ /mutually exclusive|one and only one/)
1123  ***     50      0     15   if ($opt =~ /at least one|one and only one/)
1128  ***     50      0     15   if ($opt =~ /default to/)
1133  ***     50     15      0   if ($opt =~ /restricted to option groups/)
1143  ***     50      0     15   unless $rule_ok
1160  ***     50      0     45   unless exists $$self{'opts'}{$long}
1184  ***      0      0      0   unless exists $$self{'opts'}{$long}
1204  ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50     86      0   exists $$self{'opts'}{$opt} ? :
1209  ***     50      0     86   if ($$opt{'is_cumulative'}) { }
1224  ***     50      0    795   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100    150    795   exists $$self{'defaults'}{$long} ? :
1233  ***     50      0     15   if (@ARGV and $ARGV[0] eq '--config')
1237  ***     50     15      0   if ($self->has('config'))
1243  ***     50     60      0   if ($EVAL_ERROR)
1244  ***     50      0     60   $self->got('config') ? :
1259  ***     50      0     15   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
1262  ***     50      0     15   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
1263  ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
1269  ***     50      0     15   if (@ARGV and $$self{'strict'})
1275  ***      0      0      0   if (@set > 1)
1286  ***      0      0      0   if (@set == 0)
1305  ***     50      0    945   unless $long
1307         100     86    859   if ($$opt{'got'}) { }
      ***     50      0    859   elsif ($$opt{'is_required'}) { }
1308         100      8     78   if (exists $$self{'disables'}{$long})
1315  ***     50      0     86   if (exists $$self{'allowed_groups'}{$long})
1327  ***      0      0      0   if $restricted_opt eq $long
1328  ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
1333  ***      0      0      0   if (@restricted_opts)
1335  ***      0      0      0   if (@restricted_opts == 1) { }
1356  ***     50    945      0   if ($$opt{'parsed'}) { }
1364  ***     50      0     15   if @long == $long_last
1374  ***     50      0    945   unless $opt
1376         100    375    570   if (not $$opt{'type'})
1383         100     30    540   if ($val and $$opt{'type'} eq 'm') { }
             100      2    538   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0    538   elsif ($val and $$opt{'type'} eq 'z') { }
             100     45    493   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100     15    478   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
1386  ***     50      0     30   if (not $suffix)
1392  ***     50     30      0   if ($suffix =~ /[smhd]/) { }
1393  ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***     50     30      0   $suffix eq 's' ? :
1408  ***     50      0      2   if ($from_key)
1410  ***      0      0      0   if ($$self{'opts'}{$from_key}{'parsed'}) { }
1443         100    101   1215   length $opt == 1 ? :
1444  ***     50      0   1316   unless $long and exists $$self{'opts'}{$long}
1451  ***     50      0     65   length $opt == 1 ? :
1452  ***     50      0     65   unless $long and exists $$self{'opts'}{$long}
1459         100    136    479   length $opt == 1 ? :
1460         100    564     51   defined $long ? :
1465  ***     50      0     13   length $opt == 1 ? :
1466  ***     50      0     13   unless $long and exists $$self{'opts'}{$long}
1493  ***      0      0      0   unless $ENV{'DONT_BREAK_LINES'}
1501  ***     50      0     15   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0     15   elsif (scalar @{$$self{'errors'};}) { }
1502  ***      0      0      0   unless print $self->print_usage
1506  ***      0      0      0   unless print $self->print_errors
1515  ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
1524  ***      0      0      0   unless $$self{'got_opts'}
1527  ***      0      0      0   $$_{'is_negatable'} ? :
1531  ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
1547  ***      0      0      0   $group eq 'default' ? :
1553  ***      0      0      0   $$opt{'is_negatable'} ? :
1556  ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
1565  ***      0      0      0   if ($short) { }
1574  ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
1578  ***      0      0      0   if ($$self{'DSNParser'})
1586  ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
1598  ***      0      0      0   if ref $_[0] eq 'OptionParser'
1601  ***      0      0      0   unless print $prompt
1609  ***      0      0      0   unless print "\n"
1612  ***      0      0      0   if ($EVAL_ERROR)
1634  ***     50     60      0   unless open my $fh, '<', $filename
1642  ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
1645  ***      0      0      0   if ($line eq '--')
1650  ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
1668  ***     50      0     15   unless open my $fh, '<', $file
1672         100  10080     15   unless $para =~ /^=pod$/m
1676         100   1950     15   unless $para =~ /$regex/
1681  ***     50      0     15   unless close $fh
1695  ***      0      0      0   $ref eq 'ARRAY' ? :
      ***     50    945      0   $ref eq 'HASH' ? :
             100    300    945   !$ref ? :
1711  ***      0      0      0   if (lc($val || '') eq 'null')
1719  ***      0      0      0   if (defined $num) { }
1720  ***      0      0      0   if ($factor)
1736         100    150    795   $$attribs{'short form'} ? :
             100     75    870   $$attribs{'negatable'} ? :
      ***     50      0    945   $$attribs{'cumulative'} ? :
             100    570    375   $$attribs{'type'} ? :
1745  ***      0      0      0   defined $_ ? :
1784  ***     50      0     41   unless $args{$arg}
1790  ***     50      0    354   if (not $$opt{'key'} or not $$opt{'desc'})
1810         100     15    222   if (@_ > 2)
1819         100      1     77   if (not $dsn)
1831         100    189      8   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1843         100     18    636   if (not defined $final_props{$key} and defined $$prev{$key} and $$opts{$key}{'copy'})
1849         100    439    215   if (not defined $final_props{$key})
1856  ***     50      0    197   unless exists $$opts{$key}
1861  ***     50      0     77   if (my $required = $self->prop('required'))
1863  ***      0      0      0   unless $final_props{$key}
1875  ***     50      0     17   unless ref $o eq 'OptionParser'
1878         100     85     51   if $o->has($_)
1888  ***      0      0      0   unless ref $dsn
1889  ***      0      0      0   $props ? :
1890  ***      0      0      0   $_ eq 'p' ? :
1891  ***      0      0      0   if defined $$dsn{$_}
1892  ***      0      0      0   unless not $props
1905  ***      0      0      0   $opts{$key}{'copy'} ? :
1919  ***     50      0     61   if ($driver eq 'Pg') { }
1951  ***     50      0     61   $cxn_string =~ /charset=utf8/ ? :
1960  ***     50      0     61   if ($$opts{'mysql_use_result'})
1964  ***     50      0     61   if (not $have_dbi)
1983  ***     50     61      0   if ($cxn_string =~ /mysql/i)
1991  ***     50      0     61   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1996  ***      0      0      0   if ($charset eq 'utf8') { }
1997  ***      0      0      0   unless binmode STDOUT, ':utf8'
2001  ***      0      0      0   unless binmode STDOUT
2005         100     23     38   if ($self->prop('set-vars'))
2012  ***     50      0     61   if (not $dbh and $EVAL_ERROR)
2014  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
2027  ***      0      0      0   if (not $tries)
2049  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
2066  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
2076  ***     50      0      2   unless $dsn_1
2077  ***     50      0      2   unless $dsn_2
2081  ***     50      0     16   if ($args{'overwrite'}) { }
2082  ***      0      0      0   defined $$dsn_1{$key} ? :
2085         100      4     12   defined $$dsn_2{$key} ? :
2094  ***      0      0      0   defined $_ ? :
2137         100     17     23   if (not $$self{$dbh})
2141  ***     50     40      0   $$self{$dbh} ge $self->parse($target) ? :
2148  ***      0      0      0   defined $_ ? :
2212  ***      0      0      0   if ($what eq 'table') { }
      ***      0      0      0   elsif ($what eq 'triggers') { }
      ***      0      0      0   elsif ($what eq 'view') { }
2214  ***      0      0      0   unless $ddl
2215  ***      0      0      0   if ($$ddl[0] eq 'table') { }
2229  ***      0      0      0   if ($trgs and @$trgs) { }
2232  ***      0      0      0   if ($$trg{'sql_mode'})
2236  ***      0      0      0   if ($$trg{'definer'})
2268         100     15     15   if (not $new)
2275  ***     50      0     15   if ($curr and $new and $curr eq $new)
2287  ***     50     15      0   if (not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl})
2300  ***     50      0     15   if ($EVAL_ERROR)
2310  ***     50     15      0   if ($key) { }
2326  ***      0      0      0   if (not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl})
2356  ***      0      0      0   if (not $$self{'cache'} or not $$self{'triggers'}{$db})
2369  ***      0      0      0   if ($sth->rows)
2382  ***      0      0      0   if ($tbl)
2390  ***      0      0      0   if (not $$self{'cache'} or not $$self{'databases'} or $like)
2393  ***      0      0      0   if ($like)
2401  ***      0      0      0   unless $like
2409  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_status'}{$db} or $like)
2412  ***      0      0      0   if ($like)
2427  ***      0      0      0   unless $like
2435  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_list'}{$db} or $like)
2438  ***      0      0      0   if ($like)
2446  ***      0      0      0   ($$_[1] || '') eq 'VIEW' ? :
2453  ***      0      0      0   unless $like
2461  ***      0      0      0   defined $_ ? :
2499  ***     50      0     30   unless $args{$arg}
2514  ***     50      0     15   unless $args{$arg}
2521  ***     50      0     14   unless $$index{'type'} eq 'BTREE'
2525  ***     50      0     14   if ($args{'exact'})
2526  ***      0      0      0   unless $$index{'is_unique'} and @{$$index{'cols'};} == 1
2539         100      1     13   unless $int_types{$$tbl_struct{'type_for'}{$col}} or $real_types{$$tbl_struct{'type_for'}{$col}}
2545  ***     50      0     15   if $args{'exact'} and scalar @candidate_cols
2555         100      9      6   if ($$tbl_struct{'keys'}{'PRIMARY'})
2578  ***      0      0      0   unless defined $args{$arg}
2589  ***      0      0      0   if ($col_type =~ /(?:int|year|float|double|decimal)$/) { }
      ***      0      0      0   elsif ($col_type eq 'timestamp') { }
      ***      0      0      0   elsif ($col_type eq 'date') { }
      ***      0      0      0   elsif ($col_type eq 'time') { }
      ***      0      0      0   elsif ($col_type eq 'datetime') { }
2621  ***      0      0      0   if (not defined $start_point)
2625  ***      0      0      0   if (not defined $end_point or $end_point < $start_point)
2634  ***      0      0      0   if ($int_types{$col_type})
2638  ***      0      0      0   if ($args{'exact'})
2644  ***      0      0      0   if ($start_point < $end_point) { }
2650  ***      0      0      0   if ($iter++ == 0) { }
2660  ***      0      0      0   if (@chunks) { }
2664  ***      0      0      0   $nullable ? :
2666  ***      0      0      0   if ($nullable)
2682  ***     50      0     15   unless $args{$arg}
2692  ***      0      0      0   unless $args{$arg}
2701  ***      0      0      0   if ($suffix) { }
      ***      0      0      0   elsif ($num) { }
2702  ***      0      0      0   $suffix eq 'M' ? :
      ***      0      0      0   $suffix eq 'k' ? :
2714  ***      0      0      0   if ($suffix or $args{'avg_row_length'})
2717  ***      0      0      0   if (not defined $n_rows)
2718  ***      0      0      0   $avg_row_length ? :
2722  ***      0      0      0   wantarray ? :
2729  ***      0      0      0   unless $args{$arg}
2734  ***      0      0      0   $where ? :
2742  ***      0      0      0   if ($EVAL_ERROR)
2744  ***      0      0      0   if ($EVAL_ERROR =~ /in your SQL syntax/) { }
2752  ***      0      0      0   if (not $args{'zero_row'})
2753  ***      0      0      0   if (not $min or $min eq '0' or $min eq '0000-00-00' or $min eq '0000-00-00 00:00:00')
2760  ***      0      0      0   $where ? :
2773  ***      0      0      0   $where ? :
2786  ***      0      0      0   $val =~ /\d[:-]/ ? :
2792  ***     50      0     50   unless defined $args{$arg}
2801  ***     50      0     10   if ($args{'where'} and grep {$_;} @{$args{'where'};})
2824  ***      0      0      0   if $start =~ /e/
2825  ***      0      0      0   if $end =~ /e/
2830  ***      0      0      0   if ($end > $start) { }
2876  ***      0      0      0   unless $check eq $time
2887  ***      0      0      0   defined $_ ? :
2931  ***      0      0      0   unless defined $val
2932  ***      0      0      0   if $val eq ''
2933  ***      0      0      0   if $val =~ /^0x[0-9a-fA-F]/
2935  ***      0      0      0   if (not defined $is_numeric)
2936  ***      0      0      0   $val =~ /^0|\D/ ? :
2939  ***      0      0      0   if $is_numeric
2949         100     15      5   if (not $tbl)
2958  ***     50      0     10   unless $like
3008  ***     50      0      9   if ($EVAL_ERROR)
3009  ***      0      0      0   unless print STDERR 'Cannot connect to ', $dp->as_string($dsn), "\n"
3019  ***     50      0      9   if (not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++)
3024  ***      0      0      0   if ($$args{'skip_callback'})
3032  ***     50      9      0   if (not defined $$args{'recurse'} or $level < $$args{'recurse'})
3034  ***     50      6      0   unless not $$_{'master_id'}
3051  ***     50      0      9   if ($method) { }
3056  ***     50      9      0   if (($$dsn{'P'} || 3306) != 3306)
3070         100      6      3   if @slaves
3088  ***      0      0      0   if ($host eq 'localhost')
3105         100      6      3   if (@slaves)
3110  ***     50      0      6   $hash{'user'} ? :
      ***     50      0      6   $hash{'password'} ? :
3130  ***      0      0      0   if ($vp and not $vp->version_ge($dbh, '4.1.2'))
3143  ***      0      0      0   if ($EVAL_ERROR)
3145  ***      0      0      0   if ($EVAL_ERROR =~ /no such grant defined for user/)
3158  ***      0      0      0   if $EVAL_ERROR
3160  ***      0      0      0   if (not $proc)
3177  ***      0      0      0   unless my $master_status = $self->get_master_status($master)
3179  ***      0      0      0   unless my $slave_status = $self->get_slave_status($slave)
3181  ***      0      0      0   unless my(@connected) = $self->get_connected_slaves($master)
3185  ***      0      0      0   if ($port != $$slave_status{'master_port'})
3190  ***      0      0      0   if (not grep {$$slave_status{'master_user'} eq $$_{'user'};} @connected)
3195  ***      0      0      0   if (($$slave_status{'slave_io_state'} || '') eq 'Waiting for master to send event')
3202  ***      0      0      0   if ($master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1)
3215  ***      0      0      0   unless my $master = $self->get_slave_status($dbh)
3222  ***     50     12      0   if (not $$self{'not_a_slave'}{$dbh})
3229  ***     50     12      0   if ($ss and %$ss)
3241  ***      0      0      0   if (not $$self{'not_a_master'}{$dbh})
3248  ***      0      0      0   if ($ms and %$ms)
3250  ***      0      0      0   if ($$ms{'file'} and $$ms{'position'})
3263  ***      0      0      0   unless defined $time
3267  ***      0      0      0   if ($ms) { }
3271  ***      0      0      0   defined $result ? :
3273  ***      0      0      0   if ($stat eq 'NULL' or $stat < 0 and not $timeoutok)
3293  ***      0      0      0   if ($pos) { }
3317  ***      0      0      0   if ($self->pos_cmp($slave_pos, $master_pos) < 0)
3323  ***      0      0      0   if ($EVAL_ERROR)
3325  ***      0      0      0   if ($EVAL_ERROR =~ /MASTER_POS_WAIT returned NULL/) { }
3327  ***      0      0      0   if (not $self->slave_is_running($slave_status)) { }
3332  ***      0      0      0   if ($self->pos_cmp($slave_pos, $master_pos) != 0)
3356  ***      0      0      0   if ($self->pos_cmp($s1_pos, $s2_pos) < 0) { }
      ***      0      0      0   elsif ($self->pos_cmp($s2_pos, $s1_pos) < 0) { }
3368  ***      0      0      0   if ($self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0)
3391  ***      0      0      0   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3395  ***      0      0      0   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
3400  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn))
3414  ***      0      0      0   if (not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0) { }
3429  ***      0      0      0   if ($self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0)
3440  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($sib_dsn))
3444  ***      0      0      0   unless my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3448  ***      0      0      0   unless my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3450  ***      0      0      0   if ($self->short_host($master_dsn1) ne $self->short_host($master_dsn2))
3453  ***      0      0      0   unless my $sib_master_stat = $self->get_master_status($sib_dbh)
3455  ***      0      0      0   unless $self->has_slave_updates($sib_dbh)
3467  ***      0      0      0   if ($self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
3479  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($unc_dsn))
3483  ***      0      0      0   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
3487  ***      0      0      0   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
3490  ***      0      0      0   unless my $unc_master_dsn = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
3493  ***      0      0      0   if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn))
3497  ***      0      0      0   unless my $unc_master_stat = $self->get_master_status($unc_dbh)
3499  ***      0      0      0   unless $self->has_slave_updates($unc_dbh)
3507  ***      0      0      0   if ($self->pos_cmp($self->repl_posn($slave_status), $self->repl_posn($master_status)) != 0)
3521  ***      0      0      0   if ($self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
3532  ***      0      0      0   unless my $stat = $self->get_slave_status($dbh)
3554  ***      0      0      0   if (exists $$status{'file'} and exists $$status{'position'}) { }
3582  ***      0      0      0   if ($$dsn{'master_host'}) { }
3590  ***      0      0      0   ($port || 3306) == 3306 ? :
3595  ***      0      0      0   unless $query
3598  ***      0      0      0   unless $type =~ /binlog_dump|slave_io|slave_sql|all/i
3602  ***      0      0      0   if ($type =~ /binlog_dump|all/i)
3603  ***      0      0      0   if ($$query{'Command'} || $$query{'command'} || '') eq 'Binlog Dump'
3606  ***      0      0      0   if (not $match)
3607  ***      0      0      0   if (($$query{'User'} || $$query{'user'} || '') eq 'system user') { }
3609  ***      0      0      0   if ($type =~ /slave_io|all/i)
3621  ***      0      0      0   if (not $match and $type =~ /slave_sql|all/i)
3646  ***      0      0      0   defined $_ ? :
3680  ***      0      0      0   unless $args{$arg}
3683  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
3699  ***      0      0      0   unless defined(my $pid = fork)
3700  ***      0      0      0   if ($pid)
3707  ***      0      0      0   unless POSIX::setsid()
3708  ***      0      0      0   unless chdir '/'
3714  ***      0      0      0   if (-t STDIN)
3716  ***      0      0      0   unless open STDIN, '/dev/null'
3720  ***      0      0      0   if ($$self{'log_file'}) { }
3722  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
3726  ***      0      0      0   unless open STDERR, '>&STDOUT'
3730  ***      0      0      0   if (-t STDOUT)
3732  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
3735  ***      0      0      0   if (-t STDERR)
3737  ***      0      0      0   unless open STDERR, '>', '/dev/null'
3748  ***      0      0      0   $self ? :
3750  ***      0      0      0   if ($PID_file and -f $PID_file) { }
3753  ***      0      0      0   if $EVAL_ERROR
3755  ***      0      0      0   if ($pid) { }
3757  ***      0      0      0   if ($pid_is_alive) { }
3779  ***      0      0      0   if (exists $$self{'child'})
3791  ***      0      0      0   if (not $PID_file)
3798  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
3800  ***      0      0      0   unless print $PID_FH $PID
3802  ***      0      0      0   unless close $PID_FH
3811  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
3812  ***      0      0      0   unless unlink $$self{'PID_file'}
3824  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
3830  ***      0      0      0   defined $_ ? :
3866  ***     50      0     15   unless $args{$arg}
3885  ***     50     15      0   if $o->has('databases')
3887  ***     50     15      0   if $o->has('ignore-databases')
3890  ***     50      0     15   if ($o->has('databases-regex') and my $p = $o->get('databases-regex'))
3894  ***     50      0     15   if ($o->has('ignore-databases-regex') and my $p = $o->get('ignore-databases-regex'))
3898  ***     50     15      0   if (@permit_dbs or @reject_dbs or @dbs_regex or @reject_dbs_regex)
3899  ***     50     15      0   @permit_dbs ? :
      ***     50      0     15   @reject_dbs ? :
      ***     50      0     15   @dbs_regex ? :
      ***     50      0     15   @reject_dbs_regex ? :
3908  ***     50     15      0   if ($o->has('tables') or $o->has('ignore-tables') or $o->has('ignore-tables-regex'))
3918         100     14      1   if ($o->get('tables'))
3921  ***     50      0     14   if ($_ =~ /\./) { }
3931  ***     50      0     14   if (@permit_qtbls)
3941  ***     50      0     15   if ($o->get('ignore-tables'))
3944  ***      0      0      0   if ($_ =~ /\./) { }
3954  ***      0      0      0   if (@reject_qtbls and not $have_qtbl)
3960  ***     50      0     15   if (keys %permit_qtbls and not @permit_dbs)
3968  ***      0      0      0   if (keys %$dbs)
3975  ***     50      0     15   if ($o->has('tables-regex') and my $p = $o->get('tables-regex'))
3979  ***     50      0     15   if ($o->has('ignore-tables-regex') and my $p = $o->get('ignore-tables-regex'))
3988  ***     50     15      0   if ($o->has('engines') and $o->get('engines') or $o->has('ignore-engines') and $o->get('ignore-engines'))
4007  ***     50     15      0   if (@permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs or @reject_engs)
4009         100     14      1   @permit_tbls ? :
      ***     50      0     15   @reject_tbls ? :
      ***     50      0     15   @tbls_regex ? :
      ***     50      0     15   @reject_tbls_regex ? :
      ***     50      0     15   @permit_qtbls ? :
      ***     50      0     15   @reject_qtbls ? :
      ***     50     15      0   @get_eng ? :
             100      1     14   @permit_engs ? :
      ***     50     15      0   @reject_engs ? :
4030  ***     50      0     15   unless my $filter_sub = eval $code
4047  ***     50      0     15   unless $args{$arg}
4056  ***     50     67      0   $filter ? :
4058         100     15     52   if $_ =~ /information_schema|lost\+found/
4073  ***     50      0     30   unless $args{$arg}
4079  ***     50     15      0   if ($db) { }
4089  ***     50     91      0   $filter ? :
4090  ***     50     91      0   if (not $views)
4091  ***     50      0     91   if ($type || '') eq 'VIEW'
4111         100     45     43   if (scalar keys %$objs)
4112         100     31     29   $lc ? :
4121  ***      0      0      0   defined $_ ? :
4209  ***     50      0    330   unless $o->has($arg)
4216  ***     50      0     15   if $o->get('wait')
4217         100      1     14   if $o->get('lock')
4219  ***     50      0     15   if (not @ARGV)
4231  ***     50      0     15   if ($o->get('explain-hosts'))
4241  ***     50      0     15   $o->get('schema') ? :
4243         100      7      8   if ($o->get('checksum'))
4247         100      1     14   if ($o->get('explain'))
4252         100      5     10   if $o->get('replicate') and not $o->got('throttle')
4254  ***     50     15      0   if (not $o->get('help'))
4255  ***     50      0     15   if ($o->get('replicate-check') and not $o->get('replicate'))
4258  ***     50      0     15   if ($o->get('save-since') and not $o->get('arg-table')) { }
      ***     50      0     15   elsif ($o->get('replicate') and @hosts > 1) { }
4265  ***     50      0     15   if ($o->get('resume-replicate') and not $o->get('replicate'))
4268  ***     50      0     15   if ($o->get('resume') and $o->get('replicate'))
4273  ***     50      0     15   if ($o->get('check-slave-lag') and not $o->get('throttle'))
4279  ***     50      0     15   if ($o->get('throttle') and not $o->get('replicate'))
4291  ***     50      0     15   if ($o->get('pid'))
4327         100      5     10   if ($o->get('throttle'))
4328         100      2      3   if ($o->get('check-slave-lag')) { }
4345         100      3      6   unless $level
4361  ***     50      0     15   if (my $arg_tbl = $o->get('arg-table'))
4366  ***      0      0      0   unless $$row{'db'} and $$row{'tbl'}
4369  ***      0      0      0   if $overridable_args{$_}
4373  ***      0      0      0   if (not %col_in_argtable)
4375  ***      0      0      0   if $key =~ /^(db|tbl|ts)$/
4376  ***      0      0      0   unless $overridable_args{$key}
4382  ***      0      0      0   if ($col_in_argtable{'since'})
4394  ***     50      0     15   if ($o->get('replicate-check'))
4395  ***      0      0      0   $o->get('recheck') ? :
4407  ***      0      0      0   unless @tbls
4425  ***      0      0      0   unless $o->get('recheck')
4433  ***     50     15      0   if ($checksum_table_data) { }
4437  ***     50      0     15   if ($o->get('verify') and @hosts > 1)
4451  ***     50      0     15   if ($o->get('replicate') and $o->get('resume-replicate')) { }
      ***     50      0     15   elsif ($o->get('resume')) { }
4470  ***     50     15      0   unless $o->get('replicate-check') and $o->get('recheck')
4498  ***     50      0    105   unless $args{$arg}
4537  ***     50      0    180   unless $args{$arg}
4550  ***     50      0     15   if $final_o->get('replicate') and $final_o->get('replicate') eq "$db.$tbl"
4561  ***     50      0     15   if $final_o->get('no-use-index')
4562         100     13      2   if ($idx)
4563  ***     50     13      0   $vp->version_ge($dbh, '4.0.9') ? :
4570  ***     50      0     15   if ($args{'given_chunks'}) { }
4574  ***     50      0     15   if ($final_o->get('chunk-size') and $col)
4589  ***      0      0      0   if (not grep {not defined $params{$_};} 'min', 'max', 'rows_in_range')
4614  ***     50      0     15   if ($EVAL_ERROR)
4626  ***     50      0    120   unless $args{$arg}
4652  ***     50     15      0   if ($checksum_table_data and $do_table) { }
4674  ***     50     15      0   if (not $hdr)
4675  ***     50      0     15   if ($o->get('tab')) { }
4689         100      2     13   unless ($o->get('quiet') or $o->get('explain') or $o->get('checksum') or $o->get('resume'))
4694  ***     50      0      2   unless printf $hdr, @hdr_args
4700         100      5     10   if (my $replicate_table = $final_o->get('replicate') and not $final_o->get('explain'))
4716  ***     50      0     15   if ($final_o->get('since'))
4717  ***      0      0      0   if (is_temporal($final_o->get('since'))) { }
4722  ***      0      0      0   if ($time and $time lt $final_o->get('since'))
4739  ***      0      0      0   if $_
4743  ***      0      0      0   if ($sincecol) { }
4762  ***     50     15      0   if ($checksum_table_data and $do_table) { }
4799  ***     50      0     13   if ($final_o->get('save-since') and $savesince_sth)
4800  ***      0      0      0   if (is_temporal($final_o->get('since'))) { }
      ***      0      0      0   elsif (defined $$table{'maxval'}) { }
4819         100      2     13   if ($EVAL_ERROR)
4830  ***     50      0    150   unless $args{$arg}
4856         100      5     10   if ($o->get('throttle'))
4866  ***     50      0     13   if ($num_chunks > 1 || $final_o->get('single-chunk') and $checksum_table_data and defined $final_o->get('probability') and rand 100 >= $final_o->get('probability'))
4874  ***     50      0     13   if ($num_chunks > 1 and $checksum_table_data and $final_o->get('modulo') and $chunk_num % $final_o->get('modulo') != $final_o->get('offset'))
4886         100      3     10   if ($final_o->get('replicate')) { }
4890  ***     50      0      3   if ($o->get('resume-replicate'))
4891  ***      0      0      0   if (already_checksummed($$tbl{'database'}, $$tbl{'table'}, $chunk_num, $hosts[0]{'h'}))
4895  ***      0      0      0   unless $o->get('quiet')
4917         100      9      1   if (not $final_o->get('explain'))
4918         100      1      8   if ($final_o->get('lock'))
4924  ***     50      0      9   if ($final_o->get('wait'))
4937  ***     50     10      0   if ($is_master) { }
4946  ***     50      0     10   if ($final_o->get('resume'))
4947  ***      0      0      0   if already_checksummed($$tbl{'database'}, $$tbl{'table'}, $chunk_num, $$host{'h'})
4954  ***     50      0     10   @hosts > 1 ? :
4956  ***     50     10      0   if (@hosts == 1 or defined $pid and $pid == 0) { }
      ***      0      0      0   elsif (@hosts > 1 and not defined $pid) { }
4968  ***     50      0     10   if ($EVAL_ERROR)
4971  ***      0      0      0   if @hosts > 1
4974  ***     50      0     10   if @hosts > 1
4981  ***     50      0     10   if @hosts > 1
4990         100      1      9   if ($final_o->get('lock') and not $final_o->get('explain'))
5000  ***     50      0     13   if ($final_o->get('sleep') and not $final_o->get('explain')) { }
      ***     50      0     13   elsif ($final_o->get('sleep-coef') and not $final_o->get('explain')) { }
5009  ***      0      0      0   if ($sleep_time < 0)
5029  ***     50      0     75   unless $args{$arg}
5038  ***     50      0     15   if (my $override = $$args_for{$db}{$tbl})
5048  ***     50      0     30   if ($val and not is_temporal($val))
5064  ***      0      0      0   unless $args{$arg}
5071  ***      0      0      0   if $o->get('quiet')
5078  ***      0      0      0   unless printf $fmt, map({uc $_;} @headers)
5080  ***      0      0      0   unless printf $fmt, @{$tbl;}{@headers}
5082  ***      0      0      0   unless print "\n"
5090  ***      0      0      0   unless $args{$arg}
5123  ***      0      0      0   if ($EVAL_ERROR and 0)
5133  ***     50      0     45   unless $args{$arg}
5156  ***     50      0     15   if ($o->get('algorithm') and $o->get('algorithm') ne $$ret{'strat'})
5163         100     12      3   if ($tc->is_hash_algorithm($$ret{'strat'}))
5168  ***     50      0     12   if ($o->get('function') and $o->get('function') ne $$ret{'func'})
5175         100      7      5   if ($o->get('optimize-xor') and $$ret{'strat'} eq 'BIT_XOR')
5176         100      2      5   if (not $$ret{'crc_type'} =~ /int$/) { }
5179  ***     50      0      2   if (not defined $$ret{'opt_slice'})
5197  ***      0      0      0   unless $args{$arg}
5214  ***      0      0      0   if (unique(map({$$_{'sum'};} @verify_sums)) > 1)
5236  ***     50      0     60   unless $args{$arg}
5244         100     10      5   unless $replicate_table
5254  ***     50      0      5   if (not $tbl_exists) { }
5255  ***      0      0      0   if ($o->get('create-replicate-table')) { }
5256  ***      0      0      0   unless create_repl_table(%args)
5275  ***     50      0      5   unless $have_tbl_privs
5280  ***     50      5      0   if ($o->get('empty-replicate-table'))
5301  ***      0      0      0   unless $args{$arg}
5316  ***      0      0      0   if ($EVAL_ERROR)
5327  ***      0      0      0   unless $args{$arg}
5334  ***      0      0      0   unless $replicate_table
5354  ***      0      0      0   unless open my $resume_fh, '<', $resume_file
5370  ***      0      0      0   if ($line =~ /^\S+\s+\S+\s+\d+\s+/)
5384  ***      0      0      0   if (exists $$already_checksummed{$d}{$t}{$c}{$h})
5394  ***     50      0     24   unless $args{$arg}
5429  ***     50      0      3   if ($final_o->get('explain'))
5430  ***      0      0      0   if ($chunk_num == 0)
5431  ***      0      0      0   unless printf $explain, @{$tbl;}{'database', 'table'}, $sql
5434  ***      0      0      0   unless printf $explain, @{$tbl;}{'database', 'table'}, $where
5449  ***      0      0      0   if ($$warning{'message'} =~ /Data truncated for column 'boundaries'/) { }
      ***      0      0      0   elsif (($$warning{'code'} || 0) == 1592) { }
5462  ***      0      0      0   unless "\t${_}: " . $$warning{$_}
5478  ***     50      0      3   if (not $final_o->get('quiet') and not $final_o->get('explain'))
5479  ***      0      0      0   if ($final_o->get('checksum')) { }
5481  ***      0      0      0   unless printf $md5sum_fmt, $crc, $$host{'h'}, @{$tbl;}{'database', 'table'}, $chunk_num
5486  ***      0      0      0   unless printf $hdr, @{$tbl;}{'database', 'table'}, $chunk_num, $$host{'h'}, $$tbl{'struct'}{'engine'}, $cnt, $crc, $end - $beg, 'NULL', 'NULL', 'NULL'
5499  ***     50      0    110   unless $args{$arg}
5528  ***     50      0     10   if (not $is_master and $final_o->get('wait') and not $final_o->get('explain'))
5536  ***      0      0      0   unless defined $sta
5538  ***     50      0     10   if (not $is_master and $final_o->get('slave-lag') and not $final_o->get('explain'))
5543  ***      0      0      0   $res && defined $$res{'seconds_behind_master'} ? :
5550  ***     50      0     10   if (not $is_master or not $checksum_table_data)
5556  ***      0      0      0   $$host{'h'} ? :
      ***      0      0      0   $$host{'P'} ? :
      ***      0      0      0   unless $have_table
5565  ***     50     10      0   if ($have_table)
5567  ***     50     10      0   if ($checksum_table_data) { }
5568         100      3      7   if ($strat eq 'CHECKSUM') { }
      ***     50      7      0   elsif ($final_o->get('crc')) { }
5569  ***     50      3      0   if ($final_o->get('crc'))
5572  ***     50      0      3   if ($final_o->get('count'))
5595         100      9      1   if (not $final_o->get('quiet') and not $final_o->get('explain'))
5596         100      7      2   if ($final_o->get('checksum')) { }
5598  ***     50      0      7   unless printf $md5sum_fmt, $crc, $$host{'h'}, @{$tbl;}{'database', 'table'}, $chunk_num
5603  ***     50      0      2   unless printf $hdr, @{$tbl;}{'database', 'table'}, $chunk_num, $$host{'h'}, $$tbl{'struct'}{'engine'}, $cnt, $crc, $end - $mid, $mid - $beg, $sta, $lag
5616  ***     50      0     34   unless $args{$arg}
5621  ***     50      0     17   if ($o->get('ask-pass') and not defined $$dsn{'p'})
5625         100      1     16   $o->get('lock') ? :
5637  ***     50      0     42   unless $args{$arg}
5661  ***     50      0      7   if ($final_o->get('explain'))
5662  ***      0      0      0   if ($chunk_num == 0)
5663  ***      0      0      0   unless printf $explain, @{$tbl;}{'database', 'table'}, $sql
5666  ***      0      0      0   unless printf $explain, @{$tbl;}{'database', 'table'}, $$tbl{'chunks'}[$chunk_num]
5679  ***     50      0     15   unless $args{$arg}
5689         100      1      2   if ($final_o->get('explain')) { }
5690  ***     50      0      1   unless printf $explain, @{$tbl;}{'database', 'table'}, $query
5695  ***     50      2      0   if ($res)
5697  ***     50      2      0   defined $$res{$key} ? :
5707  ***      0      0      0   unless $args{$arg}
5719  ***      0      0      0   if ($final_o->get('where') or $final_o->get('since'))
5725  ***      0      0      0   if ($final_o->get('explain')) { }
5726  ***      0      0      0   unless printf $explain, @{$tbl;}{'database', 'table'}, $sql
5744  ***     50      0      2   if not defined $msg or $o->get('quiet') and $EVAL_ERROR =~ /: Table .*? doesn't exist|Deadlock found/
5750  ***     50      2      0   if ($db and $tbl)
5753  ***     50      0      2   if ($host)
5770  ***     50      0      5   unless scalar @$slaves
5790  ***      0      0      0   defined $_ ? :


Conditions
----------

and 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
2523  ***     33     15      0   0
2545  ***     50     15      0   $args{'exact'} and scalar @candidate_cols
5123  ***      0      0      0   $EVAL_ERROR and 0

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
252   ***     33      0      0      5   $privs =~ /select/ && $privs =~ /insert/
      ***     33      0      0      5   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/
      ***     33      0      0      5   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete
290   ***     33     14      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000'
      ***     33     14      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i
321   ***     66      9      0      5   $engine =~ /InnoDB/i and not $clustered_key
323   ***     33      0      0      5   $$this_key{'is_unique'} and not $$this_key{'is_nullable'}
347   ***      0      0      0      0   not $parent =~ /\./ and $$opts{'database'}
471   ***     33      0      0     12   uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64'
491   ***     66      6      0      6   $type eq 'bigint' and $length < 20
505   ***     66      8      7      0   $alg and not $ALGOS{$alg}
522   ***     66      8      0      7   $alg and grep {$_ eq $alg;} @choices
527   ***     33      8      0      0   $args{'count'} and grep {$_ ne 'CHECKSUM';} @choices
538   ***     66      0      3     12   $ALGOS{$algorithm} && $ALGOS{$algorithm}{'hash'}
548   ***     33      0     12      0   @funcs and not $result
557   ***     33     12      0      0   $EVAL_ERROR and $EVAL_ERROR =~ /failed: (.*?) at \S+ line/
581   ***     66      0      2      3   $start < $crc_wid and $sliced ne $unsliced
628   ***     66      1      0      7   defined $opt_slice and $opt_slice < @slices
657   ***     33     12      0      0   $args{'float_precision'} and $type =~ /float|double/
      ***     33     12      0      0   $args{'trim'} and $type =~ /varchar/
691   ***     33      0      0     12   uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64'
724   ***     33      0      0     15   $algorithm and $ALGOS{$algorithm}
1094         100    375    375    195   $type and $type =~ /[HhAadzm]/
1233  ***     33      0     15      0   @ARGV and $ARGV[0] eq '--config'
1262  ***     33      0     15      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
1269  ***     33      0     15      0   @ARGV and $$self{'strict'}
1383         100    400    140     30   $val and $$opt{'type'} eq 'm'
             100    400    138      2   $val and $$opt{'type'} eq 'd'
      ***     66    400    138      0   $val and $$opt{'type'} eq 'z'
             100    400     93     30   defined $val and $$opt{'type'} eq 'h'
      ***     66    400     78      0   defined $val and $$opt{'type'} eq 'a'
1444  ***     33      0      0   1316   $long and exists $$self{'opts'}{$long}
1452  ***     33      0      0     65   $long and exists $$self{'opts'}{$long}
1466  ***     33      0      0     13   $long and exists $$self{'opts'}{$long}
1556  ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
1650  ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1843         100    197    439     18   not defined $final_props{$key} and defined $$prev{$key}
      ***     66    636      0     18   not defined $final_props{$key} and defined $$prev{$key} and $$opts{$key}{'copy'}
1976  ***     66     61      0     61   not $dbh and $tries--
2012  ***     33     61      0      0   not $dbh and $EVAL_ERROR
2229  ***      0      0      0      0   $trgs and @$trgs
2275  ***     33     15      0      0   $curr and $new
      ***     33     15      0      0   $curr and $new and $curr eq $new
2526  ***      0      0      0      0   $$index{'is_unique'} and @{$$index{'cols'};} == 1
2801  ***     33      0     10      0   $args{'where'} and grep {$_;} @{$args{'where'};}
3019  ***     66      3      6      0   defined $master_thinks_i_am and $master_thinks_i_am != $id
3130  ***      0      0      0      0   $vp and not $vp->version_ge($dbh, '4.1.2')
3229  ***     33      0      0     12   $ss and %$ss
3248  ***      0      0      0      0   $ms and %$ms
3250  ***      0      0      0      0   $$ms{'file'} and $$ms{'position'}
3273  ***      0      0      0      0   $stat < 0 and not $timeoutok
3414  ***      0      0      0      0   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status)
      ***      0      0      0      0   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0
3549  ***      0      0      0      0   $value && $value =~ /^(1|ON)$/
3554  ***      0      0      0      0   exists $$status{'file'} and exists $$status{'position'}
3621  ***      0      0      0      0   not $match and $type =~ /slave_sql|all/i
3750  ***      0      0      0      0   $PID_file and -f $PID_file
3811  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
3890  ***     33     15      0      0   $o->has('databases-regex') and my $p = $o->get('databases-regex')
3894  ***     33     15      0      0   $o->has('ignore-databases-regex') and my $p = $o->get('ignore-databases-regex')
3954  ***      0      0      0      0   @reject_qtbls and not $have_qtbl
3960  ***     33     15      0      0   keys %permit_qtbls and not @permit_dbs
3975  ***     33     15      0      0   $o->has('tables-regex') and my $p = $o->get('tables-regex')
3979  ***     33     15      0      0   $o->has('ignore-tables-regex') and my $p = $o->get('ignore-tables-regex')
3988  ***     66      0     14      1   $o->has('engines') and $o->get('engines')
      ***     33      0      0     14   $o->has('ignore-engines') and $o->get('ignore-engines')
4252  ***     66     10      0      5   $o->get('replicate') and not $o->got('throttle')
4255  ***     33     15      0      0   $o->get('replicate-check') and not $o->get('replicate')
4258  ***     33     15      0      0   $o->get('save-since') and not $o->get('arg-table')
      ***     66     10      5      0   $o->get('replicate') and @hosts > 1
4265  ***     33     15      0      0   $o->get('resume-replicate') and not $o->get('replicate')
4268  ***     33     15      0      0   $o->get('resume') and $o->get('replicate')
4273  ***     66     13      2      0   $o->get('check-slave-lag') and not $o->get('throttle')
4279  ***     66     10      5      0   $o->get('throttle') and not $o->get('replicate')
4366  ***      0      0      0      0   $$row{'db'} and $$row{'tbl'}
4437  ***     33      0     15      0   $o->get('verify') and @hosts > 1
4451  ***     66     10      5      0   $o->get('replicate') and $o->get('resume-replicate')
4470  ***     33     15      0      0   $o->get('replicate-check') and $o->get('recheck')
4550  ***     66     10      5      0   $final_o->get('replicate') and $final_o->get('replicate') eq "$db.$tbl"
4574  ***     33     15      0      0   $final_o->get('chunk-size') and $col
4652  ***     33      0      0     15   $checksum_table_data and $do_table
4700  ***     66     10      0      5   my $replicate_table = $final_o->get('replicate') and not $final_o->get('explain')
4722  ***      0      0      0      0   $time and $time lt $final_o->get('since')
4762  ***     33      0      0     15   $checksum_table_data and $do_table
4799  ***     33     13      0      0   $final_o->get('save-since') and $savesince_sth
4866  ***     33     13      0      0   $num_chunks > 1 || $final_o->get('single-chunk') and $checksum_table_data
      ***     33     13      0      0   $num_chunks > 1 || $final_o->get('single-chunk') and $checksum_table_data and defined $final_o->get('probability')
      ***     33     13      0      0   $num_chunks > 1 || $final_o->get('single-chunk') and $checksum_table_data and defined $final_o->get('probability') and rand 100 >= $final_o->get('probability')
4874  ***     33     13      0      0   $num_chunks > 1 and $checksum_table_data
      ***     33     13      0      0   $num_chunks > 1 and $checksum_table_data and $final_o->get('modulo')
      ***     33     13      0      0   $num_chunks > 1 and $checksum_table_data and $final_o->get('modulo') and $chunk_num % $final_o->get('modulo') != $final_o->get('offset')
4956  ***      0      0      0      0   defined $pid and $pid == 0
      ***      0      0      0      0   @hosts > 1 and not defined $pid
4990  ***     66      9      0      1   $final_o->get('lock') and not $final_o->get('explain')
5000  ***     33     13      0      0   $final_o->get('sleep') and not $final_o->get('explain')
      ***     33     13      0      0   $final_o->get('sleep-coef') and not $final_o->get('explain')
5048  ***     33     30      0      0   $val and not is_temporal($val)
5058  ***      0      0      0      0   $val && $val =~ /^\d{4}-\d{2}-\d{2}(?:.[0-9:]+)?/
5156  ***     66      8      7      0   $o->get('algorithm') and $o->get('algorithm') ne $$ret{'strat'}
5168  ***     66      5      7      0   $o->get('function') and $o->get('function') ne $$ret{'func'}
5175         100      1      4      7   $o->get('optimize-xor') and $$ret{'strat'} eq 'BIT_XOR'
5478  ***     33      3      0      0   not $final_o->get('quiet') and not $final_o->get('explain')
5528  ***     33     10      0      0   not $is_master and $final_o->get('wait')
      ***     33     10      0      0   not $is_master and $final_o->get('wait') and not $final_o->get('explain')
5538  ***     33     10      0      0   not $is_master and $final_o->get('slave-lag')
      ***     33     10      0      0   not $is_master and $final_o->get('slave-lag') and not $final_o->get('explain')
5543  ***      0      0      0      0   $res && defined $$res{'seconds_behind_master'}
5595  ***     66      0      1      9   not $final_o->get('quiet') and not $final_o->get('explain')
5621  ***     33     17      0      0   $o->get('ask-pass') and not defined $$dsn{'p'}
5744  ***     33      0      2      0   $o->get('quiet') and $EVAL_ERROR =~ /: Table .*? doesn't exist|Deadlock found/
5750  ***     33      0      0      2   $db and $tbl

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
47    ***     50      0     27   $ENV{'MKDEBUG'} || 0
266   ***     50     30      0   $engine || undef
289   ***     50      0     14   $type || $special || 'BTREE'
376   ***      0      0      0   $$tbl_struct{'engine'} || ''
378   ***      0      0      0   $clustered_key ||= ''
437   ***     50      0     27   $ENV{'MKDEBUG'} || 0
643   ***     50     12      0   $args{'sep'} || '#'
645   ***     50     12      0   $sep ||= '#'
821   ***     50      0     27   $ENV{'MKDEBUG'} || 0
832   ***     33     30      0   0
833   ***     50     30      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
894   ***     50      0     15   $file ||= '/home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum'
959   ***     50     30      0   $file ||= '/home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum'
1083  ***     50    945      0   $$opt{'group'} ||= 'default'
1388  ***      0      0      0   $s || 's'
1397  ***     50      0     30   $prefix || ''
1427  ***     50     45      0   $val || ''
1430  ***     50     15      0   $val || ''
1489  ***      0      0      0   $$self{'description'} || ''
1558  ***      0      0      0   $s ||= 's'
1584  ***      0      0      0   $$opt{'type'} || ''
1711  ***      0      0      0   $val || ''
1725  ***      0      0      0   $pre || ''
1779  ***     50      0     27   $ENV{'MKDEBUG'} || 0
1799  ***     50    354      0   $$opt{'copy'} || 0
1824         100      8     69   $prev ||= {}
1825         100     16     61   $defaults ||= {}
1905  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1918  ***     50      0     61   $self->prop('dbidriver') || ''
1922  ***      0      0      0   $$info{'D'} || ''
1928  ***     50      0     61   $$info{'D'} || ''
1941  ***     66     16      1   0
1942  ***     66      2     15   0
1943  ***     66      2     15   0
1944  ***     66      2     15   0
1945  ***     33      0     17   0
1950  ***     50     61      0   $opts ||= {}
2049  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
2065  ***      0      0      0   $level ||= 0
2066  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
2121  ***     50      0     27   $ENV{'MKDEBUG'} || 0
2175  ***     50      0     27   $ENV{'MKDEBUG'} || 0
2446  ***      0      0      0   $$_[1] || ''
2494  ***     50      0     27   $ENV{'MKDEBUG'} || 0
2807  ***     50     10      0   $args{'index_hint'} || ''
2913  ***     50      0     27   $ENV{'MKDEBUG'} || 0
2988  ***     50      0     27   $ENV{'MKDEBUG'} || 0
2998         100      6      3   $level ||= 0
3056  ***     50      9      0   $$dsn{'P'} || 3306
3195  ***      0      0      0   $$slave_status{'slave_io_state'} || ''
3541  ***      0      0      0   $$slave_status{'slave_sql_running'} || 'No'
3590  ***      0      0      0   $host || '[default]'
      ***      0      0      0   $port || 3306
3597  ***      0      0      0   $type ||= 'all'
3603  ***      0      0      0   $$query{'Command'} || $$query{'command'} || ''
3607  ***      0      0      0   $$query{'User'} || $$query{'user'} || ''
3608  ***      0      0      0   $$query{'State'} || $$query{'state'} || ''
3675  ***     50      0     27   $ENV{'MKDEBUG'} || 0
3861  ***     50      0     27   $ENV{'MKDEBUG'} || 0
4091  ***     50     91      0   $type || ''
4150  ***     50      0     27   $ENV{'MKDEBUG'} || 0
4939  ***     33      0     10   0
5449  ***      0      0      0   $$warning{'code'} || 0
5477  ***     50      3      0   $crc ||= 'NULL'
5578  ***     50      7      0   $crc ||= 'NULL'

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
140   ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'}
      ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
219   ***     33      0      0     10   not $$row[0] or $$row[0] ne $tbl
240   ***     33      5      0      0   $$row{'privileges'} || $$row{'Privileges'}
289   ***     33      0      0     14   $type || $special
508   ***     33      0      0     15   $args{'where'} or $args{'chunk'}
      ***     66      0      5     10   $args{'where'} or $args{'chunk'} or $args{'replicate'}
      ***     66      5      0     10   $args{'where'} or $args{'chunk'} or $args{'replicate'} or not $vp->version_ge($dbh, '4.1.1')
833   ***     33     30      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***     33     30      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
1383         100     15     30    493   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***     66     15      0    478   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1790  ***     33      0      0    354   not $$opt{'key'} or not $$opt{'desc'}
2287  ***     33     15      0      0   not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl}
2326  ***      0      0      0      0   not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl}
2356  ***      0      0      0      0   not $$self{'cache'} or not $$self{'triggers'}{$db}
2390  ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'} or $like
2409  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db} or $like
2423  ***      0      0      0      0   $tbl{'type'} || $tbl{'comment'}
      ***      0      0      0      0   $tbl{'engine'} ||= $tbl{'type'} || $tbl{'comment'}
2435  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db} or $like
2539  ***     66     13      0      1   $int_types{$$tbl_struct{'type_for'}{$col}} or $real_types{$$tbl_struct{'type_for'}{$col}}
2625  ***      0      0      0      0   not defined $end_point or $end_point < $start_point
2637  ***      0      0      0      0   $interval ||= $args{'chunk_size'}
2714  ***      0      0      0      0   $suffix or $args{'avg_row_length'}
2753  ***      0      0      0      0   not $min or $min eq '0'
      ***      0      0      0      0   not $min or $min eq '0' or $min eq '0000-00-00'
      ***      0      0      0      0   not $min or $min eq '0' or $min eq '0000-00-00' or $min eq '0000-00-00 00:00:00'
3004  ***     66      3      6      0   $$args{'dbh'} || $dp->get_dbh($dp->get_cxn_params($dsn), {'AutoCommit', 1})
3019  ***     33      0      0      9   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id
      ***     33      0      0      9   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++
3032  ***     33      9      0      0   not defined $$args{'recurse'} or $level < $$args{'recurse'}
3202  ***      0      0      0      0   $master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1
3223  ***     66      4      8      0   $$self{'sths'}{$dbh}{'SLAVE_STATUS'} ||= $dbh->prepare('SHOW SLAVE STATUS')
3242  ***      0      0      0      0   $$self{'sths'}{$dbh}{'MASTER_STATUS'} ||= $dbh->prepare('SHOW MASTER STATUS')
3266  ***      0      0      0      0   $ms ||= $self->get_master_status($master)
3273  ***      0      0      0      0   $stat eq 'NULL' or $stat < 0 and not $timeoutok
3285  ***      0      0      0      0   $$self{'sths'}{$dbh}{'STOP_SLAVE'} ||= $dbh->prepare('STOP SLAVE')
3300  ***      0      0      0      0   $$self{'sths'}{$dbh}{'START_SLAVE'} ||= $dbh->prepare('START SLAVE')
3368  ***      0      0      0      0   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status)
      ***      0      0      0      0   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0
3429  ***      0      0      0      0   $self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0
3467  ***      0      0      0      0   $self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0
3521  ***      0      0      0      0   $self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0
3603  ***      0      0      0      0   $$query{'Command'} || $$query{'command'}
3607  ***      0      0      0      0   $$query{'User'} || $$query{'user'}
3608  ***      0      0      0      0   $$query{'State'} || $$query{'state'}
3824  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
3898  ***     33     15      0      0   @permit_dbs or @reject_dbs
      ***     33     15      0      0   @permit_dbs or @reject_dbs or @dbs_regex
      ***     33     15      0      0   @permit_dbs or @reject_dbs or @dbs_regex or @reject_dbs_regex
3908  ***     33     15      0      0   $o->has('tables') or $o->has('ignore-tables')
      ***     33     15      0      0   $o->has('tables') or $o->has('ignore-tables') or $o->has('ignore-tables-regex')
3988  ***     66      1     14      0   $o->has('engines') and $o->get('engines') or $o->has('ignore-engines') and $o->get('ignore-engines')
4007  ***     66     14      0      1   @permit_tbls or @reject_tbls
      ***     66     14      0      1   @permit_tbls or @reject_tbls or @tbls_regex
      ***     66     14      0      1   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex
      ***     66     14      1      0   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs
      ***     33     15      0      0   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs or @reject_engs
4689         100      5      1      9   $o->get('quiet') or $o->get('explain')
             100      6      7      2   $o->get('quiet') or $o->get('explain') or $o->get('checksum')
      ***     66     13      0      2   $o->get('quiet') or $o->get('explain') or $o->get('checksum') or $o->get('resume')
4866  ***     33      0      0     13   $num_chunks > 1 || $final_o->get('single-chunk')
4906  ***     33      0      3      0   $hosts[0]{'dbh'} ||= $dbh
4942  ***      0      0      0      0   $$host{'dbh'} ||= get_cxn($host, %args)
4956  ***     33     10      0      0   @hosts == 1 or defined $pid and $pid == 0
4988  ***      0      0      0      0   $exit_status ||= $CHILD_ERROR >> 8
5147  ***     33      0      0     15   $o->get('where') || $o->get('since')
5550  ***     33      0      0     10   not $is_master or not $checksum_table_data
5719  ***      0      0      0      0   $final_o->get('where') or $final_o->get('since')
5744  ***     33      0      0      2   not defined $msg or $o->get('quiet') and $EVAL_ERROR =~ /: Table .*? doesn't exist|Deadlock found/
5776  ***     66      6      0      6   not defined $lag or $lag > $max_lag


Covered Subroutines
-------------------

Subroutine                   Count Location                                                         
---------------------------- ----- -----------------------------------------------------------------
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1767
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1768
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1769
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1770
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1779
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2116
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2117
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2119
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2121
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2170
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2171
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2173
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2175
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:22  
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:23  
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2481
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2482
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2486
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2487
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2488
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2489
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2494
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2909
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2910
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2911
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2913
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2977
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2978
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2982
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2983
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2984
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2988
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3669
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3670
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3672
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3673
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3675
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3852
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3853
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3855
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3856
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3861
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:39  
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:40  
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:41  
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4143
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4144
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4145
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4146
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4150
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:42  
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:432 
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:433 
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:434 
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:435 
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:437 
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:47  
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:814 
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:815 
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:817 
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:818 
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:819 
BEGIN                           27 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:821 
DSNParser                       15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:948 
__ANON__                        86 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1257
__ANON__                        30 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4065
__ANON__                        30 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4104
__ANON__                         9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4344
__ANON__                       120 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:908 
_check_opts                     15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1300
_find_slaves_by_hosts            9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3098
_get_participants               45 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1157
_make_filter                    88 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4109
_parse_attribs                 945 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1734
_parse_specs                    15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1047
_pod_to_specs                   30 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:958 
_read_config_file               60 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1633
_set_option                     86 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1203
_use_db                         30 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2267
_validate_type                 945 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1373
best_algorithm                  15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:501 
check_repl_table                15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5234
check_table                     10 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:198 
checksum_chunks                 15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4828
checksum_tables                 15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4624
choose_hash_func                12 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:542 
clone                           15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1686
copy                             2 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2075
determine_checksum_strat        15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5131
do_checksum                      3 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5677
do_tbl                          10 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5497
do_tbl_replicate                 3 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5392
do_var_crc                       7 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5635
fill_in_dsn                     17 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1937
find_chunk_columns              15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2512
find_slave_hosts                 9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3048
get                           1316 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1442
get_all_tbls_info               15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4496
get_crc_type                    12 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:481 
get_crc_wid                     12 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:469 
get_create_table                15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2286
get_cxn                         17 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5614
get_cxn_params                  61 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1915
get_db_itr                      15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4044
get_dbh                         61 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1949
get_defaults_files              15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:953 
get_engine                      30 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:263 
get_final_opts                  15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5027
get_first_chunkable_column      15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2680
get_keys                        15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:270 
get_opts                        15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1220
get_slave_lag                   12 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3569
get_slave_status                12 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3221
get_specs                       15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:893 
get_tbl_itr                     15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4070
got                             65 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1450
has                            615 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1458
inject_chunks                   10 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2790
is_hash_algorithm               15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:537 
literal_like                    10 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2957
main                            15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4169
make_checksum_query             15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:713 
make_filter                     15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3877
make_row_checksum               12 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:639 
make_xor_slices                  8 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:610 
new                             41 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1782
new                             18 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2124
new                             15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2202
new                             15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2497
new                             15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2916
new                             15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2991
new                             15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3864
new                             15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:446 
new                             15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:51  
new                             30 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:826 
optimize_xor                     2 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:569 
parse                           78 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1818
parse                           57 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2129
parse                           15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:62  
parse_options                   17 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1874
print_err                        2 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5743
prop                           237 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1809
quote                          117 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2921
read_para_after                 15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1667
recurse_to_slaves                9 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2997
save_tbl_to_checksum            15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4535
set                             13 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1464
set_filter                      15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4037
split_unquote                   20 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2946
unique                          15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5737
usage_or_errors                 15 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1500
version_ge                      40 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2136
wait_for_slaves                  5 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5763

Uncovered Subroutines
---------------------

Subroutine                   Count Location                                                         
---------------------------- ----- -----------------------------------------------------------------
DESTROY                          0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3823
__ANON__                         0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4404
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1744
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2093
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2147
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2460
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2886
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3645
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3829
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:409 
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:4120
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5789
_d                               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:791 
_find_slaves_by_processlist      0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3078
_make_PID_file                   0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3788
_parse_size                      0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1709
_remove_PID_file                 0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3810
already_checksummed              0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5383
as_string                        0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1887
calculate_chunks                 0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2575
catchup_to_master                0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3308
catchup_to_same_pos              0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3349
change_master_to                 0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3378
check_PID_file                   0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3747
crc32                            0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:455 
create_repl_table                0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5299
daemonize                        0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3696
descr                            0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1488
detach_slave                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3530
disconnect                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2058
do_count                         0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5705
dump                             0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2210
errors                           0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1478
eval_expr                        0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5117
find_best_index                  0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:152 
find_possible_keys               0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:170 
find_replication_differences     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:770 
get_columns                      0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2324
get_connected_slaves             0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3125
get_databases                    0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2389
get_defaults                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1193
get_fks                          0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:337 
get_groups                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1198
get_hostname                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2048
get_master_dsn                   0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3214
get_master_status                0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3240
get_range_statistics             0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2726
get_table_list                   0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2434
get_table_status                 0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2408
get_tmp_table                    0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2344
get_triggers                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2355
has_slave_updates                0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3545
is_master_of                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3176
is_replication_thread            0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3594
is_temporal                      0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5057
make_PID_file                    0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3778
make_sibling_of_master           0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3389
make_slave_of_sibling            0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3437
make_slave_of_uncle              0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3476
new                              0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3678
opts                             0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1169
parse_resume_file                0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5352
pos_cmp                          0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3575
pos_to_string                    0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3639
print_active_handles             0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2064
print_errors                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1513
print_inconsistent_tbls          0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5062
print_usage                      0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1523
prompt                           0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1483
prompt_noecho                    0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1598
quote                            0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2785
quote_val                        0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2929
range_date                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2846
range_datetime                   0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2853
range_num                        0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2820
range_time                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2839
range_timestamp                  0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2861
read_repl_table                  0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5325
remove_auto_increment            0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:366 
remove_secondary_indexes         0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:372 
repl_posn                        0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3553
save_error                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1473
save_inconsistent_tbls           0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5088
set_defaults                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1181
short_host                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3580
short_opts                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1175
size_to_rows                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2689
slave_is_running                 0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3540
sort_indexes                     0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:133 
start_slave                      0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3292
stop_slave                       0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3284
timestampdiff                    0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:2868
usage                            0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:1898
verify_checksum_compat           0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:5195
wait_for_master                  0 /home/daniel/dev/maatkit/mk-table-checksum/mk-table-checksum:3261


