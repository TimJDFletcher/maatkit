---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...logger/mk-deadlock-logger   15.2    3.1    8.5   36.7    n/a  100.0   12.3
Total                          15.2    3.1    8.5   36.7    n/a  100.0   12.3
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:21:22 2010
Finish:       Thu Jan 28 22:21:22 2010

Run:          ./101_basics.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:21:23 2010
Finish:       Thu Jan 28 22:21:26 2010

Run:          ./101_basics.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:21:23 2010
Finish:       Thu Jan 28 22:21:26 2010

Run:          ./101_basics.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:21:23 2010
Finish:       Thu Jan 28 22:21:29 2010

Run:          ./102_option_sanity.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:21:31 2010
Finish:       Thu Jan 28 22:21:31 2010

Run:          ./103_clear_deadlocks.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:21:33 2010
Finish:       Thu Jan 28 22:21:34 2010

Run:          ./104_standard_options.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:21:37 2010
Finish:       Thu Jan 28 22:21:41 2010

Run:          ./105_create_dest_table.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:21:44 2010
Finish:       Thu Jan 28 22:21:45 2010

/home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This is mk-deadlock-logger, a program that extracts and saves a summary of
4                                                     # the last deadlock recorded in MySQL.
5                                                     #
6                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
7                                                     # Feedback and improvements are welcome.
8                                                     #
9                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
10                                                    # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
11                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
12                                                    #
13                                                    # This program is free software; you can redistribute it and/or modify it under
14                                                    # the terms of the GNU General Public License as published by the Free Software
15                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
16                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
17                                                    # licenses.
18                                                    #
19                                                    # You should have received a copy of the GNU General Public License along with
20                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
21                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
22                                                    
23             6                    6            53   use strict;
               6                                 19   
               6                                 66   
24             6                    6            53   use warnings FATAL => 'all';
               6                                 15   
               6                                 79   
25                                                    
26                                                    our $VERSION = '@VERSION@';
27                                                    our $DISTRIB = '@DISTRIB@';
28                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5425 $ =~ m/(\d+)/g, 0));
29                                                    
30                                                    # ###########################################################################
31                                                    # OptionParser package 5266
32                                                    # ###########################################################################
33                                                    package OptionParser;
34                                                    
35             6                    6            60   use strict;
               6                                 21   
               6                                 37   
36             6                    6            55   use warnings FATAL => 'all';
               6                                 15   
               6                                 36   
37                                                    
38             6                    6           103   use Getopt::Long;
               6                                 23   
               6                                 37   
39             6                    6            45   use List::Util qw(max);
               6                                 13   
               6                                 64   
40             6                    6            41   use English qw(-no_match_vars);
               6                                 16   
               6                                 38   
41                                                    
42    ***      6            50      6            38   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 17   
               6                                101   
43                                                    
44                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
45                                                    
46                                                    my %attributes = (
47                                                       'type'       => 1,
48                                                       'short form' => 1,
49                                                       'group'      => 1,
50                                                       'default'    => 1,
51                                                       'cumulative' => 1,
52                                                       'negatable'  => 1,
53                                                    );
54                                                    
55                                                    sub new {
56    ***      0                    0             0      my ( $class, %args ) = @_;
57    ***      0                                  0      foreach my $arg ( qw(description) ) {
58    ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
59                                                       }
60    ***      0                                  0      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
61    ***      0             0                    0      $program_name ||= $PROGRAM_NAME;
62    ***      0             0                    0      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                    0                        
      ***                    0                        
63                                                    
64    ***      0      0      0                    0      my $self = {
      ***                    0                        
65                                                          description    => $args{description},
66                                                          prompt         => $args{prompt} || '<options>',
67                                                          strict         => (exists $args{strict} ? $args{strict} : 1),
68                                                          dp             => $args{dp}     || undef,
69                                                          program_name   => $program_name,
70                                                          opts           => {},
71                                                          got_opts       => 0,
72                                                          short_opts     => {},
73                                                          defaults       => {},
74                                                          groups         => {},
75                                                          allowed_groups => {},
76                                                          errors         => [],
77                                                          rules          => [],  # desc of rules for --help
78                                                          mutex          => [],  # rule: opts are mutually exclusive
79                                                          atleast1       => [],  # rule: at least one opt is required
80                                                          disables       => {},  # rule: opt disables other opts 
81                                                          defaults_to    => {},  # rule: opt defaults to value of other opt
82                                                          default_files  => [
83                                                             "/etc/maatkit/maatkit.conf",
84                                                             "/etc/maatkit/$program_name.conf",
85                                                             "$home/.maatkit.conf",
86                                                             "$home/.$program_name.conf",
87                                                          ],
88                                                       };
89    ***      0                                  0      return bless $self, $class;
90                                                    }
91                                                    
92                                                    sub get_specs {
93    ***      0                    0             0      my ( $self, $file ) = @_;
94    ***      0                                  0      my @specs = $self->_pod_to_specs($file);
95    ***      0                                  0      $self->_parse_specs(@specs);
96    ***      0                                  0      return;
97                                                    }
98                                                    
99                                                    sub get_defaults_files {
100   ***      0                    0             0      my ( $self ) = @_;
101   ***      0                                  0      return @{$self->{default_files}};
      ***      0                                  0   
102                                                   }
103                                                   
104                                                   sub _pod_to_specs {
105   ***      0                    0             0      my ( $self, $file ) = @_;
106   ***      0             0                    0      $file ||= __FILE__;
107   ***      0      0                           0      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
108                                                   
109   ***      0                                  0      my %types = (
110                                                         string => 's', # standard Getopt type
111                                                         'int'  => 'i', # standard Getopt type
112                                                         float  => 'f', # standard Getopt type
113                                                         Hash   => 'H', # hash, formed from a comma-separated list
114                                                         hash   => 'h', # hash as above, but only if a value is given
115                                                         Array  => 'A', # array, similar to Hash
116                                                         array  => 'a', # array, similar to hash
117                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
118                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
119                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
120                                                      );
121   ***      0                                  0      my @specs = ();
122   ***      0                                  0      my @rules = ();
123   ***      0                                  0      my $para;
124                                                   
125   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
126   ***      0                                  0      while ( $para = <$fh> ) {
127   ***      0      0                           0         next unless $para =~ m/^=head1 OPTIONS/;
128   ***      0                                  0         last;
129                                                      }
130                                                   
131   ***      0                                  0      while ( $para = <$fh> ) {
132   ***      0      0                           0         last if $para =~ m/^=over/;
133   ***      0                                  0         chomp $para;
134   ***      0                                  0         $para =~ s/\s+/ /g;
135   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
136   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
137   ***      0                                  0         push @rules, $para;
138                                                      }
139                                                   
140   ***      0      0                           0      die 'POD has no OPTIONS section' unless $para;
141                                                   
142   ***      0                                  0      do {
143   ***      0      0                           0         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
144   ***      0                                  0            chomp $para;
145   ***      0                                  0            MKDEBUG && _d($para);
146   ***      0                                  0            my %attribs;
147                                                   
148   ***      0                                  0            $para = <$fh>; # read next paragraph, possibly attributes
149                                                   
150   ***      0      0                           0            if ( $para =~ m/: / ) { # attributes
151   ***      0                                  0               $para =~ s/\s+\Z//g;
152   ***      0                                  0               %attribs = map {
153   ***      0                                  0                     my ( $attrib, $val) = split(/: /, $_);
154   ***      0      0                           0                     die "Unrecognized attribute for --$option: $attrib"
155                                                                        unless $attributes{$attrib};
156   ***      0                                  0                     ($attrib, $val);
157                                                                  } split(/; /, $para);
158   ***      0      0                           0               if ( $attribs{'short form'} ) {
159   ***      0                                  0                  $attribs{'short form'} =~ s/-//;
160                                                               }
161   ***      0                                  0               $para = <$fh>; # read next paragraph, probably short help desc
162                                                            }
163                                                            else {
164   ***      0                                  0               MKDEBUG && _d('Option has no attributes');
165                                                            }
166                                                   
167   ***      0                                  0            $para =~ s/\s+\Z//g;
168   ***      0                                  0            $para =~ s/\s+/ /g;
169   ***      0                                  0            $para =~ s/$POD_link_re/$1/go;
170                                                   
171   ***      0                                  0            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
172   ***      0                                  0            MKDEBUG && _d('Short help:', $para);
173                                                   
174   ***      0      0                           0            die "No description after option spec $option" if $para =~ m/^=item/;
175                                                   
176   ***      0      0                           0            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
177   ***      0                                  0               $option = $base_option;
178   ***      0                                  0               $attribs{'negatable'} = 1;
179                                                            }
180                                                   
181   ***      0      0                           0            push @specs, {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
182                                                               spec  => $option
183                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
184                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
185                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
186                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
187                                                               desc  => $para
188                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
189                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
190                                                            };
191                                                         }
192   ***      0                                  0         while ( $para = <$fh> ) {
193   ***      0      0                           0            last unless $para;
194                                                   
195                                                   
196   ***      0      0                           0            if ( $para =~ m/^=head1/ ) {
197   ***      0                                  0               $para = undef; # Can't 'last' out of a do {} block.
198   ***      0                                  0               last;
199                                                            }
200   ***      0      0                           0            last if $para =~ m/^=item --/;
201                                                         }
202                                                      } while ( $para );
203                                                   
204   ***      0      0                           0      die 'No valid specs in POD OPTIONS' unless @specs;
205                                                   
206   ***      0                                  0      close $fh;
207   ***      0                                  0      return @specs, @rules;
208                                                   }
209                                                   
210                                                   sub _parse_specs {
211   ***      0                    0             0      my ( $self, @specs ) = @_;
212   ***      0                                  0      my %disables; # special rule that requires deferred checking
213                                                   
214   ***      0                                  0      foreach my $opt ( @specs ) {
215   ***      0      0                           0         if ( ref $opt ) { # It's an option spec, not a rule.
216                                                            MKDEBUG && _d('Parsing opt spec:',
217   ***      0                                  0               map { ($_, '=>', $opt->{$_}) } keys %$opt);
218                                                   
219   ***      0                                  0            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
220   ***      0      0                           0            if ( !$long ) {
221   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
222                                                            }
223   ***      0                                  0            $opt->{long} = $long;
224                                                   
225   ***      0      0                           0            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
226   ***      0                                  0            $self->{opts}->{$long} = $opt;
227                                                   
228   ***      0      0                           0            if ( length $long == 1 ) {
229   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
230   ***      0                                  0               $self->{short_opts}->{$long} = $long;
231                                                            }
232                                                   
233   ***      0      0                           0            if ( $short ) {
234   ***      0      0                           0               die "Duplicate short option -$short"
235                                                                  if exists $self->{short_opts}->{$short};
236   ***      0                                  0               $self->{short_opts}->{$short} = $long;
237   ***      0                                  0               $opt->{short} = $short;
238                                                            }
239                                                            else {
240   ***      0                                  0               $opt->{short} = undef;
241                                                            }
242                                                   
243   ***      0      0                           0            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
244   ***      0      0                           0            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
245   ***      0      0                           0            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
246                                                   
247   ***      0             0                    0            $opt->{group} ||= 'default';
248   ***      0                                  0            $self->{groups}->{ $opt->{group} }->{$long} = 1;
249                                                   
250   ***      0                                  0            $opt->{value} = undef;
251   ***      0                                  0            $opt->{got}   = 0;
252                                                   
253   ***      0                                  0            my ( $type ) = $opt->{spec} =~ m/=(.)/;
254   ***      0                                  0            $opt->{type} = $type;
255   ***      0                                  0            MKDEBUG && _d($long, 'type:', $type);
256                                                   
257   ***      0      0      0                    0            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                    0                        
258   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
259                                                                  . "was given when this OptionParser object was created";
260                                                            }
261                                                   
262   ***      0      0      0                    0            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
263                                                   
264   ***      0      0                           0            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
265   ***      0      0                           0               $self->{defaults}->{$long} = defined $def ? $def : 1;
266   ***      0                                  0               MKDEBUG && _d($long, 'default:', $def);
267                                                            }
268                                                   
269   ***      0      0                           0            if ( $long eq 'config' ) {
270   ***      0                                  0               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
271                                                            }
272                                                   
273   ***      0      0                           0            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
274   ***      0                                  0               $disables{$long} = $dis;
275   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
276                                                            }
277                                                   
278   ***      0                                  0            $self->{opts}->{$long} = $opt;
279                                                         }
280                                                         else { # It's an option rule, not a spec.
281   ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
282   ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
283   ***      0                                  0            my @participants = $self->_get_participants($opt);
284   ***      0                                  0            my $rule_ok = 0;
285                                                   
286   ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
287   ***      0                                  0               $rule_ok = 1;
288   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
289   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
290                                                            }
291   ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
292   ***      0                                  0               $rule_ok = 1;
293   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
294   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
295                                                            }
296   ***      0      0                           0            if ( $opt =~ m/default to/ ) {
297   ***      0                                  0               $rule_ok = 1;
298   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
299   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
300                                                            }
301   ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
302   ***      0                                  0               $rule_ok = 1;
303   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
304   ***      0                                  0               my @groups = split(',', $groups);
305   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
306   ***      0                                  0                  s/\s+//;
307   ***      0                                  0                  $_ => 1;
308                                                               } @groups;
309                                                            }
310                                                   
311   ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
312                                                         }
313                                                      }
314                                                   
315   ***      0                                  0      foreach my $long ( keys %disables ) {
316   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
317   ***      0                                  0         $self->{disables}->{$long} = \@participants;
318   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
319                                                      }
320                                                   
321   ***      0                                  0      return; 
322                                                   }
323                                                   
324                                                   sub _get_participants {
325   ***      0                    0             0      my ( $self, $str ) = @_;
326   ***      0                                  0      my @participants;
327   ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
328   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
329                                                            unless exists $self->{opts}->{$long};
330   ***      0                                  0         push @participants, $long;
331                                                      }
332   ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
333   ***      0                                  0      return @participants;
334                                                   }
335                                                   
336                                                   sub opts {
337   ***      0                    0             0      my ( $self ) = @_;
338   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
339   ***      0                                  0      return %opts;
340                                                   }
341                                                   
342                                                   sub short_opts {
343   ***      0                    0             0      my ( $self ) = @_;
344   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
345   ***      0                                  0      return %short_opts;
346                                                   }
347                                                   
348                                                   sub set_defaults {
349   ***      0                    0             0      my ( $self, %defaults ) = @_;
350   ***      0                                  0      $self->{defaults} = {};
351   ***      0                                  0      foreach my $long ( keys %defaults ) {
352   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
353                                                            unless exists $self->{opts}->{$long};
354   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
355   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
356                                                      }
357   ***      0                                  0      return;
358                                                   }
359                                                   
360                                                   sub get_defaults {
361   ***      0                    0             0      my ( $self ) = @_;
362   ***      0                                  0      return $self->{defaults};
363                                                   }
364                                                   
365                                                   sub get_groups {
366   ***      0                    0             0      my ( $self ) = @_;
367   ***      0                                  0      return $self->{groups};
368                                                   }
369                                                   
370                                                   sub _set_option {
371   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
372   ***      0      0                           0      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***             0                               
373                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
374                                                               : die "Getopt::Long gave a nonexistent option: $opt";
375                                                   
376   ***      0                                  0      $opt = $self->{opts}->{$long};
377   ***      0      0                           0      if ( $opt->{is_cumulative} ) {
378   ***      0                                  0         $opt->{value}++;
379                                                      }
380                                                      else {
381   ***      0                                  0         $opt->{value} = $val;
382                                                      }
383   ***      0                                  0      $opt->{got} = 1;
384   ***      0                                  0      MKDEBUG && _d('Got option', $long, '=', $val);
385                                                   }
386                                                   
387                                                   sub get_opts {
388   ***      0                    0             0      my ( $self ) = @_; 
389                                                   
390   ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
391   ***      0                                  0         $self->{opts}->{$long}->{got} = 0;
392   ***      0      0                           0         $self->{opts}->{$long}->{value}
      ***             0                               
393                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
394                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
395                                                            : undef;
396                                                      }
397   ***      0                                  0      $self->{got_opts} = 0;
398                                                   
399   ***      0                                  0      $self->{errors} = [];
400                                                   
401   ***      0      0      0                    0      if ( @ARGV && $ARGV[0] eq "--config" ) {
402   ***      0                                  0         shift @ARGV;
403   ***      0                                  0         $self->_set_option('config', shift @ARGV);
404                                                      }
405   ***      0      0                           0      if ( $self->has('config') ) {
406   ***      0                                  0         my @extra_args;
407   ***      0                                  0         foreach my $filename ( split(',', $self->get('config')) ) {
408   ***      0                                  0            eval {
409   ***      0                                  0               push @extra_args, $self->_read_config_file($filename);
410                                                            };
411   ***      0      0                           0            if ( $EVAL_ERROR ) {
412   ***      0      0                           0               if ( $self->got('config') ) {
413   ***      0                                  0                  die $EVAL_ERROR;
414                                                               }
415                                                               elsif ( MKDEBUG ) {
416                                                                  _d($EVAL_ERROR);
417                                                               }
418                                                            }
419                                                         }
420   ***      0                                  0         unshift @ARGV, @extra_args;
421                                                      }
422                                                   
423   ***      0                                  0      Getopt::Long::Configure('no_ignore_case', 'bundling');
424                                                      GetOptions(
425   ***      0                    0             0         map    { $_->{spec} => sub { $self->_set_option(@_); } }
      ***      0                                  0   
      ***      0                                  0   
426   ***      0                                  0         grep   { $_->{long} ne 'config' } # --config is handled specially above.
427   ***      0      0                           0         values %{$self->{opts}}
428                                                      ) or $self->save_error('Error parsing options');
429                                                   
430   ***      0      0      0                    0      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
431   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
432                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
433                                                               or die "Cannot print: $OS_ERROR";
434   ***      0                                  0         exit 0;
435                                                      }
436                                                   
437   ***      0      0      0                    0      if ( @ARGV && $self->{strict} ) {
438   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
439                                                      }
440                                                   
441   ***      0                                  0      foreach my $mutex ( @{$self->{mutex}} ) {
      ***      0                                  0   
442   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
443   ***      0      0                           0         if ( @set > 1 ) {
444   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
445   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
446                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
447                                                                    . ' are mutually exclusive.';
448   ***      0                                  0            $self->save_error($err);
449                                                         }
450                                                      }
451                                                   
452   ***      0                                  0      foreach my $required ( @{$self->{atleast1}} ) {
      ***      0                                  0   
453   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
454   ***      0      0                           0         if ( @set == 0 ) {
455   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
456   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
457                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
458   ***      0                                  0            $self->save_error("Specify at least one of $err");
459                                                         }
460                                                      }
461                                                   
462   ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
463   ***      0                                  0         my $opt = $self->{opts}->{$long};
464   ***      0      0                           0         if ( $opt->{got} ) {
      ***             0                               
465   ***      0      0                           0            if ( exists $self->{disables}->{$long} ) {
466   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
467   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
468   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
469                                                                  'because', $long,'disables them');
470                                                            }
471                                                   
472   ***      0      0                           0            if ( exists $self->{allowed_groups}->{$long} ) {
473                                                   
474   ***      0                                  0               my @restricted_groups = grep {
475   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
476   ***      0                                  0               } keys %{$self->{groups}};
477                                                   
478   ***      0                                  0               my @restricted_opts;
479   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
480   ***      0                                  0                  RESTRICTED_OPT:
481   ***      0                                  0                  foreach my $restricted_opt (
482                                                                     keys %{$self->{groups}->{$restricted_group}} )
483                                                                  {
484   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
485   ***      0      0                           0                     push @restricted_opts, $restricted_opt
486                                                                        if $self->{opts}->{$restricted_opt}->{got};
487                                                                  }
488                                                               }
489                                                   
490   ***      0      0                           0               if ( @restricted_opts ) {
491   ***      0                                  0                  my $err;
492   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
493   ***      0                                  0                     $err = "--$restricted_opts[0]";
494                                                                  }
495                                                                  else {
496   ***      0                                  0                     $err = join(', ',
497   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
498   ***      0                                  0                               grep { $_ } 
499                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
500                                                                            )
501                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
502                                                                  }
503   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
504                                                               }
505                                                            }
506                                                   
507                                                         }
508                                                         elsif ( $opt->{is_required} ) { 
509   ***      0                                  0            $self->save_error("Required option --$long must be specified");
510                                                         }
511                                                   
512   ***      0                                  0         $self->_validate_type($opt);
513                                                      }
514                                                   
515   ***      0                                  0      $self->{got_opts} = 1;
516   ***      0                                  0      return;
517                                                   }
518                                                   
519                                                   sub _validate_type {
520   ***      0                    0             0      my ( $self, $opt ) = @_;
521   ***      0      0      0                    0      return unless $opt && $opt->{type};
522   ***      0                                  0      my $val = $opt->{value};
523                                                   
524   ***      0      0      0                    0      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
      ***                    0                        
525   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
526   ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
527   ***      0      0                           0         if ( !$suffix ) {
528   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
529   ***      0             0                    0            $suffix = $s || 's';
530   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
531                                                               $opt->{long}, '(value:', $val, ')');
532                                                         }
533   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
534   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
535                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
536                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
537                                                                 :                  $num * 86400;   # Days
538   ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
539   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
540                                                         }
541                                                         else {
542   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
543                                                         }
544                                                      }
545                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
546   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
547   ***      0                                  0         my $prev = {};
548   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
549   ***      0      0                           0         if ( $from_key ) {
550   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
551   ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
552                                                         }
553   ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
554   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
555                                                      }
556                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
557   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
558   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
559   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
560   ***      0      0                           0         if ( defined $num ) {
561   ***      0      0                           0            if ( $factor ) {
562   ***      0                                  0               $num *= $factor_for{$factor};
563   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
564                                                                  'to num', $num, '* factor', $factor);
565                                                            }
566   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
567                                                         }
568                                                         else {
569   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
570                                                         }
571                                                      }
572                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
573   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
574                                                      }
575                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
576   ***      0             0                    0         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
577                                                      }
578                                                      else {
579   ***      0                                  0         MKDEBUG && _d('Nothing to validate for option',
580                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
581                                                      }
582                                                   
583   ***      0                                  0      return;
584                                                   }
585                                                   
586                                                   sub get {
587   ***      0                    0             0      my ( $self, $opt ) = @_;
588   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
589   ***      0      0      0                    0      die "Option $opt does not exist"
590                                                         unless $long && exists $self->{opts}->{$long};
591   ***      0                                  0      return $self->{opts}->{$long}->{value};
592                                                   }
593                                                   
594                                                   sub got {
595   ***      0                    0             0      my ( $self, $opt ) = @_;
596   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
597   ***      0      0      0                    0      die "Option $opt does not exist"
598                                                         unless $long && exists $self->{opts}->{$long};
599   ***      0                                  0      return $self->{opts}->{$long}->{got};
600                                                   }
601                                                   
602                                                   sub has {
603   ***      0                    0             0      my ( $self, $opt ) = @_;
604   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
605   ***      0      0                           0      return defined $long ? exists $self->{opts}->{$long} : 0;
606                                                   }
607                                                   
608                                                   sub set {
609   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
610   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
611   ***      0      0      0                    0      die "Option $opt does not exist"
612                                                         unless $long && exists $self->{opts}->{$long};
613   ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
614   ***      0                                  0      return;
615                                                   }
616                                                   
617                                                   sub save_error {
618   ***      0                    0             0      my ( $self, $error ) = @_;
619   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
620                                                   }
621                                                   
622                                                   sub errors {
623   ***      0                    0             0      my ( $self ) = @_;
624   ***      0                                  0      return $self->{errors};
625                                                   }
626                                                   
627                                                   sub prompt {
628   ***      0                    0             0      my ( $self ) = @_;
629   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
630                                                   }
631                                                   
632                                                   sub descr {
633   ***      0                    0             0      my ( $self ) = @_;
634   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
635                                                                 . "  For more details, please use the --help option, "
636                                                                 . "or try 'perldoc $PROGRAM_NAME' "
637                                                                 . "for complete documentation.";
638   ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
639   ***      0                                  0      $descr =~ s/ +$//mg;
640   ***      0                                  0      return $descr;
641                                                   }
642                                                   
643                                                   sub usage_or_errors {
644   ***      0                    0             0      my ( $self ) = @_;
645   ***      0      0                           0      if ( $self->{opts}->{help}->{got} ) {
      ***      0      0                           0   
646   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
647   ***      0                                  0         exit 0;
648                                                      }
649                                                      elsif ( scalar @{$self->{errors}} ) {
650   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
651   ***      0                                  0         exit 0;
652                                                      }
653   ***      0                                  0      return;
654                                                   }
655                                                   
656                                                   sub print_errors {
657   ***      0                    0             0      my ( $self ) = @_;
658   ***      0                                  0      my $usage = $self->prompt() . "\n";
659   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
660   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
661                                                                 . "\n";
662                                                      }
663   ***      0                                  0      return $usage . "\n" . $self->descr();
664                                                   }
665                                                   
666                                                   sub print_usage {
667   ***      0                    0             0      my ( $self ) = @_;
668   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
669   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
670                                                   
671   ***      0      0                           0      my $maxl = max(
672   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
673                                                         @opts);
674                                                   
675   ***      0      0                           0      my $maxs = max(0,
676   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
677   ***      0                                  0         values %{$self->{short_opts}});
678                                                   
679   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
680   ***      0                                  0      my $rcol = 80 - $lcol - 6;
681   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
682                                                   
683   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
684                                                   
685   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
686                                                   
687   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
688   ***      0                                  0      push @groups, 'default';
689                                                   
690   ***      0                                  0      foreach my $group ( reverse @groups ) {
691   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
692   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
693   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
694                                                            grep { $_->{group} eq $group }
695                                                            @opts )
696                                                         {
697   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
698   ***      0                                  0            my $short = $opt->{short};
699   ***      0                                  0            my $desc  = $opt->{desc};
700   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
701   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
702   ***      0             0                    0               $s    ||= 's';
703   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
704   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
705                                                                      . "d=days; if no suffix, $s is used.";
706                                                            }
707   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
708   ***      0                                  0            $desc =~ s/ +$//mg;
709   ***      0      0                           0            if ( $short ) {
710   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
711                                                            }
712                                                            else {
713   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
714                                                            }
715                                                         }
716                                                      }
717                                                   
718   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
719   ***      0                                  0         $usage .= "\nRules:\n\n";
720   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
721                                                      }
722   ***      0      0                           0      if ( $self->{dp} ) {
723   ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
724                                                      }
725   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
726   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
727   ***      0                                  0         my $val   = $opt->{value};
728   ***      0             0                    0         my $type  = $opt->{type} || '';
729   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
730   ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
731                                                                   : !defined $val             ? '(No value)'
732                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
733                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
734                                                                   : $type =~ m/A|a/           ? join(',', @$val)
735                                                                   :                             $val;
736   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
737                                                      }
738   ***      0                                  0      return $usage;
739                                                   }
740                                                   
741                                                   sub prompt_noecho {
742   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
743   ***      0                                  0      my ( $prompt ) = @_;
744   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
745   ***      0      0                           0      print $prompt
746                                                         or die "Cannot print: $OS_ERROR";
747   ***      0                                  0      my $response;
748   ***      0                                  0      eval {
749   ***      0                                  0         require Term::ReadKey;
750   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
751   ***      0                                  0         chomp($response = <STDIN>);
752   ***      0                                  0         Term::ReadKey::ReadMode('normal');
753   ***      0      0                           0         print "\n"
754                                                            or die "Cannot print: $OS_ERROR";
755                                                      };
756   ***      0      0                           0      if ( $EVAL_ERROR ) {
757   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
758                                                      }
759   ***      0                                  0      return $response;
760                                                   }
761                                                   
762                                                   if ( MKDEBUG ) {
763                                                      print '# ', $^X, ' ', $], "\n";
764                                                      my $uname = `uname -a`;
765                                                      if ( $uname ) {
766                                                         $uname =~ s/\s+/ /g;
767                                                         print "# $uname\n";
768                                                      }
769                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
770                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
771                                                         ($main::SVN_REV || ''), __LINE__);
772                                                      print('# Arguments: ',
773                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
774                                                   }
775                                                   
776                                                   sub _read_config_file {
777   ***      0                    0             0      my ( $self, $filename ) = @_;
778   ***      0      0                           0      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
779   ***      0                                  0      my @args;
780   ***      0                                  0      my $prefix = '--';
781   ***      0                                  0      my $parse  = 1;
782                                                   
783                                                      LINE:
784   ***      0                                  0      while ( my $line = <$fh> ) {
785   ***      0                                  0         chomp $line;
786   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
787   ***      0                                  0         $line =~ s/\s+#.*$//g;
788   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
789   ***      0      0                           0         if ( $line eq '--' ) {
790   ***      0                                  0            $prefix = '';
791   ***      0                                  0            $parse  = 0;
792   ***      0                                  0            next LINE;
793                                                         }
794   ***      0      0      0                    0         if ( $parse
      ***             0                               
795                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
796                                                         ) {
797   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
798                                                         }
799                                                         elsif ( $line =~ m/./ ) {
800   ***      0                                  0            push @args, $line;
801                                                         }
802                                                         else {
803   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
804                                                         }
805                                                      }
806   ***      0                                  0      close $fh;
807   ***      0                                  0      return @args;
808                                                   }
809                                                   
810                                                   sub read_para_after {
811   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
812   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
813   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
814   ***      0                                  0      my $para;
815   ***      0                                  0      while ( $para = <$fh> ) {
816   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
817   ***      0                                  0         last;
818                                                      }
819   ***      0                                  0      while ( $para = <$fh> ) {
820   ***      0      0                           0         next unless $para =~ m/$regex/;
821   ***      0                                  0         last;
822                                                      }
823   ***      0                                  0      $para = <$fh>;
824   ***      0                                  0      chomp($para);
825   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
826   ***      0                                  0      return $para;
827                                                   }
828                                                   
829                                                   sub clone {
830   ***      0                    0             0      my ( $self ) = @_;
831                                                   
832   ***      0                                  0      my %clone = map {
833   ***      0                                  0         my $hashref  = $self->{$_};
834   ***      0                                  0         my $val_copy = {};
835   ***      0                                  0         foreach my $key ( keys %$hashref ) {
836   ***      0                                  0            my $ref = ref $hashref->{$key};
837   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
838   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
839   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
840                                                                              : $hashref->{$key};
841                                                         }
842   ***      0                                  0         $_ => $val_copy;
843                                                      } qw(opts short_opts defaults);
844                                                   
845   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
846   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
847                                                      }
848                                                   
849   ***      0                                  0      return bless \%clone;     
850                                                   }
851                                                   
852                                                   sub _d {
853   ***      0                    0             0      my ($package, undef, $line) = caller 0;
854   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
855   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
856                                                           @_;
857   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
858                                                   }
859                                                   
860                                                   1;
861                                                   
862                                                   # ###########################################################################
863                                                   # End OptionParser package
864                                                   # ###########################################################################
865                                                   
866                                                   # ###########################################################################
867                                                   # VersionParser package 5266
868                                                   # ###########################################################################
869                                                   package VersionParser;
870                                                   
871            6                    6            58   use strict;
               6                                 18   
               6                                 55   
872            6                    6            53   use warnings FATAL => 'all';
               6                                 18   
               6                                 46   
873                                                   
874            6                    6            37   use English qw(-no_match_vars);
               6                                 14   
               6                                 42   
875                                                   
876   ***      6            50      6            38   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 16   
               6                                133   
877                                                   
878                                                   sub new {
879   ***      0                    0             0      my ( $class ) = @_;
880   ***      0                                  0      bless {}, $class;
881                                                   }
882                                                   
883                                                   sub parse {
884   ***      0                    0             0      my ( $self, $str ) = @_;
885   ***      0                                  0      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
886   ***      0                                  0      MKDEBUG && _d($str, 'parses to', $result);
887   ***      0                                  0      return $result;
888                                                   }
889                                                   
890                                                   sub version_ge {
891   ***      0                    0             0      my ( $self, $dbh, $target ) = @_;
892   ***      0      0                           0      if ( !$self->{$dbh} ) {
893   ***      0                                  0         $self->{$dbh} = $self->parse(
894                                                            $dbh->selectrow_array('SELECT VERSION()'));
895                                                      }
896   ***      0      0                           0      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
897   ***      0                                  0      MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
898   ***      0                                  0      return $result;
899                                                   }
900                                                   
901                                                   sub _d {
902   ***      0                    0             0      my ($package, undef, $line) = caller 0;
903   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
904   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
905                                                           @_;
906   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
907                                                   }
908                                                   
909                                                   1;
910                                                   
911                                                   # ###########################################################################
912                                                   # End VersionParser package
913                                                   # ###########################################################################
914                                                   
915                                                   # ###########################################################################
916                                                   # Quoter package 5266
917                                                   # ###########################################################################
918            6                    6            42   use strict;
               6                                 13   
               6                                 42   
919            6                    6            43   use warnings FATAL => 'all';
               6                                 13   
               6                                 30   
920                                                   
921                                                   package Quoter;
922                                                   
923            6                    6            36   use English qw(-no_match_vars);
               6                                 17   
               6                                 25   
924                                                   
925   ***      6            50      6            37   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 16   
               6                                 79   
926                                                   
927                                                   sub new {
928   ***      0                    0             0      my ( $class ) = @_;
929   ***      0                                  0      bless {}, $class;
930                                                   }
931                                                   
932                                                   sub quote {
933   ***      0                    0             0      my ( $self, @vals ) = @_;
934   ***      0                                  0      foreach my $val ( @vals ) {
935   ***      0                                  0         $val =~ s/`/``/g;
936                                                      }
937   ***      0                                  0      return join('.', map { '`' . $_ . '`' } @vals);
      ***      0                                  0   
938                                                   }
939                                                   
940                                                   sub quote_val {
941   ***      0                    0             0      my ( $self, $val, $is_numeric ) = @_;
942                                                   
943   ***      0      0                           0      return 'NULL' unless defined $val;  # undef = NULL
944   ***      0      0                           0      return "''" if $val eq '';          # blank string = ''
945                                                   
946   ***      0      0                           0      if ( !defined $is_numeric ) {
947   ***      0      0                           0         $is_numeric = $val =~ m/^0|\D/ ? 0 : 1;
948                                                      }
949                                                   
950   ***      0      0                           0      return $val if $is_numeric;
951                                                   
952   ***      0                                  0      $val =~ s/(['\\])/\\$1/g;
953   ***      0                                  0      return "'$val'";
954                                                   }
955                                                   
956                                                   sub split_unquote {
957   ***      0                    0             0      my ( $self, $db_tbl, $default_db ) = @_;
958   ***      0                                  0      $db_tbl =~ s/`//g;
959   ***      0                                  0      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
960   ***      0      0                           0      if ( !$tbl ) {
961   ***      0                                  0         $tbl = $db;
962   ***      0                                  0         $db  = $default_db;
963                                                      }
964   ***      0                                  0      return ($db, $tbl);
965                                                   }
966                                                   
967                                                   sub literal_like {
968   ***      0                    0             0      my ( $self, $like ) = @_;
969   ***      0      0                           0      return unless $like;
970   ***      0                                  0      $like =~ s/([%_])/\\$1/g;
971   ***      0                                  0      return "'$like'";
972                                                   }
973                                                   
974                                                   1;
975                                                   
976                                                   # ###########################################################################
977                                                   # End Quoter package
978                                                   # ###########################################################################
979                                                   
980                                                   # ###########################################################################
981                                                   # DSNParser package 5266
982                                                   # ###########################################################################
983                                                   package DSNParser;
984                                                   
985            6                    6            44   use strict;
               6                                 14   
               6                                 31   
986            6                    6            35   use warnings FATAL => 'all';
               6                                 14   
               6                                 27   
987            6                    6            37   use English qw(-no_match_vars);
               6                                 17   
               6                                 30   
988            6                    6            50   use Data::Dumper;
               6                                 20   
               6                                 50   
989                                                   $Data::Dumper::Indent    = 0;
990                                                   $Data::Dumper::Quotekeys = 0;
991                                                   
992                                                   eval {
993                                                      require DBI;
994                                                   };
995                                                   my $have_dbi = $EVAL_ERROR ? 0 : 1;
996                                                   
997   ***      6            50      6            37   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 13   
               6                                 73   
998                                                   
999                                                   sub new {
1000           6                    6            33      my ( $class, @opts ) = @_;
1001           6                                487      my $self = {
1002                                                        opts => {
1003                                                           A => {
1004                                                              desc => 'Default character set',
1005                                                              dsn  => 'charset',
1006                                                              copy => 1,
1007                                                           },
1008                                                           D => {
1009                                                              desc => 'Database to use',
1010                                                              dsn  => 'database',
1011                                                              copy => 1,
1012                                                           },
1013                                                           F => {
1014                                                              desc => 'Only read default options from the given file',
1015                                                              dsn  => 'mysql_read_default_file',
1016                                                              copy => 1,
1017                                                           },
1018                                                           h => {
1019                                                              desc => 'Connect to host',
1020                                                              dsn  => 'host',
1021                                                              copy => 1,
1022                                                           },
1023                                                           p => {
1024                                                              desc => 'Password to use when connecting',
1025                                                              dsn  => 'password',
1026                                                              copy => 1,
1027                                                           },
1028                                                           P => {
1029                                                              desc => 'Port number to use for connection',
1030                                                              dsn  => 'port',
1031                                                              copy => 1,
1032                                                           },
1033                                                           S => {
1034                                                              desc => 'Socket file to use for connection',
1035                                                              dsn  => 'mysql_socket',
1036                                                              copy => 1,
1037                                                           },
1038                                                           u => {
1039                                                              desc => 'User for login if not current user',
1040                                                              dsn  => 'user',
1041                                                              copy => 1,
1042                                                           },
1043                                                        },
1044                                                     };
1045           6                                 30      foreach my $opt ( @opts ) {
1046  ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
1047  ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
1048                                                     }
1049           6                                 83      return bless $self, $class;
1050                                                  }
1051                                                  
1052                                                  sub prop {
1053          27                   27           132      my ( $self, $prop, $value ) = @_;
1054  ***     27     50                         126      if ( @_ > 2 ) {
1055  ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
1056  ***      0                                  0         $self->{$prop} = $value;
1057                                                     }
1058          27                                203      return $self->{$prop};
1059                                                  }
1060                                                  
1061                                                  sub parse {
1062           9                    9           399      my ( $self, $dsn, $prev, $defaults ) = @_;
1063  ***      9     50                          49      if ( !$dsn ) {
1064  ***      0                                  0         MKDEBUG && _d('No DSN to parse');
1065  ***      0                                  0         return;
1066                                                     }
1067           9                                 26      MKDEBUG && _d('Parsing', $dsn);
1068  ***      9            50                   41      $prev     ||= {};
1069  ***      9            50                   41      $defaults ||= {};
1070           9                                 27      my %given_props;
1071           9                                 23      my %final_props;
1072           9                                 29      my %opts = %{$self->{opts}};
               9                                 88   
1073                                                  
1074           9                                 84      foreach my $dsn_part ( split(/,/, $dsn) ) {
1075  ***     36     50                         318         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1076          36                                163            $given_props{$prop_key} = $prop_val;
1077                                                        }
1078                                                        else {
1079  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1080  ***      0                                  0            $given_props{h} = $dsn_part;
1081                                                        }
1082                                                     }
1083                                                  
1084           9                                 48      foreach my $key ( keys %opts ) {
1085          72                                150         MKDEBUG && _d('Finding value for', $key);
1086          72                                243         $final_props{$key} = $given_props{$key};
1087  ***     72     50     66                  661         if (   !defined $final_props{$key}
      ***                   33                        
1088                                                             && defined $prev->{$key} && $opts{$key}->{copy} )
1089                                                        {
1090  ***      0                                  0            $final_props{$key} = $prev->{$key};
1091  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1092                                                        }
1093          72    100                         298         if ( !defined $final_props{$key} ) {
1094          36                                116            $final_props{$key} = $defaults->{$key};
1095          36                                 95            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1096                                                        }
1097                                                     }
1098                                                  
1099           9                                 50      foreach my $key ( keys %given_props ) {
1100  ***     36     50                         154         die "Unrecognized DSN part '$key' in '$dsn'\n"
1101                                                           unless exists $opts{$key};
1102                                                     }
1103  ***      9     50                          47      if ( (my $required = $self->prop('required')) ) {
1104  ***      0                                  0         foreach my $key ( keys %$required ) {
1105  ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1106                                                        }
1107                                                     }
1108                                                  
1109           9                                 64      return \%final_props;
1110                                                  }
1111                                                  
1112                                                  sub parse_options {
1113  ***      0                    0             0      my ( $self, $o ) = @_;
1114  ***      0      0                           0      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1115  ***      0                                  0      my $dsn_string
1116                                                        = join(',',
1117  ***      0      0                           0             map  { "$_=".$o->get($_); }
1118  ***      0                                  0             grep { $o->has($_) && $o->get($_) }
1119  ***      0                                  0             keys %{$self->{opts}}
1120                                                          );
1121  ***      0                                  0      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1122  ***      0                                  0      return $self->parse($dsn_string);
1123                                                  }
1124                                                  
1125                                                  sub as_string {
1126  ***      0                    0             0      my ( $self, $dsn ) = @_;
1127  ***      0      0                           0      return $dsn unless ref $dsn;
1128  ***      0      0                           0      return join(',',
1129  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1130  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1131                                                        sort keys %$dsn );
1132                                                  }
1133                                                  
1134                                                  sub usage {
1135  ***      0                    0             0      my ( $self ) = @_;
1136  ***      0                                  0      my $usage
1137                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1138                                                        . "  KEY  COPY  MEANING\n"
1139                                                        . "  ===  ====  =============================================\n";
1140  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1141  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1142  ***      0      0      0                    0         $usage .= "  $key    "
1143                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1144                                                               .  ($opts{$key}->{desc} || '[No description]')
1145                                                               . "\n";
1146                                                     }
1147  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1148  ***      0                                  0      return $usage;
1149                                                  }
1150                                                  
1151                                                  sub get_cxn_params {
1152           9                    9           120      my ( $self, $info ) = @_;
1153           9                                 23      my $dsn;
1154           9                                 23      my %opts = %{$self->{opts}};
               9                                 79   
1155  ***      9            50                   47      my $driver = $self->prop('dbidriver') || '';
1156  ***      9     50                          42      if ( $driver eq 'Pg' ) {
1157  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1158  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1159  ***      0             0                    0                        grep { defined $info->{$_} }
1160                                                                       qw(h P));
1161                                                     }
1162                                                     else {
1163          18                                130         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1164          45                                171            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1165  ***      9            50                  112                        grep { defined $info->{$_} }
1166                                                                       qw(F h P S A))
1167                                                           . ';mysql_read_default_group=client';
1168                                                     }
1169           9                                 23      MKDEBUG && _d($dsn);
1170           9                                 77      return ($dsn, $info->{u}, $info->{p});
1171                                                  }
1172                                                  
1173                                                  sub fill_in_dsn {
1174  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1175  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1176  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1177  ***      0                                  0      $user =~ s/@.*//;
1178  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1179  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1180  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1181  ***      0             0                    0      $dsn->{u} ||= $user;
1182  ***      0             0                    0      $dsn->{D} ||= $db;
1183                                                  }
1184                                                  
1185                                                  sub get_dbh {
1186           9                    9            54      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1187  ***      9            50                   46      $opts ||= {};
1188  ***      9     50                          86      my $defaults = {
1189                                                        AutoCommit         => 0,
1190                                                        RaiseError         => 1,
1191                                                        PrintError         => 0,
1192                                                        ShowErrorStatement => 1,
1193                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1194                                                     };
1195           9                                 48      @{$defaults}{ keys %$opts } = values %$opts;
               9                                 38   
1196                                                  
1197  ***      9     50                          42      if ( !$have_dbi ) {
1198  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1199                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1200                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1201                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1202                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1203                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1204                                                  
1205                                                     }
1206                                                  
1207           9                                 27      my $dbh;
1208           9                                 25      my $tries = 2;
1209  ***      9            66                   92      while ( !$dbh && $tries-- ) {
1210                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1211           9                                 19            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1212                                                  
1213           9                                 31         eval {
1214           9                                 59            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1215                                                  
1216  ***      9     50                          94            if ( $cxn_string =~ m/mysql/i ) {
1217           9                                 23               my $sql;
1218                                                  
1219           9                                 40               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1220                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1221           9                                 21               MKDEBUG && _d($dbh, ':', $sql);
1222           9                                964               $dbh->do($sql);
1223                                                  
1224  ***      9     50                         111               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1225  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1226  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1227  ***      0                                  0                  $dbh->do($sql);
1228  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1229  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1230  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1231                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1232                                                                 }
1233                                                                 else {
1234  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1235                                                                 }
1236                                                              }
1237                                                  
1238  ***      9     50                          57               if ( $self->prop('set-vars') ) {
1239  ***      0                                  0                  $sql = "SET " . $self->prop('set-vars');
1240  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1241  ***      0                                  0                  $dbh->do($sql);
1242                                                              }
1243                                                           }
1244                                                        };
1245  ***      9     50     33                   99         if ( !$dbh && $EVAL_ERROR ) {
1246  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1247  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1248  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1249  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1250                                                           }
1251                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1252  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1253                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1254                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1255                                                                 . "DBD::mysql is not installed, try:\n"
1256                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1257                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1258                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1259                                                           }
1260  ***      0      0                           0            if ( !$tries ) {
1261  ***      0                                  0               die $EVAL_ERROR;
1262                                                           }
1263                                                        }
1264                                                     }
1265                                                  
1266           9                                 24      MKDEBUG && _d('DBH info: ',
1267                                                        $dbh,
1268                                                        Dumper($dbh->selectrow_hashref(
1269                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1270                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1271                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1272                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1273                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1274                                                        '$DBI::VERSION:',        $DBI::VERSION,
1275                                                     );
1276                                                  
1277           9                                 60      return $dbh;
1278                                                  }
1279                                                  
1280                                                  sub get_hostname {
1281  ***      0                    0                    my ( $self, $dbh ) = @_;
1282  ***      0      0      0                           if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1283  ***      0                                            return $host;
1284                                                     }
1285  ***      0                                         my ( $hostname, $one ) = $dbh->selectrow_array(
1286                                                        'SELECT /*!50038 @@hostname, */ 1');
1287  ***      0                                         return $hostname;
1288                                                  }
1289                                                  
1290                                                  sub disconnect {
1291  ***      0                    0                    my ( $self, $dbh ) = @_;
1292  ***      0                                         MKDEBUG && $self->print_active_handles($dbh);
1293  ***      0                                         $dbh->disconnect;
1294                                                  }
1295                                                  
1296                                                  sub print_active_handles {
1297  ***      0                    0                    my ( $self, $thing, $level ) = @_;
1298  ***      0             0                           $level ||= 0;
1299  ***      0      0      0                           printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1300                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1301                                                        or die "Cannot print: $OS_ERROR";
1302  ***      0                                         foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                      
      ***      0                                      
1303  ***      0                                            $self->print_active_handles( $handle, $level + 1 );
1304                                                     }
1305                                                  }
1306                                                  
1307                                                  sub copy {
1308  ***      0                    0                    my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1309  ***      0      0                                  die 'I need a dsn_1 argument' unless $dsn_1;
1310  ***      0      0                                  die 'I need a dsn_2 argument' unless $dsn_2;
1311  ***      0                                         my %new_dsn = map {
1312  ***      0                                            my $key = $_;
1313  ***      0                                            my $val;
1314  ***      0      0                                     if ( $args{overwrite} ) {
1315  ***      0      0                                        $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1316                                                        }
1317                                                        else {
1318  ***      0      0                                        $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1319                                                        }
1320  ***      0                                            $key => $val;
1321  ***      0                                         } keys %{$self->{opts}};
1322  ***      0                                         return \%new_dsn;
1323                                                  }
1324                                                  
1325                                                  sub _d {
1326  ***      0                    0                    my ($package, undef, $line) = caller 0;
1327  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1328  ***      0                                              map { defined $_ ? $_ : 'undef' }
1329                                                          @_;
1330  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1331                                                  }
1332                                                  
1333                                                  1;
1334                                                  
1335                                                  # ###########################################################################
1336                                                  # End DSNParser package
1337                                                  # ###########################################################################
1338                                                  
1339                                                  # ###########################################################################
1340                                                  # Daemon package 5266
1341                                                  # ###########################################################################
1342                                                  
1343                                                  package Daemon;
1344                                                  
1345           6                    6            48   use strict;
               6                                 35   
               6                                 36   
1346           6                    6            37   use warnings FATAL => 'all';
               6                                 19   
               6                                 31   
1347                                                  
1348           6                    6            33   use POSIX qw(setsid);
               6                                 18   
               6                                 45   
1349           6                    6            37   use English qw(-no_match_vars);
               6                                 16   
               6                                 30   
1350                                                  
1351  ***      6            50      6            37   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 16   
               6                                 79   
1352                                                  
1353                                                  sub new {
1354  ***      0                    0                    my ( $class, %args ) = @_;
1355  ***      0                                         foreach my $arg ( qw(o) ) {
1356  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
1357                                                     }
1358  ***      0                                         my $o = $args{o};
1359  ***      0      0                                  my $self = {
      ***             0                               
1360                                                        o        => $o,
1361                                                        log_file => $o->has('log') ? $o->get('log') : undef,
1362                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
1363                                                     };
1364                                                  
1365  ***      0                                         check_PID_file(undef, $self->{PID_file});
1366                                                  
1367  ***      0                                         MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
1368  ***      0                                         return bless $self, $class;
1369                                                  }
1370                                                  
1371                                                  sub daemonize {
1372  ***      0                    0                    my ( $self ) = @_;
1373                                                  
1374  ***      0                                         MKDEBUG && _d('About to fork and daemonize');
1375  ***      0      0                                  defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
1376  ***      0      0                                  if ( $pid ) {
1377  ***      0                                            MKDEBUG && _d('I am the parent and now I die');
1378  ***      0                                            exit;
1379                                                     }
1380                                                  
1381  ***      0                                         $self->{child} = 1;
1382                                                  
1383  ***      0      0                                  POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
1384  ***      0      0                                  chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
1385                                                  
1386  ***      0                                         $self->_make_PID_file();
1387                                                  
1388  ***      0                                         $OUTPUT_AUTOFLUSH = 1;
1389                                                  
1390  ***      0      0                                  if ( -t STDIN ) {
1391  ***      0                                            close STDIN;
1392  ***      0      0                                     open  STDIN, '/dev/null'
1393                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
1394                                                     }
1395                                                  
1396  ***      0      0                                  if ( $self->{log_file} ) {
1397  ***      0                                            close STDOUT;
1398  ***      0      0                                     open  STDOUT, '>>', $self->{log_file}
1399                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
1400                                                  
1401  ***      0                                            close STDERR;
1402  ***      0      0                                     open  STDERR, ">&STDOUT"
1403                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
1404                                                     }
1405                                                     else {
1406  ***      0      0                                     if ( -t STDOUT ) {
1407  ***      0                                               close STDOUT;
1408  ***      0      0                                        open  STDOUT, '>', '/dev/null'
1409                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
1410                                                        }
1411  ***      0      0                                     if ( -t STDERR ) {
1412  ***      0                                               close STDERR;
1413  ***      0      0                                        open  STDERR, '>', '/dev/null'
1414                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
1415                                                        }
1416                                                     }
1417                                                  
1418  ***      0                                         MKDEBUG && _d('I am the child and now I live daemonized');
1419  ***      0                                         return;
1420                                                  }
1421                                                  
1422                                                  sub check_PID_file {
1423  ***      0                    0                    my ( $self, $file ) = @_;
1424  ***      0      0                                  my $PID_file = $self ? $self->{PID_file} : $file;
1425  ***      0                                         MKDEBUG && _d('Checking PID file', $PID_file);
1426  ***      0      0      0                           if ( $PID_file && -f $PID_file ) {
1427  ***      0                                            my $pid;
1428  ***      0                                            eval { chomp($pid = `cat $PID_file`); };
      ***      0                                      
1429  ***      0      0                                     die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
1430  ***      0                                            MKDEBUG && _d('PID file exists; it contains PID', $pid);
1431  ***      0      0                                     if ( $pid ) {
1432  ***      0                                               my $pid_is_alive = kill 0, $pid;
1433  ***      0      0                                        if ( $pid_is_alive ) {
1434  ***      0                                                  die "The PID file $PID_file already exists "
1435                                                                 . " and the PID that it contains, $pid, is running";
1436                                                           }
1437                                                           else {
1438  ***      0                                                  warn "Overwriting PID file $PID_file because the PID that it "
1439                                                                 . "contains, $pid, is not running";
1440                                                           }
1441                                                        }
1442                                                        else {
1443  ***      0                                               die "The PID file $PID_file already exists but it does not "
1444                                                              . "contain a PID";
1445                                                        }
1446                                                     }
1447                                                     else {
1448  ***      0                                            MKDEBUG && _d('No PID file');
1449                                                     }
1450  ***      0                                         return;
1451                                                  }
1452                                                  
1453                                                  sub make_PID_file {
1454  ***      0                    0                    my ( $self ) = @_;
1455  ***      0      0                                  if ( exists $self->{child} ) {
1456  ***      0                                            die "Do not call Daemon::make_PID_file() for daemonized scripts";
1457                                                     }
1458  ***      0                                         $self->_make_PID_file();
1459  ***      0                                         $self->{rm_PID_file} = 1;
1460  ***      0                                         return;
1461                                                  }
1462                                                  
1463                                                  sub _make_PID_file {
1464  ***      0                    0                    my ( $self ) = @_;
1465                                                  
1466  ***      0                                         my $PID_file = $self->{PID_file};
1467  ***      0      0                                  if ( !$PID_file ) {
1468  ***      0                                            MKDEBUG && _d('No PID file to create');
1469  ***      0                                            return;
1470                                                     }
1471                                                  
1472  ***      0                                         $self->check_PID_file();
1473                                                  
1474  ***      0      0                                  open my $PID_FH, '>', $PID_file
1475                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
1476  ***      0      0                                  print $PID_FH $PID
1477                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
1478  ***      0      0                                  close $PID_FH
1479                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
1480                                                  
1481  ***      0                                         MKDEBUG && _d('Created PID file:', $self->{PID_file});
1482  ***      0                                         return;
1483                                                  }
1484                                                  
1485                                                  sub _remove_PID_file {
1486  ***      0                    0                    my ( $self ) = @_;
1487  ***      0      0      0                           if ( $self->{PID_file} && -f $self->{PID_file} ) {
1488  ***      0      0                                     unlink $self->{PID_file}
1489                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
1490  ***      0                                            MKDEBUG && _d('Removed PID file');
1491                                                     }
1492                                                     else {
1493  ***      0                                            MKDEBUG && _d('No PID to remove');
1494                                                     }
1495  ***      0                                         return;
1496                                                  }
1497                                                  
1498                                                  sub DESTROY {
1499  ***      0                    0                    my ( $self ) = @_;
1500  ***      0      0      0                           $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
1501  ***      0                                         return;
1502                                                  }
1503                                                  
1504                                                  sub _d {
1505  ***      0                    0                    my ($package, undef, $line) = caller 0;
1506  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1507  ***      0                                              map { defined $_ ? $_ : 'undef' }
1508                                                          @_;
1509  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1510                                                  }
1511                                                  
1512                                                  1;
1513                                                  
1514                                                  # ###########################################################################
1515                                                  # End Daemon package
1516                                                  # ###########################################################################
1517                                                  
1518                                                  # ###########################################################################
1519                                                  # This is a combination of modules and programs in one -- a runnable module.
1520                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
1521                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
1522                                                  #
1523                                                  # Check at the end of this package for the call to main() which actually runs
1524                                                  # the program.
1525                                                  # ###########################################################################
1526                                                  package mk_deadlock_logger;
1527                                                  
1528           6                    6            45   use English qw(-no_match_vars);
               6                                 12   
               6                                 32   
1529           6                    6            43   use List::Util qw(max);
               6                                 13   
               6                                 36   
1530           6                    6            92   use Socket qw(inet_aton);
               6                                 18   
               6                                 80   
1531           6                    6            80   use sigtrap qw(handler finish untrapped normal-signals);
               6                                 18   
               6                                 49   
1532                                                  
1533  ***      6            50      6            40   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 13   
               6                                 95   
1534                                                  
1535                                                  my $o;
1536                                                  my $oktorun;
1537                                                  my $dp;
1538                                                  
1539                                                  # ########################################################################
1540                                                  # Configuration info.
1541                                                  # ########################################################################
1542                                                  my $source_dsn;
1543                                                  my $dest_dsn;
1544                                                  
1545                                                  # Some common patterns and variables
1546                                                  my $d = qr/(\d+)/;                    # Digit
1547                                                  my $t = qr/(\d+ \d+)/;                # Transaction ID
1548                                                  my $i = qr/((?:\d{1,3}\.){3}\d+)/;    # IP address
1549                                                  my $n = qr/([^`\s]+)/;                # MySQL object name
1550                                                  my $w = qr/(\w+)/;                    # Words
1551                                                  my $s = qr/(\d{6} .\d:\d\d:\d\d)/;    # InnoDB timestamp
1552                                                  
1553                                                  # A thread's proc_info can be at least 98 different things I've found in the
1554                                                  # source.  Fortunately, most of them begin with a gerunded verb.  These are
1555                                                  # the ones that don't.
1556                                                  my %is_proc_info = (
1557                                                     'After create'                 => 1,
1558                                                     'Execution of init_command'    => 1,
1559                                                     'FULLTEXT initialization'      => 1,
1560                                                     'Reopen tables'                => 1,
1561                                                     'Repair done'                  => 1,
1562                                                     'Repair with keycache'         => 1,
1563                                                     'System lock'                  => 1,
1564                                                     'Table lock'                   => 1,
1565                                                     'Thread initialized'           => 1,
1566                                                     'User lock'                    => 1,
1567                                                     'copy to tmp table'            => 1,
1568                                                     'discard_or_import_tablespace' => 1,
1569                                                     'end'                          => 1,
1570                                                     'got handler lock'             => 1,
1571                                                     'got old table'                => 1,
1572                                                     'init'                         => 1,
1573                                                     'key cache'                    => 1,
1574                                                     'locks'                        => 1,
1575                                                     'malloc'                       => 1,
1576                                                     'query end'                    => 1,
1577                                                     'rename result table'          => 1,
1578                                                     'rename'                       => 1,
1579                                                     'setup'                        => 1,
1580                                                     'statistics'                   => 1,
1581                                                     'status'                       => 1,
1582                                                     'table cache'                  => 1,
1583                                                     'update'                       => 1,
1584                                                  );
1585                                                  
1586                                                  sub main {
1587  ***      0                    0                    @ARGV = @_;  # set global ARGV for this package
1588                                                  
1589  ***      0                                         my $q  = new Quoter();
1590  ***      0                                         my $vp = new VersionParser();
1591  ***      0                                         $dp    = new DSNParser(
1592                                                        { key => 't',
1593                                                          copy => 1,
1594                                                          desc => 'Table in which to store deadlock information'
1595                                                        },
1596                                                     );
1597                                                  
1598                                                     # ########################################################################
1599                                                     # Get configuration information.
1600                                                     # ########################################################################
1601  ***      0                                         $o = new OptionParser(
1602                                                        strict      => 0,
1603                                                        description => q{extracts and saves information about the most }
1604                                                                     . q{recent deadlock in a MySQL server.},
1605                                                        prompt      => 'SOURCE_DSN [OPTION]...',
1606                                                        dp          => $dp,
1607                                                     );
1608                                                  
1609  ***      0                                         $o->get_specs();
1610  ***      0                                         $o->get_opts();
1611                                                  
1612  ***      0      0                                  $o->set('collapse', $o->get('print')) unless $o->got('collapse'); 
1613                                                   
1614  ***      0                                         my $dsn_defaults = $dp->parse_options($o);
1615  ***      0      0                                  $source_dsn = @ARGV ? $dp->parse(shift @ARGV,$dsn_defaults) : $dsn_defaults;
1616  ***      0                                         $dest_dsn   = $o->get('dest');
1617                                                  
1618                                                     # The source dsn is not an option so --dest cannot use OptionParser
1619                                                     # to inherit values from it.  Thus, we do it manually.  --dest will
1620                                                     # inherit from --user, --port, etc.
1621  ***      0      0      0                           if ( $source_dsn && $dest_dsn ) {
1622                                                        # If dest DSN only has D and t, this will copy h, P, S, etc.
1623                                                        # from the source DSN.
1624  ***      0                                            $dest_dsn = $dp->copy($source_dsn, $dest_dsn);
1625                                                     }
1626                                                  
1627  ***      0      0                                  if ( !$o->get('help') ) {
1628  ***      0      0                                     if ( !$source_dsn ) {
1629  ***      0                                               $o->save_error('Missing or invalid source host');
1630                                                        }
1631  ***      0      0      0                              if ( $dest_dsn && !$dest_dsn->{D} ) {
1632  ***      0                                               $o->save_error("--dest requires a 'D' (database) part");
1633                                                        }
1634  ***      0      0      0                              if ( $dest_dsn && !$dest_dsn->{t} ) {
1635  ***      0                                               $o->save_error("--dest requires a 't' (table) part");
1636                                                        }
1637                                                     }
1638                                                  
1639  ***      0                                         $o->usage_or_errors();
1640                                                  
1641                                                     # ########################################################################
1642                                                     # Start working.
1643                                                     # ########################################################################
1644  ***      0                                         my $dbh   = get_cxn($source_dsn, 1);
1645  ***      0                                         my $start = time();
1646  ***      0             0                           my $end   = $start + ($o->get('run-time') || 0); # When we should exit
1647  ***      0                                         my $now   = $start;
1648  ***      0                                         my $dest_dbh;
1649  ***      0                                         my $sth;
1650  ***      0                                         my $ins_sth;
1651                                                  
1652                                                     # Since the user might not have specified a hostname for the connection,
1653                                                     # try to extract it from the $dbh
1654  ***      0      0                                  if ( !$source_dsn->{h} ) {
1655  ***      0                                            ($source_dsn->{h}) = $dbh->{mysql_hostinfo} =~ m/(\w+) via/;
1656  ***      0                                            MKDEBUG && _d('Got source host from dbh:', $source_dsn->{h});
1657                                                     }
1658                                                  
1659  ***      0                                         my @cols = qw( server ts thread txn_id txn_time user hostname ip db tbl idx
1660                                                                    lock_type lock_mode wait_hold victim query );
1661  ***      0      0                                  if ( $o->got('columns') ) {
1662  ***      0                                            @cols = grep { $o->get('columns')->{$_} } @cols;
      ***      0                                      
1663                                                     }
1664                                                  
1665  ***      0      0                                  if ( $dest_dsn ) {
1666  ***      0                                            my $db_tbl = 
1667                                                           join('.',
1668  ***      0                                               map  {  $q->quote($_) }
1669  ***      0                                               grep { $_ }
1670                                                           ( $dest_dsn->{D}, $dest_dsn->{t} ));
1671  ***      0                                            $dest_dbh = get_cxn($dest_dsn, 0);
1672  ***      0                                            my $cols  = join(',', map { $q->quote($_) } @cols);
      ***      0                                      
1673  ***      0                                            my $parms = join(',', map { '?' } @cols);
      ***      0                                      
1674  ***      0                                            $ins_sth  = $dest_dbh->prepare("INSERT IGNORE INTO $db_tbl($cols) VALUES($parms)");
1675                                                  
1676  ***      0      0                                     if ( $o->get('create-dest-table') ) {
1677  ***      0                                               my $db_tbl = $q->quote($dest_dsn->{D}, $dest_dsn->{t});
1678  ***      0                                               my $sql    = $o->read_para_after(__FILE__, qr/MAGIC_dest_table/);
1679  ***      0                                               $sql       =~ s/deadlocks/IF NOT EXISTS $db_tbl/;
1680  ***      0                                               MKDEBUG && _d($sql);
1681  ***      0                                               $dest_dbh->do($sql);
1682                                                        }
1683                                                     }
1684                                                  
1685                                                     # Daemonize only after (potentially) asking for passwords for --ask-pass.
1686  ***      0                                         my $daemon;
1687  ***      0      0                                  if ( $o->get('daemonize') ) {
      ***             0                               
1688  ***      0                                            $daemon = new Daemon(o=>$o);
1689  ***      0                                            $daemon->daemonize();
1690  ***      0                                            MKDEBUG && _d('I am a daemon now');
1691                                                     }
1692                                                     elsif ( $o->get('pid') ) {
1693                                                        # We're not daemoninzing, it just handles PID stuff.
1694  ***      0                                            $daemon = new Daemon(o=>$o);
1695  ***      0                                            $daemon->make_PID_file();
1696                                                     }
1697                                                  
1698  ***      0                                         $oktorun = 1;
1699  ***      0             0                           while (                            # Quit if:
      ***                    0                        
1700                                                        ($start == $end || $now < $end) # time is exceeded
1701                                                        && $oktorun                     # or instructed to quit
1702                                                        )
1703                                                     {
1704                                                  
1705  ***      0                                            my $text = $dbh->selectrow_hashref("SHOW INNODB STATUS")->{Status};
1706                                                  
1707  ***      0                                            my %txns = %{parse_deadlocks($text)};
      ***      0                                      
1708                                                  
1709  ***      0      0                                     if ( $ins_sth ) {
1710  ***      0                                               foreach my $txn (sort { $a->{thread} <=> $b->{thread} } values %txns) {
      ***      0                                      
1711  ***      0                                                  $ins_sth->execute(@{$txn}{@cols});
      ***      0                                      
1712                                                           }
1713  ***      0                                               $dest_dbh->commit();
1714                                                        }
1715                                                  
1716  ***      0      0      0                              if ( $o->got('print') || !$o->got('dest') ) {
1717  ***      0      0                                        my $sep = $o->get('tab') ? "\t" : ' ';
1718  ***      0                                               print join($sep, @cols), "\n";
1719  ***      0                                               foreach my $txn (sort { $a->{thread} <=> $b->{thread} } values %txns) {
      ***      0                                      
1720                                                              # If 'collapse' is on, it's already been taken care of,
1721                                                              # but if it's unset, by default strip whitespace.
1722  ***      0      0                                           if ( !$o->got('collapse') ) {
1723  ***      0                                                     $txn->{query} =~ s/\s+/ /g;
1724                                                              }
1725  ***      0                                                  print join($sep, map { $txn->{$_} } @cols), "\n";
      ***      0                                      
1726                                                           }
1727                                                        }
1728                                                  
1729                                                        # If there's an --interval argument, run forever or till specified.
1730                                                        # Otherwise just run once.
1731  ***      0      0                                     if ( $o->got('interval') ) {
1732  ***      0                                               sleep($o->get('interval'));
1733  ***      0                                               $now = time();
1734                                                        }
1735                                                        else {
1736  ***      0                                               $oktorun = 0;
1737                                                           # If specified, clear the deadlock... 
1738  ***      0      0                                        if ( my $db_tbl = $o->get('clear-deadlocks') ) {
1739  ***      0                                                  MKDEBUG && _d('Creating --clear-deadlocks table', $db_tbl);
1740  ***      0                                                  $dbh->{AutoCommit} = 0;
1741  ***      0                                                  my $sql = $o->read_para_after(__FILE__, qr/MAGIC_clear_deadlocks/);
1742                                                  
1743  ***      0      0                                           if ( !$vp->version_ge($dbh, '4.1.2') ) {
1744  ***      0                                                     $sql =~ s/ENGINE=/TYPE=/;
1745                                                              }
1746  ***      0                                                  $sql =~ s/test.deadlock_maker/$db_tbl/;
1747  ***      0                                                  MKDEBUG && _d($sql);
1748  ***      0                                                  $dbh->do($sql);
1749  ***      0                                                  $sql = "INSERT INTO $db_tbl(a) VALUES(1)";
1750  ***      0                                                  MKDEBUG && _d($sql);
1751  ***      0                                                  $dbh->do($sql); # I'm holding locks on the table now.
1752                                                  
1753                                                              # Fork off a child to try to take a lock on the table.
1754  ***      0                                                  my $pid = fork();
1755  ***      0      0      0                                    if ( defined($pid) && $pid == 0 ) { # I am a child
      ***             0                               
1756  ***      0                                                     my $dbh_child = get_cxn($source_dsn, 0);
1757  ***      0                                                     $sql = "SELECT * FROM $db_tbl FOR UPDATE";
1758  ***      0                                                     MKDEBUG && _d($sql);
1759  ***      0                                                     eval { $dbh_child->do($sql); }; # Should block against parent.
      ***      0                                      
1760  ***      0                                                     MKDEBUG && _d($EVAL_ERROR); # Parent inserted value 0.
1761  ***      0                                                     $sql = "DROP TABLE $db_tbl";
1762  ***      0                                                     MKDEBUG && _d($sql);
1763  ***      0                                                     $dbh_child->do($sql);
1764  ***      0                                                     exit;
1765                                                              }
1766                                                              elsif ( !defined($pid) ) {
1767  ***      0                                                     die("Unable to fork for clearing deadlocks!\n");
1768                                                              }
1769  ***      0                                                  sleep 1;
1770  ***      0                                                  $sql = "INSERT INTO $db_tbl(a) VALUES(0)";# Will make child deadlock
1771  ***      0                                                  MKDEBUG && _d($sql);
1772  ***      0                                                  eval { $dbh->do($sql); };
      ***      0                                      
1773  ***      0                                                  MKDEBUG && _d($EVAL_ERROR);
1774  ***      0                                                  waitpid($pid, 0);
1775                                                           }
1776                                                        }
1777                                                     }
1778                                                  
1779  ***      0                                         return 0;
1780                                                  }
1781                                                  
1782                                                  # ############################################################################
1783                                                  # Subroutines
1784                                                  # ############################################################################
1785                                                  
1786                                                  sub parse_deadlocks {
1787  ***      0                    0                    my ( $text ) = @_;
1788                                                     # Pull out the deadlock section
1789  ***      0                                         my $dl_text;
1790  ***      0                                         my @matches = $text =~ m#\n(---+)\n([A-Z /]+)\n\1\n(.*?)(?=\n(---+)\n[A-Z /]+\n\4\n|$)#gs;
1791  ***      0                                         while ( my ( $start, $name, $text, $end ) = splice(@matches, 0, 4) ) {
1792  ***      0      0                                     next unless $name eq 'LATEST DETECTED DEADLOCK';
1793  ***      0                                            $dl_text = $text;
1794                                                     }
1795                                                  
1796  ***      0      0                                  return {} unless $dl_text;
1797                                                  
1798                                                     my @sections
1799  ***      0                                            = $dl_text
1800                                                        =~ m{
1801                                                           ^\*{3}\s([^\n]*)  # *** (1) WAITING FOR THIS...
1802                                                           (.*?)             # Followed by anything, non-greedy
1803                                                           (?=(?:^\*{3})|\z) # Followed by another three-stars or EOF
1804                                                        }gmsx;
1805                                                  
1806                                                     # Loop through each section.  There are no assumptions about how many
1807                                                     # there are, who holds and wants what locks, and who gets rolled back.
1808  ***      0                                         my %txns;
1809  ***      0                                         while ( my ($header, $body) = splice(@sections, 0, 2) ) {
1810  ***      0                                            my ( $txn_id, $what ) = $header =~ m/^\($d\) (.*):$/m;
1811  ***      0      0                                     next unless $txn_id;
1812  ***      0             0                              $txns{$txn_id} ||= { id => $txn_id };
1813  ***      0                                            my $hash = $txns{$txn_id};
1814                                                  
1815  ***      0      0                                     if ( $what eq 'TRANSACTION' ) {
1816  ***      0                                               @{$hash}{qw(txn_time)} = $body =~ m/ACTIVE $d sec/;
      ***      0                                      
1817                                                  
1818                                                           # Parsing the line that begins 'MySQL thread id' is complicated.
1819                                                           # The only thing always in the line is the thread and query id.
1820                                                           # See function innobase_mysql_print_thd in InnoDB source file
1821                                                           # sql/ha_innodb.cc.
1822  ***      0                                               my ( $thread_line ) = $body =~ m/^(MySQL thread id .*)$/m;
1823  ***      0                                               my ($mysql_thread_id, $query_id, $hostname, $ip, $user, $query_status);
1824                                                  
1825  ***      0      0                                        if ( $thread_line ) {
1826                                                              # These parts can always be gotten.
1827  ***      0                                                  ( $mysql_thread_id, $query_id )
1828                                                                 = $thread_line =~ m/^MySQL thread id $d, query id $d/m;
1829                                                  
1830                                                              # If it's a master/slave thread, "Has (read|sent) all" may be the
1831                                                              # thread's proc_info.  In these cases, there won't be any
1832                                                              # host/ip/user info.
1833  ***      0                                                  ( $query_status ) = $thread_line =~ m/(Has (?:read|sent) all .*$)/m;
1834  ***      0      0                                           if ( defined($query_status) ) {
      ***             0                               
1835  ***      0                                                     $user = 'system user';
1836                                                              }
1837                                                  
1838                                                              # The query id might be the last thing in the line.
1839                                                              elsif ( $thread_line =~ m/query id \d+ / ) {
1840                                                                 # The IP address is the only non-word thing left, so it's
1841                                                                 # the most useful marker for where I have to start guessing.
1842  ***      0                                                     ( $hostname, $ip ) = $thread_line =~ m/query id \d+(?: ([A-Za-z]\S+))? $i/m;
1843  ***      0      0                                              if ( defined $ip ) {
1844  ***      0                                                        ($user, $query_status) = $thread_line =~ m/$ip $w(?: (.*))?$/;
1845                                                                 }
1846                                                                 else {
1847                                                                    # OK, there wasn't an IP address.
1848                                                                    # There might not be ANYTHING except the query status.
1849  ***      0                                                        ( $query_status ) = $thread_line =~ m/query id \d+ (.*)$/;
1850  ***      0      0      0                                          if ( $query_status !~ m/^\w+ing/
1851                                                                         && !exists($is_proc_info{$query_status}) ) {
1852                                                                       # The remaining tokens are, in order: hostname, user,
1853                                                                       # query_status.
1854                                                                       # It's basically impossible to know which is which.
1855  ***      0                                                           ( $hostname, $user, $query_status ) = $thread_line
1856                                                                          =~ m/query id \d+(?: ([A-Za-z]\S+))?(?: $w(?: (.*))?)?$/m;
1857                                                                    }
1858                                                                    else {
1859  ***      0                                                           $user = 'system user';
1860                                                                    }
1861                                                                 }
1862                                                              }
1863                                                           }
1864                                                  
1865  ***      0                                               my ( $query_text ) = $body =~ m/\nMySQL thread id .*\n((?s).*)/;
1866  ***      0                                               $query_text =~ s/\s+$//;
1867  ***      0      0                                        $query_text =~ s/\s+/ /g if $o->got('collapse');
1868                                                  
1869  ***      0                                               @{$hash}{qw(thread hostname ip user query)}
      ***      0                                      
1870                                                              = ($mysql_thread_id, $hostname, $ip, $user, $query_text);
1871  ***      0                                               foreach my $key ( keys %$hash ) {
1872  ***      0      0                                           if ( !defined $hash->{$key} ) {
1873  ***      0                                                     $hash->{$key} = '';
1874                                                              }
1875                                                           }
1876                                                  
1877                                                        }
1878                                                        else {
1879                                                           # Prefer information about locks waited-for over locks-held.
1880  ***      0      0      0                                 if ( $what eq 'WAITING FOR THIS LOCK TO BE GRANTED' || !$hash->{lock_type} ) {
1881  ***      0      0                                           $hash->{wait_hold} = $what eq 'WAITING FOR THIS LOCK TO BE GRANTED' ? 'w' : 'h';
1882  ***      0                                                  @{$hash}{ qw(lock_type idx db tbl txn_id lock_mode) }
      ***      0                                      
1883                                                                 = $body
1884                                                                 =~ m{^(RECORD|TABLE) LOCKS? (?:space id \d+ page no \d+ n bits \d+ index `?$n`? of )?table `$n(?:/|`\.`)$n` trx id $t lock.mode (\S+)}m;
1885  ***      0      0                                           if ( $hash->{txn_id} ) {
1886  ***      0                                                     my ( $high, $low ) = $hash->{txn_id} =~ m/^(\d+) (\d+)$/;
1887  ***      0      0                                              $hash->{txn_id} = $high ? ( $low + ($high << 32) ) : $low;
1888                                                              }
1889                                                           }
1890                                                        }
1891                                                  
1892                                                        # Ensure all values are defined
1893  ***      0      0                                     map { $hash->{$_} = 0 unless defined $hash->{$_} }
      ***      0                                      
1894                                                           qw(thread txn_id txn_time);
1895  ***      0      0                                     map { $hash->{$_} = '' unless defined $hash->{$_} }
      ***      0                                      
1896                                                           qw(user hostname db tbl idx lock_type lock_mode query);
1897                                                     }
1898                                                  
1899                                                     # Extract some miscellaneous data from the deadlock.
1900  ***      0                                         my ( $ts ) = $dl_text =~ m/^$s$/m;
1901  ***      0                                         my ( $year, $mon, $day, $hour, $min, $sec ) = $ts =~ m/^(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)$/;
1902  ***      0                                         $ts = sprintf('%02d-%02d-%02dT%02d:%02d:%02d', $year + 2000, $mon, $day, $hour, $min, $sec);
1903  ***      0                                         my ( $victim ) = $dl_text =~ m/^\*\*\* WE ROLL BACK TRANSACTION \((\d+)\)$/m;
1904  ***      0             0                           $victim ||= 0;
1905                                                  
1906                                                     # Stick the misc data into the transactions.
1907  ***      0                                         foreach my $txn ( values %txns ) {
1908  ***      0      0                                     $txn->{victim} = $txn->{id} == $victim ? 1 : 0;
1909  ***      0                                            $txn->{ts}     = $ts;
1910  ***      0             0                              $txn->{server} = $source_dsn->{h} || '';
1911  ***      0      0                                     $txn->{ip}     = inet_aton($txn->{ip}) if $o->got('numeric-ip');
1912                                                     }
1913                                                  
1914  ***      0                                         return \%txns;
1915                                                  }
1916                                                  
1917                                                  # Catches signals so the program can exit gracefully.
1918                                                  sub finish {
1919  ***      0                    0                    my ($signal) = @_;
1920  ***      0                                         print STDERR "Exiting on SIG$signal.\n";
1921  ***      0                                         $oktorun = 0;
1922                                                  }
1923                                                  
1924                                                  sub get_cxn {
1925  ***      0                    0                    my ( $dsn, $ac ) = @_;
1926  ***      0      0                                  if ( $o->get('ask-pass') ) {
1927  ***      0                                            $dsn->{p} = OptionParser::prompt_noecho("Enter password: "); 
1928                                                     }
1929  ***      0                                         my $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), {AutoCommit => $ac});
1930  ***      0                                         $dbh->{InactiveDestroy} = 1; # Because of forking.
1931  ***      0                                         return $dbh;
1932                                                  }
1933                                                  
1934                                                  sub _d {
1935  ***      0                    0                    my ($package, undef, $line) = caller 0;
1936  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1937  ***      0                                              map { defined $_ ? $_ : 'undef' }
1938                                                          @_;
1939  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1940                                                  }
1941                                                  
1942                                                  # ############################################################################
1943                                                  # Run the program.
1944                                                  # ############################################################################
1945                                                  if ( !caller ) { exit main(@ARGV); }
1946                                                  
1947                                                  1; # Because this is a module as well as a script.
1948                                                  
1949                                                  # ############################################################################
1950                                                  # Documentation
1951                                                  # ############################################################################
1952                                                  =pod
1953                                                  
1954                                                  =head1 NAME
1955                                                  
1956                                                  mk-deadlock-logger - Extract and log MySQL deadlock information.
1957                                                  
1958                                                  =head1 SYNOPSIS
1959                                                  
1960                                                  Print deadlocks on SOURCE_DSN:
1961                                                  
1962                                                     mk-deadlock-logger SOURCE_DSN
1963                                                  
1964                                                  Store deadlock information from SOURCE_DSN in test.deadlocks table on SOURCE_DSN
1965                                                  (source and destination are the same host):
1966                                                  
1967                                                     mk-deadlock-logger SOURCE_DSN --dest D=test,t=deadlocks
1968                                                  
1969                                                  Store deadlock information from SOURCE_DSN in test.deadlocks table on DEST_DSN
1970                                                  (source and destination are different hosts):
1971                                                  
1972                                                     mk-deadlock-logger SOURCE_DSN --dest DEST_DSN,D=test,t=deadlocks
1973                                                  
1974                                                  Daemonize and check for deadlocks on SOURCE_DSN every 30 seconds for 4 hours:
1975                                                  
1976                                                     mk-deadlock-logger SOURCE_DSN --dest D=test,t=deadlocks --daemonize --run-time 4h --interval 30s
1977                                                  
1978                                                  =head1 RISKS
1979                                                  
1980                                                  The following section is included to inform users about the potential risks,
1981                                                  whether known or unknown, of using this tool.  The two main categories of risks
1982                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
1983                                                  tools) and those created by bugs.
1984                                                  
1985                                                  mk-deadlock-logger is a read-only tool unless you specify a L<"--dest"> table.
1986                                                  In some cases polling SHOW INNODB STATUS too rapidly can cause extra load on the
1987                                                  server.  If you're using it on a production server under very heavy load, you
1988                                                  might want to set L<"--interval"> to 30 seconds or more.
1989                                                  
1990                                                  At the time of this release, we know of no bugs that could cause serious harm to
1991                                                  users.
1992                                                  
1993                                                  The authoritative source for updated information is always the online issue
1994                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
1995                                                  see a list of such issues at the following URL:
1996                                                  L<http://www.maatkit.org/bugs/mk-deadlock-logger>.
1997                                                  
1998                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
1999                                                  
2000                                                  =head1 DESCRIPTION
2001                                                  
2002                                                  mk-deadlock-logger extracts deadlock data from a MySQL server.  Currently only
2003                                                  InnoDB deadlock information is available.  You can print the information to
2004                                                  standard output, store it in a database table, or both.  If neither
2005                                                  L<"--print"> nor L<"--dest"> are given, then the deadlock information is
2006                                                  printed by default.  If only L<"--dest"> is given, then the deadlock
2007                                                  information is only stored.  If both options are given, then the deadlock
2008                                                  informat is printed and stored.
2009                                                  
2010                                                  The source host can be specified using one of two methods.  The first method is
2011                                                  to use at least one of the standard connection-related command line options:
2012                                                  L<"--defaults-file">, L<"--password">, L<"--host">, L<"--port">, L<"--socket">
2013                                                  or L<"--user">.  These options only apply to the source host; they cannot be
2014                                                  used to specify the destination host.
2015                                                  
2016                                                  The second method to specifiy the source host, or the optional destination host
2017                                                  using L<"--dest">, is a DSN.  A DSN is a special syntax that can be either just
2018                                                  a hostname (like C<server.domain.com> or C<1.2.3.4>), or a
2019                                                  C<key=value,key=value> string. Keys are a single letter:
2020                                                  
2021                                                    KEY MEANING
2022                                                    === =======
2023                                                    h   Connect to host
2024                                                    P   Port number to use for connection
2025                                                    S   Socket file to use for connection
2026                                                    u   User for login if not current user
2027                                                    p   Password to use when connecting
2028                                                    F   Only read default options from the given file
2029                                                  
2030                                                  If you omit any values from the destination host DSN, they are filled in with
2031                                                  values from the source host, so you don't need to specify them in both places.
2032                                                  C<mk-deadlock-logger> reads all normal MySQL option files, such as ~/.my.cnf, so
2033                                                  you may not need to specify username, password and other common options at all.
2034                                                  
2035                                                  =head1 OUTPUT
2036                                                  
2037                                                  You can choose which columns are output and/or saved to L<"--dest"> with the
2038                                                  L<"--columns"> argument.  The default columns are as follows:
2039                                                  
2040                                                  =over
2041                                                  
2042                                                  =item server
2043                                                  
2044                                                  The (source) server on which the deadlock occurred.  This might be useful if
2045                                                  you're tracking deadlocks on many servers.
2046                                                  
2047                                                  =item ts
2048                                                  
2049                                                  The date and time of the last detected deadlock.
2050                                                  
2051                                                  =item thread
2052                                                  
2053                                                  The MySQL thread number, which is the same as the connection ID in SHOW FULL
2054                                                  PROCESSLIST.
2055                                                  
2056                                                  =item txn_id
2057                                                  
2058                                                  The InnoDB transaction ID, which InnoDB expresses as two unsigned integers.  I
2059                                                  have multiplied them out to be one number.
2060                                                  
2061                                                  =item txn_time
2062                                                  
2063                                                  How long the transaction was active when the deadlock happened.
2064                                                  
2065                                                  =item user
2066                                                  
2067                                                  The connection's database username.
2068                                                  
2069                                                  =item hostname
2070                                                  
2071                                                  The connection's host.
2072                                                  
2073                                                  =item ip
2074                                                  
2075                                                  The connection's IP address.  If you specify L<"--numeric-ip">, this is
2076                                                  converted to an unsigned integer.
2077                                                  
2078                                                  =item db
2079                                                  
2080                                                  The database in which the deadlock occurred.
2081                                                  
2082                                                  =item tbl
2083                                                  
2084                                                  The table on which the deadlock occurred.
2085                                                  
2086                                                  =item idx
2087                                                  
2088                                                  The index on which the deadlock occurred.
2089                                                  
2090                                                  =item lock_type
2091                                                  
2092                                                  The lock type the transaction held on the lock that caused the deadlock.
2093                                                  
2094                                                  =item lock_mode
2095                                                  
2096                                                  The lock mode of the lock that caused the deadlock.
2097                                                  
2098                                                  =item wait_hold
2099                                                  
2100                                                  Whether the transaction was waiting for the lock or holding the lock.  Usually
2101                                                  you will see the two waited-for locks.
2102                                                  
2103                                                  =item victim
2104                                                  
2105                                                  Whether the transaction was selected as the deadlock victim and rolled back.
2106                                                  
2107                                                  =item query
2108                                                  
2109                                                  The query that caused the deadlock.
2110                                                  
2111                                                  =back
2112                                                  
2113                                                  =head1 INNODB CAVEATS AND DETAILS
2114                                                  
2115                                                  InnoDB's output is hard to parse and sometimes there's no way to do it right.
2116                                                  
2117                                                  Sometimes not all information (for example, username or IP address) is included
2118                                                  in the deadlock information.  In this case there's nothing for the script to put
2119                                                  in those columns.  It may also be the case that the deadlock output is so long
2120                                                  (because there were a lot of locks) that the whole thing is truncated.
2121                                                  
2122                                                  Though there are usually two transactions involved in a deadlock, there are more
2123                                                  locks than that; at a minimum, one more lock than transactions is necessary to
2124                                                  create a cycle in the waits-for graph.  mk-deadlock-logger prints the
2125                                                  transactions (always two in the InnoDB output, even when there are more
2126                                                  transactions in the waits-for graph than that) and fills in locks.  It prefers
2127                                                  waited-for over held when choosing lock information to output, but you can
2128                                                  figure out the rest with a moment's thought.  If you see one wait-for and one
2129                                                  held lock, you're looking at the same lock, so of course you'd prefer to see
2130                                                  both wait-for locks and get more information.  If the two waited-for locks are
2131                                                  not on the same table, more than two transactions were involved in the deadlock.
2132                                                  
2133                                                  =head1 OPTIONS
2134                                                  
2135                                                  =over
2136                                                  
2137                                                  =item --ask-pass
2138                                                  
2139                                                  Prompt for a password when connecting to MySQL.
2140                                                  
2141                                                  =item --charset
2142                                                  
2143                                                  short form: -A; type: string
2144                                                  
2145                                                  Default character set.  If the value is utf8, sets Perl's binmode on
2146                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and runs SET
2147                                                  NAMES UTF8 after connecting to MySQL.  Any other value sets binmode on STDOUT
2148                                                  without the utf8 layer, and runs SET NAMES after connecting to MySQL.
2149                                                  
2150                                                  =item --clear-deadlocks
2151                                                  
2152                                                  type: string
2153                                                  
2154                                                  Use this table to create a small deadlock.  This usually has the effect of
2155                                                  clearing out a huge deadlock, which otherwise consumes the entire output of
2156                                                  C<SHOW INNODB STATUS>.  The table must not exist.  mk-deadlock-logger will
2157                                                  create it with the following MAGIC_clear_deadlocks structure:
2158                                                  
2159                                                    CREATE TABLE test.deadlock_maker(a INT PRIMARY KEY) ENGINE=InnoDB;
2160                                                  
2161                                                  After creating the table and causing a small deadlock, the tool will drop the
2162                                                  table again.
2163                                                  
2164                                                  =item --[no]collapse
2165                                                  
2166                                                  Collapse whitespace in queries to a single space.  This might make it easier to
2167                                                  inspect on the command line or in a query.  By default, whitespace is collapsed
2168                                                  when printing with L<"--print">, but not modified when storing to L<"--dest">.
2169                                                  (That is, the default is different for each action).
2170                                                  
2171                                                  =item --columns
2172                                                  
2173                                                  type: hash
2174                                                  
2175                                                  Output only this comma-separated list of columns.  See L<"OUTPUT"> for more
2176                                                  details on columns.
2177                                                  
2178                                                  =item --config
2179                                                  
2180                                                  type: Array
2181                                                  
2182                                                  Read this comma-separated list of config files; if specified, this must be the
2183                                                  first option on the command line.
2184                                                  
2185                                                  =item --create-dest-table
2186                                                  
2187                                                  Create the table specified by L<"--dest">.
2188                                                  
2189                                                  Normally the L<"--dest"> table is expected to exist already.  This option
2190                                                  causes mk-deadlock-logger to create the table automatically using the suggested
2191                                                  table structure.
2192                                                  
2193                                                  =item --daemonize
2194                                                  
2195                                                  Fork to the background and detach from the shell.  POSIX operating systems only.
2196                                                  
2197                                                  =item --defaults-file
2198                                                  
2199                                                  short form: -F; type: string
2200                                                  
2201                                                  Only read mysql options from the given file.  You must give an absolute
2202                                                  pathname.
2203                                                  
2204                                                  =item --dest
2205                                                  
2206                                                  type: DSN
2207                                                  
2208                                                  DSN for where to store deadlocks; specify at least a database (D) and table (t).
2209                                                  
2210                                                  Missing values are filled in with the same values from the source host, so you
2211                                                  can usually omit most parts of this argument if you're storing deadlocks on the
2212                                                  same server on which they happen.
2213                                                  
2214                                                  By default, whitespace in the query column is left intact;
2215                                                  use L<"--[no]collapse"> if you want whitespace collapsed.
2216                                                  
2217                                                  The following MAGIC_dest_table is suggested if you want to store all the
2218                                                  information mk-deadlock-logger can extract about deadlocks:
2219                                                  
2220                                                   CREATE TABLE deadlocks (
2221                                                     server char(20) NOT NULL,
2222                                                     ts datetime NOT NULL,
2223                                                     thread int unsigned NOT NULL,
2224                                                     txn_id bigint unsigned NOT NULL,
2225                                                     txn_time smallint unsigned NOT NULL,
2226                                                     user char(16) NOT NULL,
2227                                                     hostname char(20) NOT NULL,
2228                                                     ip char(15) NOT NULL, -- alternatively, ip int unsigned NOT NULL
2229                                                     db char(64) NOT NULL,
2230                                                     tbl char(64) NOT NULL,
2231                                                     idx char(64) NOT NULL,
2232                                                     lock_type char(16) NOT NULL,
2233                                                     lock_mode char(1) NOT NULL,
2234                                                     wait_hold char(1) NOT NULL,
2235                                                     victim tinyint unsigned NOT NULL,
2236                                                     query text NOT NULL,
2237                                                     PRIMARY KEY  (server,ts,thread)
2238                                                   ) ENGINE=InnoDB
2239                                                  
2240                                                  If you use L<"--columns">, you can omit whichever columns you don't want to
2241                                                  store.
2242                                                  
2243                                                  =item --help
2244                                                  
2245                                                  Show help and exit.
2246                                                  
2247                                                  =item --host
2248                                                  
2249                                                  short form: -h; type: string
2250                                                  
2251                                                  Connect to host.
2252                                                  
2253                                                  =item --interval
2254                                                  
2255                                                  type: time; default: 0s
2256                                                  
2257                                                  How often to check for deadlocks.
2258                                                  
2259                                                  =item --log
2260                                                  
2261                                                  type: string
2262                                                  
2263                                                  Print all output to this file when daemonized.
2264                                                  
2265                                                  =item --numeric-ip
2266                                                  
2267                                                  Express IP addresses as integers.
2268                                                  
2269                                                  =item --password
2270                                                  
2271                                                  short form: -p; type: string
2272                                                  
2273                                                  Password to use when connecting.
2274                                                  
2275                                                  =item --pid
2276                                                  
2277                                                  type: string
2278                                                  
2279                                                  Create the given PID file when daemonized.  The file contains the process ID of
2280                                                  the daemonized instance.  The PID file is removed when the daemonized instance
2281                                                  exits.  The program checks for the existence of the PID file when starting; if
2282                                                  it exists and the process with the matching PID exists, the program exits.
2283                                                  
2284                                                  =item --port
2285                                                  
2286                                                  short form: -P; type: int
2287                                                  
2288                                                  Port number to use for connection.
2289                                                  
2290                                                  =item --print
2291                                                  
2292                                                  Print results on standard output.  See L<"OUTPUT"> for more.  By default,
2293                                                  enables L<"--[no]collapse"> unless you explicitly disable it.
2294                                                  
2295                                                  =item --run-time
2296                                                  
2297                                                  type: time
2298                                                  
2299                                                  How long to run before exiting.
2300                                                  
2301                                                  =item --set-vars
2302                                                  
2303                                                  type: string; default: wait_timeout=10000
2304                                                  
2305                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this string
2306                                                  will be appended to SET and executed.
2307                                                  
2308                                                  =item --socket
2309                                                  
2310                                                  short form: -S; type: string
2311                                                  
2312                                                  Socket file to use for connection.
2313                                                  
2314                                                  =item --tab
2315                                                  
2316                                                  Print tab-separated columns, instead of aligned.
2317                                                  
2318                                                  =item --user
2319                                                  
2320                                                  short form: -u; type: string
2321                                                  
2322                                                  User for login if not current user.
2323                                                  
2324                                                  =item --version
2325                                                  
2326                                                  Show version and exit.
2327                                                  
2328                                                  =back
2329                                                  
2330                                                  =head1 DOWNLOADING
2331                                                  
2332                                                  You can download Maatkit from Google Code at
2333                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
2334                                                  easily with a command like the following:
2335                                                  
2336                                                     wget http://www.maatkit.org/get/toolname
2337                                                     or
2338                                                     wget http://www.maatkit.org/trunk/toolname
2339                                                  
2340                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
2341                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
2342                                                  needed.  The first URL gets the latest released version of the tool, and the
2343                                                  second gets the latest trunk code from Subversion.
2344                                                  
2345                                                  =head1 ENVIRONMENT
2346                                                  
2347                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
2348                                                  the Maatkit tools:
2349                                                  
2350                                                     MKDEBUG=1 mk-....
2351                                                  
2352                                                  =head1 SYSTEM REQUIREMENTS
2353                                                  
2354                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
2355                                                  installed in any reasonably new version of Perl.
2356                                                  
2357                                                  =head1 BUGS
2358                                                  
2359                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-deadlock-logger>.
2360                                                  
2361                                                  Please use Google Code Issues and Groups to report bugs or request support:
2362                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
2363                                                  discuss Maatkit.
2364                                                  
2365                                                  Please include the complete command-line used to reproduce the problem you are
2366                                                  seeing, the version of all MySQL servers involved, the complete output of the
2367                                                  tool when run with L<"--version">, and if possible, debugging output produced by
2368                                                  running with the C<MKDEBUG=1> environment variable.
2369                                                  
2370                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
2371                                                  
2372                                                  This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
2373                                                  Feedback and improvements are welcome.
2374                                                  
2375                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
2376                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
2377                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
2378                                                  
2379                                                  This program is free software; you can redistribute it and/or modify it under
2380                                                  the terms of the GNU General Public License as published by the Free Software
2381                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
2382                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
2383                                                  licenses.
2384                                                  
2385                                                  You should have received a copy of the GNU General Public License along with
2386                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
2387                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
2388                                                  
2389                                                  =head1 AUTHOR
2390                                                  
2391                                                  Baron Schwartz
2392                                                  
2393                                                  =head1 ABOUT MAATKIT
2394                                                  
2395                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
2396                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
2397                                                  code contributors.  Both are employed by Percona.  Financial support for
2398                                                  Maatkit development is primarily provided by Percona and its clients. 
2399                                                  
2400                                                  =head1 VERSION
2401                                                  
2402                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5425 $.
2403                                                  
2404                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
58    ***      0      0      0   unless $args{$arg}
64    ***      0      0      0   exists $args{'strict'} ? :
107   ***      0      0      0   unless open my $fh, '<', $file
127   ***      0      0      0   unless $para =~ /^=head1 OPTIONS/
132   ***      0      0      0   if $para =~ /^=over/
140   ***      0      0      0   unless $para
143   ***      0      0      0   if (my($option) = $para =~ /^=item --(.*)/)
150   ***      0      0      0   if ($para =~ /: /) { }
154   ***      0      0      0   unless $attributes{$attrib}
158   ***      0      0      0   if ($attribs{'short form'})
174   ***      0      0      0   if $para =~ /^=item/
176   ***      0      0      0   if (my($base_option) = $option =~ /^\[no\](.*)/)
181   ***      0      0      0   $attribs{'short form'} ? :
      ***      0      0      0   $attribs{'negatable'} ? :
      ***      0      0      0   $attribs{'cumulative'} ? :
      ***      0      0      0   $attribs{'type'} ? :
      ***      0      0      0   $attribs{'default'} ? :
      ***      0      0      0   $attribs{'group'} ? :
193   ***      0      0      0   unless $para
196   ***      0      0      0   if ($para =~ /^=head1/)
200   ***      0      0      0   if $para =~ /^=item --/
204   ***      0      0      0   unless @specs
215   ***      0      0      0   if (ref $opt) { }
220   ***      0      0      0   if (not $long)
225   ***      0      0      0   if exists $$self{'opts'}{$long}
228   ***      0      0      0   if (length $long == 1)
233   ***      0      0      0   if ($short) { }
234   ***      0      0      0   if exists $$self{'short_opts'}{$short}
243   ***      0      0      0   $$opt{'spec'} =~ /!/ ? :
244   ***      0      0      0   $$opt{'spec'} =~ /\+/ ? :
245   ***      0      0      0   $$opt{'desc'} =~ /required/ ? :
257   ***      0      0      0   if ($type and $type eq 'd' and not $$self{'dp'})
262   ***      0      0      0   if $type and $type =~ /[HhAadzm]/
264   ***      0      0      0   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
265   ***      0      0      0   defined $def ? :
269   ***      0      0      0   if ($long eq 'config')
273   ***      0      0      0   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
286   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
291   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
296   ***      0      0      0   if ($opt =~ /default to/)
301   ***      0      0      0   if ($opt =~ /restricted to option groups/)
311   ***      0      0      0   unless $rule_ok
328   ***      0      0      0   unless exists $$self{'opts'}{$long}
352   ***      0      0      0   unless exists $$self{'opts'}{$long}
372   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***      0      0      0   exists $$self{'opts'}{$opt} ? :
377   ***      0      0      0   if ($$opt{'is_cumulative'}) { }
392   ***      0      0      0   $$self{'opts'}{$long}{'is_cumulative'} ? :
      ***      0      0      0   exists $$self{'defaults'}{$long} ? :
401   ***      0      0      0   if (@ARGV and $ARGV[0] eq '--config')
405   ***      0      0      0   if ($self->has('config'))
411   ***      0      0      0   if ($EVAL_ERROR)
412   ***      0      0      0   $self->got('config') ? :
427   ***      0      0      0   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
430   ***      0      0      0   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
431   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
437   ***      0      0      0   if (@ARGV and $$self{'strict'})
443   ***      0      0      0   if (@set > 1)
454   ***      0      0      0   if (@set == 0)
464   ***      0      0      0   if ($$opt{'got'}) { }
      ***      0      0      0   elsif ($$opt{'is_required'}) { }
465   ***      0      0      0   if (exists $$self{'disables'}{$long})
472   ***      0      0      0   if (exists $$self{'allowed_groups'}{$long})
484   ***      0      0      0   if $restricted_opt eq $long
485   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
490   ***      0      0      0   if (@restricted_opts)
492   ***      0      0      0   if (@restricted_opts == 1) { }
521   ***      0      0      0   unless $opt and $$opt{'type'}
524   ***      0      0      0   if ($val and $$opt{'type'} eq 'm') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'd') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'z') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
527   ***      0      0      0   if (not $suffix)
533   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
534   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
549   ***      0      0      0   if ($from_key)
560   ***      0      0      0   if (defined $num) { }
561   ***      0      0      0   if ($factor)
588   ***      0      0      0   length $opt == 1 ? :
589   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
596   ***      0      0      0   length $opt == 1 ? :
597   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
604   ***      0      0      0   length $opt == 1 ? :
605   ***      0      0      0   defined $long ? :
610   ***      0      0      0   length $opt == 1 ? :
611   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
645   ***      0      0      0   if ($$self{'opts'}{'help'}{'got'}) { }
      ***      0      0      0   elsif (scalar @{$$self{'errors'};}) { }
646   ***      0      0      0   unless print $self->print_usage
650   ***      0      0      0   unless print $self->print_errors
659   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
668   ***      0      0      0   unless $$self{'got_opts'}
671   ***      0      0      0   $$_{'is_negatable'} ? :
675   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
691   ***      0      0      0   $group eq 'default' ? :
697   ***      0      0      0   $$opt{'is_negatable'} ? :
700   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
709   ***      0      0      0   if ($short) { }
718   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
722   ***      0      0      0   if ($$self{'dp'})
730   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
742   ***      0      0      0   if ref $_[0] eq 'OptionParser'
745   ***      0      0      0   unless print $prompt
753   ***      0      0      0   unless print "\n"
756   ***      0      0      0   if ($EVAL_ERROR)
778   ***      0      0      0   unless open my $fh, '<', $filename
786   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
789   ***      0      0      0   if ($line eq '--')
794   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
812   ***      0      0      0   unless open my $fh, '<', $file
816   ***      0      0      0   unless $para =~ /^=pod$/m
820   ***      0      0      0   unless $para =~ /$regex/
825   ***      0      0      0   unless close $fh
839   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
854   ***      0      0      0   defined $_ ? :
892   ***      0      0      0   if (not $$self{$dbh})
896   ***      0      0      0   $$self{$dbh} ge $self->parse($target) ? :
903   ***      0      0      0   defined $_ ? :
943   ***      0      0      0   unless defined $val
944   ***      0      0      0   if $val eq ''
946   ***      0      0      0   if (not defined $is_numeric)
947   ***      0      0      0   $val =~ /^0|\D/ ? :
950   ***      0      0      0   if $is_numeric
960   ***      0      0      0   if (not $tbl)
969   ***      0      0      0   unless $like
1054  ***     50      0     27   if (@_ > 2)
1063  ***     50      0      9   if (not $dsn)
1075  ***     50     36      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1087  ***     50      0     72   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1093         100     36     36   if (not defined $final_props{$key})
1100  ***     50      0     36   unless exists $opts{$key}
1103  ***     50      0      9   if (my $required = $self->prop('required'))
1105  ***      0      0      0   unless $final_props{$key}
1114  ***      0      0      0   unless ref $o eq 'OptionParser'
1117  ***      0      0      0   if $o->has($_)
1127  ***      0      0      0   unless ref $dsn
1128  ***      0      0      0   $_ eq 'p' ? :
1129  ***      0      0      0   if defined $$dsn{$_}
1142  ***      0      0      0   $opts{$key}{'copy'} ? :
1156  ***     50      0      9   if ($driver eq 'Pg') { }
1188  ***     50      0      9   $cxn_string =~ /charset=utf8/ ? :
1197  ***     50      0      9   if (not $have_dbi)
1216  ***     50      9      0   if ($cxn_string =~ /mysql/i)
1224  ***     50      0      9   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1229  ***      0      0      0   if ($charset eq 'utf8') { }
1230  ***      0      0      0   unless binmode STDOUT, ':utf8'
1234  ***      0      0      0   unless binmode STDOUT
1238  ***     50      0      9   if ($self->prop('set-vars'))
1245  ***     50      0      9   if (not $dbh and $EVAL_ERROR)
1247  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1260  ***      0      0      0   if (not $tries)
1282  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1299  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1309  ***      0      0      0   unless $dsn_1
1310  ***      0      0      0   unless $dsn_2
1314  ***      0      0      0   if ($args{'overwrite'}) { }
1315  ***      0      0      0   defined $$dsn_1{$key} ? :
1318  ***      0      0      0   defined $$dsn_2{$key} ? :
1327  ***      0      0      0   defined $_ ? :
1356  ***      0      0      0   unless $args{$arg}
1359  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
1375  ***      0      0      0   unless defined(my $pid = fork)
1376  ***      0      0      0   if ($pid)
1383  ***      0      0      0   unless POSIX::setsid()
1384  ***      0      0      0   unless chdir '/'
1390  ***      0      0      0   if (-t STDIN)
1392  ***      0      0      0   unless open STDIN, '/dev/null'
1396  ***      0      0      0   if ($$self{'log_file'}) { }
1398  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
1402  ***      0      0      0   unless open STDERR, '>&STDOUT'
1406  ***      0      0      0   if (-t STDOUT)
1408  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
1411  ***      0      0      0   if (-t STDERR)
1413  ***      0      0      0   unless open STDERR, '>', '/dev/null'
1424  ***      0      0      0   $self ? :
1426  ***      0      0      0   if ($PID_file and -f $PID_file) { }
1429  ***      0      0      0   if $EVAL_ERROR
1431  ***      0      0      0   if ($pid) { }
1433  ***      0      0      0   if ($pid_is_alive) { }
1455  ***      0      0      0   if (exists $$self{'child'})
1467  ***      0      0      0   if (not $PID_file)
1474  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
1476  ***      0      0      0   unless print $PID_FH $PID
1478  ***      0      0      0   unless close $PID_FH
1487  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
1488  ***      0      0      0   unless unlink $$self{'PID_file'}
1500  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
1506  ***      0      0      0   defined $_ ? :
1612  ***      0      0      0   unless $o->got('collapse')
1615  ***      0      0      0   @ARGV ? :
1621  ***      0      0      0   if ($source_dsn and $dest_dsn)
1627  ***      0      0      0   if (not $o->get('help'))
1628  ***      0      0      0   if (not $source_dsn)
1631  ***      0      0      0   if ($dest_dsn and not $$dest_dsn{'D'})
1634  ***      0      0      0   if ($dest_dsn and not $$dest_dsn{'t'})
1654  ***      0      0      0   if (not $$source_dsn{'h'})
1661  ***      0      0      0   if ($o->got('columns'))
1665  ***      0      0      0   if ($dest_dsn)
1676  ***      0      0      0   if ($o->get('create-dest-table'))
1687  ***      0      0      0   if ($o->get('daemonize')) { }
      ***      0      0      0   elsif ($o->get('pid')) { }
1709  ***      0      0      0   if ($ins_sth)
1716  ***      0      0      0   if ($o->got('print') or not $o->got('dest'))
1717  ***      0      0      0   $o->get('tab') ? :
1722  ***      0      0      0   if (not $o->got('collapse'))
1731  ***      0      0      0   if ($o->got('interval')) { }
1738  ***      0      0      0   if (my $db_tbl = $o->get('clear-deadlocks'))
1743  ***      0      0      0   if (not $vp->version_ge($dbh, '4.1.2'))
1755  ***      0      0      0   if (defined $pid and $pid == 0) { }
      ***      0      0      0   elsif (not defined $pid) { }
1792  ***      0      0      0   unless $name eq 'LATEST DETECTED DEADLOCK'
1796  ***      0      0      0   unless $dl_text
1811  ***      0      0      0   unless $txn_id
1815  ***      0      0      0   if ($what eq 'TRANSACTION') { }
1825  ***      0      0      0   if ($thread_line)
1834  ***      0      0      0   if (defined $query_status) { }
      ***      0      0      0   elsif ($thread_line =~ /query id \d+ /) { }
1843  ***      0      0      0   if (defined $ip) { }
1850  ***      0      0      0   if (not $query_status =~ /^\w+ing/ and not exists $is_proc_info{$query_status}) { }
1867  ***      0      0      0   if $o->got('collapse')
1872  ***      0      0      0   if (not defined $$hash{$key})
1880  ***      0      0      0   if ($what eq 'WAITING FOR THIS LOCK TO BE GRANTED' or not $$hash{'lock_type'})
1881  ***      0      0      0   $what eq 'WAITING FOR THIS LOCK TO BE GRANTED' ? :
1885  ***      0      0      0   if ($$hash{'txn_id'})
1887  ***      0      0      0   $high ? :
1893  ***      0      0      0   unless defined $$hash{$_}
1895  ***      0      0      0   unless defined $$hash{$_}
1908  ***      0      0      0   $$txn{'id'} == $victim ? :
1911  ***      0      0      0   if $o->got('numeric-ip')
1926  ***      0      0      0   if ($o->get('ask-pass'))
1936  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
257   ***      0      0      0      0   $type and $type eq 'd'
      ***      0      0      0      0   $type and $type eq 'd' and not $$self{'dp'}
262   ***      0      0      0      0   $type and $type =~ /[HhAadzm]/
401   ***      0      0      0      0   @ARGV and $ARGV[0] eq '--config'
430   ***      0      0      0      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
437   ***      0      0      0      0   @ARGV and $$self{'strict'}
521   ***      0      0      0      0   $opt and $$opt{'type'}
524   ***      0      0      0      0   $val and $$opt{'type'} eq 'm'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'd'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'z'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'a'
589   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
597   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
611   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
700   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
794   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1087  ***     66     36     36      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33     72      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1209  ***     66      9      0      9   not $dbh and $tries--
1245  ***     33      9      0      0   not $dbh and $EVAL_ERROR
1426  ***      0      0      0      0   $PID_file and -f $PID_file
1487  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
1621  ***      0      0      0      0   $source_dsn and $dest_dsn
1631  ***      0      0      0      0   $dest_dsn and not $$dest_dsn{'D'}
1634  ***      0      0      0      0   $dest_dsn and not $$dest_dsn{'t'}
1699  ***      0      0      0      0   $start == $end || $now < $end and $oktorun
1755  ***      0      0      0      0   defined $pid and $pid == 0
1850  ***      0      0      0      0   not $query_status =~ /^\w+ing/ and not exists $is_proc_info{$query_status}

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
42    ***     50      0      6   $ENV{'MKDEBUG'} || 0
62    ***      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
64    ***      0      0      0   $args{'prompt'} || '<options>'
      ***      0      0      0   $args{'dp'} || undef
106   ***      0      0      0   $file ||= '/home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger'
247   ***      0      0      0   $$opt{'group'} ||= 'default'
529   ***      0      0      0   $s || 's'
538   ***      0      0      0   $prefix || ''
566   ***      0      0      0   $pre || ''
573   ***      0      0      0   $val || ''
576   ***      0      0      0   $val || ''
634   ***      0      0      0   $$self{'description'} || ''
702   ***      0      0      0   $s ||= 's'
728   ***      0      0      0   $$opt{'type'} || ''
876   ***     50      0      6   $ENV{'MKDEBUG'} || 0
925   ***     50      0      6   $ENV{'MKDEBUG'} || 0
997   ***     50      0      6   $ENV{'MKDEBUG'} || 0
1068  ***     50      0      9   $prev ||= {}
1069  ***     50      0      9   $defaults ||= {}
1142  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1155  ***     50      0      9   $self->prop('dbidriver') || ''
1159  ***      0      0      0   $$info{'D'} || ''
1165  ***     50      0      9   $$info{'D'} || ''
1187  ***     50      9      0   $opts ||= {}
1282  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1298  ***      0      0      0   $level ||= 0
1299  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1351  ***     50      0      6   $ENV{'MKDEBUG'} || 0
1533  ***     50      0      6   $ENV{'MKDEBUG'} || 0
1646  ***      0      0      0   $o->get('run-time') || 0
1812  ***      0      0      0   $txns{$txn_id} ||= {'id', $txn_id}
1904  ***      0      0      0   $victim ||= 0
1910  ***      0      0      0   $$source_dsn{'h'} || ''

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
61    ***      0      0      0      0   $program_name ||= $PROGRAM_NAME
62    ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
524   ***      0      0      0      0   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1178  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1179  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1180  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1181  ***      0      0      0      0   $$dsn{'u'} ||= $user
1182  ***      0      0      0      0   $$dsn{'D'} ||= $db
1500  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
1699  ***      0      0      0      0   $start == $end || $now < $end
1716  ***      0      0      0      0   $o->got('print') or not $o->got('dest')
1880  ***      0      0      0      0   $what eq 'WAITING FOR THIS LOCK TO BE GRANTED' or not $$hash{'lock_type'}


Covered Subroutines
-------------------

Subroutine           Count Location                                                           
-------------------- ----- -------------------------------------------------------------------
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1345
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1346
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1348
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1349
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1351
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1528
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1529
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1530
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1531
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1533
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:23  
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:24  
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:35  
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:36  
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:38  
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:39  
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:40  
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:42  
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:871 
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:872 
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:874 
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:876 
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:918 
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:919 
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:923 
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:925 
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:985 
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:986 
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:987 
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:988 
BEGIN                    6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:997 
get_cxn_params           9 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1152
get_dbh                  9 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1186
new                      6 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1000
parse                    9 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1062
prop                    27 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1053

Uncovered Subroutines
---------------------

Subroutine           Count Location                                                           
-------------------- ----- -------------------------------------------------------------------
DESTROY                  0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1499
__ANON__                 0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:425 
_d                       0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1326
_d                       0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1505
_d                       0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1935
_d                       0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:853 
_d                       0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:902 
_get_participants        0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:325 
_make_PID_file           0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1464
_parse_specs             0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:211 
_pod_to_specs            0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:105 
_read_config_file        0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:777 
_remove_PID_file         0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1486
_set_option              0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:371 
_validate_type           0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:520 
as_string                0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1126
check_PID_file           0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1423
clone                    0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:830 
copy                     0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1308
daemonize                0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1372
descr                    0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:633 
disconnect               0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1291
errors                   0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:623 
fill_in_dsn              0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1174
finish                   0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1919
get                      0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:587 
get_cxn                  0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1925
get_defaults             0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:361 
get_defaults_files       0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:100 
get_groups               0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:366 
get_hostname             0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1281
get_opts                 0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:388 
get_specs                0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:93  
got                      0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:595 
has                      0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:603 
literal_like             0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:968 
main                     0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1587
make_PID_file            0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1454
new                      0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1354
new                      0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:56  
new                      0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:879 
new                      0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:928 
opts                     0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:337 
parse                    0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:884 
parse_deadlocks          0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1787
parse_options            0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1113
print_active_handles     0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1297
print_errors             0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:657 
print_usage              0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:667 
prompt                   0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:628 
prompt_noecho            0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:742 
quote                    0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:933 
quote_val                0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:941 
read_para_after          0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:811 
save_error               0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:618 
set                      0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:609 
set_defaults             0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:349 
short_opts               0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:343 
split_unquote            0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:957 
usage                    0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:1135
usage_or_errors          0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:644 
version_ge               0 /home/daniel/dev/maatkit/mk-deadlock-logger/mk-deadlock-logger:891 


