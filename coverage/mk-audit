---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...maatkit/mk-audit/mk-audit   13.2    1.7    3.2   35.0    n/a    0.2   10.9
mk-audit.t                    100.0   50.0   33.3  100.0    n/a   99.8   92.5
Total                          14.8    2.0    3.4   36.9    n/a  100.0   12.1
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:21:15 2010
Finish:       Thu Jan 28 22:21:15 2010

Run:          ./mk-audit.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:21:17 2010
Finish:       Thu Jan 28 22:21:18 2010

/home/daniel/dev/maatkit/mk-audit/mk-audit

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This is mk-audit, a program to inspect, analyze, and report on a MySQL server.
4                                                     #
5                                                     # This program is copyright 2008-@CURRENTYEAR@ Percona Inc.
6                                                     # Feedback and improvements are welcome.
7                                                     #
8                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
9                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
10                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
11                                                    #
12                                                    # This program is free software; you can redistribute it and/or modify it under
13                                                    # the terms of the GNU General Public License as published by the Free Software
14                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
15                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
16                                                    # licenses.
17                                                    #
18                                                    # You should have received a copy of the GNU General Public License along with
19                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
20                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
21                                                    
22             1                    1            12   use strict;
               1                                  6   
               1                                 15   
23             1                    1            11   use warnings FATAL => 'all';
               1                                  2   
               1                                  7   
24                                                    
25                                                    our $VERSION = '@VERSION@';
26                                                    our $DISTRIB = '@DISTRIB@';
27                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5352 $ =~ m/(\d+)/g, 0));
28                                                    
29                                                    # ###########################################################################
30                                                    # MySQLDump package 4160
31                                                    # ###########################################################################
32                                                    package MySQLDump;
33                                                    
34             1                    1             7   use strict;
               1                                  6   
               1                                  5   
35             1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  5   
36                                                    
37             1                    1             7   use English qw(-no_match_vars);
               1                                  2   
               1                                  6   
38                                                    
39             1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  9   
40                                                    
41                                                    ( our $before = <<'EOF') =~ s/^   //gm;
42                                                       /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
43                                                       /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
44                                                       /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
45                                                       /*!40101 SET NAMES utf8 */;
46                                                       /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
47                                                       /*!40103 SET TIME_ZONE='+00:00' */;
48                                                       /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
49                                                       /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
50                                                       /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
51                                                       /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
52                                                    EOF
53                                                    
54                                                    ( our $after = <<'EOF') =~ s/^   //gm;
55                                                       /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
56                                                       /*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
57                                                       /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
58                                                       /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
59                                                       /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
60                                                       /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
61                                                       /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
62                                                       /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
63                                                    EOF
64                                                    
65                                                    sub new {
66    ***      0                    0             0      my ( $class, %args ) = @_;
67    ***      0      0                           0      $args{cache} = 1 unless defined $args{cache};
68    ***      0                                  0      my $self = bless \%args, $class;
69    ***      0                                  0      return $self;
70                                                    }
71                                                    
72                                                    sub dump {
73    ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl, $what ) = @_;
74                                                    
75    ***      0      0                           0      if ( $what eq 'table' ) {
      ***             0                               
      ***             0                               
76    ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
77    ***      0      0                           0         return unless $ddl;
78    ***      0      0                           0         if ( $ddl->[0] eq 'table' ) {
79    ***      0                                  0            return $before
80                                                                . 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
81                                                                . $ddl->[1] . ";\n";
82                                                          }
83                                                          else {
84    ***      0                                  0            return 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
85                                                                . '/*!50001 DROP VIEW IF EXISTS '
86                                                                . $quoter->quote($tbl) . "*/;\n/*!50001 "
87                                                                . $self->get_tmp_table($dbh, $quoter, $db, $tbl) . "*/;\n";
88                                                          }
89                                                       }
90                                                       elsif ( $what eq 'triggers' ) {
91    ***      0                                  0         my $trgs = $self->get_triggers($dbh, $quoter, $db, $tbl);
92    ***      0      0      0                    0         if ( $trgs && @$trgs ) {
93    ***      0                                  0            my $result = $before . "\nDELIMITER ;;\n";
94    ***      0                                  0            foreach my $trg ( @$trgs ) {
95    ***      0      0                           0               if ( $trg->{sql_mode} ) {
96    ***      0                                  0                  $result .= qq{/*!50003 SET SESSION SQL_MODE='$trg->{sql_mode}' */;;\n};
97                                                                }
98    ***      0                                  0               $result .= "/*!50003 CREATE */ ";
99    ***      0      0                           0               if ( $trg->{definer} ) {
100   ***      0                                  0                  my ( $user, $host )
101   ***      0                                  0                     = map { s/'/''/g; "'$_'"; }
      ***      0                                  0   
102                                                                       split('@', $trg->{definer}, 2);
103   ***      0                                  0                  $result .= "/*!50017 DEFINER=$user\@$host */ ";
104                                                               }
105   ***      0                                  0               $result .= sprintf("/*!50003 TRIGGER %s %s %s ON %s\nFOR EACH ROW %s */;;\n\n",
106                                                                  $quoter->quote($trg->{trigger}),
107   ***      0                                  0                  @{$trg}{qw(timing event)},
108                                                                  $quoter->quote($trg->{table}),
109                                                                  $trg->{statement});
110                                                            }
111   ***      0                                  0            $result .= "DELIMITER ;\n\n/*!50003 SET SESSION SQL_MODE=\@OLD_SQL_MODE */;\n\n";
112   ***      0                                  0            return $result;
113                                                         }
114                                                         else {
115   ***      0                                  0            return undef;
116                                                         }
117                                                      }
118                                                      elsif ( $what eq 'view' ) {
119   ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
120   ***      0                                  0         return '/*!50001 DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
121                                                            . '/*!50001 DROP VIEW IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
122                                                            . '/*!50001 ' . $ddl->[1] . "*/;\n";
123                                                      }
124                                                      else {
125   ***      0                                  0         die "You didn't say what to dump.";
126                                                      }
127                                                   }
128                                                   
129                                                   sub _use_db {
130   ***      0                    0             0      my ( $self, $dbh, $quoter, $new ) = @_;
131   ***      0      0                           0      if ( !$new ) {
132   ***      0                                  0         MKDEBUG && _d('No new DB to use');
133   ***      0                                  0         return;
134                                                      }
135   ***      0                                  0      my $sql = 'SELECT DATABASE()';
136   ***      0                                  0      MKDEBUG && _d($sql);
137   ***      0                                  0      my $curr = $dbh->selectrow_array($sql);
138   ***      0      0      0                    0      if ( $curr && $new && $curr eq $new ) {
      ***                    0                        
139   ***      0                                  0         MKDEBUG && _d('Current and new DB are the same');
140   ***      0                                  0         return $curr;
141                                                      }
142   ***      0                                  0      $sql = 'USE ' . $quoter->quote($new);
143   ***      0                                  0      MKDEBUG && _d($sql);
144   ***      0                                  0      $dbh->do($sql);
145   ***      0                                  0      return $curr;
146                                                   }
147                                                   
148                                                   sub get_create_table {
149   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
150   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{tables}->{$db}->{$tbl} ) {
151   ***      0                                  0         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
152                                                            . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
153                                                            . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
154                                                            . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
155   ***      0                                  0         MKDEBUG && _d($sql);
156   ***      0                                  0         eval { $dbh->do($sql); };
      ***      0                                  0   
157   ***      0                                  0         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
158   ***      0                                  0         my $curr_db = $self->_use_db($dbh, $quoter, $db);
159   ***      0                                  0         $sql = "SHOW CREATE TABLE " . $quoter->quote($db, $tbl);
160   ***      0                                  0         MKDEBUG && _d($sql);
161   ***      0                                  0         my $href;
162   ***      0                                  0         eval { $href = $dbh->selectrow_hashref($sql); };
      ***      0                                  0   
163   ***      0      0                           0         if ( $EVAL_ERROR ) {
164   ***      0                                  0            warn "Failed to $sql.  The table may be damaged.\nError: $EVAL_ERROR";
165   ***      0                                  0            return;
166                                                         }
167   ***      0                                  0         $self->_use_db($dbh, $quoter, $curr_db);
168   ***      0                                  0         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
169                                                            . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
170   ***      0                                  0         MKDEBUG && _d($sql);
171   ***      0                                  0         $dbh->do($sql);
172   ***      0                                  0         my ($key) = grep { m/create table/i } keys %$href;
      ***      0                                  0   
173   ***      0      0                           0         if ( $key ) {
174   ***      0                                  0            MKDEBUG && _d('This table is a base table');
175   ***      0                                  0            $self->{tables}->{$db}->{$tbl} = [ 'table', $href->{$key} ];
176                                                         }
177                                                         else {
178   ***      0                                  0            MKDEBUG && _d('This table is a view');
179   ***      0                                  0            ($key) = grep { m/create view/i } keys %$href;
      ***      0                                  0   
180   ***      0                                  0            $self->{tables}->{$db}->{$tbl} = [ 'view', $href->{$key} ];
181                                                         }
182                                                      }
183   ***      0                                  0      return $self->{tables}->{$db}->{$tbl};
184                                                   }
185                                                   
186                                                   sub get_columns {
187   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
188   ***      0                                  0      MKDEBUG && _d('Get columns for', $db, $tbl);
189   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{columns}->{$db}->{$tbl} ) {
190   ***      0                                  0         my $curr_db = $self->_use_db($dbh, $quoter, $db);
191   ***      0                                  0         my $sql = "SHOW COLUMNS FROM " . $quoter->quote($db, $tbl);
192   ***      0                                  0         MKDEBUG && _d($sql);
193   ***      0                                  0         my $cols = $dbh->selectall_arrayref($sql, { Slice => {} });
194   ***      0                                  0         $self->_use_db($dbh, $quoter, $curr_db);
195   ***      0                                  0         $self->{columns}->{$db}->{$tbl} = [
196                                                            map {
197   ***      0                                  0               my %row;
198   ***      0                                  0               @row{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
199   ***      0                                  0               \%row;
200                                                            } @$cols
201                                                         ];
202                                                      }
203   ***      0                                  0      return $self->{columns}->{$db}->{$tbl};
204                                                   }
205                                                   
206                                                   sub get_tmp_table {
207   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
208   ***      0                                  0      my $result = 'CREATE TABLE ' . $quoter->quote($tbl) . " (\n";
209   ***      0                                  0      $result .= join(",\n",
210   ***      0                                  0         map { '  ' . $quoter->quote($_->{field}) . ' ' . $_->{type} }
211   ***      0                                  0         @{$self->get_columns($dbh, $quoter, $db, $tbl)});
212   ***      0                                  0      $result .= "\n)";
213   ***      0                                  0      MKDEBUG && _d($result);
214   ***      0                                  0      return $result;
215                                                   }
216                                                   
217                                                   sub get_triggers {
218   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
219   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{triggers}->{$db} ) {
220   ***      0                                  0         $self->{triggers}->{$db} = {};
221   ***      0                                  0         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
222                                                            . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
223                                                            . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
224                                                            . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
225   ***      0                                  0         MKDEBUG && _d($sql);
226   ***      0                                  0         eval { $dbh->do($sql); };
      ***      0                                  0   
227   ***      0                                  0         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
228   ***      0                                  0         $sql = "SHOW TRIGGERS FROM " . $quoter->quote($db);
229   ***      0                                  0         MKDEBUG && _d($sql);
230   ***      0                                  0         my $sth = $dbh->prepare($sql);
231   ***      0                                  0         $sth->execute();
232   ***      0      0                           0         if ( $sth->rows ) {
233   ***      0                                  0            my $trgs = $sth->fetchall_arrayref({});
234   ***      0                                  0            foreach my $trg (@$trgs) {
235   ***      0                                  0               my %trg;
236   ***      0                                  0               @trg{ map { lc $_ } keys %$trg } = values %$trg;
      ***      0                                  0   
237   ***      0                                  0               push @{ $self->{triggers}->{$db}->{ $trg{table} } }, \%trg;
      ***      0                                  0   
238                                                            }
239                                                         }
240   ***      0                                  0         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
241                                                            . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
242   ***      0                                  0         MKDEBUG && _d($sql);
243   ***      0                                  0         $dbh->do($sql);
244                                                      }
245   ***      0      0                           0      if ( $tbl ) {
246   ***      0                                  0         return $self->{triggers}->{$db}->{$tbl};
247                                                      }
248   ***      0                                  0      return values %{$self->{triggers}->{$db}};
      ***      0                                  0   
249                                                   }
250                                                   
251                                                   sub get_databases {
252   ***      0                    0             0      my ( $self, $dbh, $quoter, $like ) = @_;
253   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{databases} || $like ) {
      ***                    0                        
254   ***      0                                  0         my $sql = 'SHOW DATABASES';
255   ***      0                                  0         my @params;
256   ***      0      0                           0         if ( $like ) {
257   ***      0                                  0            $sql .= ' LIKE ?';
258   ***      0                                  0            push @params, $like;
259                                                         }
260   ***      0                                  0         my $sth = $dbh->prepare($sql);
261   ***      0                                  0         MKDEBUG && _d($sql, @params);
262   ***      0                                  0         $sth->execute( @params );
263   ***      0                                  0         my @dbs = map { $_->[0] } @{$sth->fetchall_arrayref()};
      ***      0                                  0   
      ***      0                                  0   
264   ***      0      0                           0         $self->{databases} = \@dbs unless $like;
265   ***      0                                  0         return @dbs;
266                                                      }
267   ***      0                                  0      return @{$self->{databases}};
      ***      0                                  0   
268                                                   }
269                                                   
270                                                   sub get_table_status {
271   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
272   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_status}->{$db} || $like ) {
      ***                    0                        
273   ***      0                                  0         my $sql = "SHOW TABLE STATUS FROM " . $quoter->quote($db);
274   ***      0                                  0         my @params;
275   ***      0      0                           0         if ( $like ) {
276   ***      0                                  0            $sql .= ' LIKE ?';
277   ***      0                                  0            push @params, $like;
278                                                         }
279   ***      0                                  0         MKDEBUG && _d($sql, @params);
280   ***      0                                  0         my $sth = $dbh->prepare($sql);
281   ***      0                                  0         $sth->execute(@params);
282   ***      0                                  0         my @tables = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
283   ***      0                                  0         @tables = map {
284   ***      0                                  0            my %tbl; # Make a copy with lowercased keys
285   ***      0                                  0            @tbl{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
286   ***      0             0                    0            $tbl{engine} ||= $tbl{type} || $tbl{comment};
      ***                    0                        
287   ***      0                                  0            delete $tbl{type};
288   ***      0                                  0            \%tbl;
289                                                         } @tables;
290   ***      0      0                           0         $self->{table_status}->{$db} = \@tables unless $like;
291   ***      0                                  0         return @tables;
292                                                      }
293   ***      0                                  0      return @{$self->{table_status}->{$db}};
      ***      0                                  0   
294                                                   }
295                                                   
296                                                   sub get_table_list {
297   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
298   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_list}->{$db} || $like ) {
      ***                    0                        
299   ***      0                                  0         my $sql = "SHOW /*!50002 FULL*/ TABLES FROM " . $quoter->quote($db);
300   ***      0                                  0         my @params;
301   ***      0      0                           0         if ( $like ) {
302   ***      0                                  0            $sql .= ' LIKE ?';
303   ***      0                                  0            push @params, $like;
304                                                         }
305   ***      0                                  0         MKDEBUG && _d($sql, @params);
306   ***      0                                  0         my $sth = $dbh->prepare($sql);
307   ***      0                                  0         $sth->execute(@params);
308   ***      0                                  0         my @tables = @{$sth->fetchall_arrayref()};
      ***      0                                  0   
309   ***      0      0      0                    0         @tables = map {
310   ***      0                                  0            my %tbl = (
311                                                               name   => $_->[0],
312                                                               engine => ($_->[1] || '') eq 'VIEW' ? 'VIEW' : '',
313                                                            );
314   ***      0                                  0            \%tbl;
315                                                         } @tables;
316   ***      0      0                           0         $self->{table_list}->{$db} = \@tables unless $like;
317   ***      0                                  0         return @tables;
318                                                      }
319   ***      0                                  0      return @{$self->{table_list}->{$db}};
      ***      0                                  0   
320                                                   }
321                                                   
322                                                   sub _d {
323   ***      0                    0             0      my ($package, undef, $line) = caller 0;
324   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
325   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
326                                                           @_;
327   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
328                                                   }
329                                                   
330                                                   1;
331                                                   
332                                                   # ###########################################################################
333                                                   # End MySQLDump package
334                                                   # ###########################################################################
335                                                   
336                                                   # ###########################################################################
337                                                   # OptionParser package 4805
338                                                   # ###########################################################################
339                                                   package OptionParser;
340                                                   
341            1                    1             9   use strict;
               1                                  3   
               1                                  9   
342            1                    1             7   use warnings FATAL => 'all';
               1                                  2   
               1                                  6   
343                                                   
344            1                    1            11   use Getopt::Long;
               1                                  4   
               1                                  7   
345            1                    1            12   use List::Util qw(max);
               1                                  3   
               1                                 13   
346            1                    1             8   use English qw(-no_match_vars);
               1                                  2   
               1                                  8   
347                                                   
348            1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  9   
349                                                   
350                                                   my $POD_link_re = '[LC]<"?([^">]+)"?>';
351                                                   
352                                                   my %attributes = (
353                                                      'type'       => 1,
354                                                      'short form' => 1,
355                                                      'group'      => 1,
356                                                      'default'    => 1,
357                                                      'cumulative' => 1,
358                                                      'negatable'  => 1,
359                                                   );
360                                                   
361                                                   sub new {
362   ***      0                    0             0      my ( $class, %args ) = @_;
363   ***      0                                  0      foreach my $arg ( qw(description) ) {
364   ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
365                                                      }
366   ***      0                                  0      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
367   ***      0             0                    0      $program_name ||= $PROGRAM_NAME;
368   ***      0             0                    0      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                    0                        
      ***                    0                        
369                                                   
370   ***      0      0      0                    0      my $self = {
      ***                    0                        
371                                                         description    => $args{description},
372                                                         prompt         => $args{prompt} || '<options>',
373                                                         strict         => (exists $args{strict} ? $args{strict} : 1),
374                                                         dp             => $args{dp}     || undef,
375                                                         program_name   => $program_name,
376                                                         opts           => {},
377                                                         got_opts       => 0,
378                                                         short_opts     => {},
379                                                         defaults       => {},
380                                                         groups         => {},
381                                                         allowed_groups => {},
382                                                         errors         => [],
383                                                         rules          => [],  # desc of rules for --help
384                                                         mutex          => [],  # rule: opts are mutually exclusive
385                                                         atleast1       => [],  # rule: at least one opt is required
386                                                         disables       => {},  # rule: opt disables other opts 
387                                                         defaults_to    => {},  # rule: opt defaults to value of other opt
388                                                         default_files  => [
389                                                            "/etc/maatkit/maatkit.conf",
390                                                            "/etc/maatkit/$program_name.conf",
391                                                            "$home/.maatkit.conf",
392                                                            "$home/.$program_name.conf",
393                                                         ],
394                                                      };
395   ***      0                                  0      return bless $self, $class;
396                                                   }
397                                                   
398                                                   sub get_specs {
399   ***      0                    0             0      my ( $self, $file ) = @_;
400   ***      0                                  0      my @specs = $self->_pod_to_specs($file);
401   ***      0                                  0      $self->_parse_specs(@specs);
402   ***      0                                  0      return;
403                                                   }
404                                                   
405                                                   sub get_defaults_files {
406   ***      0                    0             0      my ( $self ) = @_;
407   ***      0                                  0      return @{$self->{default_files}};
      ***      0                                  0   
408                                                   }
409                                                   
410                                                   sub _pod_to_specs {
411   ***      0                    0             0      my ( $self, $file ) = @_;
412   ***      0             0                    0      $file ||= __FILE__;
413   ***      0      0                           0      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
414                                                   
415   ***      0                                  0      my %types = (
416                                                         string => 's', # standard Getopt type
417                                                         'int'  => 'i', # standard Getopt type
418                                                         float  => 'f', # standard Getopt type
419                                                         Hash   => 'H', # hash, formed from a comma-separated list
420                                                         hash   => 'h', # hash as above, but only if a value is given
421                                                         Array  => 'A', # array, similar to Hash
422                                                         array  => 'a', # array, similar to hash
423                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
424                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
425                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
426                                                      );
427   ***      0                                  0      my @specs = ();
428   ***      0                                  0      my @rules = ();
429   ***      0                                  0      my $para;
430                                                   
431   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
432   ***      0                                  0      while ( $para = <$fh> ) {
433   ***      0      0                           0         next unless $para =~ m/^=head1 OPTIONS/;
434   ***      0                                  0         last;
435                                                      }
436                                                   
437   ***      0                                  0      while ( $para = <$fh> ) {
438   ***      0      0                           0         last if $para =~ m/^=over/;
439   ***      0                                  0         chomp $para;
440   ***      0                                  0         $para =~ s/\s+/ /g;
441   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
442   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
443   ***      0                                  0         push @rules, $para;
444                                                      }
445                                                   
446   ***      0      0                           0      die 'POD has no OPTIONS section' unless $para;
447                                                   
448   ***      0                                  0      do {
449   ***      0      0                           0         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
450   ***      0                                  0            chomp $para;
451   ***      0                                  0            MKDEBUG && _d($para);
452   ***      0                                  0            my %attribs;
453                                                   
454   ***      0                                  0            $para = <$fh>; # read next paragraph, possibly attributes
455                                                   
456   ***      0      0                           0            if ( $para =~ m/: / ) { # attributes
457   ***      0                                  0               $para =~ s/\s+\Z//g;
458   ***      0                                  0               %attribs = map {
459   ***      0                                  0                     my ( $attrib, $val) = split(/: /, $_);
460   ***      0      0                           0                     die "Unrecognized attribute for --$option: $attrib"
461                                                                        unless $attributes{$attrib};
462   ***      0                                  0                     ($attrib, $val);
463                                                                  } split(/; /, $para);
464   ***      0      0                           0               if ( $attribs{'short form'} ) {
465   ***      0                                  0                  $attribs{'short form'} =~ s/-//;
466                                                               }
467   ***      0                                  0               $para = <$fh>; # read next paragraph, probably short help desc
468                                                            }
469                                                            else {
470   ***      0                                  0               MKDEBUG && _d('Option has no attributes');
471                                                            }
472                                                   
473   ***      0                                  0            $para =~ s/\s+\Z//g;
474   ***      0                                  0            $para =~ s/\s+/ /g;
475   ***      0                                  0            $para =~ s/$POD_link_re/$1/go;
476                                                   
477   ***      0                                  0            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
478   ***      0                                  0            MKDEBUG && _d('Short help:', $para);
479                                                   
480   ***      0      0                           0            die "No description after option spec $option" if $para =~ m/^=item/;
481                                                   
482   ***      0      0                           0            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
483   ***      0                                  0               $option = $base_option;
484   ***      0                                  0               $attribs{'negatable'} = 1;
485                                                            }
486                                                   
487   ***      0      0                           0            push @specs, {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
488                                                               spec  => $option
489                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
490                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
491                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
492                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
493                                                               desc  => $para
494                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
495                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
496                                                            };
497                                                         }
498   ***      0                                  0         while ( $para = <$fh> ) {
499   ***      0      0                           0            last unless $para;
500                                                   
501                                                   
502   ***      0      0                           0            if ( $para =~ m/^=head1/ ) {
503   ***      0                                  0               $para = undef; # Can't 'last' out of a do {} block.
504   ***      0                                  0               last;
505                                                            }
506   ***      0      0                           0            last if $para =~ m/^=item --/;
507                                                         }
508                                                      } while ( $para );
509                                                   
510   ***      0      0                           0      die 'No valid specs in POD OPTIONS' unless @specs;
511                                                   
512   ***      0                                  0      close $fh;
513   ***      0                                  0      return @specs, @rules;
514                                                   }
515                                                   
516                                                   sub _parse_specs {
517   ***      0                    0             0      my ( $self, @specs ) = @_;
518   ***      0                                  0      my %disables; # special rule that requires deferred checking
519                                                   
520   ***      0                                  0      foreach my $opt ( @specs ) {
521   ***      0      0                           0         if ( ref $opt ) { # It's an option spec, not a rule.
522                                                            MKDEBUG && _d('Parsing opt spec:',
523   ***      0                                  0               map { ($_, '=>', $opt->{$_}) } keys %$opt);
524                                                   
525   ***      0                                  0            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
526   ***      0      0                           0            if ( !$long ) {
527   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
528                                                            }
529   ***      0                                  0            $opt->{long} = $long;
530                                                   
531   ***      0      0                           0            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
532   ***      0                                  0            $self->{opts}->{$long} = $opt;
533                                                   
534   ***      0      0                           0            if ( length $long == 1 ) {
535   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
536   ***      0                                  0               $self->{short_opts}->{$long} = $long;
537                                                            }
538                                                   
539   ***      0      0                           0            if ( $short ) {
540   ***      0      0                           0               die "Duplicate short option -$short"
541                                                                  if exists $self->{short_opts}->{$short};
542   ***      0                                  0               $self->{short_opts}->{$short} = $long;
543   ***      0                                  0               $opt->{short} = $short;
544                                                            }
545                                                            else {
546   ***      0                                  0               $opt->{short} = undef;
547                                                            }
548                                                   
549   ***      0      0                           0            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
550   ***      0      0                           0            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
551   ***      0      0                           0            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
552                                                   
553   ***      0             0                    0            $opt->{group} ||= 'default';
554   ***      0                                  0            $self->{groups}->{ $opt->{group} }->{$long} = 1;
555                                                   
556   ***      0                                  0            $opt->{value} = undef;
557   ***      0                                  0            $opt->{got}   = 0;
558                                                   
559   ***      0                                  0            my ( $type ) = $opt->{spec} =~ m/=(.)/;
560   ***      0                                  0            $opt->{type} = $type;
561   ***      0                                  0            MKDEBUG && _d($long, 'type:', $type);
562                                                   
563   ***      0      0      0                    0            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                    0                        
564   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
565                                                                  . "was given when this OptionParser object was created";
566                                                            }
567                                                   
568   ***      0      0      0                    0            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
569                                                   
570   ***      0      0                           0            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
571   ***      0      0                           0               $self->{defaults}->{$long} = defined $def ? $def : 1;
572   ***      0                                  0               MKDEBUG && _d($long, 'default:', $def);
573                                                            }
574                                                   
575   ***      0      0                           0            if ( $long eq 'config' ) {
576   ***      0                                  0               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
577                                                            }
578                                                   
579   ***      0      0                           0            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
580   ***      0                                  0               $disables{$long} = $dis;
581   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
582                                                            }
583                                                   
584   ***      0                                  0            $self->{opts}->{$long} = $opt;
585                                                         }
586                                                         else { # It's an option rule, not a spec.
587   ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
588   ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
589   ***      0                                  0            my @participants = $self->_get_participants($opt);
590   ***      0                                  0            my $rule_ok = 0;
591                                                   
592   ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
593   ***      0                                  0               $rule_ok = 1;
594   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
595   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
596                                                            }
597   ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
598   ***      0                                  0               $rule_ok = 1;
599   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
600   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
601                                                            }
602   ***      0      0                           0            if ( $opt =~ m/default to/ ) {
603   ***      0                                  0               $rule_ok = 1;
604   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
605   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
606                                                            }
607   ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
608   ***      0                                  0               $rule_ok = 1;
609   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
610   ***      0                                  0               my @groups = split(',', $groups);
611   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
612   ***      0                                  0                  s/\s+//;
613   ***      0                                  0                  $_ => 1;
614                                                               } @groups;
615                                                            }
616                                                   
617   ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
618                                                         }
619                                                      }
620                                                   
621   ***      0                                  0      foreach my $long ( keys %disables ) {
622   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
623   ***      0                                  0         $self->{disables}->{$long} = \@participants;
624   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
625                                                      }
626                                                   
627   ***      0                                  0      return; 
628                                                   }
629                                                   
630                                                   sub _get_participants {
631   ***      0                    0             0      my ( $self, $str ) = @_;
632   ***      0                                  0      my @participants;
633   ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
634   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
635                                                            unless exists $self->{opts}->{$long};
636   ***      0                                  0         push @participants, $long;
637                                                      }
638   ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
639   ***      0                                  0      return @participants;
640                                                   }
641                                                   
642                                                   sub opts {
643   ***      0                    0             0      my ( $self ) = @_;
644   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
645   ***      0                                  0      return %opts;
646                                                   }
647                                                   
648                                                   sub short_opts {
649   ***      0                    0             0      my ( $self ) = @_;
650   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
651   ***      0                                  0      return %short_opts;
652                                                   }
653                                                   
654                                                   sub set_defaults {
655   ***      0                    0             0      my ( $self, %defaults ) = @_;
656   ***      0                                  0      $self->{defaults} = {};
657   ***      0                                  0      foreach my $long ( keys %defaults ) {
658   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
659                                                            unless exists $self->{opts}->{$long};
660   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
661   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
662                                                      }
663   ***      0                                  0      return;
664                                                   }
665                                                   
666                                                   sub get_defaults {
667   ***      0                    0             0      my ( $self ) = @_;
668   ***      0                                  0      return $self->{defaults};
669                                                   }
670                                                   
671                                                   sub get_groups {
672   ***      0                    0             0      my ( $self ) = @_;
673   ***      0                                  0      return $self->{groups};
674                                                   }
675                                                   
676                                                   sub _set_option {
677   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
678   ***      0      0                           0      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***             0                               
679                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
680                                                               : die "Getopt::Long gave a nonexistent option: $opt";
681                                                   
682   ***      0                                  0      $opt = $self->{opts}->{$long};
683   ***      0      0                           0      if ( $opt->{is_cumulative} ) {
684   ***      0                                  0         $opt->{value}++;
685                                                      }
686                                                      else {
687   ***      0                                  0         $opt->{value} = $val;
688                                                      }
689   ***      0                                  0      $opt->{got} = 1;
690   ***      0                                  0      MKDEBUG && _d('Got option', $long, '=', $val);
691                                                   }
692                                                   
693                                                   sub get_opts {
694   ***      0                    0             0      my ( $self ) = @_; 
695                                                   
696   ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
697   ***      0                                  0         $self->{opts}->{$long}->{got} = 0;
698   ***      0      0                           0         $self->{opts}->{$long}->{value}
      ***             0                               
699                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
700                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
701                                                            : undef;
702                                                      }
703   ***      0                                  0      $self->{got_opts} = 0;
704                                                   
705   ***      0                                  0      $self->{errors} = [];
706                                                   
707   ***      0      0      0                    0      if ( @ARGV && $ARGV[0] eq "--config" ) {
708   ***      0                                  0         shift @ARGV;
709   ***      0                                  0         $self->_set_option('config', shift @ARGV);
710                                                      }
711   ***      0      0                           0      if ( $self->has('config') ) {
712   ***      0                                  0         my @extra_args;
713   ***      0                                  0         foreach my $filename ( split(',', $self->get('config')) ) {
714   ***      0                                  0            eval {
715   ***      0                                  0               push @extra_args, $self->_read_config_file($filename);
716                                                            };
717   ***      0      0                           0            if ( $EVAL_ERROR ) {
718   ***      0      0                           0               if ( $self->got('config') ) {
719   ***      0                                  0                  die $EVAL_ERROR;
720                                                               }
721                                                               elsif ( MKDEBUG ) {
722                                                                  _d($EVAL_ERROR);
723                                                               }
724                                                            }
725                                                         }
726   ***      0                                  0         unshift @ARGV, @extra_args;
727                                                      }
728                                                   
729   ***      0                                  0      Getopt::Long::Configure('no_ignore_case', 'bundling');
730                                                      GetOptions(
731   ***      0                    0             0         map    { $_->{spec} => sub { $self->_set_option(@_); } }
      ***      0                                  0   
      ***      0                                  0   
732   ***      0                                  0         grep   { $_->{long} ne 'config' } # --config is handled specially above.
733   ***      0      0                           0         values %{$self->{opts}}
734                                                      ) or $self->save_error('Error parsing options');
735                                                   
736   ***      0      0      0                    0      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
737   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
738                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
739                                                               or die "Cannot print: $OS_ERROR";
740   ***      0                                  0         exit 0;
741                                                      }
742                                                   
743   ***      0      0      0                    0      if ( @ARGV && $self->{strict} ) {
744   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
745                                                      }
746                                                   
747   ***      0                                  0      foreach my $mutex ( @{$self->{mutex}} ) {
      ***      0                                  0   
748   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
749   ***      0      0                           0         if ( @set > 1 ) {
750   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
751   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
752                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
753                                                                    . ' are mutually exclusive.';
754   ***      0                                  0            $self->save_error($err);
755                                                         }
756                                                      }
757                                                   
758   ***      0                                  0      foreach my $required ( @{$self->{atleast1}} ) {
      ***      0                                  0   
759   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
760   ***      0      0                           0         if ( @set == 0 ) {
761   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
762   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
763                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
764   ***      0                                  0            $self->save_error("Specify at least one of $err");
765                                                         }
766                                                      }
767                                                   
768   ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
769   ***      0                                  0         my $opt = $self->{opts}->{$long};
770   ***      0      0                           0         if ( $opt->{got} ) {
      ***             0                               
771   ***      0      0                           0            if ( exists $self->{disables}->{$long} ) {
772   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
773   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
774   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
775                                                                  'because', $long,'disables them');
776                                                            }
777                                                   
778   ***      0      0                           0            if ( exists $self->{allowed_groups}->{$long} ) {
779                                                   
780   ***      0                                  0               my @restricted_groups = grep {
781   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
782   ***      0                                  0               } keys %{$self->{groups}};
783                                                   
784   ***      0                                  0               my @restricted_opts;
785   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
786   ***      0                                  0                  RESTRICTED_OPT:
787   ***      0                                  0                  foreach my $restricted_opt (
788                                                                     keys %{$self->{groups}->{$restricted_group}} )
789                                                                  {
790   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
791   ***      0      0                           0                     push @restricted_opts, $restricted_opt
792                                                                        if $self->{opts}->{$restricted_opt}->{got};
793                                                                  }
794                                                               }
795                                                   
796   ***      0      0                           0               if ( @restricted_opts ) {
797   ***      0                                  0                  my $err;
798   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
799   ***      0                                  0                     $err = "--$restricted_opts[0]";
800                                                                  }
801                                                                  else {
802   ***      0                                  0                     $err = join(', ',
803   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
804   ***      0                                  0                               grep { $_ } 
805                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
806                                                                            )
807                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
808                                                                  }
809   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
810                                                               }
811                                                            }
812                                                   
813                                                         }
814                                                         elsif ( $opt->{is_required} ) { 
815   ***      0                                  0            $self->save_error("Required option --$long must be specified");
816                                                         }
817                                                   
818   ***      0                                  0         $self->_validate_type($opt);
819                                                      }
820                                                   
821   ***      0                                  0      $self->{got_opts} = 1;
822   ***      0                                  0      return;
823                                                   }
824                                                   
825                                                   sub _validate_type {
826   ***      0                    0             0      my ( $self, $opt ) = @_;
827   ***      0      0      0                    0      return unless $opt && $opt->{type};
828   ***      0                                  0      my $val = $opt->{value};
829                                                   
830   ***      0      0      0                    0      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
      ***                    0                        
831   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
832   ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
833   ***      0      0                           0         if ( !$suffix ) {
834   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
835   ***      0             0                    0            $suffix = $s || 's';
836   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
837                                                               $opt->{long}, '(value:', $val, ')');
838                                                         }
839   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
840   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
841                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
842                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
843                                                                 :                  $num * 86400;   # Days
844   ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
845   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
846                                                         }
847                                                         else {
848   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
849                                                         }
850                                                      }
851                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
852   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
853   ***      0                                  0         my $prev = {};
854   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
855   ***      0      0                           0         if ( $from_key ) {
856   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
857   ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
858                                                         }
859   ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
860   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
861                                                      }
862                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
863   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
864   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
865   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
866   ***      0      0                           0         if ( defined $num ) {
867   ***      0      0                           0            if ( $factor ) {
868   ***      0                                  0               $num *= $factor_for{$factor};
869   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
870                                                                  'to num', $num, '* factor', $factor);
871                                                            }
872   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
873                                                         }
874                                                         else {
875   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
876                                                         }
877                                                      }
878                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
879   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
880                                                      }
881                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
882   ***      0             0                    0         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
883                                                      }
884                                                      else {
885   ***      0                                  0         MKDEBUG && _d('Nothing to validate for option',
886                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
887                                                      }
888                                                   
889   ***      0                                  0      return;
890                                                   }
891                                                   
892                                                   sub get {
893   ***      0                    0             0      my ( $self, $opt ) = @_;
894   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
895   ***      0      0      0                    0      die "Option $opt does not exist"
896                                                         unless $long && exists $self->{opts}->{$long};
897   ***      0                                  0      return $self->{opts}->{$long}->{value};
898                                                   }
899                                                   
900                                                   sub got {
901   ***      0                    0             0      my ( $self, $opt ) = @_;
902   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
903   ***      0      0      0                    0      die "Option $opt does not exist"
904                                                         unless $long && exists $self->{opts}->{$long};
905   ***      0                                  0      return $self->{opts}->{$long}->{got};
906                                                   }
907                                                   
908                                                   sub has {
909   ***      0                    0             0      my ( $self, $opt ) = @_;
910   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
911   ***      0      0                           0      return defined $long ? exists $self->{opts}->{$long} : 0;
912                                                   }
913                                                   
914                                                   sub set {
915   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
916   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
917   ***      0      0      0                    0      die "Option $opt does not exist"
918                                                         unless $long && exists $self->{opts}->{$long};
919   ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
920   ***      0                                  0      return;
921                                                   }
922                                                   
923                                                   sub save_error {
924   ***      0                    0             0      my ( $self, $error ) = @_;
925   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
926                                                   }
927                                                   
928                                                   sub errors {
929   ***      0                    0             0      my ( $self ) = @_;
930   ***      0                                  0      return $self->{errors};
931                                                   }
932                                                   
933                                                   sub prompt {
934   ***      0                    0             0      my ( $self ) = @_;
935   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
936                                                   }
937                                                   
938                                                   sub descr {
939   ***      0                    0             0      my ( $self ) = @_;
940   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
941                                                                 . "  For more details, please use the --help option, "
942                                                                 . "or try 'perldoc $PROGRAM_NAME' "
943                                                                 . "for complete documentation.";
944   ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
945   ***      0                                  0      $descr =~ s/ +$//mg;
946   ***      0                                  0      return $descr;
947                                                   }
948                                                   
949                                                   sub usage_or_errors {
950   ***      0                    0             0      my ( $self ) = @_;
951   ***      0      0                           0      if ( $self->{opts}->{help}->{got} ) {
      ***      0      0                           0   
952   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
953   ***      0                                  0         exit 0;
954                                                      }
955                                                      elsif ( scalar @{$self->{errors}} ) {
956   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
957   ***      0                                  0         exit 0;
958                                                      }
959   ***      0                                  0      return;
960                                                   }
961                                                   
962                                                   sub print_errors {
963   ***      0                    0             0      my ( $self ) = @_;
964   ***      0                                  0      my $usage = $self->prompt() . "\n";
965   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
966   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
967                                                                 . "\n";
968                                                      }
969   ***      0                                  0      return $usage . "\n" . $self->descr();
970                                                   }
971                                                   
972                                                   sub print_usage {
973   ***      0                    0             0      my ( $self ) = @_;
974   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
975   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
976                                                   
977   ***      0      0                           0      my $maxl = max(
978   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
979                                                         @opts);
980                                                   
981   ***      0      0                           0      my $maxs = max(0,
982   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
983   ***      0                                  0         values %{$self->{short_opts}});
984                                                   
985   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
986   ***      0                                  0      my $rcol = 80 - $lcol - 6;
987   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
988                                                   
989   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
990                                                   
991   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
992                                                   
993   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
994   ***      0                                  0      push @groups, 'default';
995                                                   
996   ***      0                                  0      foreach my $group ( reverse @groups ) {
997   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
998   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
999   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
1000                                                           grep { $_->{group} eq $group }
1001                                                           @opts )
1002                                                        {
1003  ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
1004  ***      0                                  0            my $short = $opt->{short};
1005  ***      0                                  0            my $desc  = $opt->{desc};
1006  ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
1007  ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
1008  ***      0             0                    0               $s    ||= 's';
1009  ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
1010  ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
1011                                                                     . "d=days; if no suffix, $s is used.";
1012                                                           }
1013  ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
1014  ***      0                                  0            $desc =~ s/ +$//mg;
1015  ***      0      0                           0            if ( $short ) {
1016  ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
1017                                                           }
1018                                                           else {
1019  ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
1020                                                           }
1021                                                        }
1022                                                     }
1023                                                  
1024  ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
1025  ***      0                                  0         $usage .= "\nRules:\n\n";
1026  ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
1027                                                     }
1028  ***      0      0                           0      if ( $self->{dp} ) {
1029  ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
1030                                                     }
1031  ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
1032  ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
1033  ***      0                                  0         my $val   = $opt->{value};
1034  ***      0             0                    0         my $type  = $opt->{type} || '';
1035  ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
1036  ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
1037                                                                  : !defined $val             ? '(No value)'
1038                                                                  : $type eq 'd'              ? $self->{dp}->as_string($val)
1039                                                                  : $type =~ m/H|h/           ? join(',', sort keys %$val)
1040                                                                  : $type =~ m/A|a/           ? join(',', @$val)
1041                                                                  :                             $val;
1042  ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
1043                                                     }
1044  ***      0                                  0      return $usage;
1045                                                  }
1046                                                  
1047                                                  sub prompt_noecho {
1048  ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
1049  ***      0                                  0      my ( $prompt ) = @_;
1050  ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
1051  ***      0      0                           0      print $prompt
1052                                                        or die "Cannot print: $OS_ERROR";
1053  ***      0                                  0      my $response;
1054  ***      0                                  0      eval {
1055  ***      0                                  0         require Term::ReadKey;
1056  ***      0                                  0         Term::ReadKey::ReadMode('noecho');
1057  ***      0                                  0         chomp($response = <STDIN>);
1058  ***      0                                  0         Term::ReadKey::ReadMode('normal');
1059  ***      0      0                           0         print "\n"
1060                                                           or die "Cannot print: $OS_ERROR";
1061                                                     };
1062  ***      0      0                           0      if ( $EVAL_ERROR ) {
1063  ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
1064                                                     }
1065  ***      0                                  0      return $response;
1066                                                  }
1067                                                  
1068                                                  if ( MKDEBUG ) {
1069                                                     print '# ', $^X, ' ', $], "\n";
1070                                                     my $uname = `uname -a`;
1071                                                     if ( $uname ) {
1072                                                        $uname =~ s/\s+/ /g;
1073                                                        print "# $uname\n";
1074                                                     }
1075                                                     printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
1076                                                        $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
1077                                                        ($main::SVN_REV || ''), __LINE__);
1078                                                     print('# Arguments: ',
1079                                                        join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
1080                                                  }
1081                                                  
1082                                                  sub _read_config_file {
1083  ***      0                    0             0      my ( $self, $filename ) = @_;
1084  ***      0      0                           0      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
1085  ***      0                                  0      my @args;
1086  ***      0                                  0      my $prefix = '--';
1087  ***      0                                  0      my $parse  = 1;
1088                                                  
1089                                                     LINE:
1090  ***      0                                  0      while ( my $line = <$fh> ) {
1091  ***      0                                  0         chomp $line;
1092  ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
1093  ***      0                                  0         $line =~ s/\s+#.*$//g;
1094  ***      0                                  0         $line =~ s/^\s+|\s+$//g;
1095  ***      0      0                           0         if ( $line eq '--' ) {
1096  ***      0                                  0            $prefix = '';
1097  ***      0                                  0            $parse  = 0;
1098  ***      0                                  0            next LINE;
1099                                                        }
1100  ***      0      0      0                    0         if ( $parse
      ***             0                               
1101                                                           && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
1102                                                        ) {
1103  ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
1104                                                        }
1105                                                        elsif ( $line =~ m/./ ) {
1106  ***      0                                  0            push @args, $line;
1107                                                        }
1108                                                        else {
1109  ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
1110                                                        }
1111                                                     }
1112  ***      0                                  0      close $fh;
1113  ***      0                                  0      return @args;
1114                                                  }
1115                                                  
1116                                                  sub read_para_after {
1117  ***      0                    0             0      my ( $self, $file, $regex ) = @_;
1118  ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
1119  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
1120  ***      0                                  0      my $para;
1121  ***      0                                  0      while ( $para = <$fh> ) {
1122  ***      0      0                           0         next unless $para =~ m/^=pod$/m;
1123  ***      0                                  0         last;
1124                                                     }
1125  ***      0                                  0      while ( $para = <$fh> ) {
1126  ***      0      0                           0         next unless $para =~ m/$regex/;
1127  ***      0                                  0         last;
1128                                                     }
1129  ***      0                                  0      $para = <$fh>;
1130  ***      0                                  0      chomp($para);
1131  ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
1132  ***      0                                  0      return $para;
1133                                                  }
1134                                                  
1135                                                  sub clone {
1136  ***      0                    0             0      my ( $self ) = @_;
1137                                                  
1138  ***      0                                  0      my %clone = map {
1139  ***      0                                  0         my $hashref  = $self->{$_};
1140  ***      0                                  0         my $val_copy = {};
1141  ***      0                                  0         foreach my $key ( keys %$hashref ) {
1142  ***      0                                  0            my $ref = ref $hashref->{$key};
1143  ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
1144  ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
1145  ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
1146                                                                             : $hashref->{$key};
1147                                                        }
1148  ***      0                                  0         $_ => $val_copy;
1149                                                     } qw(opts short_opts defaults);
1150                                                  
1151  ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
1152  ***      0                                  0         $clone{$scalar} = $self->{$scalar};
1153                                                     }
1154                                                  
1155  ***      0                                  0      return bless \%clone;     
1156                                                  }
1157                                                  
1158                                                  sub _d {
1159  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1160  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1161  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1162                                                          @_;
1163  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1164                                                  }
1165                                                  
1166                                                  1;
1167                                                  
1168                                                  # ###########################################################################
1169                                                  # End OptionParser package
1170                                                  # ###########################################################################
1171                                                  
1172                                                  # ###########################################################################
1173                                                  # TableParser package 4397
1174                                                  # ###########################################################################
1175                                                  package TableParser;
1176                                                  
1177           1                    1            12   use strict;
               1                                  3   
               1                                  8   
1178           1                    1             7   use warnings FATAL => 'all';
               1                                  2   
               1                                  8   
1179           1                    1             7   use English qw(-no_match_vars);
               1                                  3   
               1                                  7   
1180                                                  
1181           1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  9   
1182                                                  
1183                                                  sub new {
1184  ***      0                    0             0      my ( $class ) = @_;
1185  ***      0                                  0      return bless {}, $class;
1186                                                  }
1187                                                  
1188                                                  
1189                                                  sub parse {
1190  ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
1191  ***      0      0                           0      return unless $ddl;
1192  ***      0      0                           0      if ( ref $ddl eq 'ARRAY' ) {
1193  ***      0      0                           0         if ( lc $ddl->[0] eq 'table' ) {
1194  ***      0                                  0            $ddl = $ddl->[1];
1195                                                        }
1196                                                        else {
1197                                                           return {
1198  ***      0                                  0               engine => 'VIEW',
1199                                                           };
1200                                                        }
1201                                                     }
1202                                                  
1203  ***      0      0                           0      if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
1204  ***      0                                  0         die "Cannot parse table definition; is ANSI quoting "
1205                                                           . "enabled or SQL_QUOTE_SHOW_CREATE disabled?";
1206                                                     }
1207                                                  
1208  ***      0                                  0      $ddl =~ s/(`[^`]+`)/\L$1/g;
1209                                                  
1210  ***      0                                  0      my $engine = $self->get_engine($ddl);
1211                                                  
1212  ***      0                                  0      my @defs   = $ddl =~ m/^(\s+`.*?),?$/gm;
1213  ***      0                                  0      my @cols   = map { $_ =~ m/`([^`]+)`/ } @defs;
      ***      0                                  0   
1214  ***      0                                  0      MKDEBUG && _d('Columns:', join(', ', @cols));
1215                                                  
1216  ***      0                                  0      my %def_for;
1217  ***      0                                  0      @def_for{@cols} = @defs;
1218                                                  
1219  ***      0                                  0      my (@nums, @null);
1220  ***      0                                  0      my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
1221  ***      0                                  0      foreach my $col ( @cols ) {
1222  ***      0                                  0         my $def = $def_for{$col};
1223  ***      0                                  0         my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
1224  ***      0      0                           0         die "Can't determine column type for $def" unless $type;
1225  ***      0                                  0         $type_for{$col} = $type;
1226  ***      0      0                           0         if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
1227  ***      0                                  0            push @nums, $col;
1228  ***      0                                  0            $is_numeric{$col} = 1;
1229                                                        }
1230  ***      0      0                           0         if ( $def !~ m/NOT NULL/ ) {
1231  ***      0                                  0            push @null, $col;
1232  ***      0                                  0            $is_nullable{$col} = 1;
1233                                                        }
1234  ***      0      0                           0         $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
1235                                                     }
1236                                                  
1237  ***      0                                  0      my ($keys, $clustered_key) = $self->get_keys($ddl, $opts, \%is_nullable);
1238                                                  
1239                                                     return {
1240  ***      0                                  0         cols           => \@cols,
1241  ***      0                                  0         col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
1242  ***      0                                  0         is_col         => { map { $_ => 1 } @cols },
1243                                                        null_cols      => \@null,
1244                                                        is_nullable    => \%is_nullable,
1245                                                        is_autoinc     => \%is_autoinc,
1246                                                        clustered_key  => $clustered_key,
1247                                                        keys           => $keys,
1248                                                        defs           => \%def_for,
1249                                                        numeric_cols   => \@nums,
1250                                                        is_numeric     => \%is_numeric,
1251                                                        engine         => $engine,
1252                                                        type_for       => \%type_for,
1253                                                     };
1254                                                  }
1255                                                  
1256                                                  sub sort_indexes {
1257  ***      0                    0             0      my ( $self, $tbl ) = @_;
1258                                                  
1259                                                     my @indexes
1260  ***      0                                  0         = sort {
1261  ***      0                                  0            (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
1262                                                           || ( !$tbl->{keys}->{$a}->{is_unique} <=> !$tbl->{keys}->{$b}->{is_unique} )
1263                                                           || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
1264  ***      0      0      0                    0            || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      ***      0             0                    0   
1265                                                        }
1266                                                        grep {
1267  ***      0                                  0            $tbl->{keys}->{$_}->{type} eq 'BTREE'
1268                                                        }
1269  ***      0                                  0         sort keys %{$tbl->{keys}};
1270                                                  
1271  ***      0                                  0      MKDEBUG && _d('Indexes sorted best-first:', join(', ', @indexes));
1272  ***      0                                  0      return @indexes;
1273                                                  }
1274                                                  
1275                                                  sub find_best_index {
1276  ***      0                    0             0      my ( $self, $tbl, $index ) = @_;
1277  ***      0                                  0      my $best;
1278  ***      0      0                           0      if ( $index ) {
1279  ***      0                                  0         ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
      ***      0                                  0   
      ***      0                                  0   
1280                                                     }
1281  ***      0      0                           0      if ( !$best ) {
1282  ***      0      0                           0         if ( $index ) {
1283  ***      0                                  0            die "Index '$index' does not exist in table";
1284                                                        }
1285                                                        else {
1286  ***      0                                  0            ($best) = $self->sort_indexes($tbl);
1287                                                        }
1288                                                     }
1289  ***      0                                  0      MKDEBUG && _d('Best index found is', $best);
1290  ***      0                                  0      return $best;
1291                                                  }
1292                                                  
1293                                                  sub find_possible_keys {
1294  ***      0                    0             0      my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
1295  ***      0      0                           0      return () unless $where;
1296  ***      0                                  0      my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
1297                                                        . ' WHERE ' . $where;
1298  ***      0                                  0      MKDEBUG && _d($sql);
1299  ***      0                                  0      my $expl = $dbh->selectrow_hashref($sql);
1300  ***      0                                  0      $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
      ***      0                                  0   
1301  ***      0      0                           0      if ( $expl->{possible_keys} ) {
1302  ***      0                                  0         MKDEBUG && _d('possible_keys =', $expl->{possible_keys});
1303  ***      0                                  0         my @candidates = split(',', $expl->{possible_keys});
1304  ***      0                                  0         my %possible   = map { $_ => 1 } @candidates;
      ***      0                                  0   
1305  ***      0      0                           0         if ( $expl->{key} ) {
1306  ***      0                                  0            MKDEBUG && _d('MySQL chose', $expl->{key});
1307  ***      0                                  0            unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
      ***      0                                  0   
1308  ***      0                                  0            MKDEBUG && _d('Before deduping:', join(', ', @candidates));
1309  ***      0                                  0            my %seen;
1310  ***      0                                  0            @candidates = grep { !$seen{$_}++ } @candidates;
      ***      0                                  0   
1311                                                        }
1312  ***      0                                  0         MKDEBUG && _d('Final list:', join(', ', @candidates));
1313  ***      0                                  0         return @candidates;
1314                                                     }
1315                                                     else {
1316  ***      0                                  0         MKDEBUG && _d('No keys in possible_keys');
1317  ***      0                                  0         return ();
1318                                                     }
1319                                                  }
1320                                                  
1321                                                  sub table_exists {
1322  ***      0                    0             0      my ( $self, $dbh, $db, $tbl, $q, $can_insert ) = @_;
1323  ***      0                                  0      my $result = 0;
1324  ***      0                                  0      my $db_tbl = $q->quote($db, $tbl);
1325  ***      0                                  0      my $sql    = "SHOW FULL COLUMNS FROM $db_tbl";
1326  ***      0                                  0      MKDEBUG && _d($sql);
1327  ***      0                                  0      eval {
1328  ***      0                                  0         my $sth = $dbh->prepare($sql);
1329  ***      0                                  0         $sth->execute();
1330  ***      0                                  0         my @columns = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
1331  ***      0      0                           0         if ( $can_insert ) {
1332  ***      0             0                    0            $result = grep { ($_->{Privileges} || '') =~ m/insert/ } @columns;
      ***      0                                  0   
1333                                                        }
1334                                                        else {
1335  ***      0                                  0            $result = 1;
1336                                                        }
1337                                                     };
1338  ***      0                                  0      if ( MKDEBUG && $EVAL_ERROR ) {
1339                                                        _d($EVAL_ERROR);
1340                                                     }
1341  ***      0                                  0      return $result;
1342                                                  }
1343                                                  
1344                                                  sub get_engine {
1345  ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
1346  ***      0                                  0      my ( $engine ) = $ddl =~ m/\).*?(?:ENGINE|TYPE)=(\w+)/;
1347  ***      0                                  0      MKDEBUG && _d('Storage engine:', $engine);
1348  ***      0             0                    0      return $engine || undef;
1349                                                  }
1350                                                  
1351                                                  sub get_keys {
1352  ***      0                    0             0      my ( $self, $ddl, $opts, $is_nullable ) = @_;
1353  ***      0                                  0      my $engine        = $self->get_engine($ddl);
1354  ***      0                                  0      my $keys          = {};
1355  ***      0                                  0      my $clustered_key = undef;
1356                                                  
1357                                                     KEY:
1358  ***      0                                  0      foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {
1359                                                  
1360  ***      0      0                           0         next KEY if $key =~ m/FOREIGN/;
1361                                                  
1362  ***      0                                  0         MKDEBUG && _d('Parsed key:', $key);
1363                                                  
1364  ***      0      0                           0         if ( $engine !~ m/MEMORY|HEAP/ ) {
1365  ***      0                                  0            $key =~ s/USING HASH/USING BTREE/;
1366                                                        }
1367                                                  
1368  ***      0                                  0         my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
1369  ***      0                                  0         my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
1370  ***      0             0                    0         $type = $type || $special || 'BTREE';
      ***                    0                        
1371  ***      0      0      0                    0         if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
      ***                    0                        
1372                                                           && $engine =~ m/HEAP|MEMORY/i )
1373                                                        {
1374  ***      0                                  0            $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
1375                                                        }
1376                                                  
1377  ***      0                                  0         my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
1378  ***      0      0                           0         my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
1379  ***      0                                  0         my @cols;
1380  ***      0                                  0         my @col_prefixes;
1381  ***      0                                  0         foreach my $col_def ( split(',', $cols) ) {
1382  ***      0                                  0            my ($name, $prefix) = $col_def =~ m/`([^`]+)`(?:\((\d+)\))?/;
1383  ***      0                                  0            push @cols, $name;
1384  ***      0                                  0            push @col_prefixes, $prefix;
1385                                                        }
1386  ***      0                                  0         $name =~ s/`//g;
1387                                                  
1388  ***      0                                  0         MKDEBUG && _d('Key', $name, 'cols:', join(', ', @cols));
1389                                                  
1390  ***      0                                  0         $keys->{$name} = {
1391                                                           name         => $name,
1392                                                           type         => $type,
1393                                                           colnames     => $cols,
1394                                                           cols         => \@cols,
1395                                                           col_prefixes => \@col_prefixes,
1396                                                           is_unique    => $unique,
1397  ***      0                                  0            is_nullable  => scalar(grep { $is_nullable->{$_} } @cols),
1398  ***      0                                  0            is_col       => { map { $_ => 1 } @cols },
1399                                                        };
1400                                                  
1401  ***      0      0      0                    0         if ( $engine =~ m/InnoDB/i && !$clustered_key ) {
1402  ***      0                                  0            my $this_key = $keys->{$name};
1403  ***      0      0      0                    0            if ( $this_key->{name} eq 'PRIMARY' ) {
      ***             0                               
1404  ***      0                                  0               $clustered_key = 'PRIMARY';
1405                                                           }
1406                                                           elsif ( $this_key->{is_unique} && !$this_key->{is_nullable} ) {
1407  ***      0                                  0               $clustered_key = $this_key->{name};
1408                                                           }
1409  ***      0                                  0            MKDEBUG && $clustered_key && _d('This key is the clustered key');
1410                                                        }
1411                                                     }
1412                                                  
1413  ***      0                                  0      return $keys, $clustered_key;
1414                                                  }
1415                                                  
1416                                                  sub get_fks {
1417  ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
1418  ***      0                                  0      my $fks = {};
1419                                                  
1420  ***      0                                  0      foreach my $fk (
1421                                                        $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg )
1422                                                     {
1423  ***      0                                  0         my ( $name ) = $fk =~ m/CONSTRAINT `(.*?)`/;
1424  ***      0                                  0         my ( $cols ) = $fk =~ m/FOREIGN KEY \(([^\)]+)\)/;
1425  ***      0                                  0         my ( $parent, $parent_cols ) = $fk =~ m/REFERENCES (\S+) \(([^\)]+)\)/;
1426                                                  
1427  ***      0      0      0                    0         if ( $parent !~ m/\./ && $opts->{database} ) {
1428  ***      0                                  0            $parent = "`$opts->{database}`.$parent";
1429                                                        }
1430                                                  
1431  ***      0                                  0         $fks->{$name} = {
1432                                                           name           => $name,
1433                                                           colnames       => $cols,
1434  ***      0                                  0            cols           => [ map { s/[ `]+//g; $_; } split(',', $cols) ],
      ***      0                                  0   
1435                                                           parent_tbl     => $parent,
1436                                                           parent_colnames=> $parent_cols,
1437  ***      0                                  0            parent_cols    => [ map { s/[ `]+//g; $_; } split(',', $parent_cols) ],
      ***      0                                  0   
1438                                                        };
1439                                                     }
1440                                                  
1441  ***      0                                  0      return $fks;
1442                                                  }
1443                                                  
1444                                                  sub remove_auto_increment {
1445  ***      0                    0             0      my ( $self, $ddl ) = @_;
1446  ***      0                                  0      $ddl =~ s/(^\).*?) AUTO_INCREMENT=\d+\b/$1/m;
1447  ***      0                                  0      return $ddl;
1448                                                  }
1449                                                  
1450                                                  sub _d {
1451  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1452  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1453  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1454                                                          @_;
1455  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1456                                                  }
1457                                                  
1458                                                  1;
1459                                                  
1460                                                  # ###########################################################################
1461                                                  # End TableParser package
1462                                                  # ###########################################################################
1463                                                  
1464                                                  # ###########################################################################
1465                                                  # DSNParser package 5208
1466                                                  # ###########################################################################
1467           1                    1             8   use strict;
               1                                  4   
               1                                  5   
1468           1                    1             7   use warnings FATAL => 'all';
               1                                  7   
               1                                  6   
1469                                                  
1470                                                  package DSNParser;
1471                                                  
1472                                                  eval {
1473                                                     require DBI;
1474                                                  };
1475           1                    1             7   use Data::Dumper;
               1                                  2   
               1                                 10   
1476                                                  $Data::Dumper::Indent    = 0;
1477                                                  $Data::Dumper::Quotekeys = 0;
1478           1                    1             7   use English qw(-no_match_vars);
               1                                  3   
               1                                  6   
1479                                                  
1480           1                    1             8   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                257   
               1                                 11   
1481                                                  
1482                                                  sub new {
1483           1                    1             5      my ( $class, @opts ) = @_;
1484           1                                 26      my $self = {
1485                                                        opts => {
1486                                                           A => {
1487                                                              desc => 'Default character set',
1488                                                              dsn  => 'charset',
1489                                                              copy => 1,
1490                                                           },
1491                                                           D => {
1492                                                              desc => 'Database to use',
1493                                                              dsn  => 'database',
1494                                                              copy => 1,
1495                                                           },
1496                                                           F => {
1497                                                              desc => 'Only read default options from the given file',
1498                                                              dsn  => 'mysql_read_default_file',
1499                                                              copy => 1,
1500                                                           },
1501                                                           h => {
1502                                                              desc => 'Connect to host',
1503                                                              dsn  => 'host',
1504                                                              copy => 1,
1505                                                           },
1506                                                           p => {
1507                                                              desc => 'Password to use when connecting',
1508                                                              dsn  => 'password',
1509                                                              copy => 1,
1510                                                           },
1511                                                           P => {
1512                                                              desc => 'Port number to use for connection',
1513                                                              dsn  => 'port',
1514                                                              copy => 1,
1515                                                           },
1516                                                           S => {
1517                                                              desc => 'Socket file to use for connection',
1518                                                              dsn  => 'mysql_socket',
1519                                                              copy => 1,
1520                                                           },
1521                                                           u => {
1522                                                              desc => 'User for login if not current user',
1523                                                              dsn  => 'user',
1524                                                              copy => 1,
1525                                                           },
1526                                                        },
1527                                                     };
1528           1                                  5      foreach my $opt ( @opts ) {
1529  ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
1530  ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
1531                                                     }
1532           1                                 12      return bless $self, $class;
1533                                                  }
1534                                                  
1535                                                  sub prop {
1536           3                    3            14      my ( $self, $prop, $value ) = @_;
1537  ***      3     50                          14      if ( @_ > 2 ) {
1538  ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
1539  ***      0                                  0         $self->{$prop} = $value;
1540                                                     }
1541           3                                 23      return $self->{$prop};
1542                                                  }
1543                                                  
1544                                                  sub parse {
1545           1                    1            42      my ( $self, $dsn, $prev, $defaults ) = @_;
1546  ***      1     50                           5      if ( !$dsn ) {
1547  ***      0                                  0         MKDEBUG && _d('No DSN to parse');
1548  ***      0                                  0         return;
1549                                                     }
1550           1                                  2      MKDEBUG && _d('Parsing', $dsn);
1551  ***      1            50                    5      $prev     ||= {};
1552  ***      1            50                    4      $defaults ||= {};
1553           1                                  2      my %given_props;
1554           1                                  3      my %final_props;
1555           1                                  2      my %opts = %{$self->{opts}};
               1                                  9   
1556                                                  
1557           1                                  9      foreach my $dsn_part ( split(/,/, $dsn) ) {
1558  ***      4     50                          36         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1559           4                                 17            $given_props{$prop_key} = $prop_val;
1560                                                        }
1561                                                        else {
1562  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1563  ***      0                                  0            $given_props{h} = $dsn_part;
1564                                                        }
1565                                                     }
1566                                                  
1567           1                                  5      foreach my $key ( keys %opts ) {
1568           8                                 18         MKDEBUG && _d('Finding value for', $key);
1569           8                                 27         $final_props{$key} = $given_props{$key};
1570  ***      8     50     66                   84         if (   !defined $final_props{$key}
      ***                   33                        
1571                                                             && defined $prev->{$key} && $opts{$key}->{copy} )
1572                                                        {
1573  ***      0                                  0            $final_props{$key} = $prev->{$key};
1574  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1575                                                        }
1576           8    100                          47         if ( !defined $final_props{$key} ) {
1577           4                                 14            $final_props{$key} = $defaults->{$key};
1578           4                                 11            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1579                                                        }
1580                                                     }
1581                                                  
1582           1                                  6      foreach my $key ( keys %given_props ) {
1583  ***      4     50                          17         die "Unrecognized DSN part '$key' in '$dsn'\n"
1584                                                           unless exists $opts{$key};
1585                                                     }
1586  ***      1     50                           6      if ( (my $required = $self->prop('required')) ) {
1587  ***      0                                  0         foreach my $key ( keys %$required ) {
1588  ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1589                                                        }
1590                                                     }
1591                                                  
1592           1                                  7      return \%final_props;
1593                                                  }
1594                                                  
1595                                                  sub parse_options {
1596  ***      0                    0             0      my ( $self, $o ) = @_;
1597  ***      0      0                           0      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1598  ***      0                                  0      my $dsn_string
1599                                                        = join(',',
1600  ***      0      0                           0             map  { "$_=".$o->get($_); }
1601  ***      0                                  0             grep { $o->has($_) && $o->get($_) }
1602  ***      0                                  0             keys %{$self->{opts}}
1603                                                          );
1604  ***      0                                  0      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1605  ***      0                                  0      return $self->parse($dsn_string);
1606                                                  }
1607                                                  
1608                                                  sub as_string {
1609  ***      0                    0             0      my ( $self, $dsn ) = @_;
1610  ***      0      0                           0      return $dsn unless ref $dsn;
1611  ***      0      0                           0      return join(',',
1612  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1613  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1614                                                        sort keys %$dsn );
1615                                                  }
1616                                                  
1617                                                  sub usage {
1618  ***      0                    0             0      my ( $self ) = @_;
1619  ***      0                                  0      my $usage
1620                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1621                                                        . "  KEY  COPY  MEANING\n"
1622                                                        . "  ===  ====  =============================================\n";
1623  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1624  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1625  ***      0      0      0                    0         $usage .= "  $key    "
1626                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1627                                                               .  ($opts{$key}->{desc} || '[No description]')
1628                                                               . "\n";
1629                                                     }
1630  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1631  ***      0                                  0      return $usage;
1632                                                  }
1633                                                  
1634                                                  sub get_cxn_params {
1635           1                    1            12      my ( $self, $info ) = @_;
1636           1                                  3      my $dsn;
1637           1                                  3      my %opts = %{$self->{opts}};
               1                                  7   
1638  ***      1            50                    5      my $driver = $self->prop('dbidriver') || '';
1639  ***      1     50                           5      if ( $driver eq 'Pg' ) {
1640  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1641  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1642  ***      0             0                    0                        grep { defined $info->{$_} }
1643                                                                       qw(h P));
1644                                                     }
1645                                                     else {
1646           2                                 15         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1647           5                                 18            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1648  ***      1            50                   12                        grep { defined $info->{$_} }
1649                                                                       qw(F h P S A))
1650                                                           . ';mysql_read_default_group=client';
1651                                                     }
1652           1                                  3      MKDEBUG && _d($dsn);
1653           1                                  8      return ($dsn, $info->{u}, $info->{p});
1654                                                  }
1655                                                  
1656                                                  sub fill_in_dsn {
1657  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1658  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1659  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1660  ***      0                                  0      $user =~ s/@.*//;
1661  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1662  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1663  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1664  ***      0             0                    0      $dsn->{u} ||= $user;
1665  ***      0             0                    0      $dsn->{D} ||= $db;
1666                                                  }
1667                                                  
1668                                                  sub get_dbh {
1669           1                    1             6      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1670  ***      1            50                    6      $opts ||= {};
1671  ***      1     50                          10      my $defaults = {
1672                                                        AutoCommit         => 0,
1673                                                        RaiseError         => 1,
1674                                                        PrintError         => 0,
1675                                                        ShowErrorStatement => 1,
1676                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1677                                                     };
1678           1                                  6      @{$defaults}{ keys %$opts } = values %$opts;
               1                                  4   
1679                                                  
1680           1                                  3      eval {
1681           1                                  6         DBI->installed_drivers();
1682                                                     };
1683  ***      1     50                           4      if ( $EVAL_ERROR ) {
1684  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1685                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1686                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1687                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1688                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1689                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1690                                                  
1691                                                     }
1692                                                  
1693           1                                  3      my $dbh;
1694           1                                  3      my $tries = 2;
1695  ***      1            66                   10      while ( !$dbh && $tries-- ) {
1696                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1697           1                                  3            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1698                                                  
1699           1                                  2         eval {
1700           1                                  6            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1701                                                  
1702  ***      1     50                          11            if ( $cxn_string =~ m/mysql/i ) {
1703           1                                  3               my $sql;
1704                                                  
1705           1                                  4               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1706                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1707           1                                  2               MKDEBUG && _d($dbh, ':', $sql);
1708           1                                134               $dbh->do($sql);
1709                                                  
1710  ***      1     50                           8               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1711  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1712  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1713  ***      0                                  0                  $dbh->do($sql);
1714  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1715  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1716  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1717                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1718                                                                 }
1719                                                                 else {
1720  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1721                                                                 }
1722                                                              }
1723                                                  
1724  ***      1     50                           8               if ( $self->prop('set-vars') ) {
1725  ***      0                                  0                  $sql = "SET " . $self->prop('set-vars');
1726  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1727  ***      0                                  0                  $dbh->do($sql);
1728                                                              }
1729                                                           }
1730                                                        };
1731  ***      1     50     33                   18         if ( !$dbh && $EVAL_ERROR ) {
1732  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1733  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1734  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1735  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1736                                                           }
1737                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1738  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1739                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1740                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1741                                                                 . "DBD::mysql is not installed, try:\n"
1742                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1743                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1744                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1745                                                           }
1746  ***      0      0                           0            if ( !$tries ) {
1747  ***      0                                  0               die $EVAL_ERROR;
1748                                                           }
1749                                                        }
1750                                                     }
1751                                                  
1752           1                                  2      MKDEBUG && _d('DBH info: ',
1753                                                        $dbh,
1754                                                        Dumper($dbh->selectrow_hashref(
1755                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1756                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1757                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1758                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1759                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1760                                                        '$DBI::VERSION:',        $DBI::VERSION,
1761                                                     );
1762                                                  
1763           1                                  8      return $dbh;
1764                                                  }
1765                                                  
1766                                                  sub get_hostname {
1767  ***      0                    0                    my ( $self, $dbh ) = @_;
1768  ***      0      0      0                           if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1769  ***      0                                            return $host;
1770                                                     }
1771  ***      0                                         my ( $hostname, $one ) = $dbh->selectrow_array(
1772                                                        'SELECT /*!50038 @@hostname, */ 1');
1773  ***      0                                         return $hostname;
1774                                                  }
1775                                                  
1776                                                  sub disconnect {
1777  ***      0                    0                    my ( $self, $dbh ) = @_;
1778  ***      0                                         MKDEBUG && $self->print_active_handles($dbh);
1779  ***      0                                         $dbh->disconnect;
1780                                                  }
1781                                                  
1782                                                  sub print_active_handles {
1783  ***      0                    0                    my ( $self, $thing, $level ) = @_;
1784  ***      0             0                           $level ||= 0;
1785  ***      0      0      0                           printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1786                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1787                                                        or die "Cannot print: $OS_ERROR";
1788  ***      0                                         foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                      
      ***      0                                      
1789  ***      0                                            $self->print_active_handles( $handle, $level + 1 );
1790                                                     }
1791                                                  }
1792                                                  
1793                                                  sub copy {
1794  ***      0                    0                    my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1795  ***      0      0                                  die 'I need a dsn_1 argument' unless $dsn_1;
1796  ***      0      0                                  die 'I need a dsn_2 argument' unless $dsn_2;
1797  ***      0                                         my %new_dsn = map {
1798  ***      0                                            my $key = $_;
1799  ***      0                                            my $val;
1800  ***      0      0                                     if ( $args{overwrite} ) {
1801  ***      0      0                                        $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1802                                                        }
1803                                                        else {
1804  ***      0      0                                        $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1805                                                        }
1806  ***      0                                            $key => $val;
1807  ***      0                                         } keys %{$self->{opts}};
1808  ***      0                                         return \%new_dsn;
1809                                                  }
1810                                                  
1811                                                  sub _d {
1812  ***      0                    0                    my ($package, undef, $line) = caller 0;
1813  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1814  ***      0                                              map { defined $_ ? $_ : 'undef' }
1815                                                          @_;
1816  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1817                                                  }
1818                                                  
1819                                                  1;
1820                                                  
1821                                                  # ###########################################################################
1822                                                  # End DSNParser package
1823                                                  # ###########################################################################
1824                                                  
1825                                                  # ###########################################################################
1826                                                  # VersionParser package 3186
1827                                                  # ###########################################################################
1828                                                  package VersionParser;
1829                                                  
1830           1                    1             8   use strict;
               1                                  8   
               1                                  7   
1831           1                    1             7   use warnings FATAL => 'all';
               1                                  9   
               1                                  5   
1832                                                  
1833           1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  5   
1834                                                  
1835           1                    1             9   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  8   
1836                                                  
1837                                                  sub new {
1838  ***      0                    0                    my ( $class ) = @_;
1839  ***      0                                         bless {}, $class;
1840                                                  }
1841                                                  
1842                                                  sub parse {
1843  ***      0                    0                    my ( $self, $str ) = @_;
1844  ***      0                                         my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
1845  ***      0                                         MKDEBUG && _d($str, 'parses to', $result);
1846  ***      0                                         return $result;
1847                                                  }
1848                                                  
1849                                                  sub version_ge {
1850  ***      0                    0                    my ( $self, $dbh, $target ) = @_;
1851  ***      0      0                                  if ( !$self->{$dbh} ) {
1852  ***      0                                            $self->{$dbh} = $self->parse(
1853                                                           $dbh->selectrow_array('SELECT VERSION()'));
1854                                                     }
1855  ***      0      0                                  my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
1856  ***      0                                         MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
1857  ***      0                                         return $result;
1858                                                  }
1859                                                  
1860                                                  sub _d {
1861  ***      0                    0                    my ($package, undef, $line) = caller 0;
1862  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1863  ***      0                                              map { defined $_ ? $_ : 'undef' }
1864                                                          @_;
1865  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1866                                                  }
1867                                                  
1868                                                  1;
1869                                                  
1870                                                  # ###########################################################################
1871                                                  # End VersionParser package
1872                                                  # ###########################################################################
1873                                                  
1874                                                  # ###########################################################################
1875                                                  # Quoter package 3186
1876                                                  # ###########################################################################
1877           1                    1             9   use strict;
               1                                  2   
               1                                  6   
1878           1                    1             7   use warnings FATAL => 'all';
               1                                  2   
               1                                  5   
1879                                                  
1880                                                  package Quoter;
1881                                                  
1882           1                    1             7   use English qw(-no_match_vars);
               1                                  2   
               1                                  6   
1883                                                  
1884           1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  7   
1885                                                  
1886                                                  sub new {
1887  ***      0                    0                    my ( $class ) = @_;
1888  ***      0                                         bless {}, $class;
1889                                                  }
1890                                                  
1891                                                  sub quote {
1892  ***      0                    0                    my ( $self, @vals ) = @_;
1893  ***      0                                         foreach my $val ( @vals ) {
1894  ***      0                                            $val =~ s/`/``/g;
1895                                                     }
1896  ***      0                                         return join('.', map { '`' . $_ . '`' } @vals);
      ***      0                                      
1897                                                  }
1898                                                  
1899                                                  sub quote_val {
1900  ***      0                    0                    my ( $self, @vals ) = @_;
1901                                                     return join(', ',
1902                                                        map {
1903  ***      0      0                                        if ( defined $_ ) {
      ***      0                                      
1904  ***      0                                                  $_ =~ s/(['\\])/\\$1/g;
1905  ***      0      0      0                                    $_ eq '' || $_ =~ m/^0|\D/ ? "'$_'" : $_;
1906                                                           }
1907                                                           else {
1908  ***      0                                                  'NULL';
1909                                                           }
1910                                                        } @vals
1911                                                     );
1912                                                  }
1913                                                  
1914                                                  sub split_unquote {
1915  ***      0                    0                    my ( $self, $db_tbl, $default_db ) = @_;
1916  ***      0                                         $db_tbl =~ s/`//g;
1917  ***      0                                         my ( $db, $tbl ) = split(/[.]/, $db_tbl);
1918  ***      0      0                                  if ( !$tbl ) {
1919  ***      0                                            $tbl = $db;
1920  ***      0                                            $db  = $default_db;
1921                                                     }
1922  ***      0                                         return ($db, $tbl);
1923                                                  }
1924                                                  
1925                                                  1;
1926                                                  
1927                                                  # ###########################################################################
1928                                                  # End Quoter package
1929                                                  # ###########################################################################
1930                                                  
1931                                                  # ###########################################################################
1932                                                  # ServerSpecs package 4628
1933                                                  # ###########################################################################
1934                                                  
1935                                                  package ServerSpecs;
1936                                                  
1937           1                    1             7   use strict;
               1                                  3   
               1                                  5   
1938           1                    1            11   use warnings FATAL => 'all';
               1                                  2   
               1                                  6   
1939                                                  
1940           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  5   
1941                                                  
1942           1                    1             8   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  7   
1943                                                  
1944                                                  sub server_specs {
1945  ***      0                    0                    my %server;
1946                                                  
1947  ***      0                                         @{ $server{problems} } = ();
      ***      0                                      
1948                                                  
1949  ***      0                                         $server{os}->{name} = $OSNAME;
1950  ***      0      0                                  $server{os}->{regsize} = `file /bin/ls` =~ m/64-bit/ ? '64' : '32';
1951                                                  
1952  ***      0                                         $server{os}->{version} = _os_version();
1953                                                  
1954  ***      0      0                                  if ( -f '/lib/libc.so.6' ) {
1955  ***      0                                            my $stuff = `/lib/libc.so.6`;
1956  ***      0                                            ($server{sw}->{libc}->{ver}) = $stuff =~ m/GNU C.*release version (.+), /;
1957  ***      0      0                                     $server{sw}->{libc}->{threading}
      ***             0                               
1958                                                           = $stuff =~ m/Native POSIX/    ? 'NPTL'
1959                                                           : $stuff =~ m/linuxthreads-\d/ ? 'Linuxthreads'
1960                                                           :                                'Unknown';
1961  ***      0                                            ($server{sw}->{libc}->{compiled_by}) = $stuff =~ m/Compiled by (.*)/;
1962  ***      0                                            $server{sw}->{libc}->{GNU_LIBPTHREAD_VERSION} = do {
1963  ***      0                                               my $ver = `getconf GNU_LIBPTHREAD_VERSION`;
1964  ***      0                                               chomp $ver;
1965  ***      0                                               $ver;
1966                                                        };
1967                                                     }
1968                                                     else {
1969  ***      0                                            $server{sw}->{libc}->{ver}         = 'Unknown';
1970  ***      0                                            $server{sw}->{libc}->{threading}   = 'Unknown';
1971  ***      0                                            $server{sw}->{libc}->{compiled_by} = 'Unknown';
1972  ***      0                                            $server{sw}->{libc}->{GNU_LIBPTHREAD_VERSION} = 'Unknown';
1973                                                     }
1974                                                  
1975  ***      0      0                                  if ( -f '/proc/cpuinfo' ) {
1976  ***      0                                            my $info = `cat /proc/cpuinfo`;
1977  ***      0                                            my $cores = scalar( map { $_ } $info =~ m/(^processor)/gm );
      ***      0                                      
1978  ***      0                                            $server{cpu}->{cores} = $cores;
1979  ***      0                                            $server{cpu}->{count}
1980                                                           = `grep 'physical id' /proc/cpuinfo | sort | uniq | wc -l`;
1981  ***      0                                            ($server{cpu}->{speed})
1982                                                           = join(' ', 'MHz:', $info =~ m/cpu MHz.*: (\d+)/g);
1983  ***      0                                            ($server{cpu}->{cache}) = $info =~ m/cache size.*: (.+)/;
1984  ***      0                                            ($server{cpu}->{model}) = $info =~ m/model name.*: (.+)/;
1985  ***      0      0                                     $server{cpu}->{regsize} = $info =~ m/flags.*\blm\b/ ? '64' : '32';
1986                                                     }
1987                                                     else {
1988  ***      0                                            $server{cpu}->{count} = $ENV{NUMBER_OF_PROCESSORS};
1989                                                     }
1990                                                  
1991  ***      0                                         @{$server{memory}->{slots}} = _memory_slots();
      ***      0                                      
1992                                                  
1993  ***      0      0                                  if ( chomp(my $mem = `free -b`) ) {
1994  ***      0                                            my @words = $mem =~ m/(\w+)/g;
1995  ***      0                                            my @keys;
1996  ***      0                                            while ( my $key = shift @words ) {
1997  ***      0      0                                        last if $key eq 'Mem';
1998  ***      0                                               push @keys, $key;
1999                                                        }
2000  ***      0                                            foreach my $key ( @keys ) {
2001  ***      0                                               $server{memory}->{$key} = shorten(shift @words);
2002                                                        }
2003                                                     }
2004                                                  
2005  ***      0      0                                  if ( chomp(my $df = `df -hT` ) ) {
2006  ***      0                                            $df = "\n\t" . join("\n\t",
2007  ***      0                                               grep { $_ !~ m/^(varrun|varlock|udev|devshm|lrm)/ }
2008                                                           split(/\n/, $df));
2009  ***      0                                            $server{storage}->{df} = $df;
2010                                                     }
2011                                                  
2012  ***      0                                         chomp(my $vgs_cmd = `which vgs`);
2013  ***      0      0                                  if ( -f $vgs_cmd ) {
2014  ***      0                                            chomp(my $vgs_output = `$vgs_cmd`);
2015  ***      0                                            $vgs_output =~ s/^\s*/\t/g;
2016  ***      0                                            $server{storage}->{vgs} = $vgs_output;
2017                                                     }
2018                                                     else {
2019  ***      0                                            $server{storage}->{vgs} = 'No LVM2';
2020                                                     }
2021                                                  
2022  ***      0                                         get_raid_info(\%server);
2023                                                  
2024  ***      0                                         chomp($server{os}->{swappiness} = `cat /proc/sys/vm/swappiness`);
2025  ***      0      0                                  push @{ $server{problems} },
      ***      0                                      
2026                                                        "*** Server swappiness != 60; is currently: $server{os}->{swappiness}"
2027                                                        if $server{os}->{swappiness} != 60;
2028                                                  
2029  ***      0                                         check_proc_sys_net_ipv4_values(\%server);
2030                                                  
2031  ***      0                                         return \%server;
2032                                                  }
2033                                                  
2034                                                  sub get_raid_info
2035                                                  {
2036  ***      0                    0                    my ( $server ) = @_;
2037                                                  
2038  ***      0                                         $server->{storage}->{raid} = {};
2039  ***      0      0                                  if ( chomp(my $dmesg = `dmesg | grep '^scsi[0-9]'`) ) {
2040  ***      0      0                                     if (my ($raid) = $dmesg =~ m/: (.*MegaRaid)/mi) {
2041  ***      0                                               $server->{storage}->{raid}{$raid} = _get_raid_info_megarc();
2042                                                        }
2043  ***      0      0                                     if (my ($raid) = $dmesg =~ m/: (aacraid)/m) {
2044  ***      0                                               $server->{storage}->{raid}{$raid} = _get_raid_info_arcconf();
2045                                                        }
2046  ***      0      0                                     if (my ($raid) = $dmesg =~ m/: (3ware [0-9]+ Storage Controller)/m) {
2047  ***      0                                               $server->{storage}->{raid}{$raid} = _get_raid_info_tw_cli();
2048                                                        }
2049                                                     }
2050                                                  }
2051                                                  
2052                                                  sub _get_raid_info_megarc
2053                                                  {
2054  ***      0                    0                    my $result = '';
2055  ***      0                                         my $megarc = `which megarc && megarc -AllAdpInfo -aALL`;
2056  ***      0      0                                  if ( $megarc ) {
2057  ***      0      0                                     if ( $megarc =~ /No MegaRAID Found/i ) {
2058  ***      0      0                                        if ( -f '/opt/MegaRAID/MegaCli/MegaCli' ) {
      ***             0                               
2059  ***      0                                                  $megarc  = `/opt/MegaRAID/MegaCli/MegaCli -AdpAllInfo -aALL`;
2060  ***      0                                                  $megarc .= `/opt/MegaRAID/MegaCli/MegaCli -AdpBbuCmd -GetBbuStatus -aALL`;
2061                                                           }
2062                                                           elsif ( -f '/opt/MegaRAID/MegaCli/MegaCli64' ) {
2063  ***      0                                                  $megarc  = `/opt/MegaRAID/MegaCli/MegaCli64 -AdpAllInfo -aALL`;
2064  ***      0                                                  $megarc .= `/opt/MegaRAID/MegaCli/MegaCli64 -AdpBbuCmd -GetBbuStatus -aALL`;
2065                                                           }
2066                                                           else {
2067  ***      0                                                  $megarc = '';
2068                                                           }
2069                                                        }
2070                                                        else {
2071  ***      0                                               $megarc .= `megarc -AdpBbuCmd -GetBbuStatus -aALL`;
2072                                                        }
2073                                                     }
2074                                                  
2075  ***      0      0                                  if ( $megarc ) {
2076  ***      0      0                                     $result .= ($megarc =~ /^(Product Name.*\n)/m ? $1 : '');
2077  ***      0      0                                     $result .= ($megarc =~ /^(BBU.*\n)/m ? $1 : '');
2078  ***      0      0                                     $result .= ($megarc =~ /^(Battery Warning.*\n)/m ? $1 : '');
2079  ***      0      0                                     $result .= ($megarc =~ /^(Alarm.*\n)/m ? $1 : '');
2080  ***      0      0                                     $result .= ($megarc =~ /(Device Present.*?\n)\s+Supported/ms ? $1 : '');
2081  ***      0      0                                     $result .= ($megarc =~ /(Battery state.*?\n)isSOHGood/ms ? $1 : '');
2082  ***      0                                            $result =~ s/^/   /mg;
2083                                                     }
2084                                                     else {
2085  ***      0                                            $result .= "\n*** MegaRAID present but unable to check its status";
2086                                                     }
2087                                                  
2088  ***      0                                         return $result;
2089                                                  }
2090                                                  
2091                                                  sub _get_raid_info_arcconf
2092                                                  {
2093  ***      0                    0                    my $result = '';
2094  ***      0                                         my $arcconf;
2095  ***      0      0                                  if (-x '/usr/StorMan/arcconf') {
2096  ***      0                                            $arcconf = `/usr/StorMan/arcconf GETCONFIG 1`;
2097                                                     }
2098                                                     else {
2099  ***      0                                            $arcconf = `which arcconf && arcconf GETCONFIG 1`;
2100                                                     }
2101  ***      0      0                                  if ( $arcconf ) {
2102  ***      0      0                                     $result .= ($arcconf =~ /^(\s*Controller Model.*\n)/m ? $1 : '');
2103  ***      0      0                                     $result .= ($arcconf =~ /^(\s*Controller Status.*\n)/m ? $1 : '');
2104  ***      0      0                                     $result .= ($arcconf =~ /^(\s*Installed memory.*\n)/m ? $1 : '');
2105  ***      0      0                                     $result .= ($arcconf =~ /^(\s*Temperature.*\n)/m ? $1 : '');
2106  ***      0      0                                     $result .= ($arcconf =~ /^(\s*Defunct disk drive count.*\n)/m ? $1 : '');
2107  ***      0      0                                     $result .= ($arcconf =~ /^(\s*Logical devices\/Failed \(error\)\/Degraded.*\n)/m ? $1 : '');
2108  ***      0      0                                     $result .= ($arcconf =~ /^(\s*Write-cache mode.*\n)/m ? $1 : '');
2109  ***      0      0                                     $result .= ($arcconf =~ /^(\s*Write-cache setting.*\n)/m ? $1 : '');
2110  ***      0      0                                     $result .= ($arcconf =~ /^(\s*Controller Battery Information.*?\n\n)/ms ? $1 : '');
2111                                                     }
2112                                                     else {
2113  ***      0                                            $result .= "\n*** aacraid present but unable to check its status";
2114                                                     }
2115                                                  
2116  ***      0                                         return $result;
2117                                                  }
2118                                                  
2119                                                  sub _get_raid_info_tw_cli
2120                                                  {
2121  ***      0                    0                    my $result = '';
2122  ***      0                                         my $tw_cli = `which tw_cli && tw_cli /c0 show all`;
2123  ***      0      0                                  if ( $tw_cli ) {
2124  ***      0      0                                     $result .= ($tw_cli =~ /^\/c0\s*(Model.*\n)/m ? $1 : '');
2125  ***      0      0                                     $result .= ($tw_cli =~ /^\/c0\s*(Memory Installed.*\n)/m ? $1 : '');
2126  ***      0      0                                     $result .= ($tw_cli =~ /\n(\n.*)/ms ? $1 : '');
2127  ***      0                                            $result =~ s/^/   /mg;
2128                                                     }
2129                                                     else {
2130  ***      0                                            $result .= "\n*** 3ware Storage Controller present but unable to check its status";
2131                                                     }
2132                                                  
2133  ***      0                                         return $result;
2134                                                  }
2135                                                  
2136                                                  sub check_proc_sys_net_ipv4_values
2137                                                  {
2138  ***      0                    0                    my ( $server, $sysctl_conf ) = @_;
2139                                                  
2140  ***      0                                         my %ipv4_defaults = qw(
2141                                                        ip_forward                        0
2142                                                        ip_default_ttl                    64
2143                                                        ip_no_pmtu_disc                   0
2144                                                        min_pmtu                          562
2145                                                        ipfrag_secret_interval            600
2146                                                        ipfrag_max_dist                   64
2147                                                        somaxconn                         128
2148                                                        tcp_abc                           0
2149                                                        tcp_abort_on_overflow             0
2150                                                        tcp_adv_win_scale                 2
2151                                                        tcp_allowed_congestion_control    reno
2152                                                        tcp_app_win                       31
2153                                                        tcp_fin_timeout                   60
2154                                                        tcp_frto_response                 0
2155                                                        tcp_keepalive_time                7200
2156                                                        tcp_keepalive_probes              9 
2157                                                        tcp_keepalive_intvl               75
2158                                                        tcp_low_latency                   0
2159                                                        tcp_max_syn_backlog               1024
2160                                                        tcp_moderate_rcvbuf               1
2161                                                        tcp_reordering                    3
2162                                                        tcp_retries1                      3
2163                                                        tcp_retries2                      15
2164                                                        tcp_rfc1337                       0
2165                                                        tcp_rmem                          8192_87380_174760
2166                                                        tcp_slow_start_after_idle         1
2167                                                        tcp_stdurg                        0
2168                                                        tcp_synack_retries                5
2169                                                        tcp_syncookies                    0
2170                                                        tcp_syn_retries                   5
2171                                                        tcp_tso_win_divisor               3
2172                                                        tcp_tw_recycle                    0
2173                                                        tcp_tw_reuse                      0
2174                                                        tcp_wmem                          4096_16384_131072
2175                                                        tcp_workaround_signed_windows     0
2176                                                        tcp_dma_copybreak                 4096
2177                                                        ip_nonlocal_bind                  0
2178                                                        ip_dynaddr                        0
2179                                                        icmp_echo_ignore_all              0
2180                                                        icmp_echo_ignore_broadcasts       1
2181                                                        icmp_ratelimit                    100
2182                                                        icmp_ratemask                     6168
2183                                                        icmp_errors_use_inbound_ifaddr    0
2184                                                        igmp_max_memberships              20
2185                                                        icmp_ignore_bogus_error_responses 0
2186                                                     );
2187                                                  
2188  ***      0             0                           $sysctl_conf ||= '/etc/sysctl.conf';
2189  ***      0                                         load_ipv4_defaults(\%ipv4_defaults, $sysctl_conf);
2190                                                  
2191  ***      0                                         $server->{os}->{non_default_ipv4_vals} = '';
2192  ***      0      0                                  if ( chomp(my $ipv4_files = `ls -1p /proc/sys/net/ipv4/`) ) {
2193  ***      0                                            foreach my $ipv4_file ( split "\n", $ipv4_files ) {
2194  ***      0      0                                        next if !exists $ipv4_defaults{$ipv4_file};
2195  ***      0                                               chomp(my $val = `cat /proc/sys/net/ipv4/$ipv4_file`);
2196  ***      0                                               $val =~ s/\s+/_/g;
2197  ***      0      0                                        if ( $ipv4_defaults{$ipv4_file} ne $val ) {
2198  ***      0                                                  push @{ $server->{problems} },
      ***      0                                      
2199                                                                 "Not default value /proc/sys/net/ipv4/$ipv4_file\:\n" .
2200                                                                 "\t\tset=$val\n\t\tdefault=$ipv4_defaults{$ipv4_file}";
2201                                                           }
2202                                                        }
2203                                                     }
2204                                                  
2205  ***      0                                         return;
2206                                                  }
2207                                                  
2208                                                  sub load_ipv4_defaults {
2209  ***      0                    0                    my ( $ipv4_defaults, $sysctl_conf ) = @_;
2210                                                   
2211  ***      0                                         my %conf_ipv4_defaults = parse_sysctl_conf($sysctl_conf);
2212                                                  
2213  ***      0                                         foreach my $var ( keys %conf_ipv4_defaults ) {
2214  ***      0                                            if ( MKDEBUG && exists $ipv4_defaults->{$var} ) {
2215                                                           _d('sysctl override', $var, ': conf=', $conf_ipv4_defaults{$var},
2216                                                              'overrides default', $ipv4_defaults->{$var});
2217                                                        }
2218  ***      0                                            $ipv4_defaults->{$var} = $conf_ipv4_defaults{$var};
2219                                                     }
2220                                                  
2221  ***      0                                         return;
2222                                                  }
2223                                                  
2224                                                  sub parse_sysctl_conf {
2225  ***      0                    0                    my ( $sysctl_conf ) = @_;
2226  ***      0                                         my %sysctl;
2227                                                  
2228  ***      0      0                                  if ( !-f $sysctl_conf ) {
2229  ***      0                                            MKDEBUG && _d('sysctl file', $sysctl_conf, 'does not exist');
2230  ***      0                                            return;
2231                                                     }
2232                                                  
2233  ***      0      0                                  if ( open my $SYSCTL, '<', $sysctl_conf ) {
2234  ***      0                                            MKDEBUG && _d('Parsing', $sysctl_conf);
2235  ***      0                                            while ( my $line = <$SYSCTL> ) {
2236  ***      0      0                                        next if $line  =~ /^#/; # skip comments
2237  ***      0      0                                        next unless $line =~ /\s*net.ipv4.(\w+)\s*=\s*(\w+)/;
2238  ***      0                                               my ( $var, $val ) = ( $1, $2 );
2239  ***      0                                               MKDEBUG && _d('sysctl:', $var, '=', $val);
2240  ***      0      0      0                                 if ( exists $sysctl{$var} && MKDEBUG ) {
2241  ***      0                                                  _d('Duplicate sysctl var:', $var,
2242                                                                 '; was', $sysctl{$var}, ', is now', $val);
2243                                                           }
2244  ***      0                                               $sysctl{$var} = $val;
2245                                                        }
2246                                                     }
2247                                                     else {
2248  ***      0                                            warn "Cannot read $sysctl_conf: $OS_ERROR";
2249                                                     }
2250                                                  
2251  ***      0                                         return %sysctl;
2252                                                  }
2253                                                  
2254                                                  sub _can_run {
2255  ***      0                    0                    my ( $cmd ) = @_;
2256  ***      0                                         my $retval = system("$cmd 2>/dev/null > /dev/null");
2257  ***      0                                         $retval = $retval >> 8;
2258  ***      0                                         MKDEBUG && _d('Running', $cmd, 'returned', $retval);
2259  ***      0      0                                  return !$retval ? 1 : 0;
2260                                                  }
2261                                                  
2262                                                  sub _os_version {
2263  ***      0                    0                    my $version = 'unknown version';
2264                                                  
2265  ***      0      0                                  if ( _can_run('cat /etc/*release') ) {
      ***             0                               
2266  ***      0                                            chomp(my $rel = `cat /etc/*release`);
2267  ***      0      0                                     if ( my ($desc) = $rel =~ m/DISTRIB_DESCRIPTION="(.*)"/ ) {
2268  ***      0                                               $version = $desc;
2269                                                        }
2270                                                        else {
2271  ***      0                                               $version = $rel;
2272                                                        }
2273                                                     }
2274                                                     elsif ( -r '/etc/debian_version' ) {
2275  ***      0                                            chomp(my $rel = `cat /etc/debian_version`);
2276  ***      0                                            $version = "Debian (or Debian-based) $rel";
2277                                                     }
2278                                                     elsif ( MKDEBUG ) {
2279                                                        _d('No OS version info because no /etc/*release exists');
2280                                                     }
2281                                                  
2282  ***      0                                         return $version;
2283                                                  }
2284                                                  
2285                                                  sub _memory_slots {
2286  ***      0                    0                    my @memory_slots = ();
2287                                                  
2288  ***      0      0                                  if ( _can_run('dmidecode') ) {
2289  ***      0                                            my $dmi = `dmidecode`;
2290  ***      0                                            chomp $dmi;
2291  ***      0                                            my @mem_info = $dmi =~ m/^(Memory Device\n.*?)\n\n/gsm;
2292  ***      0                                            my @attribs  = ( 'Size', 'Form Factor', 'Type', 'Type Detail', 'Speed' );
2293  ***      0                                            foreach my $mem ( @mem_info ) {
2294  ***      0                                               my %fields = map { split /: / } $mem =~ m/^\s+(\S.*:.*)$/gm;
      ***      0                                      
2295  ***      0                                               push(@memory_slots, join(' ', grep { $_ } @fields{@attribs}));
      ***      0                                      
2296                                                        }
2297                                                     }
2298                                                     elsif ( MKDEBUG ) {
2299                                                        _d('No memory slots info because dmidecode cannot be ran');
2300                                                     }
2301                                                  
2302  ***      0                                         return @memory_slots;
2303                                                  }
2304                                                  
2305                                                  sub shorten
2306                                                  {
2307  ***      0                    0                    my ( $number, $kb, $d ) = @_;
2308  ***      0                                         my $n = 0;
2309  ***      0                                         my $short;
2310                                                  
2311  ***      0             0                           $kb ||= 1;
2312  ***      0             0                           $d  ||= 2;
2313                                                  
2314  ***      0      0                                  if ( $kb ) {
2315  ***      0                                            while ( $number > 1_023 ) { $number /= 1_024; $n++; }
      ***      0                                      
      ***      0                                      
2316                                                     }
2317                                                     else {
2318  ***      0                                            while ($number > 999) { $number /= 1000; $n++; }
      ***      0                                      
      ***      0                                      
2319                                                     }
2320  ***      0                                         $short = sprintf "%.${d}f%s", $number, ('','k','M','G','T')[$n];
2321  ***      0      0                                  return $1 if $short =~ /^(.+)\.(00)$/o; # 12.00 -> 12 but not 12.00k -> 12k
2322  ***      0                                         return $short;
2323                                                  }
2324                                                  
2325                                                  sub _d {
2326  ***      0                    0                    my ($package, undef, $line) = caller 0;
2327  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2328  ***      0                                              map { defined $_ ? $_ : 'undef' }
2329                                                          @_;
2330  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2331                                                  }
2332                                                  
2333                                                  1;
2334                                                  
2335                                                  # ###########################################################################
2336                                                  # End ServerSpecs package
2337                                                  # ###########################################################################
2338                                                  
2339                                                  # ###########################################################################
2340                                                  # MySQLInstance package 3459
2341                                                  # ###########################################################################
2342                                                  package MySQLInstance;
2343                                                  
2344           1                    1             9   use strict;
               1                                  3   
               1                                  6   
2345           1                    1             7   use warnings FATAL => 'all';
               1                                  2   
               1                                  6   
2346                                                  
2347           1                    1             7   use English qw(-no_match_vars);
               1                                  2   
               1                                  6   
2348           1                    1            14   use File::Temp ();
               1                                  3   
               1                                  4   
2349           1                    1             9   use Data::Dumper;
               1                                  3   
               1                                  8   
2350                                                  $Data::Dumper::Indent = 1;
2351                                                  
2352           1                    1             8   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  8   
2353                                                  
2354                                                  my $option_pattern = '([^\s=]+)(?:=(\S+))?';
2355                                                  
2356                                                  my %alias_for = (
2357                                                     ON   => 'TRUE',
2358                                                     OFF  => 'FALSE',
2359                                                     YES  => '1',
2360                                                     NO   => '0',
2361                                                  );
2362                                                  
2363                                                  my %undef_for = (
2364                                                     'log'                         => 'OFF',
2365                                                     log_bin                       => 'OFF',
2366                                                     log_slow_queries              => 'OFF',
2367                                                     log_slave_updates             => 'ON',
2368                                                     log_queries_not_using_indexes => 'ON',
2369                                                     log_update                    => 'OFF',
2370                                                     skip_bdb                      => 0,
2371                                                     skip_external_locking         => 'ON',
2372                                                     skip_name_resolve             => 'ON',
2373                                                  );
2374                                                  
2375                                                  my %ignore_sys_var = (
2376                                                     date_format     => 1,
2377                                                     datetime_format => 1,
2378                                                     time_format     => 1,
2379                                                  );
2380                                                  
2381                                                  my %eq_for = (
2382                                                     ft_stopword_file          => sub { return _veq(@_, '(built-in)', ''); },
2383                                                     query_cache_type          => sub { return _veq(@_, 'ON', '1');        },
2384                                                     ssl                       => sub { return _veq(@_, '1', 'TRUE');      },
2385                                                     sql_mode                  => sub { return _veq(@_, '', 'OFF');        },
2386                                                  
2387                                                     basedir                   => sub { return _patheq(@_);                },
2388                                                     language                  => sub { return _patheq(@_);                },
2389                                                  
2390                                                     log_bin                   => sub { return _eqifon(@_);                },
2391                                                     log_slow_queries          => sub { return _eqifon(@_);                },
2392                                                  
2393                                                     general_log_file          => sub { return _eqifconfundef(@_);         },
2394                                                     innodb_data_file_path     => sub { return _eqifconfundef(@_);         },
2395                                                     innodb_log_group_home_dir => sub { return _eqifconfundef(@_);         },
2396                                                     log_error                 => sub { return _eqifconfundef(@_);         },
2397                                                     open_files_limit          => sub { return _eqifconfundef(@_);         },
2398                                                     slow_query_log_file       => sub { return _eqifconfundef(@_);         },
2399                                                     tmpdir                    => sub { return _eqifconfundef(@_);         },
2400                                                  
2401                                                     long_query_time           => sub { return _numericeq(@_);             },
2402                                                  );
2403                                                  
2404                                                  my %can_be_duplicate = (
2405                                                     replicate_wild_do_table     => 1,
2406                                                     replicate_wild_ignore_table => 1,
2407                                                     replicate_rewrite_db        => 1,
2408                                                     replicate_ignore_table      => 1,
2409                                                     replicate_ignore_db         => 1,
2410                                                     replicate_do_table          => 1,
2411                                                     replicate_do_db             => 1,
2412                                                  );
2413                                                  
2414                                                  sub mysqld_processes
2415                                                  {
2416  ***      0                    0                    my ( $ps_output ) = @_;
2417  ***      0                                         my @mysqld_processes;
2418  ***      0                                         my $cmd = 'ps -o euser,%cpu,rss,vsz,cmd -e | grep -v grep | grep mysql';
2419  ***      0      0                                  my $ps  = defined $ps_output ? $ps_output : `$cmd`;
2420  ***      0      0                                  if ( $ps ) {
2421  ***      0                                            MKDEBUG && _d('ps full output:', $ps);
2422  ***      0                                            foreach my $line ( split("\n", $ps) ) {
2423  ***      0                                               MKDEBUG && _d('ps line:', $line);
2424  ***      0                                               my ($user, $pcpu, $rss, $vsz, $cmd) = split(/\s+/, $line, 5);
2425  ***      0                                               my $bin = find_mysqld_binary_unix($cmd);
2426  ***      0      0                                        if ( !$bin ) {
2427  ***      0                                                  MKDEBUG && _d('No mysqld binary in ps line');
2428  ***      0                                                  next;
2429                                                           }
2430  ***      0                                               MKDEBUG && _d('mysqld binary from ps:', $bin);
2431  ***      0      0                                        push @mysqld_processes,
      ***             0                               
2432                                                              { user    => $user,
2433                                                                pcpu    => $pcpu,
2434                                                                rss     => $rss,
2435                                                                vsz     => $vsz,
2436                                                                cmd     => $cmd,
2437                                                                '64bit' => `file $bin` =~ m/64-bit/ ? 'Yes' : 'No',
2438                                                                syslog  => $ps =~ m/logger/ ? 'Yes' : 'No',
2439                                                              };
2440                                                        }
2441                                                     }
2442  ***      0                                         MKDEBUG && _d('mysqld processes:', Dumper(\@mysqld_processes));
2443  ***      0                                         return \@mysqld_processes;
2444                                                  }
2445                                                  
2446                                                  sub new {
2447  ***      0                    0                    my ( $class, $cmd ) = @_;
2448  ***      0                                         my $self = {};
2449  ***      0                                         MKDEBUG && _d('cmd:', $cmd);
2450  ***      0      0                                  $self->{mysqld_binary} = find_mysqld_binary_unix($cmd)
2451                                                        or die "No mysqld binary found in $cmd";
2452  ***      0                                         my $file_output  = `file $self->{mysqld_binary} 2>&1`;
2453  ***      0                                         $self->{regsize} = get_register_size($file_output);
2454  ***      0                                         %{ $self->{cmd_line_ops} }
      ***      0                                      
2455                                                        = map {
2456  ***      0                                                 my ( $var, $val ) = m/$option_pattern/o;
2457  ***      0                                                 $var =~ s/-/_/go;
2458  ***      0             0                                   $val ||= $undef_for{$var} || '';
      ***                    0                        
2459  ***      0                                                 $var => $val;
2460                                                          } ($cmd =~ m/--(\S+)/g);
2461  ***      0             0                           $self->{cmd_line_ops}->{defaults_file} ||= '';
2462  ***      0                                         $self->{conf_sys_vars}   = {};
2463  ***      0                                         $self->{online_sys_vars} = {};
2464  ***      0                                         MKDEBUG && _d('new MySQLInstance:', Dumper($self));
2465  ***      0                                         return bless $self, $class;
2466                                                  }
2467                                                  
2468                                                  sub get_register_size {
2469  ***      0                    0                    my ( $file_output ) = @_;
2470  ***      0                                         my ( $size ) = $file_output =~ m/\b(\d+)-bit/;
2471  ***      0             0                           return $size || 0;
2472                                                  }
2473                                                  
2474                                                  sub find_mysqld_binary_unix {
2475  ***      0                    0                    my ( $cmd ) = @_;
2476  ***      0                                         my ( $binary ) = $cmd =~ m/(\S+mysqld)\b(?=\s|\Z)/;
2477  ***      0             0                           return $binary || '';
2478                                                  }
2479                                                  
2480                                                  sub load_sys_vars {
2481  ***      0                    0                    my ( $self, $dbh ) = @_;
2482                                                  
2483  ***      0                                         my $mysqld_broken_msg
2484                                                        = "The mysqld binary may be broken. "
2485                                                        . "Try manually running the command above.\n"
2486                                                        . "Information about system variables from the defaults file "
2487                                                        . "will not be available.\n";
2488                                                  
2489  ***      0                                         my ( $defaults_file_op, $tmp_file ) = $self->_defaults_file_op();
2490  ***      0                                         my $cmd = "$self->{mysqld_binary} $defaults_file_op --help --verbose";
2491  ***      0                                         MKDEBUG && _d('Getting sys vars from mysqld:', $cmd);
2492  ***      0                                         my $retval = system("$cmd 1>/dev/null 2>/dev/null");
2493  ***      0                                         $retval = $retval >> 8;
2494  ***      0      0                                  if ( $retval != 0 ) {
2495  ***      0                                            MKDEBUG && _d('self dump:', Dumper($self));
2496  ***      0                                            warn "Cannot execute $cmd\n" . $mysqld_broken_msg;
2497                                                     }
2498                                                     else {
2499  ***      0      0                                     if ( my $mysqld_output = `$cmd` ) {
2500  ***      0                                               my ($sys_vars) = $mysqld_output =~ m/---\n(.*?)\n\n/ms;
2501  ***      0                                               %{ $self->{conf_sys_vars} }
      ***      0                                      
2502                                                              = map {
2503  ***      0                                                       my ( $var, $val ) = m/^(\S+)\s+(?:(\S+))?/;
2504  ***      0                                                       $var =~ s/-/_/go;
2505  ***      0      0      0                                         if ( $val && $val =~ m/\(No/ ) { # (No default value)
2506  ***      0                                                          $val = undef;
2507                                                                   }
2508  ***      0             0                                         $val ||= $undef_for{$var} || '';
      ***                    0                        
2509  ***      0                                                       $var => $val;
2510                                                                } split "\n", $sys_vars;
2511                                                  
2512  ***      0                                               $self->_load_default_defaults_files($mysqld_output);
2513                                                        }
2514                                                        else {
2515  ***      0                                               warn "MySQL returned no information by running $cmd\n"
2516                                                              . $mysqld_broken_msg;
2517                                                        }
2518                                                     }
2519                                                  
2520  ***      0                                         $self->_load_online_sys_vars($dbh);
2521                                                  
2522  ***      0                                         $self->{defaults_files_sys_vars}
2523                                                        = $self->_vars_from_defaults_file($defaults_file_op); 
2524  ***      0                                         foreach my $var_val ( reverse @{ $self->{defaults_file_sys_vars} } ) {
      ***      0                                      
2525  ***      0                                            my ( $var, $val ) = ( $var_val->[0], $var_val->[1] );
2526  ***      0      0                                     if ( !exists $self->{conf_sys_vars}->{$var} ) {
2527  ***      0                                               $self->{conf_sys_vars}->{$var} = $val;
2528                                                        }
2529  ***      0      0                                     if ( !exists $self->{online_sys_vars}->{$var} ) {
2530  ***      0                                               $self->{online_sys_vars}->{$var} = $val;
2531                                                        }
2532                                                     }
2533                                                  
2534  ***      0                                         return;
2535                                                  }
2536                                                  
2537                                                  sub _defaults_file_op {
2538  ***      0                    0                    my ( $self, $ddf )   = @_;  # ddf = default defaults file (optional)
2539  ***      0                                         my $defaults_file_op = '';
2540  ***      0                                         my $tmp_file         = undef;
2541  ***      0      0                                  my $defaults_file    = defined $ddf ? $ddf
2542                                                                          : $self->{cmd_line_ops}->{defaults_file};
2543                                                  
2544  ***      0      0      0                           if ( $defaults_file && -f $defaults_file ) {
2545  ***      0                                            $tmp_file = File::Temp->new();
2546  ***      0                                            my $cp_cmd = "cp $defaults_file "
2547                                                                   . $tmp_file->filename;
2548  ***      0                                            `$cp_cmd`;
2549  ***      0                                            $defaults_file_op = "--defaults-file=" . $tmp_file->filename;
2550                                                  
2551  ***      0                                            MKDEBUG && _d('Tmp file for defaults file', $defaults_file, ':',
2552                                                           $tmp_file->filename);
2553                                                     }
2554                                                     else {
2555  ***      0                                            MKDEBUG && _d('Defaults file does not exist:', $defaults_file);
2556                                                     }
2557                                                  
2558  ***      0                                         return ( $defaults_file_op, $tmp_file );
2559                                                  }
2560                                                  
2561                                                  sub _load_default_defaults_files {
2562  ***      0                    0                    my ( $self, $mysqld_output ) = @_;
2563  ***      0                                         my ( $ddf_list ) = $mysqld_output =~ /Default options.+order:\n(.*?)\n/ms;
2564  ***      0      0                                  if ( !$ddf_list ) {
2565  ***      0                                            die "Cannot parse default defaults files: $mysqld_output\n";
2566                                                     }
2567  ***      0                                         MKDEBUG && _d('List of default defaults files:', $ddf_list);
2568  ***      0                                         my %have_seen;
2569  ***      0                                         @{ $self->{default_defaults_files} }
      ***      0                                      
2570  ***      0                                            = grep { !$have_seen{$_}++ } split /\s/, $ddf_list;
2571  ***      0                                         return;
2572                                                  }
2573                                                  
2574                                                  sub _vars_from_defaults_file {
2575  ***      0                    0                    my ( $self, $defaults_file_op, $my_print_defaults ) = @_;
2576                                                  
2577  ***      0             0                           my $my_print_defaults_cmd = $my_print_defaults || 'my_print_defaults';
2578  ***      0                                         my $retval = system("$my_print_defaults_cmd --help 1>/dev/null 2>/dev/null");
2579  ***      0                                         $retval = $retval >> 8;
2580  ***      0      0                                  if ( $retval != 0 ) {
2581  ***      0                                            MKDEBUG && _d('self dump:', Dumper($self));
2582  ***      0                                            die "Cannot execute my_print_defaults command '$my_print_defaults_cmd'";
2583                                                     }
2584                                                  
2585  ***      0                                         my @defaults_file_ops;
2586  ***      0                                         my @ddf_ops;
2587                                                  
2588  ***      0      0                                  if( !$defaults_file_op ) {
2589                                                  
2590  ***      0                                            foreach my $ddf ( @{ $self->{default_defaults_files} } ) {
      ***      0                                      
2591  ***      0                                               my @dfo = $self->_defaults_file_op($ddf);
2592  ***      0      0                                        if ( defined $dfo[1] ) { # tmp_file handle
2593  ***      0                                                  push @ddf_ops, [ @dfo ];
2594  ***      0                                                  push @defaults_file_ops, $dfo[0]; # defaults file op
2595                                                           }
2596                                                        }
2597                                                     }
2598                                                     else {
2599  ***      0                                            $defaults_file_ops[0] = $defaults_file_op;
2600                                                     }
2601                                                  
2602  ***      0      0                                  if ( scalar @defaults_file_ops == 0 ) {
2603  ***      0                                            MKDEBUG && _d('self dump:', Dumper($self));
2604  ***      0                                            die 'MySQL instance has no valid defaults files.'
2605                                                     }
2606                                                  
2607  ***      0                                         foreach my $defaults_file_op ( @defaults_file_ops ) {
2608  ***      0                                            my $cmd = "$my_print_defaults_cmd $defaults_file_op mysqld";
2609  ***      0                                            MKDEBUG && _d('my_print_defaults cmd:', $cmd);
2610  ***      0      0                                     if ( my $my_print_defaults_output = `$cmd` ) {
2611  ***      0                                               foreach my $var_val ( split "\n", $my_print_defaults_output ) {
2612  ***      0                                                  my ( $var, $val ) = $var_val =~ m/^--$option_pattern/o;
2613  ***      0                                                  $var =~ s/-/_/go;
2614  ***      0      0      0                                    if ( defined $val && $val =~ /(\d+)([kKmMgGtT]?)/) {
2615  ***      0      0                                              if ( $2 ) {
2616  ***      0                                                        my %digits_for = (
2617                                                                       'k'   => 1_024,
2618                                                                       'K'   => 1_204,
2619                                                                       'm'   => 1_048_576,
2620                                                                       'M'   => 1_048_576,
2621                                                                       'g'   => 1_073_741_824,
2622                                                                       'G'   => 1_073_741_824,
2623                                                                       't'   => 1_099_511_627_776,
2624                                                                       'T'   => 1_099_511_627_776,
2625                                                                    );
2626  ***      0                                                        $val = $1 * $digits_for{$2};
2627                                                                 }
2628                                                              }
2629  ***      0             0                                    $val ||= $undef_for{$var} || '';
      ***                    0                        
2630  ***      0                                                  push @{ $self->{defaults_file_sys_vars} }, [ $var, $val ];
      ***      0                                      
2631                                                           }
2632                                                        }
2633                                                     }
2634  ***      0                                         return;
2635                                                  }
2636                                                  
2637                                                  sub _load_online_sys_vars {
2638  ***      0                    0                    my ( $self, $dbh ) = @_;
2639  ***      0                                         %{ $self->{online_sys_vars} }
      ***      0                                      
2640  ***      0                                            = map { $_->{Variable_name} => $_->{Value} }
2641  ***      0                                                  @{ $dbh->selectall_arrayref('SHOW /*!40101 GLOBAL*/ VARIABLES',
2642                                                                                          { Slice => {} })
2643                                                              };
2644  ***      0                                         return;
2645                                                  }
2646                                                  
2647                                                  sub get_DSN {
2648  ***      0                    0                    my ( $self, $o ) = @_;
2649  ***      0      0                                  die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
2650  ***      0             0                           my $port   = $self->{cmd_line_ops}->{port} || '';
2651  ***      0             0                           my $socket = $o->get('socket') || $self->{cmd_line_ops}->{'socket'} || '';
      ***                    0                        
2652  ***      0      0                                  my $host   = $o->get('socket') ? 'localhost'
      ***             0                               
2653                                                                : $port ne 3306     ? '127.0.0.1'
2654                                                                :                   'localhost';
2655                                                     return {
2656  ***      0                                            P => $port,
2657                                                        S => $socket,
2658                                                        h => $host,
2659                                                     };
2660                                                  }
2661                                                  
2662                                                  sub duplicate_sys_vars {
2663  ***      0                    0                    my ( $self ) = @_;
2664  ***      0                                         my @duplicate_vars;
2665  ***      0                                         my %have_seen;
2666  ***      0                                         foreach my $var_val ( @{ $self->{defaults_file_sys_vars} } ) {
      ***      0                                      
2667  ***      0                                            my ( $var, $val ) = ( $var_val->[0], $var_val->[1] );
2668  ***      0      0                                     next if $can_be_duplicate{$var};
2669  ***      0      0                                     push @duplicate_vars, $var if $have_seen{$var}++ == 1;
2670                                                     }
2671  ***      0                                         return \@duplicate_vars;
2672                                                  }
2673                                                  
2674                                                  sub overriden_sys_vars {
2675  ***      0                    0                    my ( $self ) = @_;
2676  ***      0                                         my %overriden_vars;
2677  ***      0                                         foreach my $var_val ( @{ $self->{defaults_file_sys_vars} } ) {
      ***      0                                      
2678  ***      0                                            my ( $var, $val ) = ( $var_val->[0], $var_val->[1] );
2679  ***      0      0      0                              if ( !defined $var || !defined $val ) {
2680  ***      0                                               MKDEBUG && _d('Undefined var or val:', Dumper($var_val));
2681  ***      0                                               next;
2682                                                        }
2683  ***      0      0                                     if ( exists $self->{cmd_line_ops}->{$var} ) {
2684  ***      0      0      0                                 if(    ( !defined $self->{cmd_line_ops}->{$var} && !defined $val)
      ***                    0                        
2685                                                               || ( $self->{cmd_line_ops}->{$var} ne $val) ) {
2686  ***      0                                                  $overriden_vars{$var} = [ $self->{cmd_line_ops}->{$var}, $val ];
2687                                                           }
2688                                                        }
2689                                                     }
2690  ***      0                                         return \%overriden_vars;
2691                                                  }
2692                                                  
2693                                                  sub out_of_sync_sys_vars {
2694  ***      0                    0                    my ( $self ) = @_;
2695  ***      0                                         my %out_of_sync_vars;
2696                                                  
2697  ***      0                                         VAR:
2698  ***      0                                         foreach my $var ( keys %{ $self->{conf_sys_vars} } ) {
2699  ***      0      0                                     next VAR if exists $ignore_sys_var{$var};
2700  ***      0      0                                     next VAR unless exists $self->{online_sys_vars}->{$var};
2701                                                  
2702  ***      0                                            my $conf_val        = $self->{conf_sys_vars}->{$var};
2703  ***      0                                            my $online_val      = $self->{online_sys_vars}->{$var};
2704  ***      0                                            my $var_out_of_sync = 0;
2705                                                  
2706                                                  
2707  ***      0      0      0                              if ( ($conf_val || $online_val) && ($conf_val ne $online_val) ) {
      ***                    0                        
2708  ***      0                                               $var_out_of_sync = 1;
2709                                                  
2710  ***      0      0                                        if ( exists $eq_for{$var} ) {
2711  ***      0                                                  $var_out_of_sync = !$eq_for{$var}->($conf_val, $online_val);
2712                                                           }
2713  ***      0      0                                        if ( exists $alias_for{$online_val} ) {
2714  ***      0      0                                           $var_out_of_sync = 0 if $conf_val eq $alias_for{$online_val};
2715                                                           }
2716                                                        }
2717                                                  
2718  ***      0      0                                     if ( $var_out_of_sync ) {
2719  ***      0                                               $out_of_sync_vars{$var} = { online=>$online_val, config=>$conf_val };
2720                                                        }
2721                                                     }
2722                                                  
2723  ***      0                                         return \%out_of_sync_vars;
2724                                                  }
2725                                                  
2726                                                  sub load_status_vals {
2727  ***      0                    0                    my ( $self, $dbh ) = @_;
2728  ***      0                                         %{ $self->{status_vals} }
      ***      0                                      
2729  ***      0                                            = map { $_->{Variable_name} => $_->{Value} }
2730  ***      0                                                  @{ $dbh->selectall_arrayref('SHOW /*!50002 GLOBAL */ STATUS',
2731                                                                                          { Slice => {} })
2732                                                              };
2733  ***      0                                         return;
2734                                                  }
2735                                                  
2736                                                  sub get_eq_for {
2737  ***      0                    0                    my ( $var ) = @_;
2738  ***      0      0                                  if ( exists $eq_for{$var} ) {
2739  ***      0                                            return $eq_for{$var};
2740                                                     }
2741  ***      0                                         return;
2742                                                  }
2743                                                  
2744                                                  sub _veq { 
2745  ***      0                    0                    my ( $x, $y, $val1, $val2 ) = @_;
2746  ***      0      0      0                           return 1 if ( ($x eq $val1 || $x eq $val2) && ($y eq $val1 || $y eq $val2) );
      ***                    0                        
      ***                    0                        
2747  ***      0                                         return 0;
2748                                                  }
2749                                                  
2750                                                  sub _patheq {
2751  ***      0                    0                    my ( $x, $y ) = @_;
2752  ***      0      0                                  $x .= '/' if $x !~ m/\/$/;
2753  ***      0      0                                  $y .= '/' if $y !~ m/\/$/;
2754  ***      0                                         return $x eq $y;
2755                                                  }
2756                                                  
2757                                                  sub _eqifon { 
2758  ***      0                    0                    my ( $x, $y ) = @_;
2759  ***      0      0      0                           return 1 if ( $x && $x eq 'ON' && $y );
      ***                    0                        
2760  ***      0      0      0                           return 1 if ( $y && $y eq 'ON' && $x );
      ***                    0                        
2761  ***      0                                         return 0;
2762                                                  }
2763                                                  
2764                                                  sub _eqifconfundef {
2765  ***      0                    0                    my ( $conf_val, $online_val ) = @_;
2766  ***      0      0                                  return ($conf_val eq '' ? 1 : 0);
2767                                                  }
2768                                                  
2769                                                  sub _numericeq {
2770  ***      0                    0                    my ( $x, $y ) = @_;
2771  ***      0      0                                  return ($x == $y ? 1 : 0);
2772                                                  }
2773                                                  
2774                                                  sub _d {
2775  ***      0                    0                    my ($package, undef, $line) = caller 0;
2776  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2777  ***      0                                              map { defined $_ ? $_ : 'undef' }
2778                                                          @_;
2779  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2780                                                  }
2781                                                  
2782                                                  1;
2783                                                  
2784                                                  # ###########################################################################
2785                                                  # End MySQLInstance package
2786                                                  # ###########################################################################
2787                                                  
2788                                                  # ###########################################################################
2789                                                  # SchemaDiscover package 4588
2790                                                  # ###########################################################################
2791                                                  package SchemaDiscover;
2792                                                  
2793           1                    1            12   use strict;
               1                                  4   
               1                                  9   
2794           1                    1             8   use warnings FATAL => 'all';
               1                                  6   
               1                                  8   
2795                                                  
2796           1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  9   
2797                                                  
2798           1                    1             8   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  9   
2799                                                  
2800                                                  sub new {
2801  ***      0                    0                    my ( $class, %args ) = @_;
2802  ***      0                                         foreach my $arg ( qw(du q tp vp) ) {
2803  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
2804                                                     }
2805  ***      0                                         my $self = {
2806                                                        %args
2807                                                     };
2808  ***      0                                         return bless $self, $class;
2809                                                  }
2810                                                  
2811                                                  sub discover {
2812  ***      0                    0                    my ( $self, $dbh ) = @_;
2813  ***      0      0                                  die "I need a dbh" unless $dbh;
2814                                                  
2815  ***      0                                         my $schema = {
2816                                                        dbs         => {},
2817                                                        counts      => {},
2818                                                        stored_code => undef,  # may be either arrayref of error string
2819                                                     };
2820  ***      0                                         my $dbs     = $schema->{dbs};
2821  ***      0                                         my $counts  = $schema->{counts};
2822  ***      0                                         my $du      = $self->{du};
2823  ***      0                                         my $q       = $self->{q};
2824  ***      0                                         my $tp      = $self->{tp};
2825  ***      0                                         my $vp      = $self->{vp};
2826                                                  
2827  ***      0                                         %$dbs = map { $_ => {} } $du->get_databases($dbh, $q);
      ***      0                                      
2828                                                  
2829  ***      0      0                                  delete $dbs->{information_schema}
2830                                                        if exists $dbs->{information_schema};
2831                                                  
2832  ***      0                                         $counts->{TOTAL}->{dbs} = scalar keys %{$dbs};
      ***      0                                      
2833                                                  
2834  ***      0                                         foreach my $db ( keys %$dbs ) {
2835  ***      0                                            %{$dbs->{$db}}
      ***      0                                      
2836  ***      0                                               = map { $_->{name} => {} } $du->get_table_list($dbh, $q, $db);
2837  ***      0                                            foreach my $tbl_stat ($du->get_table_status($dbh, $q, $db)) {
2838  ***      0                                               %{$dbs->{$db}->{"$tbl_stat->{name}"}} = %$tbl_stat;
      ***      0                                      
2839                                                        }
2840  ***      0                                            foreach my $table ( keys %{$dbs->{$db}} ) {
      ***      0                                      
2841  ***      0                                               my $ddl        = $du->get_create_table($dbh, $q, $db, $table);
2842  ***      0                                               my $table_info = $tp->parse($ddl);
2843  ***      0                                               my $n_indexes  = scalar keys %{ $table_info->{keys} };
      ***      0                                      
2844                                                  
2845  ***      0             0                                 my $data_size  = $dbs->{$db}->{$table}->{data_length}  ||= 0;
2846  ***      0             0                                 my $index_size = $dbs->{$db}->{$table}->{index_length} ||= 0;
2847  ***      0             0                                 my $rows       = $dbs->{$db}->{$table}->{rows}         ||= 0;
2848  ***      0                                               my $engine     = $dbs->{$db}->{$table}->{engine}; 
2849                                                  
2850  ***      0                                               $counts->{dbs}->{$db}->{tables}             += 1;
2851  ***      0                                               $counts->{dbs}->{$db}->{indexes}            += $n_indexes;
2852  ***      0                                               $counts->{dbs}->{$db}->{engines}->{$engine} += 1;
2853  ***      0                                               $counts->{dbs}->{$db}->{rows}               += $rows;
2854  ***      0                                               $counts->{dbs}->{$db}->{data_size}          += $data_size;
2855  ***      0                                               $counts->{dbs}->{$db}->{index_size}         += $index_size;
2856                                                  
2857  ***      0                                               $counts->{engines}->{$engine}->{tables}     += 1;
2858  ***      0                                               $counts->{engines}->{$engine}->{indexes}    += $n_indexes;
2859  ***      0                                               $counts->{engines}->{$engine}->{data_size}  += $data_size;
2860  ***      0                                               $counts->{engines}->{$engine}->{index_size} += $index_size; 
2861                                                  
2862  ***      0                                               $counts->{TOTAL}->{tables}     += 1;
2863  ***      0                                               $counts->{TOTAL}->{indexes}    += $n_indexes;
2864  ***      0                                               $counts->{TOTAL}->{rows}       += $rows;
2865  ***      0                                               $counts->{TOTAL}->{data_size}  += $data_size;
2866  ***      0                                               $counts->{TOTAL}->{index_size} += $index_size;
2867                                                        }
2868                                                     }
2869                                                  
2870  ***      0      0                                  if ( $vp->version_ge($dbh, '5.0.0') ) {
2871  ***      0                                            $schema->{stored_code} = $self->discover_stored_code($dbh);
2872                                                     }
2873                                                     else {
2874  ***      0                                            $schema->{stored_code}
2875                                                           = 'This version of MySQL does not support stored code.';
2876                                                     }
2877                                                  
2878  ***      0                                         return $schema;
2879                                                  }
2880                                                  
2881                                                  sub discover_stored_code {
2882  ***      0                    0                    my ( $self, $dbh ) = @_;
2883  ***      0      0                                  die "I need a dbh" unless $dbh;
2884                                                  
2885  ***      0                                         my @stored_code_objs;
2886  ***      0                                         eval {
2887  ***      0                                            @stored_code_objs = @{ $dbh->selectall_arrayref(
      ***      0                                      
2888                                                              "SELECT EVENT_OBJECT_SCHEMA AS db,
2889                                                              CONCAT(LEFT(LOWER(EVENT_MANIPULATION), 3), '_trg') AS what,
2890                                                              COUNT(*) AS num
2891                                                              FROM INFORMATION_SCHEMA.TRIGGERS GROUP BY db, what
2892                                                              UNION ALL
2893                                                              SELECT ROUTINE_SCHEMA AS db,
2894                                                              LEFT(LOWER(ROUTINE_TYPE), 4) AS what,
2895                                                              COUNT(*) AS num
2896                                                              FROM INFORMATION_SCHEMA.ROUTINES GROUP BY db, what
2897                                                              /*!50106
2898                                                                 UNION ALL
2899                                                                 SELECT EVENT_SCHEMA AS db, 'evt' AS what, COUNT(*) AS num
2900                                                                 FROM INFORMATION_SCHEMA.EVENTS GROUP BY db, what
2901                                                              */")
2902                                                        };
2903                                                     };
2904  ***      0      0                                  if ( $EVAL_ERROR ) {
2905  ***      0                                            MKDEBUG && _d($EVAL_ERROR);
2906  ***      0                                            return "Failed to get stored code: $EVAL_ERROR";
2907                                                     }
2908                                                     
2909  ***      0                                         my @formatted_code_objs;
2910  ***      0                                         foreach my $code_obj ( @stored_code_objs ) {
2911  ***      0                                            push @formatted_code_objs, "$code_obj->[0] $code_obj->[1] $code_obj->[2]";
2912                                                     }
2913                                                  
2914  ***      0                                         return \@formatted_code_objs;
2915                                                  }
2916                                                  
2917                                                  sub _d {
2918  ***      0                    0                    my ($package, undef, $line) = caller 0;
2919  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2920  ***      0                                              map { defined $_ ? $_ : 'undef' }
2921                                                          @_;
2922  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2923                                                  }
2924                                                  
2925                                                  1;
2926                                                  
2927                                                  # ###########################################################################
2928                                                  # End SchemaDiscover package
2929                                                  # ###########################################################################
2930                                                  
2931                                                  # ###########################################################################
2932                                                  # MySQLAdvisor package 3186
2933                                                  # ###########################################################################
2934                                                  
2935                                                  package MySQLAdvisor;
2936                                                  
2937           1                    1             8   use strict;
               1                                  3   
               1                                  6   
2938           1                    1             7   use warnings FATAL => 'all';
               1                                  2   
               1                                 31   
2939                                                  
2940           1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  5   
2941           1                    1             8   use List::Util qw(max);
               1                                  2   
               1                                  6   
2942                                                  
2943           1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  8   
2944                                                  
2945                                                  my %checks = (
2946                                                     innodb_flush_method =>
2947                                                        sub {
2948                                                           my ( $sys_vars, $status_vals, $schema, $counts ) = @_;
2949                                                           return "innodb_flush_method is not set to O_DIRECT"
2950                                                              if $sys_vars->{innodb_flush_method} ne 'O_DIRECT';
2951                                                           return 0;
2952                                                        },
2953                                                     log_slow_queries =>
2954                                                        sub {
2955                                                           my ( $sys_vars, $status_vals, $schema, $counts ) = @_;
2956                                                           return "Slow query logging is disabled (log_slow_queries = OFF)"
2957                                                              if $sys_vars->{log_slow_queries} eq 'OFF';
2958                                                           return 0;
2959                                                        },
2960                                                     max_connections =>
2961                                                        sub {
2962                                                           my ( $sys_vars, $status_vals, $schema, $counts ) = @_;
2963                                                           return "max_connections has been modified from its default (100): "
2964                                                                  . $sys_vars->{max_connections}
2965                                                              if $sys_vars->{max_connections} != 100;
2966                                                           return 0;
2967                                                        },
2968                                                     thread_cache_size =>
2969                                                        sub {
2970                                                           my ( $sys_vars, $status_vals, $schema, $counts ) = @_;
2971                                                           return "Zero thread cache (thread_cache_size = 0)"
2972                                                              if $sys_vars->{thread_cache_size} == 0;
2973                                                           return 0;
2974                                                        },
2975                                                     'socket' =>
2976                                                        sub {
2977                                                           my ( $sys_vars, $status_vals, $schema, $counts ) = @_;
2978                                                           if ( ! (-e $sys_vars->{'socket'} && -S $sys_vars->{'socket'}) ) {
2979                                                              return "Socket is missing ($sys_vars->{socket})";
2980                                                           }
2981                                                           return 0;
2982                                                        },
2983                                                     'query_cache' =>
2984                                                        sub {
2985                                                           my ( $sys_vars, $status_vals, $schema, $counts ) = @_;
2986                                                           if ( exists $sys_vars->{query_cache_type} ) {
2987                                                              if (    $sys_vars->{query_cache_type} eq 'ON'
2988                                                                   && $sys_vars->{query_cache_size} == 0) {
2989                                                                 return "Query caching is enabled but query_cache_size is zero";
2990                                                              }
2991                                                           }
2992                                                           return 0;
2993                                                        },
2994                                                     'Innodb_buffer_pool_pages_free' =>
2995                                                        sub {
2996                                                           my ( $sys_vars, $status_vals, $schema, $counts ) = @_;
2997                                                           if ( exists $status_vals->{Innodb_buffer_pool_pages_free} ) {
2998                                                              if ( $status_vals->{Innodb_buffer_pool_pages_free} == 0 ) {
2999                                                                 return "InnoDB: zero free buffer pool pages";
3000                                                              }
3001                                                           }
3002                                                           return 0;
3003                                                        },
3004                                                     'skip_name_resolve' =>
3005                                                        sub {
3006                                                           my ( $sys_vars, $status_vals, $schema, $counts ) = @_;
3007                                                           if ( !exists $sys_vars->{skip_name_resolve} ) {
3008                                                              return "skip-name-resolve is not set";
3009                                                           }
3010                                                           return 0;
3011                                                        },
3012                                                     'key_buffer too large' =>
3013                                                        sub {
3014                                                           my ( $sys_vars, $status_vals, $schema, $counts ) = @_;
3015                                                           return "Key buffer may be too large"
3016                                                              if $sys_vars->{key_buffer_size}
3017                                                                 > max($counts->{engines}->{MyISAM}->{data_size}, 33554432); # 32M
3018                                                           return 0;
3019                                                        },
3020                                                     'InnoDB buffer pool too small' =>
3021                                                        sub {
3022                                                           my ( $sys_vars, $status_vals, $schema, $counts ) = @_;
3023                                                           if (    exists $sys_vars->{innodb_buffer_pool_size} 
3024                                                                && exists $counts->{engines}->{InnoDB} ) {
3025                                                              return "InnoDB: buffer pool too small"
3026                                                                 if $counts->{engines}->{InnoDB}->{data_size}
3027                                                                    >= $sys_vars->{innodb_buffer_pool_size};
3028                                                           }
3029                                                        },
3030                                                  );
3031                                                  
3032                                                  sub new {
3033  ***      0                    0                    my ( $class, $MySQLInstance, $SchemaDiscover ) = @_;
3034  ***      0                                         my $self = {
3035                                                        sys_vars    => $MySQLInstance->{online_sys_vars},
3036                                                        status_vals => $MySQLInstance->{status_vals},
3037                                                        schema      => $SchemaDiscover->{dbs},
3038                                                        counts      => $SchemaDiscover->{counts},
3039                                                     };
3040  ***      0                                         return bless $self, $class;
3041                                                  }
3042                                                  
3043                                                  sub run_checks {
3044  ***      0                    0                    my ( $self, $check_name ) = @_;
3045  ***      0                                         my %problems;
3046  ***      0      0                                  if ( defined $check_name ) {
3047  ***      0      0                                     if ( exists $checks{$check_name} ) {
3048  ***      0      0                                        if ( my $problem = $checks{$check_name}->($self->{sys_vars},
3049                                                                                                     $self->{status_vals},
3050                                                                                                     $self->{schema},
3051                                                                                                     $self->{counts}) ) {
3052  ***      0                                                  $problems{$check_name} = $problem;
3053                                                           }
3054                                                        }
3055                                                        else {
3056  ***      0                                               $problems{ERROR} = "No check named $check_name exists.";
3057                                                        }
3058                                                     }
3059                                                     else {
3060  ***      0                                            foreach my $check_name ( keys %checks ) {
3061  ***      0      0                                        if ( my $problem = $checks{$check_name}->($self->{sys_vars},
3062                                                                                                     $self->{status_vals},
3063                                                                                                     $self->{schema},
3064                                                                                                     $self->{counts}) ) {
3065  ***      0                                                  $problems{$check_name} = $problem;
3066                                                           }
3067                                                        }
3068                                                     }
3069  ***      0                                         return \%problems;
3070                                                  }
3071                                                  
3072                                                  sub _d {
3073  ***      0                    0                    my ($package, undef, $line) = caller 0;
3074  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
3075  ***      0                                              map { defined $_ ? $_ : 'undef' }
3076                                                          @_;
3077  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3078                                                  }
3079                                                  
3080                                                  1;
3081                                                  
3082                                                  # ###########################################################################
3083                                                  # End MySQLAdvisor package
3084                                                  # ###########################################################################
3085                                                  
3086                                                  # ###########################################################################
3087                                                  # AggregateProcesslist package 3470
3088                                                  # ###########################################################################
3089                                                  package AggregateProcesslist;
3090                                                  
3091           1                    1             7   use strict;
               1                                  3   
               1                                  6   
3092           1                    1             7   use warnings FATAL => 'all';
               1                                  3   
               1                                  5   
3093           1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  5   
3094                                                  
3095           1                    1             8   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  8   
3096                                                  
3097                                                  sub new {
3098  ***      0                    0                    my ( $class, %args ) = @_;
3099  ***      0             0                           my $self = {
3100                                                        undef_val => $args{undef_val} || 'NULL',
3101                                                     };
3102  ***      0                                         return bless $self, $class;
3103                                                  }
3104                                                  
3105                                                  sub aggregate {
3106  ***      0                    0                    my ( $self, $proclist ) = @_;
3107  ***      0                                         my $aggregate = {};
3108  ***      0                                         foreach my $proc ( @{$proclist} ) {
      ***      0                                      
3109  ***      0                                            foreach my $field ( keys %{ $proc } ) {
      ***      0                                      
3110  ***      0      0                                        next if $field eq 'Id';
3111  ***      0      0                                        next if $field eq 'Info';
3112  ***      0      0                                        next if $field eq 'Time';
3113                                                  
3114  ***      0                                               my $val  = $proc->{ $field };
3115  ***      0      0                                           $val  = $self->{undef_val} if !defined $val;
3116  ***      0      0      0                                    $val  = lc $val if ( $field eq 'Command' || $field eq 'State' );
3117  ***      0      0                                           $val  =~ s/:.*// if $field eq 'Host';
3118                                                  
3119  ***      0                                               my $time = $proc->{Time};
3120  ***      0      0                                           $time = 0 if $time eq 'NULL';
3121                                                  
3122  ***      0                                               $field = lc $field;
3123                                                  
3124  ***      0                                               $aggregate->{ $field }->{ $val }->{time}  += $time;
3125  ***      0                                               $aggregate->{ $field }->{ $val }->{count} += 1;
3126                                                        }
3127                                                     }
3128  ***      0                                         return $aggregate;
3129                                                  }
3130                                                  
3131                                                  sub _d {
3132  ***      0                    0                    my ($package, undef, $line) = caller 0;
3133  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
3134  ***      0                                              map { defined $_ ? $_ : 'undef' }
3135                                                          @_;
3136  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3137                                                  }
3138                                                  
3139                                                  1;
3140                                                  
3141                                                  # ###########################################################################
3142                                                  # End AggregateProcesslist package
3143                                                  # ###########################################################################
3144                                                  
3145                                                  # ###########################################################################
3146                                                  # Grants package 3464
3147                                                  # ###########################################################################
3148                                                  package Grants;
3149                                                  
3150           1                    1             8   use strict;
               1                                  3   
               1                                  6   
3151           1                    1             7   use warnings FATAL => 'all';
               1                                  2   
               1                                  6   
3152           1                    1             7   use English qw(-no_match_vars);
               1                                  3   
               1                                  5   
3153                                                  
3154           1                    1            15   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  8   
3155                                                  
3156                                                  my %check_for_priv = (
3157                                                     'PROCESS' => sub {
3158                                                        my ( $dbh ) = @_;
3159                                                        my $priv =
3160                                                           grep { m/ALL PRIVILEGES.*?\*\.\*|PROCESS/ }
3161                                                           @{$dbh->selectcol_arrayref('SHOW GRANTS')};
3162                                                           return 0 if !$priv;
3163                                                           return 1;
3164                                                     },
3165                                                  );
3166                                                        
3167                                                  sub new {
3168  ***      0                    0                    my ( $class, %args ) = @_;
3169  ***      0                                         my $self = {};
3170  ***      0                                         return bless $self, $class;
3171                                                  }
3172                                                  
3173                                                  sub have_priv {
3174  ***      0                    0                    my ( $self, $dbh, $priv ) = @_;
3175  ***      0                                         $priv = uc $priv;
3176  ***      0      0                                  if ( !exists $check_for_priv{$priv} ) {
3177  ***      0                                            die "There is no check for privilege $priv";
3178                                                     }
3179  ***      0                                         return $check_for_priv{$priv}->($dbh);
3180                                                  }
3181                                                  
3182                                                  sub _d {
3183  ***      0                    0                    my ($package, undef, $line) = caller 0;
3184  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
3185  ***      0                                              map { defined $_ ? $_ : 'undef' }
3186                                                          @_;
3187  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3188                                                  }
3189                                                  
3190                                                  1;
3191                                                  
3192                                                  # ###########################################################################
3193                                                  # End Grants package
3194                                                  # ###########################################################################
3195                                                  
3196                                                  # ###########################################################################
3197                                                  # Transformers package 4299
3198                                                  # ###########################################################################
3199                                                  
3200                                                  package Transformers;
3201                                                  
3202           1                    1            13   use strict;
               1                                  3   
               1                                  5   
3203           1                    1             7   use warnings FATAL => 'all';
               1                                  2   
               1                                  6   
3204           1                    1             7   use English qw(-no_match_vars);
               1                                  7   
               1                                  5   
3205           1                    1            14   use Time::Local qw(timelocal);
               1                                  3   
               1                                 12   
3206           1                    1             8   use Digest::MD5 qw(md5_hex);
               1                                  3   
               1                                  8   
3207                                                  
3208           1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  8   
3209                                                  
3210                                                  require Exporter;
3211                                                  our @ISA         = qw(Exporter);
3212                                                  our %EXPORT_TAGS = ();
3213                                                  our @EXPORT      = ();
3214                                                  our @EXPORT_OK   = qw(
3215                                                     micro_t
3216                                                     percentage_of
3217                                                     secs_to_time
3218                                                     shorten
3219                                                     ts
3220                                                     parse_timestamp
3221                                                     unix_timestamp
3222                                                     any_unix_timestamp
3223                                                     make_checksum
3224                                                  );
3225                                                  
3226                                                  our $mysql_ts  = qr/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?/;
3227                                                  our $proper_ts = qr/(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(?:\.\d+)?/;
3228                                                  our $n_ts      = qr/(\d{1,5})([shmd]?)/; # Limit \d{1,5} because \d{6} looks
3229                                                  
3230                                                  sub micro_t {
3231  ***      0                    0                    my ( $t, %args ) = @_;
3232  ***      0      0                                  my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
3233  ***      0      0                                  my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
3234  ***      0                                         my $f;
3235                                                  
3236  ***      0      0                                  $t = 0 if $t < 0;
3237                                                  
3238  ***      0      0                                  $t = sprintf('%.17f', $t) if $t =~ /e/;
3239                                                  
3240  ***      0                                         $t =~ s/\.(\d{1,6})\d*/\.$1/;
3241                                                  
3242  ***      0      0      0                           if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
3243  ***      0                                            $f = ($t * 1000000) . 'us';
3244                                                     }
3245                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
3246  ***      0                                            $f = sprintf("%.${p_ms}f", $t * 1000);
3247  ***      0                                            $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
3248                                                     }
3249                                                     elsif ($t >= 1) {
3250  ***      0                                            $f = sprintf("%.${p_s}f", $t);
3251  ***      0                                            $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
3252                                                     }
3253                                                     else {
3254  ***      0                                            $f = 0;  # $t should = 0 at this point
3255                                                     }
3256                                                  
3257  ***      0                                         return $f;
3258                                                  }
3259                                                  
3260                                                  sub percentage_of {
3261  ***      0                    0                    my ( $is, $of, %args ) = @_;
3262  ***      0             0                           my $p   = $args{p} || 0; # float precision
3263  ***      0      0                                  my $fmt = $p ? "%.${p}f" : "%d";
3264  ***      0             0                           return sprintf $fmt, ($is * 100) / ($of ||= 1);
3265                                                  }
3266                                                  
3267                                                  sub secs_to_time {
3268  ***      0                    0                    my ( $secs, $fmt ) = @_;
3269  ***      0             0                           $secs ||= 0;
3270  ***      0      0                                  return '00:00' unless $secs;
3271                                                  
3272  ***      0      0      0                           $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
3273                                                            : $secs >= 3_600  ? 'h'
3274                                                            :                   'm';
3275                                                  
3276                                                     return
3277  ***      0      0                                     $fmt eq 'd' ? sprintf(
      ***             0                               
3278                                                           "%d+%02d:%02d:%02d",
3279                                                           int($secs / 86_400),
3280                                                           int(($secs % 86_400) / 3_600),
3281                                                           int(($secs % 3_600) / 60),
3282                                                           $secs % 60)
3283                                                        : $fmt eq 'h' ? sprintf(
3284                                                           "%02d:%02d:%02d",
3285                                                           int(($secs % 86_400) / 3_600),
3286                                                           int(($secs % 3_600) / 60),
3287                                                           $secs % 60)
3288                                                        : sprintf(
3289                                                           "%02d:%02d",
3290                                                           int(($secs % 3_600) / 60),
3291                                                           $secs % 60);
3292                                                  }
3293                                                  
3294                                                  sub shorten {
3295  ***      0                    0                    my ( $num, %args ) = @_;
3296  ***      0      0                                  my $p = defined $args{p} ? $args{p} : 2;     # float precision
3297  ***      0      0                                  my $d = defined $args{d} ? $args{d} : 1_024; # divisor
3298  ***      0                                         my $n = 0;
3299  ***      0                                         my @units = ('', qw(k M G T P E Z Y));
3300  ***      0             0                           while ( $num >= $d && $n < @units - 1 ) {
3301  ***      0                                            $num /= $d;
3302  ***      0                                            ++$n;
3303                                                     }
3304  ***      0      0      0                           return sprintf(
3305                                                        $num =~ m/\./ || $n
3306                                                           ? "%.${p}f%s"
3307                                                           : '%d',
3308                                                        $num, $units[$n]);
3309                                                  }
3310                                                  
3311                                                  sub ts {
3312  ***      0                    0                    my ( $time ) = @_;
3313  ***      0                                         my ( $sec, $min, $hour, $mday, $mon, $year )
3314                                                        = localtime($time);
3315  ***      0                                         $mon  += 1;
3316  ***      0                                         $year += 1900;
3317  ***      0                                         return sprintf("%d-%02d-%02dT%02d:%02d:%02d",
3318                                                        $year, $mon, $mday, $hour, $min, $sec);
3319                                                  }
3320                                                  
3321                                                  sub parse_timestamp {
3322  ***      0                    0                    my ( $val ) = @_;
3323  ***      0      0                                  if ( my($y, $m, $d, $h, $i, $s, $f)
3324                                                           = $val =~ m/^$mysql_ts$/ )
3325                                                     {
3326  ***      0      0                                     return sprintf "%d-%02d-%02d %02d:%02d:"
      ***             0                               
3327                                                                       . (defined $f ? '%02.6f' : '%02d'),
3328                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
3329                                                     }
3330  ***      0                                         return $val;
3331                                                  }
3332                                                  
3333                                                  sub unix_timestamp {
3334  ***      0                    0                    my ( $val ) = @_;
3335  ***      0      0                                  if ( my($y, $m, $d, $h, $i, $s)
3336                                                       = $val =~ m/^$proper_ts$/ )
3337                                                     {
3338  ***      0                                            return timelocal($s, $i, $h, $d, $m - 1, $y);
3339                                                     }
3340  ***      0                                         return $val;
3341                                                  }
3342                                                  
3343                                                  sub any_unix_timestamp {
3344  ***      0                    0                    my ( $val, $callback ) = @_;
3345                                                  
3346  ***      0      0                                  if ( my ($n, $suffix) = $val =~ m/^$n_ts$/ ) {
      ***             0                               
      ***             0                               
3347  ***      0      0                                     $n = $suffix eq 's' ? $n            # Seconds
      ***             0                               
      ***             0                               
      ***             0                               
3348                                                           : $suffix eq 'm' ? $n * 60       # Minutes
3349                                                           : $suffix eq 'h' ? $n * 3600     # Hours
3350                                                           : $suffix eq 'd' ? $n * 86400    # Days
3351                                                           :                  $n;           # default: Seconds
3352  ***      0                                            MKDEBUG && _d('ts is now - N[shmd]:', $n);
3353  ***      0                                            return time - $n;
3354                                                     }
3355                                                     elsif ( my ($ymd, $hms) = $val =~ m/^(\d{6})(?:\s+(\d+:\d+:\d+))?/ ) {
3356  ***      0                                            MKDEBUG && _d('ts is MySQL slow log timestamp');
3357  ***      0      0                                     $val .= ' 00:00:00' unless $hms;
3358  ***      0                                            return unix_timestamp(parse_timestamp($val));
3359                                                     }
3360                                                     elsif ( ($ymd, $hms) = $val =~ m/^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) {
3361  ***      0                                            MKDEBUG && _d('ts is properly formatted timestamp');
3362  ***      0      0                                     $val .= ' 00:00:00' unless $hms;
3363  ***      0                                            return unix_timestamp($val);
3364                                                     }
3365                                                     else {
3366  ***      0                                            MKDEBUG && _d('ts is MySQL expression');
3367  ***      0      0      0                              return $callback->($val) if $callback && ref $callback eq 'CODE';
3368                                                     }
3369                                                  
3370  ***      0                                         MKDEBUG && _d('Unknown ts type:', $val);
3371  ***      0                                         return;
3372                                                  }
3373                                                  
3374                                                  sub make_checksum {
3375  ***      0                    0                    my ( $val ) = @_;
3376  ***      0                                         my $checksum = uc substr(md5_hex($val), -16);
3377  ***      0                                         MKDEBUG && _d($checksum, 'checksum for', $val);
3378  ***      0                                         return $checksum;
3379                                                  }
3380                                                  
3381                                                  sub _d {
3382  ***      0                    0                    my ($package, undef, $line) = caller 0;
3383  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
3384  ***      0                                              map { defined $_ ? $_ : 'undef' }
3385                                                          @_;
3386  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3387                                                  }
3388                                                  
3389                                                  1;
3390                                                  
3391                                                  # ###########################################################################
3392                                                  # End Transformers package
3393                                                  # ###########################################################################
3394                                                  
3395                                                  # ###########################################################################
3396                                                  # MySQLInstanceReporter package 3469
3397                                                  # ###########################################################################
3398                                                  
3399                                                  package MySQLInstanceReporter;
3400                                                  
3401           1                    1             9   use strict;
               1                                  3   
               1                                  7   
3402           1                    1             7   use warnings FATAL => 'all';
               1                                  3   
               1                                  6   
3403           1                    1             7   use English qw(-no_match_vars);
               1                                  3   
               1                                  6   
3404                                                  
3405                                                  Transformers->import( qw(micro_t shorten secs_to_time) );
3406                                                  
3407           1                    1             6   use constant MKDEBUG     => $ENV{MKDEBUG};
               1                                  3   
               1                                  8   
3408           1                    1             6   use constant LINE_LENGTH => 74;
               1                                  2   
               1                                  5   
3409                                                  
3410                                                  sub new {
3411  ***      0                    0                    my ( $class, %args ) = @_;
3412  ***      0                                         my $self = {};
3413  ***      0                                         return bless $self, $class;
3414                                                  }
3415                                                  
3416                                                  sub report {
3417  ***      0                    0                    my ( $self, %args ) = @_;
3418  ***      0                                         foreach my $arg ( qw(mi n ps schema ma o proclist) ) {
3419  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
3420                                                     }
3421  ***      0                                         my $mi       = $args{mi};
3422  ***      0                                         my $n        = $args{n};
3423  ***      0                                         my $ps       = $args{ps};
3424  ***      0                                         my $schema   = $args{schema};
3425  ***      0                                         my $ma       = $args{ma};
3426  ***      0                                         my $o        = $args{o};
3427  ***      0                                         my $proclist = $args{proclist};
3428                                                  
3429                                                  format MYSQL_INSTANCE_1 =
3430                                                  
3431                                                  ____________________________________________________________ MySQL Instance @>>
3432                                                  $n
3433                                                     Version:  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Architecture: @<-bit
3434                                                  $mi->{online_sys_vars}->{version}, $mi->{regsize}
3435                                                     Uptime:   @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
3436                                                  secs_to_time($mi->{status_vals}->{Uptime})
3437                                                     ps vals:  user @<<<<<<< cpu% @<<<<< rss @<<<<<< vsz @<<<<<< syslog: @<<
3438                                                  $ps->{user}, $ps->{pcpu}, shorten($ps->{rss} * 1024), shorten($ps->{vsz} * 1024), $ps->{syslog}
3439                                                     Bin:      @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
3440                                                  $mi->{mysqld_binary}
3441                                                     Data dir: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
3442                                                  $mi->{online_sys_vars}->{datadir}
3443                                                     PID file: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
3444                                                  $mi->{online_sys_vars}->{pid_file}
3445                                                     Socket:   @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
3446                                                  $mi->{online_sys_vars}->{'socket'}
3447                                                     Port:     @<<<<<<
3448                                                  $mi->{online_sys_vars}->{port}
3449                                                     Log locations:
3450                                                        Error:  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
3451                                                  $mi->{conf_sys_vars}->{log_error} || ''
3452                                                        Relay:  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
3453                                                  $mi->{conf_sys_vars}->{relay_log} || ''
3454                                                        Slow:   @<<<<<< @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
3455                                                  micro_t($mi->{online_sys_vars}->{long_query_time}), $mi->{conf_sys_vars}->{log_slow_queries} || 'OFF'
3456                                                     Config file location: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
3457                                                  $mi->{cmd_line_ops}->{defaults_file}
3458                                                  .
3459                                                  
3460  ***      0                                         $FORMAT_NAME = 'MYSQL_INSTANCE_1';
3461  ***      0                                         write;
3462                                                  
3463  ***      0      0                                  if ( $schema->{counts}->{TOTAL}->{dbs} == 0 ) {
3464  ***      0                                            print "This MySQL instance has no databases.\n"
3465                                                     }
3466                                                     else {
3467                                                  format MYSQL_INSTANCE_2 =
3468                                                     SCHEMA ________________________________________________________________
3469                                                        @<<<<<<      @<<<<<<   @<<<<<<   @<<<<<<    @<<<<<<     @<<<<<<
3470                                                  $schema->{counts}->{TOTAL}->{dbs}, $schema->{counts}->{TOTAL}->{tables}, shorten($schema->{counts}->{TOTAL}->{rows}, d=>1000), $schema->{counts}->{TOTAL}->{indexes} || 'NA', shorten($schema->{counts}->{TOTAL}->{data_size}), shorten($schema->{counts}->{TOTAL}->{index_size})
3471                                                  
3472                                                        Key buffer size        : @<<<<<<
3473                                                  shorten($mi->{online_sys_vars}->{key_buffer_size})
3474                                                        InnoDB buffer pool size: @<<<<<<
3475                                                  exists $mi->{online_sys_vars}->{innodb_buffer_pool_size} ? shorten($mi->{online_sys_vars}->{innodb_buffer_pool_size}) : ''
3476                                                  
3477                                                  .
3478                                                  
3479  ***      0                                            $FORMAT_NAME = 'MYSQL_INSTANCE_2';
3480  ***      0                                            write;
3481                                                  
3482  ***      0                                            $self->_print_dbs_size_summary($schema, $o);
3483  ***      0                                            $self->_print_tables_size_summary($schema, $o);
3484  ***      0                                            $self->_print_engines_summary($schema, $o);
3485  ***      0                                            $self->_print_stored_code_summary($schema, $o);
3486                                                     }
3487                                                  
3488  ***      0                                         print "\n   PROBLEMS ______________________________________________________________\n";
3489                                                  
3490  ***      0                                         my $duplicates = $mi->duplicate_sys_vars();
3491  ***      0      0                                  if ( scalar @{ $duplicates } ) {
      ***      0                                      
3492  ***      0                                            print "\tDuplicate system variables in config file:\n";
3493  ***      0                                            print "\tVARIABLE\n";
3494  ***      0                                            foreach my $var ( @{ $duplicates } ) {
      ***      0                                      
3495  ***      0                                               print "\t$var\n";
3496                                                        }
3497  ***      0                                            print "\n";
3498                                                     }
3499                                                  
3500  ***      0                                         my $three_cols = "\t%-20.20s  %-24.24s  %-24.24s\n";
3501                                                  
3502  ***      0                                         my $overridens = $mi->overriden_sys_vars();
3503  ***      0      0                                  if ( scalar keys %{ $overridens } ) {
      ***      0                                      
3504  ***      0                                            print "\tOverridden system variables "
3505                                                           . "(cmd line value overrides config value):\n";
3506  ***      0                                            printf($three_cols, 'VARIABLE', 'CMD LINE VALUE', 'CONFIG VALUE');
3507  ***      0                                            foreach my $var ( keys %{ $overridens } ) {
      ***      0                                      
3508  ***      0                                               printf($three_cols,
3509                                                                  $var,
3510                                                                  $overridens->{$var}->[0],
3511                                                                  $overridens->{$var}->[1]);
3512                                                        }
3513  ***      0                                            print "\n";
3514                                                     }
3515                                                  
3516  ***      0                                         my $oos = $mi->out_of_sync_sys_vars();
3517  ***      0      0                                  if ( scalar keys %{ $oos } ) {
      ***      0                                      
3518  ***      0                                            print "\tOut of sync system variables "
3519                                                           . "(online value differs from config value):\n";
3520  ***      0                                            printf($three_cols, 'VARIABLE', 'ONLINE VALUE', 'CONFIG VALUE');
3521  ***      0                                            foreach my $var ( keys %{ $oos } ) {
      ***      0                                      
3522  ***      0                                               printf($three_cols,
3523                                                                  $var,
3524                                                                  $oos->{$var}->{online},
3525                                                                  $oos->{$var}->{config});
3526                                                        }
3527  ***      0                                            print "\n";
3528                                                     }
3529                                                  
3530  ***      0                                         my $failed_checks = $ma->run_checks();
3531  ***      0      0                                  if ( scalar keys %{ $failed_checks } ) {
      ***      0                                      
3532  ***      0                                            print "\tThings to Note:\n";
3533  ***      0                                            foreach my $check_name ( keys %{ $failed_checks } ) {
      ***      0                                      
3534  ***      0                                               print "\t\t- $failed_checks->{$check_name}\n";
3535                                                        }
3536                                                     }
3537                                                  
3538  ***      0                                         $self->_print_aggregated_processlist($proclist);
3539                                                  
3540  ***      0                                         return;
3541                                                  }
3542                                                  
3543                                                  sub _print_dbs_size_summary {
3544  ***      0                    0                    my ( $self, $schema, $o ) = @_;
3545  ***      0                                         my %dbs = %{ $schema->{counts}->{dbs} }; # copy we can chop
      ***      0                                      
3546  ***      0                                         my $top = $o->get('top');
3547  ***      0                                         my @sorted;
3548  ***      0                                         my ( $db, $size );
3549  ***      0                                         print   "      Top $top largest databases:\n"
3550                                                           . "         DATABASE             SIZE DATA\n";
3551                                                  format DB_LINE =
3552                                                           @<<<<<<<<<<<<<<<<<   @<<<<<<<<<<<<<<<<<<<<<<<<<<<
3553                                                  $db, $size
3554                                                  .
3555  ***      0                                         @sorted = sort { $dbs{$b}->{data_size} <=> $dbs{$a}->{data_size} } keys %dbs;
      ***      0                                      
3556  ***      0                                         $FORMAT_NAME = 'DB_LINE';
3557  ***      0                                         foreach $db ( @sorted ) {
3558  ***      0                                            $size = shorten($dbs{$db}->{data_size});
3559  ***      0                                            write;
3560  ***      0                                            delete $dbs{$db};
3561  ***      0      0                                     last if !--$top;
3562                                                     }
3563  ***      0                                         my $n_remaining = 0;
3564  ***      0                                         my $r_size      = 0;
3565  ***      0                                         my $r_avg       = 0;
3566  ***      0                                         foreach my $db ( keys %dbs ) {
3567  ***      0                                            $n_remaining++;
3568  ***      0                                            $r_size += $dbs{$db}->{data_size};
3569                                                     }
3570  ***      0      0                                  if ($n_remaining) {
3571  ***      0                                            $r_avg = shorten($r_size / $n_remaining);
3572  ***      0                                            $r_size = shorten($r_size);
3573  ***      0                                            $db   = "Remaining $n_remaining";
3574  ***      0                                            $size = "$r_size ($r_avg average)";
3575  ***      0                                            write;
3576                                                     }
3577  ***      0                                         return;
3578                                                  }
3579                                                  
3580                                                  sub _print_tables_size_summary {
3581  ***      0                    0                    my ( $self, $schema, $o ) = @_;
3582  ***      0                                         my %dbs_tbls;
3583  ***      0                                         my $dbs = $schema->{dbs};
3584  ***      0                                         my $top = $o->get('top');
3585  ***      0                                         my @sorted;
3586  ***      0                                         my ( $db_tbl, $size_data, $size_index, $n_rows, $engine );
3587  ***      0                                         print   "      Top $top largest tables:\n"
3588                                                           . "         DB.TBL              SIZE DATA  SIZE INDEX  #ROWS    ENGINE\n";
3589                                                  format TBL_LINE =
3590                                                           @<<<<<<<<<<<<<<<<   @<<<<<<<<  @<<<<<<<<<  @<<<<<<  @<<<<<
3591                                                  $db_tbl, $size_data, $size_index, $n_rows, $engine
3592                                                  .
3593  ***      0                                         foreach my $db ( keys %$dbs ) {
3594  ***      0                                            foreach my $tbl ( keys %{$dbs->{$db}} ) {
      ***      0                                      
3595  ***      0                                               $dbs_tbls{"$db.$tbl"} = $dbs->{$db}->{$tbl}->{data_length};
3596                                                        }
3597                                                     }
3598  ***      0                                         @sorted = sort { $dbs_tbls{$b} <=> $dbs_tbls{$a} } keys %dbs_tbls;
      ***      0                                      
3599  ***      0                                         $FORMAT_NAME = 'TBL_LINE';
3600  ***      0                                         foreach $db_tbl ( @sorted ) {
3601  ***      0                                            my ( $db, $tbl ) = split '\.', $db_tbl;
3602  ***      0                                            $size_data  = shorten($dbs_tbls{$db_tbl});
3603  ***      0                                            $size_index = shorten($dbs->{$db}->{$tbl}->{index_length});
3604  ***      0                                            $n_rows     = shorten($dbs->{$db}->{$tbl}->{rows}, d=>1000);
3605  ***      0                                            $engine     = $dbs->{$db}->{$tbl}->{engine};
3606  ***      0                                            write;
3607  ***      0                                            delete $dbs_tbls{$db_tbl};
3608  ***      0      0                                     last if !--$top;
3609                                                     }
3610  ***      0                                         my $n_remaining = 0;
3611  ***      0                                         my $r_size      = 0;
3612  ***      0                                         my $r_avg       = 0;
3613  ***      0                                         foreach my $db_tbl ( keys %dbs_tbls ) {
3614  ***      0                                            $n_remaining++;
3615  ***      0                                            $r_size += $dbs_tbls{$db_tbl};
3616                                                     }
3617  ***      0      0                                  if ($n_remaining) {
3618  ***      0                                            $r_avg  = shorten($r_size / $n_remaining);
3619  ***      0                                            $r_size = shorten($r_size);
3620  ***      0                                            print "         Remaining $n_remaining        $r_size ($r_avg average)\n";
3621                                                     }
3622  ***      0                                         return;
3623                                                  }
3624                                                  
3625                                                  sub _print_engines_summary {
3626  ***      0                    0                    my ( $self, $schema, $o ) = @_;
3627  ***      0                                         my $engines = $schema->{counts}->{engines};
3628  ***      0                                         my ($engine, $n_tables, $n_indexes, $size_data, $size_indexes);
3629  ***      0                                         print   "      Engines:\n"
3630                                                           . "         ENGINE      SIZE DATA   SIZE INDEX   #TABLES   #INDEXES\n";
3631                                                  format ENGINE_LINE =
3632                                                           @<<<<<<<<<  @<<<<<<     @<<<<<<      @<<<<<<   @<<<<<<
3633                                                  $engine, $size_data, $size_indexes, $n_tables, $n_indexes
3634                                                  .
3635  ***      0                                         $FORMAT_NAME = 'ENGINE_LINE';
3636  ***      0                                         foreach $engine ( keys %{ $engines } ) {
      ***      0                                      
3637  ***      0                                            $size_data    = shorten($engines->{$engine}->{data_size});
3638  ***      0                                            $size_indexes = shorten($engines->{$engine}->{index_size});
3639  ***      0                                            $n_tables     = $engines->{$engine}->{tables};
3640  ***      0             0                              $n_indexes    = $engines->{$engine}->{indexes} || 'NA';
3641  ***      0                                            write;
3642                                                     }
3643  ***      0                                         return;
3644                                                  }
3645                                                  
3646                                                  sub _print_stored_code_summary {
3647  ***      0                    0                    my ( $self, $schema, $o ) = @_;
3648  ***      0                                         my ( $db, $type, $count );
3649                                                  
3650  ***      0                                         print   "      Triggers, Routines, Events:\n"
3651                                                           . "         DATABASE           TYPE      COUNT\n";
3652                                                  format TRE_LINE =
3653                                                           @<<<<<<<<<<<<<<<<  @<<<<<<   @<<<<<<
3654                                                  $db, $type, $count
3655                                                  .
3656                                                  
3657  ***      0      0                                  if ( ref $schema->{stored_code} ) {
3658  ***      0                                            my @stored_code_objs = @{$schema->{stored_code}};
      ***      0                                      
3659  ***      0      0                                     if ( @stored_code_objs ) {
3660  ***      0                                               $FORMAT_NAME = 'TRE_LINE';
3661  ***      0                                               foreach my $code_obj ( @stored_code_objs ) {
3662  ***      0                                                  ( $db, $type, $count ) = split ' ', $code_obj;
3663  ***      0                                                  write;
3664                                                           }
3665                                                        }
3666                                                        else {
3667  ***      0                                               print "         No triggers, routines, or events\n";
3668                                                        }
3669                                                     }
3670                                                     else {
3671  ***      0                                            print "         $schema->{stored_code}\n";
3672                                                     }
3673                                                  
3674  ***      0                                         return;
3675                                                  }
3676                                                  
3677                                                  sub _print_aggregated_processlist {
3678  ***      0                    0                    my ( $self, $ag_pl ) = @_;
3679  ***      0                                         my ( $value, $count, $total_time); # used by format
3680                                                  
3681  ***      0                                         print "\n   Aggregated PROCESSLIST ________________________________________________
3682                                                        FIELD      VALUE                       COUNT   TOTAL TIME (s)\n";
3683                                                  
3684                                                  format VALUE_LINE =
3685                                                                   @<<<<<<<<<<<<<<<<<<<<<<<<   @<<<<   @<<<<
3686                                                  $value, $count, $total_time
3687                                                  .
3688                                                  
3689  ***      0      0                                  if ( ref $ag_pl ) {
3690  ***      0                                            foreach my $field ( keys %{ $ag_pl } ) {
      ***      0                                      
3691  ***      0                                               printf "      %.8s\n", $field;
3692  ***      0                                               $FORMAT_NAME = 'VALUE_LINE';
3693  ***      0                                               foreach $value ( keys %{ $ag_pl->{$field} } ) {
      ***      0                                      
3694  ***      0                                                  $count       = $ag_pl->{$field}->{$value}->{count};
3695  ***      0                                                  $total_time  = $ag_pl->{$field}->{$value}->{time};
3696  ***      0                                                  write;
3697                                                           }
3698                                                        }
3699                                                     }
3700                                                     else {
3701  ***      0                                            print "   $ag_pl\n";
3702                                                     }
3703                                                  
3704  ***      0                                         return;
3705                                                  }
3706                                                  
3707                                                  sub _d {
3708  ***      0                    0                    my ($package, undef, $line) = caller 0;
3709  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
3710  ***      0                                              map { defined $_ ? $_ : 'undef' }
3711                                                          @_;
3712  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3713                                                  }
3714                                                  
3715                                                  1;
3716                                                  
3717                                                  # ###########################################################################
3718                                                  # End MySQLInstanceReporter package
3719                                                  # ###########################################################################
3720                                                  
3721                                                  # ###########################################################################
3722                                                  # Daemon package 4565
3723                                                  # ###########################################################################
3724                                                  
3725                                                  package Daemon;
3726                                                  
3727           1                    1             8   use strict;
               1                                  2   
               1                                  7   
3728           1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  6   
3729                                                  
3730           1                    1             6   use POSIX qw(setsid);
               1                                  2   
               1                                  7   
3731           1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  4   
3732                                                  
3733           1                    1             8   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  7   
3734                                                  
3735                                                  sub new {
3736  ***      0                    0                    my ( $class, %args ) = @_;
3737  ***      0                                         foreach my $arg ( qw(o) ) {
3738  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
3739                                                     }
3740  ***      0                                         my $o = $args{o};
3741  ***      0      0                                  my $self = {
      ***             0                               
3742                                                        o        => $o,
3743                                                        log_file => $o->has('log') ? $o->get('log') : undef,
3744                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
3745                                                     };
3746                                                  
3747  ***      0                                         check_PID_file(undef, $self->{PID_file});
3748                                                  
3749  ***      0                                         MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
3750  ***      0                                         return bless $self, $class;
3751                                                  }
3752                                                  
3753                                                  sub daemonize {
3754  ***      0                    0                    my ( $self ) = @_;
3755                                                  
3756  ***      0                                         MKDEBUG && _d('About to fork and daemonize');
3757  ***      0      0                                  defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
3758  ***      0      0                                  if ( $pid ) {
3759  ***      0                                            MKDEBUG && _d('I am the parent and now I die');
3760  ***      0                                            exit;
3761                                                     }
3762                                                  
3763  ***      0                                         $self->{child} = 1;
3764                                                  
3765  ***      0      0                                  POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
3766  ***      0      0                                  chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
3767                                                  
3768  ***      0                                         $self->_make_PID_file();
3769                                                  
3770  ***      0                                         $OUTPUT_AUTOFLUSH = 1;
3771                                                  
3772  ***      0      0                                  if ( -t STDIN ) {
3773  ***      0                                            close STDIN;
3774  ***      0      0                                     open  STDIN, '/dev/null'
3775                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
3776                                                     }
3777                                                  
3778  ***      0      0                                  if ( $self->{log_file} ) {
3779  ***      0                                            close STDOUT;
3780  ***      0      0                                     open  STDOUT, '>>', $self->{log_file}
3781                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
3782                                                  
3783  ***      0                                            close STDERR;
3784  ***      0      0                                     open  STDERR, ">&STDOUT"
3785                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
3786                                                     }
3787                                                     else {
3788  ***      0      0                                     if ( -t STDOUT ) {
3789  ***      0                                               close STDOUT;
3790  ***      0      0                                        open  STDOUT, '>', '/dev/null'
3791                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
3792                                                        }
3793  ***      0      0                                     if ( -t STDERR ) {
3794  ***      0                                               close STDERR;
3795  ***      0      0                                        open  STDERR, '>', '/dev/null'
3796                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
3797                                                        }
3798                                                     }
3799                                                  
3800  ***      0                                         MKDEBUG && _d('I am the child and now I live daemonized');
3801  ***      0                                         return;
3802                                                  }
3803                                                  
3804                                                  sub check_PID_file {
3805  ***      0                    0                    my ( $self, $file ) = @_;
3806  ***      0      0                                  my $PID_file = $self ? $self->{PID_file} : $file;
3807  ***      0                                         MKDEBUG && _d('Checking PID file', $PID_file);
3808  ***      0      0      0                           if ( $PID_file && -f $PID_file ) {
3809  ***      0                                            my $pid;
3810  ***      0                                            eval { chomp($pid = `cat $PID_file`); };
      ***      0                                      
3811  ***      0      0                                     die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
3812  ***      0                                            MKDEBUG && _d('PID file exists; it contains PID', $pid);
3813  ***      0      0                                     if ( $pid ) {
3814  ***      0                                               my $pid_is_alive = kill 0, $pid;
3815  ***      0      0                                        if ( $pid_is_alive ) {
3816  ***      0                                                  die "The PID file $PID_file already exists "
3817                                                                 . " and the PID that it contains, $pid, is running";
3818                                                           }
3819                                                           else {
3820  ***      0                                                  warn "Overwriting PID file $PID_file because the PID that it "
3821                                                                 . "contains, $pid, is not running";
3822                                                           }
3823                                                        }
3824                                                        else {
3825  ***      0                                               die "The PID file $PID_file already exists but it does not "
3826                                                              . "contain a PID";
3827                                                        }
3828                                                     }
3829                                                     else {
3830  ***      0                                            MKDEBUG && _d('No PID file');
3831                                                     }
3832  ***      0                                         return;
3833                                                  }
3834                                                  
3835                                                  sub make_PID_file {
3836  ***      0                    0                    my ( $self ) = @_;
3837  ***      0      0                                  if ( exists $self->{child} ) {
3838  ***      0                                            die "Do not call Daemon::make_PID_file() for daemonized scripts";
3839                                                     }
3840  ***      0                                         $self->_make_PID_file();
3841  ***      0                                         $self->{rm_PID_file} = 1;
3842  ***      0                                         return;
3843                                                  }
3844                                                  
3845                                                  sub _make_PID_file {
3846  ***      0                    0                    my ( $self ) = @_;
3847                                                  
3848  ***      0                                         my $PID_file = $self->{PID_file};
3849  ***      0      0                                  if ( !$PID_file ) {
3850  ***      0                                            MKDEBUG && _d('No PID file to create');
3851  ***      0                                            return;
3852                                                     }
3853                                                  
3854  ***      0                                         $self->check_PID_file();
3855                                                  
3856  ***      0      0                                  open my $PID_FH, '>', $PID_file
3857                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
3858  ***      0      0                                  print $PID_FH $PID
3859                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
3860  ***      0      0                                  close $PID_FH
3861                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
3862                                                  
3863  ***      0                                         MKDEBUG && _d('Created PID file:', $self->{PID_file});
3864  ***      0                                         return;
3865                                                  }
3866                                                  
3867                                                  sub _remove_PID_file {
3868  ***      0                    0                    my ( $self ) = @_;
3869  ***      0      0      0                           if ( $self->{PID_file} && -f $self->{PID_file} ) {
3870  ***      0      0                                     unlink $self->{PID_file}
3871                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
3872  ***      0                                            MKDEBUG && _d('Removed PID file');
3873                                                     }
3874                                                     else {
3875  ***      0                                            MKDEBUG && _d('No PID to remove');
3876                                                     }
3877  ***      0                                         return;
3878                                                  }
3879                                                  
3880                                                  sub DESTROY {
3881  ***      0                    0                    my ( $self ) = @_;
3882  ***      0      0      0                           $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
3883  ***      0                                         return;
3884                                                  }
3885                                                  
3886                                                  sub _d {
3887  ***      0                    0                    my ($package, undef, $line) = caller 0;
3888  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
3889  ***      0                                              map { defined $_ ? $_ : 'undef' }
3890                                                          @_;
3891  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3892                                                  }
3893                                                  
3894                                                  1;
3895                                                  
3896                                                  # ###########################################################################
3897                                                  # End Daemon package
3898                                                  # ###########################################################################
3899                                                  
3900                                                  # ###########################################################################
3901                                                  # This is a combination of modules and programs in one -- a runnable module.
3902                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
3903                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
3904                                                  #
3905                                                  # Check at the end of this package for the call to main() which actually runs
3906                                                  # the program.
3907                                                  # ###########################################################################
3908                                                  package mk_audit;
3909                                                  
3910           1                    1             7   use English qw(-no_match_vars);
               1                                  2   
               1                                  5   
3911                                                  
3912           1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                 10   
3913                                                  
3914                                                  sub main {
3915  ***      0                    0                    @ARGV = @_;  # set global ARGV for this package
3916                                                  
3917                                                     # #########################################################################
3918                                                     # Get configuration information.
3919                                                     # #########################################################################
3920  ***      0                                         my $dp = new DSNParser(); 
3921  ***      0                                         my $o  = new OptionParser(
3922                                                        description => 'inspects, analyzes and reports on a MySQL server.',
3923                                                     );
3924  ***      0                                         $o->get_specs();
3925  ***      0                                         $o->get_opts();
3926                                                  
3927                                                     # --host doesn't work because MySQLInstance insists on doing all the work.
3928                                                     # That is, we can't tell it "just use this --host".  mk-audit is due for
3929                                                     # retirment so this limitation will remain.
3930  ***      0      0                                  die "Sorry, --host is not implemented yet" if $o->got('host');
3931                                                  
3932  ***      0                                         $dp->prop('set-vars', $o->get('set-vars'));
3933                                                  
3934  ***      0                                         $o->usage_or_errors();
3935                                                  
3936  ***      0      0                                  if ( $o->get('ask-pass') ) {
3937  ***      0                                            $o->set('password', OptionParser::prompt_noecho("Enter password: "));
3938                                                     }
3939                                                  
3940                                                     # ########################################################################
3941                                                     # If --pid, check it first since we'll die if it already exits.
3942                                                     # ########################################################################
3943  ***      0                                         my $daemon;
3944  ***      0      0                                  if ( $o->get('pid') ) {
3945                                                        # We're not daemoninzing, it just handles PID stuff.  Keep $daemon
3946                                                        # in the the scope of main() because when it's destroyed it automatically
3947                                                        # removes the PID file.
3948  ***      0                                            $daemon = new Daemon(o=>$o);
3949  ***      0                                            $daemon->make_PID_file();
3950                                                     }
3951                                                  
3952                                                     # #########################################################################
3953                                                     # Get and report server specs.
3954                                                     # #########################################################################
3955  ***      0                                         my $server_specs = ServerSpecs::server_specs();
3956  ***      0                                         report_server_specs($server_specs);
3957                                                  
3958                                                     # #########################################################################
3959                                                     # Find and report all MySQL instances.
3960                                                     # #########################################################################
3961  ***      0                                         my $n           = 0; # instance number
3962  ***      0                                         my $mi_reporter = new MySQLInstanceReporter();
3963  ***      0                                         my $vp          = new VersionParser;
3964  ***      0                                         my $du          = new MySQLDump(cache => 0);
3965  ***      0                                         my $q           = new Quoter;
3966  ***      0                                         my $tp          = new TableParser;
3967  ***      0                                         my $apl         = new AggregateProcesslist();
3968  ***      0                                         my $gr          = new Grants();
3969  ***      0                                         my $sd          = new SchemaDiscover(du=>$du, q=>$q, tp=>$tp, vp=>$vp);
3970                                                  
3971                                                     # This sub does the actual work.  It's called below, either in a foreach()
3972                                                     # loop or once if a specific --host was given.  This sub must be declared
3973                                                     # here so that it's in the scope of all those objects above (vp, du, etc.)
3974                                                     my $audit_instance = sub {
3975  ***      0                    0                       my ( $mysqld_ps, $mi, $dbh ) = @_;
3976                                                  
3977                                                        # Get system variable and status values.
3978  ***      0                                            $mi->load_sys_vars($dbh);
3979  ***      0                                            $mi->load_status_vals($dbh);
3980                                                  
3981                                                        # Get schema info.
3982  ***      0                                            my $schema = $sd->discover($dbh);
3983                                                  
3984                                                        # Get aggregated processlist.
3985  ***      0                                            my $aggregated_proclist;
3986  ***      0      0                                     if ( $gr->have_priv($dbh, 'PROCESS') ) {
3987  ***      0                                               $aggregated_proclist = $apl->aggregate(
3988                                                              $dbh->selectall_arrayref('SHOW PROCESSLIST',{ Slice => {} }));
3989                                                        }
3990                                                        else {
3991  ***      0                                               $aggregated_proclist
3992                                                              = "Cannot report aggregated processlist because "
3993                                                              . "database user does not have PROCESS privilege.\n";
3994                                                        }
3995                                                  
3996                                                        # Check for problems and oddities.
3997  ***      0                                            my $ma = new MySQLAdvisor($mi, $schema);
3998                                                  
3999                                                        # Finally, report everything.
4000  ***      0                                            $mi_reporter->report(
4001                                                           ma        => $ma,
4002                                                           mi        => $mi,
4003                                                           n         => $n,
4004                                                           o         => $o,
4005                                                           ps        => $mysqld_ps,
4006                                                           schema    => $schema,
4007                                                           proclist  => $aggregated_proclist,
4008                                                        );
4009                                                  
4010  ***      0                                            return; 
4011  ***      0                                         };
4012                                                  
4013                                                  
4014                                                     # Audit every MySQL instance that we can find on the server
4015                                                     # by looking at ps output.
4016  ***      0                                         my $mysqld_procs = MySQLInstance::mysqld_processes();
4017                                                     INSTANCE:
4018  ***      0                                         foreach my $mysqld_ps ( @$mysqld_procs ) {
4019  ***      0                                            $n++;
4020                                                  
4021                                                        # Connect to instance.
4022  ***      0                                            my $mi           = new MySQLInstance( $mysqld_ps->{cmd} );
4023  ***      0                                            my $dsn          = $mi->get_DSN($o);
4024  ***      0                                            my $dsn_defaults = $dp->parse_options($o);
4025  ***      0                                            my $dbh;
4026  ***      0                                            eval {
4027  ***      0                                               $dbh = $dp->get_dbh($dp->get_cxn_params($dsn, $dsn_defaults));
4028                                                        };
4029  ***      0      0                                     if ( $EVAL_ERROR ) {
4030  ***      0                                               print "Cannot connect to ", $dp->as_string($dsn), ": $EVAL_ERROR\n";
4031  ***      0                                               next INSTANCE;
4032                                                        }
4033                                                  
4034  ***      0                                            $audit_instance->($mysqld_ps, $mi, $dbh);
4035                                                        
4036  ***      0                                            $dbh->disconnect();
4037                                                     }
4038                                                  
4039  ***      0      0                                  if ( $n == 0 ) {
4040  ***      0                                            print "No instances of MySQL were found running on this server.\n";
4041                                                     }
4042                                                  
4043                                                  
4044  ***      0                                         return 0;
4045                                                  }
4046                                                  
4047                                                  # #############################################################################
4048                                                  # Subroutines.
4049                                                  # #############################################################################
4050                                                  
4051                                                  sub report_server_specs {
4052  ***      0                    0                    my ( $server ) = @_;
4053                                                  
4054                                                  format SERVER_1 =
4055                                                  __________________________________________________________________ Server Specs
4056                                                  OS: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Architecture: @<-bit
4057                                                  "$server->{os}->{name} $server->{os}->{version}", $server->{os}->{regsize}
4058                                                  
4059                                                  CPU: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Architecture: @<-bit
4060                                                  $server->{cpu}->{model}, $server->{cpu}->{regsize}
4061                                                     Speed: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
4062                                                  $server->{cpu}->{speed}
4063                                                     Cache: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
4064                                                  $server->{cpu}->{cache}
4065                                                     Count: @<<<<<<<<<<<<
4066                                                  $server->{cpu}->{count}
4067                                                     Cores: @<<<<<<<<<<<<
4068                                                  $server->{cpu}->{cores}
4069                                                  
4070                                                  Memory: used @<<<<<< of @<<<<<< total  (@<<<<<< free)
4071                                                  $server->{memory}->{used}, $server->{memory}->{total}, $server->{memory}->{free}
4072                                                     Buffers: @<<<<<<<<<<
4073                                                  $server->{memory}->{buffers}
4074                                                     Cached:  @<<<<<<<<<<
4075                                                  $server->{memory}->{cached}
4076                                                     Shared:  @<<<<<<<<<<
4077                                                  $server->{memory}->{shared}
4078                                                     Slots: @*
4079                                                  { local $LIST_SEPARATOR = "\n"; "@{$server->{memory}->{slots}}" }
4080                                                  
4081                                                  Storage:
4082                                                  .
4083                                                  
4084                                                  format SERVER_2 =
4085                                                     LVM volume groups: @*
4086                                                  $server->{storage}->{vgs}
4087                                                     df: @*
4088                                                  $server->{storage}->{df}
4089                                                  
4090                                                  libc: @<<<<<<<<<<<<<<<<<
4091                                                  $server->{sw}->{libc}->{ver}
4092                                                     Compiled by: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
4093                                                  $server->{sw}->{libc}->{compiled_by}
4094                                                     Threading:   @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
4095                                                  $server->{sw}->{libc}->{threading}
4096                                                     GNU libpthread version: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
4097                                                  $server->{sw}->{libc}->{GNU_LIBPTHREAD_VERSION}
4098                                                  
4099                                                  PROBLEMS _________________________________________________________________
4100                                                  .
4101                                                  
4102                                                     # Print SERVER report
4103  ***      0                                         $FORMAT_NAME = 'SERVER_1';
4104  ***      0                                         write;
4105                                                  
4106                                                     # Print RAID information
4107                                                     # Apparently, the @* field has a 17 line limit
4108                                                     # hence we must print this stuff manually.
4109  ***      0                                         my $raid_ctrls   = $server->{storage}->{raid};
4110  ***      0                                         my $n_raid_ctrls = scalar keys %$raid_ctrls;
4111  ***      0      0                                  if ( $n_raid_ctrls == 0 ) {
4112  ***      0                                            print "   No RAID controllers detected.\n";
4113                                                     }
4114                                                     else {
4115  ***      0                                            print "   $n_raid_ctrls RAID controllers  detected:\n\n";
4116  ***      0                                            while ( my ($raid_name, $raid_info) = each %$raid_ctrls ) {
4117  ***      0                                               print "$raid_name\n"
4118                                                              . ('#' x (length $raid_name)) . "\n"
4119                                                              . "$raid_info\n";
4120                                                        }
4121  ***      0                                            print "########## End of RAID controllers ##########\n\n";
4122                                                     }
4123                                                  
4124  ***      0                                         $FORMAT_NAME = 'SERVER_2';
4125  ***      0                                         write;
4126  ***      0                                         foreach my $problem ( @{ $server->{problems} } ) {
      ***      0                                      
4127  ***      0                                            print "\t- $problem\n";
4128                                                     }
4129                                                  
4130  ***      0                                         return;
4131                                                  }
4132                                                  
4133                                                  sub _d {
4134  ***      0                    0                    my ($package, undef, $line) = caller 0;
4135  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
4136  ***      0                                              map { defined $_ ? $_ : 'undef' }
4137                                                          @_;
4138  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4139                                                  }
4140                                                  
4141                                                  # ############################################################################
4142                                                  # Run the program.
4143                                                  # ############################################################################
4144                                                  if ( !caller ) { exit main(@ARGV); }
4145                                                  
4146                                                  1; # Because this is a module as well as a script.
4147                                                  
4148                                                  # ############################################################################
4149                                                  # Documentation.
4150                                                  # ############################################################################
4151                                                  
4152                                                  =pod
4153                                                  
4154                                                  =head1 NAME
4155                                                  
4156                                                  mk-audit - Analyze, summarize and report on MySQL config, schema and operation
4157                                                  
4158                                                  =head1 SYNOPSIS
4159                                                  
4160                                                     mk-audit
4161                                                  
4162                                                  =head1 RISKS
4163                                                  
4164                                                  The following section is included to inform users about the potential risks,
4165                                                  whether known or unknown, of using this tool.  The two main categories of risks
4166                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
4167                                                  tools) and those created by bugs.
4168                                                  
4169                                                  mk-audit only reads information so there is little to no risk.  At worst,
4170                                                  it may cause slight server load if there are thousands of databases and tables
4171                                                  to audit.
4172                                                  
4173                                                  At the time of this release, we know of no bugs that could cause serious harm to
4174                                                  users.
4175                                                  
4176                                                  The authoritative source for updated information is always the online issue
4177                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
4178                                                  see a list of such issues at the following URL:
4179                                                  L<http://www.maatkit.org/bugs/mk-audit>.
4180                                                  
4181                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
4182                                                  
4183                                                  =head1 DESCRIPTION
4184                                                  
4185                                                  mk-audit summarizes the information a consultant may find useful when analyzing
4186                                                  a MySQL server.  It prints out a report that contains the following information:
4187                                                  
4188                                                  =head2 OPERATING SYSTEM
4189                                                  
4190                                                  The operating system report shows information about the operating system and
4191                                                  hardware.  The information includes the operating system version and flavor, and
4192                                                  information on CPU, memory and disks as well as some core system libraries.
4193                                                  
4194                                                  This is currently very specific to GNU/Linux.
4195                                                  
4196                                                  =head2 MYSQL
4197                                                  
4198                                                  For each MySQL instance detected on the system, mk-audit reports some
4199                                                  information on the server and the data in it.
4200                                                  
4201                                                  =head1 OPTIONS
4202                                                  
4203                                                  =over
4204                                                  
4205                                                  =item --ask-pass
4206                                                  
4207                                                  Prompt for a password when connecting to MySQL.
4208                                                  
4209                                                  =item --charset
4210                                                  
4211                                                  short form: -A; type: string
4212                                                  
4213                                                  Default character set.  If the value is utf8, sets Perl's binmode on
4214                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and runs SET
4215                                                  NAMES UTF8 after connecting to MySQL.  Any other value sets binmode on STDOUT
4216                                                  without the utf8 layer, and runs SET NAMES after connecting to MySQL.
4217                                                  
4218                                                  =item --config
4219                                                  
4220                                                  type: Array
4221                                                  
4222                                                  Read this comma-separated list of config files; if specified, this must be the
4223                                                  first option on the command line.
4224                                                  
4225                                                  =item --defaults-file
4226                                                  
4227                                                  short form: -F; type: string
4228                                                  
4229                                                  Only read mysql options from the given file.  You must give an absolute
4230                                                  pathname.
4231                                                  
4232                                                  =item --help
4233                                                  
4234                                                  Show help and exit.
4235                                                  
4236                                                  =item --host
4237                                                  
4238                                                  short form: -h; type: string
4239                                                  
4240                                                  Connect to host.
4241                                                  
4242                                                  TODO: Not implemented yet.
4243                                                  
4244                                                  =item --password
4245                                                  
4246                                                  short form: -p; type: string
4247                                                  
4248                                                  Password to use when connecting.
4249                                                  
4250                                                  =item --pid
4251                                                  
4252                                                  type: string
4253                                                  
4254                                                  Create the given PID file.  The file contains the process ID of the script.
4255                                                  The PID file is removed when the script exits.  Before starting, the script
4256                                                  checks if the PID file already exists.  If it does not, then the script creates
4257                                                  and writes its own PID to it.  If it does, then the script checks the following:
4258                                                  if the file contains a PID and a process is running with that PID, then
4259                                                  the script dies; or, if there is no process running with that PID, then the
4260                                                  script overwrites the file with its own PID and starts; else, if the file
4261                                                  contains no PID, then the script dies.
4262                                                  
4263                                                  =item --port
4264                                                  
4265                                                  short form: -P; type: int
4266                                                  
4267                                                  Port number to use for connection.
4268                                                  
4269                                                  =item --set-vars
4270                                                  
4271                                                  type: string; default: wait_timeout=10000
4272                                                  
4273                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this string
4274                                                  will be appended to SET and executed.
4275                                                  
4276                                                  =item --socket
4277                                                  
4278                                                  short form: -S; type: string
4279                                                  
4280                                                  Socket file to use for connection.
4281                                                  
4282                                                  =item --top
4283                                                  
4284                                                  type: int; default: 5
4285                                                  
4286                                                  Show top N largest databases and tables.
4287                                                  
4288                                                  =item --user
4289                                                  
4290                                                  short form: -u; type: string
4291                                                  
4292                                                  User for login if not current user.
4293                                                  
4294                                                  =item --version
4295                                                  
4296                                                  Show version and exit.
4297                                                  
4298                                                  =back
4299                                                  
4300                                                  =head1 DOWNLOADING
4301                                                  
4302                                                  You can download Maatkit from Google Code at
4303                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
4304                                                  easily with a command like the following:
4305                                                  
4306                                                     wget http://www.maatkit.org/get/toolname
4307                                                     or
4308                                                     wget http://www.maatkit.org/trunk/toolname
4309                                                  
4310                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
4311                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
4312                                                  needed.  The first URL gets the latest released version of the tool, and the
4313                                                  second gets the latest trunk code from Subversion.
4314                                                  
4315                                                  =head1 ENVIRONMENT
4316                                                  
4317                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
4318                                                  the Maatkit tools:
4319                                                  
4320                                                     MKDEBUG=1 mk-....
4321                                                  
4322                                                  =head1 SYSTEM REQUIREMENTS
4323                                                  
4324                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
4325                                                  installed in any reasonably new version of Perl.
4326                                                  
4327                                                  =head1 BUGS
4328                                                  
4329                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-audit>.
4330                                                  
4331                                                  Please use Google Code Issues and Groups to report bugs or request support:
4332                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
4333                                                  discuss Maatkit.
4334                                                  
4335                                                  Please include the complete command-line used to reproduce the problem you are
4336                                                  seeing, the version of all MySQL servers involved, the complete output of the
4337                                                  tool when run with L<"--version">, and if possible, debugging output produced by
4338                                                  running with the C<MKDEBUG=1> environment variable.
4339                                                  
4340                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
4341                                                  
4342                                                  This program is copyright 2008-@CURRENTYEAR@ Percona Inc.
4343                                                  Feedback and improvements are welcome.
4344                                                  
4345                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
4346                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
4347                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
4348                                                  
4349                                                  This program is free software; you can redistribute it and/or modify it under
4350                                                  the terms of the GNU General Public License as published by the Free Software
4351                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
4352                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
4353                                                  licenses.
4354                                                  
4355                                                  You should have received a copy of the GNU General Public License along with
4356                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
4357                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
4358                                                  
4359                                                  =head1 AUTHOR
4360                                                  
4361                                                  Daniel Nichter, Baron Schwartz
4362                                                  
4363                                                  =head1 ABOUT MAATKIT
4364                                                  
4365                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
4366                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
4367                                                  code contributors.  Both are employed by Percona.  Financial support for
4368                                                  Maatkit development is primarily provided by Percona and its clients. 
4369                                                  
4370                                                  =head1 VERSION
4371                                                  
4372                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5352 $.
4373                                                  
4374                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
67    ***      0      0      0   unless defined $args{'cache'}
75    ***      0      0      0   if ($what eq 'table') { }
      ***      0      0      0   elsif ($what eq 'triggers') { }
      ***      0      0      0   elsif ($what eq 'view') { }
77    ***      0      0      0   unless $ddl
78    ***      0      0      0   if ($$ddl[0] eq 'table') { }
92    ***      0      0      0   if ($trgs and @$trgs) { }
95    ***      0      0      0   if ($$trg{'sql_mode'})
99    ***      0      0      0   if ($$trg{'definer'})
131   ***      0      0      0   if (not $new)
138   ***      0      0      0   if ($curr and $new and $curr eq $new)
150   ***      0      0      0   if (not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl})
163   ***      0      0      0   if ($EVAL_ERROR)
173   ***      0      0      0   if ($key) { }
189   ***      0      0      0   if (not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl})
219   ***      0      0      0   if (not $$self{'cache'} or not $$self{'triggers'}{$db})
232   ***      0      0      0   if ($sth->rows)
245   ***      0      0      0   if ($tbl)
253   ***      0      0      0   if (not $$self{'cache'} or not $$self{'databases'} or $like)
256   ***      0      0      0   if ($like)
264   ***      0      0      0   unless $like
272   ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_status'}{$db} or $like)
275   ***      0      0      0   if ($like)
290   ***      0      0      0   unless $like
298   ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_list'}{$db} or $like)
301   ***      0      0      0   if ($like)
309   ***      0      0      0   ($$_[1] || '') eq 'VIEW' ? :
316   ***      0      0      0   unless $like
324   ***      0      0      0   defined $_ ? :
364   ***      0      0      0   unless $args{$arg}
370   ***      0      0      0   exists $args{'strict'} ? :
413   ***      0      0      0   unless open my $fh, '<', $file
433   ***      0      0      0   unless $para =~ /^=head1 OPTIONS/
438   ***      0      0      0   if $para =~ /^=over/
446   ***      0      0      0   unless $para
449   ***      0      0      0   if (my($option) = $para =~ /^=item --(.*)/)
456   ***      0      0      0   if ($para =~ /: /) { }
460   ***      0      0      0   unless $attributes{$attrib}
464   ***      0      0      0   if ($attribs{'short form'})
480   ***      0      0      0   if $para =~ /^=item/
482   ***      0      0      0   if (my($base_option) = $option =~ /^\[no\](.*)/)
487   ***      0      0      0   $attribs{'short form'} ? :
      ***      0      0      0   $attribs{'negatable'} ? :
      ***      0      0      0   $attribs{'cumulative'} ? :
      ***      0      0      0   $attribs{'type'} ? :
      ***      0      0      0   $attribs{'default'} ? :
      ***      0      0      0   $attribs{'group'} ? :
499   ***      0      0      0   unless $para
502   ***      0      0      0   if ($para =~ /^=head1/)
506   ***      0      0      0   if $para =~ /^=item --/
510   ***      0      0      0   unless @specs
521   ***      0      0      0   if (ref $opt) { }
526   ***      0      0      0   if (not $long)
531   ***      0      0      0   if exists $$self{'opts'}{$long}
534   ***      0      0      0   if (length $long == 1)
539   ***      0      0      0   if ($short) { }
540   ***      0      0      0   if exists $$self{'short_opts'}{$short}
549   ***      0      0      0   $$opt{'spec'} =~ /!/ ? :
550   ***      0      0      0   $$opt{'spec'} =~ /\+/ ? :
551   ***      0      0      0   $$opt{'desc'} =~ /required/ ? :
563   ***      0      0      0   if ($type and $type eq 'd' and not $$self{'dp'})
568   ***      0      0      0   if $type and $type =~ /[HhAadzm]/
570   ***      0      0      0   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
571   ***      0      0      0   defined $def ? :
575   ***      0      0      0   if ($long eq 'config')
579   ***      0      0      0   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
592   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
597   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
602   ***      0      0      0   if ($opt =~ /default to/)
607   ***      0      0      0   if ($opt =~ /restricted to option groups/)
617   ***      0      0      0   unless $rule_ok
634   ***      0      0      0   unless exists $$self{'opts'}{$long}
658   ***      0      0      0   unless exists $$self{'opts'}{$long}
678   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***      0      0      0   exists $$self{'opts'}{$opt} ? :
683   ***      0      0      0   if ($$opt{'is_cumulative'}) { }
698   ***      0      0      0   $$self{'opts'}{$long}{'is_cumulative'} ? :
      ***      0      0      0   exists $$self{'defaults'}{$long} ? :
707   ***      0      0      0   if (@ARGV and $ARGV[0] eq '--config')
711   ***      0      0      0   if ($self->has('config'))
717   ***      0      0      0   if ($EVAL_ERROR)
718   ***      0      0      0   $self->got('config') ? :
733   ***      0      0      0   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
736   ***      0      0      0   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
737   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
743   ***      0      0      0   if (@ARGV and $$self{'strict'})
749   ***      0      0      0   if (@set > 1)
760   ***      0      0      0   if (@set == 0)
770   ***      0      0      0   if ($$opt{'got'}) { }
      ***      0      0      0   elsif ($$opt{'is_required'}) { }
771   ***      0      0      0   if (exists $$self{'disables'}{$long})
778   ***      0      0      0   if (exists $$self{'allowed_groups'}{$long})
790   ***      0      0      0   if $restricted_opt eq $long
791   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
796   ***      0      0      0   if (@restricted_opts)
798   ***      0      0      0   if (@restricted_opts == 1) { }
827   ***      0      0      0   unless $opt and $$opt{'type'}
830   ***      0      0      0   if ($val and $$opt{'type'} eq 'm') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'd') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'z') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
833   ***      0      0      0   if (not $suffix)
839   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
840   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
855   ***      0      0      0   if ($from_key)
866   ***      0      0      0   if (defined $num) { }
867   ***      0      0      0   if ($factor)
894   ***      0      0      0   length $opt == 1 ? :
895   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
902   ***      0      0      0   length $opt == 1 ? :
903   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
910   ***      0      0      0   length $opt == 1 ? :
911   ***      0      0      0   defined $long ? :
916   ***      0      0      0   length $opt == 1 ? :
917   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
951   ***      0      0      0   if ($$self{'opts'}{'help'}{'got'}) { }
      ***      0      0      0   elsif (scalar @{$$self{'errors'};}) { }
952   ***      0      0      0   unless print $self->print_usage
956   ***      0      0      0   unless print $self->print_errors
965   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
974   ***      0      0      0   unless $$self{'got_opts'}
977   ***      0      0      0   $$_{'is_negatable'} ? :
981   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
997   ***      0      0      0   $group eq 'default' ? :
1003  ***      0      0      0   $$opt{'is_negatable'} ? :
1006  ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
1015  ***      0      0      0   if ($short) { }
1024  ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
1028  ***      0      0      0   if ($$self{'dp'})
1036  ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
1048  ***      0      0      0   if ref $_[0] eq 'OptionParser'
1051  ***      0      0      0   unless print $prompt
1059  ***      0      0      0   unless print "\n"
1062  ***      0      0      0   if ($EVAL_ERROR)
1084  ***      0      0      0   unless open my $fh, '<', $filename
1092  ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
1095  ***      0      0      0   if ($line eq '--')
1100  ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
1118  ***      0      0      0   unless open my $fh, '<', $file
1122  ***      0      0      0   unless $para =~ /^=pod$/m
1126  ***      0      0      0   unless $para =~ /$regex/
1131  ***      0      0      0   unless close $fh
1145  ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
1160  ***      0      0      0   defined $_ ? :
1191  ***      0      0      0   unless $ddl
1192  ***      0      0      0   if (ref $ddl eq 'ARRAY')
1193  ***      0      0      0   if (lc $$ddl[0] eq 'table') { }
1203  ***      0      0      0   if (not $ddl =~ /CREATE (?:TEMPORARY )?TABLE `/)
1224  ***      0      0      0   unless $type
1226  ***      0      0      0   if ($type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/)
1230  ***      0      0      0   if (not $def =~ /NOT NULL/)
1234  ***      0      0      0   $def =~ /AUTO_INCREMENT/i ? :
1264  ***      0      0      0   unless ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
1278  ***      0      0      0   if ($index)
1281  ***      0      0      0   if (not $best)
1282  ***      0      0      0   if ($index) { }
1295  ***      0      0      0   unless $where
1301  ***      0      0      0   if ($$expl{'possible_keys'}) { }
1305  ***      0      0      0   if ($$expl{'key'})
1331  ***      0      0      0   if ($can_insert) { }
1360  ***      0      0      0   if $key =~ /FOREIGN/
1364  ***      0      0      0   if (not $engine =~ /MEMORY|HEAP/)
1371  ***      0      0      0   if ($$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i)
1378  ***      0      0      0   $key =~ /PRIMARY|UNIQUE/ ? :
1401  ***      0      0      0   if ($engine =~ /InnoDB/i and not $clustered_key)
1403  ***      0      0      0   if ($$this_key{'name'} eq 'PRIMARY') { }
      ***      0      0      0   elsif ($$this_key{'is_unique'} and not $$this_key{'is_nullable'}) { }
1427  ***      0      0      0   if (not $parent =~ /\./ and $$opts{'database'})
1452  ***      0      0      0   defined $_ ? :
1537  ***     50      0      3   if (@_ > 2)
1546  ***     50      0      1   if (not $dsn)
1558  ***     50      4      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1570  ***     50      0      8   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1576         100      4      4   if (not defined $final_props{$key})
1583  ***     50      0      4   unless exists $opts{$key}
1586  ***     50      0      1   if (my $required = $self->prop('required'))
1588  ***      0      0      0   unless $final_props{$key}
1597  ***      0      0      0   unless ref $o eq 'OptionParser'
1600  ***      0      0      0   if $o->has($_)
1610  ***      0      0      0   unless ref $dsn
1611  ***      0      0      0   $_ eq 'p' ? :
1612  ***      0      0      0   if defined $$dsn{$_}
1625  ***      0      0      0   $opts{$key}{'copy'} ? :
1639  ***     50      0      1   if ($driver eq 'Pg') { }
1671  ***     50      0      1   $cxn_string =~ /charset=utf8/ ? :
1683  ***     50      0      1   if ($EVAL_ERROR)
1702  ***     50      1      0   if ($cxn_string =~ /mysql/i)
1710  ***     50      0      1   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1715  ***      0      0      0   if ($charset eq 'utf8') { }
1716  ***      0      0      0   unless binmode STDOUT, ':utf8'
1720  ***      0      0      0   unless binmode STDOUT
1724  ***     50      0      1   if ($self->prop('set-vars'))
1731  ***     50      0      1   if (not $dbh and $EVAL_ERROR)
1733  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1746  ***      0      0      0   if (not $tries)
1768  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1785  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1795  ***      0      0      0   unless $dsn_1
1796  ***      0      0      0   unless $dsn_2
1800  ***      0      0      0   if ($args{'overwrite'}) { }
1801  ***      0      0      0   defined $$dsn_1{$key} ? :
1804  ***      0      0      0   defined $$dsn_2{$key} ? :
1813  ***      0      0      0   defined $_ ? :
1851  ***      0      0      0   if (not $$self{$dbh})
1855  ***      0      0      0   $$self{$dbh} ge $self->parse($target) ? :
1862  ***      0      0      0   defined $_ ? :
1903  ***      0      0      0   if (defined $_) { }
1905  ***      0      0      0   $_ eq '' || $_ =~ /^0|\D/ ? :
1918  ***      0      0      0   if (not $tbl)
1950  ***      0      0      0   `file /bin/ls` =~ /64-bit/ ? :
1954  ***      0      0      0   if (-f '/lib/libc.so.6') { }
1957  ***      0      0      0   $stuff =~ /linuxthreads-\d/ ? :
      ***      0      0      0   $stuff =~ /Native POSIX/ ? :
1975  ***      0      0      0   if (-f '/proc/cpuinfo') { }
1985  ***      0      0      0   $info =~ /flags.*\blm\b/ ? :
1993  ***      0      0      0   if (chomp(my $mem = `free -b`))
1997  ***      0      0      0   if $key eq 'Mem'
2005  ***      0      0      0   if (chomp(my $df = `df -hT`))
2013  ***      0      0      0   if (-f $vgs_cmd) { }
2025  ***      0      0      0   if $server{'os'}{'swappiness'} != 60
2039  ***      0      0      0   if (chomp(my $dmesg = `dmesg | grep '^scsi[0-9]'`))
2040  ***      0      0      0   if (my($raid) = $dmesg =~ /: (.*MegaRaid)/im)
2043  ***      0      0      0   if (my($raid) = $dmesg =~ /: (aacraid)/m)
2046  ***      0      0      0   if (my($raid) = $dmesg =~ /: (3ware [0-9]+ Storage Controller)/m)
2056  ***      0      0      0   if ($megarc)
2057  ***      0      0      0   if ($megarc =~ /No MegaRAID Found/i) { }
2058  ***      0      0      0   if (-f '/opt/MegaRAID/MegaCli/MegaCli') { }
      ***      0      0      0   elsif (-f '/opt/MegaRAID/MegaCli/MegaCli64') { }
2075  ***      0      0      0   if ($megarc) { }
2076  ***      0      0      0   $megarc =~ /^(Product Name.*\n)/m ? :
2077  ***      0      0      0   $megarc =~ /^(BBU.*\n)/m ? :
2078  ***      0      0      0   $megarc =~ /^(Battery Warning.*\n)/m ? :
2079  ***      0      0      0   $megarc =~ /^(Alarm.*\n)/m ? :
2080  ***      0      0      0   $megarc =~ /(Device Present.*?\n)\s+Supported/ms ? :
2081  ***      0      0      0   $megarc =~ /(Battery state.*?\n)isSOHGood/ms ? :
2095  ***      0      0      0   if (-x '/usr/StorMan/arcconf') { }
2101  ***      0      0      0   if ($arcconf) { }
2102  ***      0      0      0   $arcconf =~ /^(\s*Controller Model.*\n)/m ? :
2103  ***      0      0      0   $arcconf =~ /^(\s*Controller Status.*\n)/m ? :
2104  ***      0      0      0   $arcconf =~ /^(\s*Installed memory.*\n)/m ? :
2105  ***      0      0      0   $arcconf =~ /^(\s*Temperature.*\n)/m ? :
2106  ***      0      0      0   $arcconf =~ /^(\s*Defunct disk drive count.*\n)/m ? :
2107  ***      0      0      0   $arcconf =~ m[^(\s*Logical devices/Failed \(error\)/Degraded.*\n)]m ? :
2108  ***      0      0      0   $arcconf =~ /^(\s*Write-cache mode.*\n)/m ? :
2109  ***      0      0      0   $arcconf =~ /^(\s*Write-cache setting.*\n)/m ? :
2110  ***      0      0      0   $arcconf =~ /^(\s*Controller Battery Information.*?\n\n)/ms ? :
2123  ***      0      0      0   if ($tw_cli) { }
2124  ***      0      0      0   $tw_cli =~ m[^/c0\s*(Model.*\n)]m ? :
2125  ***      0      0      0   $tw_cli =~ m[^/c0\s*(Memory Installed.*\n)]m ? :
2126  ***      0      0      0   $tw_cli =~ /\n(\n.*)/ms ? :
2192  ***      0      0      0   if (chomp(my $ipv4_files = `ls -1p /proc/sys/net/ipv4/`))
2194  ***      0      0      0   if not exists $ipv4_defaults{$ipv4_file}
2197  ***      0      0      0   if ($ipv4_defaults{$ipv4_file} ne $val)
2228  ***      0      0      0   if (not -f $sysctl_conf)
2233  ***      0      0      0   if (open my $SYSCTL, '<', $sysctl_conf) { }
2236  ***      0      0      0   if $line =~ /^#/
2237  ***      0      0      0   unless $line =~ /\s*net.ipv4.(\w+)\s*=\s*(\w+)/
2240  ***      0      0      0   if (exists $sysctl{$var} and undef)
2259  ***      0      0      0   !$retval ? :
2265  ***      0      0      0   if (_can_run('cat /etc/*release')) { }
      ***      0      0      0   elsif (-r '/etc/debian_version') { }
2267  ***      0      0      0   if (my($desc) = $rel =~ /DISTRIB_DESCRIPTION="(.*)"/) { }
2288  ***      0      0      0   _can_run('dmidecode') ? :
2314  ***      0      0      0   if ($kb) { }
2321  ***      0      0      0   if $short =~ /^(.+)\.(00)$/o
2327  ***      0      0      0   defined $_ ? :
2419  ***      0      0      0   defined $ps_output ? :
2420  ***      0      0      0   if ($ps)
2426  ***      0      0      0   if (not $bin)
2431  ***      0      0      0   `file $bin` =~ /64-bit/ ? :
      ***      0      0      0   $ps =~ /logger/ ? :
2450  ***      0      0      0   unless $$self{'mysqld_binary'} = find_mysqld_binary_unix($cmd)
2494  ***      0      0      0   if ($retval != 0) { }
2499  ***      0      0      0   if (my $mysqld_output = `$cmd`) { }
2505  ***      0      0      0   if ($val and $val =~ /\(No/)
2526  ***      0      0      0   if (not exists $$self{'conf_sys_vars'}{$var})
2529  ***      0      0      0   if (not exists $$self{'online_sys_vars'}{$var})
2541  ***      0      0      0   defined $ddf ? :
2544  ***      0      0      0   if ($defaults_file and -f $defaults_file) { }
2564  ***      0      0      0   if (not $ddf_list)
2580  ***      0      0      0   if ($retval != 0)
2588  ***      0      0      0   if (not $defaults_file_op) { }
2592  ***      0      0      0   if (defined $dfo[1])
2602  ***      0      0      0   if (scalar @defaults_file_ops == 0)
2610  ***      0      0      0   if (my $my_print_defaults_output = `$cmd`)
2614  ***      0      0      0   if (defined $val and $val =~ /(\d+)([kKmMgGtT]?)/)
2615  ***      0      0      0   if ($2)
2649  ***      0      0      0   unless ref $o eq 'OptionParser'
2652  ***      0      0      0   $port ne 3306 ? :
      ***      0      0      0   $o->get('socket') ? :
2668  ***      0      0      0   if $can_be_duplicate{$var}
2669  ***      0      0      0   if $have_seen{$var}++ == 1
2679  ***      0      0      0   if (not defined $var or not defined $val)
2683  ***      0      0      0   if (exists $$self{'cmd_line_ops'}{$var})
2684  ***      0      0      0   if (not defined $$self{'cmd_line_ops'}{$var} and not defined $val or $$self{'cmd_line_ops'}{$var} ne $val)
2699  ***      0      0      0   if exists $ignore_sys_var{$var}
2700  ***      0      0      0   unless exists $$self{'online_sys_vars'}{$var}
2707  ***      0      0      0   if ($conf_val || $online_val and $conf_val ne $online_val)
2710  ***      0      0      0   if (exists $eq_for{$var})
2713  ***      0      0      0   if (exists $alias_for{$online_val})
2714  ***      0      0      0   if $conf_val eq $alias_for{$online_val}
2718  ***      0      0      0   if ($var_out_of_sync)
2738  ***      0      0      0   if (exists $eq_for{$var})
2746  ***      0      0      0   if $x eq $val1 || $x eq $val2 and $y eq $val1 || $y eq $val2
2752  ***      0      0      0   if not $x =~ m[/$]
2753  ***      0      0      0   if not $y =~ m[/$]
2759  ***      0      0      0   if $x and $x eq 'ON' and $y
2760  ***      0      0      0   if $y and $y eq 'ON' and $x
2766  ***      0      0      0   $conf_val eq '' ? :
2771  ***      0      0      0   $x == $y ? :
2776  ***      0      0      0   defined $_ ? :
2803  ***      0      0      0   unless $args{$arg}
2813  ***      0      0      0   unless $dbh
2829  ***      0      0      0   if exists $$dbs{'information_schema'}
2870  ***      0      0      0   if ($vp->version_ge($dbh, '5.0.0')) { }
2883  ***      0      0      0   unless $dbh
2904  ***      0      0      0   if ($EVAL_ERROR)
2919  ***      0      0      0   defined $_ ? :
3046  ***      0      0      0   if (defined $check_name) { }
3047  ***      0      0      0   if (exists $checks{$check_name}) { }
3048  ***      0      0      0   if (my $problem = $checks{$check_name}($$self{'sys_vars'}, $$self{'status_vals'}, $$self{'schema'}, $$self{'counts'}))
3061  ***      0      0      0   if (my $problem = $checks{$check_name}($$self{'sys_vars'}, $$self{'status_vals'}, $$self{'schema'}, $$self{'counts'}))
3074  ***      0      0      0   defined $_ ? :
3110  ***      0      0      0   if $field eq 'Id'
3111  ***      0      0      0   if $field eq 'Info'
3112  ***      0      0      0   if $field eq 'Time'
3115  ***      0      0      0   if not defined $val
3116  ***      0      0      0   if $field eq 'Command' or $field eq 'State'
3117  ***      0      0      0   if $field eq 'Host'
3120  ***      0      0      0   if $time eq 'NULL'
3133  ***      0      0      0   defined $_ ? :
3176  ***      0      0      0   if (not exists $check_for_priv{$priv})
3184  ***      0      0      0   defined $_ ? :
3232  ***      0      0      0   defined $args{'p_ms'} ? :
3233  ***      0      0      0   defined $args{'p_s'} ? :
3236  ***      0      0      0   if $t < 0
3238  ***      0      0      0   if $t =~ /e/
3242  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
3263  ***      0      0      0   $p ? :
3270  ***      0      0      0   unless $secs
3272  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
3277  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
3296  ***      0      0      0   defined $args{'p'} ? :
3297  ***      0      0      0   defined $args{'d'} ? :
3304  ***      0      0      0   $num =~ /\./ || $n ? :
3323  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^$mysql_ts$/)
3326  ***      0      0      0   defined $f ? :
      ***      0      0      0   defined $f ? :
3335  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s) = $val =~ /^$proper_ts$/)
3346  ***      0      0      0   if (my($n, $suffix) = $val =~ /^$n_ts$/) { }
      ***      0      0      0   elsif (my($ymd, $hms) = $val =~ /^(\d{6})(?:\s+(\d+:\d+:\d+))?/) { }
      ***      0      0      0   elsif (($ymd, $hms) = $val =~ /^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) { }
3347  ***      0      0      0   $suffix eq 'd' ? :
      ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
3357  ***      0      0      0   unless $hms
3362  ***      0      0      0   unless $hms
3367  ***      0      0      0   if $callback and ref $callback eq 'CODE'
3383  ***      0      0      0   defined $_ ? :
3419  ***      0      0      0   unless $args{$arg}
3463  ***      0      0      0   if ($$schema{'counts'}{'TOTAL'}{'dbs'} == 0) { }
3491  ***      0      0      0   if (scalar @{$duplicates;})
3503  ***      0      0      0   if (scalar keys %{$overridens;})
3517  ***      0      0      0   if (scalar keys %{$oos;})
3531  ***      0      0      0   if (scalar keys %{$failed_checks;})
3561  ***      0      0      0   if not --$top
3570  ***      0      0      0   if ($n_remaining)
3608  ***      0      0      0   if not --$top
3617  ***      0      0      0   if ($n_remaining)
3657  ***      0      0      0   if (ref $$schema{'stored_code'}) { }
3659  ***      0      0      0   if (@stored_code_objs) { }
3689  ***      0      0      0   if (ref $ag_pl) { }
3709  ***      0      0      0   defined $_ ? :
3738  ***      0      0      0   unless $args{$arg}
3741  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
3757  ***      0      0      0   unless defined(my $pid = fork)
3758  ***      0      0      0   if ($pid)
3765  ***      0      0      0   unless POSIX::setsid()
3766  ***      0      0      0   unless chdir '/'
3772  ***      0      0      0   if (-t STDIN)
3774  ***      0      0      0   unless open STDIN, '/dev/null'
3778  ***      0      0      0   if ($$self{'log_file'}) { }
3780  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
3784  ***      0      0      0   unless open STDERR, '>&STDOUT'
3788  ***      0      0      0   if (-t STDOUT)
3790  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
3793  ***      0      0      0   if (-t STDERR)
3795  ***      0      0      0   unless open STDERR, '>', '/dev/null'
3806  ***      0      0      0   $self ? :
3808  ***      0      0      0   if ($PID_file and -f $PID_file) { }
3811  ***      0      0      0   if $EVAL_ERROR
3813  ***      0      0      0   if ($pid) { }
3815  ***      0      0      0   if ($pid_is_alive) { }
3837  ***      0      0      0   if (exists $$self{'child'})
3849  ***      0      0      0   if (not $PID_file)
3856  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
3858  ***      0      0      0   unless print $PID_FH $PID
3860  ***      0      0      0   unless close $PID_FH
3869  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
3870  ***      0      0      0   unless unlink $$self{'PID_file'}
3882  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
3888  ***      0      0      0   defined $_ ? :
3930  ***      0      0      0   if $o->got('host')
3936  ***      0      0      0   if ($o->get('ask-pass'))
3944  ***      0      0      0   if ($o->get('pid'))
3986  ***      0      0      0   if ($gr->have_priv($dbh, 'PROCESS')) { }
4029  ***      0      0      0   if ($EVAL_ERROR)
4039  ***      0      0      0   if ($n == 0)
4111  ***      0      0      0   if ($n_raid_ctrls == 0) { }
4135  ***      0      0      0   defined $_ ? :


Conditions
----------

and 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
2240  ***      0      0      0   exists $sysctl{$var} and undef

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
92    ***      0      0      0      0   $trgs and @$trgs
138   ***      0      0      0      0   $curr and $new
      ***      0      0      0      0   $curr and $new and $curr eq $new
563   ***      0      0      0      0   $type and $type eq 'd'
      ***      0      0      0      0   $type and $type eq 'd' and not $$self{'dp'}
568   ***      0      0      0      0   $type and $type =~ /[HhAadzm]/
707   ***      0      0      0      0   @ARGV and $ARGV[0] eq '--config'
736   ***      0      0      0      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
743   ***      0      0      0      0   @ARGV and $$self{'strict'}
827   ***      0      0      0      0   $opt and $$opt{'type'}
830   ***      0      0      0      0   $val and $$opt{'type'} eq 'm'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'd'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'z'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'a'
895   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
903   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
917   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
1006  ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
1100  ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1371  ***      0      0      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000'
      ***      0      0      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i
1401  ***      0      0      0      0   $engine =~ /InnoDB/i and not $clustered_key
1403  ***      0      0      0      0   $$this_key{'is_unique'} and not $$this_key{'is_nullable'}
1427  ***      0      0      0      0   not $parent =~ /\./ and $$opts{'database'}
1570  ***     66      4      4      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33      8      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1695  ***     66      1      0      1   not $dbh and $tries--
1731  ***     33      1      0      0   not $dbh and $EVAL_ERROR
2505  ***      0      0      0      0   $val and $val =~ /\(No/
2544  ***      0      0      0      0   $defaults_file and -f $defaults_file
2614  ***      0      0      0      0   defined $val and $val =~ /(\d+)([kKmMgGtT]?)/
2684  ***      0      0      0      0   not defined $$self{'cmd_line_ops'}{$var} and not defined $val
2707  ***      0      0      0      0   $conf_val || $online_val and $conf_val ne $online_val
2746  ***      0      0      0      0   $x eq $val1 || $x eq $val2 and $y eq $val1 || $y eq $val2
2759  ***      0      0      0      0   $x and $x eq 'ON'
      ***      0      0      0      0   $x and $x eq 'ON' and $y
2760  ***      0      0      0      0   $y and $y eq 'ON'
      ***      0      0      0      0   $y and $y eq 'ON' and $x
3242  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
3300  ***      0      0      0      0   $num >= $d and $n < @units - 1
3367  ***      0      0      0      0   $callback and ref $callback eq 'CODE'
3808  ***      0      0      0      0   $PID_file and -f $PID_file
3869  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
309   ***      0      0      0   $$_[1] || ''
368   ***      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
370   ***      0      0      0   $args{'prompt'} || '<options>'
      ***      0      0      0   $args{'dp'} || undef
412   ***      0      0      0   $file ||= '/home/daniel/dev/maatkit/mk-audit/mk-audit'
553   ***      0      0      0   $$opt{'group'} ||= 'default'
835   ***      0      0      0   $s || 's'
844   ***      0      0      0   $prefix || ''
872   ***      0      0      0   $pre || ''
879   ***      0      0      0   $val || ''
882   ***      0      0      0   $val || ''
940   ***      0      0      0   $$self{'description'} || ''
1008  ***      0      0      0   $s ||= 's'
1034  ***      0      0      0   $$opt{'type'} || ''
1332  ***      0      0      0   $$_{'Privileges'} || ''
1348  ***      0      0      0   $engine || undef
1370  ***      0      0      0   $type || $special || 'BTREE'
1551  ***     50      0      1   $prev ||= {}
1552  ***     50      0      1   $defaults ||= {}
1625  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1638  ***     50      0      1   $self->prop('dbidriver') || ''
1642  ***      0      0      0   $$info{'D'} || ''
1648  ***     50      0      1   $$info{'D'} || ''
1670  ***     50      1      0   $opts ||= {}
1768  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1784  ***      0      0      0   $level ||= 0
1785  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
2188  ***      0      0      0   $sysctl_conf ||= '/etc/sysctl.conf'
2311  ***      0      0      0   $kb ||= 1
2312  ***      0      0      0   $d ||= 2
2458  ***      0      0      0   $undef_for{$var} || ''
2461  ***      0      0      0   $$self{'cmd_line_ops'}{'defaults_file'} ||= ''
2471  ***      0      0      0   $size || 0
2477  ***      0      0      0   $binary || ''
2508  ***      0      0      0   $undef_for{$var} || ''
2577  ***      0      0      0   $my_print_defaults || 'my_print_defaults'
2629  ***      0      0      0   $undef_for{$var} || ''
2650  ***      0      0      0   $$self{'cmd_line_ops'}{'port'} || ''
2651  ***      0      0      0   $o->get('socket') || $$self{'cmd_line_ops'}{'socket'} || ''
2845  ***      0      0      0   $$dbs{$db}{$table}{'data_length'} ||= 0
2846  ***      0      0      0   $$dbs{$db}{$table}{'index_length'} ||= 0
2847  ***      0      0      0   $$dbs{$db}{$table}{'rows'} ||= 0
3099  ***      0      0      0   $args{'undef_val'} || 'NULL'
3262  ***      0      0      0   $args{'p'} || 0
3264  ***      0      0      0   $of ||= 1
3269  ***      0      0      0   $secs ||= 0
3640  ***      0      0      0   $$engines{$engine}{'indexes'} || 'NA'

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
150   ***      0      0      0      0   not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl}
189   ***      0      0      0      0   not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl}
219   ***      0      0      0      0   not $$self{'cache'} or not $$self{'triggers'}{$db}
253   ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'} or $like
272   ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db} or $like
286   ***      0      0      0      0   $tbl{'type'} || $tbl{'comment'}
      ***      0      0      0      0   $tbl{'engine'} ||= $tbl{'type'} || $tbl{'comment'}
298   ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db} or $like
367   ***      0      0      0      0   $program_name ||= $PROGRAM_NAME
368   ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
830   ***      0      0      0      0   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1264  ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'}
      ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
1370  ***      0      0      0      0   $type || $special
1661  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1662  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1663  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1664  ***      0      0      0      0   $$dsn{'u'} ||= $user
1665  ***      0      0      0      0   $$dsn{'D'} ||= $db
1905  ***      0      0      0      0   $_ eq '' || $_ =~ /^0|\D/
2458  ***      0      0      0      0   $val ||= $undef_for{$var} || ''
2508  ***      0      0      0      0   $val ||= $undef_for{$var} || ''
2629  ***      0      0      0      0   $val ||= $undef_for{$var} || ''
2651  ***      0      0      0      0   $o->get('socket') || $$self{'cmd_line_ops'}{'socket'}
2679  ***      0      0      0      0   not defined $var or not defined $val
2684  ***      0      0      0      0   not defined $$self{'cmd_line_ops'}{$var} and not defined $val or $$self{'cmd_line_ops'}{$var} ne $val
2707  ***      0      0      0      0   $conf_val || $online_val
2746  ***      0      0      0      0   $x eq $val1 || $x eq $val2
      ***      0      0      0      0   $y eq $val1 || $y eq $val2
3116  ***      0      0      0      0   $field eq 'Command' or $field eq 'State'
3272  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
3304  ***      0      0      0      0   $num =~ /\./ || $n
3882  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}


Covered Subroutines
-------------------

Subroutine                     Count Location                                       
------------------------------ ----- -----------------------------------------------
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:1177
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:1178
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:1179
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:1181
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:1467
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:1468
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:1475
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:1478
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:1480
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:1830
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:1831
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:1833
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:1835
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:1877
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:1878
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:1882
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:1884
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:1937
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:1938
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:1940
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:1942
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:22  
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:23  
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:2344
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:2345
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:2347
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:2348
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:2349
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:2352
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:2793
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:2794
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:2796
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:2798
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:2937
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:2938
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:2940
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:2941
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:2943
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3091
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3092
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3093
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3095
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3150
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3151
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3152
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3154
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3202
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3203
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3204
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3205
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3206
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3208
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:34  
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3401
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3402
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3403
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3407
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3408
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:341 
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:342 
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:344 
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:345 
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:346 
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:348 
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:35  
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:37  
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3727
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3728
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3730
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3731
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3733
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:39  
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3910
BEGIN                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:3912
get_cxn_params                     1 /home/daniel/dev/maatkit/mk-audit/mk-audit:1635
get_dbh                            1 /home/daniel/dev/maatkit/mk-audit/mk-audit:1669
new                                1 /home/daniel/dev/maatkit/mk-audit/mk-audit:1483
parse                              1 /home/daniel/dev/maatkit/mk-audit/mk-audit:1545
prop                               3 /home/daniel/dev/maatkit/mk-audit/mk-audit:1536

Uncovered Subroutines
---------------------

Subroutine                     Count Location                                       
------------------------------ ----- -----------------------------------------------
DESTROY                            0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3881
__ANON__                           0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3975
__ANON__                           0 /home/daniel/dev/maatkit/mk-audit/mk-audit:731 
_can_run                           0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2255
_d                                 0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1159
_d                                 0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1451
_d                                 0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1812
_d                                 0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1861
_d                                 0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2326
_d                                 0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2775
_d                                 0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2918
_d                                 0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3073
_d                                 0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3132
_d                                 0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3183
_d                                 0 /home/daniel/dev/maatkit/mk-audit/mk-audit:323 
_d                                 0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3382
_d                                 0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3708
_d                                 0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3887
_d                                 0 /home/daniel/dev/maatkit/mk-audit/mk-audit:4134
_defaults_file_op                  0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2538
_eqifconfundef                     0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2765
_eqifon                            0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2758
_get_participants                  0 /home/daniel/dev/maatkit/mk-audit/mk-audit:631 
_get_raid_info_arcconf             0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2093
_get_raid_info_megarc              0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2054
_get_raid_info_tw_cli              0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2121
_load_default_defaults_files       0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2562
_load_online_sys_vars              0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2638
_make_PID_file                     0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3846
_memory_slots                      0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2286
_numericeq                         0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2770
_os_version                        0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2263
_parse_specs                       0 /home/daniel/dev/maatkit/mk-audit/mk-audit:517 
_patheq                            0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2751
_pod_to_specs                      0 /home/daniel/dev/maatkit/mk-audit/mk-audit:411 
_print_aggregated_processlist      0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3678
_print_dbs_size_summary            0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3544
_print_engines_summary             0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3626
_print_stored_code_summary         0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3647
_print_tables_size_summary         0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3581
_read_config_file                  0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1083
_remove_PID_file                   0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3868
_set_option                        0 /home/daniel/dev/maatkit/mk-audit/mk-audit:677 
_use_db                            0 /home/daniel/dev/maatkit/mk-audit/mk-audit:130 
_validate_type                     0 /home/daniel/dev/maatkit/mk-audit/mk-audit:826 
_vars_from_defaults_file           0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2575
_veq                               0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2745
aggregate                          0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3106
any_unix_timestamp                 0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3344
as_string                          0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1609
check_PID_file                     0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3805
check_proc_sys_net_ipv4_values     0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2138
clone                              0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1136
copy                               0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1794
daemonize                          0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3754
descr                              0 /home/daniel/dev/maatkit/mk-audit/mk-audit:939 
disconnect                         0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1777
discover                           0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2812
discover_stored_code               0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2882
dump                               0 /home/daniel/dev/maatkit/mk-audit/mk-audit:73  
duplicate_sys_vars                 0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2663
errors                             0 /home/daniel/dev/maatkit/mk-audit/mk-audit:929 
fill_in_dsn                        0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1657
find_best_index                    0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1276
find_mysqld_binary_unix            0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2475
find_possible_keys                 0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1294
get                                0 /home/daniel/dev/maatkit/mk-audit/mk-audit:893 
get_DSN                            0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2648
get_columns                        0 /home/daniel/dev/maatkit/mk-audit/mk-audit:187 
get_create_table                   0 /home/daniel/dev/maatkit/mk-audit/mk-audit:149 
get_databases                      0 /home/daniel/dev/maatkit/mk-audit/mk-audit:252 
get_defaults                       0 /home/daniel/dev/maatkit/mk-audit/mk-audit:667 
get_defaults_files                 0 /home/daniel/dev/maatkit/mk-audit/mk-audit:406 
get_engine                         0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1345
get_eq_for                         0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2737
get_fks                            0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1417
get_groups                         0 /home/daniel/dev/maatkit/mk-audit/mk-audit:672 
get_hostname                       0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1767
get_keys                           0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1352
get_opts                           0 /home/daniel/dev/maatkit/mk-audit/mk-audit:694 
get_raid_info                      0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2036
get_register_size                  0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2469
get_specs                          0 /home/daniel/dev/maatkit/mk-audit/mk-audit:399 
get_table_list                     0 /home/daniel/dev/maatkit/mk-audit/mk-audit:297 
get_table_status                   0 /home/daniel/dev/maatkit/mk-audit/mk-audit:271 
get_tmp_table                      0 /home/daniel/dev/maatkit/mk-audit/mk-audit:207 
get_triggers                       0 /home/daniel/dev/maatkit/mk-audit/mk-audit:218 
got                                0 /home/daniel/dev/maatkit/mk-audit/mk-audit:901 
has                                0 /home/daniel/dev/maatkit/mk-audit/mk-audit:909 
have_priv                          0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3174
load_ipv4_defaults                 0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2209
load_status_vals                   0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2727
load_sys_vars                      0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2481
main                               0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3915
make_PID_file                      0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3836
make_checksum                      0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3375
micro_t                            0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3231
mysqld_processes                   0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2416
new                                0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1184
new                                0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1838
new                                0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1887
new                                0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2447
new                                0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2801
new                                0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3033
new                                0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3098
new                                0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3168
new                                0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3411
new                                0 /home/daniel/dev/maatkit/mk-audit/mk-audit:362 
new                                0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3736
new                                0 /home/daniel/dev/maatkit/mk-audit/mk-audit:66  
opts                               0 /home/daniel/dev/maatkit/mk-audit/mk-audit:643 
out_of_sync_sys_vars               0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2694
overriden_sys_vars                 0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2675
parse                              0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1190
parse                              0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1843
parse_options                      0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1596
parse_sysctl_conf                  0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2225
parse_timestamp                    0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3322
percentage_of                      0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3261
print_active_handles               0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1783
print_errors                       0 /home/daniel/dev/maatkit/mk-audit/mk-audit:963 
print_usage                        0 /home/daniel/dev/maatkit/mk-audit/mk-audit:973 
prompt                             0 /home/daniel/dev/maatkit/mk-audit/mk-audit:934 
prompt_noecho                      0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1048
quote                              0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1892
quote_val                          0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1900
read_para_after                    0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1117
remove_auto_increment              0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1445
report                             0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3417
report_server_specs                0 /home/daniel/dev/maatkit/mk-audit/mk-audit:4052
run_checks                         0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3044
save_error                         0 /home/daniel/dev/maatkit/mk-audit/mk-audit:924 
secs_to_time                       0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3268
server_specs                       0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1945
set                                0 /home/daniel/dev/maatkit/mk-audit/mk-audit:915 
set_defaults                       0 /home/daniel/dev/maatkit/mk-audit/mk-audit:655 
short_opts                         0 /home/daniel/dev/maatkit/mk-audit/mk-audit:649 
shorten                            0 /home/daniel/dev/maatkit/mk-audit/mk-audit:2307
shorten                            0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3295
sort_indexes                       0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1257
split_unquote                      0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1915
table_exists                       0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1322
ts                                 0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3312
unix_timestamp                     0 /home/daniel/dev/maatkit/mk-audit/mk-audit:3334
usage                              0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1618
usage_or_errors                    0 /home/daniel/dev/maatkit/mk-audit/mk-audit:950 
version_ge                         0 /home/daniel/dev/maatkit/mk-audit/mk-audit:1850


mk-audit.t

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     BEGIN {
4     ***      1     50     33      1            32      die "The MAATKIT_TRUNK environment variable is not set.  See http://code.google.com/p/maatkit/wiki/Testing"
5                                                           unless $ENV{MAATKIT_TRUNK} && -d $ENV{MAATKIT_TRUNK};
6              1                                  7      unshift @INC, "$ENV{MAATKIT_TRUNK}/common";
7                                                     };
8                                                     
9              1                    1            11   use strict;
               1                                  3   
               1                                  6   
10             1                    1             7   use warnings FATAL => 'all';
               1                                  2   
               1                                  6   
11             1                    1            11   use English qw(-no_match_vars);
               1                                  2   
               1                                  7   
12             1                    1            11   use Test::More tests => 4;
               1                                  3   
               1                                 11   
13                                                    
14             1                    1            13   use MaatkitTest;
               1                                  3   
               1                                 11   
15             1                    1            13   use Sandbox;
               1                                  3   
               1                                 11   
16             1                                 34   require "$trunk/mk-audit/mk-audit";
17                                                    
18             1                                 10   my $dp = new DSNParser();
19             1                                 11   my $sb = new Sandbox(basedir => '/tmp', DSNParser => $dp);
20             1                                 56   my $dbh = $sb->get_dbh_for('master');
21                                                    
22             1                             159752   my $output = `$trunk/mk-audit/mk-audit --help`;
23             1                                 66   like($output, qr/Prompt for a password/, 'It compiles');
24                                                    
25    ***      1     50                           5   SKIP: {
26             1                                 17      skip 'Sandbox master is not running', 5 unless $dbh;
27                                                    
28             1                                  5      my $out_file = '/tmp/mk-audit.output';
29             1                             1111015      my $output = `$trunk/mk-audit/mk-audit 1>$out_file 2>$out_file.err`;
30                                                    
31                                                       # mk-audit used to warn about certain things. Ideally, however,
32                                                       # it should never error/warn to STDERR and instead make an
33                                                       # remark in the report like, "mysqld exists but segfaults when ran."
34                                                       # So any output to STDERR probably indicates something is broken
35                                                       # inside the code, or some new condition we're not catching gracefully.
36             1                               5909      is(`cat $out_file.err`, '', 'No errors or warnings on STDERR');
37             1                               6451      diag(`rm -f $out_file.err`);
38                                                    
39             1                              12255      like(`grep 'Server Specs' $out_file`, qr/Server Specs/, 'Server Specs');
40                                                    
41                                                    #   SKIP: {
42                                                    #      skip 'mk-audit is deprecated', 2 if 1;
43                                                    #      like(`grep 'MySQL Instance' $out_file`, qr/MySQL Instance\s+\d+/, 'MySQL Instance');
44                                                    
45                                                          # The persistent sandbox is purposefully broken so that
46                                                          # long_query_time is out of sync.
47                                                    #      like(`grep long_query_time $out_file`, qr/long_query_time\s+3\s+1/, 'long_query_time out of sync');
48                                                    #   };
49                                                    
50             1                               6111      diag(`rm -f $out_file`);
51                                                    
52                                                       # #########################################################################
53                                                       # Issue 391: Add --pid option to all scripts
54                                                       # #########################################################################
55             1                               6226      `touch /tmp/mk-script.pid`;
56             1                             175173      $output = `$trunk/mk-audit/mk-audit --pid /tmp/mk-script.pid 2>&1`;
57             1                                 54      like(
58                                                          $output,
59                                                          qr{PID file /tmp/mk-script.pid already exists},
60                                                          'Dies if PID file already exists (issue 391)'
61                                                       );
62             1                               3442      `rm -rf /tmp/mk-script.pid`;
63                                                    
64                                                    };
65                                                    
66             1                                  9   exit;


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
4     ***     50      0      1   unless $ENV{'MAATKIT_TRUNK'} and -d $ENV{'MAATKIT_TRUNK'}
25    ***     50      0      1   unless $dbh


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
4     ***     33      0      0      1   $ENV{'MAATKIT_TRUNK'} and -d $ENV{'MAATKIT_TRUNK'}


Covered Subroutines
-------------------

Subroutine Count Location     
---------- ----- -------------
BEGIN          1 mk-audit.t:10
BEGIN          1 mk-audit.t:11
BEGIN          1 mk-audit.t:12
BEGIN          1 mk-audit.t:14
BEGIN          1 mk-audit.t:15
BEGIN          1 mk-audit.t:4 
BEGIN          1 mk-audit.t:9 


