---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...kit/mk-upgrade/mk-upgrade   38.2   20.9   22.9   54.0    n/a  100.0   33.1
Total                          38.2   20.9   22.9   54.0    n/a  100.0   33.1
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          mk-upgrade.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Mon Jun 29 14:49:02 2009
Finish:       Mon Jun 29 14:49:02 2009

/home/daniel/dev/maatkit/mk-upgrade/mk-upgrade

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This program is copyright 2009-@CURRENTYEAR@ Percona Inc.
4                                                     # Feedback and improvements are welcome.
5                                                     #
6                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
7                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
8                                                     # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
9                                                     #
10                                                    # This program is free software; you can redistribute it and/or modify it under
11                                                    # the terms of the GNU General Public License as published by the Free Software
12                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
13                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
14                                                    # licenses.
15                                                    #
16                                                    # You should have received a copy of the GNU General Public License along with
17                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
18                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
19                                                    
20             1                    1             7   use strict;
               1                                 12   
               1                                  7   
21             1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  9   
22                                                    
23                                                    our $VERSION = '@VERSION@';
24                                                    our $DISTRIB = '@DISTRIB@';
25                                                    our $SVN_REV = sprintf("%d", (q$Revision: 4008 $ =~ m/(\d+)/g, 0));
26                                                    
27                                                    # ###########################################################################
28                                                    # DSNParser package 3963
29                                                    # ###########################################################################
30             1                    1             5   use strict;
               1                                  2   
               1                                  5   
31             1                    1             5   use warnings FATAL => 'all';
               1                                  2   
               1                                  5   
32                                                    
33                                                    package DSNParser;
34                                                    
35             1                    1            10   use DBI;
               1                                  5   
               1                                 10   
36             1                    1             7   use Data::Dumper;
               1                                  3   
               1                                  9   
37                                                    $Data::Dumper::Indent    = 0;
38                                                    $Data::Dumper::Quotekeys = 0;
39             1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  8   
40                                                    
41             1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                 11   
42                                                    
43                                                    sub new {
44             3                    3            36      my ( $class, @opts ) = @_;
45             3                                638      my $self = {
46                                                          opts => {
47                                                             A => {
48                                                                desc => 'Default character set',
49                                                                dsn  => 'charset',
50                                                                copy => 1,
51                                                             },
52                                                             D => {
53                                                                desc => 'Database to use',
54                                                                dsn  => 'database',
55                                                                copy => 1,
56                                                             },
57                                                             F => {
58                                                                desc => 'Only read default options from the given file',
59                                                                dsn  => 'mysql_read_default_file',
60                                                                copy => 1,
61                                                             },
62                                                             h => {
63                                                                desc => 'Connect to host',
64                                                                dsn  => 'host',
65                                                                copy => 1,
66                                                             },
67                                                             p => {
68                                                                desc => 'Password to use when connecting',
69                                                                dsn  => 'password',
70                                                                copy => 1,
71                                                             },
72                                                             P => {
73                                                                desc => 'Port number to use for connection',
74                                                                dsn  => 'port',
75                                                                copy => 1,
76                                                             },
77                                                             S => {
78                                                                desc => 'Socket file to use for connection',
79                                                                dsn  => 'mysql_socket',
80                                                                copy => 1,
81                                                             },
82                                                             u => {
83                                                                desc => 'User for login if not current user',
84                                                                dsn  => 'user',
85                                                                copy => 1,
86                                                             },
87                                                          },
88                                                       };
89             3                                 19      foreach my $opt ( @opts ) {
90    ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
91    ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
92                                                       }
93             3                                 34      return bless $self, $class;
94                                                    }
95                                                    
96                                                    sub prop {
97            18                   18            84      my ( $self, $prop, $value ) = @_;
98    ***     18     50                          82      if ( @_ > 2 ) {
99    ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
100   ***      0                                  0         $self->{$prop} = $value;
101                                                      }
102           18                                127      return $self->{$prop};
103                                                   }
104                                                   
105                                                   sub parse {
106            6                    6            37      my ( $self, $dsn, $prev, $defaults ) = @_;
107   ***      6     50                          28      if ( !$dsn ) {
108   ***      0                                  0         MKDEBUG && _d('No DSN to parse');
109   ***      0                                  0         return;
110                                                      }
111            6                                 15      MKDEBUG && _d('Parsing', $dsn);
112            6           100                   32      $prev     ||= {};
113   ***      6            50                   26      $defaults ||= {};
114            6                                 17      my %given_props;
115            6                                 20      my %final_props;
116            6                                 16      my %opts = %{$self->{opts}};
               6                                 98   
117                                                   
118            6                                 56      foreach my $dsn_part ( split(/,/, $dsn) ) {
119   ***     11     50                         111         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
120           11                                 55            $given_props{$prop_key} = $prop_val;
121                                                         }
122                                                         else {
123   ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
124   ***      0                                  0            $given_props{h} = $dsn_part;
125                                                         }
126                                                      }
127                                                   
128            6                                 34      foreach my $key ( keys %opts ) {
129           48                                 98         MKDEBUG && _d('Finding value for', $key);
130           48                                159         $final_props{$key} = $given_props{$key};
131           48    100    100                  427         if (   !defined $final_props{$key}
      ***                   66                        
132                                                              && defined $prev->{$key} && $opts{$key}->{copy} )
133                                                         {
134            1                                  3            $final_props{$key} = $prev->{$key};
135            1                                  3            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
136                                                         }
137           48    100                         204         if ( !defined $final_props{$key} ) {
138           36                                119            $final_props{$key} = $defaults->{$key};
139           36                                105            MKDEBUG && _d('Copying value for', $key, 'from defaults');
140                                                         }
141                                                      }
142                                                   
143            6                                 30      foreach my $key ( keys %given_props ) {
144   ***     11     50                          53         die "Unrecognized DSN part '$key' in '$dsn'\n"
145                                                            unless exists $opts{$key};
146                                                      }
147   ***      6     50                          30      if ( (my $required = $self->prop('required')) ) {
148   ***      0                                  0         foreach my $key ( keys %$required ) {
149   ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
150                                                         }
151                                                      }
152                                                   
153            6                                 46      return \%final_props;
154                                                   }
155                                                   
156                                                   sub parse_options {
157   ***      0                    0             0      my ( $self, $o ) = @_;
158   ***      0      0                           0      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
159   ***      0                                  0      my $dsn_string
160                                                         = join(',',
161   ***      0      0                           0             map  { "$_=".$o->get($_); }
162   ***      0                                  0             grep { $o->has($_) && $o->get($_) }
163   ***      0                                  0             keys %{$self->{opts}}
164                                                           );
165   ***      0                                  0      MKDEBUG && _d('DSN string made from options:', $dsn_string);
166   ***      0                                  0      return $self->parse($dsn_string);
167                                                   }
168                                                   
169                                                   sub as_string {
170   ***      0                    0             0      my ( $self, $dsn ) = @_;
171   ***      0      0                           0      return $dsn unless ref $dsn;
172   ***      0      0                           0      return join(',',
173   ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
174   ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
175                                                         sort keys %$dsn );
176                                                   }
177                                                   
178                                                   sub usage {
179   ***      0                    0             0      my ( $self ) = @_;
180   ***      0                                  0      my $usage
181                                                         = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
182                                                         . "  KEY  COPY  MEANING\n"
183                                                         . "  ===  ====  =============================================\n";
184   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
185   ***      0                                  0      foreach my $key ( sort keys %opts ) {
186   ***      0      0      0                    0         $usage .= "  $key    "
187                                                                .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
188                                                                .  ($opts{$key}->{desc} || '[No description]')
189                                                                . "\n";
190                                                      }
191   ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
192   ***      0                                  0      return $usage;
193                                                   }
194                                                   
195                                                   sub get_cxn_params {
196            6                    6            26      my ( $self, $info ) = @_;
197            6                                 18      my $dsn;
198            6                                 19      my %opts = %{$self->{opts}};
               6                                 55   
199   ***      6            50                   34      my $driver = $self->prop('dbidriver') || '';
200   ***      6     50                          25      if ( $driver eq 'Pg' ) {
201   ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
202   ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
203   ***      0             0                    0                        grep { defined $info->{$_} }
204                                                                        qw(h P));
205                                                      }
206                                                      else {
207           12                                 83         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
208           30                                108            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
209   ***      6            50                   81                        grep { defined $info->{$_} }
210                                                                        qw(F h P S A))
211                                                            . ';mysql_read_default_group=client';
212                                                      }
213            6                                 18      MKDEBUG && _d($dsn);
214            6                                 54      return ($dsn, $info->{u}, $info->{p});
215                                                   }
216                                                   
217                                                   sub fill_in_dsn {
218   ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
219   ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
220   ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
221   ***      0                                  0      $user =~ s/@.*//;
222   ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
223   ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
224   ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
225   ***      0             0                    0      $dsn->{u} ||= $user;
226   ***      0             0                    0      $dsn->{D} ||= $db;
227                                                   }
228                                                   
229                                                   sub get_dbh {
230            6                    6            37      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
231   ***      6            50                   27      $opts ||= {};
232   ***      6     50                          53      my $defaults = {
233                                                         AutoCommit        => 0,
234                                                         RaiseError        => 1,
235                                                         PrintError        => 0,
236                                                         mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
237                                                      };
238            6                                 32      @{$defaults}{ keys %$opts } = values %$opts;
               6                                 24   
239                                                   
240            6                                 17      my $dbh;
241            6                                 14      my $tries = 2;
242   ***      6            66                   60      while ( !$dbh && $tries-- ) {
243                                                         MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
244            6                                 12            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
245                                                   
246            6                                 18         eval {
247            6                                 59            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
248                                                   
249   ***      6     50                          57            if ( $cxn_string =~ m/mysql/i ) {
250            6                                 16               my $sql;
251                                                   
252            6                                 24               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
253                                                                    . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
254            6                                 14               MKDEBUG && _d($dbh, ':', $sql);
255            6                                621               $dbh->do($sql);
256                                                   
257   ***      6     50                          63               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
258   ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
259   ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
260   ***      0                                  0                  $dbh->do($sql);
261   ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
262   ***      0      0                           0                  if ( $charset eq 'utf8' ) {
263   ***      0      0                           0                     binmode(STDOUT, ':utf8')
264                                                                        or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
265                                                                  }
266                                                                  else {
267   ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
268                                                                  }
269                                                               }
270                                                   
271   ***      6     50                          38               if ( $self->prop('setvars') ) {
272   ***      0                                  0                  $sql = "SET " . $self->prop('setvars');
273   ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
274   ***      0                                  0                  $dbh->do($sql);
275                                                               }
276                                                            }
277                                                         };
278   ***      6     50     33                   61         if ( !$dbh && $EVAL_ERROR ) {
279   ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
280   ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
281   ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
282   ***      0                                  0               delete $defaults->{mysql_enable_utf8};
283                                                            }
284   ***      0      0                           0            if ( !$tries ) {
285   ***      0                                  0               die $EVAL_ERROR;
286                                                            }
287                                                         }
288                                                      }
289                                                   
290            6                                 13      MKDEBUG && _d('DBH info: ',
291                                                         $dbh,
292                                                         Dumper($dbh->selectrow_hashref(
293                                                            'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
294                                                         'Connection info:',      $dbh->{mysql_hostinfo},
295                                                         'Character set info:',   Dumper($dbh->selectall_arrayref(
296                                                                        'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
297                                                         '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
298                                                         '$DBI::VERSION:',        $DBI::VERSION,
299                                                      );
300                                                   
301            6                                 30      return $dbh;
302                                                   }
303                                                   
304                                                   sub get_hostname {
305   ***      0                    0             0      my ( $self, $dbh ) = @_;
306   ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
307   ***      0                                  0         return $host;
308                                                      }
309   ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
310                                                         'SELECT /*!50038 @@hostname, */ 1');
311   ***      0                                  0      return $hostname;
312                                                   }
313                                                   
314                                                   sub disconnect {
315   ***      0                    0             0      my ( $self, $dbh ) = @_;
316   ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
317   ***      0                                  0      $dbh->disconnect;
318                                                   }
319                                                   
320                                                   sub print_active_handles {
321   ***      0                    0             0      my ( $self, $thing, $level ) = @_;
322   ***      0             0                    0      $level ||= 0;
323   ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
324                                                         $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
325                                                         or die "Cannot print: $OS_ERROR";
326   ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
327   ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
328                                                      }
329                                                   }
330                                                   
331                                                   sub copy {
332   ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
333   ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
334   ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
335   ***      0                                  0      my %new_dsn = map {
336   ***      0                                  0         my $key = $_;
337   ***      0                                  0         my $val;
338   ***      0      0                           0         if ( $args{overwrite} ) {
339   ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
340                                                         }
341                                                         else {
342   ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
343                                                         }
344   ***      0                                  0         $key => $val;
345   ***      0                                  0      } keys %{$self->{opts}};
346   ***      0                                  0      return \%new_dsn;
347                                                   }
348                                                   
349                                                   sub _d {
350   ***      0                    0             0      my ($package, undef, $line) = caller 0;
351   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
352   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
353                                                           @_;
354   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
355                                                   }
356                                                   
357                                                   1;
358                                                   
359                                                   # ###########################################################################
360                                                   # End DSNParser package
361                                                   # ###########################################################################
362                                                   
363                                                   # ###########################################################################
364                                                   # Quoter package 3186
365                                                   # ###########################################################################
366            1                    1            11   use strict;
               1                                  3   
               1                                  8   
367            1                    1             5   use warnings FATAL => 'all';
               1                                  3   
               1                                  8   
368                                                   
369                                                   package Quoter;
370                                                   
371            1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  5   
372                                                   
373            1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  7   
374                                                   
375                                                   sub new {
376   ***      0                    0             0      my ( $class ) = @_;
377   ***      0                                  0      bless {}, $class;
378                                                   }
379                                                   
380                                                   sub quote {
381   ***      0                    0             0      my ( $self, @vals ) = @_;
382   ***      0                                  0      foreach my $val ( @vals ) {
383   ***      0                                  0         $val =~ s/`/``/g;
384                                                      }
385   ***      0                                  0      return join('.', map { '`' . $_ . '`' } @vals);
      ***      0                                  0   
386                                                   }
387                                                   
388                                                   sub quote_val {
389   ***      0                    0             0      my ( $self, @vals ) = @_;
390                                                      return join(', ',
391                                                         map {
392   ***      0      0                           0            if ( defined $_ ) {
      ***      0                                  0   
393   ***      0                                  0               $_ =~ s/(['\\])/\\$1/g;
394   ***      0      0      0                    0               $_ eq '' || $_ =~ m/^0|\D/ ? "'$_'" : $_;
395                                                            }
396                                                            else {
397   ***      0                                  0               'NULL';
398                                                            }
399                                                         } @vals
400                                                      );
401                                                   }
402                                                   
403                                                   sub split_unquote {
404   ***      0                    0             0      my ( $self, $db_tbl, $default_db ) = @_;
405   ***      0                                  0      $db_tbl =~ s/`//g;
406   ***      0                                  0      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
407   ***      0      0                           0      if ( !$tbl ) {
408   ***      0                                  0         $tbl = $db;
409   ***      0                                  0         $db  = $default_db;
410                                                      }
411   ***      0                                  0      return ($db, $tbl);
412                                                   }
413                                                   
414                                                   1;
415                                                   
416                                                   # ###########################################################################
417                                                   # End Quoter package
418                                                   # ###########################################################################
419                                                   
420                                                   # ###########################################################################
421                                                   # OptionParser package 3945
422                                                   # ###########################################################################
423                                                   package OptionParser;
424                                                   
425            1                    1             8   use strict;
               1                                  2   
               1                                  7   
426            1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  6   
427                                                   
428            1                    1            20   use Getopt::Long;
               1                                  3   
               1                                  7   
429            1                    1             6   use List::Util qw(max);
               1                                  3   
               1                                 17   
430            1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  7   
431                                                   
432            1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  8   
433                                                   
434                                                   my $POD_link_re = '[LC]<"?([^">]+)"?>';
435                                                   
436                                                   my %attributes = (
437                                                      'type'       => 1,
438                                                      'short form' => 1,
439                                                      'group'      => 1,
440                                                      'default'    => 1,
441                                                      'cumulative' => 1,
442                                                      'negatable'  => 1,
443                                                   );
444                                                   
445                                                   sub new {
446            2                    2            25      my ( $class, %args ) = @_;
447            2                                 12      foreach my $arg ( qw(description) ) {
448   ***      2     50                          13         die "I need a $arg argument" unless $args{$arg};
449                                                      }
450            2                                 21      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
451   ***      2            50                   10      $program_name ||= $PROGRAM_NAME;
452                                                   
453   ***      2     50     50                   73      my $self = {
      ***                   50                        
454                                                         description    => $args{description},
455                                                         prompt         => $args{prompt} || '<options>',
456                                                         strict         => (exists $args{strict} ? $args{strict} : 1),
457                                                         dp             => $args{dp}     || undef,
458                                                         program_name   => $program_name,
459                                                         opts           => {},
460                                                         got_opts       => 0,
461                                                         short_opts     => {},
462                                                         defaults       => {},
463                                                         groups         => {},
464                                                         allowed_groups => {},
465                                                         errors         => [],
466                                                         rules          => [],  # desc of rules for --help
467                                                         mutex          => [],  # rule: opts are mutually exclusive
468                                                         atleast1       => [],  # rule: at least one opt is required
469                                                         disables       => {},  # rule: opt disables other opts 
470                                                         defaults_to    => {},  # rule: opt defaults to value of other opt
471                                                         default_files  => [
472                                                            "/etc/maatkit/maatkit.conf",
473                                                            "/etc/maatkit/$program_name.conf",
474                                                            "$ENV{HOME}/.maatkit.conf",
475                                                            "$ENV{HOME}/.$program_name.conf",
476                                                         ],
477                                                      };
478            2                                 33      return bless $self, $class;
479                                                   }
480                                                   
481                                                   sub get_specs {
482            2                    2             8      my ( $self, $file ) = @_;
483            2                                 14      my @specs = $self->_pod_to_specs($file);
484            2                                 31      $self->_parse_specs(@specs);
485            2                                  7      return;
486                                                   }
487                                                   
488                                                   sub get_defaults_files {
489            2                    2             8      my ( $self ) = @_;
490            2                                  6      return @{$self->{default_files}};
               2                                 24   
491                                                   }
492                                                   
493                                                   sub _pod_to_specs {
494            2                    2             8      my ( $self, $file ) = @_;
495   ***      2            50                   11      $file ||= __FILE__;
496   ***      2     50                          52      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
497                                                   
498            2                                 31      my %types = (
499                                                         string => 's', # standard Getopt type
500                                                         'int'  => 'i', # standard Getopt type
501                                                         float  => 'f', # standard Getopt type
502                                                         Hash   => 'H', # hash, formed from a comma-separated list
503                                                         hash   => 'h', # hash as above, but only if a value is given
504                                                         Array  => 'A', # array, similar to Hash
505                                                         array  => 'a', # array, similar to hash
506                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
507                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
508                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
509                                                      );
510            2                                  6      my @specs = ();
511            2                                  8      my @rules = ();
512            2                                  4      my $para;
513                                                   
514            2                                 14      local $INPUT_RECORD_SEPARATOR = '';
515            2                                 41      while ( $para = <$fh> ) {
516          898    100                        5490         next unless $para =~ m/^=head1 OPTIONS/;
517            2                                  8         last;
518                                                      }
519                                                   
520            2                                 11      while ( $para = <$fh> ) {
521   ***      2     50                          11         last if $para =~ m/^=over/;
522   ***      0                                  0         chomp $para;
523   ***      0                                  0         $para =~ s/\s+/ /g;
524   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
525   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
526   ***      0                                  0         push @rules, $para;
527                                                      }
528                                                   
529   ***      2     50                           8      die 'POD has no OPTIONS section' unless $para;
530                                                   
531            2                                  6      do {
532           36    100                         219         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
533           34                                 89            chomp $para;
534           34                                 68            MKDEBUG && _d($para);
535           34                                 80            my %attribs;
536                                                   
537           34                                108            $para = <$fh>; # read next paragraph, possibly attributes
538                                                   
539           34    100                         122            if ( $para =~ m/: / ) { # attributes
540           22                                 98               $para =~ s/\s+\Z//g;
541           34                                152               %attribs = map {
542           22                                106                     my ( $attrib, $val) = split(/: /, $_);
543   ***     34     50                         141                     die "Unrecognized attribute for --$option: $attrib"
544                                                                        unless $attributes{$attrib};
545           34                                151                     ($attrib, $val);
546                                                                  } split(/; /, $para);
547           22    100                          99               if ( $attribs{'short form'} ) {
548           12                                 52                  $attribs{'short form'} =~ s/-//;
549                                                               }
550           22                                 82               $para = <$fh>; # read next paragraph, probably short help desc
551                                                            }
552                                                            else {
553           12                                 33               MKDEBUG && _d('Option has no attributes');
554                                                            }
555                                                   
556           34                                217            $para =~ s/\s+\Z//g;
557           34                                226            $para =~ s/\s+/ /g;
558           34                                125            $para =~ s/$POD_link_re/$1/go;
559                                                   
560           34                                121            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
561           34                                 72            MKDEBUG && _d('Short help:', $para);
562                                                   
563   ***     34     50                         133            die "No description after option spec $option" if $para =~ m/^=item/;
564                                                   
565   ***     34     50                         142            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
566   ***      0                                  0               $option = $base_option;
567   ***      0                                  0               $attribs{'negatable'} = 1;
568                                                            }
569                                                   
570           34    100                         515            push @specs, {
      ***            50                               
      ***            50                               
                    100                               
      ***            50                               
      ***            50                               
571                                                               spec  => $option
572                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
573                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
574                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
575                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
576                                                               desc  => $para
577                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
578                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
579                                                            };
580                                                         }
581           36                                192         while ( $para = <$fh> ) {
582   ***     50     50                         173            last unless $para;
583                                                   
584                                                   
585           50    100                         176            if ( $para =~ m/^=head1/ ) {
586            2                                  6               $para = undef; # Can't 'last' out of a do {} block.
587            2                                 10               last;
588                                                            }
589           48    100                         280            last if $para =~ m/^=item --/;
590                                                         }
591                                                      } while ( $para );
592                                                   
593   ***      2     50                           9      die 'No valid specs in POD OPTIONS' unless @specs;
594                                                   
595            2                                 23      close $fh;
596            2                                  6      return @specs, @rules;
597                                                   }
598                                                   
599                                                   sub _parse_specs {
600            2                    2            11      my ( $self, @specs ) = @_;
601            2                                  8      my %disables; # special rule that requires deferred checking
602                                                   
603            2                                  9      foreach my $opt ( @specs ) {
604   ***     34     50                         114         if ( ref $opt ) { # It's an option spec, not a rule.
605                                                            MKDEBUG && _d('Parsing opt spec:',
606           34                                 72               map { ($_, '=>', $opt->{$_}) } keys %$opt);
607                                                   
608           34                                223            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
609   ***     34     50                         134            if ( !$long ) {
610   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
611                                                            }
612           34                                114            $opt->{long} = $long;
613                                                   
614   ***     34     50                         144            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
615           34                                156            $self->{opts}->{$long} = $opt;
616                                                   
617   ***     34     50                         122            if ( length $long == 1 ) {
618   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
619   ***      0                                  0               $self->{short_opts}->{$long} = $long;
620                                                            }
621                                                   
622           34    100                         104            if ( $short ) {
623   ***     12     50                          51               die "Duplicate short option -$short"
624                                                                  if exists $self->{short_opts}->{$short};
625           12                                 44               $self->{short_opts}->{$short} = $long;
626           12                                 38               $opt->{short} = $short;
627                                                            }
628                                                            else {
629           22                                 86               $opt->{short} = undef;
630                                                            }
631                                                   
632   ***     34     50                         163            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
633   ***     34     50                         162            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
634   ***     34     50                         179            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
635                                                   
636   ***     34            50                  126            $opt->{group} ||= 'default';
637           34                                156            $self->{groups}->{ $opt->{group} }->{$long} = 1;
638                                                   
639           34                                100            $opt->{value} = undef;
640           34                                 99            $opt->{got}   = 0;
641                                                   
642           34                                167            my ( $type ) = $opt->{spec} =~ m/=(.)/;
643           34                                118            $opt->{type} = $type;
644           34                                 78            MKDEBUG && _d($long, 'type:', $type);
645                                                   
646   ***     34     50     66                  260            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                   33                        
647   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
648                                                                  . "was given when this OptionParser object was created";
649                                                            }
650                                                   
651           34    100    100                  220            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
652                                                   
653   ***     34     50                         165            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
654   ***      0      0                           0               if ( $opt->{is_negatable} ) {
655   ***      0      0                           0                  $def = $def eq 'yes' ? 1
      ***             0                               
656                                                                       : $def eq 'no'  ? 0
657                                                                       : $def;
658                                                               }
659   ***      0      0                           0               $self->{defaults}->{$long} = defined $def ? $def : 1;
660   ***      0                                  0               MKDEBUG && _d($long, 'default:', $def);
661                                                            }
662                                                   
663           34    100                         122            if ( $long eq 'config' ) {
664            2                                  9               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
665                                                            }
666                                                   
667   ***     34     50                         173            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
668   ***      0                                  0               $disables{$long} = $dis;
669   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
670                                                            }
671                                                   
672           34                                160            $self->{opts}->{$long} = $opt;
673                                                         }
674                                                         else { # It's an option rule, not a spec.
675   ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
676   ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
677   ***      0                                  0            my @participants = $self->_get_participants($opt);
678   ***      0                                  0            my $rule_ok = 0;
679                                                   
680   ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
681   ***      0                                  0               $rule_ok = 1;
682   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
683   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
684                                                            }
685   ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
686   ***      0                                  0               $rule_ok = 1;
687   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
688   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
689                                                            }
690   ***      0      0                           0            if ( $opt =~ m/default to/ ) {
691   ***      0                                  0               $rule_ok = 1;
692   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
693   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
694                                                            }
695   ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
696   ***      0                                  0               $rule_ok = 1;
697   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
698   ***      0                                  0               my @groups = split(',', $groups);
699   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
700   ***      0                                  0                  s/\s+//;
701   ***      0                                  0                  $_ => 1;
702                                                               } @groups;
703                                                            }
704                                                   
705   ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
706                                                         }
707                                                      }
708                                                   
709            2                                 11      foreach my $long ( keys %disables ) {
710   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
711   ***      0                                  0         $self->{disables}->{$long} = \@participants;
712   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
713                                                      }
714                                                   
715            2                                  9      return; 
716                                                   }
717                                                   
718                                                   sub _get_participants {
719   ***      0                    0             0      my ( $self, $str ) = @_;
720   ***      0                                  0      my @participants;
721   ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
722   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
723                                                            unless exists $self->{opts}->{$long};
724   ***      0                                  0         push @participants, $long;
725                                                      }
726   ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
727   ***      0                                  0      return @participants;
728                                                   }
729                                                   
730                                                   sub opts {
731   ***      0                    0             0      my ( $self ) = @_;
732   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
733   ***      0                                  0      return %opts;
734                                                   }
735                                                   
736                                                   sub opt_values {
737   ***      0                    0             0      my ( $self ) = @_;
738   ***      0      0                           0      my %opts = map {
739   ***      0                                  0         my $opt = $self->{opts}->{$_}->{short} ? $self->{opts}->{$_}->{short}
740                                                                 : $_;
741   ***      0                                  0         $opt => $self->{opts}->{$_}->{value}
742   ***      0                                  0      } keys %{$self->{opts}};
743   ***      0                                  0      return %opts;
744                                                   }
745                                                   
746                                                   sub short_opts {
747   ***      0                    0             0      my ( $self ) = @_;
748   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
749   ***      0                                  0      return %short_opts;
750                                                   }
751                                                   
752                                                   sub set_defaults {
753   ***      0                    0             0      my ( $self, %defaults ) = @_;
754   ***      0                                  0      $self->{defaults} = {};
755   ***      0                                  0      foreach my $long ( keys %defaults ) {
756   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
757                                                            unless exists $self->{opts}->{$long};
758   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
759   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
760                                                      }
761   ***      0                                  0      return;
762                                                   }
763                                                   
764                                                   sub get_defaults {
765   ***      0                    0             0      my ( $self ) = @_;
766   ***      0                                  0      return $self->{defaults};
767                                                   }
768                                                   
769                                                   sub get_groups {
770   ***      0                    0             0      my ( $self ) = @_;
771   ***      0                                  0      return $self->{groups};
772                                                   }
773                                                   
774                                                   sub _set_option {
775   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
776   ***      0      0                           0      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***             0                               
777                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
778                                                               : die "Getopt::Long gave a nonexistent option: $opt";
779                                                   
780   ***      0                                  0      $opt = $self->{opts}->{$long};
781   ***      0      0                           0      if ( $opt->{is_cumulative} ) {
782   ***      0                                  0         $opt->{value}++;
783                                                      }
784                                                      else {
785   ***      0                                  0         $opt->{value} = $val;
786                                                      }
787   ***      0                                  0      $opt->{got} = 1;
788   ***      0                                  0      MKDEBUG && _d('Got option', $long, '=', $val);
789                                                   }
790                                                   
791                                                   sub get_opts {
792            2                    2             8      my ( $self ) = @_; 
793                                                   
794            2                                  5      foreach my $long ( keys %{$self->{opts}} ) {
               2                                 20   
795           34                                116         $self->{opts}->{$long}->{got} = 0;
796   ***     34     50                         271         $self->{opts}->{$long}->{value}
                    100                               
797                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
798                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
799                                                            : undef;
800                                                      }
801            2                                  9      $self->{got_opts} = 0;
802                                                   
803            2                                  8      $self->{errors} = [];
804                                                   
805   ***      2     50     33                   24      if ( @ARGV && $ARGV[0] eq "--config" ) {
806   ***      0                                  0         shift @ARGV;
807   ***      0                                  0         $self->_set_option('config', shift @ARGV);
808                                                      }
809   ***      2     50                          15      if ( $self->has('config') ) {
810            2                                  6         my @extra_args;
811            2                                 13         foreach my $filename ( split(',', $self->get('config')) ) {
812            8                                 20            eval {
813            8                                 42               push @ARGV, $self->_read_config_file($filename);
814                                                            };
815   ***      8     50                          36            if ( $EVAL_ERROR ) {
816   ***      8     50                          36               if ( $self->got('config') ) {
817   ***      0                                  0                  die $EVAL_ERROR;
818                                                               }
819                                                               elsif ( MKDEBUG ) {
820                                                                  _d($EVAL_ERROR);
821                                                               }
822                                                            }
823                                                         }
824            2                                 15         unshift @ARGV, @extra_args;
825                                                      }
826                                                   
827            2                                 17      Getopt::Long::Configure('no_ignore_case', 'bundling');
828                                                      GetOptions(
829   ***     32                    0           207         map    { $_->{spec} => sub { $self->_set_option(@_); } }
      ***      0                                  0   
              34                                123   
830            2                                 12         grep   { $_->{long} ne 'config' } # --config is handled specially above.
831   ***      2     50                           7         values %{$self->{opts}}
832                                                      ) or $self->save_error('Error parsing options');
833                                                   
834   ***      2     50     33                   75      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
835   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
836                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
837                                                               or die "Cannot print: $OS_ERROR";
838   ***      0                                  0         exit 0;
839                                                      }
840                                                   
841   ***      2     50     33                   19      if ( @ARGV && $self->{strict} ) {
842   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
843                                                      }
844                                                   
845            2                                  6      foreach my $mutex ( @{$self->{mutex}} ) {
               2                                 11   
846   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
847   ***      0      0                           0         if ( @set > 1 ) {
848   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
849   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
850                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
851                                                                    . ' are mutually exclusive.';
852   ***      0                                  0            $self->save_error($err);
853                                                         }
854                                                      }
855                                                   
856            2                                  6      foreach my $required ( @{$self->{atleast1}} ) {
               2                                 10   
857   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
858   ***      0      0                           0         if ( @set == 0 ) {
859   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
860   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
861                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
862   ***      0                                  0            $self->save_error("Specify at least one of $err");
863                                                         }
864                                                      }
865                                                   
866            2                                  6      foreach my $long ( keys %{$self->{opts}} ) {
               2                                 19   
867           34                                120         my $opt = $self->{opts}->{$long};
868   ***     34     50                         178         if ( $opt->{got} ) {
      ***            50                               
869   ***      0      0                           0            if ( exists $self->{disables}->{$long} ) {
870   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
871   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
872   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
873                                                                  'because', $long,'disables them');
874                                                            }
875                                                   
876   ***      0      0                           0            if ( exists $self->{allowed_groups}->{$long} ) {
877                                                   
878   ***      0                                  0               my @restricted_groups = grep {
879   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
880   ***      0                                  0               } keys %{$self->{groups}};
881                                                   
882   ***      0                                  0               my @restricted_opts;
883   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
884   ***      0                                  0                  RESTRICTED_OPT:
885   ***      0                                  0                  foreach my $restricted_opt (
886                                                                     keys %{$self->{groups}->{$restricted_group}} )
887                                                                  {
888   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
889   ***      0      0                           0                     push @restricted_opts, $restricted_opt
890                                                                        if $self->{opts}->{$restricted_opt}->{got};
891                                                                  }
892                                                               }
893                                                   
894   ***      0      0                           0               if ( @restricted_opts ) {
895   ***      0                                  0                  my $err;
896   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
897   ***      0                                  0                     $err = "--$restricted_opts[0]";
898                                                                  }
899                                                                  else {
900   ***      0                                  0                     $err = join(', ',
901   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
902   ***      0                                  0                               grep { $_ } 
903                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
904                                                                            )
905                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
906                                                                  }
907   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
908                                                               }
909                                                            }
910                                                   
911                                                         }
912                                                         elsif ( $opt->{is_required} ) { 
913   ***      0                                  0            $self->save_error("Required option --$long must be specified");
914                                                         }
915                                                   
916           34                                120         $self->_validate_type($opt);
917                                                      }
918                                                   
919            2                                 11      $self->{got_opts} = 1;
920            2                                  6      return;
921                                                   }
922                                                   
923                                                   sub _validate_type {
924           34                   34           121      my ( $self, $opt ) = @_;
925   ***     34    100     66                  278      return unless $opt && $opt->{type};
926           22                                 66      my $val = $opt->{value};
927                                                   
928   ***     22     50     66                  465      if ( $val && $opt->{type} eq 'm' ) {
      ***            50     66                        
      ***            50     66                        
      ***            50     66                        
      ***           100     33                        
      ***                   33                        
      ***                   66                        
929   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
930   ***      0                                  0         my ( $num, $suffix ) = $val =~ m/(\d+)([a-z])?$/;
931   ***      0      0                           0         if ( !$suffix ) {
932   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
933   ***      0             0                    0            $suffix = $s || 's';
934   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
935                                                               $opt->{long}, '(value:', $val, ')');
936                                                         }
937   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
938   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
939                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
940                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
941                                                                 :                  $num * 86400;   # Days
942   ***      0                                  0            $opt->{value} = $val;
943   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
944                                                         }
945                                                         else {
946   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
947                                                         }
948                                                      }
949                                                      elsif ( $val && $opt->{type} eq 'd' ) {
950   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
951   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
952   ***      0                                  0         my $default = {};
953   ***      0      0                           0         if ( $from_key ) {
954   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
955   ***      0                                  0            $default = $self->{dp}->parse(
956                                                               $self->{dp}->as_string($self->{opts}->{$from_key}->{value}) );
957                                                         }
958   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $default);
959                                                      }
960                                                      elsif ( $val && $opt->{type} eq 'z' ) {
961   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
962   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
963   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
964   ***      0      0                           0         if ( defined $num ) {
965   ***      0      0                           0            if ( $factor ) {
966   ***      0                                  0               $num *= $factor_for{$factor};
967   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
968                                                                  'to num', $num, '* factor', $factor);
969                                                            }
970   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
971                                                         }
972                                                         else {
973   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
974                                                         }
975                                                      }
976                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
977   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
978                                                      }
979                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
980   ***      2            50                   34         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
981                                                      }
982                                                      else {
983           20                                 45         MKDEBUG && _d('Nothing to validate for option',
984                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
985                                                      }
986                                                   
987           22                                 71      return;
988                                                   }
989                                                   
990                                                   sub get {
991           18                   18            81      my ( $self, $opt ) = @_;
992   ***     18     50                          87      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
993   ***     18     50     33                  181      die "Option $opt does not exist"
994                                                         unless $long && exists $self->{opts}->{$long};
995           18                                137      return $self->{opts}->{$long}->{value};
996                                                   }
997                                                   
998                                                   sub got {
999            8                    8            31      my ( $self, $opt ) = @_;
1000  ***      8     50                          35      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1001  ***      8     50     33                   71      die "Option $opt does not exist"
1002                                                        unless $long && exists $self->{opts}->{$long};
1003           8                                 46      return $self->{opts}->{$long}->{got};
1004                                                  }
1005                                                  
1006                                                  sub has {
1007           2                    2            10      my ( $self, $opt ) = @_;
1008  ***      2     50                          11      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1009  ***      2     50                          19      return defined $long ? exists $self->{opts}->{$long} : 0;
1010                                                  }
1011                                                  
1012                                                  sub set {
1013  ***      0                    0             0      my ( $self, $opt, $val ) = @_;
1014  ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1015  ***      0      0      0                    0      die "Option $opt does not exist"
1016                                                        unless $long && exists $self->{opts}->{$long};
1017  ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
1018  ***      0                                  0      return;
1019                                                  }
1020                                                  
1021                                                  sub save_error {
1022  ***      0                    0             0      my ( $self, $error ) = @_;
1023  ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
1024                                                  }
1025                                                  
1026                                                  sub errors {
1027  ***      0                    0             0      my ( $self ) = @_;
1028  ***      0                                  0      return $self->{errors};
1029                                                  }
1030                                                  
1031                                                  sub prompt {
1032  ***      0                    0             0      my ( $self ) = @_;
1033  ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
1034                                                  }
1035                                                  
1036                                                  sub descr {
1037  ***      0                    0             0      my ( $self ) = @_;
1038  ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
1039                                                                . "  For more details, please use the --help option, "
1040                                                                . "or try 'perldoc $PROGRAM_NAME' "
1041                                                                . "for complete documentation.";
1042  ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
1043  ***      0                                  0      $descr =~ s/ +$//mg;
1044  ***      0                                  0      return $descr;
1045                                                  }
1046                                                  
1047                                                  sub usage_or_errors {
1048           2                    2            11      my ( $self ) = @_;
1049  ***      2     50                          12      if ( $self->{opts}->{help}->{got} ) {
      ***      2     50                          12   
1050  ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
1051  ***      0                                  0         exit 0;
1052                                                     }
1053                                                     elsif ( scalar @{$self->{errors}} ) {
1054  ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
1055  ***      0                                  0         exit 0;
1056                                                     }
1057           2                                  6      return;
1058                                                  }
1059                                                  
1060                                                  sub print_errors {
1061  ***      0                    0             0      my ( $self ) = @_;
1062  ***      0                                  0      my $usage = $self->prompt() . "\n";
1063  ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
1064  ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
1065                                                                . "\n";
1066                                                     }
1067  ***      0                                  0      return $usage . "\n" . $self->descr();
1068                                                  }
1069                                                  
1070                                                  sub print_usage {
1071  ***      0                    0             0      my ( $self ) = @_;
1072  ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
1073  ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
1074                                                  
1075  ***      0      0                           0      my $maxl = max(
1076  ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
1077                                                        @opts);
1078                                                  
1079  ***      0      0                           0      my $maxs = max(0,
1080  ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
1081  ***      0                                  0         values %{$self->{short_opts}});
1082                                                  
1083  ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
1084  ***      0                                  0      my $rcol = 80 - $lcol - 6;
1085  ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
1086                                                  
1087  ***      0                                  0      $maxs = max($lcol - 3, $maxs);
1088                                                  
1089  ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
1090                                                  
1091  ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
1092  ***      0                                  0      push @groups, 'default';
1093                                                  
1094  ***      0                                  0      foreach my $group ( reverse @groups ) {
1095  ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
1096  ***      0                                  0         foreach my $opt (
      ***      0                                  0   
1097  ***      0                                  0            sort { $a->{long} cmp $b->{long} }
1098                                                           grep { $_->{group} eq $group }
1099                                                           @opts )
1100                                                        {
1101  ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
1102  ***      0                                  0            my $short = $opt->{short};
1103  ***      0                                  0            my $desc  = $opt->{desc};
1104  ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
1105  ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
1106  ***      0             0                    0               $s    ||= 's';
1107  ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
1108  ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
1109                                                                     . "d=days; if no suffix, $s is used.";
1110                                                           }
1111  ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
1112  ***      0                                  0            $desc =~ s/ +$//mg;
1113  ***      0      0                           0            if ( $short ) {
1114  ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
1115                                                           }
1116                                                           else {
1117  ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
1118                                                           }
1119                                                        }
1120                                                     }
1121                                                  
1122  ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
1123  ***      0                                  0         $usage .= "\nRules:\n\n";
1124  ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
1125                                                     }
1126  ***      0      0                           0      if ( $self->{dp} ) {
1127  ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
1128                                                     }
1129  ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
1130  ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
1131  ***      0                                  0         my $val   = $opt->{value};
1132  ***      0             0                    0         my $type  = $opt->{type} || '';
1133  ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
1134  ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
1135                                                                  : !defined $val             ? '(No value)'
1136                                                                  : $type eq 'd'              ? $self->{dp}->as_string($val)
1137                                                                  : $type =~ m/H|h/           ? join(',', sort keys %$val)
1138                                                                  : $type =~ m/A|a/           ? join(',', @$val)
1139                                                                  :                             $val;
1140  ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
1141                                                     }
1142  ***      0                                  0      return $usage;
1143                                                  }
1144                                                  
1145                                                  sub prompt_noecho {
1146  ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
1147  ***      0                                  0      my ( $prompt ) = @_;
1148  ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
1149  ***      0      0                           0      print $prompt
1150                                                        or die "Cannot print: $OS_ERROR";
1151  ***      0                                  0      my $response;
1152  ***      0                                  0      eval {
1153  ***      0                                  0         require Term::ReadKey;
1154  ***      0                                  0         Term::ReadKey::ReadMode('noecho');
1155  ***      0                                  0         chomp($response = <STDIN>);
1156  ***      0                                  0         Term::ReadKey::ReadMode('normal');
1157  ***      0      0                           0         print "\n"
1158                                                           or die "Cannot print: $OS_ERROR";
1159                                                     };
1160  ***      0      0                           0      if ( $EVAL_ERROR ) {
1161  ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
1162                                                     }
1163  ***      0                                  0      return $response;
1164                                                  }
1165                                                  
1166                                                  if ( MKDEBUG ) {
1167                                                     print '# ', $^X, ' ', $], "\n";
1168                                                     my $uname = `uname -a`;
1169                                                     if ( $uname ) {
1170                                                        $uname =~ s/\s+/ /g;
1171                                                        print "# $uname\n";
1172                                                     }
1173                                                     printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
1174                                                        $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
1175                                                        ($main::SVN_REV || ''), __LINE__);
1176                                                     print('# Arguments: ',
1177                                                        join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
1178                                                  }
1179                                                  
1180                                                  sub _read_config_file {
1181           8                    8            33      my ( $self, $filename ) = @_;
1182  ***      8     50                          18      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
1183  ***      0                                  0      my @args;
1184  ***      0                                  0      my $prefix = '--';
1185  ***      0                                  0      my $parse  = 1;
1186                                                  
1187                                                     LINE:
1188  ***      0                                  0      while ( my $line = <$fh> ) {
1189  ***      0                                  0         chomp $line;
1190  ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
1191  ***      0                                  0         $line =~ s/\s+#.*$//g;
1192  ***      0                                  0         $line =~ s/^\s+|\s+$//g;
1193  ***      0      0                           0         if ( $line eq '--' ) {
1194  ***      0                                  0            $prefix = '';
1195  ***      0                                  0            $parse  = 0;
1196  ***      0                                  0            next LINE;
1197                                                        }
1198  ***      0      0      0                    0         if ( $parse
      ***             0                               
1199                                                           && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
1200                                                        ) {
1201  ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
1202                                                        }
1203                                                        elsif ( $line =~ m/./ ) {
1204  ***      0                                  0            push @args, $line;
1205                                                        }
1206                                                        else {
1207  ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
1208                                                        }
1209                                                     }
1210  ***      0                                  0      close $fh;
1211  ***      0                                  0      return @args;
1212                                                  }
1213                                                  
1214                                                  sub read_para_after {
1215  ***      0                    0             0      my ( $self, $file, $regex ) = @_;
1216  ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
1217  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
1218  ***      0                                  0      my $para;
1219  ***      0                                  0      while ( $para = <$fh> ) {
1220  ***      0      0                           0         next unless $para =~ m/^=pod$/m;
1221  ***      0                                  0         last;
1222                                                     }
1223  ***      0                                  0      while ( $para = <$fh> ) {
1224  ***      0      0                           0         next unless $para =~ m/$regex/;
1225  ***      0                                  0         last;
1226                                                     }
1227  ***      0                                  0      $para = <$fh>;
1228  ***      0                                  0      chomp($para);
1229  ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
1230  ***      0                                  0      return $para;
1231                                                  }
1232                                                  
1233                                                  sub clone {
1234  ***      0                    0             0      my ( $self ) = @_;
1235                                                  
1236  ***      0                                  0      my %clone = map {
1237  ***      0                                  0         my $hashref  = $self->{$_};
1238  ***      0                                  0         my $val_copy = {};
1239  ***      0                                  0         foreach my $key ( keys %$hashref ) {
1240  ***      0                                  0            my $ref = ref $hashref->{$key};
1241  ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
1242  ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
1243  ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
1244                                                                             : $hashref->{$key};
1245                                                        }
1246  ***      0                                  0         $_ => $val_copy;
1247                                                     } qw(opts short_opts defaults);
1248                                                  
1249  ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
1250  ***      0                                  0         $clone{$scalar} = $self->{$scalar};
1251                                                     }
1252                                                  
1253  ***      0                                  0      return bless \%clone;     
1254                                                  }
1255                                                  
1256                                                  sub _d {
1257  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1258  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1259  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1260                                                          @_;
1261  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1262                                                  }
1263                                                  
1264                                                  1;
1265                                                  
1266                                                  # ###########################################################################
1267                                                  # End OptionParser package
1268                                                  # ###########################################################################
1269                                                  
1270                                                  # ###########################################################################
1271                                                  # Transformers package 3972
1272                                                  # ###########################################################################
1273                                                  
1274                                                  package Transformers;
1275                                                  
1276           1                    1             9   use strict;
               1                                  3   
               1                                  7   
1277           1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  8   
1278           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  7   
1279           1                    1            14   use Time::Local qw(timelocal);
               1                                  3   
               1                                  9   
1280           1                    1             7   use Digest::MD5 qw(md5_hex);
               1                                  2   
               1                                  8   
1281                                                  
1282           1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  7   
1283                                                  
1284                                                  require Exporter;
1285                                                  our @ISA         = qw(Exporter);
1286                                                  our %EXPORT_TAGS = ();
1287                                                  our @EXPORT      = ();
1288                                                  our @EXPORT_OK   = qw(
1289                                                     micro_t
1290                                                     percentage_of
1291                                                     secs_to_time
1292                                                     shorten
1293                                                     ts
1294                                                     parse_timestamp
1295                                                     unix_timestamp
1296                                                     make_checksum
1297                                                  );
1298                                                  
1299                                                  sub micro_t {
1300  ***      0                    0             0      my ( $t, %args ) = @_;
1301  ***      0      0                           0      my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
1302  ***      0      0                           0      my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
1303  ***      0                                  0      my $f;
1304                                                  
1305  ***      0      0                           0      $t = 0 if $t < 0;
1306                                                  
1307  ***      0      0                           0      $t = sprintf('%.17f', $t) if $t =~ /e/;
1308                                                  
1309  ***      0                                  0      $t =~ s/\.(\d{1,6})\d*/\.$1/;
1310                                                  
1311  ***      0      0      0                    0      if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
1312  ***      0                                  0         $f = ($t * 1000000) . 'us';
1313                                                     }
1314                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
1315  ***      0                                  0         $f = sprintf("%.${p_ms}f", $t * 1000);
1316  ***      0                                  0         $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
1317                                                     }
1318                                                     elsif ($t >= 1) {
1319  ***      0                                  0         $f = sprintf("%.${p_s}f", $t);
1320  ***      0                                  0         $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
1321                                                     }
1322                                                     else {
1323  ***      0                                  0         $f = 0;  # $t should = 0 at this point
1324                                                     }
1325                                                  
1326  ***      0                                  0      return $f;
1327                                                  }
1328                                                  
1329                                                  sub percentage_of {
1330  ***      0                    0             0      my ( $is, $of, %args ) = @_;
1331  ***      0             0                    0      my $p   = $args{p} || 0; # float precision
1332  ***      0      0                           0      my $fmt = $p ? "%.${p}f" : "%d";
1333  ***      0             0                    0      return sprintf $fmt, ($is * 100) / ($of ||= 1);
1334                                                  }
1335                                                  
1336                                                  sub secs_to_time {
1337  ***      0                    0             0      my ( $secs, $fmt ) = @_;
1338  ***      0             0                    0      $secs ||= 0;
1339  ***      0      0                           0      return '00:00' unless $secs;
1340                                                  
1341  ***      0      0      0                    0      $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
1342                                                            : $secs >= 3_600  ? 'h'
1343                                                            :                   'm';
1344                                                  
1345                                                     return
1346  ***      0      0                           0         $fmt eq 'd' ? sprintf(
      ***             0                               
1347                                                           "%d+%02d:%02d:%02d",
1348                                                           int($secs / 86_400),
1349                                                           int(($secs % 86_400) / 3_600),
1350                                                           int(($secs % 3_600) / 60),
1351                                                           $secs % 60)
1352                                                        : $fmt eq 'h' ? sprintf(
1353                                                           "%02d:%02d:%02d",
1354                                                           int(($secs % 86_400) / 3_600),
1355                                                           int(($secs % 3_600) / 60),
1356                                                           $secs % 60)
1357                                                        : sprintf(
1358                                                           "%02d:%02d",
1359                                                           int(($secs % 3_600) / 60),
1360                                                           $secs % 60);
1361                                                  }
1362                                                  
1363                                                  sub shorten {
1364  ***      0                    0             0      my ( $num, %args ) = @_;
1365  ***      0      0                           0      my $p = defined $args{p} ? $args{p} : 2;     # float precision
1366  ***      0      0                           0      my $d = defined $args{d} ? $args{d} : 1_024; # divisor
1367  ***      0                                  0      my $n = 0;
1368  ***      0                                  0      my @units = ('', qw(k M G T P E Z Y));
1369  ***      0             0                    0      while ( $num >= $d && $n < @units - 1 ) {
1370  ***      0                                  0         $num /= $d;
1371  ***      0                                  0         ++$n;
1372                                                     }
1373  ***      0      0      0                    0      return sprintf(
1374                                                        $num =~ m/\./ || $n
1375                                                           ? "%.${p}f%s"
1376                                                           : '%d',
1377                                                        $num, $units[$n]);
1378                                                  }
1379                                                  
1380                                                  sub ts {
1381  ***      0                    0             0      my ( $time ) = @_;
1382  ***      0                                  0      my ( $sec, $min, $hour, $mday, $mon, $year )
1383                                                        = localtime($time);
1384  ***      0                                  0      $mon  += 1;
1385  ***      0                                  0      $year += 1900;
1386  ***      0                                  0      return sprintf("%d-%02d-%02dT%02d:%02d:%02d",
1387                                                        $year, $mon, $mday, $hour, $min, $sec);
1388                                                  }
1389                                                  
1390                                                  sub parse_timestamp {
1391  ***      0                    0             0      my ( $val ) = @_;
1392  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $f)
1393                                                           = $val =~ m/^(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?$/ )
1394                                                     {
1395  ***      0      0                           0         return sprintf "%d-%02d-%02d %02d:%02d:"
      ***             0                               
1396                                                                       . (defined $f ? '%02.6f' : '%02d'),
1397                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
1398                                                     }
1399  ***      0                                  0      return $val;
1400                                                  }
1401                                                  
1402                                                  sub unix_timestamp {
1403  ***      0                    0             0      my ( $val ) = @_;
1404  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s)
1405                                                       = $val =~ m/^(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(?:\.\d+)?$/ )
1406                                                     {
1407  ***      0                                  0         return timelocal($s, $i, $h, $d, $m - 1, $y);
1408                                                     }
1409  ***      0                                  0      return $val;
1410                                                  }
1411                                                  
1412                                                  sub make_checksum {
1413  ***      0                    0             0      my ( $val ) = @_;
1414  ***      0                                  0      my $checksum = uc substr(md5_hex($val), -16);
1415  ***      0                                  0      MKDEBUG && _d($checksum, 'checksum for', $val);
1416  ***      0                                  0      return $checksum;
1417                                                  }
1418                                                  
1419                                                  sub _d {
1420  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1421  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1422  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1423                                                          @_;
1424  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1425                                                  }
1426                                                  
1427                                                  1;
1428                                                  
1429                                                  # ###########################################################################
1430                                                  # End Transformers package
1431                                                  # ###########################################################################
1432                                                  
1433                                                  # ###########################################################################
1434                                                  # QueryRewriter package 3383
1435                                                  # ###########################################################################
1436           1                    1             7   use strict;
               1                                  3   
               1                                  5   
1437           1                    1             5   use warnings FATAL => 'all';
               1                                  3   
               1                                  6   
1438                                                  
1439                                                  package QueryRewriter;
1440                                                  
1441           1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  5   
1442                                                  
1443           1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  8   
1444                                                  
1445                                                  our $verbs   = qr{^SHOW|^FLUSH|^COMMIT|^ROLLBACK|^BEGIN|SELECT|INSERT
1446                                                                    |UPDATE|DELETE|REPLACE|^SET|UNION|^START}xi;
1447                                                  my $quote_re = qr/"(?:(?!(?<!\\)").)*"|'(?:(?!(?<!\\)').)*'/; # Costly!
1448                                                  my $bal;
1449                                                  $bal         = qr/
1450                                                                    \(
1451                                                                    (?:
1452                                                                       (?> [^()]+ )    # Non-parens without backtracking
1453                                                                       |
1454                                                                       (??{ $bal })    # Group with matching parens
1455                                                                    )*
1456                                                                    \)
1457                                                                   /x;
1458                                                  
1459                                                  my $olc_re = qr/(?:--|#)[^'"\r\n]*(?=[\r\n]|\Z)/;  # One-line comments
1460                                                  my $mlc_re = qr#/\*[^!].*?\*/#sm;                  # But not /*!version */
1461                                                  
1462                                                  sub new {
1463  ***      0                    0             0      my ( $class, %args ) = @_;
1464  ***      0                                  0      my $self = { %args };
1465  ***      0                                  0      return bless $self, $class;
1466                                                  }
1467                                                  
1468                                                  sub strip_comments {
1469  ***      0                    0             0      my ( $self, $query ) = @_;
1470  ***      0                                  0      $query =~ s/$olc_re//go;
1471  ***      0                                  0      $query =~ s/$mlc_re//go;
1472  ***      0                                  0      return $query;
1473                                                  }
1474                                                  
1475                                                  sub shorten {
1476  ***      0                    0             0      my ( $self, $query, $length ) = @_;
1477  ***      0                                  0      $query =~ s{
1478                                                        \A(
1479                                                           (?:INSERT|REPLACE)
1480                                                           (?:\s+LOW_PRIORITY|DELAYED|HIGH_PRIORITY|IGNORE)?
1481                                                           (?:\s\w+)*\s+\S+\s+VALUES\s*\(.*?\)
1482                                                        )
1483                                                        \s*,\s*\(.*?(ON\s+DUPLICATE|\Z)}
1484                                                        {$1 /*... omitted ...*/$2}xsi;
1485                                                  
1486  ***      0      0                           0      return $query unless $query =~ m/IN\s*\(\s*(?!select)/i;
1487                                                  
1488  ***      0      0      0                    0      if ( $length && length($query) > $length ) {
1489  ***      0                                  0         my ($left, $mid, $right) = $query =~ m{
1490                                                           (\A.*?\bIN\s*\()     # Everything up to the opening of IN list
1491                                                           ([^\)]+)             # Contents of the list
1492                                                           (\).*\Z)             # The rest of the query
1493                                                        }xsi;
1494  ***      0      0                           0         if ( $left ) {
1495  ***      0                                  0            my $targ = $length - length($left) - length($right);
1496  ***      0                                  0            my @vals = split(/,/, $mid);
1497  ***      0                                  0            my @left = shift @vals;
1498  ***      0                                  0            my @right;
1499  ***      0                                  0            my $len  = length($left[0]);
1500  ***      0             0                    0            while ( @vals && $len < $targ / 2 ) {
1501  ***      0                                  0               $len += length($vals[0]) + 1;
1502  ***      0                                  0               push @left, shift @vals;
1503                                                           }
1504  ***      0             0                    0            while ( @vals && $len < $targ ) {
1505  ***      0                                  0               $len += length($vals[-1]) + 1;
1506  ***      0                                  0               unshift @right, pop @vals;
1507                                                           }
1508  ***      0      0                           0            $query = $left . join(',', @left)
1509                                                                  . (@right ? ',' : '')
1510                                                                  . " /*... omitted " . scalar(@vals) . " items ...*/ "
1511                                                                  . join(',', @right) . $right;
1512                                                        }
1513                                                     }
1514                                                  
1515  ***      0                                  0      return $query;
1516                                                  }
1517                                                  
1518                                                  sub fingerprint {
1519  ***      0                    0             0      my ( $self, $query ) = @_;
1520                                                  
1521  ***      0      0                           0      $query =~ m#\ASELECT /\*!40001 SQL_NO_CACHE \*/ \* FROM `# # mysqldump query
1522                                                        && return 'mysqldump';
1523  ***      0      0                           0      $query =~ m#/\*\w+\.\w+:[0-9]/[0-9]\*/#     # mk-table-checksum, etc query
1524                                                        && return 'maatkit';
1525  ***      0      0                           0      $query =~ m/\A# administrator command: /
1526                                                        && return $query;
1527  ***      0      0                           0      $query =~ m/\A\s*(call\s+\S+)\(/i
1528                                                        && return lc($1); # Warning! $1 used, be careful.
1529  ***      0      0                           0      if ( my ($beginning) = $query =~ m/\A((?:INSERT|REPLACE)(?: IGNORE)? INTO .+? VALUES \(.*?\)),\(/i ) {
1530  ***      0                                  0         $query = $beginning; # Shorten multi-value INSERT statements ASAP
1531                                                     }
1532                                                  
1533  ***      0                                  0      $query =~ s/$olc_re//go;
1534  ***      0                                  0      $query =~ s/$mlc_re//go;
1535  ***      0      0                           0      $query =~ s/\Ause \S+\Z/use ?/i       # Abstract the DB in USE
1536                                                        && return $query;
1537                                                  
1538  ***      0                                  0      $query =~ s/\\["']//g;                # quoted strings
1539  ***      0                                  0      $query =~ s/".*?"/?/sg;               # quoted strings
1540  ***      0                                  0      $query =~ s/'.*?'/?/sg;               # quoted strings
1541  ***      0                                  0      $query =~ s/[0-9+-][0-9a-f.xb+-]*/?/g;# Anything vaguely resembling numbers
1542  ***      0                                  0      $query =~ s/[xb.+-]\?/?/g;            # Clean up leftovers
1543  ***      0                                  0      $query =~ s/\A\s+//;                  # Chop off leading whitespace
1544  ***      0                                  0      chomp $query;                         # Kill trailing whitespace
1545  ***      0                                  0      $query =~ tr[ \n\t\r\f][ ]s;          # Collapse whitespace
1546  ***      0                                  0      $query = lc $query;
1547  ***      0                                  0      $query =~ s/\bnull\b/?/g;             # Get rid of NULLs
1548  ***      0                                  0      $query =~ s{                          # Collapse IN and VALUES lists
1549                                                                 \b(in|values?)(?:[\s,]*\([\s?,]*\))+
1550                                                                }
1551                                                                {$1(?+)}gx;
1552  ***      0                                  0      $query =~ s{                          # Collapse UNION
1553                                                                 \b(select\s.*?)(?:(\sunion(?:\sall)?)\s\1)+
1554                                                                }
1555                                                                {$1 /*repeat$2*/}xg;
1556  ***      0                                  0      $query =~ s/\blimit \?(?:, ?\?| offset \?)?/limit ?/; # LIMIT
1557  ***      0                                  0      return $query;
1558                                                  }
1559                                                  
1560                                                  sub distill {
1561  ***      0                    0             0      my ( $self, $query, %args ) = @_;
1562  ***      0             0                    0      my $qp = $args{qp} || $self->{QueryParser};
1563  ***      0      0                           0      die "I need a qp argument" unless $qp;
1564                                                  
1565  ***      0      0                           0      $query =~ m/\A\s*call\s+(\S+)\(/i
1566                                                        && return "CALL $1"; # Warning! $1 used, be careful.
1567  ***      0      0                           0      $query =~ m/\A# administrator/
1568                                                        && return "ADMIN";
1569  ***      0      0                           0      $query =~ m/\A\s*use\s+/
1570                                                        && return "USE";
1571                                                  
1572  ***      0                                  0      my @verbs = $query =~ m/\b($verbs)\b/gio;
1573  ***      0                                  0      @verbs    = do {
1574  ***      0                                  0         my $last = '';
1575  ***      0                                  0         grep { my $pass = $_ ne $last; $last = $_; $pass } map { uc } @verbs;
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
1576                                                     };
1577  ***      0                                  0      my $verbs = join(q{ }, @verbs);
1578  ***      0                                  0      $verbs =~ s/( UNION SELECT)+/ UNION/g;
1579                                                  
1580  ***      0                                  0      my @tables = map {
1581  ***      0                                  0         $_ =~ s/`//g;
1582  ***      0                                  0         $_ =~ s/(_?)[0-9]+/$1?/g;
1583  ***      0                                  0         $_;
1584                                                     } $qp->get_tables($query);
1585                                                  
1586  ***      0                                  0      @tables = do {
1587  ***      0                                  0         my $last = '';
1588  ***      0                                  0         grep { my $pass = $_ ne $last; $last = $_; $pass } @tables;
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
1589                                                     };
1590                                                  
1591  ***      0                                  0      $query = join(q{ }, $verbs, @tables);
1592  ***      0                                  0      return $query;
1593                                                  }
1594                                                  
1595                                                  sub convert_to_select {
1596  ***      0                    0             0      my ( $self, $query ) = @_;
1597  ***      0      0                           0      return unless $query;
1598  ***      0                                  0      $query =~ s{
      ***      0                                  0   
1599                                                                   \A.*?
1600                                                                   update\s+(.*?)
1601                                                                   \s+set\b(.*?)
1602                                                                   (?:\s*where\b(.*?))?
1603                                                                   (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
1604                                                                   \Z
1605                                                                }
1606                                                                {__update_to_select($1, $2, $3, $4)}exsi
1607  ***      0                                  0         || $query =~ s{
1608                                                                      \A.*?
1609                                                                      (?:insert|replace)\s+
1610                                                                      .*?\binto\b(.*?)\(([^\)]+)\)\s*
1611                                                                      values?\s*(\(.*?\))\s*
1612                                                                      (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
1613                                                                      \Z
1614                                                                   }
1615                                                                   {__insert_to_select($1, $2, $3)}exsi
1616  ***      0      0      0                    0         || $query =~ s{
1617                                                                      \A.*?
1618                                                                      delete\s+(.*?)
1619                                                                      \bfrom\b(.*)
1620                                                                      \Z
1621                                                                   }
1622                                                                   {__delete_to_select($1, $2)}exsi;
1623  ***      0                                  0      $query =~ s/\s*on\s+duplicate\s+key\s+update.*\Z//si;
1624  ***      0                                  0      $query =~ s/\A.*?(?=\bSELECT\s*\b)//ism;
1625  ***      0                                  0      return $query;
1626                                                  }
1627                                                  
1628                                                  sub convert_select_list {
1629  ***      0                    0             0      my ( $self, $query ) = @_;
1630  ***      0      0                           0      $query =~ s{
      ***      0                                  0   
1631                                                                 \A\s*select(.*?)\bfrom\b
1632                                                                }
1633                                                                {$1 =~ m/\*/ ? "select 1 from" : "select isnull(coalesce($1)) from"}exi;
1634  ***      0                                  0      return $query;
1635                                                  }
1636                                                  
1637                                                  sub __delete_to_select {
1638  ***      0                    0             0      my ( $delete, $join ) = @_;
1639  ***      0      0                           0      if ( $join =~ m/\bjoin\b/ ) {
1640  ***      0                                  0         return "select 1 from $join";
1641                                                     }
1642  ***      0                                  0      return "select * from $join";
1643                                                  }
1644                                                  
1645                                                  sub __insert_to_select {
1646  ***      0                    0             0      my ( $tbl, $cols, $vals ) = @_;
1647  ***      0                                  0      MKDEBUG && _d('Args:', @_);
1648  ***      0                                  0      my @cols = split(/,/, $cols);
1649  ***      0                                  0      MKDEBUG && _d('Cols:', @cols);
1650  ***      0                                  0      $vals =~ s/^\(|\)$//g; # Strip leading/trailing parens
1651  ***      0                                  0      my @vals = $vals =~ m/($quote_re|[^,]*${bal}[^,]*|[^,]+)/g;
1652  ***      0                                  0      MKDEBUG && _d('Vals:', @vals);
1653  ***      0      0                           0      if ( @cols == @vals ) {
1654  ***      0                                  0         return "select * from $tbl where "
1655  ***      0                                  0            . join(' and ', map { "$cols[$_]=$vals[$_]" } (0..$#cols));
1656                                                     }
1657                                                     else {
1658  ***      0                                  0         return "select * from $tbl limit 1";
1659                                                     }
1660                                                  }
1661                                                  
1662                                                  sub __update_to_select {
1663  ***      0                    0             0      my ( $from, $set, $where, $limit ) = @_;
1664  ***      0      0                           0      return "select $set from $from "
      ***             0                               
1665                                                        . ( $where ? "where $where" : '' )
1666                                                        . ( $limit ? " $limit "      : '' );
1667                                                  }
1668                                                  
1669                                                  sub wrap_in_derived {
1670  ***      0                    0             0      my ( $self, $query ) = @_;
1671  ***      0      0                           0      return unless $query;
1672  ***      0      0                           0      return $query =~ m/\A\s*select/i
1673                                                        ? "select 1 from ($query) as x limit 1"
1674                                                        : $query;
1675                                                  }
1676                                                  
1677                                                  sub _d {
1678  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1679  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1680  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1681                                                          @_;
1682  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1683                                                  }
1684                                                  
1685                                                  1;
1686                                                  
1687                                                  # ###########################################################################
1688                                                  # End QueryRewriter package
1689                                                  # ###########################################################################
1690                                                  
1691                                                  # ###########################################################################
1692                                                  # SlowLogParser package 3980
1693                                                  # ###########################################################################
1694                                                  package SlowLogParser;
1695                                                  
1696           1                    1             8   use strict;
               1                                  3   
               1                                 10   
1697           1                    1             5   use warnings FATAL => 'all';
               1                                  3   
               1                                  5   
1698           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  6   
1699           1                    1             6   use Data::Dumper;
               1                                  3   
               1                                  6   
1700                                                  
1701           1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  7   
1702                                                  
1703                                                  sub new {
1704           2                    2            11      my ( $class ) = @_;
1705           2                                 26      bless {}, $class;
1706                                                  }
1707                                                  
1708                                                  my $slow_log_ts_line = qr/^# Time: ([0-9: ]{15})/;
1709                                                  my $slow_log_uh_line = qr/# User\@Host: ([^\[]+|\[[^[]+\]).*?@ (\S*) \[(.*)\]/;
1710                                                  my $slow_log_hd_line = qr{
1711                                                        ^(?:
1712                                                        T[cC][pP]\s[pP]ort:\s+\d+ # case differs on windows/unix
1713                                                        |
1714                                                        [/A-Z].*mysqld,\sVersion.*(?:started\swith:|embedded\slibrary)
1715                                                        |
1716                                                        Time\s+Id\s+Command
1717                                                        ).*\n
1718                                                     }xm;
1719                                                  
1720                                                  sub parse_event {
1721           6                    6            31      my ( $self, $fh, $misc, @callbacks ) = @_;
1722           6                                 21      my $oktorun_here = 1;
1723  ***      6     50                          31      my $oktorun      = $misc->{oktorun} ? $misc->{oktorun} : \$oktorun_here;
1724           6                                 17      my $num_events   = 0;
1725                                                  
1726           6                                 15      my @pending;
1727           6                                 53      local $INPUT_RECORD_SEPARATOR = ";\n#";
1728           6                                 23      my $trimlen    = length($INPUT_RECORD_SEPARATOR);
1729           6                                 31      my $pos_in_log = tell($fh);
1730           6                                 17      my $stmt;
1731                                                  
1732                                                     EVENT:
1733  ***      6            66                  139      while ( $$oktorun
      ***                   66                        
1734                                                             && (defined($stmt = shift @pending) or defined($stmt = <$fh>)) ) {
1735           4                                 25         my @properties = ('cmd', 'Query', 'pos_in_log', $pos_in_log);
1736           4                                 14         $pos_in_log = tell($fh);
1737                                                  
1738  ***      4     50                          60         if ( $stmt =~ s/$slow_log_hd_line//go ){ # Throw away header lines in log
1739  ***      0                                  0            my @chunks = split(/$INPUT_RECORD_SEPARATOR/o, $stmt);
1740  ***      0      0                           0            if ( @chunks > 1 ) {
1741  ***      0                                  0               MKDEBUG && _d("Found multiple chunks");
1742  ***      0                                  0               $stmt = shift @chunks;
1743  ***      0                                  0               unshift @pending, @chunks;
1744                                                           }
1745                                                        }
1746                                                  
1747           4    100                          26         $stmt = '#' . $stmt unless $stmt =~ m/\A#/;
1748           4                                 28         $stmt =~ s/;\n#?\Z//;
1749                                                  
1750                                                  
1751           4                                 15         my ($got_ts, $got_uh, $got_ac, $got_db, $got_set, $got_embed);
1752           4                                 13         my $pos = 0;
1753           4                                 12         my $len = length($stmt);
1754           4                                 10         my $found_arg = 0;
1755                                                        LINE:
1756           4                                 28         while ( $stmt =~ m/^(.*)$/mg ) { # /g is important, requires scalar match.
1757          20                                 56            $pos     = pos($stmt);  # Be careful not to mess this up!
1758          20                                 74            my $line = $1;          # Necessary for /g and pos() to work.
1759          20                                 47            MKDEBUG && _d($line);
1760                                                  
1761          20    100                         117            if ($line =~ m/^(?:#|use |SET (?:last_insert_id|insert_id|timestamp))/o) {
1762                                                  
1763  ***     16    100     66                  278               if ( !$got_ts && (my ( $time ) = $line =~ m/$slow_log_ts_line/o)) {
      ***           100     66                        
      ***            50     33                        
      ***           100     33                        
      ***            50      0                        
      ***             0                               
1764           4                                  8                  MKDEBUG && _d("Got ts", $time);
1765           4                                 17                  push @properties, 'ts', $time;
1766           4                                 11                  ++$got_ts;
1767  ***      4     50     33                   49                  if ( !$got_uh
1768                                                                    && ( my ( $user, $host, $ip ) = $line =~ m/$slow_log_uh_line/o )
1769                                                                 ) {
1770  ***      0                                  0                     MKDEBUG && _d("Got user, host, ip", $user, $host, $ip);
1771  ***      0                                  0                     push @properties, 'user', $user, 'host', $host, 'ip', $ip;
1772  ***      0                                  0                     ++$got_uh;
1773                                                                 }
1774                                                              }
1775                                                  
1776                                                              elsif ( !$got_uh
1777                                                                    && ( my ( $user, $host, $ip ) = $line =~ m/$slow_log_uh_line/o )
1778                                                              ) {
1779           4                                 15                  MKDEBUG && _d("Got user, host, ip", $user, $host, $ip);
1780           4                                 22                  push @properties, 'user', $user, 'host', $host, 'ip', $ip;
1781           4                                 11                  ++$got_uh;
1782                                                              }
1783                                                  
1784                                                              elsif (!$got_ac && $line =~ m/^# (?:administrator command:.*)$/) {
1785  ***      0                                  0                  MKDEBUG && _d("Got admin command");
1786  ***      0                                  0                  push @properties, 'cmd', 'Admin', 'arg', $line;
1787  ***      0                                  0                  push @properties, 'bytes', length($properties[-1]);
1788  ***      0                                  0                  ++$found_arg;
1789  ***      0                                  0                  ++$got_ac;
1790                                                              }
1791                                                  
1792                                                              elsif ( $line =~ m/^# +[A-Z][A-Za-z_]+: \S+/ ) { # Make the test cheap!
1793           4                                 12                  MKDEBUG && _d("Got some line with properties");
1794           4                                 65                  my @temp = $line =~ m/(\w+):\s+(\d+(?:\.\d+)?|\S+|\Z)/g;
1795           4                                 28                  push @properties, @temp;
1796                                                              }
1797                                                  
1798                                                              elsif ( !$got_db && (my ( $db ) = $line =~ m/^use ([^;]+)/ ) ) {
1799           4                                  9                  MKDEBUG && _d("Got a default database:", $db);
1800           4                                 15                  push @properties, 'db', $db;
1801           4                                 10                  ++$got_db;
1802                                                              }
1803                                                  
1804                                                              elsif (!$got_set && (my ($setting) = $line =~ m/^SET\s+([^;]*)/)) {
1805  ***      0                                  0                  MKDEBUG && _d("Got some setting:", $setting);
1806  ***      0                                  0                  push @properties, split(/,|\s*=\s*/, $setting);
1807  ***      0                                  0                  ++$got_set;
1808                                                              }
1809                                                  
1810  ***     16     50     33                  183               if ( !$found_arg && $pos == $len ) {
1811  ***      0                                  0                  MKDEBUG && _d("Did not find arg, looking for special cases");
1812  ***      0                                  0                  local $INPUT_RECORD_SEPARATOR = ";\n";
1813  ***      0      0                           0                  if ( defined(my $l = <$fh>) ) {
1814  ***      0                                  0                     chomp $l;
1815  ***      0                                  0                     MKDEBUG && _d("Found admin statement", $l);
1816  ***      0                                  0                     push @properties, 'cmd', 'Admin', 'arg', '#' . $l;
1817  ***      0                                  0                     push @properties, 'bytes', length($properties[-1]);
1818  ***      0                                  0                     $found_arg++;
1819                                                                 }
1820                                                                 else {
1821  ***      0                                  0                     MKDEBUG && _d("I can't figure out what to do with this line");
1822  ***      0                                  0                     next EVENT;
1823                                                                 }
1824                                                              }
1825                                                           }
1826                                                           else {
1827           4                                  9               MKDEBUG && _d("Got the query/arg line");
1828           4                                 20               my $arg = substr($stmt, $pos - length($line));
1829           4                                 22               push @properties, 'arg', $arg, 'bytes', length($arg);
1830  ***      4     50     33                   49               if ( $misc && $misc->{embed}
      ***                   33                        
1831                                                                 && ( my ($e) = $arg =~ m/($misc->{embed})/)
1832                                                              ) {
1833  ***      0                                  0                  push @properties, $e =~ m/$misc->{capture}/g;
1834                                                              }
1835           4                                 12               last LINE;
1836                                                           }
1837                                                        }
1838                                                  
1839           4                                 10         MKDEBUG && _d('Properties of event:', Dumper(\@properties));
1840           4                                 53         my $event = { @properties };
1841           4                                 15         foreach my $callback ( @callbacks ) {
1842  ***     12     50                          46            last unless $event = $callback->($event);
1843                                                        }
1844           4                                 11         ++$num_events;
1845  ***      4     50                          47         last EVENT unless @pending;
1846                                                     }
1847           6                                 41      return $num_events;
1848                                                  }
1849                                                  
1850                                                  sub _d {
1851  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1852  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1853  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1854                                                          @_;
1855  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1856                                                  }
1857                                                  
1858                                                  1;
1859                                                  
1860                                                  # ###########################################################################
1861                                                  # End SlowLogParser package
1862                                                  # ###########################################################################
1863                                                  
1864                                                  # ###########################################################################
1865                                                  # EventAggregator package 3966
1866                                                  # ###########################################################################
1867                                                  package EventAggregator;
1868                                                  
1869           1                    1             7   use strict;
               1                                  3   
               1                                  5   
1870           1                    1             5   use warnings FATAL => 'all';
               1                                  3   
               1                                  6   
1871           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  5   
1872                                                  
1873           1                    1            11   use constant MKDEBUG      => $ENV{MKDEBUG};
               1                                  2   
               1                                 15   
1874           1                    1             6   use constant BUCK_SIZE    => 1.05;
               1                                  3   
               1                                  4   
1875           1                    1             6   use constant BASE_LOG     => log(BUCK_SIZE);
               1                                  2   
               1                                  5   
1876           1                    1             6   use constant BASE_OFFSET  => abs(1 - log(0.000001) / BASE_LOG); # 284.1617969
               1                                  7   
               1                                  5   
1877           1                    1             5   use constant NUM_BUCK     => 1000;
               1                                  3   
               1                                  5   
1878           1                    1             5   use constant MIN_BUCK     => .000001;
               1                                  2   
               1                                  5   
1879                                                  
1880                                                  our @buckets  = map { 0 } (0..NUM_BUCK-1);
1881                                                  
1882                                                  my @buck_vals = map { bucket_value($_); } (0..NUM_BUCK-1);
1883                                                  
1884                                                  sub new {
1885  ***      0                    0             0      my ( $class, %args ) = @_;
1886  ***      0                                  0      foreach my $arg ( qw(groupby worst) ) {
1887  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1888                                                     }
1889  ***      0             0                    0      my $attributes = $args{attributes} || {};
1890  ***      0                                  0      return bless {
1891                                                        groupby        => $args{groupby},
1892                                                        detect_attribs => scalar keys %$attributes == 0 ? 1 : 0,
1893                                                        all_attribs    => [ keys %$attributes ],
1894                                                        ignore_attribs => {
1895  ***      0                                  0            map  { $_ => $args{attributes}->{$_} }
1896  ***      0                                  0            grep { $_ ne $args{groupby} }
1897  ***      0                                  0            @{$args{ignore_attributes}}
1898                                                        },
1899                                                        attributes     => {
1900  ***      0                                  0            map  { $_ => $args{attributes}->{$_} }
1901  ***      0      0      0                    0            grep { $_ ne $args{groupby} }
1902                                                           keys %$attributes
1903                                                        },
1904                                                        worst        => $args{worst},
1905                                                        unroll_limit => $args{unroll_limit} || 50,
1906                                                        attrib_limit => $args{attrib_limit},
1907                                                        result_classes => {},
1908                                                        result_globals => {},
1909                                                        result_samples => {},
1910                                                        n_events       => 0,
1911                                                     }, $class;
1912                                                  }
1913                                                  
1914                                                  sub reset_aggregated_data {
1915  ***      0                    0             0      my ( $self ) = @_;
1916  ***      0                                  0      foreach my $class ( values %{$self->{result_classes}} ) {
      ***      0                                  0   
1917  ***      0                                  0         foreach my $attrib ( values %$class ) {
1918  ***      0                                  0            delete @{$attrib}{keys %$attrib};
      ***      0                                  0   
1919                                                        }
1920                                                     }
1921  ***      0                                  0      foreach my $class ( values %{$self->{result_globals}} ) {
      ***      0                                  0   
1922  ***      0                                  0         delete @{$class}{keys %$class};
      ***      0                                  0   
1923                                                     }
1924  ***      0                                  0      delete @{$self->{result_samples}}{keys %{$self->{result_samples}}};
      ***      0                                  0   
      ***      0                                  0   
1925  ***      0                                  0      $self->{n_events} = 0;
1926                                                  }
1927                                                  
1928                                                  sub aggregate {
1929  ***      0                    0             0      my ( $self, $event ) = @_;
1930                                                  
1931  ***      0                                  0      my $group_by = $event->{$self->{groupby}};
1932  ***      0      0                           0      return unless defined $group_by;
1933                                                  
1934  ***      0      0                           0      $self->add_new_attributes($event) if $self->{detect_attribs};
1935                                                  
1936  ***      0                                  0      $self->{n_events}++;
1937                                                  
1938  ***      0      0                           0      if ( exists $self->{unrolled_loops} ) {
1939  ***      0                                  0         return $self->{unrolled_loops}->($self, $event, $group_by);
1940                                                     }
1941                                                  
1942  ***      0                                  0      my @attrs = sort keys %{$self->{attributes}};
      ***      0                                  0   
1943                                                     ATTRIB:
1944  ***      0                                  0      foreach my $attrib ( @attrs ) {
1945  ***      0      0                           0         next ATTRIB unless exists $event->{$attrib};
1946                                                        GROUPBY:
1947  ***      0      0                           0         foreach my $val ( ref $group_by ? @$group_by : ($group_by) ) {
1948  ***      0             0                    0            my $class_attrib  = $self->{result_classes}->{$val}->{$attrib} ||= {};
1949  ***      0             0                    0            my $global_attrib = $self->{result_globals}->{$attrib} ||= {};
1950  ***      0                                  0            my $samples       = $self->{result_samples};
1951  ***      0                                  0            my $handler = $self->{handlers}->{ $attrib };
1952  ***      0      0                           0            if ( !$handler ) {
1953  ***      0                                  0               $handler = $self->make_handler(
1954                                                                 $attrib,
1955                                                                 $event,
1956                                                                 wor => $self->{worst} eq $attrib,
1957                                                                 alt => $self->{attributes}->{$attrib},
1958                                                              );
1959  ***      0                                  0               $self->{handlers}->{$attrib} = $handler;
1960                                                           }
1961  ***      0      0                           0            next GROUPBY unless $handler;
1962  ***      0             0                    0            $samples->{$val} ||= $event; # Initialize to the first event.
1963  ***      0                                  0            $handler->($event, $class_attrib, $global_attrib, $samples, $group_by);
1964                                                        }
1965                                                     }
1966                                                  
1967  ***      0      0      0                    0      if ( $self->{n_queries}++ > 50  # ...after 50 events, or
      ***      0             0                    0   
1968                                                          || ( # all attribs have handlers and
1969                                                               !grep { ref $self->{handlers}->{$_} ne 'CODE' } @attrs
1970                                                               && !$self->{detect_attribs}
1971                                                             ) )
1972                                                     {
1973  ***      0                                  0         my @attrs   = grep { $self->{handlers}->{$_} } @attrs;
      ***      0                                  0   
1974  ***      0                                  0         my $globs   = $self->{result_globals}; # Global stats for each
1975  ***      0                                  0         my $samples = $self->{result_samples};
1976                                                  
1977  ***      0      0                           0         my @lines = (
1978                                                           'my ( $self, $event, $group_by ) = @_;',
1979                                                           'my ($val, $class, $global, $idx);',
1980                                                           (ref $group_by ? ('foreach my $group_by ( @$group_by ) {') : ()),
1981                                                           'my $temp = $self->{result_classes}->{ $group_by }
1982                                                              ||= { map { $_ => { } } @attrs };',
1983                                                           '$samples->{$group_by} ||= $event;', # Always start with the first.
1984                                                        );
1985  ***      0                                  0         foreach my $i ( 0 .. $#attrs ) {
1986  ***      0                                  0            push @lines, (
1987                                                              '$class  = $temp->{"'  . $attrs[$i] . '"};',
1988                                                              '$global = $globs->{"' . $attrs[$i] . '"};',
1989                                                              $self->{unrolled_for}->{$attrs[$i]},
1990                                                           );
1991                                                        }
1992  ***      0      0                           0         if ( ref $group_by ) {
1993  ***      0                                  0            push @lines, '}'; # Close the loop opened above
1994                                                        }
1995  ***      0                                  0         @lines = map { s/^/   /gm; $_ } @lines; # Indent for debugging
      ***      0                                  0   
      ***      0                                  0   
1996  ***      0                                  0         unshift @lines, 'sub {';
1997  ***      0                                  0         push @lines, '}';
1998                                                  
1999  ***      0                                  0         my $code = join("\n", @lines);
2000  ***      0                                  0         MKDEBUG && _d('Unrolled subroutine:', @lines);
2001  ***      0                                  0         my $sub = eval $code;
2002  ***      0      0                           0         die if $EVAL_ERROR;
2003  ***      0                                  0         $self->{unrolled_loops} = $sub;
2004                                                     }
2005                                                  
2006  ***      0                                  0      return;
2007                                                  }
2008                                                  
2009                                                  sub results {
2010  ***      0                    0             0      my ( $self ) = @_;
2011                                                     return {
2012  ***      0                                  0         classes => $self->{result_classes},
2013                                                        globals => $self->{result_globals},
2014                                                        samples => $self->{result_samples},
2015                                                     };
2016                                                  }
2017                                                  
2018                                                  sub attributes {
2019  ***      0                    0             0      my ( $self ) = @_;
2020  ***      0                                  0      return $self->{type_for};
2021                                                  }
2022                                                  
2023                                                  sub type_for {
2024  ***      0                    0             0      my ( $self, $attrib ) = @_;
2025  ***      0                                  0      return $self->{type_for}->{$attrib};
2026                                                  }
2027                                                  
2028                                                  sub make_handler {
2029  ***      0                    0             0      my ( $self, $attrib, $event, %args ) = @_;
2030  ***      0      0                           0      die "I need an attrib" unless defined $attrib;
2031  ***      0                                  0      my ($val) = grep { defined $_ } map { $event->{$_} } @{ $args{alt} };
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
2032  ***      0                                  0      my $is_array = 0;
2033  ***      0      0                           0      if (ref $val eq 'ARRAY') {
2034  ***      0                                  0         $is_array = 1;
2035  ***      0                                  0         $val      = $val->[0];
2036                                                     }
2037  ***      0      0                           0      return unless defined $val; # Can't decide type if it's undef.
2038                                                  
2039  ***      0                                  0      my $float_re = qr{[+-]?(?:(?=\d|[.])\d+(?:[.])\d{0,})(?:E[+-]?\d+)?}i;
2040  ***      0      0                           0      my $type = $val  =~ m/^(?:\d+|$float_re)$/o ? 'num'
      ***             0                               
2041                                                              : $val  =~ m/^(?:Yes|No)$/         ? 'bool'
2042                                                              :                                    'string';
2043  ***      0                                  0      MKDEBUG && _d('Type for', $attrib, 'is', $type,
2044                                                        '(sample:', $val, '), is array:', $is_array);
2045  ***      0                                  0      $self->{type_for}->{$attrib} = $type;
2046                                                  
2047  ***      0      0                           0      %args = ( # Set up defaults
      ***             0                               
      ***             0                               
      ***             0                               
2048                                                        min => 1,
2049                                                        max => 1,
2050                                                        sum => $type =~ m/num|bool/    ? 1 : 0,
2051                                                        cnt => 1,
2052                                                        unq => $type =~ m/bool|string/ ? 1 : 0,
2053                                                        all => $type eq 'num'          ? 1 : 0,
2054                                                        glo => 1,
2055                                                        trf => ($type eq 'bool') ? q{($val || '' eq 'Yes') ? 1 : 0} : undef,
2056                                                        wor => 0,
2057                                                        alt => [],
2058                                                        %args,
2059                                                     );
2060                                                  
2061  ***      0                                  0      my @lines = ("# type: $type"); # Lines of code for the subroutine
2062  ***      0      0                           0      if ( $args{trf} ) {
2063  ***      0                                  0         push @lines, q{$val = } . $args{trf} . ';';
2064                                                     }
2065                                                  
2066  ***      0                                  0      foreach my $place ( qw($class $global) ) {
2067  ***      0                                  0         my @tmp;
2068  ***      0      0                           0         if ( $args{min} ) {
2069  ***      0      0                           0            my $op   = $type eq 'num' ? '<' : 'lt';
2070  ***      0                                  0            push @tmp, (
2071                                                              'PLACE->{min} = $val if !defined PLACE->{min} || $val '
2072                                                                 . $op . ' PLACE->{min};',
2073                                                           );
2074                                                        }
2075  ***      0      0                           0         if ( $args{max} ) {
2076  ***      0      0                           0            my $op = ($type eq 'num') ? '>' : 'gt';
2077  ***      0                                  0            push @tmp, (
2078                                                              'PLACE->{max} = $val if !defined PLACE->{max} || $val '
2079                                                                 . $op . ' PLACE->{max};',
2080                                                           );
2081                                                        }
2082  ***      0      0                           0         if ( $args{sum} ) {
2083  ***      0                                  0            push @tmp, 'PLACE->{sum} += $val;';
2084                                                        }
2085  ***      0      0                           0         if ( $args{cnt} ) {
2086  ***      0                                  0            push @tmp, '++PLACE->{cnt};';
2087                                                        }
2088  ***      0      0                           0         if ( $args{all} ) {
2089  ***      0                                  0            push @tmp, (
2090                                                              'exists PLACE->{all} or PLACE->{all} = [ @buckets ];',
2091                                                              '++PLACE->{all}->[ EventAggregator::bucket_idx($val) ];',
2092                                                           );
2093                                                        }
2094  ***      0                                  0         push @lines, map { s/PLACE/$place/g; $_ } @tmp;
      ***      0                                  0   
      ***      0                                  0   
2095                                                     }
2096                                                  
2097  ***      0      0                           0      if ( $args{unq} ) {
2098  ***      0                                  0         push @lines, '++$class->{unq}->{$val};';
2099                                                     }
2100  ***      0      0                           0      if ( $args{wor} ) {
2101  ***      0      0                           0         my $op = $type eq 'num' ? '>=' : 'ge';
2102  ***      0                                  0         push @lines, (
2103                                                           'if ( $val ' . $op . ' ($class->{max} || 0) ) {',
2104                                                           '   $samples->{$group_by} = $event;',
2105                                                           '}',
2106                                                        );
2107                                                     }
2108                                                  
2109  ***      0                                  0      my @limit;
2110  ***      0      0      0                    0      if ( $args{all} && $type eq 'num' && $self->{attrib_limit} ) {
      ***                    0                        
2111  ***      0                                  0         push @limit, (
2112                                                           "if ( \$val > $self->{attrib_limit} ) {",
2113                                                           '   $val = $class->{last} ||= 0;',
2114                                                           '}',
2115                                                           '$class->{last} = $val;',
2116                                                        );
2117                                                     }
2118                                                  
2119  ***      0                                  0      my @unrolled = (
2120                                                        "\$val = \$event->{'$attrib'};",
2121                                                        ($is_array ? ('foreach my $val ( @$val ) {') : ()),
2122  ***      0                                  0         (map { "\$val = \$event->{'$_'} unless defined \$val;" }
2123  ***      0                                  0            grep { $_ ne $attrib } @{$args{alt}}),
      ***      0                                  0   
2124                                                        'defined $val && do {',
2125  ***      0      0                           0         ( map { s/^/   /gm; $_ } (@limit, @lines) ), # Indent for debugging
      ***      0      0                           0   
2126                                                        '};',
2127                                                        ($is_array ? ('}') : ()),
2128                                                     );
2129  ***      0                                  0      $self->{unrolled_for}->{$attrib} = join("\n", @unrolled);
2130                                                  
2131  ***      0                                  0      unshift @lines, (
2132                                                        'sub {',
2133                                                        'my ( $event, $class, $global, $samples, $group_by ) = @_;',
2134                                                        'my ($val, $idx);', # NOTE: define all variables here
2135                                                        "\$val = \$event->{'$attrib'};",
2136  ***      0                                  0         (map { "\$val = \$event->{'$_'} unless defined \$val;" }
2137  ***      0      0                           0            grep { $_ ne $attrib } @{$args{alt}}),
      ***      0      0                           0   
2138                                                        'return unless defined $val;',
2139                                                        ($is_array ? ('foreach my $val ( @$val ) {') : ()),
2140                                                        @limit,
2141                                                        ($is_array ? ('}') : ()),
2142                                                     );
2143  ***      0                                  0      push @lines, '}';
2144  ***      0                                  0      my $code = join("\n", @lines);
2145  ***      0                                  0      $self->{code_for}->{$attrib} = $code;
2146                                                  
2147  ***      0                                  0      MKDEBUG && _d('Metric handler for', $attrib, ':', @lines);
2148  ***      0                                  0      my $sub = eval join("\n", @lines);
2149  ***      0      0                           0      die if $EVAL_ERROR;
2150  ***      0                                  0      return $sub;
2151                                                  }
2152                                                  
2153                                                  sub bucket_idx {
2154  ***      0                    0             0      my ( $val ) = @_;
2155  ***      0      0                           0      return 0 if $val < MIN_BUCK;
2156  ***      0                                  0      my $idx = int(BASE_OFFSET + log($val)/BASE_LOG);
2157  ***      0      0                           0      return $idx > (NUM_BUCK-1) ? (NUM_BUCK-1) : $idx;
2158                                                  }
2159                                                  
2160                                                  sub bucket_value {
2161        1000                 1000          2941      my ( $bucket ) = @_;
2162        1000    100                        3494      return 0 if $bucket == 0;
2163  ***    999     50     33                 7236      die "Invalid bucket: $bucket" if $bucket < 0 || $bucket > (NUM_BUCK-1);
2164         999                               4498      return (BUCK_SIZE**($bucket-1)) * MIN_BUCK;
2165                                                  }
2166                                                  
2167                                                  {
2168                                                     my @buck_tens;
2169                                                     sub buckets_of {
2170  ***      0      0             0             0         return @buck_tens if @buck_tens;
2171                                                  
2172  ***      0                                  0         my $start_bucket  = 0;
2173  ***      0                                  0         my @base10_starts = (0);
2174  ***      0                                  0         map { push @base10_starts, (10**$_)*MIN_BUCK } (1..7);
      ***      0                                  0   
2175                                                  
2176  ***      0                                  0         for my $base10_bucket ( 0..($#base10_starts-1) ) {
2177  ***      0                                  0            my $next_bucket = bucket_idx( $base10_starts[$base10_bucket+1] );
2178  ***      0                                  0            MKDEBUG && _d('Base 10 bucket $base10_bucket maps to',
2179                                                              'base 1.05 buckets', $start_bucket, '..', $next_bucket-1);
2180  ***      0                                  0            for my $base1_05_bucket ($start_bucket..($next_bucket-1)) {
2181  ***      0                                  0               $buck_tens[$base1_05_bucket] = $base10_bucket;
2182                                                           }
2183  ***      0                                  0            $start_bucket = $next_bucket;
2184                                                        }
2185                                                  
2186  ***      0                                  0         map { $buck_tens[$_] = 7 } ($start_bucket..(NUM_BUCK-1));
      ***      0                                  0   
2187                                                  
2188  ***      0                                  0         return @buck_tens;
2189                                                     }
2190                                                  }
2191                                                  
2192                                                  sub calculate_statistical_metrics {
2193  ***      0                    0             0      my ( $self, $vals, $args ) = @_;
2194  ***      0                                  0      my $statistical_metrics = {
2195                                                        pct_95    => 0,
2196                                                        stddev    => 0,
2197                                                        median    => 0,
2198                                                        cutoff    => undef,
2199                                                     };
2200                                                  
2201  ***      0      0      0                    0      return $statistical_metrics
      ***                    0                        
2202                                                        unless defined $vals && @$vals && $args->{cnt};
2203                                                  
2204  ***      0                                  0      my $n_vals = $args->{cnt};
2205  ***      0      0      0                    0      if ( $n_vals == 1 || $args->{max} == $args->{min} ) {
      ***             0                               
2206  ***      0             0                    0         my $v      = $args->{max} || 0;
2207  ***      0      0                           0         my $bucket = int(6 + ( log($v > 0 ? $v : MIN_BUCK) / log(10)));
2208  ***      0      0                           0         $bucket    = $bucket > 7 ? 7 : $bucket < 0 ? 0 : $bucket;
      ***             0                               
2209                                                        return {
2210  ***      0                                  0            pct_95 => $v,
2211                                                           stddev => 0,
2212                                                           median => $v,
2213                                                           cutoff => $n_vals,
2214                                                        };
2215                                                     }
2216                                                     elsif ( $n_vals == 2 ) {
2217  ***      0                                  0         foreach my $v ( $args->{min}, $args->{max} ) {
2218  ***      0      0      0                    0            my $bucket = int(6 + ( log($v && $v > 0 ? $v : MIN_BUCK) / log(10)));
2219  ***      0      0                           0            $bucket = $bucket > 7 ? 7 : $bucket < 0 ? 0 : $bucket;
      ***             0                               
2220                                                        }
2221  ***      0             0                    0         my $v      = $args->{max} || 0;
2222  ***      0             0                    0         my $mean = (($args->{min} || 0) + $v) / 2;
2223                                                        return {
2224  ***      0                                  0            pct_95 => $v,
2225                                                           stddev => sqrt((($v - $mean) ** 2) *2),
2226                                                           median => $mean,
2227                                                           cutoff => $n_vals,
2228                                                        };
2229                                                     }
2230                                                  
2231  ***      0      0                           0      my $cutoff = $n_vals >= 10 ? int ( $n_vals * 0.95 ) : $n_vals;
2232  ***      0                                  0      $statistical_metrics->{cutoff} = $cutoff;
2233                                                  
2234  ***      0                                  0      my $total_left = $n_vals;
2235  ***      0                                  0      my $top_vals   = $n_vals - $cutoff; # vals > 95th
2236  ***      0                                  0      my $sum_excl   = 0;
2237  ***      0                                  0      my $sum        = 0;
2238  ***      0                                  0      my $sumsq      = 0;
2239  ***      0                                  0      my $mid        = int($n_vals / 2);
2240  ***      0                                  0      my $median     = 0;
2241  ***      0                                  0      my $prev       = NUM_BUCK-1; # Used for getting median when $cutoff is odd
2242  ***      0                                  0      my $bucket_95  = 0; # top bucket in 95th
2243                                                  
2244  ***      0                                  0      MKDEBUG && _d('total vals:', $total_left, 'top vals:', $top_vals, 'mid:', $mid);
2245                                                  
2246                                                     BUCKET:
2247  ***      0                                  0      for my $bucket ( reverse 0..(NUM_BUCK-1) ) {
2248  ***      0                                  0         my $val = $vals->[$bucket];
2249  ***      0      0                           0         next BUCKET unless $val; 
2250                                                  
2251  ***      0                                  0         $total_left -= $val;
2252  ***      0                                  0         $sum_excl   += $val;
2253  ***      0      0      0                    0         $bucket_95   = $bucket if !$bucket_95 && $sum_excl > $top_vals;
2254                                                  
2255  ***      0      0      0                    0         if ( !$median && $total_left <= $mid ) {
2256  ***      0      0      0                    0            $median = (($cutoff % 2) || ($val > 1)) ? $buck_vals[$bucket]
2257                                                                   : ($buck_vals[$bucket] + $buck_vals[$prev]) / 2;
2258                                                        }
2259                                                  
2260  ***      0                                  0         $sum    += $val * $buck_vals[$bucket];
2261  ***      0                                  0         $sumsq  += $val * ($buck_vals[$bucket]**2);
2262  ***      0                                  0         $prev   =  $bucket;
2263                                                     }
2264                                                  
2265  ***      0                                  0      my $var      = $sumsq/$n_vals - ( ($sum/$n_vals) ** 2 );
2266  ***      0      0                           0      my $stddev   = $var > 0 ? sqrt($var) : 0;
2267  ***      0             0                    0      my $maxstdev = (($args->{max} || 0) - ($args->{min} || 0)) / 2;
      ***                    0                        
2268  ***      0      0                           0      $stddev      = $stddev > $maxstdev ? $maxstdev : $stddev;
2269                                                  
2270  ***      0                                  0      MKDEBUG && _d('sum:', $sum, 'sumsq:', $sumsq, 'stddev:', $stddev,
2271                                                        'median:', $median, 'prev bucket:', $prev,
2272                                                        'total left:', $total_left, 'sum excl', $sum_excl,
2273                                                        'bucket 95:', $bucket_95, $buck_vals[$bucket_95]);
2274                                                  
2275  ***      0                                  0      $statistical_metrics->{stddev} = $stddev;
2276  ***      0                                  0      $statistical_metrics->{pct_95} = $buck_vals[$bucket_95];
2277  ***      0                                  0      $statistical_metrics->{median} = $median;
2278                                                  
2279  ***      0                                  0      return $statistical_metrics;
2280                                                  }
2281                                                  
2282                                                  sub metrics {
2283  ***      0                    0             0      my ( $self, %args ) = @_;
2284  ***      0                                  0      foreach my $arg ( qw(attrib where) ) {
2285  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
2286                                                     }
2287  ***      0                                  0      my $stats = $self->results;
2288  ***      0                                  0      my $store = $stats->{classes}->{$args{where}}->{$args{attrib}};
2289                                                  
2290  ***      0                                  0      my $global_cnt = $stats->{globals}->{$args{attrib}}->{cnt};
2291  ***      0                                  0      my $metrics    = $self->calculate_statistical_metrics($store->{all}, $store);
2292                                                  
2293                                                     return {
2294  ***      0      0      0                    0         cnt    => $store->{cnt},
      ***             0      0                        
2295                                                        pct    => $global_cnt && $store->{cnt} ? $store->{cnt} / $global_cnt : 0,
2296                                                        sum    => $store->{sum},
2297                                                        min    => $store->{min},
2298                                                        max    => $store->{max},
2299                                                        avg    => $store->{sum} && $store->{cnt} ? $store->{sum} / $store->{cnt} : 0,
2300                                                        median => $metrics->{median},
2301                                                        pct_95 => $metrics->{pct_95},
2302                                                        stddev => $metrics->{stddev},
2303                                                     };
2304                                                  }
2305                                                  
2306                                                  sub top_events {
2307  ***      0                    0             0      my ( $self, %args ) = @_;
2308  ***      0                                  0      my $classes = $self->{result_classes};
2309  ***      0                                  0      my @sorted = reverse sort { # Sorted list of $groupby values
2310  ***      0                                  0         $classes->{$a}->{$args{attrib}}->{$args{orderby}}
2311                                                           <=> $classes->{$b}->{$args{attrib}}->{$args{orderby}}
2312                                                        } grep {
2313  ***      0                                  0            defined $classes->{$_}->{$args{attrib}}->{$args{orderby}}
2314                                                        } keys %$classes;
2315  ***      0                                  0      my @chosen;
2316  ***      0                                  0      my ($total, $count) = (0, 0);
2317  ***      0                                  0      foreach my $groupby ( @sorted ) {
2318  ***      0      0      0                    0         if ( 
      ***             0      0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
2319                                                           (!$args{total} || $total < $args{total} )
2320                                                           && ( !$args{count} || $count < $args{count} )
2321                                                        ) {
2322  ***      0                                  0            push @chosen, [$groupby, 'top'];
2323                                                        }
2324                                                  
2325                                                        elsif ( $args{ol_attrib} && (!$args{ol_freq}
2326                                                           || $classes->{$groupby}->{$args{ol_attrib}}->{cnt} >= $args{ol_freq})
2327                                                        ) {
2328  ***      0                                  0            MKDEBUG && _d('Calculating statistical_metrics');
2329  ***      0                                  0            my $stats = $self->calculate_statistical_metrics(
2330                                                              $classes->{$groupby}->{$args{ol_attrib}}->{all},
2331                                                              $classes->{$groupby}->{$args{ol_attrib}}
2332                                                           );
2333  ***      0      0                           0            if ( $stats->{pct_95} >= $args{ol_limit} ) {
2334  ***      0                                  0               push @chosen, [$groupby, 'outlier'];
2335                                                           }
2336                                                        }
2337                                                  
2338  ***      0                                  0         $total += $classes->{$groupby}->{$args{attrib}}->{$args{orderby}};
2339  ***      0                                  0         $count++;
2340                                                     }
2341  ***      0                                  0      return @chosen;
2342                                                  }
2343                                                  
2344                                                  sub add_new_attributes {
2345  ***      0                    0             0      my ( $self, $event ) = @_;
2346  ***      0      0                           0      return unless $event;
2347  ***      0                                  0      map {
2348  ***      0      0      0                    0         $self->{attributes}->{$_} = [$_];
2349  ***      0                                  0         push @{$self->{all_attribs}}, $_;
      ***      0                                  0   
2350  ***      0                                  0         MKDEBUG && _d('Added new attribute:', $_);
2351                                                     }
2352                                                     grep {
2353  ***      0                                  0         $_ ne $self->{groupby}
2354                                                        && !exists $self->{attributes}->{$_}
2355                                                        && !exists $self->{ignore_attribs}->{$_}
2356                                                     }
2357                                                     keys %$event;
2358  ***      0                                  0      return;
2359                                                  }
2360                                                  
2361                                                  sub get_attributes {
2362  ***      0                    0             0      my ( $self ) = @_;
2363  ***      0                                  0      return @{$self->{all_attribs}};
      ***      0                                  0   
2364                                                  }
2365                                                  
2366                                                  sub events_processed {
2367  ***      0                    0             0      my ( $self ) = @_;
2368  ***      0                                  0      return $self->{n_events};
2369                                                  }
2370                                                  
2371                                                  sub _d {
2372  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2373  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2374  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2375                                                          @_;
2376  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2377                                                  }
2378                                                  
2379                                                  1;
2380                                                  
2381                                                  # ###########################################################################
2382                                                  # End EventAggregator package
2383                                                  # ###########################################################################
2384                                                  
2385                                                  # ###########################################################################
2386                                                  # QueryParser package 3637
2387                                                  # ###########################################################################
2388                                                  package QueryParser;
2389                                                  
2390           1                    1             9   use strict;
               1                                  3   
               1                                  5   
2391           1                    1            10   use warnings FATAL => 'all';
               1                                  3   
               1                                  7   
2392           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  7   
2393                                                  
2394           1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  7   
2395                                                  our $tbl_ident = qr/(?:`[^`]+`|\w+)(?:\.(?:`[^`]+`|\w+))?/;
2396                                                  our $tbl_regex = qr{
2397                                                           \b(?:FROM|JOIN|(?<!KEY\s)UPDATE|INTO) # Words that precede table names
2398                                                           \b\s*
2399                                                           ($tbl_ident
2400                                                              (?: (?:\s+ (?:AS\s+)? \w+)?, \s*$tbl_ident )*
2401                                                           )
2402                                                        }xio;
2403                                                  our $has_derived = qr{
2404                                                        \b(?:FROM|JOIN|,)
2405                                                        \s*\(\s*SELECT
2406                                                     }xi;
2407                                                  
2408                                                  sub new {
2409  ***      0                    0             0      my ( $class ) = @_;
2410  ***      0                                  0      bless {}, $class;
2411                                                  }
2412                                                  
2413                                                  sub get_tables {
2414  ***      0                    0             0      my ( $self, $query ) = @_;
2415  ***      0      0                           0      return unless $query;
2416  ***      0                                  0      MKDEBUG && _d('Getting tables for', $query);
2417                                                  
2418  ***      0                                  0      $query =~ s/ (?:LOW_PRIORITY|IGNORE|STRAIGHT_JOIN)//ig;
2419                                                  
2420  ***      0                                  0      $query =~ s/\\["']//g;                # quoted strings
2421  ***      0                                  0      $query =~ s/".*?"/?/sg;               # quoted strings
2422  ***      0                                  0      $query =~ s/'.*?'/?/sg;               # quoted strings
2423                                                  
2424  ***      0                                  0      my @tables;
2425  ***      0                                  0      foreach my $tbls ( $query =~ m/$tbl_regex/gio ) {
2426  ***      0                                  0         MKDEBUG && _d('Match tables:', $tbls);
2427  ***      0                                  0         foreach my $tbl ( split(',', $tbls) ) {
2428  ***      0                                  0            $tbl =~ s/\s*($tbl_ident)(\s+.*)?/$1/gio;
2429  ***      0                                  0            push @tables, $tbl;
2430                                                        }
2431                                                     }
2432  ***      0                                  0      return @tables;
2433                                                  }
2434                                                  
2435                                                  sub has_derived_table {
2436  ***      0                    0             0      my ( $self, $query ) = @_;
2437  ***      0                                  0      my $match = $query =~ m/$has_derived/;
2438  ***      0                                  0      MKDEBUG && _d($query, 'has ' . ($match ? 'a' : 'no') . ' derived table');
2439  ***      0                                  0      return $match;
2440                                                  }
2441                                                  
2442                                                  sub get_aliases {
2443  ***      0                    0             0      my ( $self, $query ) = @_;
2444  ***      0      0                           0      return unless $query;
2445  ***      0                                  0      my $aliases;
2446                                                  
2447  ***      0                                  0      $query =~ s/ (?:LOW_PRIORITY|IGNORE|STRAIGHT_JOIN)//ig;
2448                                                  
2449  ***      0                                  0      $query =~ s/ (?:INNER|OUTER|CROSS|LEFT|RIGHT|NATURAL)//ig;
2450                                                  
2451  ***      0                                  0      my ($tbl_refs, $from) = $query =~ m{
2452                                                        (
2453                                                           (FROM|INTO|UPDATE)\b\s*   # Keyword before table refs
2454                                                           .+?                       # Table refs
2455                                                        )
2456                                                        (?:\s+|\z)                   # If the query does not end with the table
2457                                                        (?:WHERE|ORDER|LIMIT|HAVING|SET|VALUES|\z) # Keyword after table refs
2458                                                     }ix;
2459                                                  
2460  ***      0      0      0                    0      die "Failed to parse table references from $query"
2461                                                        unless $tbl_refs && $from;
2462                                                  
2463  ***      0                                  0      MKDEBUG && _d('tbl refs:', $tbl_refs);
2464                                                  
2465  ***      0                                  0      my $before_tbl = qr/(?:,|JOIN|\s|$from)+/i;
2466                                                  
2467  ***      0                                  0      my $after_tbl  = qr/(?:,|JOIN|ON|USING|\z)/i;
2468                                                  
2469  ***      0                                  0      $tbl_refs =~ s/ = /=/g;
2470                                                  
2471  ***      0                                  0      while (
2472                                                        $tbl_refs =~ m{
2473                                                           $before_tbl\b\s*
2474                                                              ( ($tbl_ident) (?:\s+ (?:AS\s+)? (\w+))? )
2475                                                           \s*$after_tbl
2476                                                        }xgio )
2477                                                     {
2478  ***      0                                  0         my ( $tbl_ref, $db_tbl, $alias ) = ($1, $2, $3);
2479  ***      0                                  0         MKDEBUG && _d('Match table:', $tbl_ref);
2480                                                  
2481  ***      0      0                           0         if ( $tbl_ref =~ m/^AS\s+\w+/i ) {
2482  ***      0                                  0            MKDEBUG && _d('Subquery', $tbl_ref);
2483  ***      0                                  0            $aliases->{$alias} = undef;
2484  ***      0                                  0            next;
2485                                                        }
2486                                                  
2487  ***      0                                  0         my ( $db, $tbl ) = $db_tbl =~ m/^(?:(.*?)\.)?(.*)/;
2488  ***      0             0                    0         $aliases->{$alias || $tbl} = $tbl;
2489  ***      0      0                           0         $aliases->{DATABASE}->{$tbl} = $db if $db;
2490                                                     }
2491  ***      0                                  0      return $aliases;
2492                                                  }
2493                                                  
2494                                                  sub _d {
2495  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2496  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2497  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2498                                                          @_;
2499  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2500                                                  }
2501                                                  
2502                                                  1;
2503                                                  
2504                                                  # ###########################################################################
2505                                                  # End QueryParser package
2506                                                  # ###########################################################################
2507                                                  
2508                                                  # ###########################################################################
2509                                                  # Daemon package 3976
2510                                                  # ###########################################################################
2511                                                  
2512                                                  package Daemon;
2513                                                  
2514           1                    1             7   use strict;
               1                                  3   
               1                                 13   
2515           1                    1             5   use warnings FATAL => 'all';
               1                                  3   
               1                                  5   
2516                                                  
2517           1                    1            13   use POSIX qw(setsid);
               1                                  2   
               1                                  8   
2518           1                    1             7   use English qw(-no_match_vars);
               1                                  2   
               1                                  8   
2519                                                  
2520           1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  9   
2521                                                  
2522                                                  sub new {
2523  ***      0                    0             0      my ( $class, %args ) = @_;
2524  ***      0                                  0      foreach my $arg ( qw(o) ) {
2525  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
2526                                                     }
2527  ***      0                                  0      my $o = $args{o};
2528  ***      0      0                           0      my $self = {
      ***             0                               
2529                                                        o        => $o,
2530                                                        log_file => $o->has('log') ? $o->get('log') : undef,
2531                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
2532                                                     };
2533                                                  
2534  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
2535                                                  
2536  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
2537  ***      0                                  0      return bless $self, $class;
2538                                                  }
2539                                                  
2540                                                  sub daemonize {
2541  ***      0                    0             0      my ( $self ) = @_;
2542                                                  
2543  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
2544  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
2545  ***      0      0                           0      if ( $pid ) {
2546  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
2547  ***      0                                  0         exit;
2548                                                     }
2549                                                  
2550  ***      0                                  0      $self->{child} = 1;
2551                                                  
2552  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
2553  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
2554                                                  
2555  ***      0                                  0      $self->_make_PID_file();
2556                                                  
2557  ***      0      0                           0      if ( -t STDIN ) {
2558  ***      0                                  0         close STDIN;
2559  ***      0      0                           0         open  STDIN, '/dev/null'
2560                                                           or die "Cannot reopen STDIN to /dev/null";
2561                                                     }
2562                                                  
2563  ***      0      0                           0      if ( $self->{log_file} ) {
2564  ***      0                                  0         close STDOUT;
2565  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
2566                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
2567                                                  
2568  ***      0                                  0         close STDERR;
2569  ***      0      0                           0         open  STDERR, ">&STDOUT"
2570                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR";
2571                                                     }
2572                                                  
2573  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
2574  ***      0                                  0      return;
2575                                                  }
2576                                                  
2577                                                  sub check_PID_file {
2578  ***      0                    0             0      my ( $self, $file ) = @_;
2579  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
2580  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
2581  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
2582  ***      0                                  0         my $pid;
2583  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
2584  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
2585  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
2586  ***      0      0                           0         if ( $pid ) {
2587  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
2588  ***      0      0                           0            if ( $pid_is_alive ) {
2589  ***      0                                  0               die "The PID file $PID_file already exists "
2590                                                                 . " and the PID that it contains, $pid, is running";
2591                                                           }
2592                                                           else {
2593  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
2594                                                                 . "contains, $pid, is not running";
2595                                                           }
2596                                                        }
2597                                                        else {
2598  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
2599                                                              . "contain a PID";
2600                                                        }
2601                                                     }
2602                                                     else {
2603  ***      0                                  0         MKDEBUG && _d('No PID file');
2604                                                     }
2605  ***      0                                  0      return;
2606                                                  }
2607                                                  
2608                                                  sub make_PID_file {
2609  ***      0                    0             0      my ( $self ) = @_;
2610  ***      0      0                           0      if ( exists $self->{child} ) {
2611  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
2612                                                     }
2613  ***      0                                  0      $self->_make_PID_file();
2614  ***      0                                  0      $self->{rm_PID_file} = 1;
2615  ***      0                                  0      return;
2616                                                  }
2617                                                  
2618                                                  sub _make_PID_file {
2619  ***      0                    0             0      my ( $self ) = @_;
2620                                                  
2621  ***      0                                  0      my $PID_file = $self->{PID_file};
2622  ***      0      0                           0      if ( !$PID_file ) {
2623  ***      0                                  0         MKDEBUG && _d('No PID file to create');
2624  ***      0                                  0         return;
2625                                                     }
2626                                                  
2627  ***      0                                  0      $self->check_PID_file();
2628                                                  
2629  ***      0      0                           0      open my $PID_FH, '>', $PID_file
2630                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
2631  ***      0      0                           0      print $PID_FH $PID
2632                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
2633  ***      0      0                           0      close $PID_FH
2634                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
2635                                                  
2636  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
2637  ***      0                                  0      return;
2638                                                  }
2639                                                  
2640                                                  sub _remove_PID_file {
2641  ***      0                    0             0      my ( $self ) = @_;
2642  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
2643  ***      0      0                           0         unlink $self->{PID_file}
2644                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
2645  ***      0                                  0         MKDEBUG && _d('Removed PID file');
2646                                                     }
2647                                                     else {
2648  ***      0                                  0         MKDEBUG && _d('No PID to remove');
2649                                                     }
2650  ***      0                                  0      return;
2651                                                  }
2652                                                  
2653                                                  sub DESTROY {
2654  ***      0                    0             0      my ( $self ) = @_;
2655  ***      0      0      0                    0      $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
2656  ***      0                                  0      return;
2657                                                  }
2658                                                  
2659                                                  sub _d {
2660  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2661  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2662  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2663                                                          @_;
2664  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2665                                                  }
2666                                                  
2667                                                  1;
2668                                                  
2669                                                  # ###########################################################################
2670                                                  # End Daemon package
2671                                                  # ###########################################################################
2672                                                  
2673                                                  # ###########################################################################
2674                                                  # QueryExecutor package 4003
2675                                                  # ###########################################################################
2676                                                  package QueryExecutor;
2677                                                  
2678           1                    1             8   use strict;
               1                                  3   
               1                                  6   
2679           1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  7   
2680                                                  
2681           1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  6   
2682           1                    1            13   use Time::HiRes qw(time);
               1                                  3   
               1                                  5   
2683                                                  
2684           1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  9   
2685                                                  
2686                                                  sub new {
2687           2                    2            10      my ( $class, %args ) = @_;
2688           2                                 11      foreach my $arg ( qw() ) {
2689  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
2690                                                     }
2691           2                                  6      my $self = {
2692                                                     };
2693           2                                 21      return bless $self, $class;
2694                                                  }
2695                                                  
2696                                                  sub exec {
2697           4                    4            37      my ( $self, %args ) = @_;
2698           4                                 21      foreach my $arg ( qw(query host1_dbh host2_dbh) ) {
2699  ***     12     50                          55         die "I need a $arg argument" unless $args{$arg};
2700                                                     }
2701                                                     return {
2702           4                                 24         host1 => $self->_exec_query($args{query}, $args{host1_dbh}),
2703                                                        host2 => $self->_exec_query($args{query}, $args{host2_dbh}),
2704                                                     };
2705                                                  }
2706                                                  
2707                                                  sub _exec_query {
2708           8                    8            35      my ( $self, $query, $dbh ) = @_;
2709  ***      8     50                          33      die "I need a query" unless $query;
2710  ***      8     50                          25      die "I need a dbh"   unless $dbh;
2711                                                  
2712           8                                 24      my ( $start, $end, $query_time );
2713           8                                 21      eval {
2714           8                                 44         $start = time();
2715           8                                747         $dbh->do($query);
2716           4                                 25         $end   = time();
2717           4                                 69         $query_time = sprintf '%.6f', $end - $start;
2718                                                     };
2719           8    100                          43      if ( $EVAL_ERROR ) {
2720           4                                 37         return $EVAL_ERROR;
2721                                                     }
2722                                                  
2723           4                                 11      my $warnings = $dbh->selectall_hashref('SHOW WARNINGS', 'Code');
2724           4                                 81      my $warning_count = @{$dbh->selectall_arrayref('SELECT @@warning_count',
               4                                 44   
2725                                                        { Slice => {} })}[0]->{'@@warning_count'};
2726                                                  
2727           4                                 48      my $results = {
2728                                                        Query_time    => $query_time,
2729                                                        warnings      => $warnings,
2730                                                        warning_count => $warning_count,
2731                                                     };
2732                                                  
2733           4                                 30      return $results;
2734                                                  }   
2735                                                  
2736                                                  sub _d {
2737  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2738  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2739  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2740                                                          @_;
2741  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2742                                                  }
2743                                                  
2744                                                  1;
2745                                                  
2746                                                  # ###########################################################################
2747                                                  # End QueryExecutor package
2748                                                  # ###########################################################################
2749                                                  
2750                                                  # ###########################################################################
2751                                                  # QueryRanker package 4002
2752                                                  # ###########################################################################
2753                                                  package QueryRanker;
2754                                                  
2755                                                  
2756           1                    1             7   use strict;
               1                                  3   
               1                                  5   
2757           1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  7   
2758                                                  
2759           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  5   
2760           1                    1             6   use POSIX qw(floor);
               1                                  2   
               1                                  6   
2761                                                  
2762           1                    1             5   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  6   
2763                                                  
2764                                                  my @bucket_threshold = qw(500 100  100   500 50   50    20 1   );
2765                                                  my @bucket_labels    = qw(1us 10us 100us 1ms 10ms 100ms 1s 10s+);
2766                                                  
2767                                                  sub new {
2768           2                    2            10      my ( $class, %args ) = @_;
2769           2                                  9      foreach my $arg ( qw() ) {
2770  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
2771                                                     }
2772           2                                 12      my $self = {
2773                                                     };
2774           2                                 18      return bless $self, $class;
2775                                                  }
2776                                                  
2777                                                  sub rank {
2778           2                    2             9      my ( $self, $results ) = @_;
2779  ***      2     50                           7      die "I need a results argument" unless $results;
2780                                                     
2781           2                                  6      my $rank    = 0;   # total rank
2782           2                                  6      my @reasons = ();  # all reasons
2783           2                                  6      my @res     = ();  # ($rank, @reasons) for each comparison
2784           2                                  8      my $host1   = $results->{host1};
2785           2                                  6      my $host2   = $results->{host2};
2786                                                  
2787           2                                 15      @res = $self->compare_query_times($host1->{Query_time},$host2->{Query_time});
2788           2                                  6      $rank += shift @res;
2789           2                                  6      push @reasons, @res;
2790                                                  
2791  ***      2     50     33                   24      if ( $host1->{warning_count} > 0 || $host2->{warning_count} > 0 ) {
2792  ***      0                                  0         $rank += 1;
2793  ***      0                                  0         push @reasons, "Query has warnings (rank+1)";
2794                                                     }
2795                                                  
2796  ***      2     50                          14      if ( my $diff = abs($host1->{warning_count} - $host2->{warning_count}) ) {
2797  ***      0                                  0         $rank += $diff;
2798  ***      0                                  0         push @reasons, "Warning counts differ by $diff (rank+$diff)";
2799                                                     }
2800                                                  
2801           2                                 13      @res = $self->compare_warnings($host1->{warnings}, $host2->{warnings});
2802           2                                  6      $rank += shift @res;
2803           2                                  6      push @reasons, @res;
2804                                                  
2805           2                                  8      return $rank, @reasons;
2806                                                  }
2807                                                  
2808                                                  sub compare_query_times {
2809           2                    2            11      my ( $self, $t1, $t2 ) = @_;
2810  ***      2     50                           9      die "I need a t1 argument" unless defined $t1;
2811  ***      2     50                           8      die "I need a t2 argument" unless defined $t2;
2812                                                  
2813           2                                 14      my $t1_bucket = bucket_for($t1);
2814           2                                  6      my $t2_bucket = bucket_for($t2);
2815                                                  
2816  ***      2     50                           9      if ( $t1_bucket != $t2_bucket ) {
2817  ***      0                                  0         my $rank_inc = 2 * abs($t1_bucket - $t2_bucket);
2818  ***      0                                  0         return $rank_inc, "Query times differ significantly: "
2819                                                           . "host1 in ".$bucket_labels[$t1_bucket]." range, "
2820                                                           . "host2 in ".$bucket_labels[$t2_bucket]." range (rank+2)";
2821                                                     }
2822                                                  
2823           2                                 10      my $inc = percentage_increase($t1, $t2);
2824  ***      2     50                          12      if ( $inc >= $bucket_threshold[$t1_bucket] ) {
2825  ***      0                                  0         return 1, "Query time increase $inc\% exceeds "
2826                                                           . $bucket_threshold[$t1_bucket] . "\% increase threshold for "
2827                                                           . $bucket_labels[$t1_bucket] . " range (rank+1)";
2828                                                     }
2829                                                  
2830           2                                  8      return (0);  # No significant difference.
2831                                                  }
2832                                                  
2833                                                  sub compare_warnings {
2834           2                    2            10      my ( $self, $warnings1, $warnings2 ) = @_;
2835  ***      2     50                           9      die "I need a warnings1 argument" unless defined $warnings1;
2836  ***      2     50                           8      die "I need a warnings2 argument" unless defined $warnings2;
2837                                                  
2838           2                                  5      my %new_warnings;
2839           2                                  5      my $rank_inc = 0;
2840           2                                  6      my @reasons;
2841                                                  
2842           2                                 12      foreach my $code ( keys %$warnings1 ) {
2843  ***      0      0                           0         if ( exists $warnings2->{$code} ) {
2844  ***      0      0                           0            if ( $warnings2->{$code}->{Level} ne $warnings1->{$code}->{Level} ) {
2845  ***      0                                  0               $rank_inc += 2;
2846  ***      0                                  0               push @reasons, "Error $code changes level: "
2847                                                                 . $warnings1->{$code}->{Level} . " on host1, "
2848                                                                 . $warnings2->{$code}->{Level} . " on host2 (rank+2)";
2849                                                           }
2850                                                        }
2851                                                        else {
2852  ***      0                                  0            MKDEBUG && _d('New warning in warnings1:', $code);
2853  ***      0                                  0            push @reasons, "Error $code on host1 is new (rank+3)";
2854  ***      0                                  0            %{ $new_warnings{$code} } = %{ $warnings1->{$code} };
      ***      0                                  0   
      ***      0                                  0   
2855                                                        }
2856                                                     }
2857                                                  
2858           2                                  9      foreach my $code ( keys %$warnings2 ) {
2859  ***      0      0      0                    0         if ( !exists $warnings1->{$code} && !exists $new_warnings{$code} ) {
2860  ***      0                                  0            MKDEBUG && _d('New warning in warnings2:', $code);
2861  ***      0                                  0            push @reasons, "Error $code on host2 is new (rank+3)";
2862  ***      0                                  0            %{ $new_warnings{$code} } = %{ $warnings2->{$code} };
      ***      0                                  0   
      ***      0                                  0   
2863                                                        }
2864                                                     }
2865                                                  
2866           2                                  8      $rank_inc += 3 * scalar keys %new_warnings;
2867                                                  
2868                                                  
2869           2                                 15      return $rank_inc, @reasons;
2870                                                  }
2871                                                  
2872                                                  sub bucket_for {
2873           4                    4            16      my ( $val ) = @_;
2874  ***      4     50                          15      die "I need a val" unless defined $val;
2875  ***      4     50                          21      return 0 if $val == 0;
2876           4                                 47      my $bucket = floor(log($val) / log(10)) + 6;
2877  ***      4     50                          20      $bucket = $bucket > 7 ? 7 : $bucket < 0 ? 0 : $bucket;
      ***            50                               
2878           4                                 15      return $bucket;
2879                                                  }
2880                                                  
2881                                                  sub percentage_increase {
2882           2                    2             9      my ( $x, $y ) = @_;
2883  ***      2     50                          12      return 0 if $x == $y;
2884                                                  
2885  ***      2     50                           9      if ( $x > $y ) {
2886           2                                  5         my $z = $y;
2887           2                                  5            $y = $x;
2888           2                                  6            $x = $z;
2889                                                     }
2890                                                  
2891  ***      2     50                           8      if ( $x == 0 ) {
2892  ***      0                                  0         return 1000;  # This should trigger all buckets' thresholds.
2893                                                     }
2894                                                  
2895           2                                 28      return sprintf '%.2f', (($y - $x) / $x) * 100;
2896                                                  }
2897                                                  
2898                                                  sub _d {
2899  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2900  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2901  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2902                                                          @_;
2903  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2904                                                  }
2905                                                  
2906                                                  1;
2907                                                  
2908                                                  # ###########################################################################
2909                                                  # End QueryRanker package
2910                                                  # ###########################################################################
2911                                                  
2912                                                  # ###########################################################################
2913                                                  # This is a combination of modules and programs in one -- a runnable module.
2914                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
2915                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
2916                                                  #
2917                                                  # Check at the end of this package for the call to main() which actually runs
2918                                                  # the program.
2919                                                  # ###########################################################################
2920                                                  package mk_upgrade;
2921                                                  
2922           1                    1             7   use English qw(-no_match_vars);
               1                                  2   
               1                                  7   
2923           1                    1             7   use Time::HiRes qw(time);
               1                                  3   
               1                                  4   
2924           1                    1             6   use Data::Dumper;
               1                                  2   
               1                                  8   
2925                                                  $Data::Dumper::Indent    = 1;
2926                                                  $Data::Dumper::Sortkeys  = 1;
2927                                                  $Data::Dumper::Quotekeys = 0;
2928                                                  
2929                                                  Transformers->import(qw());
2930                                                  
2931           1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  8   
2932                                                  
2933           1                    1            12   use sigtrap 'handler', \&sig_int, 'normal-signals';
               1                                  3   
               1                                 13   
2934                                                  
2935                                                  # Global variables.  Only really essential variables should be here.
2936                                                  my $oktorun = 1;
2937                                                  
2938                                                  sub main {
2939           2                    2            45      @ARGV = @_;  # set global ARGV for this package
2940                                                  
2941                                                     # ##########################################################################
2942                                                     # Get configuration information.
2943                                                     # ##########################################################################
2944           2                                 27      my $dp = new DSNParser();
2945           2                                 30      my $o  = new OptionParser(
2946                                                        strict      => 0,
2947                                                        dp          => $dp,
2948                                                        prompt      => '[OPTION...] HOST-1-DSN HOST-2-DSN FILE',
2949                                                        description => q{compares two hosts by executing queries in the given }
2950                                                                     . q{file (or STDIN if no file given) and examining the }
2951                                                                     . q{results, errors, warnings, etc. produced on each.},
2952                                                     );
2953           2                                 12      $o->get_specs();
2954           2                                 18      $o->get_opts();
2955                                                  
2956  ***      2     50                          11      if ( !$o->get('help') ) {
2957  ***      2     50                          10         if ( @ARGV < 2 ) {
2958  ***      0                                  0            $o->save_error('Specify at least two host DSNs');
2959                                                        }
2960                                                     }
2961                                                  
2962           2                                 14      $o->usage_or_errors();
2963                                                  
2964                                                     # ########################################################################
2965                                                     # Parse the host DSNs and make sure that we can connect to each.
2966                                                     # ########################################################################
2967                                                     # TODO: make sure host2 dsn inherits from host1 dsn.
2968           2                                 16      my $host1_dsn = $dp->parse(shift @ARGV);
2969           2                                 15      my $host1_dbh = get_cxn($dp, $o, $host1_dsn);
2970           2                                 15      my $host2_dbh = get_cxn($dp, $o, $dp->parse(shift @ARGV, $host1_dsn));
2971                                                  
2972                                                  
2973                                                     # ########################################################################
2974                                                     # Make some common modules.
2975                                                     # ########################################################################
2976           2                                 36      my $parser  = new SlowLogParser();
2977           2                                 26      my $qexec   = new QueryExecutor();
2978           2                                 21      my $qranker = new QueryRanker();
2979                                                  
2980                                                  
2981                                                     # ########################################################################
2982                                                     # Set up an array of callbacks to transform, filter and process events.
2983                                                     # Results are saved in %results and compared and reported after all
2984                                                     # events have been processed.
2985                                                     # ########################################################################
2986           2                                  6      my @callbacks;
2987           2                                  7      my %results;
2988                                                  
2989                                                     # For the moment we only support deterministic SELECT queries.
2990                                                     # There's no filter/transformation for non-deterministic functions yet,
2991                                                     # just a simple filter to remove non-SELECTs.
2992                                                     # TODO: this will become QueryFilter.
2993                                                     push @callbacks, sub {
2994           4                    4            16         my ( $event ) = @_;
2995  ***      4     50                          24         return unless $event->{cmd} eq 'Query';
2996  ***      4     50                          18         return unless $event->{arg};
2997  ***      4     50                          38         return $event if $event->{arg} =~ m/^SELECT/i;  # Query passes.
2998  ***      0                                  0         return;  # Non-SELECT; query fails.
2999           2                                 24      };
3000                                                  
3001                                                     # User-defined filter.
3002  ***      2     50                          10      if ( $o->get('filter') ) {
3003  ***      0                                  0         my $filter = $o->get('filter');
3004  ***      0                                  0         my $code   = "sub { my (\$event) = shift; $filter && return \$event; };";
3005  ***      0                                  0         MKDEBUG && _d('--filter code:', $code);
3006  ***      0      0                           0         my $sub = eval $code or die;
3007  ***      0                                  0         push @callbacks, $sub;
3008                                                     }
3009                                                  
3010                                                     # Now we should have only the queries that we want, and they should
3011                                                     # have all appropriate transformations.  The real work begins here.
3012                                                  
3013                                                     # Execute and time the query on each host.
3014           2                                  6      my $current_db;
3015                                                     push @callbacks, sub {
3016  ***      4            50      4            16         my ( $event ) = @_;
      ***                   50                        
3017           4                                 16         my $db    = $event->{db}; 
3018           4                                 16         my $query = $event->{arg};
3019                                                  
3020                                                        # Set rank=0 so that any potential rank+=N ops won't die because
3021                                                        # rank is undef.
3022  ***      4            50                  593         $results{ $query }->{rank}    ||= 0;
3023  ***      4            50                   22         $results{ $query }->{reasons} ||= ();
3024                                                  
3025           4                                 10         eval {
3026  ***      4    100     66                   45            if ( $db && (!$current_db || $db ne $current_db) ) {
      ***                   66                        
3027           2                                  5               MKDEBUG && _d('USE', $db);
3028           2                                284               $host1_dbh->do("USE $db");
3029           2                                172               $host2_dbh->do("USE $db");  
3030           2                                  9               $current_db = $db;
3031                                                           }
3032                                                  
3033           4                                 28            my $results = $qexec->exec(
3034                                                              query     => $query,
3035                                                              host1_dbh => $host1_dbh,
3036                                                              host2_dbh => $host2_dbh,
3037                                                           );
3038                                                           # Results are compared and reported later.
3039           4                                 24            $results{ $query }->{execution} = $results;
3040                                                        };
3041  ***      4     50                          17         if ( $EVAL_ERROR ) {
3042  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
3043                                                           # Normally results are hashrefs, but strings signal no results
3044                                                           # due to the error given in the string.
3045  ***      0                                  0            $results{ $query }->{execution} = $EVAL_ERROR;
3046                                                        }
3047           4                                 25         return $event;
3048           2                                 22      };
3049                                                  
3050                                                     # Rank the query's execution and warnings.
3051                                                     push @callbacks, sub {
3052           4                    4            16         my ( $event ) = @_;
3053           4                                 18         my $query = $event->{arg};
3054  ***      4    100     66                   40         if ( ref $results{ $query }->{execution}->{host1}
3055                                                             && ref $results{ $query }->{execution}->{host2} ) {
3056           2                                 16            my @results = $qranker->rank( $results{ $query }->{execution} ); 
3057           2                                  8            $results{ $query }->{rank} += shift @results;
3058           2                                  6            push @{$results{ $query }->{reasons}}, @results;
               2                                 10   
3059                                                        }
3060                                                        else {
3061           2                                  5            MKDEBUG && _d('No results for event');
3062           2                                 10            $results{ $query }->{rank} += 100;
3063           2                                  5            push @{$results{ $query }->{reasons}},
               2                                 12   
3064                                                              "Query cannot be executed (rank+100)";
3065                                                        }
3066           4                                 25         return $event;
3067           2                                 25      };
3068                                                  
3069                                                  
3070                                                     # ########################################################################
3071                                                     # Daemonize now that everything is setup and ready to work.
3072                                                     # ########################################################################
3073           2                                  6      my $daemon;
3074  ***      2     50                           8      if ( $o->get('daemonize') ) {
3075  ***      0                                  0         $daemon = new Daemon(o=>$o);
3076  ***      0                                  0         $daemon->daemonize();
3077  ***      0                                  0         MKDEBUG && _d('I am a daemon now');
3078                                                     }
3079                                                  
3080                                                  
3081                                                     # ##########################################################################
3082                                                     # Parse input and process events.
3083                                                     # ##########################################################################
3084  ***      2     50                          10      if ( @ARGV == 0 ) {
3085  ***      0                                  0         MKDEBUG && _d('Reading STDIN');
3086  ***      0                                  0         push @ARGV, '-'; # Magical STDIN filename.
3087                                                     }
3088                                                  
3089           2                                 27      my $start = time();
3090  ***      2            50                    9      my $end   = $start + ($o->get('run-time') || 0); # When we should exit
3091           2                                  7      my $now   = $start;
3092                                                  
3093                                                     FILE:
3094  ***      2            33                   39      while (                                 # Quit if:
      ***                   33                        
      ***                   66                        
3095                                                        $oktorun                             # instructed to quit
3096                                                        && ($start == $end || $now < $end)   # or time is exceeded
3097                                                        && @ARGV )                           # or there's no more files
3098                                                     {
3099           2                                  7         my $file = shift @ARGV;
3100           2                                  6         MKDEBUG && _d('Parsing', $file);
3101           2                                  7         my $fh;
3102  ***      2     50                          42         if ( $file eq '-' ) {
3103  ***      0                                  0            $fh = *STDIN;
3104                                                        }
3105                                                        else {
3106  ***      2     50                          76            if ( !open $fh, "<", $file ) {
3107  ***      0                                  0               warn "Cannot open $file: $OS_ERROR";
3108  ***      0                                  0               next FILE;
3109                                                           }
3110                                                        }
3111                                                  
3112           2                                  5         my $events;
3113                                                        EVENT:
3114  ***      2            33                   22         while ( $oktorun
      ***                   33                        
3115                                                                && ($start == $end || $now < $end) ) {
3116           6                                 15            eval {
3117           6                                 35               $events = $parser->parse_event($fh, undef, @callbacks);
3118                                                           };
3119  ***      6     50                          21            if ( $EVAL_ERROR ) {
3120  ***      0                                  0               _d($EVAL_ERROR);
3121  ***      0      0                           0               last EVENT unless $o->get('continue-on-error');
3122                                                           }
3123           6    100                          23            last EVENT unless $events;
3124           4                                 55            $now = time();
3125                                                        }
3126                                                  
3127           2                                 23         close $fh;
3128           2                                  6         $now = time();
3129                                                     }
3130                                                  
3131                                                  
3132                                                     # ######################################################################
3133                                                     # Report results.
3134                                                     # ######################################################################
3135                                                     QUERY:
3136           2                                  5      foreach my $query (
               2                                 10   
3137                                                        sort { $results{$b}->{rank} <=> $results{$a}->{rank} } keys %results )
3138                                                     {
3139  ***      4     50                          29         if ( $o->get('dump-results') ) {
3140  ***      0                                  0            print Dumper($results{$query});
3141  ***      0                                  0            next QUERY;
3142                                                        }
3143                                                  
3144           4                                 31         print "# Rank: $results{$query}->{rank}\n";
3145                                                  
3146           4                                 13         my $reasons = $results{$query}->{reasons};
3147           4    100                          20         print "# Reasons: " . (@$reasons == 0 ? "none\n" : "\n");
3148           4                                 20         for my $i ( 0..(scalar @$reasons - 1) ) {
3149           2                                 21            print '#   ',$i+1,". $reasons->[$i]\n";
3150                                                        }
3151                                                  
3152           4                                 13         print "# Execution Results:\n";
3153           4                                 23         print_execution_results('host1', $results{$query}->{execution}->{host1});
3154           4                                 20         print_execution_results('host2', $results{$query}->{execution}->{host2});
3155                                                  
3156           4                                 16         print "$query\n\n";
3157                                                     }
3158                                                  
3159           2                                252      $host1_dbh->disconnect();
3160           2                                146      $host2_dbh->disconnect();
3161           2                                386      return 0;
3162                                                  
3163                                                  } # End main().
3164                                                  
3165                                                  # ############################################################################
3166                                                  # Subroutines.
3167                                                  # ############################################################################
3168                                                  sub print_execution_results {
3169           8                    8            34      my ( $host, $res ) = @_;
3170                                                  
3171           8                                 49      print "#   $host\n"
3172                                                         . "#   " . ('=' x length $host) . "\n";
3173           8    100                          31      if ( ref $res ) {
3174           4                                 14         my $warnings = $res->{warnings};
3175                                                  
3176           4                                 16         print '#   Query time: ', $res->{Query_time}, "\n";
3177           4                                 15         print '#   Warning count: ', $res->{warning_count}, "\n";
3178  ***      4     50                          20         print '#   Warnings: ' . (scalar keys %$warnings == 0 ? "none\n" : "\n");
3179                                                  
3180           4                                 29         foreach my $code ( sort { $b <=> $a } keys %$warnings ) {
      ***      0                                  0   
3181  ***      0                                  0            print "#     $code $warnings->{$code}->{Level} "
3182                                                              . "$warnings->{$code}->{Message}\n";
3183                                                        }
3184                                                     }
3185                                                     else { 
3186           4                                 19         print "#   Error executing query on $host: $res";
3187                                                     }
3188                                                  
3189           8                                 24      print "#\n";  # Spacing between hosts.
3190                                                  
3191           8                                 21      return;
3192                                                  }
3193                                                  
3194                                                  sub get_cxn {
3195           4                    4            33      my ( $dp, $o, $dsn ) = @_;
3196  ***      4     50                          21      if ( $o->get('ask-pass') ) {
3197  ***      0                                  0         $dsn->{p} = OptionParser::prompt_noecho("Enter password: ");
3198                                                     }
3199           4                                 28      my $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), {AutoCommit => 1});
3200           4                                 27      return $dbh;
3201                                                  }
3202                                                  
3203                                                  # Catches signals so we can exit gracefully.
3204                                                  # TODO: test this
3205                                                  # TODO: break wait for <$fh> with SIGINT.  Possibly by closing all $fh?
3206                                                  sub sig_int {
3207  ***      0                    0             0      my ( $signal ) = @_;
3208  ***      0      0                           0      if ( $oktorun ) {
3209  ***      0                                  0         print STDERR "# Caught SIG$signal.\n";
3210  ***      0                                  0         $oktorun = 0;
3211                                                     }
3212                                                     else {
3213  ***      0                                  0         print STDERR "# Exiting on SIG$signal.\n";
3214  ***      0                                  0         exit(1);
3215                                                     }
3216                                                  }
3217                                                  
3218                                                  sub _d {
3219           1                    1             8      my ($package, undef, $line) = caller 0;
3220  ***      1     50                           8      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
               1                                  5   
               1                                  7   
3221           1                                  5           map { defined $_ ? $_ : 'undef' }
3222                                                          @_;
3223           1                                  3      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3224                                                  }
3225                                                  
3226                                                  # ############################################################################
3227                                                  # Run the program.
3228                                                  # ############################################################################
3229                                                  if ( !caller ) { exit main(@ARGV); }
3230                                                  
3231                                                  1; # Because this is a module as well as a script.
3232                                                  
3233                                                  # #############################################################################
3234                                                  # Documentation.
3235                                                  # #############################################################################
3236                                                  
3237                                                  =pod
3238                                                  
3239                                                  =head1 NAME
3240                                                  
3241                                                  mk-upgrade - Compare SQL statements on different MySQL servers.
3242                                                  
3243                                                  =head1 SYNOPSIS
3244                                                  
3245                                                  Compare queries in slow.log on host1 to host2:
3246                                                  
3247                                                     mk-upgrade h=host1 h=host2 slow.log
3248                                                  
3249                                                  Use mk-query-digest to parse tcpdump and compare queries:
3250                                                  
3251                                                    mk-query-digest --type tcpdump --report '' --print tcpdump.txt | mk-upgrade h=host1 h=host2
3252                                                  
3253                                                  =head1 DESCRIPTION
3254                                                  
3255                                                  mk-upgrade compares and ranks how the results of SQL statements differ when
3256                                                  executed on different MySQL servers.  These ranked differences help to test
3257                                                  upgrade (or downgrade) compatibility.  The higher a query ranks, the greater
3258                                                  its results differ.
3259                                                  
3260                                                  mk-upgrade reads only slow logs.  mk-query-digest can be used to parse and
3261                                                  transform other input sources into a slow log using its C<--print --report ''>
3262                                                  options.
3263                                                  
3264                                                  At present, queries are not fingerprinted or aggregated.  Every query is
3265                                                  executed, compared and ranked individually.  This will change later.
3266                                                  
3267                                                  =head1 OPTIONS
3268                                                  
3269                                                  =over
3270                                                  
3271                                                  =item --ask-pass
3272                                                  
3273                                                  Prompt for a password when connecting to MySQL.
3274                                                  
3275                                                  =item --charset
3276                                                  
3277                                                  short form: -A; type: string
3278                                                  
3279                                                  Default character set.  If the value is utf8, sets Perl's binmode on
3280                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
3281                                                  runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
3282                                                  binmode on STDOUT without the utf8 layer, and runs SET NAMES after
3283                                                  connecting to MySQL.
3284                                                  
3285                                                  =item --config
3286                                                  
3287                                                  type: Array
3288                                                  
3289                                                  Read this comma-separated list of config files; if specified, this must be the
3290                                                  first option on the command line.
3291                                                  
3292                                                  =item --continue-on-error
3293                                                  
3294                                                  Continue parsing even if there is an error.
3295                                                  
3296                                                  =item --daemonize
3297                                                  
3298                                                  Fork to the background and detach from the shell.  POSIX
3299                                                  operating systems only.
3300                                                  
3301                                                  =item --dump-results
3302                                                  
3303                                                  Don't print a human-readable report, just dump the raw results.
3304                                                  
3305                                                  =item --filter
3306                                                  
3307                                                  type: string
3308                                                  
3309                                                  Discard events for which this Perl code doesn't return true.
3310                                                  
3311                                                  This option is a string of Perl code that gets compiled into a subroutine with
3312                                                  one argument: $event.  This is a hashref.  If the code returns true, the chain
3313                                                  of callbacks continues; otherwise it ends.  The code is the last statement in
3314                                                  the subroutine other than C<return $event>.
3315                                                  
3316                                                  An example filter that discards everything but SELECT statements:
3317                                                  
3318                                                    --filter '$event->{arg} =~ m/^select/i'
3319                                                  
3320                                                  This is compiled into a subroutine like the following:
3321                                                  
3322                                                    sub { $event = shift; $event->{arg} =~ m/^select/i && return $event; }
3323                                                  
3324                                                  It is permissible for the code to have side effects (to alter $event).
3325                                                  
3326                                                  =item --help
3327                                                  
3328                                                  Show help and exit.
3329                                                  
3330                                                  =item --host
3331                                                  
3332                                                  short form: -h; type: string
3333                                                  
3334                                                  Connect to host.
3335                                                  
3336                                                  =item --log
3337                                                  
3338                                                  type: string
3339                                                  
3340                                                  Print all output to this file when daemonized.
3341                                                  
3342                                                  =item --password
3343                                                  
3344                                                  short form: -p; type: string
3345                                                  
3346                                                  Password to use when connecting.
3347                                                  
3348                                                  =item --pid
3349                                                  
3350                                                  type: string
3351                                                  
3352                                                  Create the given PID file when daemonized.  The file contains the process
3353                                                  ID of the daemonized instance.  The PID file is removed when the
3354                                                  daemonized instance exits.  The program checks for the existence of the
3355                                                  PID file when starting; if it exists and the process with the matching PID
3356                                                  exists, the program exits.
3357                                                  
3358                                                  =item --port
3359                                                  
3360                                                  short form: -P; type: int
3361                                                  
3362                                                  Port number to use for connection.
3363                                                  
3364                                                  =item --run-time
3365                                                  
3366                                                  type: time
3367                                                  
3368                                                  How long to run before exiting.  The default is to run forever (you can
3369                                                  interrupt with CTRL-C).
3370                                                  
3371                                                  =item --socket
3372                                                  
3373                                                  short form: -S; type: string
3374                                                  
3375                                                  Socket file to use for connection.
3376                                                  
3377                                                  =item --user
3378                                                  
3379                                                  short form: -u; type: string
3380                                                  
3381                                                  User for login if not current user.
3382                                                  
3383                                                  =item --version
3384                                                  
3385                                                  Show version and exit.
3386                                                  
3387                                                  =back
3388                                                  
3389                                                  =head1 DOWNLOADING
3390                                                  
3391                                                  You can download Maatkit from Google Code at
3392                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
3393                                                  easily with a command like the following:
3394                                                  
3395                                                     wget http://www.maatkit.org/get/toolname
3396                                                     or
3397                                                     wget http://www.maatkit.org/trunk/toolname
3398                                                  
3399                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
3400                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
3401                                                  needed.  The first URL gets the latest released version of the tool, and the
3402                                                  second gets the latest trunk code from Subversion.
3403                                                  
3404                                                  =head1 SYSTEM REQUIREMENTS
3405                                                  
3406                                                  You need Perl and some core packages that ought to be installed in any
3407                                                  reasonably new version of Perl.
3408                                                  
3409                                                  =head1 ENVIRONMENT
3410                                                  
3411                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
3412                                                  the Maatkit tools:
3413                                                  
3414                                                     MKDEBUG=1 mk-....
3415                                                  
3416                                                  =head1 BUGS
3417                                                  
3418                                                  Please use Google Code Issues and Groups to report bugs or request support:
3419                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
3420                                                  discuss Maatkit.
3421                                                  
3422                                                  Please include the complete command-line used to reproduce the problem you are
3423                                                  seeing, the version of all MySQL servers involved, the complete output of the
3424                                                  tool when run with L<"--version">, and if possible, debugging output produced by
3425                                                  running with the C<MKDEBUG=1> environment variable.
3426                                                  
3427                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
3428                                                  
3429                                                  This program is copyright 2009-@CURRENTYEAR@ Percona, Inc.
3430                                                  Feedback and improvements are welcome.
3431                                                  
3432                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
3433                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
3434                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
3435                                                  
3436                                                  This program is free software; you can redistribute it and/or modify it under
3437                                                  the terms of the GNU General Public License as published by the Free Software
3438                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
3439                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
3440                                                  licenses.
3441                                                  
3442                                                  You should have received a copy of the GNU General Public License along with
3443                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
3444                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
3445                                                  
3446                                                  =head1 AUTHOR
3447                                                  
3448                                                  Baron Schwartz, Daniel Nichter
3449                                                  
3450                                                  =head1 VERSION
3451                                                  
3452                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 4008 $.
3453                                                  
3454                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
98    ***     50      0     18   if (@_ > 2)
107   ***     50      0      6   if (not $dsn)
119   ***     50     11      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
131          100      1     47   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
137          100     36     12   if (not defined $final_props{$key})
144   ***     50      0     11   unless exists $opts{$key}
147   ***     50      0      6   if (my $required = $self->prop('required'))
149   ***      0      0      0   unless $final_props{$key}
158   ***      0      0      0   unless ref $o eq 'OptionParser'
161   ***      0      0      0   if $o->has($_)
171   ***      0      0      0   unless ref $dsn
172   ***      0      0      0   $_ eq 'p' ? :
173   ***      0      0      0   if defined $$dsn{$_}
186   ***      0      0      0   $opts{$key}{'copy'} ? :
200   ***     50      0      6   if ($driver eq 'Pg') { }
232   ***     50      0      6   $cxn_string =~ /charset=utf8/ ? :
249   ***     50      6      0   if ($cxn_string =~ /mysql/i)
257   ***     50      0      6   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
262   ***      0      0      0   if ($charset eq 'utf8') { }
263   ***      0      0      0   unless binmode STDOUT, ':utf8'
267   ***      0      0      0   unless binmode STDOUT
271   ***     50      0      6   if ($self->prop('setvars'))
278   ***     50      0      6   if (not $dbh and $EVAL_ERROR)
280   ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/)
284   ***      0      0      0   if (not $tries)
306   ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
323   ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
333   ***      0      0      0   unless $dsn_1
334   ***      0      0      0   unless $dsn_2
338   ***      0      0      0   if ($args{'overwrite'}) { }
339   ***      0      0      0   defined $$dsn_1{$key} ? :
342   ***      0      0      0   defined $$dsn_2{$key} ? :
351   ***      0      0      0   defined $_ ? :
392   ***      0      0      0   if (defined $_) { }
394   ***      0      0      0   $_ eq '' || $_ =~ /^0|\D/ ? :
407   ***      0      0      0   if (not $tbl)
448   ***     50      0      2   unless $args{$arg}
453   ***     50      2      0   exists $args{'strict'} ? :
496   ***     50      0      2   unless open my $fh, '<', $file
516          100    896      2   unless $para =~ /^=head1 OPTIONS/
521   ***     50      2      0   if $para =~ /^=over/
529   ***     50      0      2   unless $para
532          100     34      2   if (my($option) = $para =~ /^=item --(.*)/)
539          100     22     12   if ($para =~ /: /) { }
543   ***     50      0     34   unless $attributes{$attrib}
547          100     12     10   if ($attribs{'short form'})
563   ***     50      0     34   if $para =~ /^=item/
565   ***     50      0     34   if (my($base_option) = $option =~ /^\[no\](.*)/)
570          100     12     22   $attribs{'short form'} ? :
      ***     50      0     34   $attribs{'negatable'} ? :
      ***     50      0     34   $attribs{'cumulative'} ? :
             100     22     12   $attribs{'type'} ? :
      ***     50      0     34   $attribs{'default'} ? :
      ***     50      0     34   $attribs{'group'} ? :
582   ***     50      0     50   unless $para
585          100      2     48   if ($para =~ /^=head1/)
589          100     34     14   if $para =~ /^=item --/
593   ***     50      0      2   unless @specs
604   ***     50     34      0   if (ref $opt) { }
609   ***     50      0     34   if (not $long)
614   ***     50      0     34   if exists $$self{'opts'}{$long}
617   ***     50      0     34   if (length $long == 1)
622          100     12     22   if ($short) { }
623   ***     50      0     12   if exists $$self{'short_opts'}{$short}
632   ***     50      0     34   $$opt{'spec'} =~ /!/ ? :
633   ***     50      0     34   $$opt{'spec'} =~ /\+/ ? :
634   ***     50      0     34   $$opt{'desc'} =~ /required/ ? :
646   ***     50      0     34   if ($type and $type eq 'd' and not $$self{'dp'})
651          100      4     30   if $type and $type =~ /[HhAadzm]/
653   ***     50      0     34   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
654   ***      0      0      0   if ($$opt{'is_negatable'})
655   ***      0      0      0   $def eq 'no' ? :
      ***      0      0      0   $def eq 'yes' ? :
659   ***      0      0      0   defined $def ? :
663          100      2     32   if ($long eq 'config')
667   ***     50      0     34   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
680   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
685   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
690   ***      0      0      0   if ($opt =~ /default to/)
695   ***      0      0      0   if ($opt =~ /restricted to option groups/)
705   ***      0      0      0   unless $rule_ok
722   ***      0      0      0   unless exists $$self{'opts'}{$long}
738   ***      0      0      0   $$self{'opts'}{$_}{'short'} ? :
756   ***      0      0      0   unless exists $$self{'opts'}{$long}
776   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***      0      0      0   exists $$self{'opts'}{$opt} ? :
781   ***      0      0      0   if ($$opt{'is_cumulative'}) { }
796   ***     50      0     32   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100      2     32   exists $$self{'defaults'}{$long} ? :
805   ***     50      0      2   if (@ARGV and $ARGV[0] eq '--config')
809   ***     50      2      0   if ($self->has('config'))
815   ***     50      8      0   if ($EVAL_ERROR)
816   ***     50      0      8   $self->got('config') ? :
831   ***     50      0      2   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
834   ***     50      0      2   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
835   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
841   ***     50      0      2   if (@ARGV and $$self{'strict'})
847   ***      0      0      0   if (@set > 1)
858   ***      0      0      0   if (@set == 0)
868   ***     50      0     34   if ($$opt{'got'}) { }
      ***     50      0     34   elsif ($$opt{'is_required'}) { }
869   ***      0      0      0   if (exists $$self{'disables'}{$long})
876   ***      0      0      0   if (exists $$self{'allowed_groups'}{$long})
888   ***      0      0      0   if $restricted_opt eq $long
889   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
894   ***      0      0      0   if (@restricted_opts)
896   ***      0      0      0   if (@restricted_opts == 1) { }
925          100     12     22   unless $opt and $$opt{'type'}
928   ***     50      0     22   if ($val and $$opt{'type'} eq 'm') { }
      ***     50      0     22   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0     22   elsif ($val and $$opt{'type'} eq 'z') { }
      ***     50      0     22   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100      2     20   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
931   ***      0      0      0   if (not $suffix)
937   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
938   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
953   ***      0      0      0   if ($from_key)
964   ***      0      0      0   if (defined $num) { }
965   ***      0      0      0   if ($factor)
992   ***     50      0     18   length $opt == 1 ? :
993   ***     50      0     18   unless $long and exists $$self{'opts'}{$long}
1000  ***     50      0      8   length $opt == 1 ? :
1001  ***     50      0      8   unless $long and exists $$self{'opts'}{$long}
1008  ***     50      0      2   length $opt == 1 ? :
1009  ***     50      2      0   defined $long ? :
1014  ***      0      0      0   length $opt == 1 ? :
1015  ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
1049  ***     50      0      2   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0      2   elsif (scalar @{$$self{'errors'};}) { }
1050  ***      0      0      0   unless print $self->print_usage
1054  ***      0      0      0   unless print $self->print_errors
1063  ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
1072  ***      0      0      0   unless $$self{'got_opts'}
1075  ***      0      0      0   $$_{'is_negatable'} ? :
1079  ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
1095  ***      0      0      0   $group eq 'default' ? :
1101  ***      0      0      0   $$opt{'is_negatable'} ? :
1104  ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
1113  ***      0      0      0   if ($short) { }
1122  ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
1126  ***      0      0      0   if ($$self{'dp'})
1134  ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
1146  ***      0      0      0   if ref $_[0] eq 'OptionParser'
1149  ***      0      0      0   unless print $prompt
1157  ***      0      0      0   unless print "\n"
1160  ***      0      0      0   if ($EVAL_ERROR)
1182  ***     50      8      0   unless open my $fh, '<', $filename
1190  ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
1193  ***      0      0      0   if ($line eq '--')
1198  ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
1216  ***      0      0      0   unless open my $fh, '<', $file
1220  ***      0      0      0   unless $para =~ /^=pod$/m
1224  ***      0      0      0   unless $para =~ /$regex/
1229  ***      0      0      0   unless close $fh
1243  ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
1258  ***      0      0      0   defined $_ ? :
1301  ***      0      0      0   defined $args{'p_ms'} ? :
1302  ***      0      0      0   defined $args{'p_s'} ? :
1305  ***      0      0      0   if $t < 0
1307  ***      0      0      0   if $t =~ /e/
1311  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
1332  ***      0      0      0   $p ? :
1339  ***      0      0      0   unless $secs
1341  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
1346  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
1365  ***      0      0      0   defined $args{'p'} ? :
1366  ***      0      0      0   defined $args{'d'} ? :
1373  ***      0      0      0   $num =~ /\./ || $n ? :
1392  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?$/)
1395  ***      0      0      0   defined $f ? :
      ***      0      0      0   defined $f ? :
1404  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s) = $val =~ /^(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(?:\.\d+)?$/)
1421  ***      0      0      0   defined $_ ? :
1486  ***      0      0      0   unless $query =~ /IN\s*\(\s*(?!select)/i
1488  ***      0      0      0   if ($length and length $query > $length)
1494  ***      0      0      0   if ($left)
1508  ***      0      0      0   @right ? :
1521  ***      0      0      0   if $query =~ m[\ASELECT /\*!40001 SQL_NO_CACHE \*/ \* FROM `]
1523  ***      0      0      0   if $query =~ m[/\*\w+\.\w+:[0-9]/[0-9]\*/]
1525  ***      0      0      0   if $query =~ /\A# administrator command: /
1527  ***      0      0      0   if $query =~ /\A\s*(call\s+\S+)\(/i
1529  ***      0      0      0   if (my($beginning) = $query =~ /\A((?:INSERT|REPLACE)(?: IGNORE)? INTO .+? VALUES \(.*?\)),\(/i)
1535  ***      0      0      0   if $query =~ s/\Ause \S+\Z/use ?/i
1563  ***      0      0      0   unless $qp
1565  ***      0      0      0   if $query =~ /\A\s*call\s+(\S+)\(/i
1567  ***      0      0      0   if $query =~ /\A# administrator/
1569  ***      0      0      0   if $query =~ /\A\s*use\s+/
1597  ***      0      0      0   unless $query
1616  ***      0      0      0   unless $query =~ s/
                 \A.*?
                 update\s+(.*?)
                 \s+set\b(.*?)
                 (?:\s*where\b(.*?))?
                 (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
                 \Z
              /__update_to_select($1, $2, $3, $4);/eisx or $query =~ s/
                    \A.*?
                    (?:insert|replace)\s+
                    .*?\binto\b(.*?)\(([^\)]+)\)\s*
                    values?\s*(\(.*?\))\s*
                    (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
                    \Z
                 /__insert_to_select($1, $2, $3);/eisx
1630  ***      0      0      0   $1 =~ /\*/ ? :
1639  ***      0      0      0   if ($join =~ /\bjoin\b/)
1653  ***      0      0      0   if (@cols == @vals) { }
1664  ***      0      0      0   $where ? :
      ***      0      0      0   $limit ? :
1671  ***      0      0      0   unless $query
1672  ***      0      0      0   $query =~ /\A\s*select/i ? :
1679  ***      0      0      0   defined $_ ? :
1723  ***     50      0      6   $$misc{'oktorun'} ? :
1738  ***     50      0      4   if ($stmt =~ s/$slow_log_hd_line//go)
1740  ***      0      0      0   if (@chunks > 1)
1747         100      2      2   unless $stmt =~ /\A#/
1761         100     16      4   if ($line =~ /^(?:#|use |SET (?:last_insert_id|insert_id|timestamp))/o) { }
1763         100      4     12   if (not $got_ts and my($time) = $line =~ /$slow_log_ts_line/o) { }
             100      4      8   elsif (not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o) { }
      ***     50      0      8   elsif (not $got_ac and $line =~ /^# (?:administrator command:.*)$/) { }
             100      4      4   elsif ($line =~ /^# +[A-Z][A-Za-z_]+: \S+/) { }
      ***     50      4      0   elsif (not $got_db and my($db) = $line =~ /^use ([^;]+)/) { }
      ***      0      0      0   elsif (not $got_set and my($setting) = $line =~ /^SET\s+([^;]*)/) { }
1767  ***     50      0      4   if (not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o)
1810  ***     50      0     16   if (not $found_arg and $pos == $len)
1813  ***      0      0      0   if (defined(my $l = <$fh>)) { }
1830  ***     50      0      4   if ($misc and $$misc{'embed'} and my($e) = $arg =~ /($$misc{'embed'})/)
1842  ***     50      0     12   unless $event = &$callback($event)
1845  ***     50      4      0   unless @pending
1852  ***      0      0      0   defined $_ ? :
1887  ***      0      0      0   unless $args{$arg}
1901  ***      0      0      0   scalar keys %$attributes == 0 ? :
1932  ***      0      0      0   unless defined $group_by
1934  ***      0      0      0   if $$self{'detect_attribs'}
1938  ***      0      0      0   if (exists $$self{'unrolled_loops'})
1945  ***      0      0      0   unless exists $$event{$attrib}
1947  ***      0      0      0   ref $group_by ? :
1952  ***      0      0      0   if (not $handler)
1961  ***      0      0      0   unless $handler
1967  ***      0      0      0   if ($$self{'n_queries'}++ > 50 or not grep {ref $$self{'handlers'}{$_} ne 'CODE';} @attrs && !$$self{'detect_attribs'})
1977  ***      0      0      0   ref $group_by ? :
1992  ***      0      0      0   if (ref $group_by)
2002  ***      0      0      0   if $EVAL_ERROR
2030  ***      0      0      0   unless defined $attrib
2033  ***      0      0      0   if (ref $val eq 'ARRAY')
2037  ***      0      0      0   unless defined $val
2040  ***      0      0      0   $val =~ /^(?:Yes|No)$/ ? :
      ***      0      0      0   $val =~ /^(?:\d+|$float_re)$/o ? :
2047  ***      0      0      0   $type =~ /num|bool/ ? :
      ***      0      0      0   $type =~ /bool|string/ ? :
      ***      0      0      0   $type eq 'num' ? :
      ***      0      0      0   $type eq 'bool' ? :
2062  ***      0      0      0   if ($args{'trf'})
2068  ***      0      0      0   if ($args{'min'})
2069  ***      0      0      0   $type eq 'num' ? :
2075  ***      0      0      0   if ($args{'max'})
2076  ***      0      0      0   $type eq 'num' ? :
2082  ***      0      0      0   if ($args{'sum'})
2085  ***      0      0      0   if ($args{'cnt'})
2088  ***      0      0      0   if ($args{'all'})
2097  ***      0      0      0   if ($args{'unq'})
2100  ***      0      0      0   if ($args{'wor'})
2101  ***      0      0      0   $type eq 'num' ? :
2110  ***      0      0      0   if ($args{'all'} and $type eq 'num' and $$self{'attrib_limit'})
2125  ***      0      0      0   $is_array ? :
      ***      0      0      0   $is_array ? :
2137  ***      0      0      0   $is_array ? :
      ***      0      0      0   $is_array ? :
2149  ***      0      0      0   if $EVAL_ERROR
2155  ***      0      0      0   if $val < 1e-06
2157  ***      0      0      0   $idx > 999 ? :
2162         100      1    999   if $bucket == 0
2163  ***     50      0    999   if $bucket < 0 or $bucket > 999
2170  ***      0      0      0   if @buck_tens
2201  ***      0      0      0   unless defined $vals and @$vals and $$args{'cnt'}
2205  ***      0      0      0   if ($n_vals == 1 or $$args{'max'} == $$args{'min'}) { }
      ***      0      0      0   elsif ($n_vals == 2) { }
2207  ***      0      0      0   $v > 0 ? :
2208  ***      0      0      0   $bucket < 0 ? :
      ***      0      0      0   $bucket > 7 ? :
2218  ***      0      0      0   $v && $v > 0 ? :
2219  ***      0      0      0   $bucket < 0 ? :
      ***      0      0      0   $bucket > 7 ? :
2231  ***      0      0      0   $n_vals >= 10 ? :
2249  ***      0      0      0   unless $val
2253  ***      0      0      0   if not $bucket_95 and $sum_excl > $top_vals
2255  ***      0      0      0   if (not $median and $total_left <= $mid)
2256  ***      0      0      0   $cutoff % 2 || $val > 1 ? :
2266  ***      0      0      0   $var > 0 ? :
2268  ***      0      0      0   $stddev > $maxstdev ? :
2285  ***      0      0      0   unless $args{$arg}
2294  ***      0      0      0   $global_cnt && $$store{'cnt'} ? :
      ***      0      0      0   $$store{'sum'} && $$store{'cnt'} ? :
2318  ***      0      0      0   if (!$args{'total'} || $total < $args{'total'} and !$args{'count'} || $count < $args{'count'}) { }
      ***      0      0      0   elsif ($args{'ol_attrib'} and !$args{'ol_freq'} || $$classes{$groupby}{$args{'ol_attrib'}}{'cnt'} >= $args{'ol_freq'}) { }
2333  ***      0      0      0   if ($$stats{'pct_95'} >= $args{'ol_limit'})
2346  ***      0      0      0   unless $event
2348  ***      0      0      0   if $_ ne $$self{'groupby'} and not exists $$self{'attributes'}{$_}
2373  ***      0      0      0   defined $_ ? :
2415  ***      0      0      0   unless $query
2444  ***      0      0      0   unless $query
2460  ***      0      0      0   unless $tbl_refs and $from
2481  ***      0      0      0   if ($tbl_ref =~ /^AS\s+\w+/i)
2489  ***      0      0      0   if $db
2496  ***      0      0      0   defined $_ ? :
2525  ***      0      0      0   unless $args{$arg}
2528  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
2544  ***      0      0      0   unless defined(my $pid = fork)
2545  ***      0      0      0   if ($pid)
2552  ***      0      0      0   unless POSIX::setsid()
2553  ***      0      0      0   unless chdir '/'
2557  ***      0      0      0   if (-t STDIN)
2559  ***      0      0      0   unless open STDIN, '/dev/null'
2563  ***      0      0      0   if ($$self{'log_file'})
2565  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
2569  ***      0      0      0   unless open STDERR, '>&STDOUT'
2579  ***      0      0      0   $self ? :
2581  ***      0      0      0   if ($PID_file and -f $PID_file) { }
2584  ***      0      0      0   if $EVAL_ERROR
2586  ***      0      0      0   if ($pid) { }
2588  ***      0      0      0   if ($pid_is_alive) { }
2610  ***      0      0      0   if (exists $$self{'child'})
2622  ***      0      0      0   if (not $PID_file)
2629  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
2631  ***      0      0      0   unless print $PID_FH $PID
2633  ***      0      0      0   unless close $PID_FH
2642  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
2643  ***      0      0      0   unless unlink $$self{'PID_file'}
2655  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
2661  ***      0      0      0   defined $_ ? :
2689  ***      0      0      0   unless $args{$arg}
2699  ***     50      0     12   unless $args{$arg}
2709  ***     50      0      8   unless $query
2710  ***     50      0      8   unless $dbh
2719         100      4      4   if ($EVAL_ERROR)
2738  ***      0      0      0   defined $_ ? :
2770  ***      0      0      0   unless $args{$arg}
2779  ***     50      0      2   unless $results
2791  ***     50      0      2   if ($$host1{'warning_count'} > 0 or $$host2{'warning_count'} > 0)
2796  ***     50      0      2   if (my $diff = abs $$host1{'warning_count'} - $$host2{'warning_count'})
2810  ***     50      0      2   unless defined $t1
2811  ***     50      0      2   unless defined $t2
2816  ***     50      0      2   if ($t1_bucket != $t2_bucket)
2824  ***     50      0      2   if ($inc >= $bucket_threshold[$t1_bucket])
2835  ***     50      0      2   unless defined $warnings1
2836  ***     50      0      2   unless defined $warnings2
2843  ***      0      0      0   if (exists $$warnings2{$code}) { }
2844  ***      0      0      0   if ($$warnings2{$code}{'Level'} ne $$warnings1{$code}{'Level'})
2859  ***      0      0      0   if (not exists $$warnings1{$code} and not exists $new_warnings{$code})
2874  ***     50      0      4   unless defined $val
2875  ***     50      0      4   if $val == 0
2877  ***     50      0      4   $bucket < 0 ? :
      ***     50      0      4   $bucket > 7 ? :
2883  ***     50      0      2   if $x == $y
2885  ***     50      2      0   if ($x > $y)
2891  ***     50      0      2   if ($x == 0)
2900  ***      0      0      0   defined $_ ? :
2956  ***     50      2      0   if (not $o->get('help'))
2957  ***     50      0      2   if (@ARGV < 2)
2995  ***     50      0      4   unless $$event{'cmd'} eq 'Query'
2996  ***     50      0      4   unless $$event{'arg'}
2997  ***     50      4      0   if $$event{'arg'} =~ /^SELECT/i
3002  ***     50      0      2   if ($o->get('filter'))
3006  ***      0      0      0   unless my $sub = eval $code
3026         100      2      2   if ($db and !$current_db || $db ne $current_db)
3041  ***     50      0      4   if ($EVAL_ERROR)
3054         100      2      2   if (ref $results{$query}{'execution'}{'host1'} and ref $results{$query}{'execution'}{'host2'}) { }
3074  ***     50      0      2   if ($o->get('daemonize'))
3084  ***     50      0      2   if (@ARGV == 0)
3102  ***     50      0      2   if ($file eq '-') { }
3106  ***     50      0      2   if (not open $fh, '<', $file)
3119  ***     50      0      6   if ($EVAL_ERROR)
3121  ***      0      0      0   unless $o->get('continue-on-error')
3123         100      2      4   unless $events
3139  ***     50      0      4   if ($o->get('dump-results'))
3147         100      2      2   @$reasons == 0 ? :
3173         100      4      4   if (ref $res) { }
3178  ***     50      4      0   scalar keys %$warnings == 0 ? :
3196  ***     50      0      4   if ($o->get('ask-pass'))
3208  ***      0      0      0   if ($oktorun) { }
3220  ***     50      1      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
131          100     11     36      1   not defined $final_props{$key} and defined $$prev{$key}
      ***     66     47      0      1   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
242   ***     66      6      0      6   not $dbh and $tries--
278   ***     33      6      0      0   not $dbh and $EVAL_ERROR
646   ***     66     12     22      0   $type and $type eq 'd'
      ***     33     34      0      0   $type and $type eq 'd' and not $$self{'dp'}
651          100     12     18      4   $type and $type =~ /[HhAadzm]/
805   ***     33      0      2      0   @ARGV and $ARGV[0] eq '--config'
834   ***     33      0      2      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
841   ***     33      0      2      0   @ARGV and $$self{'strict'}
925   ***     66      0     12     22   $opt and $$opt{'type'}
928   ***     66     20      2      0   $val and $$opt{'type'} eq 'm'
      ***     66     20      2      0   $val and $$opt{'type'} eq 'd'
      ***     66     20      2      0   $val and $$opt{'type'} eq 'z'
      ***     66     20      2      0   defined $val and $$opt{'type'} eq 'h'
      ***     33     20      0      0   defined $val and $$opt{'type'} eq 'a'
993   ***     33      0      0     18   $long and exists $$self{'opts'}{$long}
1001  ***     33      0      0      8   $long and exists $$self{'opts'}{$long}
1015  ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
1104  ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
1198  ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1311  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
1369  ***      0      0      0      0   $num >= $d and $n < @units - 1
1488  ***      0      0      0      0   $length and length $query > $length
1500  ***      0      0      0      0   @vals and $len < $targ / 2
1504  ***      0      0      0      0   @vals and $len < $targ
1733  ***     66      0      2      4   $$oktorun and defined($stmt = shift @pending) || defined($stmt = <$fh>)
1763  ***     66     12      0      4   not $got_ts and my($time) = $line =~ /$slow_log_ts_line/o
      ***     66      8      0      4   not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o
      ***     33      0      8      0   not $got_ac and $line =~ /^# (?:administrator command:.*)$/
      ***     33      0      0      4   not $got_db and my($db) = $line =~ /^use ([^;]+)/
      ***      0      0      0      0   not $got_set and my($setting) = $line =~ /^SET\s+([^;]*)/
1767  ***     33      0      4      0   not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o
1810  ***     33      0     16      0   not $found_arg and $pos == $len
1830  ***     33      0      4      0   $misc and $$misc{'embed'}
      ***     33      4      0      0   $misc and $$misc{'embed'} and my($e) = $arg =~ /($$misc{'embed'})/
1967  ***      0      0      0      0   @attrs && !$$self{'detect_attribs'}
2110  ***      0      0      0      0   $args{'all'} and $type eq 'num'
      ***      0      0      0      0   $args{'all'} and $type eq 'num' and $$self{'attrib_limit'}
2201  ***      0      0      0      0   defined $vals and @$vals
      ***      0      0      0      0   defined $vals and @$vals and $$args{'cnt'}
2218  ***      0      0      0      0   $v && $v > 0
2253  ***      0      0      0      0   not $bucket_95 and $sum_excl > $top_vals
2255  ***      0      0      0      0   not $median and $total_left <= $mid
2294  ***      0      0      0      0   $global_cnt && $$store{'cnt'}
      ***      0      0      0      0   $$store{'sum'} && $$store{'cnt'}
2318  ***      0      0      0      0   !$args{'total'} || $total < $args{'total'} and !$args{'count'} || $count < $args{'count'}
      ***      0      0      0      0   $args{'ol_attrib'} and !$args{'ol_freq'} || $$classes{$groupby}{$args{'ol_attrib'}}{'cnt'} >= $args{'ol_freq'}
2348  ***      0      0      0      0   $_ ne $$self{'groupby'} and not exists $$self{'attributes'}{$_}
2460  ***      0      0      0      0   $tbl_refs and $from
2581  ***      0      0      0      0   $PID_file and -f $PID_file
2642  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
2859  ***      0      0      0      0   not exists $$warnings1{$code} and not exists $new_warnings{$code}
3026  ***     66      0      2      2   $db and !$current_db || $db ne $current_db
3054  ***     66      2      0      2   ref $results{$query}{'execution'}{'host1'} and ref $results{$query}{'execution'}{'host2'}
3094  ***     33      0      0      4   $oktorun and $start == $end || $now < $end
      ***     66      0      2      2   $oktorun and $start == $end || $now < $end and @ARGV
3114  ***     33      0      0      6   $oktorun and $start == $end || $now < $end

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
112          100      2      4   $prev ||= {}
113   ***     50      0      6   $defaults ||= {}
186   ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
199   ***     50      0      6   $self->prop('dbidriver') || ''
203   ***      0      0      0   $$info{'D'} || ''
209   ***     50      0      6   $$info{'D'} || ''
231   ***     50      6      0   $opts ||= {}
306   ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
322   ***      0      0      0   $level ||= 0
323   ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
451   ***     50      2      0   $program_name ||= $PROGRAM_NAME
453   ***     50      2      0   $args{'prompt'} || '<options>'
      ***     50      2      0   $args{'dp'} || undef
495   ***     50      0      2   $file ||= '../mk-upgrade'
636   ***     50     34      0   $$opt{'group'} ||= 'default'
933   ***      0      0      0   $s || 's'
970   ***      0      0      0   $pre || ''
977   ***      0      0      0   $val || ''
980   ***     50      2      0   $val || ''
1038  ***      0      0      0   $$self{'description'} || ''
1106  ***      0      0      0   $s ||= 's'
1132  ***      0      0      0   $$opt{'type'} || ''
1331  ***      0      0      0   $args{'p'} || 0
1333  ***      0      0      0   $of ||= 1
1338  ***      0      0      0   $secs ||= 0
1889  ***      0      0      0   $args{'attributes'} || {}
1901  ***      0      0      0   $args{'unroll_limit'} || 50
1948  ***      0      0      0   $$self{'result_classes'}{$val}{$attrib} ||= {}
1949  ***      0      0      0   $$self{'result_globals'}{$attrib} ||= {}
2206  ***      0      0      0   $$args{'max'} || 0
2221  ***      0      0      0   $$args{'max'} || 0
2222  ***      0      0      0   $$args{'min'} || 0
2267  ***      0      0      0   $$args{'max'} || 0
      ***      0      0      0   $$args{'min'} || 0
3016  ***     50      0      4    ||= 
      ***     50      0      4    ||= 
3022  ***     50      0      4   $results{$query}{'rank'} ||= 0
3023  ***     50      0      4   $results{$query}{'reasons'} ||= ()
3090  ***     50      0      2   $o->get('run-time') || 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
222   ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
223   ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
224   ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
225   ***      0      0      0      0   $$dsn{'u'} ||= $user
226   ***      0      0      0      0   $$dsn{'D'} ||= $db
394   ***      0      0      0      0   $_ eq '' || $_ =~ /^0|\D/
928   ***     33      0      0     22   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***     66      2      0     20   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1341  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
1373  ***      0      0      0      0   $num =~ /\./ || $n
1562  ***      0      0      0      0   $args{'qp'} || $$self{'QueryParser'}
1616  ***      0      0      0      0   $query =~ s/
                 \A.*?
                 update\s+(.*?)
                 \s+set\b(.*?)
                 (?:\s*where\b(.*?))?
                 (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
                 \Z
              /__update_to_select($1, $2, $3, $4);/eisx or $query =~ s/
                    \A.*?
                    (?:insert|replace)\s+
                    .*?\binto\b(.*?)\(([^\)]+)\)\s*
                    values?\s*(\(.*?\))\s*
                    (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
                    \Z
                 /__insert_to_select($1, $2, $3);/eisx
1733  ***     66      0      4      2   defined($stmt = shift @pending) || defined($stmt = <$fh>)
1962  ***      0      0      0      0   $$samples{$val} ||= $event
1967  ***      0      0      0      0   $$self{'n_queries'}++ > 50 or not grep {ref $$self{'handlers'}{$_} ne 'CODE';} @attrs && !$$self{'detect_attribs'}
2163  ***     33      0      0    999   $bucket < 0 or $bucket > 999
2205  ***      0      0      0      0   $n_vals == 1 or $$args{'max'} == $$args{'min'}
2256  ***      0      0      0      0   $cutoff % 2 || $val > 1
2318  ***      0      0      0      0   !$args{'total'} || $total < $args{'total'}
      ***      0      0      0      0   !$args{'count'} || $count < $args{'count'}
      ***      0      0      0      0   !$args{'ol_freq'} || $$classes{$groupby}{$args{'ol_attrib'}}{'cnt'} >= $args{'ol_freq'}
2488  ***      0      0      0      0   $alias or $tbl
2655  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
2791  ***     33      0      0      2   $$host1{'warning_count'} > 0 or $$host2{'warning_count'} > 0
3026  ***     66      2      0      2   !$current_db || $db ne $current_db
3094  ***     33      4      0      0   $start == $end || $now < $end
3114  ***     33      6      0      0   $start == $end || $now < $end


Covered Subroutines
-------------------

Subroutine                    Count Location                                           
----------------------------- ----- ---------------------------------------------------
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1276
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1277
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1278
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1279
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1280
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1282
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1436
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1437
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1441
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1443
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1696
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1697
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1698
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1699
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1701
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1869
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1870
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1871
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1873
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1874
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1875
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1876
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1877
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1878
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:20  
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:21  
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2390
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2391
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2392
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2394
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2514
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2515
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2517
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2518
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2520
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2678
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2679
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2681
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2682
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2684
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2756
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2757
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2759
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2760
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2762
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2922
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2923
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2924
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2931
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2933
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:30  
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:31  
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:35  
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:36  
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:366 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:367 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:371 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:373 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:39  
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:41  
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:425 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:426 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:428 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:429 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:430 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:432 
__ANON__                          4 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2994
__ANON__                          4 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3016
__ANON__                          4 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3052
_d                                1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3219
_exec_query                       8 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2708
_parse_specs                      2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:600 
_pod_to_specs                     2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:494 
_read_config_file                 8 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1181
_validate_type                   34 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:924 
bucket_for                        4 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2873
bucket_value                   1000 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2161
compare_query_times               2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2809
compare_warnings                  2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2834
exec                              4 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2697
get                              18 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:991 
get_cxn                           4 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3195
get_cxn_params                    6 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:196 
get_dbh                           6 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:230 
get_defaults_files                2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:489 
get_opts                          2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:792 
get_specs                         2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:482 
got                               8 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:999 
has                               2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1007
main                              2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2939
new                               2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1704
new                               2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2687
new                               2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2768
new                               3 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:44  
new                               2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:446 
parse                             6 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:106 
parse_event                       6 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1721
percentage_increase               2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2882
print_execution_results           8 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3169
prop                             18 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:97  
rank                              2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2778
usage_or_errors                   2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1048

Uncovered Subroutines
---------------------

Subroutine                    Count Location                                           
----------------------------- ----- ---------------------------------------------------
DESTROY                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2654
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:829 
__delete_to_select                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1638
__insert_to_select                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1646
__update_to_select                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1663
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1257
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1420
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1678
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1851
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2372
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2495
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2660
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2737
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2899
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:350 
_get_participants                 0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:719 
_make_PID_file                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2619
_remove_PID_file                  0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2641
_set_option                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:775 
add_new_attributes                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2345
aggregate                         0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1929
as_string                         0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:170 
attributes                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2019
bucket_idx                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2154
buckets_of                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2170
calculate_statistical_metrics     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2193
check_PID_file                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2578
clone                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1234
convert_select_list               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1629
convert_to_select                 0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1596
copy                              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:332 
daemonize                         0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2541
descr                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1037
disconnect                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:315 
distill                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1561
errors                            0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1027
events_processed                  0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2367
fill_in_dsn                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:218 
fingerprint                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1519
get_aliases                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2443
get_attributes                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2362
get_defaults                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:765 
get_groups                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:770 
get_hostname                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:305 
get_tables                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2414
has_derived_table                 0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2436
make_PID_file                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2609
make_checksum                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1413
make_handler                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2029
metrics                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2283
micro_t                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1300
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1463
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1885
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2409
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2523
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:376 
opt_values                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:737 
opts                              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:731 
parse_options                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:157 
parse_timestamp                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1391
percentage_of                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1330
print_active_handles              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:321 
print_errors                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1061
print_usage                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1071
prompt                            0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1032
prompt_noecho                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1146
quote                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:381 
quote_val                         0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:389 
read_para_after                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1215
reset_aggregated_data             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1915
results                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2010
save_error                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1022
secs_to_time                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1337
set                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1013
set_defaults                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:753 
short_opts                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:747 
shorten                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1364
shorten                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1476
sig_int                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3207
split_unquote                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:404 
strip_comments                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1469
top_events                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2307
ts                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1381
type_for                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2024
unix_timestamp                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1403
usage                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:179 
wrap_in_derived                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1670


