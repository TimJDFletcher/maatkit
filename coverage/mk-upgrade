---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...kit/mk-upgrade/mk-upgrade   10.2    0.9    4.7   31.2    n/a  100.0    8.9
Total                          10.2    0.9    4.7   31.2    n/a  100.0    8.9
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:45:47 2010
Finish:       Thu Jan 28 22:45:47 2010

Run:          ./100_rewrite_non_select.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:45:48 2010
Finish:       Thu Jan 28 22:45:54 2010

Run:          ./101_basics.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:46:01 2010
Finish:       Thu Jan 28 22:46:03 2010

Run:          ./102_skip_non_select.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:46:11 2010
Finish:       Thu Jan 28 22:46:12 2010

Run:          ./103_daemon.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:46:20 2010
Finish:       Thu Jan 28 22:46:21 2010

Run:          ./104_warnings.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:46:29 2010
Finish:       Thu Jan 28 22:46:30 2010

/home/daniel/dev/maatkit/mk-upgrade/mk-upgrade

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This program is copyright 2009-@CURRENTYEAR@ Percona Inc.
4                                                     # Feedback and improvements are welcome.
5                                                     #
6                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
7                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
8                                                     # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
9                                                     #
10                                                    # This program is free software; you can redistribute it and/or modify it under
11                                                    # the terms of the GNU General Public License as published by the Free Software
12                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
13                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
14                                                    # licenses.
15                                                    #
16                                                    # You should have received a copy of the GNU General Public License along with
17                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
18                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
19                                                    
20             5                    5           366   use strict;
               5                                 18   
               5                                 42   
21             5                    5            32   use warnings FATAL => 'all';
               5                                 13   
               5                                 43   
22                                                    
23                                                    our $VERSION = '@VERSION@';
24                                                    our $DISTRIB = '@DISTRIB@';
25                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5502 $ =~ m/(\d+)/g, 0));
26                                                    
27                                                    # ###########################################################################
28                                                    # DSNParser package 5266
29                                                    # ###########################################################################
30                                                    package DSNParser;
31                                                    
32             5                    5            34   use strict;
               5                                 13   
               5                                 30   
33             5                    5            35   use warnings FATAL => 'all';
               5                                 12   
               5                                 24   
34             5                    5            33   use English qw(-no_match_vars);
               5                                 14   
               5                                 35   
35             5                    5            48   use Data::Dumper;
               5                                 13   
               5                                 52   
36                                                    $Data::Dumper::Indent    = 0;
37                                                    $Data::Dumper::Quotekeys = 0;
38                                                    
39                                                    eval {
40                                                       require DBI;
41                                                    };
42                                                    my $have_dbi = $EVAL_ERROR ? 0 : 1;
43                                                    
44    ***      5            50      5            37   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 14   
               5                                 92   
45                                                    
46                                                    sub new {
47             5                    5            63      my ( $class, @opts ) = @_;
48             5                                393      my $self = {
49                                                          opts => {
50                                                             A => {
51                                                                desc => 'Default character set',
52                                                                dsn  => 'charset',
53                                                                copy => 1,
54                                                             },
55                                                             D => {
56                                                                desc => 'Database to use',
57                                                                dsn  => 'database',
58                                                                copy => 1,
59                                                             },
60                                                             F => {
61                                                                desc => 'Only read default options from the given file',
62                                                                dsn  => 'mysql_read_default_file',
63                                                                copy => 1,
64                                                             },
65                                                             h => {
66                                                                desc => 'Connect to host',
67                                                                dsn  => 'host',
68                                                                copy => 1,
69                                                             },
70                                                             p => {
71                                                                desc => 'Password to use when connecting',
72                                                                dsn  => 'password',
73                                                                copy => 1,
74                                                             },
75                                                             P => {
76                                                                desc => 'Port number to use for connection',
77                                                                dsn  => 'port',
78                                                                copy => 1,
79                                                             },
80                                                             S => {
81                                                                desc => 'Socket file to use for connection',
82                                                                dsn  => 'mysql_socket',
83                                                                copy => 1,
84                                                             },
85                                                             u => {
86                                                                desc => 'User for login if not current user',
87                                                                dsn  => 'user',
88                                                                copy => 1,
89                                                             },
90                                                          },
91                                                       };
92             5                                 49      foreach my $opt ( @opts ) {
93    ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
94    ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
95                                                       }
96             5                                165      return bless $self, $class;
97                                                    }
98                                                    
99                                                    sub prop {
100           30                   30           157      my ( $self, $prop, $value ) = @_;
101   ***     30     50                         151      if ( @_ > 2 ) {
102   ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
103   ***      0                                  0         $self->{$prop} = $value;
104                                                      }
105           30                                245      return $self->{$prop};
106                                                   }
107                                                   
108                                                   sub parse {
109           10                   10           598      my ( $self, $dsn, $prev, $defaults ) = @_;
110   ***     10     50                          82      if ( !$dsn ) {
111   ***      0                                  0         MKDEBUG && _d('No DSN to parse');
112   ***      0                                  0         return;
113                                                      }
114           10                                 37      MKDEBUG && _d('Parsing', $dsn);
115   ***     10            50                   91      $prev     ||= {};
116   ***     10            50                   63      $defaults ||= {};
117           10                                 34      my %given_props;
118           10                                 32      my %final_props;
119           10                                 34      my %opts = %{$self->{opts}};
              10                                152   
120                                                   
121           10                                113      foreach my $dsn_part ( split(/,/, $dsn) ) {
122   ***     40     50                         395         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
123           40                                191            $given_props{$prop_key} = $prop_val;
124                                                         }
125                                                         else {
126   ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
127   ***      0                                  0            $given_props{h} = $dsn_part;
128                                                         }
129                                                      }
130                                                   
131           10                                 64      foreach my $key ( keys %opts ) {
132           80                                173         MKDEBUG && _d('Finding value for', $key);
133           80                                286         $final_props{$key} = $given_props{$key};
134   ***     80     50     66                  683         if (   !defined $final_props{$key}
      ***                   33                        
135                                                              && defined $prev->{$key} && $opts{$key}->{copy} )
136                                                         {
137   ***      0                                  0            $final_props{$key} = $prev->{$key};
138   ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
139                                                         }
140           80    100                         349         if ( !defined $final_props{$key} ) {
141           40                                139            $final_props{$key} = $defaults->{$key};
142           40                                109            MKDEBUG && _d('Copying value for', $key, 'from defaults');
143                                                         }
144                                                      }
145                                                   
146           10                                 62      foreach my $key ( keys %given_props ) {
147   ***     40     50                         180         die "Unrecognized DSN part '$key' in '$dsn'\n"
148                                                            unless exists $opts{$key};
149                                                      }
150   ***     10     50                          63      if ( (my $required = $self->prop('required')) ) {
151   ***      0                                  0         foreach my $key ( keys %$required ) {
152   ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
153                                                         }
154                                                      }
155                                                   
156           10                                 86      return \%final_props;
157                                                   }
158                                                   
159                                                   sub parse_options {
160   ***      0                    0             0      my ( $self, $o ) = @_;
161   ***      0      0                           0      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
162   ***      0                                  0      my $dsn_string
163                                                         = join(',',
164   ***      0      0                           0             map  { "$_=".$o->get($_); }
165   ***      0                                  0             grep { $o->has($_) && $o->get($_) }
166   ***      0                                  0             keys %{$self->{opts}}
167                                                           );
168   ***      0                                  0      MKDEBUG && _d('DSN string made from options:', $dsn_string);
169   ***      0                                  0      return $self->parse($dsn_string);
170                                                   }
171                                                   
172                                                   sub as_string {
173   ***      0                    0             0      my ( $self, $dsn ) = @_;
174   ***      0      0                           0      return $dsn unless ref $dsn;
175   ***      0      0                           0      return join(',',
176   ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
177   ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
178                                                         sort keys %$dsn );
179                                                   }
180                                                   
181                                                   sub usage {
182   ***      0                    0             0      my ( $self ) = @_;
183   ***      0                                  0      my $usage
184                                                         = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
185                                                         . "  KEY  COPY  MEANING\n"
186                                                         . "  ===  ====  =============================================\n";
187   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
188   ***      0                                  0      foreach my $key ( sort keys %opts ) {
189   ***      0      0      0                    0         $usage .= "  $key    "
190                                                                .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
191                                                                .  ($opts{$key}->{desc} || '[No description]')
192                                                                . "\n";
193                                                      }
194   ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
195   ***      0                                  0      return $usage;
196                                                   }
197                                                   
198                                                   sub get_cxn_params {
199           10                   10           196      my ( $self, $info ) = @_;
200           10                                 33      my $dsn;
201           10                                 32      my %opts = %{$self->{opts}};
              10                                 98   
202   ***     10            50                   70      my $driver = $self->prop('dbidriver') || '';
203   ***     10     50                          58      if ( $driver eq 'Pg' ) {
204   ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
205   ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
206   ***      0             0                    0                        grep { defined $info->{$_} }
207                                                                        qw(h P));
208                                                      }
209                                                      else {
210           20                                169         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
211           50                                203            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
212   ***     10            50                  152                        grep { defined $info->{$_} }
213                                                                        qw(F h P S A))
214                                                            . ';mysql_read_default_group=client';
215                                                      }
216           10                                 34      MKDEBUG && _d($dsn);
217           10                                118      return ($dsn, $info->{u}, $info->{p});
218                                                   }
219                                                   
220                                                   sub fill_in_dsn {
221   ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
222   ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
223   ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
224   ***      0                                  0      $user =~ s/@.*//;
225   ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
226   ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
227   ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
228   ***      0             0                    0      $dsn->{u} ||= $user;
229   ***      0             0                    0      $dsn->{D} ||= $db;
230                                                   }
231                                                   
232                                                   sub get_dbh {
233           10                   10            72      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
234   ***     10            50                   51      $opts ||= {};
235   ***     10     50                         149      my $defaults = {
236                                                         AutoCommit         => 0,
237                                                         RaiseError         => 1,
238                                                         PrintError         => 0,
239                                                         ShowErrorStatement => 1,
240                                                         mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
241                                                      };
242           10                                 57      @{$defaults}{ keys %$opts } = values %$opts;
              10                                 46   
243                                                   
244   ***     10     50                          52      if ( !$have_dbi ) {
245   ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
246                                                            . "installed or not found.  Run 'perl -MDBI' to see the directories "
247                                                            . "that Perl searches for DBI.  If DBI is not installed, try:\n"
248                                                            . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
249                                                            . "  RHEL/CentOS    yum install perl-DBI\n"
250                                                            . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
251                                                   
252                                                      }
253                                                   
254           10                                 31      my $dbh;
255           10                                 36      my $tries = 2;
256   ***     10            66                  126      while ( !$dbh && $tries-- ) {
257                                                         MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
258           10                                 28            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
259                                                   
260           10                                 29         eval {
261           10                                119            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
262                                                   
263   ***     10     50                         131            if ( $cxn_string =~ m/mysql/i ) {
264           10                                 32               my $sql;
265                                                   
266           10                                 41               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
267                                                                    . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
268           10                                 23               MKDEBUG && _d($dbh, ':', $sql);
269           10                               1082               $dbh->do($sql);
270                                                   
271   ***     10     50                         109               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
272   ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
273   ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
274   ***      0                                  0                  $dbh->do($sql);
275   ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
276   ***      0      0                           0                  if ( $charset eq 'utf8' ) {
277   ***      0      0                           0                     binmode(STDOUT, ':utf8')
278                                                                        or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
279                                                                  }
280                                                                  else {
281   ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
282                                                                  }
283                                                               }
284                                                   
285   ***     10     50                          72               if ( $self->prop('set-vars') ) {
286   ***      0                                  0                  $sql = "SET " . $self->prop('set-vars');
287   ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
288   ***      0                                  0                  $dbh->do($sql);
289                                                               }
290                                                            }
291                                                         };
292   ***     10     50     33                  112         if ( !$dbh && $EVAL_ERROR ) {
293   ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
294   ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
295   ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
296   ***      0                                  0               delete $defaults->{mysql_enable_utf8};
297                                                            }
298                                                            elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
299   ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
300                                                                  . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
301                                                                  . "the directories that Perl searches for DBD::mysql.  If "
302                                                                  . "DBD::mysql is not installed, try:\n"
303                                                                  . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
304                                                                  . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
305                                                                  . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
306                                                            }
307   ***      0      0                           0            if ( !$tries ) {
308   ***      0                                  0               die $EVAL_ERROR;
309                                                            }
310                                                         }
311                                                      }
312                                                   
313           10                                 28      MKDEBUG && _d('DBH info: ',
314                                                         $dbh,
315                                                         Dumper($dbh->selectrow_hashref(
316                                                            'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
317                                                         'Connection info:',      $dbh->{mysql_hostinfo},
318                                                         'Character set info:',   Dumper($dbh->selectall_arrayref(
319                                                                        'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
320                                                         '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
321                                                         '$DBI::VERSION:',        $DBI::VERSION,
322                                                      );
323                                                   
324           10                                 71      return $dbh;
325                                                   }
326                                                   
327                                                   sub get_hostname {
328   ***      0                    0             0      my ( $self, $dbh ) = @_;
329   ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
330   ***      0                                  0         return $host;
331                                                      }
332   ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
333                                                         'SELECT /*!50038 @@hostname, */ 1');
334   ***      0                                  0      return $hostname;
335                                                   }
336                                                   
337                                                   sub disconnect {
338   ***      0                    0             0      my ( $self, $dbh ) = @_;
339   ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
340   ***      0                                  0      $dbh->disconnect;
341                                                   }
342                                                   
343                                                   sub print_active_handles {
344   ***      0                    0             0      my ( $self, $thing, $level ) = @_;
345   ***      0             0                    0      $level ||= 0;
346   ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
347                                                         $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
348                                                         or die "Cannot print: $OS_ERROR";
349   ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
350   ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
351                                                      }
352                                                   }
353                                                   
354                                                   sub copy {
355   ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
356   ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
357   ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
358   ***      0                                  0      my %new_dsn = map {
359   ***      0                                  0         my $key = $_;
360   ***      0                                  0         my $val;
361   ***      0      0                           0         if ( $args{overwrite} ) {
362   ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
363                                                         }
364                                                         else {
365   ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
366                                                         }
367   ***      0                                  0         $key => $val;
368   ***      0                                  0      } keys %{$self->{opts}};
369   ***      0                                  0      return \%new_dsn;
370                                                   }
371                                                   
372                                                   sub _d {
373   ***      0                    0             0      my ($package, undef, $line) = caller 0;
374   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
375   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
376                                                           @_;
377   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
378                                                   }
379                                                   
380                                                   1;
381                                                   
382                                                   # ###########################################################################
383                                                   # End DSNParser package
384                                                   # ###########################################################################
385                                                   
386                                                   # ###########################################################################
387                                                   # MySQLDump package 5266
388                                                   # ###########################################################################
389                                                   package MySQLDump;
390                                                   
391            5                    5            67   use strict;
               5                                 14   
               5                                 43   
392            5                    5            35   use warnings FATAL => 'all';
               5                                 12   
               5                                 38   
393                                                   
394            5                    5            38   use English qw(-no_match_vars);
               5                                 16   
               5                                 36   
395                                                   
396   ***      5            50      5            48   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 11   
               5                                125   
397                                                   
398                                                   ( our $before = <<'EOF') =~ s/^   //gm;
399                                                      /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
400                                                      /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
401                                                      /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
402                                                      /*!40101 SET NAMES utf8 */;
403                                                      /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
404                                                      /*!40103 SET TIME_ZONE='+00:00' */;
405                                                      /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
406                                                      /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
407                                                      /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
408                                                      /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
409                                                   EOF
410                                                   
411                                                   ( our $after = <<'EOF') =~ s/^   //gm;
412                                                      /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
413                                                      /*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
414                                                      /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
415                                                      /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
416                                                      /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
417                                                      /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
418                                                      /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
419                                                      /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
420                                                   EOF
421                                                   
422                                                   sub new {
423   ***      0                    0             0      my ( $class, %args ) = @_;
424   ***      0      0                           0      $args{cache} = 1 unless defined $args{cache};
425   ***      0                                  0      my $self = bless \%args, $class;
426   ***      0                                  0      return $self;
427                                                   }
428                                                   
429                                                   sub dump {
430   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl, $what ) = @_;
431                                                   
432   ***      0      0                           0      if ( $what eq 'table' ) {
      ***             0                               
      ***             0                               
433   ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
434   ***      0      0                           0         return unless $ddl;
435   ***      0      0                           0         if ( $ddl->[0] eq 'table' ) {
436   ***      0                                  0            return $before
437                                                               . 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
438                                                               . $ddl->[1] . ";\n";
439                                                         }
440                                                         else {
441   ***      0                                  0            return 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
442                                                               . '/*!50001 DROP VIEW IF EXISTS '
443                                                               . $quoter->quote($tbl) . "*/;\n/*!50001 "
444                                                               . $self->get_tmp_table($dbh, $quoter, $db, $tbl) . "*/;\n";
445                                                         }
446                                                      }
447                                                      elsif ( $what eq 'triggers' ) {
448   ***      0                                  0         my $trgs = $self->get_triggers($dbh, $quoter, $db, $tbl);
449   ***      0      0      0                    0         if ( $trgs && @$trgs ) {
450   ***      0                                  0            my $result = $before . "\nDELIMITER ;;\n";
451   ***      0                                  0            foreach my $trg ( @$trgs ) {
452   ***      0      0                           0               if ( $trg->{sql_mode} ) {
453   ***      0                                  0                  $result .= qq{/*!50003 SET SESSION SQL_MODE='$trg->{sql_mode}' */;;\n};
454                                                               }
455   ***      0                                  0               $result .= "/*!50003 CREATE */ ";
456   ***      0      0                           0               if ( $trg->{definer} ) {
457   ***      0                                  0                  my ( $user, $host )
458   ***      0                                  0                     = map { s/'/''/g; "'$_'"; }
      ***      0                                  0   
459                                                                       split('@', $trg->{definer}, 2);
460   ***      0                                  0                  $result .= "/*!50017 DEFINER=$user\@$host */ ";
461                                                               }
462   ***      0                                  0               $result .= sprintf("/*!50003 TRIGGER %s %s %s ON %s\nFOR EACH ROW %s */;;\n\n",
463                                                                  $quoter->quote($trg->{trigger}),
464   ***      0                                  0                  @{$trg}{qw(timing event)},
465                                                                  $quoter->quote($trg->{table}),
466                                                                  $trg->{statement});
467                                                            }
468   ***      0                                  0            $result .= "DELIMITER ;\n\n/*!50003 SET SESSION SQL_MODE=\@OLD_SQL_MODE */;\n\n";
469   ***      0                                  0            return $result;
470                                                         }
471                                                         else {
472   ***      0                                  0            return undef;
473                                                         }
474                                                      }
475                                                      elsif ( $what eq 'view' ) {
476   ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
477   ***      0                                  0         return '/*!50001 DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
478                                                            . '/*!50001 DROP VIEW IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
479                                                            . '/*!50001 ' . $ddl->[1] . "*/;\n";
480                                                      }
481                                                      else {
482   ***      0                                  0         die "You didn't say what to dump.";
483                                                      }
484                                                   }
485                                                   
486                                                   sub _use_db {
487   ***      0                    0             0      my ( $self, $dbh, $quoter, $new ) = @_;
488   ***      0      0                           0      if ( !$new ) {
489   ***      0                                  0         MKDEBUG && _d('No new DB to use');
490   ***      0                                  0         return;
491                                                      }
492   ***      0                                  0      my $sql = 'SELECT DATABASE()';
493   ***      0                                  0      MKDEBUG && _d($sql);
494   ***      0                                  0      my $curr = $dbh->selectrow_array($sql);
495   ***      0      0      0                    0      if ( $curr && $new && $curr eq $new ) {
      ***                    0                        
496   ***      0                                  0         MKDEBUG && _d('Current and new DB are the same');
497   ***      0                                  0         return $curr;
498                                                      }
499   ***      0                                  0      $sql = 'USE ' . $quoter->quote($new);
500   ***      0                                  0      MKDEBUG && _d($sql);
501   ***      0                                  0      $dbh->do($sql);
502   ***      0                                  0      return $curr;
503                                                   }
504                                                   
505                                                   sub get_create_table {
506   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
507   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{tables}->{$db}->{$tbl} ) {
508   ***      0                                  0         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
509                                                            . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
510                                                            . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
511                                                            . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
512   ***      0                                  0         MKDEBUG && _d($sql);
513   ***      0                                  0         eval { $dbh->do($sql); };
      ***      0                                  0   
514   ***      0                                  0         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
515   ***      0                                  0         my $curr_db = $self->_use_db($dbh, $quoter, $db);
516   ***      0                                  0         $sql = "SHOW CREATE TABLE " . $quoter->quote($db, $tbl);
517   ***      0                                  0         MKDEBUG && _d($sql);
518   ***      0                                  0         my $href;
519   ***      0                                  0         eval { $href = $dbh->selectrow_hashref($sql); };
      ***      0                                  0   
520   ***      0      0                           0         if ( $EVAL_ERROR ) {
521   ***      0                                  0            warn "Failed to $sql.  The table may be damaged.\nError: $EVAL_ERROR";
522   ***      0                                  0            return;
523                                                         }
524   ***      0                                  0         $self->_use_db($dbh, $quoter, $curr_db);
525   ***      0                                  0         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
526                                                            . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
527   ***      0                                  0         MKDEBUG && _d($sql);
528   ***      0                                  0         $dbh->do($sql);
529   ***      0                                  0         my ($key) = grep { m/create table/i } keys %$href;
      ***      0                                  0   
530   ***      0      0                           0         if ( $key ) {
531   ***      0                                  0            MKDEBUG && _d('This table is a base table');
532   ***      0                                  0            $self->{tables}->{$db}->{$tbl} = [ 'table', $href->{$key} ];
533                                                         }
534                                                         else {
535   ***      0                                  0            MKDEBUG && _d('This table is a view');
536   ***      0                                  0            ($key) = grep { m/create view/i } keys %$href;
      ***      0                                  0   
537   ***      0                                  0            $self->{tables}->{$db}->{$tbl} = [ 'view', $href->{$key} ];
538                                                         }
539                                                      }
540   ***      0                                  0      return $self->{tables}->{$db}->{$tbl};
541                                                   }
542                                                   
543                                                   sub get_columns {
544   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
545   ***      0                                  0      MKDEBUG && _d('Get columns for', $db, $tbl);
546   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{columns}->{$db}->{$tbl} ) {
547   ***      0                                  0         my $curr_db = $self->_use_db($dbh, $quoter, $db);
548   ***      0                                  0         my $sql = "SHOW COLUMNS FROM " . $quoter->quote($db, $tbl);
549   ***      0                                  0         MKDEBUG && _d($sql);
550   ***      0                                  0         my $cols = $dbh->selectall_arrayref($sql, { Slice => {} });
551   ***      0                                  0         $self->_use_db($dbh, $quoter, $curr_db);
552   ***      0                                  0         $self->{columns}->{$db}->{$tbl} = [
553                                                            map {
554   ***      0                                  0               my %row;
555   ***      0                                  0               @row{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
556   ***      0                                  0               \%row;
557                                                            } @$cols
558                                                         ];
559                                                      }
560   ***      0                                  0      return $self->{columns}->{$db}->{$tbl};
561                                                   }
562                                                   
563                                                   sub get_tmp_table {
564   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
565   ***      0                                  0      my $result = 'CREATE TABLE ' . $quoter->quote($tbl) . " (\n";
566   ***      0                                  0      $result .= join(",\n",
567   ***      0                                  0         map { '  ' . $quoter->quote($_->{field}) . ' ' . $_->{type} }
568   ***      0                                  0         @{$self->get_columns($dbh, $quoter, $db, $tbl)});
569   ***      0                                  0      $result .= "\n)";
570   ***      0                                  0      MKDEBUG && _d($result);
571   ***      0                                  0      return $result;
572                                                   }
573                                                   
574                                                   sub get_triggers {
575   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
576   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{triggers}->{$db} ) {
577   ***      0                                  0         $self->{triggers}->{$db} = {};
578   ***      0                                  0         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
579                                                            . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
580                                                            . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
581                                                            . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
582   ***      0                                  0         MKDEBUG && _d($sql);
583   ***      0                                  0         eval { $dbh->do($sql); };
      ***      0                                  0   
584   ***      0                                  0         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
585   ***      0                                  0         $sql = "SHOW TRIGGERS FROM " . $quoter->quote($db);
586   ***      0                                  0         MKDEBUG && _d($sql);
587   ***      0                                  0         my $sth = $dbh->prepare($sql);
588   ***      0                                  0         $sth->execute();
589   ***      0      0                           0         if ( $sth->rows ) {
590   ***      0                                  0            my $trgs = $sth->fetchall_arrayref({});
591   ***      0                                  0            foreach my $trg (@$trgs) {
592   ***      0                                  0               my %trg;
593   ***      0                                  0               @trg{ map { lc $_ } keys %$trg } = values %$trg;
      ***      0                                  0   
594   ***      0                                  0               push @{ $self->{triggers}->{$db}->{ $trg{table} } }, \%trg;
      ***      0                                  0   
595                                                            }
596                                                         }
597   ***      0                                  0         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
598                                                            . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
599   ***      0                                  0         MKDEBUG && _d($sql);
600   ***      0                                  0         $dbh->do($sql);
601                                                      }
602   ***      0      0                           0      if ( $tbl ) {
603   ***      0                                  0         return $self->{triggers}->{$db}->{$tbl};
604                                                      }
605   ***      0                                  0      return values %{$self->{triggers}->{$db}};
      ***      0                                  0   
606                                                   }
607                                                   
608                                                   sub get_databases {
609   ***      0                    0             0      my ( $self, $dbh, $quoter, $like ) = @_;
610   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{databases} || $like ) {
      ***                    0                        
611   ***      0                                  0         my $sql = 'SHOW DATABASES';
612   ***      0                                  0         my @params;
613   ***      0      0                           0         if ( $like ) {
614   ***      0                                  0            $sql .= ' LIKE ?';
615   ***      0                                  0            push @params, $like;
616                                                         }
617   ***      0                                  0         my $sth = $dbh->prepare($sql);
618   ***      0                                  0         MKDEBUG && _d($sql, @params);
619   ***      0                                  0         $sth->execute( @params );
620   ***      0                                  0         my @dbs = map { $_->[0] } @{$sth->fetchall_arrayref()};
      ***      0                                  0   
      ***      0                                  0   
621   ***      0      0                           0         $self->{databases} = \@dbs unless $like;
622   ***      0                                  0         return @dbs;
623                                                      }
624   ***      0                                  0      return @{$self->{databases}};
      ***      0                                  0   
625                                                   }
626                                                   
627                                                   sub get_table_status {
628   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
629   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_status}->{$db} || $like ) {
      ***                    0                        
630   ***      0                                  0         my $sql = "SHOW TABLE STATUS FROM " . $quoter->quote($db);
631   ***      0                                  0         my @params;
632   ***      0      0                           0         if ( $like ) {
633   ***      0                                  0            $sql .= ' LIKE ?';
634   ***      0                                  0            push @params, $like;
635                                                         }
636   ***      0                                  0         MKDEBUG && _d($sql, @params);
637   ***      0                                  0         my $sth = $dbh->prepare($sql);
638   ***      0                                  0         $sth->execute(@params);
639   ***      0                                  0         my @tables = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
640   ***      0                                  0         @tables = map {
641   ***      0                                  0            my %tbl; # Make a copy with lowercased keys
642   ***      0                                  0            @tbl{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
643   ***      0             0                    0            $tbl{engine} ||= $tbl{type} || $tbl{comment};
      ***                    0                        
644   ***      0                                  0            delete $tbl{type};
645   ***      0                                  0            \%tbl;
646                                                         } @tables;
647   ***      0      0                           0         $self->{table_status}->{$db} = \@tables unless $like;
648   ***      0                                  0         return @tables;
649                                                      }
650   ***      0                                  0      return @{$self->{table_status}->{$db}};
      ***      0                                  0   
651                                                   }
652                                                   
653                                                   sub get_table_list {
654   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
655   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_list}->{$db} || $like ) {
      ***                    0                        
656   ***      0                                  0         my $sql = "SHOW /*!50002 FULL*/ TABLES FROM " . $quoter->quote($db);
657   ***      0                                  0         my @params;
658   ***      0      0                           0         if ( $like ) {
659   ***      0                                  0            $sql .= ' LIKE ?';
660   ***      0                                  0            push @params, $like;
661                                                         }
662   ***      0                                  0         MKDEBUG && _d($sql, @params);
663   ***      0                                  0         my $sth = $dbh->prepare($sql);
664   ***      0                                  0         $sth->execute(@params);
665   ***      0                                  0         my @tables = @{$sth->fetchall_arrayref()};
      ***      0                                  0   
666   ***      0      0      0                    0         @tables = map {
667   ***      0                                  0            my %tbl = (
668                                                               name   => $_->[0],
669                                                               engine => ($_->[1] || '') eq 'VIEW' ? 'VIEW' : '',
670                                                            );
671   ***      0                                  0            \%tbl;
672                                                         } @tables;
673   ***      0      0                           0         $self->{table_list}->{$db} = \@tables unless $like;
674   ***      0                                  0         return @tables;
675                                                      }
676   ***      0                                  0      return @{$self->{table_list}->{$db}};
      ***      0                                  0   
677                                                   }
678                                                   
679                                                   sub _d {
680   ***      0                    0             0      my ($package, undef, $line) = caller 0;
681   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
682   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
683                                                           @_;
684   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
685                                                   }
686                                                   
687                                                   1;
688                                                   
689                                                   # ###########################################################################
690                                                   # End MySQLDump package
691                                                   # ###########################################################################
692                                                   
693                                                   # ###########################################################################
694                                                   # TableParser package 5266
695                                                   # ###########################################################################
696                                                   package TableParser;
697                                                   
698            5                    5            65   use strict;
               5                                 19   
               5                                 42   
699            5                    5            32   use warnings FATAL => 'all';
               5                                 13   
               5                                 36   
700            5                    5            54   use English qw(-no_match_vars);
               5                                 12   
               5                                 33   
701            5                    5            47   use Data::Dumper;
               5                                 15   
               5                                 69   
702                                                   $Data::Dumper::Indent    = 1;
703                                                   $Data::Dumper::Sortkeys  = 1;
704                                                   $Data::Dumper::Quotekeys = 0;
705                                                   
706   ***      5            50      5            35   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 18   
               5                                 89   
707                                                   
708                                                   
709                                                   sub new {
710   ***      0                    0             0      my ( $class, %args ) = @_;
711   ***      0                                  0      my @required_args = qw(Quoter);
712   ***      0                                  0      foreach my $arg ( @required_args ) {
713   ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
714                                                      }
715   ***      0                                  0      my $self = { %args };
716   ***      0                                  0      return bless $self, $class;
717                                                   }
718                                                   
719                                                   
720                                                   sub parse {
721   ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
722   ***      0      0                           0      return unless $ddl;
723   ***      0      0                           0      if ( ref $ddl eq 'ARRAY' ) {
724   ***      0      0                           0         if ( lc $ddl->[0] eq 'table' ) {
725   ***      0                                  0            $ddl = $ddl->[1];
726                                                         }
727                                                         else {
728                                                            return {
729   ***      0                                  0               engine => 'VIEW',
730                                                            };
731                                                         }
732                                                      }
733                                                   
734   ***      0      0                           0      if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
735   ***      0                                  0         die "Cannot parse table definition; is ANSI quoting "
736                                                            . "enabled or SQL_QUOTE_SHOW_CREATE disabled?";
737                                                      }
738                                                   
739   ***      0                                  0      my ($name)     = $ddl =~ m/CREATE (?:TEMPORARY )?TABLE\s+(`.+?`)/;
740   ***      0      0                           0      (undef, $name) = $self->{Quoter}->split_unquote($name) if $name;
741                                                   
742   ***      0                                  0      $ddl =~ s/(`[^`]+`)/\L$1/g;
743                                                   
744   ***      0                                  0      my $engine = $self->get_engine($ddl);
745                                                   
746   ***      0                                  0      my @defs   = $ddl =~ m/^(\s+`.*?),?$/gm;
747   ***      0                                  0      my @cols   = map { $_ =~ m/`([^`]+)`/ } @defs;
      ***      0                                  0   
748   ***      0                                  0      MKDEBUG && _d('Columns:', join(', ', @cols));
749                                                   
750   ***      0                                  0      my %def_for;
751   ***      0                                  0      @def_for{@cols} = @defs;
752                                                   
753   ***      0                                  0      my (@nums, @null);
754   ***      0                                  0      my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
755   ***      0                                  0      foreach my $col ( @cols ) {
756   ***      0                                  0         my $def = $def_for{$col};
757   ***      0                                  0         my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
758   ***      0      0                           0         die "Can't determine column type for $def" unless $type;
759   ***      0                                  0         $type_for{$col} = $type;
760   ***      0      0                           0         if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
761   ***      0                                  0            push @nums, $col;
762   ***      0                                  0            $is_numeric{$col} = 1;
763                                                         }
764   ***      0      0                           0         if ( $def !~ m/NOT NULL/ ) {
765   ***      0                                  0            push @null, $col;
766   ***      0                                  0            $is_nullable{$col} = 1;
767                                                         }
768   ***      0      0                           0         $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
769                                                      }
770                                                   
771   ***      0                                  0      my ($keys, $clustered_key) = $self->get_keys($ddl, $opts, \%is_nullable);
772                                                   
773                                                      return {
774   ***      0                                  0         name           => $name,
775                                                         cols           => \@cols,
776   ***      0                                  0         col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
777   ***      0                                  0         is_col         => { map { $_ => 1 } @cols },
778                                                         null_cols      => \@null,
779                                                         is_nullable    => \%is_nullable,
780                                                         is_autoinc     => \%is_autoinc,
781                                                         clustered_key  => $clustered_key,
782                                                         keys           => $keys,
783                                                         defs           => \%def_for,
784                                                         numeric_cols   => \@nums,
785                                                         is_numeric     => \%is_numeric,
786                                                         engine         => $engine,
787                                                         type_for       => \%type_for,
788                                                      };
789                                                   }
790                                                   
791                                                   sub sort_indexes {
792   ***      0                    0             0      my ( $self, $tbl ) = @_;
793                                                   
794                                                      my @indexes
795   ***      0                                  0         = sort {
796   ***      0                                  0            (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
797                                                            || ( !$tbl->{keys}->{$a}->{is_unique} <=> !$tbl->{keys}->{$b}->{is_unique} )
798                                                            || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
799   ***      0      0      0                    0            || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      ***      0             0                    0   
800                                                         }
801                                                         grep {
802   ***      0                                  0            $tbl->{keys}->{$_}->{type} eq 'BTREE'
803                                                         }
804   ***      0                                  0         sort keys %{$tbl->{keys}};
805                                                   
806   ***      0                                  0      MKDEBUG && _d('Indexes sorted best-first:', join(', ', @indexes));
807   ***      0                                  0      return @indexes;
808                                                   }
809                                                   
810                                                   sub find_best_index {
811   ***      0                    0             0      my ( $self, $tbl, $index ) = @_;
812   ***      0                                  0      my $best;
813   ***      0      0                           0      if ( $index ) {
814   ***      0                                  0         ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
      ***      0                                  0   
      ***      0                                  0   
815                                                      }
816   ***      0      0                           0      if ( !$best ) {
817   ***      0      0                           0         if ( $index ) {
818   ***      0                                  0            die "Index '$index' does not exist in table";
819                                                         }
820                                                         else {
821   ***      0                                  0            ($best) = $self->sort_indexes($tbl);
822                                                         }
823                                                      }
824   ***      0                                  0      MKDEBUG && _d('Best index found is', $best);
825   ***      0                                  0      return $best;
826                                                   }
827                                                   
828                                                   sub find_possible_keys {
829   ***      0                    0             0      my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
830   ***      0      0                           0      return () unless $where;
831   ***      0                                  0      my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
832                                                         . ' WHERE ' . $where;
833   ***      0                                  0      MKDEBUG && _d($sql);
834   ***      0                                  0      my $expl = $dbh->selectrow_hashref($sql);
835   ***      0                                  0      $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
      ***      0                                  0   
836   ***      0      0                           0      if ( $expl->{possible_keys} ) {
837   ***      0                                  0         MKDEBUG && _d('possible_keys =', $expl->{possible_keys});
838   ***      0                                  0         my @candidates = split(',', $expl->{possible_keys});
839   ***      0                                  0         my %possible   = map { $_ => 1 } @candidates;
      ***      0                                  0   
840   ***      0      0                           0         if ( $expl->{key} ) {
841   ***      0                                  0            MKDEBUG && _d('MySQL chose', $expl->{key});
842   ***      0                                  0            unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
      ***      0                                  0   
843   ***      0                                  0            MKDEBUG && _d('Before deduping:', join(', ', @candidates));
844   ***      0                                  0            my %seen;
845   ***      0                                  0            @candidates = grep { !$seen{$_}++ } @candidates;
      ***      0                                  0   
846                                                         }
847   ***      0                                  0         MKDEBUG && _d('Final list:', join(', ', @candidates));
848   ***      0                                  0         return @candidates;
849                                                      }
850                                                      else {
851   ***      0                                  0         MKDEBUG && _d('No keys in possible_keys');
852   ***      0                                  0         return ();
853                                                      }
854                                                   }
855                                                   
856                                                   sub check_table {
857   ***      0                    0             0      my ( $self, %args ) = @_;
858   ***      0                                  0      my @required_args = qw(dbh db tbl);
859   ***      0                                  0      foreach my $arg ( @required_args ) {
860   ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
861                                                      }
862   ***      0                                  0      my ($dbh, $db, $tbl) = @args{@required_args};
863   ***      0                                  0      my $q      = $self->{Quoter};
864   ***      0                                  0      my $db_tbl = $q->quote($db, $tbl);
865   ***      0                                  0      MKDEBUG && _d('Checking', $db_tbl);
866                                                   
867   ***      0                                  0      my $sql = "SHOW TABLES FROM " . $q->quote($db)
868                                                              . ' LIKE ' . $q->literal_like($tbl);
869   ***      0                                  0      MKDEBUG && _d($sql);
870   ***      0                                  0      my $row;
871   ***      0                                  0      eval {
872   ***      0                                  0         $row = $dbh->selectrow_arrayref($sql);
873                                                      };
874   ***      0      0                           0      if ( $EVAL_ERROR ) {
875   ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
876   ***      0                                  0         return 0;
877                                                      }
878   ***      0      0      0                    0      if ( !$row->[0] || $row->[0] ne $tbl ) {
879   ***      0                                  0         MKDEBUG && _d('Table does not exist');
880   ***      0                                  0         return 0;
881                                                      }
882                                                   
883   ***      0                                  0      MKDEBUG && _d('Table exists; no privs to check');
884   ***      0      0                           0      return 1 unless $args{all_privs};
885                                                   
886   ***      0                                  0      $sql = "SHOW FULL COLUMNS FROM $db_tbl";
887   ***      0                                  0      MKDEBUG && _d($sql);
888   ***      0                                  0      eval {
889   ***      0                                  0         $row = $dbh->selectrow_hashref($sql);
890                                                      };
891   ***      0      0                           0      if ( $EVAL_ERROR ) {
892   ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
893   ***      0                                  0         return 0;
894                                                      }
895   ***      0      0                           0      if ( !scalar keys %$row ) {
896   ***      0                                  0         MKDEBUG && _d('Table has no columns:', Dumper($row));
897   ***      0                                  0         return 0;
898                                                      }
899   ***      0             0                    0      my $privs = $row->{privileges} || $row->{Privileges};
900                                                   
901   ***      0                                  0      $sql = "DELETE FROM $db_tbl LIMIT 0";
902   ***      0                                  0      MKDEBUG && _d($sql);
903   ***      0                                  0      eval {
904   ***      0                                  0         $dbh->do($sql);
905                                                      };
906   ***      0      0                           0      my $can_delete = $EVAL_ERROR ? 0 : 1;
907                                                   
908   ***      0                                  0      MKDEBUG && _d('User privs on', $db_tbl, ':', $privs,
909                                                         ($can_delete ? 'delete' : ''));
910                                                   
911   ***      0      0      0                    0      if ( !($privs =~ m/select/ && $privs =~ m/insert/ && $privs =~ m/update/
      ***                    0                        
      ***                    0                        
912                                                             && $can_delete) ) {
913   ***      0                                  0         MKDEBUG && _d('User does not have all privs');
914   ***      0                                  0         return 0;
915                                                      }
916                                                   
917   ***      0                                  0      MKDEBUG && _d('User has all privs');
918   ***      0                                  0      return 1;
919                                                   }
920                                                   
921                                                   sub get_engine {
922   ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
923   ***      0                                  0      my ( $engine ) = $ddl =~ m/\).*?(?:ENGINE|TYPE)=(\w+)/;
924   ***      0                                  0      MKDEBUG && _d('Storage engine:', $engine);
925   ***      0             0                    0      return $engine || undef;
926                                                   }
927                                                   
928                                                   sub get_keys {
929   ***      0                    0             0      my ( $self, $ddl, $opts, $is_nullable ) = @_;
930   ***      0                                  0      my $engine        = $self->get_engine($ddl);
931   ***      0                                  0      my $keys          = {};
932   ***      0                                  0      my $clustered_key = undef;
933                                                   
934                                                      KEY:
935   ***      0                                  0      foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {
936                                                   
937   ***      0      0                           0         next KEY if $key =~ m/FOREIGN/;
938                                                   
939   ***      0                                  0         my $key_ddl = $key;
940   ***      0                                  0         MKDEBUG && _d('Parsed key:', $key_ddl);
941                                                   
942   ***      0      0                           0         if ( $engine !~ m/MEMORY|HEAP/ ) {
943   ***      0                                  0            $key =~ s/USING HASH/USING BTREE/;
944                                                         }
945                                                   
946   ***      0                                  0         my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
947   ***      0                                  0         my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
948   ***      0             0                    0         $type = $type || $special || 'BTREE';
      ***                    0                        
949   ***      0      0      0                    0         if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
      ***                    0                        
950                                                            && $engine =~ m/HEAP|MEMORY/i )
951                                                         {
952   ***      0                                  0            $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
953                                                         }
954                                                   
955   ***      0                                  0         my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
956   ***      0      0                           0         my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
957   ***      0                                  0         my @cols;
958   ***      0                                  0         my @col_prefixes;
959   ***      0                                  0         foreach my $col_def ( split(',', $cols) ) {
960   ***      0                                  0            my ($name, $prefix) = $col_def =~ m/`([^`]+)`(?:\((\d+)\))?/;
961   ***      0                                  0            push @cols, $name;
962   ***      0                                  0            push @col_prefixes, $prefix;
963                                                         }
964   ***      0                                  0         $name =~ s/`//g;
965                                                   
966   ***      0                                  0         MKDEBUG && _d('Key', $name, 'cols:', join(', ', @cols));
967                                                   
968   ***      0                                  0         $keys->{$name} = {
969                                                            name         => $name,
970                                                            type         => $type,
971                                                            colnames     => $cols,
972                                                            cols         => \@cols,
973                                                            col_prefixes => \@col_prefixes,
974                                                            is_unique    => $unique,
975   ***      0                                  0            is_nullable  => scalar(grep { $is_nullable->{$_} } @cols),
976   ***      0                                  0            is_col       => { map { $_ => 1 } @cols },
977                                                            ddl          => $key_ddl,
978                                                         };
979                                                   
980   ***      0      0      0                    0         if ( $engine =~ m/InnoDB/i && !$clustered_key ) {
981   ***      0                                  0            my $this_key = $keys->{$name};
982   ***      0      0      0                    0            if ( $this_key->{name} eq 'PRIMARY' ) {
      ***             0                               
983   ***      0                                  0               $clustered_key = 'PRIMARY';
984                                                            }
985                                                            elsif ( $this_key->{is_unique} && !$this_key->{is_nullable} ) {
986   ***      0                                  0               $clustered_key = $this_key->{name};
987                                                            }
988   ***      0                                  0            MKDEBUG && $clustered_key && _d('This key is the clustered key');
989                                                         }
990                                                      }
991                                                   
992   ***      0                                  0      return $keys, $clustered_key;
993                                                   }
994                                                   
995                                                   sub get_fks {
996   ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
997   ***      0                                  0      my $fks = {};
998                                                   
999   ***      0                                  0      foreach my $fk (
1000                                                        $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg )
1001                                                     {
1002  ***      0                                  0         my ( $name ) = $fk =~ m/CONSTRAINT `(.*?)`/;
1003  ***      0                                  0         my ( $cols ) = $fk =~ m/FOREIGN KEY \(([^\)]+)\)/;
1004  ***      0                                  0         my ( $parent, $parent_cols ) = $fk =~ m/REFERENCES (\S+) \(([^\)]+)\)/;
1005                                                  
1006  ***      0      0      0                    0         if ( $parent !~ m/\./ && $opts->{database} ) {
1007  ***      0                                  0            $parent = "`$opts->{database}`.$parent";
1008                                                        }
1009                                                  
1010  ***      0                                  0         $fks->{$name} = {
1011                                                           name           => $name,
1012                                                           colnames       => $cols,
1013  ***      0                                  0            cols           => [ map { s/[ `]+//g; $_; } split(',', $cols) ],
      ***      0                                  0   
1014                                                           parent_tbl     => $parent,
1015                                                           parent_colnames=> $parent_cols,
1016  ***      0                                  0            parent_cols    => [ map { s/[ `]+//g; $_; } split(',', $parent_cols) ],
      ***      0                                  0   
1017                                                           ddl            => $fk,
1018                                                        };
1019                                                     }
1020                                                  
1021  ***      0                                  0      return $fks;
1022                                                  }
1023                                                  
1024                                                  sub remove_auto_increment {
1025  ***      0                    0             0      my ( $self, $ddl ) = @_;
1026  ***      0                                  0      $ddl =~ s/(^\).*?) AUTO_INCREMENT=\d+\b/$1/m;
1027  ***      0                                  0      return $ddl;
1028                                                  }
1029                                                  
1030                                                  sub remove_secondary_indexes {
1031  ***      0                    0             0      my ( $self, $ddl ) = @_;
1032  ***      0                                  0      my $sec_indexes_ddl;
1033  ***      0                                  0      my $tbl_struct = $self->parse($ddl);
1034                                                  
1035  ***      0      0      0                    0      if ( ($tbl_struct->{engine} || '') =~ m/InnoDB/i ) {
1036  ***      0                                  0         my $clustered_key = $tbl_struct->{clustered_key};
1037  ***      0             0                    0         $clustered_key  ||= '';
1038                                                  
1039  ***      0                                  0         my @sec_indexes   = map {
1040  ***      0                                  0            my $key_def = $_->{ddl};
1041  ***      0                                  0            $key_def =~ s/([\(\)])/\\$1/g;
1042  ***      0                                  0            $ddl =~ s/\s+$key_def//;
1043  ***      0                                  0            "ADD $_->{ddl}";
1044                                                        }
1045  ***      0                                  0         grep { $_->{name} ne $clustered_key }
1046  ***      0                                  0         values %{$tbl_struct->{keys}};
1047  ***      0                                  0         MKDEBUG && _d('Secondary indexes:', Dumper(\@sec_indexes));
1048                                                  
1049  ***      0      0                           0         if ( @sec_indexes ) {
1050  ***      0                                  0            $sec_indexes_ddl = join(' ', @sec_indexes);
1051  ***      0                                  0            $sec_indexes_ddl =~ s/,$//;
1052                                                        }
1053                                                  
1054  ***      0                                  0         $ddl =~ s/,(\n\) )/$1/s;
1055                                                     }
1056                                                     else {
1057  ***      0                                  0         MKDEBUG && _d('Not removing secondary indexes from',
1058                                                           $tbl_struct->{engine}, 'table');
1059                                                     }
1060                                                  
1061  ***      0                                  0      return $ddl, $sec_indexes_ddl, $tbl_struct;
1062                                                  }
1063                                                  
1064                                                  sub _d {
1065  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1066  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1067  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1068                                                          @_;
1069  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1070                                                  }
1071                                                  
1072                                                  1;
1073                                                  
1074                                                  # ###########################################################################
1075                                                  # End TableParser package
1076                                                  # ###########################################################################
1077                                                  
1078                                                  # ###########################################################################
1079                                                  # Quoter package 5266
1080                                                  # ###########################################################################
1081           5                    5            68   use strict;
               5                                 22   
               5                                 45   
1082           5                    5            36   use warnings FATAL => 'all';
               5                                 13   
               5                                 38   
1083                                                  
1084                                                  package Quoter;
1085                                                  
1086           5                    5            33   use English qw(-no_match_vars);
               5                                 15   
               5                                 33   
1087                                                  
1088  ***      5            50      5            66   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 17   
               5                                155   
1089                                                  
1090                                                  sub new {
1091  ***      0                    0             0      my ( $class ) = @_;
1092  ***      0                                  0      bless {}, $class;
1093                                                  }
1094                                                  
1095                                                  sub quote {
1096  ***      0                    0             0      my ( $self, @vals ) = @_;
1097  ***      0                                  0      foreach my $val ( @vals ) {
1098  ***      0                                  0         $val =~ s/`/``/g;
1099                                                     }
1100  ***      0                                  0      return join('.', map { '`' . $_ . '`' } @vals);
      ***      0                                  0   
1101                                                  }
1102                                                  
1103                                                  sub quote_val {
1104  ***      0                    0             0      my ( $self, $val, $is_numeric ) = @_;
1105                                                  
1106  ***      0      0                           0      return 'NULL' unless defined $val;  # undef = NULL
1107  ***      0      0                           0      return "''" if $val eq '';          # blank string = ''
1108                                                  
1109  ***      0      0                           0      if ( !defined $is_numeric ) {
1110  ***      0      0                           0         $is_numeric = $val =~ m/^0|\D/ ? 0 : 1;
1111                                                     }
1112                                                  
1113  ***      0      0                           0      return $val if $is_numeric;
1114                                                  
1115  ***      0                                  0      $val =~ s/(['\\])/\\$1/g;
1116  ***      0                                  0      return "'$val'";
1117                                                  }
1118                                                  
1119                                                  sub split_unquote {
1120  ***      0                    0             0      my ( $self, $db_tbl, $default_db ) = @_;
1121  ***      0                                  0      $db_tbl =~ s/`//g;
1122  ***      0                                  0      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
1123  ***      0      0                           0      if ( !$tbl ) {
1124  ***      0                                  0         $tbl = $db;
1125  ***      0                                  0         $db  = $default_db;
1126                                                     }
1127  ***      0                                  0      return ($db, $tbl);
1128                                                  }
1129                                                  
1130                                                  sub literal_like {
1131  ***      0                    0             0      my ( $self, $like ) = @_;
1132  ***      0      0                           0      return unless $like;
1133  ***      0                                  0      $like =~ s/([%_])/\\$1/g;
1134  ***      0                                  0      return "'$like'";
1135                                                  }
1136                                                  
1137                                                  1;
1138                                                  
1139                                                  # ###########################################################################
1140                                                  # End Quoter package
1141                                                  # ###########################################################################
1142                                                  
1143                                                  # ###########################################################################
1144                                                  # OptionParser package 5266
1145                                                  # ###########################################################################
1146                                                  package OptionParser;
1147                                                  
1148           5                    5            46   use strict;
               5                                 13   
               5                                 35   
1149           5                    5            31   use warnings FATAL => 'all';
               5                                 13   
               5                                 40   
1150                                                  
1151           5                    5            67   use Getopt::Long;
               5                                 19   
               5                                 41   
1152           5                    5            45   use List::Util qw(max);
               5                                 14   
               5                                 61   
1153           5                    5            35   use English qw(-no_match_vars);
               5                                 11   
               5                                 42   
1154                                                  
1155  ***      5            50      5            52   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 15   
               5                                 93   
1156                                                  
1157                                                  my $POD_link_re = '[LC]<"?([^">]+)"?>';
1158                                                  
1159                                                  my %attributes = (
1160                                                     'type'       => 1,
1161                                                     'short form' => 1,
1162                                                     'group'      => 1,
1163                                                     'default'    => 1,
1164                                                     'cumulative' => 1,
1165                                                     'negatable'  => 1,
1166                                                  );
1167                                                  
1168                                                  sub new {
1169  ***      0                    0             0      my ( $class, %args ) = @_;
1170  ***      0                                  0      foreach my $arg ( qw(description) ) {
1171  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1172                                                     }
1173  ***      0                                  0      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
1174  ***      0             0                    0      $program_name ||= $PROGRAM_NAME;
1175  ***      0             0                    0      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                    0                        
      ***                    0                        
1176                                                  
1177  ***      0      0      0                    0      my $self = {
      ***                    0                        
1178                                                        description    => $args{description},
1179                                                        prompt         => $args{prompt} || '<options>',
1180                                                        strict         => (exists $args{strict} ? $args{strict} : 1),
1181                                                        dp             => $args{dp}     || undef,
1182                                                        program_name   => $program_name,
1183                                                        opts           => {},
1184                                                        got_opts       => 0,
1185                                                        short_opts     => {},
1186                                                        defaults       => {},
1187                                                        groups         => {},
1188                                                        allowed_groups => {},
1189                                                        errors         => [],
1190                                                        rules          => [],  # desc of rules for --help
1191                                                        mutex          => [],  # rule: opts are mutually exclusive
1192                                                        atleast1       => [],  # rule: at least one opt is required
1193                                                        disables       => {},  # rule: opt disables other opts 
1194                                                        defaults_to    => {},  # rule: opt defaults to value of other opt
1195                                                        default_files  => [
1196                                                           "/etc/maatkit/maatkit.conf",
1197                                                           "/etc/maatkit/$program_name.conf",
1198                                                           "$home/.maatkit.conf",
1199                                                           "$home/.$program_name.conf",
1200                                                        ],
1201                                                     };
1202  ***      0                                  0      return bless $self, $class;
1203                                                  }
1204                                                  
1205                                                  sub get_specs {
1206  ***      0                    0             0      my ( $self, $file ) = @_;
1207  ***      0                                  0      my @specs = $self->_pod_to_specs($file);
1208  ***      0                                  0      $self->_parse_specs(@specs);
1209  ***      0                                  0      return;
1210                                                  }
1211                                                  
1212                                                  sub get_defaults_files {
1213  ***      0                    0             0      my ( $self ) = @_;
1214  ***      0                                  0      return @{$self->{default_files}};
      ***      0                                  0   
1215                                                  }
1216                                                  
1217                                                  sub _pod_to_specs {
1218  ***      0                    0             0      my ( $self, $file ) = @_;
1219  ***      0             0                    0      $file ||= __FILE__;
1220  ***      0      0                           0      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
1221                                                  
1222  ***      0                                  0      my %types = (
1223                                                        string => 's', # standard Getopt type
1224                                                        'int'  => 'i', # standard Getopt type
1225                                                        float  => 'f', # standard Getopt type
1226                                                        Hash   => 'H', # hash, formed from a comma-separated list
1227                                                        hash   => 'h', # hash as above, but only if a value is given
1228                                                        Array  => 'A', # array, similar to Hash
1229                                                        array  => 'a', # array, similar to hash
1230                                                        DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
1231                                                        size   => 'z', # size with kMG suffix (powers of 2^10)
1232                                                        'time' => 'm', # time, with an optional suffix of s/h/m/d
1233                                                     );
1234  ***      0                                  0      my @specs = ();
1235  ***      0                                  0      my @rules = ();
1236  ***      0                                  0      my $para;
1237                                                  
1238  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
1239  ***      0                                  0      while ( $para = <$fh> ) {
1240  ***      0      0                           0         next unless $para =~ m/^=head1 OPTIONS/;
1241  ***      0                                  0         last;
1242                                                     }
1243                                                  
1244  ***      0                                  0      while ( $para = <$fh> ) {
1245  ***      0      0                           0         last if $para =~ m/^=over/;
1246  ***      0                                  0         chomp $para;
1247  ***      0                                  0         $para =~ s/\s+/ /g;
1248  ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
1249  ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
1250  ***      0                                  0         push @rules, $para;
1251                                                     }
1252                                                  
1253  ***      0      0                           0      die 'POD has no OPTIONS section' unless $para;
1254                                                  
1255  ***      0                                  0      do {
1256  ***      0      0                           0         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
1257  ***      0                                  0            chomp $para;
1258  ***      0                                  0            MKDEBUG && _d($para);
1259  ***      0                                  0            my %attribs;
1260                                                  
1261  ***      0                                  0            $para = <$fh>; # read next paragraph, possibly attributes
1262                                                  
1263  ***      0      0                           0            if ( $para =~ m/: / ) { # attributes
1264  ***      0                                  0               $para =~ s/\s+\Z//g;
1265  ***      0                                  0               %attribs = map {
1266  ***      0                                  0                     my ( $attrib, $val) = split(/: /, $_);
1267  ***      0      0                           0                     die "Unrecognized attribute for --$option: $attrib"
1268                                                                       unless $attributes{$attrib};
1269  ***      0                                  0                     ($attrib, $val);
1270                                                                 } split(/; /, $para);
1271  ***      0      0                           0               if ( $attribs{'short form'} ) {
1272  ***      0                                  0                  $attribs{'short form'} =~ s/-//;
1273                                                              }
1274  ***      0                                  0               $para = <$fh>; # read next paragraph, probably short help desc
1275                                                           }
1276                                                           else {
1277  ***      0                                  0               MKDEBUG && _d('Option has no attributes');
1278                                                           }
1279                                                  
1280  ***      0                                  0            $para =~ s/\s+\Z//g;
1281  ***      0                                  0            $para =~ s/\s+/ /g;
1282  ***      0                                  0            $para =~ s/$POD_link_re/$1/go;
1283                                                  
1284  ***      0                                  0            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
1285  ***      0                                  0            MKDEBUG && _d('Short help:', $para);
1286                                                  
1287  ***      0      0                           0            die "No description after option spec $option" if $para =~ m/^=item/;
1288                                                  
1289  ***      0      0                           0            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
1290  ***      0                                  0               $option = $base_option;
1291  ***      0                                  0               $attribs{'negatable'} = 1;
1292                                                           }
1293                                                  
1294  ***      0      0                           0            push @specs, {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
1295                                                              spec  => $option
1296                                                                 . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
1297                                                                 . ($attribs{'negatable'}  ? '!'                          : '' )
1298                                                                 . ($attribs{'cumulative'} ? '+'                          : '' )
1299                                                                 . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
1300                                                              desc  => $para
1301                                                                 . ($attribs{default} ? " (default $attribs{default})" : ''),
1302                                                              group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
1303                                                           };
1304                                                        }
1305  ***      0                                  0         while ( $para = <$fh> ) {
1306  ***      0      0                           0            last unless $para;
1307                                                  
1308                                                  
1309  ***      0      0                           0            if ( $para =~ m/^=head1/ ) {
1310  ***      0                                  0               $para = undef; # Can't 'last' out of a do {} block.
1311  ***      0                                  0               last;
1312                                                           }
1313  ***      0      0                           0            last if $para =~ m/^=item --/;
1314                                                        }
1315                                                     } while ( $para );
1316                                                  
1317  ***      0      0                           0      die 'No valid specs in POD OPTIONS' unless @specs;
1318                                                  
1319  ***      0                                  0      close $fh;
1320  ***      0                                  0      return @specs, @rules;
1321                                                  }
1322                                                  
1323                                                  sub _parse_specs {
1324  ***      0                    0             0      my ( $self, @specs ) = @_;
1325  ***      0                                  0      my %disables; # special rule that requires deferred checking
1326                                                  
1327  ***      0                                  0      foreach my $opt ( @specs ) {
1328  ***      0      0                           0         if ( ref $opt ) { # It's an option spec, not a rule.
1329                                                           MKDEBUG && _d('Parsing opt spec:',
1330  ***      0                                  0               map { ($_, '=>', $opt->{$_}) } keys %$opt);
1331                                                  
1332  ***      0                                  0            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
1333  ***      0      0                           0            if ( !$long ) {
1334  ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
1335                                                           }
1336  ***      0                                  0            $opt->{long} = $long;
1337                                                  
1338  ***      0      0                           0            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
1339  ***      0                                  0            $self->{opts}->{$long} = $opt;
1340                                                  
1341  ***      0      0                           0            if ( length $long == 1 ) {
1342  ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
1343  ***      0                                  0               $self->{short_opts}->{$long} = $long;
1344                                                           }
1345                                                  
1346  ***      0      0                           0            if ( $short ) {
1347  ***      0      0                           0               die "Duplicate short option -$short"
1348                                                                 if exists $self->{short_opts}->{$short};
1349  ***      0                                  0               $self->{short_opts}->{$short} = $long;
1350  ***      0                                  0               $opt->{short} = $short;
1351                                                           }
1352                                                           else {
1353  ***      0                                  0               $opt->{short} = undef;
1354                                                           }
1355                                                  
1356  ***      0      0                           0            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
1357  ***      0      0                           0            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
1358  ***      0      0                           0            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
1359                                                  
1360  ***      0             0                    0            $opt->{group} ||= 'default';
1361  ***      0                                  0            $self->{groups}->{ $opt->{group} }->{$long} = 1;
1362                                                  
1363  ***      0                                  0            $opt->{value} = undef;
1364  ***      0                                  0            $opt->{got}   = 0;
1365                                                  
1366  ***      0                                  0            my ( $type ) = $opt->{spec} =~ m/=(.)/;
1367  ***      0                                  0            $opt->{type} = $type;
1368  ***      0                                  0            MKDEBUG && _d($long, 'type:', $type);
1369                                                  
1370  ***      0      0      0                    0            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                    0                        
1371  ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
1372                                                                 . "was given when this OptionParser object was created";
1373                                                           }
1374                                                  
1375  ***      0      0      0                    0            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
1376                                                  
1377  ***      0      0                           0            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
1378  ***      0      0                           0               $self->{defaults}->{$long} = defined $def ? $def : 1;
1379  ***      0                                  0               MKDEBUG && _d($long, 'default:', $def);
1380                                                           }
1381                                                  
1382  ***      0      0                           0            if ( $long eq 'config' ) {
1383  ***      0                                  0               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
1384                                                           }
1385                                                  
1386  ***      0      0                           0            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
1387  ***      0                                  0               $disables{$long} = $dis;
1388  ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
1389                                                           }
1390                                                  
1391  ***      0                                  0            $self->{opts}->{$long} = $opt;
1392                                                        }
1393                                                        else { # It's an option rule, not a spec.
1394  ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
1395  ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
1396  ***      0                                  0            my @participants = $self->_get_participants($opt);
1397  ***      0                                  0            my $rule_ok = 0;
1398                                                  
1399  ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
1400  ***      0                                  0               $rule_ok = 1;
1401  ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
1402  ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
1403                                                           }
1404  ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
1405  ***      0                                  0               $rule_ok = 1;
1406  ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
1407  ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
1408                                                           }
1409  ***      0      0                           0            if ( $opt =~ m/default to/ ) {
1410  ***      0                                  0               $rule_ok = 1;
1411  ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
1412  ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
1413                                                           }
1414  ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
1415  ***      0                                  0               $rule_ok = 1;
1416  ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
1417  ***      0                                  0               my @groups = split(',', $groups);
1418  ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
1419  ***      0                                  0                  s/\s+//;
1420  ***      0                                  0                  $_ => 1;
1421                                                              } @groups;
1422                                                           }
1423                                                  
1424  ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
1425                                                        }
1426                                                     }
1427                                                  
1428  ***      0                                  0      foreach my $long ( keys %disables ) {
1429  ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
1430  ***      0                                  0         $self->{disables}->{$long} = \@participants;
1431  ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
1432                                                     }
1433                                                  
1434  ***      0                                  0      return; 
1435                                                  }
1436                                                  
1437                                                  sub _get_participants {
1438  ***      0                    0             0      my ( $self, $str ) = @_;
1439  ***      0                                  0      my @participants;
1440  ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
1441  ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
1442                                                           unless exists $self->{opts}->{$long};
1443  ***      0                                  0         push @participants, $long;
1444                                                     }
1445  ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
1446  ***      0                                  0      return @participants;
1447                                                  }
1448                                                  
1449                                                  sub opts {
1450  ***      0                    0             0      my ( $self ) = @_;
1451  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1452  ***      0                                  0      return %opts;
1453                                                  }
1454                                                  
1455                                                  sub short_opts {
1456  ***      0                    0             0      my ( $self ) = @_;
1457  ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
1458  ***      0                                  0      return %short_opts;
1459                                                  }
1460                                                  
1461                                                  sub set_defaults {
1462  ***      0                    0             0      my ( $self, %defaults ) = @_;
1463  ***      0                                  0      $self->{defaults} = {};
1464  ***      0                                  0      foreach my $long ( keys %defaults ) {
1465  ***      0      0                           0         die "Cannot set default for nonexistent option $long"
1466                                                           unless exists $self->{opts}->{$long};
1467  ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
1468  ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
1469                                                     }
1470  ***      0                                  0      return;
1471                                                  }
1472                                                  
1473                                                  sub get_defaults {
1474  ***      0                    0             0      my ( $self ) = @_;
1475  ***      0                                  0      return $self->{defaults};
1476                                                  }
1477                                                  
1478                                                  sub get_groups {
1479  ***      0                    0             0      my ( $self ) = @_;
1480  ***      0                                  0      return $self->{groups};
1481                                                  }
1482                                                  
1483                                                  sub _set_option {
1484  ***      0                    0             0      my ( $self, $opt, $val ) = @_;
1485  ***      0      0                           0      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***             0                               
1486                                                              : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
1487                                                              : die "Getopt::Long gave a nonexistent option: $opt";
1488                                                  
1489  ***      0                                  0      $opt = $self->{opts}->{$long};
1490  ***      0      0                           0      if ( $opt->{is_cumulative} ) {
1491  ***      0                                  0         $opt->{value}++;
1492                                                     }
1493                                                     else {
1494  ***      0                                  0         $opt->{value} = $val;
1495                                                     }
1496  ***      0                                  0      $opt->{got} = 1;
1497  ***      0                                  0      MKDEBUG && _d('Got option', $long, '=', $val);
1498                                                  }
1499                                                  
1500                                                  sub get_opts {
1501  ***      0                    0             0      my ( $self ) = @_; 
1502                                                  
1503  ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
1504  ***      0                                  0         $self->{opts}->{$long}->{got} = 0;
1505  ***      0      0                           0         $self->{opts}->{$long}->{value}
      ***             0                               
1506                                                           = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
1507                                                           : $self->{opts}->{$long}->{is_cumulative} ? 0
1508                                                           : undef;
1509                                                     }
1510  ***      0                                  0      $self->{got_opts} = 0;
1511                                                  
1512  ***      0                                  0      $self->{errors} = [];
1513                                                  
1514  ***      0      0      0                    0      if ( @ARGV && $ARGV[0] eq "--config" ) {
1515  ***      0                                  0         shift @ARGV;
1516  ***      0                                  0         $self->_set_option('config', shift @ARGV);
1517                                                     }
1518  ***      0      0                           0      if ( $self->has('config') ) {
1519  ***      0                                  0         my @extra_args;
1520  ***      0                                  0         foreach my $filename ( split(',', $self->get('config')) ) {
1521  ***      0                                  0            eval {
1522  ***      0                                  0               push @extra_args, $self->_read_config_file($filename);
1523                                                           };
1524  ***      0      0                           0            if ( $EVAL_ERROR ) {
1525  ***      0      0                           0               if ( $self->got('config') ) {
1526  ***      0                                  0                  die $EVAL_ERROR;
1527                                                              }
1528                                                              elsif ( MKDEBUG ) {
1529                                                                 _d($EVAL_ERROR);
1530                                                              }
1531                                                           }
1532                                                        }
1533  ***      0                                  0         unshift @ARGV, @extra_args;
1534                                                     }
1535                                                  
1536  ***      0                                  0      Getopt::Long::Configure('no_ignore_case', 'bundling');
1537                                                     GetOptions(
1538  ***      0                    0             0         map    { $_->{spec} => sub { $self->_set_option(@_); } }
      ***      0                                  0   
      ***      0                                  0   
1539  ***      0                                  0         grep   { $_->{long} ne 'config' } # --config is handled specially above.
1540  ***      0      0                           0         values %{$self->{opts}}
1541                                                     ) or $self->save_error('Error parsing options');
1542                                                  
1543  ***      0      0      0                    0      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
1544  ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
1545                                                           $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
1546                                                              or die "Cannot print: $OS_ERROR";
1547  ***      0                                  0         exit 0;
1548                                                     }
1549                                                  
1550  ***      0      0      0                    0      if ( @ARGV && $self->{strict} ) {
1551  ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
1552                                                     }
1553                                                  
1554  ***      0                                  0      foreach my $mutex ( @{$self->{mutex}} ) {
      ***      0                                  0   
1555  ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
1556  ***      0      0                           0         if ( @set > 1 ) {
1557  ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
1558  ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
1559                                                                   . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
1560                                                                   . ' are mutually exclusive.';
1561  ***      0                                  0            $self->save_error($err);
1562                                                        }
1563                                                     }
1564                                                  
1565  ***      0                                  0      foreach my $required ( @{$self->{atleast1}} ) {
      ***      0                                  0   
1566  ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
1567  ***      0      0                           0         if ( @set == 0 ) {
1568  ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
1569  ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
1570                                                                   .' or --'.$self->{opts}->{$required->[-1]}->{long};
1571  ***      0                                  0            $self->save_error("Specify at least one of $err");
1572                                                        }
1573                                                     }
1574                                                  
1575  ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
1576  ***      0                                  0         my $opt = $self->{opts}->{$long};
1577  ***      0      0                           0         if ( $opt->{got} ) {
      ***             0                               
1578  ***      0      0                           0            if ( exists $self->{disables}->{$long} ) {
1579  ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
1580  ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
1581  ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
1582                                                                 'because', $long,'disables them');
1583                                                           }
1584                                                  
1585  ***      0      0                           0            if ( exists $self->{allowed_groups}->{$long} ) {
1586                                                  
1587  ***      0                                  0               my @restricted_groups = grep {
1588  ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
1589  ***      0                                  0               } keys %{$self->{groups}};
1590                                                  
1591  ***      0                                  0               my @restricted_opts;
1592  ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
1593  ***      0                                  0                  RESTRICTED_OPT:
1594  ***      0                                  0                  foreach my $restricted_opt (
1595                                                                    keys %{$self->{groups}->{$restricted_group}} )
1596                                                                 {
1597  ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
1598  ***      0      0                           0                     push @restricted_opts, $restricted_opt
1599                                                                       if $self->{opts}->{$restricted_opt}->{got};
1600                                                                 }
1601                                                              }
1602                                                  
1603  ***      0      0                           0               if ( @restricted_opts ) {
1604  ***      0                                  0                  my $err;
1605  ***      0      0                           0                  if ( @restricted_opts == 1 ) {
1606  ***      0                                  0                     $err = "--$restricted_opts[0]";
1607                                                                 }
1608                                                                 else {
1609  ***      0                                  0                     $err = join(', ',
1610  ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
1611  ***      0                                  0                               grep { $_ } 
1612                                                                              @restricted_opts[0..scalar(@restricted_opts) - 2]
1613                                                                           )
1614                                                                         . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
1615                                                                 }
1616  ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
1617                                                              }
1618                                                           }
1619                                                  
1620                                                        }
1621                                                        elsif ( $opt->{is_required} ) { 
1622  ***      0                                  0            $self->save_error("Required option --$long must be specified");
1623                                                        }
1624                                                  
1625  ***      0                                  0         $self->_validate_type($opt);
1626                                                     }
1627                                                  
1628  ***      0                                  0      $self->{got_opts} = 1;
1629  ***      0                                  0      return;
1630                                                  }
1631                                                  
1632                                                  sub _validate_type {
1633  ***      0                    0             0      my ( $self, $opt ) = @_;
1634  ***      0      0      0                    0      return unless $opt && $opt->{type};
1635  ***      0                                  0      my $val = $opt->{value};
1636                                                  
1637  ***      0      0      0                    0      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
      ***                    0                        
1638  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
1639  ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
1640  ***      0      0                           0         if ( !$suffix ) {
1641  ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
1642  ***      0             0                    0            $suffix = $s || 's';
1643  ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
1644                                                              $opt->{long}, '(value:', $val, ')');
1645                                                        }
1646  ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
1647  ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
1648                                                                : $suffix eq 'm' ? $num * 60       # Minutes
1649                                                                : $suffix eq 'h' ? $num * 3600     # Hours
1650                                                                :                  $num * 86400;   # Days
1651  ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
1652  ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
1653                                                        }
1654                                                        else {
1655  ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
1656                                                        }
1657                                                     }
1658                                                     elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
1659  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
1660  ***      0                                  0         my $prev = {};
1661  ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
1662  ***      0      0                           0         if ( $from_key ) {
1663  ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
1664  ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
1665                                                        }
1666  ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
1667  ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
1668                                                     }
1669                                                     elsif ( $val && $opt->{type} eq 'z' ) {  # type size
1670  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
1671  ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
1672  ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
1673  ***      0      0                           0         if ( defined $num ) {
1674  ***      0      0                           0            if ( $factor ) {
1675  ***      0                                  0               $num *= $factor_for{$factor};
1676  ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
1677                                                                 'to num', $num, '* factor', $factor);
1678                                                           }
1679  ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
1680                                                        }
1681                                                        else {
1682  ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
1683                                                        }
1684                                                     }
1685                                                     elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
1686  ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
1687                                                     }
1688                                                     elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
1689  ***      0             0                    0         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
1690                                                     }
1691                                                     else {
1692  ***      0                                  0         MKDEBUG && _d('Nothing to validate for option',
1693                                                           $opt->{long}, 'type', $opt->{type}, 'value', $val);
1694                                                     }
1695                                                  
1696  ***      0                                  0      return;
1697                                                  }
1698                                                  
1699                                                  sub get {
1700  ***      0                    0             0      my ( $self, $opt ) = @_;
1701  ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1702  ***      0      0      0                    0      die "Option $opt does not exist"
1703                                                        unless $long && exists $self->{opts}->{$long};
1704  ***      0                                  0      return $self->{opts}->{$long}->{value};
1705                                                  }
1706                                                  
1707                                                  sub got {
1708  ***      0                    0             0      my ( $self, $opt ) = @_;
1709  ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1710  ***      0      0      0                    0      die "Option $opt does not exist"
1711                                                        unless $long && exists $self->{opts}->{$long};
1712  ***      0                                  0      return $self->{opts}->{$long}->{got};
1713                                                  }
1714                                                  
1715                                                  sub has {
1716  ***      0                    0             0      my ( $self, $opt ) = @_;
1717  ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1718  ***      0      0                           0      return defined $long ? exists $self->{opts}->{$long} : 0;
1719                                                  }
1720                                                  
1721                                                  sub set {
1722  ***      0                    0             0      my ( $self, $opt, $val ) = @_;
1723  ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1724  ***      0      0      0                    0      die "Option $opt does not exist"
1725                                                        unless $long && exists $self->{opts}->{$long};
1726  ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
1727  ***      0                                  0      return;
1728                                                  }
1729                                                  
1730                                                  sub save_error {
1731  ***      0                    0             0      my ( $self, $error ) = @_;
1732  ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
1733                                                  }
1734                                                  
1735                                                  sub errors {
1736  ***      0                    0             0      my ( $self ) = @_;
1737  ***      0                                  0      return $self->{errors};
1738                                                  }
1739                                                  
1740                                                  sub prompt {
1741  ***      0                    0             0      my ( $self ) = @_;
1742  ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
1743                                                  }
1744                                                  
1745                                                  sub descr {
1746  ***      0                    0             0      my ( $self ) = @_;
1747  ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
1748                                                                . "  For more details, please use the --help option, "
1749                                                                . "or try 'perldoc $PROGRAM_NAME' "
1750                                                                . "for complete documentation.";
1751  ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
1752  ***      0                                  0      $descr =~ s/ +$//mg;
1753  ***      0                                  0      return $descr;
1754                                                  }
1755                                                  
1756                                                  sub usage_or_errors {
1757  ***      0                    0             0      my ( $self ) = @_;
1758  ***      0      0                           0      if ( $self->{opts}->{help}->{got} ) {
      ***      0      0                           0   
1759  ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
1760  ***      0                                  0         exit 0;
1761                                                     }
1762                                                     elsif ( scalar @{$self->{errors}} ) {
1763  ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
1764  ***      0                                  0         exit 0;
1765                                                     }
1766  ***      0                                  0      return;
1767                                                  }
1768                                                  
1769                                                  sub print_errors {
1770  ***      0                    0             0      my ( $self ) = @_;
1771  ***      0                                  0      my $usage = $self->prompt() . "\n";
1772  ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
1773  ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
1774                                                                . "\n";
1775                                                     }
1776  ***      0                                  0      return $usage . "\n" . $self->descr();
1777                                                  }
1778                                                  
1779                                                  sub print_usage {
1780  ***      0                    0             0      my ( $self ) = @_;
1781  ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
1782  ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
1783                                                  
1784  ***      0      0                           0      my $maxl = max(
1785  ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
1786                                                        @opts);
1787                                                  
1788  ***      0      0                           0      my $maxs = max(0,
1789  ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
1790  ***      0                                  0         values %{$self->{short_opts}});
1791                                                  
1792  ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
1793  ***      0                                  0      my $rcol = 80 - $lcol - 6;
1794  ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
1795                                                  
1796  ***      0                                  0      $maxs = max($lcol - 3, $maxs);
1797                                                  
1798  ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
1799                                                  
1800  ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
1801  ***      0                                  0      push @groups, 'default';
1802                                                  
1803  ***      0                                  0      foreach my $group ( reverse @groups ) {
1804  ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
1805  ***      0                                  0         foreach my $opt (
      ***      0                                  0   
1806  ***      0                                  0            sort { $a->{long} cmp $b->{long} }
1807                                                           grep { $_->{group} eq $group }
1808                                                           @opts )
1809                                                        {
1810  ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
1811  ***      0                                  0            my $short = $opt->{short};
1812  ***      0                                  0            my $desc  = $opt->{desc};
1813  ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
1814  ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
1815  ***      0             0                    0               $s    ||= 's';
1816  ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
1817  ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
1818                                                                     . "d=days; if no suffix, $s is used.";
1819                                                           }
1820  ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
1821  ***      0                                  0            $desc =~ s/ +$//mg;
1822  ***      0      0                           0            if ( $short ) {
1823  ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
1824                                                           }
1825                                                           else {
1826  ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
1827                                                           }
1828                                                        }
1829                                                     }
1830                                                  
1831  ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
1832  ***      0                                  0         $usage .= "\nRules:\n\n";
1833  ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
1834                                                     }
1835  ***      0      0                           0      if ( $self->{dp} ) {
1836  ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
1837                                                     }
1838  ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
1839  ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
1840  ***      0                                  0         my $val   = $opt->{value};
1841  ***      0             0                    0         my $type  = $opt->{type} || '';
1842  ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
1843  ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
1844                                                                  : !defined $val             ? '(No value)'
1845                                                                  : $type eq 'd'              ? $self->{dp}->as_string($val)
1846                                                                  : $type =~ m/H|h/           ? join(',', sort keys %$val)
1847                                                                  : $type =~ m/A|a/           ? join(',', @$val)
1848                                                                  :                             $val;
1849  ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
1850                                                     }
1851  ***      0                                  0      return $usage;
1852                                                  }
1853                                                  
1854                                                  sub prompt_noecho {
1855  ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
1856  ***      0                                  0      my ( $prompt ) = @_;
1857  ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
1858  ***      0      0                           0      print $prompt
1859                                                        or die "Cannot print: $OS_ERROR";
1860  ***      0                                  0      my $response;
1861  ***      0                                  0      eval {
1862  ***      0                                  0         require Term::ReadKey;
1863  ***      0                                  0         Term::ReadKey::ReadMode('noecho');
1864  ***      0                                  0         chomp($response = <STDIN>);
1865  ***      0                                  0         Term::ReadKey::ReadMode('normal');
1866  ***      0      0                           0         print "\n"
1867                                                           or die "Cannot print: $OS_ERROR";
1868                                                     };
1869  ***      0      0                           0      if ( $EVAL_ERROR ) {
1870  ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
1871                                                     }
1872  ***      0                                  0      return $response;
1873                                                  }
1874                                                  
1875                                                  if ( MKDEBUG ) {
1876                                                     print '# ', $^X, ' ', $], "\n";
1877                                                     my $uname = `uname -a`;
1878                                                     if ( $uname ) {
1879                                                        $uname =~ s/\s+/ /g;
1880                                                        print "# $uname\n";
1881                                                     }
1882                                                     printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
1883                                                        $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
1884                                                        ($main::SVN_REV || ''), __LINE__);
1885                                                     print('# Arguments: ',
1886                                                        join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
1887                                                  }
1888                                                  
1889                                                  sub _read_config_file {
1890  ***      0                    0             0      my ( $self, $filename ) = @_;
1891  ***      0      0                           0      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
1892  ***      0                                  0      my @args;
1893  ***      0                                  0      my $prefix = '--';
1894  ***      0                                  0      my $parse  = 1;
1895                                                  
1896                                                     LINE:
1897  ***      0                                  0      while ( my $line = <$fh> ) {
1898  ***      0                                  0         chomp $line;
1899  ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
1900  ***      0                                  0         $line =~ s/\s+#.*$//g;
1901  ***      0                                  0         $line =~ s/^\s+|\s+$//g;
1902  ***      0      0                           0         if ( $line eq '--' ) {
1903  ***      0                                  0            $prefix = '';
1904  ***      0                                  0            $parse  = 0;
1905  ***      0                                  0            next LINE;
1906                                                        }
1907  ***      0      0      0                    0         if ( $parse
      ***             0                               
1908                                                           && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
1909                                                        ) {
1910  ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
1911                                                        }
1912                                                        elsif ( $line =~ m/./ ) {
1913  ***      0                                  0            push @args, $line;
1914                                                        }
1915                                                        else {
1916  ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
1917                                                        }
1918                                                     }
1919  ***      0                                  0      close $fh;
1920  ***      0                                  0      return @args;
1921                                                  }
1922                                                  
1923                                                  sub read_para_after {
1924  ***      0                    0             0      my ( $self, $file, $regex ) = @_;
1925  ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
1926  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
1927  ***      0                                  0      my $para;
1928  ***      0                                  0      while ( $para = <$fh> ) {
1929  ***      0      0                           0         next unless $para =~ m/^=pod$/m;
1930  ***      0                                  0         last;
1931                                                     }
1932  ***      0                                  0      while ( $para = <$fh> ) {
1933  ***      0      0                           0         next unless $para =~ m/$regex/;
1934  ***      0                                  0         last;
1935                                                     }
1936  ***      0                                  0      $para = <$fh>;
1937  ***      0                                  0      chomp($para);
1938  ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
1939  ***      0                                  0      return $para;
1940                                                  }
1941                                                  
1942                                                  sub clone {
1943  ***      0                    0             0      my ( $self ) = @_;
1944                                                  
1945  ***      0                                  0      my %clone = map {
1946  ***      0                                  0         my $hashref  = $self->{$_};
1947  ***      0                                  0         my $val_copy = {};
1948  ***      0                                  0         foreach my $key ( keys %$hashref ) {
1949  ***      0                                  0            my $ref = ref $hashref->{$key};
1950  ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
1951  ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
1952  ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
1953                                                                             : $hashref->{$key};
1954                                                        }
1955  ***      0                                  0         $_ => $val_copy;
1956                                                     } qw(opts short_opts defaults);
1957                                                  
1958  ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
1959  ***      0                                  0         $clone{$scalar} = $self->{$scalar};
1960                                                     }
1961                                                  
1962  ***      0                                  0      return bless \%clone;     
1963                                                  }
1964                                                  
1965                                                  sub _d {
1966  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1967  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1968  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1969                                                          @_;
1970  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1971                                                  }
1972                                                  
1973                                                  1;
1974                                                  
1975                                                  # ###########################################################################
1976                                                  # End OptionParser package
1977                                                  # ###########################################################################
1978                                                  
1979                                                  # ###########################################################################
1980                                                  # Transformers package 5266
1981                                                  # ###########################################################################
1982                                                  
1983                                                  package Transformers;
1984                                                  
1985           5                    5            75   use strict;
               5                                 15   
               5                                 45   
1986           5                    5            32   use warnings FATAL => 'all';
               5                                 14   
               5                                 39   
1987           5                    5            31   use English qw(-no_match_vars);
               5                                 26   
               5                                 40   
1988           5                    5            85   use Time::Local qw(timegm timelocal);
               5                                 18   
               5                                 68   
1989           5                    5            40   use Digest::MD5 qw(md5_hex);
               5                                 12   
               5                                 39   
1990                                                  
1991  ***      5            50      5            31   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 15   
               5                                 74   
1992                                                  
1993                                                  require Exporter;
1994                                                  our @ISA         = qw(Exporter);
1995                                                  our %EXPORT_TAGS = ();
1996                                                  our @EXPORT      = ();
1997                                                  our @EXPORT_OK   = qw(
1998                                                     micro_t
1999                                                     percentage_of
2000                                                     secs_to_time
2001                                                     shorten
2002                                                     ts
2003                                                     parse_timestamp
2004                                                     unix_timestamp
2005                                                     any_unix_timestamp
2006                                                     make_checksum
2007                                                  );
2008                                                  
2009                                                  our $mysql_ts  = qr/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?/;
2010                                                  our $proper_ts = qr/(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(\.\d+)?/;
2011                                                  our $n_ts      = qr/(\d{1,5})([shmd]?)/; # Limit \d{1,5} because \d{6} looks
2012                                                  
2013                                                  sub micro_t {
2014  ***      0                    0             0      my ( $t, %args ) = @_;
2015  ***      0      0                           0      my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
2016  ***      0      0                           0      my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
2017  ***      0                                  0      my $f;
2018                                                  
2019  ***      0      0                           0      $t = 0 if $t < 0;
2020                                                  
2021  ***      0      0                           0      $t = sprintf('%.17f', $t) if $t =~ /e/;
2022                                                  
2023  ***      0                                  0      $t =~ s/\.(\d{1,6})\d*/\.$1/;
2024                                                  
2025  ***      0      0      0                    0      if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
2026  ***      0                                  0         $f = ($t * 1000000) . 'us';
2027                                                     }
2028                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
2029  ***      0                                  0         $f = sprintf("%.${p_ms}f", $t * 1000);
2030  ***      0                                  0         $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
2031                                                     }
2032                                                     elsif ($t >= 1) {
2033  ***      0                                  0         $f = sprintf("%.${p_s}f", $t);
2034  ***      0                                  0         $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
2035                                                     }
2036                                                     else {
2037  ***      0                                  0         $f = 0;  # $t should = 0 at this point
2038                                                     }
2039                                                  
2040  ***      0                                  0      return $f;
2041                                                  }
2042                                                  
2043                                                  sub percentage_of {
2044  ***      0                    0             0      my ( $is, $of, %args ) = @_;
2045  ***      0             0                    0      my $p   = $args{p} || 0; # float precision
2046  ***      0      0                           0      my $fmt = $p ? "%.${p}f" : "%d";
2047  ***      0             0                    0      return sprintf $fmt, ($is * 100) / ($of ||= 1);
2048                                                  }
2049                                                  
2050                                                  sub secs_to_time {
2051  ***      0                    0             0      my ( $secs, $fmt ) = @_;
2052  ***      0             0                    0      $secs ||= 0;
2053  ***      0      0                           0      return '00:00' unless $secs;
2054                                                  
2055  ***      0      0      0                    0      $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
2056                                                            : $secs >= 3_600  ? 'h'
2057                                                            :                   'm';
2058                                                  
2059                                                     return
2060  ***      0      0                           0         $fmt eq 'd' ? sprintf(
      ***             0                               
2061                                                           "%d+%02d:%02d:%02d",
2062                                                           int($secs / 86_400),
2063                                                           int(($secs % 86_400) / 3_600),
2064                                                           int(($secs % 3_600) / 60),
2065                                                           $secs % 60)
2066                                                        : $fmt eq 'h' ? sprintf(
2067                                                           "%02d:%02d:%02d",
2068                                                           int(($secs % 86_400) / 3_600),
2069                                                           int(($secs % 3_600) / 60),
2070                                                           $secs % 60)
2071                                                        : sprintf(
2072                                                           "%02d:%02d",
2073                                                           int(($secs % 3_600) / 60),
2074                                                           $secs % 60);
2075                                                  }
2076                                                  
2077                                                  sub shorten {
2078  ***      0                    0             0      my ( $num, %args ) = @_;
2079  ***      0      0                           0      my $p = defined $args{p} ? $args{p} : 2;     # float precision
2080  ***      0      0                           0      my $d = defined $args{d} ? $args{d} : 1_024; # divisor
2081  ***      0                                  0      my $n = 0;
2082  ***      0                                  0      my @units = ('', qw(k M G T P E Z Y));
2083  ***      0             0                    0      while ( $num >= $d && $n < @units - 1 ) {
2084  ***      0                                  0         $num /= $d;
2085  ***      0                                  0         ++$n;
2086                                                     }
2087  ***      0      0      0                    0      return sprintf(
2088                                                        $num =~ m/\./ || $n
2089                                                           ? "%.${p}f%s"
2090                                                           : '%d',
2091                                                        $num, $units[$n]);
2092                                                  }
2093                                                  
2094                                                  sub ts {
2095  ***      0                    0             0      my ( $time, $gmt ) = @_;
2096  ***      0      0                           0      my ( $sec, $min, $hour, $mday, $mon, $year )
2097                                                        = $gmt ? gmtime($time) : localtime($time);
2098  ***      0                                  0      $mon  += 1;
2099  ***      0                                  0      $year += 1900;
2100  ***      0                                  0      my $val = sprintf("%d-%02d-%02dT%02d:%02d:%02d",
2101                                                        $year, $mon, $mday, $hour, $min, $sec);
2102  ***      0      0                           0      if ( my ($us) = $time =~ m/(\.\d+)$/ ) {
2103  ***      0                                  0         $us = sprintf("%.6f", $us);
2104  ***      0                                  0         $us =~ s/^0\././;
2105  ***      0                                  0         $val .= $us;
2106                                                     }
2107  ***      0                                  0      return $val;
2108                                                  }
2109                                                  
2110                                                  sub parse_timestamp {
2111  ***      0                    0             0      my ( $val ) = @_;
2112  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $f)
2113                                                           = $val =~ m/^$mysql_ts$/ )
2114                                                     {
2115  ***      0      0                           0         return sprintf "%d-%02d-%02d %02d:%02d:"
      ***             0                               
2116                                                                       . (defined $f ? '%02.6f' : '%02d'),
2117                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
2118                                                     }
2119  ***      0                                  0      return $val;
2120                                                  }
2121                                                  
2122                                                  sub unix_timestamp {
2123  ***      0                    0             0      my ( $val, $gmt ) = @_;
2124  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $us) = $val =~ m/^$proper_ts$/ ) {
2125  ***      0      0                           0         $val = $gmt
2126                                                           ? timegm($s, $i, $h, $d, $m - 1, $y)
2127                                                           : timelocal($s, $i, $h, $d, $m - 1, $y);
2128  ***      0      0                           0         if ( defined $us ) {
2129  ***      0                                  0            $us = sprintf('%.6f', $us);
2130  ***      0                                  0            $us =~ s/^0\././;
2131  ***      0                                  0            $val .= $us;
2132                                                        }
2133                                                     }
2134  ***      0                                  0      return $val;
2135                                                  }
2136                                                  
2137                                                  sub any_unix_timestamp {
2138  ***      0                    0             0      my ( $val, $callback ) = @_;
2139                                                  
2140  ***      0      0                           0      if ( my ($n, $suffix) = $val =~ m/^$n_ts$/ ) {
      ***             0                               
      ***             0                               
2141  ***      0      0                           0         $n = $suffix eq 's' ? $n            # Seconds
      ***             0                               
      ***             0                               
      ***             0                               
2142                                                           : $suffix eq 'm' ? $n * 60       # Minutes
2143                                                           : $suffix eq 'h' ? $n * 3600     # Hours
2144                                                           : $suffix eq 'd' ? $n * 86400    # Days
2145                                                           :                  $n;           # default: Seconds
2146  ***      0                                  0         MKDEBUG && _d('ts is now - N[shmd]:', $n);
2147  ***      0                                  0         return time - $n;
2148                                                     }
2149                                                     elsif ( my ($ymd, $hms) = $val =~ m/^(\d{6})(?:\s+(\d+:\d+:\d+))?/ ) {
2150  ***      0                                  0         MKDEBUG && _d('ts is MySQL slow log timestamp');
2151  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
2152  ***      0                                  0         return unix_timestamp(parse_timestamp($val));
2153                                                     }
2154                                                     elsif ( ($ymd, $hms) = $val =~ m/^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) {
2155  ***      0                                  0         MKDEBUG && _d('ts is properly formatted timestamp');
2156  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
2157  ***      0                                  0         return unix_timestamp($val);
2158                                                     }
2159                                                     else {
2160  ***      0                                  0         MKDEBUG && _d('ts is MySQL expression');
2161  ***      0      0      0                    0         return $callback->($val) if $callback && ref $callback eq 'CODE';
2162                                                     }
2163                                                  
2164  ***      0                                  0      MKDEBUG && _d('Unknown ts type:', $val);
2165  ***      0                                  0      return;
2166                                                  }
2167                                                  
2168                                                  sub make_checksum {
2169  ***      0                    0             0      my ( $val ) = @_;
2170  ***      0                                  0      my $checksum = uc substr(md5_hex($val), -16);
2171  ***      0                                  0      MKDEBUG && _d($checksum, 'checksum for', $val);
2172  ***      0                                  0      return $checksum;
2173                                                  }
2174                                                  
2175                                                  sub _d {
2176  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2177  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2178  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2179                                                          @_;
2180  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2181                                                  }
2182                                                  
2183                                                  1;
2184                                                  
2185                                                  # ###########################################################################
2186                                                  # End Transformers package
2187                                                  # ###########################################################################
2188                                                  
2189                                                  # ###########################################################################
2190                                                  # SlowLogParser package 5357
2191                                                  # ###########################################################################
2192                                                  package SlowLogParser;
2193                                                  
2194           5                    5            56   use strict;
               5                                 15   
               5                                 40   
2195           5                    5            33   use warnings FATAL => 'all';
               5                                 16   
               5                                 40   
2196           5                    5            31   use English qw(-no_match_vars);
               5                                 13   
               5                                 36   
2197           5                    5            52   use Data::Dumper;
               5                                 13   
               5                                 38   
2198                                                  
2199  ***      5            50      5            32   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 13   
               5                                 88   
2200                                                  
2201                                                  sub new {
2202  ***      0                    0             0      my ( $class ) = @_;
2203  ***      0                                  0      my $self = {
2204                                                        pending => [],
2205                                                     };
2206  ***      0                                  0      return bless $self, $class;
2207                                                  }
2208                                                  
2209                                                  my $slow_log_ts_line = qr/^# Time: ([0-9: ]{15})/;
2210                                                  my $slow_log_uh_line = qr/# User\@Host: ([^\[]+|\[[^[]+\]).*?@ (\S*) \[(.*)\]/;
2211                                                  my $slow_log_hd_line = qr{
2212                                                        ^(?:
2213                                                        T[cC][pP]\s[pP]ort:\s+\d+ # case differs on windows/unix
2214                                                        |
2215                                                        [/A-Z].*mysqld,\sVersion.*(?:started\swith:|embedded\slibrary)
2216                                                        |
2217                                                        Time\s+Id\s+Command
2218                                                        ).*\n
2219                                                     }xm;
2220                                                  
2221                                                  sub parse_event {
2222  ***      0                    0             0      my ( $self, %args ) = @_;
2223  ***      0                                  0      my @required_args = qw(next_event tell);
2224  ***      0                                  0      foreach my $arg ( @required_args ) {
2225  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
2226                                                     }
2227  ***      0                                  0      my ($next_event, $tell) = @args{@required_args};
2228                                                  
2229  ***      0                                  0      my $pending = $self->{pending};
2230  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = ";\n#";
2231  ***      0                                  0      my $trimlen    = length($INPUT_RECORD_SEPARATOR);
2232  ***      0                                  0      my $pos_in_log = $tell->();
2233  ***      0                                  0      my $stmt;
2234                                                  
2235                                                     EVENT:
2236  ***      0             0                    0      while (
2237                                                           defined($stmt = shift @$pending)
2238                                                        or defined($stmt = $next_event->())
2239                                                     ) {
2240  ***      0                                  0         my @properties = ('cmd', 'Query', 'pos_in_log', $pos_in_log);
2241  ***      0                                  0         $pos_in_log = $tell->();
2242                                                  
2243  ***      0      0                           0         if ( $stmt =~ s/$slow_log_hd_line//go ){ # Throw away header lines in log
2244  ***      0                                  0            my @chunks = split(/$INPUT_RECORD_SEPARATOR/o, $stmt);
2245  ***      0      0                           0            if ( @chunks > 1 ) {
2246  ***      0                                  0               MKDEBUG && _d("Found multiple chunks");
2247  ***      0                                  0               $stmt = shift @chunks;
2248  ***      0                                  0               unshift @$pending, @chunks;
2249                                                           }
2250                                                        }
2251                                                  
2252  ***      0      0                           0         $stmt = '#' . $stmt unless $stmt =~ m/\A#/;
2253  ***      0                                  0         $stmt =~ s/;\n#?\Z//;
2254                                                  
2255                                                  
2256  ***      0                                  0         my ($got_ts, $got_uh, $got_ac, $got_db, $got_set, $got_embed);
2257  ***      0                                  0         my $pos = 0;
2258  ***      0                                  0         my $len = length($stmt);
2259  ***      0                                  0         my $found_arg = 0;
2260                                                        LINE:
2261  ***      0                                  0         while ( $stmt =~ m/^(.*)$/mg ) { # /g is important, requires scalar match.
2262  ***      0                                  0            $pos     = pos($stmt);  # Be careful not to mess this up!
2263  ***      0                                  0            my $line = $1;          # Necessary for /g and pos() to work.
2264  ***      0                                  0            MKDEBUG && _d($line);
2265                                                  
2266  ***      0      0                           0            if ($line =~ m/^(?:#|use |SET (?:last_insert_id|insert_id|timestamp))/o) {
2267                                                  
2268  ***      0      0      0                    0               if ( !$got_ts && (my ( $time ) = $line =~ m/$slow_log_ts_line/o)) {
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***             0                               
2269  ***      0                                  0                  MKDEBUG && _d("Got ts", $time);
2270  ***      0                                  0                  push @properties, 'ts', $time;
2271  ***      0                                  0                  ++$got_ts;
2272  ***      0      0      0                    0                  if ( !$got_uh
2273                                                                    && ( my ( $user, $host, $ip ) = $line =~ m/$slow_log_uh_line/o )
2274                                                                 ) {
2275  ***      0                                  0                     MKDEBUG && _d("Got user, host, ip", $user, $host, $ip);
2276  ***      0                                  0                     push @properties, 'user', $user, 'host', $host, 'ip', $ip;
2277  ***      0                                  0                     ++$got_uh;
2278                                                                 }
2279                                                              }
2280                                                  
2281                                                              elsif ( !$got_uh
2282                                                                    && ( my ( $user, $host, $ip ) = $line =~ m/$slow_log_uh_line/o )
2283                                                              ) {
2284  ***      0                                  0                  MKDEBUG && _d("Got user, host, ip", $user, $host, $ip);
2285  ***      0                                  0                  push @properties, 'user', $user, 'host', $host, 'ip', $ip;
2286  ***      0                                  0                  ++$got_uh;
2287                                                              }
2288                                                  
2289                                                              elsif (!$got_ac && $line =~ m/^# (?:administrator command:.*)$/) {
2290  ***      0                                  0                  MKDEBUG && _d("Got admin command");
2291  ***      0                                  0                  push @properties, 'cmd', 'Admin', 'arg', $line;
2292  ***      0                                  0                  push @properties, 'bytes', length($properties[-1]);
2293  ***      0                                  0                  ++$found_arg;
2294  ***      0                                  0                  ++$got_ac;
2295                                                              }
2296                                                  
2297                                                              elsif ( $line =~ m/^# +[A-Z][A-Za-z_]+: \S+/ ) { # Make the test cheap!
2298  ***      0                                  0                  MKDEBUG && _d("Got some line with properties");
2299  ***      0                                  0                  my @temp = $line =~ m/(\w+):\s+(\S+|\Z)/g;
2300  ***      0                                  0                  push @properties, @temp;
2301                                                              }
2302                                                  
2303                                                              elsif ( !$got_db && (my ( $db ) = $line =~ m/^use ([^;]+)/ ) ) {
2304  ***      0                                  0                  MKDEBUG && _d("Got a default database:", $db);
2305  ***      0                                  0                  push @properties, 'db', $db;
2306  ***      0                                  0                  ++$got_db;
2307                                                              }
2308                                                  
2309                                                              elsif (!$got_set && (my ($setting) = $line =~ m/^SET\s+([^;]*)/)) {
2310  ***      0                                  0                  MKDEBUG && _d("Got some setting:", $setting);
2311  ***      0                                  0                  push @properties, split(/,|\s*=\s*/, $setting);
2312  ***      0                                  0                  ++$got_set;
2313                                                              }
2314                                                  
2315  ***      0      0      0                    0               if ( !$found_arg && $pos == $len ) {
2316  ***      0                                  0                  MKDEBUG && _d("Did not find arg, looking for special cases");
2317  ***      0                                  0                  local $INPUT_RECORD_SEPARATOR = ";\n";
2318  ***      0      0                           0                  if ( defined(my $l = $next_event->()) ) {
2319  ***      0                                  0                     chomp $l;
2320  ***      0                                  0                     MKDEBUG && _d("Found admin statement", $l);
2321  ***      0                                  0                     push @properties, 'cmd', 'Admin', 'arg', '#' . $l;
2322  ***      0                                  0                     push @properties, 'bytes', length($properties[-1]);
2323  ***      0                                  0                     $found_arg++;
2324                                                                 }
2325                                                                 else {
2326  ***      0                                  0                     MKDEBUG && _d("I can't figure out what to do with this line");
2327  ***      0                                  0                     next EVENT;
2328                                                                 }
2329                                                              }
2330                                                           }
2331                                                           else {
2332  ***      0                                  0               MKDEBUG && _d("Got the query/arg line");
2333  ***      0                                  0               my $arg = substr($stmt, $pos - length($line));
2334  ***      0                                  0               push @properties, 'arg', $arg, 'bytes', length($arg);
2335  ***      0      0      0                    0               if ( $args{misc} && $args{misc}->{embed}
      ***                    0                        
2336                                                                 && ( my ($e) = $arg =~ m/($args{misc}->{embed})/)
2337                                                              ) {
2338  ***      0                                  0                  push @properties, $e =~ m/$args{misc}->{capture}/g;
2339                                                              }
2340  ***      0                                  0               last LINE;
2341                                                           }
2342                                                        }
2343                                                  
2344  ***      0                                  0         MKDEBUG && _d('Properties of event:', Dumper(\@properties));
2345  ***      0                                  0         my $event = { @properties };
2346  ***      0                                  0         return $event;
2347                                                     } # EVENT
2348                                                  
2349  ***      0                                  0      @$pending = ();
2350  ***      0      0                           0      $args{oktorun}->(0) if $args{oktorun};
2351  ***      0                                  0      return;
2352                                                  }
2353                                                  
2354                                                  sub _d {
2355  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2356  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2357  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2358                                                          @_;
2359  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2360                                                  }
2361                                                  
2362                                                  1;
2363                                                  
2364                                                  # ###########################################################################
2365                                                  # End SlowLogParser package
2366                                                  # ###########################################################################
2367                                                  
2368                                                  # ###########################################################################
2369                                                  # EventAggregator package 4916
2370                                                  # ###########################################################################
2371                                                  package EventAggregator;
2372                                                  
2373           5                    5            62   use strict;
               5                                 15   
               5                                 51   
2374           5                    5            40   use warnings FATAL => 'all';
               5                                 15   
               5                                 37   
2375           5                    5            35   use English qw(-no_match_vars);
               5                                 12   
               5                                 38   
2376                                                  
2377           5                    5            52   use constant MKDEBUG      => $ENV{MKDEBUG};
               5                                 14   
               5                                 56   
2378           5                    5            31   use constant BUCK_SIZE    => 1.05;
               5                                 14   
               5                                 24   
2379           5                    5            31   use constant BASE_LOG     => log(BUCK_SIZE);
               5                                 14   
               5                                 23   
2380           5                    5            51   use constant BASE_OFFSET  => abs(1 - log(0.000001) / BASE_LOG); # 284.1617969
               5                                 13   
               5                                 29   
2381           5                    5           112   use constant NUM_BUCK     => 1000;
               5                                 13   
               5                                 23   
2382           5                    5            29   use constant MIN_BUCK     => .000001;
               5                                 13   
               5                                 23   
2383                                                  
2384                                                  our @buckets  = map { 0 } (0..NUM_BUCK-1);
2385                                                  
2386                                                  my @buck_vals = map { bucket_value($_); } (0..NUM_BUCK-1);
2387                                                  
2388                                                  sub new {
2389  ***      0                    0             0      my ( $class, %args ) = @_;
2390  ***      0                                  0      foreach my $arg ( qw(groupby worst) ) {
2391  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
2392                                                     }
2393  ***      0             0                    0      my $attributes = $args{attributes} || {};
2394  ***      0                                  0      my $self = {
2395                                                        groupby        => $args{groupby},
2396                                                        detect_attribs => scalar keys %$attributes == 0 ? 1 : 0,
2397                                                        all_attribs    => [ keys %$attributes ],
2398                                                        ignore_attribs => {
2399  ***      0                                  0            map  { $_ => $args{attributes}->{$_} }
2400  ***      0                                  0            grep { $_ ne $args{groupby} }
2401  ***      0                                  0            @{$args{ignore_attributes}}
2402                                                        },
2403                                                        attributes     => {
2404  ***      0                                  0            map  { $_ => $args{attributes}->{$_} }
2405  ***      0                                  0            grep { $_ ne $args{groupby} }
2406                                                           keys %$attributes
2407                                                        },
2408                                                        alt_attribs    => {
2409  ***      0                                  0            map  { $_ => make_alt_attrib(@{$args{attributes}->{$_}}) }
      ***      0                                  0   
2410  ***      0      0                           0            grep { $_ ne $args{groupby} }
2411                                                           keys %$attributes
2412                                                        },
2413                                                        worst        => $args{worst},
2414                                                        unroll_limit => $args{unroll_limit} || 1000,
2415                                                        attrib_limit => $args{attrib_limit},
2416                                                        result_classes => {},
2417                                                        result_globals => {},
2418                                                        result_samples => {},
2419                                                        n_events       => 0,
2420                                                        unrolled_loops => undef,
2421  ***      0      0      0                    0         type_for       => { %{$args{type_for} || { Query_time => 'num' }} },
2422                                                     };
2423  ***      0                                  0      return bless $self, $class;
2424                                                  }
2425                                                  
2426                                                  sub reset_aggregated_data {
2427  ***      0                    0             0      my ( $self ) = @_;
2428  ***      0                                  0      foreach my $class ( values %{$self->{result_classes}} ) {
      ***      0                                  0   
2429  ***      0                                  0         foreach my $attrib ( values %$class ) {
2430  ***      0                                  0            delete @{$attrib}{keys %$attrib};
      ***      0                                  0   
2431                                                        }
2432                                                     }
2433  ***      0                                  0      foreach my $class ( values %{$self->{result_globals}} ) {
      ***      0                                  0   
2434  ***      0                                  0         delete @{$class}{keys %$class};
      ***      0                                  0   
2435                                                     }
2436  ***      0                                  0      delete @{$self->{result_samples}}{keys %{$self->{result_samples}}};
      ***      0                                  0   
      ***      0                                  0   
2437  ***      0                                  0      $self->{n_events} = 0;
2438                                                  }
2439                                                  
2440                                                  sub aggregate {
2441  ***      0                    0             0      my ( $self, $event ) = @_;
2442                                                  
2443  ***      0                                  0      my $group_by = $event->{$self->{groupby}};
2444  ***      0      0                           0      return unless defined $group_by;
2445                                                  
2446  ***      0                                  0      $self->{n_events}++;
2447  ***      0                                  0      MKDEBUG && _d('event', $self->{n_events});
2448                                                  
2449  ***      0      0                           0      return $self->{unrolled_loops}->($self, $event, $group_by)
2450                                                        if $self->{unrolled_loops};
2451                                                  
2452  ***      0      0                           0      if ( $self->{n_events} <= $self->{unroll_limit} ) {
2453                                                  
2454  ***      0      0                           0         $self->add_new_attributes($event) if $self->{detect_attribs};
2455                                                  
2456  ***      0                                  0         ATTRIB:
2457  ***      0                                  0         foreach my $attrib ( keys %{$self->{attributes}} ) {
2458                                                  
2459  ***      0      0                           0            if ( !exists $event->{$attrib} ) {
2460  ***      0                                  0               MKDEBUG && _d("attrib doesn't exist in event:", $attrib);
2461  ***      0                                  0               my $alt_attrib = $self->{alt_attribs}->{$attrib}->($event);
2462  ***      0                                  0               MKDEBUG && _d('alt attrib:', $alt_attrib);
2463  ***      0      0                           0               next ATTRIB unless $alt_attrib;
2464                                                           }
2465                                                  
2466                                                           GROUPBY:
2467  ***      0      0                           0            foreach my $val ( ref $group_by ? @$group_by : ($group_by) ) {
2468  ***      0             0                    0               my $class_attrib  = $self->{result_classes}->{$val}->{$attrib} ||= {};
2469  ***      0             0                    0               my $global_attrib = $self->{result_globals}->{$attrib} ||= {};
2470  ***      0                                  0               my $samples       = $self->{result_samples};
2471  ***      0                                  0               my $handler = $self->{handlers}->{ $attrib };
2472  ***      0      0                           0               if ( !$handler ) {
2473  ***      0                                  0                  $handler = $self->make_handler(
2474                                                                    $attrib,
2475                                                                    $event,
2476                                                                    wor => $self->{worst} eq $attrib,
2477                                                                    alt => $self->{attributes}->{$attrib},
2478                                                                 );
2479  ***      0                                  0                  $self->{handlers}->{$attrib} = $handler;
2480                                                              }
2481  ***      0      0                           0               next GROUPBY unless $handler;
2482  ***      0             0                    0               $samples->{$val} ||= $event; # Initialize to the first event.
2483  ***      0                                  0               $handler->($event, $class_attrib, $global_attrib, $samples, $group_by);
2484                                                           }
2485                                                        }
2486                                                     }
2487                                                     else {
2488  ***      0                                  0         $self->_make_unrolled_loops($event);
2489  ***      0                                  0         $self->{unrolled_loops}->($self, $event, $group_by);
2490                                                     }
2491                                                  
2492  ***      0                                  0      return;
2493                                                  }
2494                                                  
2495                                                  sub _make_unrolled_loops {
2496  ***      0                    0             0      my ( $self, $event ) = @_;
2497                                                  
2498  ***      0                                  0      my $group_by = $event->{$self->{groupby}};
2499                                                  
2500  ***      0                                  0      my @attrs   = grep { $self->{handlers}->{$_} } keys %{$self->{attributes}};
      ***      0                                  0   
      ***      0                                  0   
2501  ***      0                                  0      my $globs   = $self->{result_globals}; # Global stats for each
2502  ***      0                                  0      my $samples = $self->{result_samples};
2503                                                  
2504  ***      0      0                           0      my @lines = (
2505                                                        'my ( $self, $event, $group_by ) = @_;',
2506                                                        'my ($val, $class, $global, $idx);',
2507                                                        (ref $group_by ? ('foreach my $group_by ( @$group_by ) {') : ()),
2508                                                        'my $temp = $self->{result_classes}->{ $group_by }
2509                                                           ||= { map { $_ => { } } @attrs };',
2510                                                        '$samples->{$group_by} ||= $event;', # Always start with the first.
2511                                                     );
2512  ***      0                                  0      foreach my $i ( 0 .. $#attrs ) {
2513  ***      0                                  0         push @lines, (
2514                                                           '$class  = $temp->{\''  . $attrs[$i] . '\'};',
2515                                                           '$global = $globs->{\'' . $attrs[$i] . '\'};',
2516                                                           $self->{unrolled_for}->{$attrs[$i]},
2517                                                        );
2518                                                     }
2519  ***      0      0                           0      if ( ref $group_by ) {
2520  ***      0                                  0         push @lines, '}'; # Close the loop opened above
2521                                                     }
2522  ***      0                                  0      @lines = map { s/^/   /gm; $_ } @lines; # Indent for debugging
      ***      0                                  0   
      ***      0                                  0   
2523  ***      0                                  0      unshift @lines, 'sub {';
2524  ***      0                                  0      push @lines, '}';
2525                                                  
2526  ***      0                                  0      my $code = join("\n", @lines);
2527  ***      0                                  0      MKDEBUG && _d('Unrolled subroutine:', @lines);
2528  ***      0                                  0      my $sub = eval $code;
2529  ***      0      0                           0      die $EVAL_ERROR if $EVAL_ERROR;
2530  ***      0                                  0      $self->{unrolled_loops} = $sub;
2531                                                  
2532  ***      0                                  0      return;
2533                                                  }
2534                                                  
2535                                                  sub results {
2536  ***      0                    0             0      my ( $self ) = @_;
2537                                                     return {
2538  ***      0                                  0         classes => $self->{result_classes},
2539                                                        globals => $self->{result_globals},
2540                                                        samples => $self->{result_samples},
2541                                                     };
2542                                                  }
2543                                                  
2544                                                  sub attributes {
2545  ***      0                    0             0      my ( $self ) = @_;
2546  ***      0                                  0      return $self->{type_for};
2547                                                  }
2548                                                  
2549                                                  sub type_for {
2550  ***      0                    0             0      my ( $self, $attrib ) = @_;
2551  ***      0                                  0      return $self->{type_for}->{$attrib};
2552                                                  }
2553                                                  
2554                                                  sub make_handler {
2555  ***      0                    0             0      my ( $self, $attrib, $event, %args ) = @_;
2556  ***      0      0                           0      die "I need an attrib" unless defined $attrib;
2557  ***      0                                  0      my ($val) = grep { defined $_ } map { $event->{$_} } @{ $args{alt} };
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
2558  ***      0                                  0      my $is_array = 0;
2559  ***      0      0                           0      if (ref $val eq 'ARRAY') {
2560  ***      0                                  0         $is_array = 1;
2561  ***      0                                  0         $val      = $val->[0];
2562                                                     }
2563  ***      0      0                           0      return unless defined $val; # Can't decide type if it's undef.
2564                                                  
2565  ***      0                                  0      my $float_re = qr{[+-]?(?:(?=\d|[.])\d+(?:[.])\d{0,})(?:E[+-]?\d+)?}i;
2566  ***      0      0                           0      my $type = $self->type_for($attrib)         ? $self->type_for($attrib)
      ***             0                               
      ***             0                               
2567                                                              : $val  =~ m/^(?:\d+|$float_re)$/o ? 'num'
2568                                                              : $val  =~ m/^(?:Yes|No)$/         ? 'bool'
2569                                                              :                                    'string';
2570  ***      0                                  0      MKDEBUG && _d('Type for', $attrib, 'is', $type,
2571                                                        '(sample:', $val, '), is array:', $is_array);
2572  ***      0                                  0      $self->{type_for}->{$attrib} = $type;
2573                                                  
2574  ***      0      0                           0      %args = ( # Set up defaults
      ***             0                               
      ***             0                               
      ***             0                               
2575                                                        min => 1,
2576                                                        max => 1,
2577                                                        sum => $type =~ m/num|bool/    ? 1 : 0,
2578                                                        cnt => 1,
2579                                                        unq => $type =~ m/bool|string/ ? 1 : 0,
2580                                                        all => $type eq 'num'          ? 1 : 0,
2581                                                        glo => 1,
2582                                                        trf => ($type eq 'bool') ? q{(($val || '') eq 'Yes') ? 1 : 0} : undef,
2583                                                        wor => 0,
2584                                                        alt => [],
2585                                                        %args,
2586                                                     );
2587                                                  
2588  ***      0                                  0      my @lines = ("# type: $type"); # Lines of code for the subroutine
2589  ***      0      0                           0      if ( $args{trf} ) {
2590  ***      0                                  0         push @lines, q{$val = } . $args{trf} . ';';
2591                                                     }
2592                                                  
2593  ***      0                                  0      foreach my $place ( qw($class $global) ) {
2594  ***      0                                  0         my @tmp;
2595  ***      0      0                           0         if ( $args{min} ) {
2596  ***      0      0                           0            my $op   = $type eq 'num' ? '<' : 'lt';
2597  ***      0                                  0            push @tmp, (
2598                                                              'PLACE->{min} = $val if !defined PLACE->{min} || $val '
2599                                                                 . $op . ' PLACE->{min};',
2600                                                           );
2601                                                        }
2602  ***      0      0                           0         if ( $args{max} ) {
2603  ***      0      0                           0            my $op = ($type eq 'num') ? '>' : 'gt';
2604  ***      0                                  0            push @tmp, (
2605                                                              'PLACE->{max} = $val if !defined PLACE->{max} || $val '
2606                                                                 . $op . ' PLACE->{max};',
2607                                                           );
2608                                                        }
2609  ***      0      0                           0         if ( $args{sum} ) {
2610  ***      0                                  0            push @tmp, 'PLACE->{sum} += $val;';
2611                                                        }
2612  ***      0      0                           0         if ( $args{cnt} ) {
2613  ***      0                                  0            push @tmp, '++PLACE->{cnt};';
2614                                                        }
2615  ***      0      0                           0         if ( $args{all} ) {
2616  ***      0                                  0            push @tmp, (
2617                                                              'exists PLACE->{all} or PLACE->{all} = [ @buckets ];',
2618                                                              '++PLACE->{all}->[ EventAggregator::bucket_idx($val) ];',
2619                                                           );
2620                                                        }
2621  ***      0                                  0         push @lines, map { s/PLACE/$place/g; $_ } @tmp;
      ***      0                                  0   
      ***      0                                  0   
2622                                                     }
2623                                                  
2624  ***      0      0                           0      if ( $args{unq} ) {
2625  ***      0                                  0         push @lines, '++$class->{unq}->{$val};';
2626                                                     }
2627  ***      0      0                           0      if ( $args{wor} ) {
2628  ***      0      0                           0         my $op = $type eq 'num' ? '>=' : 'ge';
2629  ***      0                                  0         push @lines, (
2630                                                           'if ( $val ' . $op . ' ($class->{max} || 0) ) {',
2631                                                           '   $samples->{$group_by} = $event;',
2632                                                           '}',
2633                                                        );
2634                                                     }
2635                                                  
2636  ***      0                                  0      my @broken_query_time;
2637  ***      0      0                           0      if ( $attrib eq 'Query_time' ) {
2638  ***      0                                  0         push @broken_query_time, (
2639                                                           '$val =~ s/^(\d+(?:\.\d+)?).*/$1/;',
2640                                                           '$event->{\''.$attrib.'\'} = $val;',
2641                                                        );
2642                                                     }
2643                                                  
2644  ***      0                                  0      my @limit;
2645  ***      0      0      0                    0      if ( $args{all} && $type eq 'num' && $self->{attrib_limit} ) {
      ***                    0                        
2646  ***      0                                  0         push @limit, (
2647                                                           "if ( \$val > $self->{attrib_limit} ) {",
2648                                                           '   $val = $class->{last} ||= 0;',
2649                                                           '}',
2650                                                           '$class->{last} = $val;',
2651                                                        );
2652                                                     }
2653                                                  
2654  ***      0                                  0      my @unrolled = (
2655                                                        "\$val = \$event->{'$attrib'};",
2656                                                        ($is_array ? ('foreach my $val ( @$val ) {') : ()),
2657  ***      0                                  0         (map { "\$val = \$event->{'$_'} unless defined \$val;" }
2658  ***      0                                  0            grep { $_ ne $attrib } @{$args{alt}}),
      ***      0                                  0   
2659                                                        'defined $val && do {',
2660  ***      0      0                           0         ( map { s/^/   /gm; $_ } (@broken_query_time, @limit, @lines) ), # Indent for debugging
      ***      0      0                           0   
2661                                                        '};',
2662                                                        ($is_array ? ('}') : ()),
2663                                                     );
2664  ***      0                                  0      $self->{unrolled_for}->{$attrib} = join("\n", @unrolled);
2665                                                  
2666  ***      0                                  0      unshift @lines, (
2667                                                        'sub {',
2668                                                        'my ( $event, $class, $global, $samples, $group_by ) = @_;',
2669                                                        'my ($val, $idx);', # NOTE: define all variables here
2670                                                        "\$val = \$event->{'$attrib'};",
2671  ***      0                                  0         (map { "\$val = \$event->{'$_'} unless defined \$val;" }
2672  ***      0      0                           0            grep { $_ ne $attrib } @{$args{alt}}),
      ***      0      0                           0   
2673                                                        'return unless defined $val;',
2674                                                        ($is_array ? ('foreach my $val ( @$val ) {') : ()),
2675                                                        @broken_query_time,
2676                                                        @limit,
2677                                                        ($is_array ? ('}') : ()),
2678                                                     );
2679  ***      0                                  0      push @lines, '}';
2680  ***      0                                  0      my $code = join("\n", @lines);
2681  ***      0                                  0      $self->{code_for}->{$attrib} = $code;
2682                                                  
2683  ***      0                                  0      MKDEBUG && _d('Metric handler for', $attrib, ':', @lines);
2684  ***      0                                  0      my $sub = eval join("\n", @lines);
2685  ***      0      0                           0      die if $EVAL_ERROR;
2686  ***      0                                  0      return $sub;
2687                                                  }
2688                                                  
2689                                                  sub bucket_idx {
2690  ***      0                    0             0      my ( $val ) = @_;
2691  ***      0      0                           0      return 0 if $val < MIN_BUCK;
2692  ***      0                                  0      my $idx = int(BASE_OFFSET + log($val)/BASE_LOG);
2693  ***      0      0                           0      return $idx > (NUM_BUCK-1) ? (NUM_BUCK-1) : $idx;
2694                                                  }
2695                                                  
2696                                                  sub bucket_value {
2697        5000                 5000         15760      my ( $bucket ) = @_;
2698        5000    100                       21121      return 0 if $bucket == 0;
2699  ***   4995     50     33                38434      die "Invalid bucket: $bucket" if $bucket < 0 || $bucket > (NUM_BUCK-1);
2700        4995                              39801      return (BUCK_SIZE**($bucket-1)) * MIN_BUCK;
2701                                                  }
2702                                                  
2703                                                  {
2704                                                     my @buck_tens;
2705                                                     sub buckets_of {
2706  ***      0      0             0                       return @buck_tens if @buck_tens;
2707                                                  
2708  ***      0                                            my $start_bucket  = 0;
2709  ***      0                                            my @base10_starts = (0);
2710  ***      0                                            map { push @base10_starts, (10**$_)*MIN_BUCK } (1..7);
      ***      0                                      
2711                                                  
2712  ***      0                                            for my $base10_bucket ( 0..($#base10_starts-1) ) {
2713  ***      0                                               my $next_bucket = bucket_idx( $base10_starts[$base10_bucket+1] );
2714  ***      0                                               MKDEBUG && _d('Base 10 bucket', $base10_bucket, 'maps to',
2715                                                              'base 1.05 buckets', $start_bucket, '..', $next_bucket-1);
2716  ***      0                                               for my $base1_05_bucket ($start_bucket..($next_bucket-1)) {
2717  ***      0                                                  $buck_tens[$base1_05_bucket] = $base10_bucket;
2718                                                           }
2719  ***      0                                               $start_bucket = $next_bucket;
2720                                                        }
2721                                                  
2722  ***      0                                            map { $buck_tens[$_] = 7 } ($start_bucket..(NUM_BUCK-1));
      ***      0                                      
2723                                                  
2724  ***      0                                            return @buck_tens;
2725                                                     }
2726                                                  }
2727                                                  
2728                                                  sub calculate_statistical_metrics {
2729  ***      0                    0                    my ( $self, $vals, $args ) = @_;
2730  ***      0                                         my $statistical_metrics = {
2731                                                        pct_95    => 0,
2732                                                        stddev    => 0,
2733                                                        median    => 0,
2734                                                        cutoff    => undef,
2735                                                     };
2736                                                  
2737  ***      0      0      0                           return $statistical_metrics
      ***                    0                        
2738                                                        unless defined $vals && @$vals && $args->{cnt};
2739                                                  
2740  ***      0                                         my $n_vals = $args->{cnt};
2741  ***      0      0      0                           if ( $n_vals == 1 || $args->{max} == $args->{min} ) {
      ***             0                               
2742  ***      0             0                              my $v      = $args->{max} || 0;
2743  ***      0      0                                     my $bucket = int(6 + ( log($v > 0 ? $v : MIN_BUCK) / log(10)));
2744  ***      0      0                                     $bucket    = $bucket > 7 ? 7 : $bucket < 0 ? 0 : $bucket;
      ***             0                               
2745                                                        return {
2746  ***      0                                               pct_95 => $v,
2747                                                           stddev => 0,
2748                                                           median => $v,
2749                                                           cutoff => $n_vals,
2750                                                        };
2751                                                     }
2752                                                     elsif ( $n_vals == 2 ) {
2753  ***      0                                            foreach my $v ( $args->{min}, $args->{max} ) {
2754  ***      0      0      0                                 my $bucket = int(6 + ( log($v && $v > 0 ? $v : MIN_BUCK) / log(10)));
2755  ***      0      0                                        $bucket = $bucket > 7 ? 7 : $bucket < 0 ? 0 : $bucket;
      ***             0                               
2756                                                        }
2757  ***      0             0                              my $v      = $args->{max} || 0;
2758  ***      0             0                              my $mean = (($args->{min} || 0) + $v) / 2;
2759                                                        return {
2760  ***      0                                               pct_95 => $v,
2761                                                           stddev => sqrt((($v - $mean) ** 2) *2),
2762                                                           median => $mean,
2763                                                           cutoff => $n_vals,
2764                                                        };
2765                                                     }
2766                                                  
2767  ***      0      0                                  my $cutoff = $n_vals >= 10 ? int ( $n_vals * 0.95 ) : $n_vals;
2768  ***      0                                         $statistical_metrics->{cutoff} = $cutoff;
2769                                                  
2770  ***      0                                         my $total_left = $n_vals;
2771  ***      0                                         my $top_vals   = $n_vals - $cutoff; # vals > 95th
2772  ***      0                                         my $sum_excl   = 0;
2773  ***      0                                         my $sum        = 0;
2774  ***      0                                         my $sumsq      = 0;
2775  ***      0                                         my $mid        = int($n_vals / 2);
2776  ***      0                                         my $median     = 0;
2777  ***      0                                         my $prev       = NUM_BUCK-1; # Used for getting median when $cutoff is odd
2778  ***      0                                         my $bucket_95  = 0; # top bucket in 95th
2779                                                  
2780  ***      0                                         MKDEBUG && _d('total vals:', $total_left, 'top vals:', $top_vals, 'mid:', $mid);
2781                                                  
2782                                                     BUCKET:
2783  ***      0                                         for my $bucket ( reverse 0..(NUM_BUCK-1) ) {
2784  ***      0                                            my $val = $vals->[$bucket];
2785  ***      0      0                                     next BUCKET unless $val; 
2786                                                  
2787  ***      0                                            $total_left -= $val;
2788  ***      0                                            $sum_excl   += $val;
2789  ***      0      0      0                              $bucket_95   = $bucket if !$bucket_95 && $sum_excl > $top_vals;
2790                                                  
2791  ***      0      0      0                              if ( !$median && $total_left <= $mid ) {
2792  ***      0      0      0                                 $median = (($cutoff % 2) || ($val > 1)) ? $buck_vals[$bucket]
2793                                                                   : ($buck_vals[$bucket] + $buck_vals[$prev]) / 2;
2794                                                        }
2795                                                  
2796  ***      0                                            $sum    += $val * $buck_vals[$bucket];
2797  ***      0                                            $sumsq  += $val * ($buck_vals[$bucket]**2);
2798  ***      0                                            $prev   =  $bucket;
2799                                                     }
2800                                                  
2801  ***      0                                         my $var      = $sumsq/$n_vals - ( ($sum/$n_vals) ** 2 );
2802  ***      0      0                                  my $stddev   = $var > 0 ? sqrt($var) : 0;
2803  ***      0             0                           my $maxstdev = (($args->{max} || 0) - ($args->{min} || 0)) / 2;
      ***                    0                        
2804  ***      0      0                                  $stddev      = $stddev > $maxstdev ? $maxstdev : $stddev;
2805                                                  
2806  ***      0                                         MKDEBUG && _d('sum:', $sum, 'sumsq:', $sumsq, 'stddev:', $stddev,
2807                                                        'median:', $median, 'prev bucket:', $prev,
2808                                                        'total left:', $total_left, 'sum excl', $sum_excl,
2809                                                        'bucket 95:', $bucket_95, $buck_vals[$bucket_95]);
2810                                                  
2811  ***      0                                         $statistical_metrics->{stddev} = $stddev;
2812  ***      0                                         $statistical_metrics->{pct_95} = $buck_vals[$bucket_95];
2813  ***      0                                         $statistical_metrics->{median} = $median;
2814                                                  
2815  ***      0                                         return $statistical_metrics;
2816                                                  }
2817                                                  
2818                                                  sub metrics {
2819  ***      0                    0                    my ( $self, %args ) = @_;
2820  ***      0                                         foreach my $arg ( qw(attrib where) ) {
2821  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
2822                                                     }
2823  ***      0                                         my $stats = $self->results;
2824  ***      0                                         my $store = $stats->{classes}->{$args{where}}->{$args{attrib}};
2825                                                  
2826  ***      0                                         my $global_cnt = $stats->{globals}->{$args{attrib}}->{cnt};
2827  ***      0                                         my $metrics    = $self->calculate_statistical_metrics($store->{all}, $store);
2828                                                  
2829                                                     return {
2830  ***      0      0      0                              cnt    => $store->{cnt},
      ***             0      0                        
2831                                                        pct    => $global_cnt && $store->{cnt} ? $store->{cnt} / $global_cnt : 0,
2832                                                        sum    => $store->{sum},
2833                                                        min    => $store->{min},
2834                                                        max    => $store->{max},
2835                                                        avg    => $store->{sum} && $store->{cnt} ? $store->{sum} / $store->{cnt} : 0,
2836                                                        median => $metrics->{median},
2837                                                        pct_95 => $metrics->{pct_95},
2838                                                        stddev => $metrics->{stddev},
2839                                                     };
2840                                                  }
2841                                                  
2842                                                  sub top_events {
2843  ***      0                    0                    my ( $self, %args ) = @_;
2844  ***      0                                         my $classes = $self->{result_classes};
2845  ***      0                                         my @sorted = reverse sort { # Sorted list of $groupby values
2846  ***      0                                            $classes->{$a}->{$args{attrib}}->{$args{orderby}}
2847                                                           <=> $classes->{$b}->{$args{attrib}}->{$args{orderby}}
2848                                                        } grep {
2849  ***      0                                               defined $classes->{$_}->{$args{attrib}}->{$args{orderby}}
2850                                                        } keys %$classes;
2851  ***      0                                         my @chosen;
2852  ***      0                                         my ($total, $count) = (0, 0);
2853  ***      0                                         foreach my $groupby ( @sorted ) {
2854  ***      0      0      0                              if ( 
      ***             0      0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
2855                                                           (!$args{total} || $total < $args{total} )
2856                                                           && ( !$args{count} || $count < $args{count} )
2857                                                        ) {
2858  ***      0                                               push @chosen, [$groupby, 'top'];
2859                                                        }
2860                                                  
2861                                                        elsif ( $args{ol_attrib} && (!$args{ol_freq}
2862                                                           || $classes->{$groupby}->{$args{ol_attrib}}->{cnt} >= $args{ol_freq})
2863                                                        ) {
2864  ***      0                                               MKDEBUG && _d('Calculating statistical_metrics');
2865  ***      0                                               my $stats = $self->calculate_statistical_metrics(
2866                                                              $classes->{$groupby}->{$args{ol_attrib}}->{all},
2867                                                              $classes->{$groupby}->{$args{ol_attrib}}
2868                                                           );
2869  ***      0      0                                        if ( $stats->{pct_95} >= $args{ol_limit} ) {
2870  ***      0                                                  push @chosen, [$groupby, 'outlier'];
2871                                                           }
2872                                                        }
2873                                                  
2874  ***      0                                            $total += $classes->{$groupby}->{$args{attrib}}->{$args{orderby}};
2875  ***      0                                            $count++;
2876                                                     }
2877  ***      0                                         return @chosen;
2878                                                  }
2879                                                  
2880                                                  sub add_new_attributes {
2881  ***      0                    0                    my ( $self, $event ) = @_;
2882  ***      0      0                                  return unless $event;
2883                                                  
2884  ***      0                                         map {
2885  ***      0      0      0                              my $attrib = $_;
2886  ***      0                                            $self->{attributes}->{$attrib}  = [$attrib];
2887  ***      0                                            $self->{alt_attribs}->{$attrib} = make_alt_attrib($attrib);
2888  ***      0                                            push @{$self->{all_attribs}}, $attrib;
      ***      0                                      
2889  ***      0                                            MKDEBUG && _d('Added new attribute:', $attrib);
2890                                                     }
2891                                                     grep {
2892  ***      0                                            $_ ne $self->{groupby}
2893                                                        && !exists $self->{attributes}->{$_}
2894                                                        && !exists $self->{ignore_attribs}->{$_}
2895                                                     }
2896                                                     keys %$event;
2897                                                  
2898  ***      0                                         return;
2899                                                  }
2900                                                  
2901                                                  sub get_attributes {
2902  ***      0                    0                    my ( $self ) = @_;
2903  ***      0                                         return @{$self->{all_attribs}};
      ***      0                                      
2904                                                  }
2905                                                  
2906                                                  sub events_processed {
2907  ***      0                    0                    my ( $self ) = @_;
2908  ***      0                                         return $self->{n_events};
2909                                                  }
2910                                                  
2911                                                  sub make_alt_attrib {
2912  ***      0                    0                    my ( @attribs ) = @_;
2913                                                  
2914  ***      0                                         my $attrib = shift @attribs;  # Primary attribute.
2915  ***      0      0             0                    return sub {} unless @attribs;  # No alternates.
      ***      0                                      
2916                                                  
2917  ***      0                                         my @lines;
2918  ***      0                                         push @lines, 'sub { my ( $event ) = @_; my $alt_attrib;';
2919  ***      0                                         push @lines, map  {
2920  ***      0                                               "\$alt_attrib = '$_' if !defined \$alt_attrib "
2921                                                           . "&& exists \$event->{'$_'};"
2922                                                        } @attribs;
2923  ***      0                                         push @lines, 'return $alt_attrib; }';
2924  ***      0                                         MKDEBUG && _d('alt attrib sub for', $attrib, ':', @lines);
2925  ***      0                                         my $sub = eval join("\n", @lines);
2926  ***      0      0                                  die if $EVAL_ERROR;
2927  ***      0                                         return $sub;
2928                                                  }
2929                                                  
2930                                                  sub _d {
2931  ***      0                    0                    my ($package, undef, $line) = caller 0;
2932  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2933  ***      0                                              map { defined $_ ? $_ : 'undef' }
2934                                                          @_;
2935  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2936                                                  }
2937                                                  
2938                                                  1;
2939                                                  
2940                                                  # ###########################################################################
2941                                                  # End EventAggregator package
2942                                                  # ###########################################################################
2943                                                  
2944                                                  # ###########################################################################
2945                                                  # QueryParser package 5266
2946                                                  # ###########################################################################
2947                                                  package QueryParser;
2948                                                  
2949           5                    5            68   use strict;
               5                                 14   
               5                                 51   
2950           5                    5            32   use warnings FATAL => 'all';
               5                                 13   
               5                                 37   
2951           5                    5            31   use English qw(-no_match_vars);
               5                                 18   
               5                                 36   
2952                                                  
2953  ***      5            50      5            46   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 13   
               5                                 93   
2954                                                  our $tbl_ident = qr/(?:`[^`]+`|\w+)(?:\.(?:`[^`]+`|\w+))?/;
2955                                                  our $tbl_regex = qr{
2956                                                           \b(?:FROM|JOIN|(?<!KEY\s)UPDATE|INTO) # Words that precede table names
2957                                                           \b\s*
2958                                                           ($tbl_ident
2959                                                              (?: (?:\s+ (?:AS\s+)? \w+)?, \s*$tbl_ident )*
2960                                                           )
2961                                                        }xio;
2962                                                  our $has_derived = qr{
2963                                                        \b(?:FROM|JOIN|,)
2964                                                        \s*\(\s*SELECT
2965                                                     }xi;
2966                                                  
2967                                                  our $data_def_stmts = qr/(?:CREATE|ALTER|TRUNCATE|DROP|RENAME)/i;
2968                                                  
2969                                                  our $data_manip_stmts = qr/(?:INSERT|UPDATE|DELETE|REPLACE)/i;
2970                                                  
2971                                                  sub new {
2972  ***      0                    0                    my ( $class ) = @_;
2973  ***      0                                         bless {}, $class;
2974                                                  }
2975                                                  
2976                                                  sub get_tables {
2977  ***      0                    0                    my ( $self, $query ) = @_;
2978  ***      0      0                                  return unless $query;
2979  ***      0                                         MKDEBUG && _d('Getting tables for', $query);
2980                                                  
2981  ***      0                                         my ( $ddl_stmt ) = $query =~ /^\s*($data_def_stmts)\b/i;
2982  ***      0      0                                  if ( $ddl_stmt ) {
2983  ***      0                                            MKDEBUG && _d('Special table type:', $ddl_stmt);
2984  ***      0                                            $query =~ s/IF NOT EXISTS//i;
2985  ***      0      0                                     if ( $query =~ m/$ddl_stmt DATABASE\b/i ) {
2986  ***      0                                               MKDEBUG && _d('Query alters a database, not a table');
2987  ***      0                                               return ();
2988                                                        }
2989  ***      0      0      0                              if ( $ddl_stmt =~ m/CREATE/i && $query =~ m/$ddl_stmt\b.+?\bSELECT\b/i ) {
2990  ***      0                                               my ($select) = $query =~ m/\b(SELECT\b.+)/is;
2991  ***      0                                               MKDEBUG && _d('CREATE TABLE ... SELECT:', $select);
2992  ***      0                                               return $self->get_tables($select);
2993                                                        }
2994  ***      0                                            my ($tbl) = $query =~ m/TABLE\s+($tbl_ident)(\s+.*)?/i;
2995  ***      0                                            MKDEBUG && _d('Matches table:', $tbl);
2996  ***      0                                            return ($tbl);
2997                                                     }
2998                                                  
2999  ***      0                                         $query =~ s/ (?:LOW_PRIORITY|IGNORE|STRAIGHT_JOIN)//ig;
3000                                                  
3001  ***      0      0                                  if ( $query =~ /^\s*LOCK TABLES/i ) {
3002  ***      0                                            MKDEBUG && _d('Special table type: LOCK TABLES');
3003  ***      0                                            $query =~ s/^(\s*LOCK TABLES\s+)//;
3004  ***      0                                            $query =~ s/\s+(?:READ|WRITE|LOCAL)+\s*//g;
3005  ***      0                                            MKDEBUG && _d('Locked tables:', $query);
3006  ***      0                                            $query = "FROM $query";
3007                                                     }
3008                                                  
3009  ***      0                                         $query =~ s/\\["']//g;                # quoted strings
3010  ***      0                                         $query =~ s/".*?"/?/sg;               # quoted strings
3011  ***      0                                         $query =~ s/'.*?'/?/sg;               # quoted strings
3012                                                  
3013  ***      0                                         my @tables;
3014  ***      0                                         foreach my $tbls ( $query =~ m/$tbl_regex/gio ) {
3015  ***      0                                            MKDEBUG && _d('Match tables:', $tbls);
3016  ***      0                                            foreach my $tbl ( split(',', $tbls) ) {
3017  ***      0                                               $tbl =~ s/\s*($tbl_ident)(\s+.*)?/$1/gio;
3018                                                  
3019  ***      0      0                                        if ( $tbl !~ m/[a-zA-Z]/ ) {
3020  ***      0                                                  MKDEBUG && _d('Skipping suspicious table name:', $tbl);
3021  ***      0                                                  next;
3022                                                           }
3023                                                  
3024  ***      0                                               push @tables, $tbl;
3025                                                        }
3026                                                     }
3027  ***      0                                         return @tables;
3028                                                  }
3029                                                  
3030                                                  sub has_derived_table {
3031  ***      0                    0                    my ( $self, $query ) = @_;
3032  ***      0                                         my $match = $query =~ m/$has_derived/;
3033  ***      0                                         MKDEBUG && _d($query, 'has ' . ($match ? 'a' : 'no') . ' derived table');
3034  ***      0                                         return $match;
3035                                                  }
3036                                                  
3037                                                  sub get_aliases {
3038  ***      0                    0                    my ( $self, $query ) = @_;
3039  ***      0      0                                  return unless $query;
3040  ***      0                                         my $aliases;
3041                                                  
3042  ***      0                                         $query =~ s/ (?:LOW_PRIORITY|IGNORE|STRAIGHT_JOIN)//ig;
3043                                                  
3044  ***      0                                         $query =~ s/ (?:INNER|OUTER|CROSS|LEFT|RIGHT|NATURAL)//ig;
3045                                                  
3046  ***      0                                         my ($tbl_refs, $from) = $query =~ m{
3047                                                        (
3048                                                           (FROM|INTO|UPDATE)\b\s*   # Keyword before table refs
3049                                                           .+?                       # Table refs
3050                                                        )
3051                                                        (?:\s+|\z)                   # If the query does not end with the table
3052                                                        (?:WHERE|ORDER|LIMIT|HAVING|SET|VALUES|\z) # Keyword after table refs
3053                                                     }ix;
3054                                                  
3055  ***      0      0      0                           die "Failed to parse table references from $query"
3056                                                        unless $tbl_refs && $from;
3057                                                  
3058  ***      0                                         MKDEBUG && _d('tbl refs:', $tbl_refs);
3059                                                  
3060  ***      0                                         my $before_tbl = qr/(?:,|JOIN|\s|$from)+/i;
3061                                                  
3062  ***      0                                         my $after_tbl  = qr/(?:,|JOIN|ON|USING|\z)/i;
3063                                                  
3064  ***      0                                         $tbl_refs =~ s/ = /=/g;
3065                                                  
3066  ***      0                                         while (
3067                                                        $tbl_refs =~ m{
3068                                                           $before_tbl\b\s*
3069                                                              ( ($tbl_ident) (?:\s+ (?:AS\s+)? (\w+))? )
3070                                                           \s*$after_tbl
3071                                                        }xgio )
3072                                                     {
3073  ***      0                                            my ( $tbl_ref, $db_tbl, $alias ) = ($1, $2, $3);
3074  ***      0                                            MKDEBUG && _d('Match table:', $tbl_ref);
3075                                                  
3076  ***      0      0                                     if ( $tbl_ref =~ m/^AS\s+\w+/i ) {
3077  ***      0                                               MKDEBUG && _d('Subquery', $tbl_ref);
3078  ***      0                                               $aliases->{$alias} = undef;
3079  ***      0                                               next;
3080                                                        }
3081                                                  
3082  ***      0                                            my ( $db, $tbl ) = $db_tbl =~ m/^(?:(.*?)\.)?(.*)/;
3083  ***      0             0                              $aliases->{$alias || $tbl} = $tbl;
3084  ***      0      0                                     $aliases->{DATABASE}->{$tbl} = $db if $db;
3085                                                     }
3086  ***      0                                         return $aliases;
3087                                                  }
3088                                                  
3089                                                  sub split {
3090  ***      0                    0                    my ( $self, $query ) = @_;
3091  ***      0      0                                  return unless $query;
3092  ***      0                                         $query = $self->clean_query($query);
3093  ***      0                                         MKDEBUG && _d('Splitting', $query);
3094                                                  
3095  ***      0                                         my $verbs = qr{SELECT|INSERT|UPDATE|DELETE|REPLACE|UNION|CREATE}i;
3096                                                  
3097  ***      0                                         my @split_statements = grep { $_ } split(m/\b($verbs\b(?!(?:\s*\()))/io, $query);
      ***      0                                      
3098                                                  
3099  ***      0                                         my @statements;
3100  ***      0      0                                  if ( @split_statements == 1 ) {
3101  ***      0                                            push @statements, $query;
3102                                                     }
3103                                                     else {
3104                                                        for ( my $i = 0; $i <= $#split_statements; $i += 2 ) {
3105  ***      0                                               push @statements, $split_statements[$i].$split_statements[$i+1];
3106                                                  
3107  ***      0      0      0                                 if ( $statements[-2] && $statements[-2] =~ m/on duplicate key\s+$/i ) {
3108  ***      0                                                  $statements[-2] .= pop @statements;
3109                                                           }
3110  ***      0                                            }
3111                                                     }
3112                                                  
3113  ***      0                                         MKDEBUG && _d('statements:', map { $_ ? "<$_>" : 'none' } @statements);
3114  ***      0                                         return @statements;
3115                                                  }
3116                                                  
3117                                                  sub clean_query {
3118  ***      0                    0                    my ( $self, $query ) = @_;
3119  ***      0      0                                  return unless $query;
3120  ***      0                                         $query =~ s!/\*.*?\*/! !g;  # Remove /* comment blocks */
3121  ***      0                                         $query =~ s/^\s+//;         # Remove leading spaces
3122  ***      0                                         $query =~ s/\s+$//;         # Remove trailing spaces
3123  ***      0                                         $query =~ s/\s{2,}/ /g;     # Remove extra spaces
3124  ***      0                                         return $query;
3125                                                  }
3126                                                  
3127                                                  sub split_subquery {
3128  ***      0                    0                    my ( $self, $query ) = @_;
3129  ***      0      0                                  return unless $query;
3130  ***      0                                         $query = $self->clean_query($query);
3131  ***      0                                         $query =~ s/;$//;
3132                                                  
3133  ***      0                                         my @subqueries;
3134  ***      0                                         my $sqno = 0;  # subquery number
3135  ***      0                                         my $pos  = 0;
3136  ***      0                                         while ( $query =~ m/(\S+)(?:\s+|\Z)/g ) {
3137  ***      0                                            $pos = pos($query);
3138  ***      0                                            my $word = $1;
3139  ***      0                                            MKDEBUG && _d($word, $sqno);
3140  ***      0      0                                     if ( $word =~ m/^\(?SELECT\b/i ) {
3141  ***      0                                               my $start_pos = $pos - length($word) - 1;
3142  ***      0      0                                        if ( $start_pos ) {
3143  ***      0                                                  $sqno++;
3144  ***      0                                                  MKDEBUG && _d('Subquery', $sqno, 'starts at', $start_pos);
3145  ***      0                                                  $subqueries[$sqno] = {
3146                                                                 start_pos => $start_pos,
3147                                                                 end_pos   => 0,
3148                                                                 len       => 0,
3149                                                                 words     => [$word],
3150                                                                 lp        => 1, # left parentheses
3151                                                                 rp        => 0, # right parentheses
3152                                                                 done      => 0,
3153                                                              };
3154                                                           }
3155                                                           else {
3156  ***      0                                                  MKDEBUG && _d('Main SELECT at pos 0');
3157                                                           }
3158                                                        }
3159                                                        else {
3160  ***      0      0                                        next unless $sqno;  # next unless we're in a subquery
3161  ***      0                                               MKDEBUG && _d('In subquery', $sqno);
3162  ***      0                                               my $sq = $subqueries[$sqno];
3163  ***      0      0                                        if ( $sq->{done} ) {
3164  ***      0                                                  MKDEBUG && _d('This subquery is done; SQL is for',
3165                                                                 ($sqno - 1 ? "subquery $sqno" : "the main SELECT"));
3166  ***      0                                                  next;
3167                                                           }
3168  ***      0                                               push @{$sq->{words}}, $word;
      ***      0                                      
3169  ***      0             0                                 my $lp = ($word =~ tr/\(//) || 0;
3170  ***      0             0                                 my $rp = ($word =~ tr/\)//) || 0;
3171  ***      0                                               MKDEBUG && _d('parentheses left', $lp, 'right', $rp);
3172  ***      0      0                                        if ( ($sq->{lp} + $lp) - ($sq->{rp} + $rp) == 0 ) {
3173  ***      0                                                  my $end_pos = $pos - 1;
3174  ***      0                                                  MKDEBUG && _d('Subquery', $sqno, 'ends at', $end_pos);
3175  ***      0                                                  $sq->{end_pos} = $end_pos;
3176  ***      0                                                  $sq->{len}     = $end_pos - $sq->{start_pos};
3177                                                           }
3178                                                        }
3179                                                     }
3180                                                  
3181  ***      0                                         for my $i ( 1..$#subqueries ) {
3182  ***      0                                            my $sq = $subqueries[$i];
3183  ***      0      0                                     next unless $sq;
3184  ***      0                                            $sq->{sql} = join(' ', @{$sq->{words}});
      ***      0                                      
3185  ***      0                                            substr $query,
3186                                                           $sq->{start_pos} + 1,  # +1 for (
3187                                                           $sq->{len} - 1,        # -1 for )
3188                                                           "__subquery_$i";
3189                                                     }
3190                                                  
3191  ***      0                                         return $query, map { $_->{sql} } grep { defined $_ } @subqueries;
      ***      0                                      
      ***      0                                      
3192                                                  }
3193                                                  
3194                                                  sub query_type {
3195  ***      0                    0                    my ( $self, $query, $qr ) = @_;
3196  ***      0                                         my ($type, undef) = $qr->_distill_verbs($query);
3197  ***      0                                         my $rw;
3198  ***      0      0      0                           if ( $type =~ m/^SELECT\b/ ) {
      ***             0                               
3199  ***      0                                            $rw = 'read';
3200                                                     }
3201                                                     elsif ( $type =~ m/^$data_manip_stmts\b/
3202                                                             || $type =~ m/^$data_def_stmts\b/  ) {
3203  ***      0                                            $rw = 'write'
3204                                                     }
3205                                                  
3206                                                     return {
3207  ***      0                                            type => $type,
3208                                                        rw   => $rw,
3209                                                     }
3210                                                  }
3211                                                  
3212                                                  sub _d {
3213  ***      0                    0                    my ($package, undef, $line) = caller 0;
3214  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
3215  ***      0                                              map { defined $_ ? $_ : 'undef' }
3216                                                          @_;
3217  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3218                                                  }
3219                                                  
3220                                                  1;
3221                                                  
3222                                                  # ###########################################################################
3223                                                  # End QueryParser package
3224                                                  # ###########################################################################
3225                                                  
3226                                                  # ###########################################################################
3227                                                  # QueryRewriter package 5356
3228                                                  # ###########################################################################
3229           5                    5            61   use strict;
               5                                 13   
               5                                 39   
3230           5                    5            33   use warnings FATAL => 'all';
               5                                 14   
               5                                 38   
3231                                                  
3232                                                  package QueryRewriter;
3233                                                  
3234           5                    5            57   use English qw(-no_match_vars);
               5                                 15   
               5                                 39   
3235                                                  
3236  ***      5            50      5            53   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 14   
               5                                 97   
3237                                                  
3238                                                  our $verbs   = qr{^SHOW|^FLUSH|^COMMIT|^ROLLBACK|^BEGIN|SELECT|INSERT
3239                                                                    |UPDATE|DELETE|REPLACE|^SET|UNION|^START|^LOCK}xi;
3240                                                  my $quote_re = qr/"(?:(?!(?<!\\)").)*"|'(?:(?!(?<!\\)').)*'/; # Costly!
3241                                                  my $bal;
3242                                                  $bal         = qr/
3243                                                                    \(
3244                                                                    (?:
3245                                                                       (?> [^()]+ )    # Non-parens without backtracking
3246                                                                       |
3247                                                                       (??{ $bal })    # Group with matching parens
3248                                                                    )*
3249                                                                    \)
3250                                                                   /x;
3251                                                  
3252                                                  my $olc_re = qr/(?:--|#)[^'"\r\n]*(?=[\r\n]|\Z)/;  # One-line comments
3253                                                  my $mlc_re = qr#/\*[^!].*?\*/#sm;                  # But not /*!version */
3254                                                  my $vlc_re = qr#/\*.*?[0-9+].*?\*/#sm;                  # But for replacing SHOW + /*!version */
3255                                                  my $vlc_rf = qr#^(SHOW).*?/\*![0-9+].*?\*/#sm;    		# ^^ if its starts with SHOW followed by version
3256                                                  
3257                                                  sub new {
3258  ***      0                    0                    my ( $class, %args ) = @_;
3259  ***      0                                         my $self = { %args };
3260  ***      0                                         return bless $self, $class;
3261                                                  }
3262                                                  
3263                                                  sub strip_comments {
3264  ***      0                    0                    my ( $self, $query ) = @_;
3265  ***      0      0                                  return unless $query;
3266  ***      0                                         $query =~ s/$olc_re//go;
3267  ***      0                                         $query =~ s/$mlc_re//go;
3268  ***      0      0                                  if ( $query =~ m/$vlc_rf/i ) { # contains show + version
3269  ***      0                                         			$query =~ s/$vlc_re//go;
3270                                                     }
3271  ***      0                                         return $query;
3272                                                  }
3273                                                  
3274                                                  sub shorten {
3275  ***      0                    0                    my ( $self, $query, $length ) = @_;
3276  ***      0                                         $query =~ s{
3277                                                        \A(
3278                                                           (?:INSERT|REPLACE)
3279                                                           (?:\s+LOW_PRIORITY|DELAYED|HIGH_PRIORITY|IGNORE)?
3280                                                           (?:\s\w+)*\s+\S+\s+VALUES\s*\(.*?\)
3281                                                        )
3282                                                        \s*,\s*\(.*?(ON\s+DUPLICATE|\Z)}
3283                                                        {$1 /*... omitted ...*/$2}xsi;
3284                                                  
3285  ***      0      0                                  return $query unless $query =~ m/IN\s*\(\s*(?!select)/i;
3286                                                  
3287  ***      0                                         my $last_length  = 0;
3288  ***      0                                         my $query_length = length($query);
3289  ***      0             0                           while (
      ***                    0                        
      ***                    0                        
3290                                                        $length          > 0
3291                                                        && $query_length > $length
3292                                                        && $query_length < ( $last_length || $query_length + 1 )
3293                                                     ) {
3294  ***      0                                            $last_length = $query_length;
3295  ***      0                                            $query =~ s{
3296  ***      0                                               (\bIN\s*\()    # The opening of an IN list
3297                                                           ([^\)]+)       # Contents of the list, assuming no item contains paren
3298                                                           (?=\))           # Close of the list
3299                                                        }
3300                                                        {
3301                                                           $1 . __shorten($2)
3302                                                        }gexsi;
3303                                                     }
3304                                                  
3305  ***      0                                         return $query;
3306                                                  }
3307                                                  
3308                                                  sub __shorten {
3309  ***      0                    0                    my ( $snippet ) = @_;
3310  ***      0                                         my @vals = split(/,/, $snippet);
3311  ***      0      0                                  return $snippet unless @vals > 20;
3312  ***      0                                         my @keep = splice(@vals, 0, 20);  # Remove and save the first 20 items
3313                                                     return
3314  ***      0                                            join(',', @keep)
3315                                                        . "/*... omitted "
3316                                                        . scalar(@vals)
3317                                                        . " items ...*/";
3318                                                  }
3319                                                  
3320                                                  sub fingerprint {
3321  ***      0                    0                    my ( $self, $query ) = @_;
3322                                                  
3323  ***      0      0                                  $query =~ m#\ASELECT /\*!40001 SQL_NO_CACHE \*/ \* FROM `# # mysqldump query
3324                                                        && return 'mysqldump';
3325  ***      0      0                                  $query =~ m#/\*\w+\.\w+:[0-9]/[0-9]\*/#     # mk-table-checksum, etc query
3326                                                        && return 'maatkit';
3327  ***      0      0                                  $query =~ m/\A# administrator command: /
3328                                                        && return $query;
3329  ***      0      0                                  $query =~ m/\A\s*(call\s+\S+)\(/i
3330                                                        && return lc($1); # Warning! $1 used, be careful.
3331  ***      0      0                                  if ( my ($beginning) = $query =~ m/\A((?:INSERT|REPLACE)(?: IGNORE)?\s+INTO.+?VALUES\s*\(.*?\))\s*,\s*\(/is ) {
3332  ***      0                                            $query = $beginning; # Shorten multi-value INSERT statements ASAP
3333                                                     }
3334                                                  
3335  ***      0                                         $query =~ s/$olc_re//go;
3336  ***      0                                         $query =~ s/$mlc_re//go;
3337  ***      0      0                                  $query =~ s/\Ause \S+\Z/use ?/i       # Abstract the DB in USE
3338                                                        && return $query;
3339                                                  
3340  ***      0                                         $query =~ s/\\["']//g;                # quoted strings
3341  ***      0                                         $query =~ s/".*?"/?/sg;               # quoted strings
3342  ***      0                                         $query =~ s/'.*?'/?/sg;               # quoted strings
3343  ***      0                                         $query =~ s/[0-9+-][0-9a-f.xb+-]*/?/g;# Anything vaguely resembling numbers
3344  ***      0                                         $query =~ s/[xb.+-]\?/?/g;            # Clean up leftovers
3345  ***      0                                         $query =~ s/\A\s+//;                  # Chop off leading whitespace
3346  ***      0                                         chomp $query;                         # Kill trailing whitespace
3347  ***      0                                         $query =~ tr[ \n\t\r\f][ ]s;          # Collapse whitespace
3348  ***      0                                         $query = lc $query;
3349  ***      0                                         $query =~ s/\bnull\b/?/g;             # Get rid of NULLs
3350  ***      0                                         $query =~ s{                          # Collapse IN and VALUES lists
3351                                                                 \b(in|values?)(?:[\s,]*\([\s?,]*\))+
3352                                                                }
3353                                                                {$1(?+)}gx;
3354  ***      0                                         $query =~ s{                          # Collapse UNION
3355                                                                 \b(select\s.*?)(?:(\sunion(?:\sall)?)\s\1)+
3356                                                                }
3357                                                                {$1 /*repeat$2*/}xg;
3358  ***      0                                         $query =~ s/\blimit \?(?:, ?\?| offset \?)?/limit ?/; # LIMIT
3359  ***      0                                         return $query;
3360                                                  }
3361                                                  
3362                                                  sub _distill_verbs {
3363  ***      0                    0                    my ( $self, $query ) = @_;
3364                                                  
3365  ***      0      0                                  $query =~ m/\A\s*call\s+(\S+)\(/i
3366                                                        && return "CALL $1"; # Warning! $1 used, be careful.
3367  ***      0      0                                  if ( $query =~ m/\A# administrator command:/ ) {
3368  ***      0                                      		$query =~ s/# administrator command:/ADMIN/go;
3369  ***      0                                      		$query = uc $query;
3370  ***      0                                             	return "$query";
3371                                                     }
3372  ***      0      0                                  $query =~ m/\A\s*use\s+/
3373                                                        && return "USE";
3374  ***      0      0                                  $query =~ m/\A\s*UNLOCK TABLES/i
3375                                                        && return "UNLOCK";
3376  ***      0      0                                  $query =~ m/\A\s*xa\s+(\S+)/i
3377                                                        && return "XA_$1";
3378                                                  
3379  ***      0                                         $query = $self->strip_comments($query);
3380                                                  
3381  ***      0      0                                  if ( $query =~ m/\A\s*SHOW\s+/i ) {
3382  ***      0                                            my @what = $query =~ m/SHOW\s+(\S+)(?:\s+(\S+))?/i;
3383  ***      0                                            MKDEBUG && _d('SHOW', @what);
3384  ***      0      0                                     return unless scalar @what;
3385  ***      0                                            @what = map { uc $_ } grep { defined $_ } @what; 
      ***      0                                      
      ***      0                                      
3386                                                  
3387  ***      0      0      0                              if ( $what[0] =~ m/CREATE/
      ***                    0                        
      ***                    0                        
3388                                                             || ($what[1] && $what[1] =~ m/STATUS/)
3389                                                             || $what[0] =~ m/MASTER/ ) {
3390  ***      0                                               return "SHOW $what[0] $what[1]";
3391                                                        }
3392                                                        else {
3393  ***      0      0                                        $what[0] =~ m/GLOBAL/ ? return "SHOW $what[1]"
3394                                                                    :              return "SHOW $what[0]";
3395                                                        }
3396                                                     }
3397                                                  
3398  ***      0                                         eval $QueryParser::data_def_stmts;
3399  ***      0                                         eval $QueryParser::tbl_ident;
3400  ***      0                                         my ( $dds ) = $query =~ /^\s*($QueryParser::data_def_stmts)\b/i;
3401  ***      0      0                                  if ( $dds ) {
3402  ***      0                                            my ( $obj ) = $query =~ m/$dds.+(DATABASE|TABLE)\b/i;
3403  ***      0      0                                     $obj = uc $obj if $obj;
3404  ***      0                                            MKDEBUG && _d('Data def statment:', $dds, 'obj:', $obj);
3405  ***      0                                            my ($db_or_tbl)
3406                                                           = $query =~ m/(?:TABLE|DATABASE)\s+($QueryParser::tbl_ident)(\s+.*)?/i;
3407  ***      0                                            MKDEBUG && _d('Matches db or table:', $db_or_tbl);
3408  ***      0      0                                     return uc($dds . ($obj ? " $obj" : '')), $db_or_tbl;
3409                                                     }
3410                                                  
3411  ***      0                                         my @verbs = $query =~ m/\b($verbs)\b/gio;
3412  ***      0                                         @verbs    = do {
3413  ***      0                                            my $last = '';
3414  ***      0                                            grep { my $pass = $_ ne $last; $last = $_; $pass } map { uc } @verbs;
      ***      0                                      
      ***      0                                      
      ***      0                                      
      ***      0                                      
3415                                                     };
3416  ***      0                                         my $verbs = join(q{ }, @verbs);
3417  ***      0                                         $verbs =~ s/( UNION SELECT)+/ UNION/g;
3418                                                  
3419  ***      0                                         return $verbs;
3420                                                  }
3421                                                  
3422                                                  sub _distill_tables {
3423  ***      0                    0                    my ( $self, $query, $table, %args ) = @_;
3424  ***      0             0                           my $qp = $args{QueryParser} || $self->{QueryParser};
3425  ***      0      0                                  die "I need a QueryParser argument" unless $qp;
3426                                                  
3427  ***      0                                         my @tables = map {
3428  ***      0                                            $_ =~ s/`//g;
3429  ***      0                                            $_ =~ s/(_?)[0-9]+/$1?/g;
3430  ***      0                                            $_;
3431  ***      0                                         } grep { defined $_ } $qp->get_tables($query);
3432                                                  
3433  ***      0      0                                  push @tables, $table if $table;
3434                                                  
3435  ***      0                                         @tables = do {
3436  ***      0                                            my $last = '';
3437  ***      0                                            grep { my $pass = $_ ne $last; $last = $_; $pass } @tables;
      ***      0                                      
      ***      0                                      
      ***      0                                      
3438                                                     };
3439                                                  
3440  ***      0                                         return @tables;
3441                                                  }
3442                                                  
3443                                                  sub distill {
3444  ***      0                    0                    my ( $self, $query, %args ) = @_;
3445                                                  
3446  ***      0      0                                  if ( $args{generic} ) {
3447  ***      0                                            my ($cmd, $arg) = $query =~ m/^(\S+)\s+(\S+)/;
3448  ***      0      0                                     return '' unless $cmd;
3449  ***      0      0                                     $query = (uc $cmd) . ($arg ? " $arg" : '');
3450                                                     }
3451                                                     else {
3452  ***      0                                            my ($verbs, $table)  = $self->_distill_verbs($query, %args);
3453  ***      0                                            my @tables           = $self->_distill_tables($query, $table, %args);
3454  ***      0                                            $query               = join(q{ }, $verbs, @tables);
3455                                                     }
3456                                                     
3457  ***      0      0                                  if ( $args{trf} ) {
3458  ***      0                                            $query = $args{trf}->($query, %args);
3459                                                     }
3460                                                  
3461  ***      0                                         return $query;
3462                                                  }
3463                                                  
3464                                                  sub convert_to_select {
3465  ***      0                    0                    my ( $self, $query ) = @_;
3466  ***      0      0                                  return unless $query;
3467  ***      0                                         $query =~ s{
      ***      0                                      
3468                                                                   \A.*?
3469                                                                   update\s+(.*?)
3470                                                                   \s+set\b(.*?)
3471                                                                   (?:\s*where\b(.*?))?
3472                                                                   (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
3473                                                                   \Z
3474                                                                }
3475                                                                {__update_to_select($1, $2, $3, $4)}exsi
3476  ***      0                                            || $query =~ s{
3477                                                                      \A.*?
3478                                                                      (?:insert|replace)\s+
3479                                                                      .*?\binto\b(.*?)\(([^\)]+)\)\s*
3480                                                                      values?\s*(\(.*?\))\s*
3481                                                                      (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
3482                                                                      \Z
3483                                                                   }
3484                                                                   {__insert_to_select($1, $2, $3)}exsi
3485  ***      0      0      0                              || $query =~ s{
3486                                                                      \A.*?
3487                                                                      delete\s+(.*?)
3488                                                                      \bfrom\b(.*)
3489                                                                      \Z
3490                                                                   }
3491                                                                   {__delete_to_select($1, $2)}exsi;
3492  ***      0                                         $query =~ s/\s*on\s+duplicate\s+key\s+update.*\Z//si;
3493  ***      0                                         $query =~ s/\A.*?(?=\bSELECT\s*\b)//ism;
3494  ***      0                                         return $query;
3495                                                  }
3496                                                  
3497                                                  sub convert_select_list {
3498  ***      0                    0                    my ( $self, $query ) = @_;
3499  ***      0      0                                  $query =~ s{
      ***      0                                      
3500                                                                 \A\s*select(.*?)\bfrom\b
3501                                                                }
3502                                                                {$1 =~ m/\*/ ? "select 1 from" : "select isnull(coalesce($1)) from"}exi;
3503  ***      0                                         return $query;
3504                                                  }
3505                                                  
3506                                                  sub __delete_to_select {
3507  ***      0                    0                    my ( $delete, $join ) = @_;
3508  ***      0      0                                  if ( $join =~ m/\bjoin\b/ ) {
3509  ***      0                                            return "select 1 from $join";
3510                                                     }
3511  ***      0                                         return "select * from $join";
3512                                                  }
3513                                                  
3514                                                  sub __insert_to_select {
3515  ***      0                    0                    my ( $tbl, $cols, $vals ) = @_;
3516  ***      0                                         MKDEBUG && _d('Args:', @_);
3517  ***      0                                         my @cols = split(/,/, $cols);
3518  ***      0                                         MKDEBUG && _d('Cols:', @cols);
3519  ***      0                                         $vals =~ s/^\(|\)$//g; # Strip leading/trailing parens
3520  ***      0                                         my @vals = $vals =~ m/($quote_re|[^,]*${bal}[^,]*|[^,]+)/g;
3521  ***      0                                         MKDEBUG && _d('Vals:', @vals);
3522  ***      0      0                                  if ( @cols == @vals ) {
3523  ***      0                                            return "select * from $tbl where "
3524  ***      0                                               . join(' and ', map { "$cols[$_]=$vals[$_]" } (0..$#cols));
3525                                                     }
3526                                                     else {
3527  ***      0                                            return "select * from $tbl limit 1";
3528                                                     }
3529                                                  }
3530                                                  
3531                                                  sub __update_to_select {
3532  ***      0                    0                    my ( $from, $set, $where, $limit ) = @_;
3533  ***      0      0                                  return "select $set from $from "
      ***             0                               
3534                                                        . ( $where ? "where $where" : '' )
3535                                                        . ( $limit ? " $limit "      : '' );
3536                                                  }
3537                                                  
3538                                                  sub wrap_in_derived {
3539  ***      0                    0                    my ( $self, $query ) = @_;
3540  ***      0      0                                  return unless $query;
3541  ***      0      0                                  return $query =~ m/\A\s*select/i
3542                                                        ? "select 1 from ($query) as x limit 1"
3543                                                        : $query;
3544                                                  }
3545                                                  
3546                                                  sub _d {
3547  ***      0                    0                    my ($package, undef, $line) = caller 0;
3548  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
3549  ***      0                                              map { defined $_ ? $_ : 'undef' }
3550                                                          @_;
3551  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3552                                                  }
3553                                                  
3554                                                  1;
3555                                                  
3556                                                  # ###########################################################################
3557                                                  # End QueryRewriter package
3558                                                  # ###########################################################################
3559                                                  
3560                                                  # ###########################################################################
3561                                                  # Daemon package 5266
3562                                                  # ###########################################################################
3563                                                  
3564                                                  package Daemon;
3565                                                  
3566           5                    5            64   use strict;
               5                                 16   
               5                                 45   
3567           5                    5            33   use warnings FATAL => 'all';
               5                                 12   
               5                                 36   
3568                                                  
3569           5                    5            33   use POSIX qw(setsid);
               5                                 16   
               5                                 40   
3570           5                    5            38   use English qw(-no_match_vars);
               5                                 11   
               5                                 36   
3571                                                  
3572  ***      5            50      5            44   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 14   
               5                                 85   
3573                                                  
3574                                                  sub new {
3575  ***      0                    0                    my ( $class, %args ) = @_;
3576  ***      0                                         foreach my $arg ( qw(o) ) {
3577  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
3578                                                     }
3579  ***      0                                         my $o = $args{o};
3580  ***      0      0                                  my $self = {
      ***             0                               
3581                                                        o        => $o,
3582                                                        log_file => $o->has('log') ? $o->get('log') : undef,
3583                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
3584                                                     };
3585                                                  
3586  ***      0                                         check_PID_file(undef, $self->{PID_file});
3587                                                  
3588  ***      0                                         MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
3589  ***      0                                         return bless $self, $class;
3590                                                  }
3591                                                  
3592                                                  sub daemonize {
3593  ***      0                    0                    my ( $self ) = @_;
3594                                                  
3595  ***      0                                         MKDEBUG && _d('About to fork and daemonize');
3596  ***      0      0                                  defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
3597  ***      0      0                                  if ( $pid ) {
3598  ***      0                                            MKDEBUG && _d('I am the parent and now I die');
3599  ***      0                                            exit;
3600                                                     }
3601                                                  
3602  ***      0                                         $self->{child} = 1;
3603                                                  
3604  ***      0      0                                  POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
3605  ***      0      0                                  chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
3606                                                  
3607  ***      0                                         $self->_make_PID_file();
3608                                                  
3609  ***      0                                         $OUTPUT_AUTOFLUSH = 1;
3610                                                  
3611  ***      0      0                                  if ( -t STDIN ) {
3612  ***      0                                            close STDIN;
3613  ***      0      0                                     open  STDIN, '/dev/null'
3614                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
3615                                                     }
3616                                                  
3617  ***      0      0                                  if ( $self->{log_file} ) {
3618  ***      0                                            close STDOUT;
3619  ***      0      0                                     open  STDOUT, '>>', $self->{log_file}
3620                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
3621                                                  
3622  ***      0                                            close STDERR;
3623  ***      0      0                                     open  STDERR, ">&STDOUT"
3624                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
3625                                                     }
3626                                                     else {
3627  ***      0      0                                     if ( -t STDOUT ) {
3628  ***      0                                               close STDOUT;
3629  ***      0      0                                        open  STDOUT, '>', '/dev/null'
3630                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
3631                                                        }
3632  ***      0      0                                     if ( -t STDERR ) {
3633  ***      0                                               close STDERR;
3634  ***      0      0                                        open  STDERR, '>', '/dev/null'
3635                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
3636                                                        }
3637                                                     }
3638                                                  
3639  ***      0                                         MKDEBUG && _d('I am the child and now I live daemonized');
3640  ***      0                                         return;
3641                                                  }
3642                                                  
3643                                                  sub check_PID_file {
3644  ***      0                    0                    my ( $self, $file ) = @_;
3645  ***      0      0                                  my $PID_file = $self ? $self->{PID_file} : $file;
3646  ***      0                                         MKDEBUG && _d('Checking PID file', $PID_file);
3647  ***      0      0      0                           if ( $PID_file && -f $PID_file ) {
3648  ***      0                                            my $pid;
3649  ***      0                                            eval { chomp($pid = `cat $PID_file`); };
      ***      0                                      
3650  ***      0      0                                     die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
3651  ***      0                                            MKDEBUG && _d('PID file exists; it contains PID', $pid);
3652  ***      0      0                                     if ( $pid ) {
3653  ***      0                                               my $pid_is_alive = kill 0, $pid;
3654  ***      0      0                                        if ( $pid_is_alive ) {
3655  ***      0                                                  die "The PID file $PID_file already exists "
3656                                                                 . " and the PID that it contains, $pid, is running";
3657                                                           }
3658                                                           else {
3659  ***      0                                                  warn "Overwriting PID file $PID_file because the PID that it "
3660                                                                 . "contains, $pid, is not running";
3661                                                           }
3662                                                        }
3663                                                        else {
3664  ***      0                                               die "The PID file $PID_file already exists but it does not "
3665                                                              . "contain a PID";
3666                                                        }
3667                                                     }
3668                                                     else {
3669  ***      0                                            MKDEBUG && _d('No PID file');
3670                                                     }
3671  ***      0                                         return;
3672                                                  }
3673                                                  
3674                                                  sub make_PID_file {
3675  ***      0                    0                    my ( $self ) = @_;
3676  ***      0      0                                  if ( exists $self->{child} ) {
3677  ***      0                                            die "Do not call Daemon::make_PID_file() for daemonized scripts";
3678                                                     }
3679  ***      0                                         $self->_make_PID_file();
3680  ***      0                                         $self->{rm_PID_file} = 1;
3681  ***      0                                         return;
3682                                                  }
3683                                                  
3684                                                  sub _make_PID_file {
3685  ***      0                    0                    my ( $self ) = @_;
3686                                                  
3687  ***      0                                         my $PID_file = $self->{PID_file};
3688  ***      0      0                                  if ( !$PID_file ) {
3689  ***      0                                            MKDEBUG && _d('No PID file to create');
3690  ***      0                                            return;
3691                                                     }
3692                                                  
3693  ***      0                                         $self->check_PID_file();
3694                                                  
3695  ***      0      0                                  open my $PID_FH, '>', $PID_file
3696                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
3697  ***      0      0                                  print $PID_FH $PID
3698                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
3699  ***      0      0                                  close $PID_FH
3700                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
3701                                                  
3702  ***      0                                         MKDEBUG && _d('Created PID file:', $self->{PID_file});
3703  ***      0                                         return;
3704                                                  }
3705                                                  
3706                                                  sub _remove_PID_file {
3707  ***      0                    0                    my ( $self ) = @_;
3708  ***      0      0      0                           if ( $self->{PID_file} && -f $self->{PID_file} ) {
3709  ***      0      0                                     unlink $self->{PID_file}
3710                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
3711  ***      0                                            MKDEBUG && _d('Removed PID file');
3712                                                     }
3713                                                     else {
3714  ***      0                                            MKDEBUG && _d('No PID to remove');
3715                                                     }
3716  ***      0                                         return;
3717                                                  }
3718                                                  
3719                                                  sub DESTROY {
3720  ***      0                    0                    my ( $self ) = @_;
3721  ***      0      0      0                           $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
3722  ***      0                                         return;
3723                                                  }
3724                                                  
3725                                                  sub _d {
3726  ***      0                    0                    my ($package, undef, $line) = caller 0;
3727  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
3728  ***      0                                              map { defined $_ ? $_ : 'undef' }
3729                                                          @_;
3730  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3731                                                  }
3732                                                  
3733                                                  1;
3734                                                  
3735                                                  # ###########################################################################
3736                                                  # End Daemon package
3737                                                  # ###########################################################################
3738                                                  
3739                                                  # ###########################################################################
3740                                                  # ChangeHandler package 5266
3741                                                  # ###########################################################################
3742           5                    5            51   use strict;
               5                                 12   
               5                                 37   
3743           5                    5            30   use warnings FATAL => 'all';
               5                                 15   
               5                                 45   
3744                                                  
3745                                                  package ChangeHandler;
3746                                                  
3747           5                    5            31   use English qw(-no_match_vars);
               5                                 12   
               5                                 32   
3748                                                  
3749                                                  my $DUPE_KEY  = qr/Duplicate entry/;
3750                                                  our @ACTIONS  = qw(DELETE REPLACE INSERT UPDATE);
3751                                                  
3752  ***      5            50      5            47   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 11   
               5                                122   
3753                                                  
3754                                                  sub new {
3755  ***      0                    0                    my ( $class, %args ) = @_;
3756  ***      0                                         foreach my $arg ( qw(Quoter dst_db dst_tbl src_db src_tbl replace queue) ) {
3757  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
3758                                                     }
3759  ***      0                                         my $self = { %args, map { $_ => [] } @ACTIONS };
      ***      0                                      
3760  ***      0                                         $self->{dst_db_tbl} = $self->{Quoter}->quote(@args{qw(dst_db dst_tbl)});
3761  ***      0                                         $self->{src_db_tbl} = $self->{Quoter}->quote(@args{qw(src_db src_tbl)});
3762  ***      0                                         $self->{changes} = { map { $_ => 0 } @ACTIONS };
      ***      0                                      
3763  ***      0                                         return bless $self, $class;
3764                                                  }
3765                                                  
3766                                                  sub fetch_back {
3767  ***      0                    0                    my ( $self, $dbh ) = @_;
3768  ***      0                                         $self->{fetch_back} = $dbh;
3769  ***      0                                         MKDEBUG && _d('Will fetch rows from source when updating destination');
3770                                                  }
3771                                                  
3772                                                  sub take_action {
3773  ***      0                    0                    my ( $self, @sql ) = @_;
3774  ***      0                                         MKDEBUG && _d('Calling subroutines on', @sql);
3775  ***      0                                         foreach my $action ( @{$self->{actions}} ) {
      ***      0                                      
3776  ***      0                                            $action->(@sql);
3777                                                     }
3778                                                  }
3779                                                  
3780                                                  sub change {
3781  ***      0                    0                    my ( $self, $action, $row, $cols ) = @_;
3782  ***      0                                         MKDEBUG && _d($action, 'where', $self->make_where_clause($row, $cols));
3783                                                     $self->{changes}->{
3784  ***      0      0      0                              $self->{replace} && $action ne 'DELETE' ? 'REPLACE' : $action
3785                                                     }++;
3786  ***      0      0                                  if ( $self->{queue} ) {
3787  ***      0                                            $self->__queue($action, $row, $cols);
3788                                                     }
3789                                                     else {
3790  ***      0                                            eval {
3791  ***      0                                               my $func = "make_$action";
3792  ***      0                                               $self->take_action($self->$func($row, $cols));
3793                                                        };
3794  ***      0      0                                     if ( $EVAL_ERROR =~ m/$DUPE_KEY/ ) {
      ***             0                               
3795  ***      0                                               MKDEBUG && _d('Duplicate key violation; will queue and rewrite');
3796  ***      0                                               $self->{queue}++;
3797  ***      0                                               $self->{replace} = 1;
3798  ***      0                                               $self->__queue($action, $row, $cols);
3799                                                        }
3800                                                        elsif ( $EVAL_ERROR ) {
3801  ***      0                                               die $EVAL_ERROR;
3802                                                        }
3803                                                     }
3804                                                  }
3805                                                  
3806                                                  sub __queue {
3807  ***      0                    0                    my ( $self, $action, $row, $cols ) = @_;
3808  ***      0                                         MKDEBUG && _d('Queueing change for later');
3809  ***      0      0                                  if ( $self->{replace} ) {
3810  ***      0      0                                     $action = $action eq 'DELETE' ? $action : 'REPLACE';
3811                                                     }
3812  ***      0                                         push @{$self->{$action}}, [ $row, $cols ];
      ***      0                                      
3813                                                  }
3814                                                  
3815                                                  sub process_rows {
3816  ***      0                    0                    my ( $self, $queue_level ) = @_;
3817  ***      0                                         my $error_count = 0;
3818                                                     TRY: {
3819  ***      0      0      0                              if ( $queue_level && $queue_level < $self->{queue} ) { # see redo below!
      ***      0                                      
3820  ***      0                                               MKDEBUG && _d('Not processing now', $queue_level, '<', $self->{queue});
3821  ***      0                                               return;
3822                                                        }
3823  ***      0                                            MKDEBUG && _d('Processing rows:');
3824  ***      0                                            my ($row, $cur_act);
3825  ***      0                                            eval {
3826  ***      0                                               foreach my $action ( @ACTIONS ) {
3827  ***      0                                                  my $func = "make_$action";
3828  ***      0                                                  my $rows = $self->{$action};
3829  ***      0                                                  MKDEBUG && _d(scalar(@$rows), 'to', $action);
3830  ***      0                                                  $cur_act = $action;
3831  ***      0                                                  while ( @$rows ) {
3832  ***      0                                                     $row = shift @$rows;
3833  ***      0                                                     $self->take_action($self->$func(@$row));
3834                                                              }
3835                                                           }
3836  ***      0                                               $error_count = 0;
3837                                                        };
3838  ***      0      0      0                              if ( !$error_count++ && $EVAL_ERROR =~ m/$DUPE_KEY/ ) {
      ***             0                               
3839  ***      0                                               MKDEBUG
3840                                                              && _d('Duplicate key violation; re-queueing and rewriting');
3841  ***      0                                               $self->{queue}++; # Defer rows to the very end
3842  ***      0                                               $self->{replace} = 1;
3843  ***      0                                               $self->__queue($cur_act, @$row);
3844  ***      0                                               redo TRY;
3845                                                        }
3846                                                        elsif ( $EVAL_ERROR ) {
3847  ***      0                                               die $EVAL_ERROR;
3848                                                        }
3849                                                     }
3850                                                  }
3851                                                  
3852                                                  sub make_DELETE {
3853  ***      0                    0                    my ( $self, $row, $cols ) = @_;
3854  ***      0                                         MKDEBUG && _d('Make DELETE');
3855  ***      0                                         return "DELETE FROM $self->{dst_db_tbl} WHERE "
3856                                                        . $self->make_where_clause($row, $cols)
3857                                                        . ' LIMIT 1';
3858                                                  }
3859                                                  
3860                                                  sub make_UPDATE {
3861  ***      0                    0                    my ( $self, $row, $cols ) = @_;
3862  ***      0                                         MKDEBUG && _d('Make UPDATE');
3863  ***      0      0                                  if ( $self->{replace} ) {
3864  ***      0                                            return $self->make_row('REPLACE', $row, $cols);
3865                                                     }
3866  ***      0                                         my %in_where = map { $_ => 1 } @$cols;
      ***      0                                      
3867  ***      0                                         my $where = $self->make_where_clause($row, $cols);
3868  ***      0                                         my @cols;
3869  ***      0      0                                  if ( my $dbh = $self->{fetch_back} ) {
3870  ***      0                                            my $sql = "SELECT * FROM $self->{src_db_tbl} WHERE $where LIMIT 1";
3871  ***      0                                            MKDEBUG && _d('Fetching data for UPDATE:', $sql);
3872  ***      0                                            my $res = $dbh->selectrow_hashref($sql);
3873  ***      0                                            @{$row}{keys %$res} = values %$res;
      ***      0                                      
3874  ***      0                                            @cols = $self->sort_cols($res);
3875                                                     }
3876                                                     else {
3877  ***      0                                            @cols = $self->sort_cols($row);
3878                                                     }
3879  ***      0                                         return "UPDATE $self->{dst_db_tbl} SET "
3880                                                        . join(', ', map {
3881  ***      0                                                  $self->{Quoter}->quote($_)
3882                                                              . '=' .  $self->{Quoter}->quote_val($row->{$_})
3883  ***      0                                               } grep { !$in_where{$_} } @cols)
3884                                                        . " WHERE $where LIMIT 1";
3885                                                  }
3886                                                  
3887                                                  sub make_INSERT {
3888  ***      0                    0                    my ( $self, $row, $cols ) = @_;
3889  ***      0                                         MKDEBUG && _d('Make INSERT');
3890  ***      0      0                                  if ( $self->{replace} ) {
3891  ***      0                                            return $self->make_row('REPLACE', $row, $cols);
3892                                                     }
3893  ***      0                                         return $self->make_row('INSERT', $row, $cols);
3894                                                  }
3895                                                  
3896                                                  sub make_REPLACE {
3897  ***      0                    0                    my ( $self, $row, $cols ) = @_;
3898  ***      0                                         MKDEBUG && _d('Make REPLACE');
3899  ***      0                                         return $self->make_row('REPLACE', $row, $cols);
3900                                                  }
3901                                                  
3902                                                  sub make_row {
3903  ***      0                    0                    my ( $self, $verb, $row, $cols ) = @_;
3904  ***      0                                         my @cols; 
3905  ***      0      0                                  if ( my $dbh = $self->{fetch_back} ) {
3906  ***      0                                            my $where = $self->make_where_clause($row, $cols);
3907  ***      0                                            my $sql = "SELECT * FROM $self->{src_db_tbl} WHERE $where LIMIT 1";
3908  ***      0                                            MKDEBUG && _d('Fetching data for UPDATE:', $sql);
3909  ***      0                                            my $res = $dbh->selectrow_hashref($sql);
3910  ***      0                                            @{$row}{keys %$res} = values %$res;
      ***      0                                      
3911  ***      0                                            @cols = $self->sort_cols($res);
3912                                                     }
3913                                                     else {
3914  ***      0                                            @cols = $self->sort_cols($row);
3915                                                     }
3916  ***      0                                         my $q = $self->{Quoter};
3917  ***      0                                         return "$verb INTO $self->{dst_db_tbl}("
3918  ***      0                                            . join(', ', map { $q->quote($_) } @cols)
3919                                                        . ') VALUES ('
3920  ***      0                                            . join(', ', map { $q->quote_val($_) } @{$row}{@cols} )
      ***      0                                      
3921                                                        . ')';
3922                                                  }
3923                                                  
3924                                                  sub make_where_clause {
3925  ***      0                    0                    my ( $self, $row, $cols ) = @_;
3926  ***      0                                         my @clauses = map {
3927  ***      0                                            my $val = $row->{$_};
3928  ***      0      0                                     my $sep = defined $val ? '=' : ' IS ';
3929  ***      0                                            $self->{Quoter}->quote($_) . $sep . $self->{Quoter}->quote_val($val);
3930                                                     } @$cols;
3931  ***      0                                         return join(' AND ', @clauses);
3932                                                  }
3933                                                  
3934                                                  sub get_changes {
3935  ***      0                    0                    my ( $self ) = @_;
3936  ***      0                                         return %{$self->{changes}};
      ***      0                                      
3937                                                  }
3938                                                  
3939                                                  sub sort_cols {
3940  ***      0                    0                    my ( $self, $row ) = @_;
3941  ***      0                                         my @cols;
3942  ***      0      0                                  if ( $self->{tbl_struct} ) { 
3943  ***      0                                            my $pos = $self->{tbl_struct}->{col_posn};
3944  ***      0                                            my @not_in_tbl;
3945  ***      0                                            @cols = sort {
3946                                                              $pos->{$a} <=> $pos->{$b}
3947                                                           }
3948                                                           grep {
3949  ***      0      0                                           if ( !defined $pos->{$_} ) {
      ***      0                                      
3950  ***      0                                                     push @not_in_tbl, $_;
3951  ***      0                                                     0;
3952                                                              }
3953                                                              else {
3954  ***      0                                                     1;
3955                                                              }
3956                                                           }
3957                                                           keys %$row;
3958  ***      0      0                                     push @cols, @not_in_tbl if @not_in_tbl;
3959                                                     }
3960                                                     else {
3961  ***      0                                            @cols = sort keys %$row;
3962                                                     }
3963  ***      0                                         return @cols;
3964                                                  }
3965                                                  
3966                                                  sub _d {
3967  ***      0                    0                    my ($package, undef, $line) = caller 0;
3968  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
3969  ***      0                                              map { defined $_ ? $_ : 'undef' }
3970                                                          @_;
3971  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3972                                                  }
3973                                                  
3974                                                  1;
3975                                                  
3976                                                  # ###########################################################################
3977                                                  # End ChangeHandler package
3978                                                  # ###########################################################################
3979                                                  
3980                                                  # ###########################################################################
3981                                                  # RowDiff package 5266
3982                                                  # ###########################################################################
3983           5                    5            62   use strict;
               5                                 19   
               5                                 48   
3984           5                    5            33   use warnings FATAL => 'all';
               5                                 12   
               5                                 39   
3985                                                  
3986                                                  package RowDiff;
3987                                                  
3988           5                    5            40   use English qw(-no_match_vars);
               5                                 17   
               5                                 76   
3989                                                  
3990  ***      5            50      5            62   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 14   
               5                                202   
3991                                                  
3992                                                  sub new {
3993  ***      0                    0                    my ( $class, %args ) = @_;
3994  ***      0      0                                  die "I need a dbh" unless $args{dbh};
3995  ***      0                                         my $self = \%args;
3996  ***      0                                         return bless $self, $class;
3997                                                  }
3998                                                  
3999                                                  sub compare_sets {
4000  ***      0                    0                    my ( $self, %args ) = @_;
4001  ***      0                                         my ( $left, $right, $syncer, $tbl )
4002                                                        = @args{qw(left right syncer tbl)};
4003                                                  
4004  ***      0                                         my ($lr, $rr);  # Current row from the left/right sources.
4005  ***      0                                         my $done = $self->{done};
4006                                                  
4007  ***      0                                         my ($left_done, $right_done) = (0, 0);
4008                                                  
4009  ***      0             0                           do {
4010  ***      0      0      0                              if ( !$lr && !$left_done ) {
4011  ***      0                                               MKDEBUG && _d('Fetching row from left');
4012  ***      0                                               eval { $lr = $left->fetchrow_hashref(); };
      ***      0                                      
4013  ***      0                                               MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
4014  ***      0      0      0                                 $left_done = !$lr || $EVAL_ERROR ? 1 : 0;
4015                                                        }
4016                                                        elsif ( MKDEBUG ) {
4017                                                           _d('Left still has rows');
4018                                                        }
4019                                                  
4020  ***      0      0      0                              if ( !$rr && !$right_done ) {
4021  ***      0                                               MKDEBUG && _d('Fetching row from right');
4022  ***      0                                               eval { $rr = $right->fetchrow_hashref(); };
      ***      0                                      
4023  ***      0                                               MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
4024  ***      0      0      0                                 $right_done = !$rr || $EVAL_ERROR ? 1 : 0;
4025                                                        }
4026                                                        elsif ( MKDEBUG ) {
4027                                                           _d('Right still has rows');
4028                                                        }
4029                                                  
4030  ***      0                                            my $cmp;
4031  ***      0      0      0                              if ( $lr && $rr ) {
4032  ***      0                                               $cmp = $self->key_cmp($lr, $rr, $syncer->key_cols(), $tbl);
4033  ***      0                                               MKDEBUG && _d('Key comparison on left and right:', $cmp);
4034                                                        }
4035  ***      0      0      0                              if ( $lr || $rr ) {
4036  ***      0      0      0                                 if ( $lr && $rr && defined $cmp && $cmp == 0 ) {
      ***             0      0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
4037  ***      0                                                  MKDEBUG && _d('Left and right have the same key');
4038  ***      0                                                  $syncer->same_row($lr, $rr);
4039  ***      0      0                                           $self->{same_row}->($lr, $rr) if $self->{same_row};
4040  ***      0                                                  $lr = $rr = undef; # Fetch another row from each side.
4041                                                           }
4042                                                           elsif ( !$rr || ( defined $cmp && $cmp < 0 ) ) {
4043  ***      0                                                  MKDEBUG && _d('Left is not in right');
4044  ***      0                                                  $syncer->not_in_right($lr);
4045  ***      0      0                                           $self->{not_in_right}->($lr) if $self->{not_in_right};
4046  ***      0                                                  $lr = undef;
4047                                                           }
4048                                                           else {
4049  ***      0                                                  MKDEBUG && _d('Right is not in left');
4050  ***      0                                                  $syncer->not_in_left($rr);
4051  ***      0      0                                           $self->{not_in_left}->($rr) if $self->{not_in_left};
4052  ***      0                                                  $rr = undef;
4053                                                           }
4054                                                        }
4055  ***      0      0      0                              $left_done = $right_done = 1 if $done && $done->($left, $right);
4056                                                     } while ( !($left_done && $right_done) );
4057  ***      0                                         MKDEBUG && _d('No more rows');
4058  ***      0                                         $syncer->done_with_rows();
4059                                                  }
4060                                                  
4061                                                  sub key_cmp {
4062  ***      0                    0                    my ( $self, $lr, $rr, $key_cols, $tbl ) = @_;
4063  ***      0                                         MKDEBUG && _d('Comparing keys using columns:', join(',', @$key_cols));
4064  ***      0                                         my $callback = $self->{key_cmp};
4065  ***      0                                         my $trf      = $self->{trf};
4066  ***      0                                         foreach my $col ( @$key_cols ) {
4067  ***      0                                            my $l = $lr->{$col};
4068  ***      0                                            my $r = $rr->{$col};
4069  ***      0      0      0                              if ( !defined $l || !defined $r ) {
4070  ***      0                                               MKDEBUG && _d($col, 'is not defined in both rows');
4071  ***      0      0                                        return defined $l ? 1 : defined $r ? -1 : 0;
      ***             0                               
4072                                                        }
4073                                                        else {
4074  ***      0      0                                        if ($tbl->{is_numeric}->{$col} ) {   # Numeric column
      ***             0                               
4075  ***      0                                                  MKDEBUG && _d($col, 'is numeric');
4076  ***      0      0                                           ($l, $r) = $trf->($l, $r, $tbl, $col) if $trf;
4077  ***      0                                                  my $cmp = $l <=> $r;
4078  ***      0      0                                           if ( $cmp ) {
4079  ***      0                                                     MKDEBUG && _d('Column', $col, 'differs:', $l, '!=', $r);
4080  ***      0      0                                              $callback->($col, $l, $r) if $callback;
4081  ***      0                                                     return $cmp;
4082                                                              }
4083                                                           }
4084                                                           elsif ( $l ne $r ) {
4085  ***      0                                                  my $cmp;
4086  ***      0                                                  my $coll = $tbl->{collation_for}->{$col};
4087  ***      0      0      0                                    if ( $coll && ( $coll ne 'latin1_swedish_ci'
      ***                    0                        
      ***                    0                        
4088                                                                             || $l =~ m/[^\040-\177]/ || $r =~ m/[^\040-\177]/) ) {
4089  ***      0                                                     MKDEBUG && _d('Comparing', $col, 'via MySQL');
4090  ***      0                                                     $cmp = $self->db_cmp($coll, $l, $r);
4091                                                              }
4092                                                              else {
4093  ***      0                                                     MKDEBUG && _d('Comparing', $col, 'in lowercase');
4094  ***      0                                                     $cmp = lc $l cmp lc $r;
4095                                                              }
4096  ***      0      0                                           if ( $cmp ) {
4097  ***      0                                                     MKDEBUG && _d('Column', $col, 'differs:', $l, 'ne', $r);
4098  ***      0      0                                              $callback->($col, $l, $r) if $callback;
4099  ***      0                                                     return $cmp;
4100                                                              }
4101                                                           }
4102                                                        }
4103                                                     }
4104  ***      0                                         return 0;
4105                                                  }
4106                                                  
4107                                                  sub db_cmp {
4108  ***      0                    0                    my ( $self, $collation, $l, $r ) = @_;
4109  ***      0      0                                  if ( !$self->{sth}->{$collation} ) {
4110  ***      0      0                                     if ( !$self->{charset_for} ) {
4111  ***      0                                               MKDEBUG && _d('Fetching collations from MySQL');
4112  ***      0                                               my @collations = @{$self->{dbh}->selectall_arrayref(
      ***      0                                      
4113                                                              'SHOW COLLATION', {Slice => { collation => 1, charset => 1 }})};
4114  ***      0                                               foreach my $collation ( @collations ) {
4115  ***      0                                                  $self->{charset_for}->{$collation->{collation}}
4116                                                                 = $collation->{charset};
4117                                                           }
4118                                                        }
4119  ***      0                                            my $sql = "SELECT STRCMP(_$self->{charset_for}->{$collation}? COLLATE $collation, "
4120                                                           . "_$self->{charset_for}->{$collation}? COLLATE $collation) AS res";
4121  ***      0                                            MKDEBUG && _d($sql);
4122  ***      0                                            $self->{sth}->{$collation} = $self->{dbh}->prepare($sql);
4123                                                     }
4124  ***      0                                         my $sth = $self->{sth}->{$collation};
4125  ***      0                                         $sth->execute($l, $r);
4126  ***      0                                         return $sth->fetchall_arrayref()->[0]->[0];
4127                                                  }
4128                                                  
4129                                                  sub _d {
4130  ***      0                    0                    my ($package, undef, $line) = caller 0;
4131  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
4132  ***      0                                              map { defined $_ ? $_ : 'undef' }
4133                                                          @_;
4134  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4135                                                  }
4136                                                  
4137                                                  1;
4138                                                  
4139                                                  # ###########################################################################
4140                                                  # End RowDiff package
4141                                                  # ###########################################################################
4142                                                  
4143                                                  # ###########################################################################
4144                                                  # TableChunker package 5266
4145                                                  # ###########################################################################
4146           5                    5            51   use strict;
               5                                 22   
               5                                 75   
4147           5                    5            30   use warnings FATAL => 'all';
               5                                 13   
               5                                 36   
4148                                                  
4149                                                  package TableChunker;
4150                                                  
4151           5                    5            34   use English qw(-no_match_vars);
               5                                 13   
               5                                 35   
4152           5                    5            44   use POSIX qw(ceil);
               5                                 15   
               5                                 44   
4153           5                    5            32   use List::Util qw(min max);
               5                                 15   
               5                                 35   
4154           5                    5            43   use Data::Dumper;
               5                                 14   
               5                                 33   
4155                                                  $Data::Dumper::Indent    = 1;
4156                                                  $Data::Dumper::Sortkeys  = 1;
4157                                                  $Data::Dumper::Quotekeys = 0;
4158                                                  
4159  ***      5            50      5            35   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 17   
               5                                101   
4160                                                  
4161                                                  sub new {
4162  ***      0                    0                    my ( $class, %args ) = @_;
4163  ***      0                                         foreach my $arg ( qw(Quoter MySQLDump) ) {
4164  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
4165                                                     }
4166  ***      0                                         my $self = { %args };
4167  ***      0                                         return bless $self, $class;
4168                                                  }
4169                                                  
4170                                                  my $EPOCH      = '1970-01-01';
4171                                                  my %int_types  = map { $_ => 1 }
4172                                                     qw(bigint date datetime int mediumint smallint time timestamp tinyint year);
4173                                                  my %real_types = map { $_ => 1 }
4174                                                     qw(decimal double float);
4175                                                  
4176                                                  sub find_chunk_columns {
4177  ***      0                    0                    my ( $self, %args ) = @_;
4178  ***      0                                         foreach my $arg ( qw(tbl_struct) ) {
4179  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
4180                                                     }
4181  ***      0                                         my $tbl_struct = $args{tbl_struct};
4182                                                  
4183  ***      0                                         my @possible_indexes;
4184  ***      0                                         foreach my $index ( values %{ $tbl_struct->{keys} } ) {
      ***      0                                      
4185                                                  
4186  ***      0      0                                     next unless $index->{type} eq 'BTREE';
4187                                                  
4188  ***      0             0                              defined $_ && next for @{ $index->{col_prefixes} };
      ***      0                                      
      ***      0                                      
4189                                                  
4190  ***      0      0                                     if ( $args{exact} ) {
4191  ***      0      0      0                                 next unless $index->{is_unique} && @{$index->{cols}} == 1;
      ***      0                                      
4192                                                        }
4193                                                  
4194  ***      0                                            push @possible_indexes, $index;
4195                                                     }
4196                                                     MKDEBUG && _d('Possible chunk indexes in order:',
4197  ***      0                                            join(', ', map { $_->{name} } @possible_indexes));
4198                                                  
4199  ***      0                                         my $can_chunk_exact = 0;
4200  ***      0                                         my @candidate_cols;
4201  ***      0                                         foreach my $index ( @possible_indexes ) { 
4202  ***      0                                            my $col = $index->{cols}->[0];
4203                                                  
4204  ***      0      0      0                              next unless ( $int_types{$tbl_struct->{type_for}->{$col}}
4205                                                                      || $real_types{$tbl_struct->{type_for}->{$col}} );
4206                                                  
4207  ***      0                                            push @candidate_cols, { column => $col, index => $index->{name} };
4208                                                     }
4209                                                  
4210  ***      0      0      0                           $can_chunk_exact = 1 if $args{exact} && scalar @candidate_cols;
4211                                                  
4212  ***      0                                         if ( MKDEBUG ) {
4213                                                        my $chunk_type = $args{exact} ? 'Exact' : 'Inexact';
4214                                                        _d($chunk_type, 'chunkable:',
4215                                                           join(', ', map { "$_->{column} on $_->{index}" } @candidate_cols));
4216                                                     }
4217                                                  
4218  ***      0                                         my @result;
4219  ***      0                                         MKDEBUG && _d('Ordering columns by order in tbl, PK first');
4220  ***      0      0                                  if ( $tbl_struct->{keys}->{PRIMARY} ) {
4221  ***      0                                            my $pk_first_col = $tbl_struct->{keys}->{PRIMARY}->{cols}->[0];
4222  ***      0                                            @result          = grep { $_->{column} eq $pk_first_col } @candidate_cols;
      ***      0                                      
4223  ***      0                                            @candidate_cols  = grep { $_->{column} ne $pk_first_col } @candidate_cols;
      ***      0                                      
4224                                                     }
4225  ***      0                                         my $i = 0;
4226  ***      0                                         my %col_pos = map { $_ => $i++ } @{$tbl_struct->{cols}};
      ***      0                                      
      ***      0                                      
4227  ***      0                                         push @result, sort { $col_pos{$a->{column}} <=> $col_pos{$b->{column}} }
      ***      0                                      
4228                                                                      @candidate_cols;
4229                                                  
4230  ***      0                                         if ( MKDEBUG ) {
4231                                                        _d('Chunkable columns:',
4232                                                           join(', ', map { "$_->{column} on $_->{index}" } @result));
4233                                                        _d('Can chunk exactly:', $can_chunk_exact);
4234                                                     }
4235                                                  
4236  ***      0                                         return ($can_chunk_exact, @result);
4237                                                  }
4238                                                  
4239                                                  sub calculate_chunks {
4240  ***      0                    0                    my ( $self, %args ) = @_;
4241  ***      0                                         foreach my $arg ( qw(dbh tbl_struct chunk_col min max rows_in_range
4242                                                                          chunk_size dbh) ) {
4243  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
4244                                                     }
4245  ***      0                                         MKDEBUG && _d('Calculate chunks for', Dumper(\%args));
4246  ***      0                                         my $dbh = $args{dbh};
4247                                                  
4248  ***      0                                         my @chunks;
4249  ***      0                                         my ($range_func, $start_point, $end_point);
4250  ***      0                                         my $col_type = $args{tbl_struct}->{type_for}->{$args{chunk_col}};
4251  ***      0                                         MKDEBUG && _d('chunk col type:', $col_type);
4252                                                  
4253                                                  
4254  ***      0      0                                  if ( $col_type =~ m/(?:int|year|float|double|decimal)$/ ) {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
4255  ***      0                                            $start_point = $args{min};
4256  ***      0                                            $end_point   = $args{max};
4257  ***      0                                            $range_func  = 'range_num';
4258                                                     }
4259                                                     elsif ( $col_type eq 'timestamp' ) {
4260  ***      0                                            my $sql = "SELECT UNIX_TIMESTAMP('$args{min}'), UNIX_TIMESTAMP('$args{max}')";
4261  ***      0                                            MKDEBUG && _d($sql);
4262  ***      0                                            ($start_point, $end_point) = $dbh->selectrow_array($sql);
4263  ***      0                                            $range_func  = 'range_timestamp';
4264                                                     }
4265                                                     elsif ( $col_type eq 'date' ) {
4266  ***      0                                            my $sql = "SELECT TO_DAYS('$args{min}'), TO_DAYS('$args{max}')";
4267  ***      0                                            MKDEBUG && _d($sql);
4268  ***      0                                            ($start_point, $end_point) = $dbh->selectrow_array($sql);
4269  ***      0                                            $range_func  = 'range_date';
4270                                                     }
4271                                                     elsif ( $col_type eq 'time' ) {
4272  ***      0                                            my $sql = "SELECT TIME_TO_SEC('$args{min}'), TIME_TO_SEC('$args{max}')";
4273  ***      0                                            MKDEBUG && _d($sql);
4274  ***      0                                            ($start_point, $end_point) = $dbh->selectrow_array($sql);
4275  ***      0                                            $range_func  = 'range_time';
4276                                                     }
4277                                                     elsif ( $col_type eq 'datetime' ) {
4278  ***      0                                            $start_point = $self->timestampdiff($dbh, $args{min});
4279  ***      0                                            $end_point   = $self->timestampdiff($dbh, $args{max});
4280  ***      0                                            $range_func  = 'range_datetime';
4281                                                     }
4282                                                     else {
4283  ***      0                                            die "I don't know how to chunk $col_type\n";
4284                                                     }
4285                                                  
4286  ***      0      0                                  if ( !defined $start_point ) {
4287  ***      0                                            MKDEBUG && _d('Start point is undefined');
4288  ***      0                                            $start_point = 0;
4289                                                     }
4290  ***      0      0      0                           if ( !defined $end_point || $end_point < $start_point ) {
4291  ***      0                                            MKDEBUG && _d('End point is undefined or before start point');
4292  ***      0                                            $end_point = 0;
4293                                                     }
4294  ***      0                                         MKDEBUG && _d('Start and end of chunk range:',$start_point,',', $end_point);
4295                                                  
4296  ***      0                                         my $interval = $args{chunk_size}
4297                                                                  * ($end_point - $start_point)
4298                                                                  / $args{rows_in_range};
4299  ***      0      0                                  if ( $int_types{$col_type} ) {
4300  ***      0                                            $interval = ceil($interval);
4301                                                     }
4302  ***      0             0                           $interval ||= $args{chunk_size};
4303  ***      0      0                                  if ( $args{exact} ) {
4304  ***      0                                            $interval = $args{chunk_size};
4305                                                     }
4306  ***      0                                         MKDEBUG && _d('Chunk interval:', $interval, 'units');
4307                                                  
4308  ***      0                                         my $col = $self->{Quoter}->quote($args{chunk_col});
4309  ***      0      0                                  if ( $start_point < $end_point ) {
4310  ***      0                                            my ( $beg, $end );
4311  ***      0                                            my $iter = 0;
4312                                                        for ( my $i = $start_point; $i < $end_point; $i += $interval ) {
4313  ***      0                                               ( $beg, $end ) = $self->$range_func($dbh, $i, $interval, $end_point);
4314                                                  
4315  ***      0      0                                        if ( $iter++ == 0 ) {
4316  ***      0                                                  push @chunks, "$col < " . $self->quote($end);
4317                                                           }
4318                                                           else {
4319  ***      0                                                  push @chunks, "$col >= " . $self->quote($beg) . " AND $col < " . $self->quote($end);
4320                                                           }
4321  ***      0                                            }
4322                                                  
4323  ***      0                                            my $nullable = $args{tbl_struct}->{is_nullable}->{$args{chunk_col}};
4324  ***      0                                            pop @chunks;
4325  ***      0      0                                     if ( @chunks ) {
4326  ***      0                                               push @chunks, "$col >= " . $self->quote($beg);
4327                                                        }
4328                                                        else {
4329  ***      0      0                                        push @chunks, $nullable ? "$col IS NOT NULL" : '1=1';
4330                                                        }
4331  ***      0      0                                     if ( $nullable ) {
4332  ***      0                                               push @chunks, "$col IS NULL";
4333                                                        }
4334                                                  
4335                                                     }
4336                                                     else {
4337  ***      0                                            MKDEBUG && _d('No chunks; using single chunk 1=1');
4338  ***      0                                            push @chunks, '1=1';
4339                                                     }
4340                                                  
4341  ***      0                                         return @chunks;
4342                                                  }
4343                                                  
4344                                                  sub get_first_chunkable_column {
4345  ***      0                    0                    my ( $self, %args ) = @_;
4346  ***      0                                         foreach my $arg ( qw(tbl_struct) ) {
4347  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
4348                                                     }
4349  ***      0                                         my ($exact, @cols) = $self->find_chunk_columns(%args);
4350  ***      0                                         return ( $cols[0]->{column}, $cols[0]->{index} );
4351                                                  }
4352                                                  
4353                                                  sub size_to_rows {
4354  ***      0                    0                    my ( $self, %args ) = @_;
4355  ***      0                                         my @required_args = qw(dbh db tbl chunk_size);
4356  ***      0                                         foreach my $arg ( @required_args ) {
4357  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
4358                                                     }
4359  ***      0                                         my ($dbh, $db, $tbl, $chunk_size) = @args{@required_args};
4360  ***      0                                         my $q  = $self->{Quoter};
4361  ***      0                                         my $du = $self->{MySQLDump};
4362                                                  
4363  ***      0                                         my ($n_rows, $avg_row_length);
4364                                                  
4365  ***      0                                         my ( $num, $suffix ) = $chunk_size =~ m/^(\d+)([MGk])?$/;
4366  ***      0      0                                  if ( $suffix ) { # Convert to bytes.
      ***             0                               
4367  ***      0      0                                     $chunk_size = $suffix eq 'k' ? $num * 1_024
      ***             0                               
4368                                                                    : $suffix eq 'M' ? $num * 1_024 * 1_024
4369                                                                    :                  $num * 1_024 * 1_024 * 1_024;
4370                                                     }
4371                                                     elsif ( $num ) {
4372  ***      0                                            $n_rows = $num;
4373                                                     }
4374                                                     else {
4375  ***      0                                            die "Invalid chunk size $chunk_size; must be an integer "
4376                                                           . "with optional suffix kMG";
4377                                                     }
4378                                                  
4379  ***      0      0      0                           if ( $suffix || $args{avg_row_length} ) {
4380  ***      0                                            my ($status) = $du->get_table_status($dbh, $q, $db, $tbl);
4381  ***      0                                            $avg_row_length = $status->{avg_row_length};
4382  ***      0      0                                     if ( !defined $n_rows ) {
4383  ***      0      0                                        $n_rows = $avg_row_length ? ceil($chunk_size / $avg_row_length) : undef;
4384                                                        }
4385                                                     }
4386                                                  
4387  ***      0      0                                  return wantarray ? ($n_rows, $avg_row_length) : $n_rows;
4388                                                  }
4389                                                  
4390                                                  sub get_range_statistics {
4391  ***      0                    0                    my ( $self, %args ) = @_;
4392  ***      0                                         my @required_args = qw(dbh db tbl chunk_col);
4393  ***      0                                         foreach my $arg ( @required_args ) {
4394  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
4395                                                     }
4396  ***      0                                         my ($dbh, $db, $tbl, $col) = @args{@required_args};
4397  ***      0                                         my $where = $args{where};
4398  ***      0                                         my $q = $self->{Quoter};
4399  ***      0      0                                  my $sql = "SELECT MIN(" . $q->quote($col) . "), MAX(" . $q->quote($col)
4400                                                        . ") FROM " . $q->quote($db, $tbl)
4401                                                        . ($where ? " WHERE $where" : '');
4402  ***      0                                         MKDEBUG && _d($sql);
4403  ***      0                                         my ( $min, $max );
4404  ***      0                                         eval {
4405  ***      0                                            ( $min, $max ) = $dbh->selectrow_array($sql);
4406                                                     };
4407  ***      0      0                                  if ( $EVAL_ERROR ) {
4408  ***      0                                            chomp $EVAL_ERROR;
4409  ***      0      0                                     if ( $EVAL_ERROR =~ m/in your SQL syntax/ ) {
4410  ***      0                                               die "$EVAL_ERROR (WHERE clause: $where)";
4411                                                        }
4412                                                        else {
4413  ***      0                                               die $EVAL_ERROR;
4414                                                        }
4415                                                     }
4416  ***      0      0                                  $sql = "EXPLAIN SELECT * FROM " . $q->quote($db, $tbl)
4417                                                        . ($where ? " WHERE $where" : '');
4418  ***      0                                         MKDEBUG && _d($sql);
4419  ***      0                                         my $expl = $dbh->selectrow_hashref($sql);
4420                                                     return (
4421  ***      0                                            min           => $min,
4422                                                        max           => $max,
4423                                                        rows_in_range => $expl->{rows},
4424                                                     );
4425                                                  }
4426                                                  
4427                                                  sub quote {
4428  ***      0                    0                    my ( $self, $val ) = @_;
4429  ***      0      0                                  return $val =~ m/\d[:-]/ ? qq{"$val"} : $val;
4430                                                  }
4431                                                  
4432                                                  sub inject_chunks {
4433  ***      0                    0                    my ( $self, %args ) = @_;
4434  ***      0                                         foreach my $arg ( qw(database table chunks chunk_num query) ) {
4435  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
4436                                                     }
4437  ***      0                                         MKDEBUG && _d('Injecting chunk', $args{chunk_num});
4438  ***      0                                         my $query   = $args{query};
4439  ***      0                                         my $comment = sprintf("/*%s.%s:%d/%d*/",
4440                                                        $args{database}, $args{table},
4441  ***      0                                            $args{chunk_num} + 1, scalar @{$args{chunks}});
4442  ***      0                                         $query =~ s!/\*PROGRESS_COMMENT\*/!$comment!;
4443  ***      0                                         my $where = "WHERE (" . $args{chunks}->[$args{chunk_num}] . ')';
4444  ***      0      0      0                           if ( $args{where} && grep { $_ } @{$args{where}} ) {
      ***      0                                      
      ***      0                                      
4445  ***      0                                            $where .= " AND ("
4446  ***      0                                               . join(" AND ", map { "($_)" } grep { $_ } @{$args{where}} )
      ***      0                                      
      ***      0                                      
4447                                                           . ")";
4448                                                     }
4449  ***      0                                         my $db_tbl     = $self->{Quoter}->quote(@args{qw(database table)});
4450  ***      0             0                           my $index_hint = $args{index_hint} || '';
4451                                                  
4452  ***      0                                         MKDEBUG && _d('Parameters:',
4453                                                        Dumper({WHERE => $where, DB_TBL => $db_tbl, INDEX_HINT => $index_hint}));
4454  ***      0                                         $query =~ s!/\*WHERE\*/! $where!;
4455  ***      0                                         $query =~ s!/\*DB_TBL\*/!$db_tbl!;
4456  ***      0                                         $query =~ s!/\*INDEX_HINT\*/! $index_hint!;
4457  ***      0                                         $query =~ s!/\*CHUNK_NUM\*/! $args{chunk_num} AS chunk_num,!;
4458                                                  
4459  ***      0                                         return $query;
4460                                                  }
4461                                                  
4462                                                  sub range_num {
4463  ***      0                    0                    my ( $self, $dbh, $start, $interval, $max ) = @_;
4464  ***      0                                         my $end = min($max, $start + $interval);
4465                                                  
4466                                                  
4467  ***      0      0                                  $start = sprintf('%.17f', $start) if $start =~ /e/;
4468  ***      0      0                                  $end   = sprintf('%.17f', $end)   if $end   =~ /e/;
4469                                                  
4470  ***      0                                         $start =~ s/\.(\d{5}).*$/.$1/;
4471  ***      0                                         $end   =~ s/\.(\d{5}).*$/.$1/;
4472                                                  
4473  ***      0      0                                  if ( $end > $start ) {
4474  ***      0                                            return ( $start, $end );
4475                                                     }
4476                                                     else {
4477  ***      0                                            die "Chunk size is too small: $end !> $start\n";
4478                                                     }
4479                                                  }
4480                                                  
4481                                                  sub range_time {
4482  ***      0                    0                    my ( $self, $dbh, $start, $interval, $max ) = @_;
4483  ***      0                                         my $sql = "SELECT SEC_TO_TIME($start), SEC_TO_TIME(LEAST($max, $start + $interval))";
4484  ***      0                                         MKDEBUG && _d($sql);
4485  ***      0                                         return $dbh->selectrow_array($sql);
4486                                                  }
4487                                                  
4488                                                  sub range_date {
4489  ***      0                    0                    my ( $self, $dbh, $start, $interval, $max ) = @_;
4490  ***      0                                         my $sql = "SELECT FROM_DAYS($start), FROM_DAYS(LEAST($max, $start + $interval))";
4491  ***      0                                         MKDEBUG && _d($sql);
4492  ***      0                                         return $dbh->selectrow_array($sql);
4493                                                  }
4494                                                  
4495                                                  sub range_datetime {
4496  ***      0                    0                    my ( $self, $dbh, $start, $interval, $max ) = @_;
4497  ***      0                                         my $sql = "SELECT DATE_ADD('$EPOCH', INTERVAL $start SECOND), "
4498                                                         . "DATE_ADD('$EPOCH', INTERVAL LEAST($max, $start + $interval) SECOND)";
4499  ***      0                                         MKDEBUG && _d($sql);
4500  ***      0                                         return $dbh->selectrow_array($sql);
4501                                                  }
4502                                                  
4503                                                  sub range_timestamp {
4504  ***      0                    0                    my ( $self, $dbh, $start, $interval, $max ) = @_;
4505  ***      0                                         my $sql = "SELECT FROM_UNIXTIME($start), FROM_UNIXTIME(LEAST($max, $start + $interval))";
4506  ***      0                                         MKDEBUG && _d($sql);
4507  ***      0                                         return $dbh->selectrow_array($sql);
4508                                                  }
4509                                                  
4510                                                  sub timestampdiff {
4511  ***      0                    0                    my ( $self, $dbh, $time ) = @_;
4512  ***      0                                         my $sql = "SELECT (COALESCE(TO_DAYS('$time'), 0) * 86400 + TIME_TO_SEC('$time')) "
4513                                                        . "- TO_DAYS('$EPOCH 00:00:00') * 86400";
4514  ***      0                                         MKDEBUG && _d($sql);
4515  ***      0                                         my ( $diff ) = $dbh->selectrow_array($sql);
4516  ***      0                                         $sql = "SELECT DATE_ADD('$EPOCH', INTERVAL $diff SECOND)";
4517  ***      0                                         MKDEBUG && _d($sql);
4518  ***      0                                         my ( $check ) = $dbh->selectrow_array($sql);
4519  ***      0      0                                  die <<"   EOF"
4520                                                     Incorrect datetime math: given $time, calculated $diff but checked to $check.
4521                                                     This is probably because you are using a version of MySQL that overflows on
4522                                                     large interval values to DATE_ADD().  If not, please report this as a bug.
4523                                                     EOF
4524                                                        unless $check eq $time;
4525  ***      0                                         return $diff;
4526                                                  }
4527                                                  
4528                                                  sub _d {
4529  ***      0                    0                    my ($package, undef, $line) = caller 0;
4530  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
4531  ***      0                                              map { defined $_ ? $_ : 'undef' }
4532                                                          @_;
4533  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4534                                                  }
4535                                                  
4536                                                  1;
4537                                                  
4538                                                  # ###########################################################################
4539                                                  # End TableChunker package
4540                                                  # ###########################################################################
4541                                                  
4542                                                  # ###########################################################################
4543                                                  # TableNibbler package 5266
4544                                                  # ###########################################################################
4545                                                  package TableNibbler;
4546                                                  
4547           5                    5            65   use strict;
               5                                 15   
               5                                 45   
4548           5                    5            34   use warnings FATAL => 'all';
               5                                 13   
               5                                 41   
4549                                                  
4550           5                    5            33   use English qw(-no_match_vars);
               5                                 12   
               5                                 38   
4551                                                  
4552  ***      5            50      5            48   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 13   
               5                                 93   
4553                                                  
4554                                                  sub new {
4555  ***      0                    0                    my ( $class, %args ) = @_;
4556  ***      0                                         my @required_args = qw(TableParser Quoter);
4557  ***      0                                         foreach my $arg ( @required_args ) {
4558  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
4559                                                     }
4560  ***      0                                         my $self = { %args };
4561  ***      0                                         return bless $self, $class;
4562                                                  }
4563                                                  
4564                                                  sub generate_asc_stmt {
4565  ***      0                    0                    my ( $self, %args ) = @_;
4566  ***      0                                         my @required_args = qw(tbl_struct index);
4567  ***      0                                         foreach my $arg ( @required_args ) {
4568  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
4569                                                     }
4570  ***      0                                         my ($tbl_struct, $index) = @args{@required_args};
4571  ***      0      0                                  my @cols = $args{cols}  ? @{$args{cols}} : @{$tbl_struct->{cols}};
      ***      0                                      
      ***      0                                      
4572  ***      0                                         my $q    = $self->{Quoter};
4573                                                  
4574  ***      0      0                                  die "Index '$index' does not exist in table"
4575                                                        unless exists $tbl_struct->{keys}->{$index};
4576                                                  
4577  ***      0                                         my @asc_cols = @{$tbl_struct->{keys}->{$index}->{cols}};
      ***      0                                      
4578  ***      0                                         my @asc_slice;
4579                                                  
4580  ***      0                                         @asc_cols = @{$tbl_struct->{keys}->{$index}->{cols}};
      ***      0                                      
4581  ***      0                                         MKDEBUG && _d('Will ascend index', $index);
4582  ***      0                                         MKDEBUG && _d('Will ascend columns', join(', ', @asc_cols));
4583  ***      0      0                                  if ( $args{asc_first} ) {
4584  ***      0                                            @asc_cols = $asc_cols[0];
4585  ***      0                                            MKDEBUG && _d('Ascending only first column');
4586                                                     }
4587                                                  
4588  ***      0                                         my %col_posn = do { my $i = 0; map { $_ => $i++ } @cols };
      ***      0                                      
      ***      0                                      
      ***      0                                      
4589  ***      0                                         foreach my $col ( @asc_cols ) {
4590  ***      0      0                                     if ( !exists $col_posn{$col} ) {
4591  ***      0                                               push @cols, $col;
4592  ***      0                                               $col_posn{$col} = $#cols;
4593                                                        }
4594  ***      0                                            push @asc_slice, $col_posn{$col};
4595                                                     }
4596  ***      0                                         MKDEBUG && _d('Will ascend, in ordinal position:', join(', ', @asc_slice));
4597                                                  
4598  ***      0                                         my $asc_stmt = {
4599                                                        cols  => \@cols,
4600                                                        index => $index,
4601                                                        where => '',
4602                                                        slice => [],
4603                                                        scols => [],
4604                                                     };
4605                                                  
4606  ***      0      0                                  if ( @asc_slice ) {
4607  ***      0                                            my $cmp_where;
4608  ***      0                                            foreach my $cmp ( qw(< <= >= >) ) {
4609  ***      0                                               $cmp_where = $self->generate_cmp_where(
4610                                                              type        => $cmp,
4611                                                              slice       => \@asc_slice,
4612                                                              cols        => \@cols,
4613                                                              quoter      => $q,
4614                                                              is_nullable => $tbl_struct->{is_nullable},
4615                                                           );
4616  ***      0                                               $asc_stmt->{boundaries}->{$cmp} = $cmp_where->{where};
4617                                                        }
4618  ***      0      0                                     my $cmp = $args{asc_only} ? '>' : '>=';
4619  ***      0                                            $asc_stmt->{where} = $asc_stmt->{boundaries}->{$cmp};
4620  ***      0                                            $asc_stmt->{slice} = $cmp_where->{slice};
4621  ***      0                                            $asc_stmt->{scols} = $cmp_where->{scols};
4622                                                     }
4623                                                  
4624  ***      0                                         return $asc_stmt;
4625                                                  }
4626                                                  
4627                                                  sub generate_cmp_where {
4628  ***      0                    0                    my ( $self, %args ) = @_;
4629  ***      0                                         foreach my $arg ( qw(type slice cols is_nullable) ) {
4630  ***      0      0                                     die "I need a $arg arg" unless defined $args{$arg};
4631                                                     }
4632  ***      0                                         my @slice       = @{$args{slice}};
      ***      0                                      
4633  ***      0                                         my @cols        = @{$args{cols}};
      ***      0                                      
4634  ***      0                                         my $is_nullable = $args{is_nullable};
4635  ***      0                                         my $type        = $args{type};
4636  ***      0                                         my $q           = $self->{Quoter};
4637                                                  
4638  ***      0                                         (my $cmp = $type) =~ s/=//;
4639                                                  
4640  ***      0                                         my @r_slice;    # Resulting slice columns, by ordinal
4641  ***      0                                         my @r_scols;    # Ditto, by name
4642                                                  
4643  ***      0                                         my @clauses;
4644  ***      0                                         foreach my $i ( 0 .. $#slice ) {
4645  ***      0                                            my @clause;
4646                                                  
4647  ***      0                                            foreach my $j ( 0 .. $i - 1 ) {
4648  ***      0                                               my $ord = $slice[$j];
4649  ***      0                                               my $col = $cols[$ord];
4650  ***      0                                               my $quo = $q->quote($col);
4651  ***      0      0                                        if ( $is_nullable->{$col} ) {
4652  ***      0                                                  push @clause, "((? IS NULL AND $quo IS NULL) OR ($quo = ?))";
4653  ***      0                                                  push @r_slice, $ord, $ord;
4654  ***      0                                                  push @r_scols, $col, $col;
4655                                                           }
4656                                                           else {
4657  ***      0                                                  push @clause, "$quo = ?";
4658  ***      0                                                  push @r_slice, $ord;
4659  ***      0                                                  push @r_scols, $col;
4660                                                           }
4661                                                        }
4662                                                  
4663  ***      0                                            my $ord = $slice[$i];
4664  ***      0                                            my $col = $cols[$ord];
4665  ***      0                                            my $quo = $q->quote($col);
4666  ***      0                                            my $end = $i == $#slice; # Last clause of the whole group.
4667  ***      0      0                                     if ( $is_nullable->{$col} ) {
4668  ***      0      0      0                                 if ( $type =~ m/=/ && $end ) {
      ***             0                               
4669  ***      0                                                  push @clause, "(? IS NULL OR $quo $type ?)";
4670                                                           }
4671                                                           elsif ( $type =~ m/>/ ) {
4672  ***      0                                                  push @clause, "((? IS NULL AND $quo IS NOT NULL) OR ($quo $cmp ?))";
4673                                                           }
4674                                                           else { # If $type =~ m/</ ) {
4675  ***      0                                                  push @clause, "((? IS NOT NULL AND $quo IS NULL) OR ($quo $cmp ?))";
4676                                                           }
4677  ***      0                                               push @r_slice, $ord, $ord;
4678  ***      0                                               push @r_scols, $col, $col;
4679                                                        }
4680                                                        else {
4681  ***      0                                               push @r_slice, $ord;
4682  ***      0                                               push @r_scols, $col;
4683  ***      0      0      0                                 push @clause, ($type =~ m/=/ && $end ? "$quo $type ?" : "$quo $cmp ?");
4684                                                        }
4685                                                  
4686  ***      0                                            push @clauses, '(' . join(' AND ', @clause) . ')';
4687                                                     }
4688  ***      0                                         my $result = '(' . join(' OR ', @clauses) . ')';
4689  ***      0                                         my $where = {
4690                                                        slice => \@r_slice,
4691                                                        scols => \@r_scols,
4692                                                        where => $result,
4693                                                     };
4694  ***      0                                         return $where;
4695                                                  }
4696                                                  
4697                                                  sub generate_del_stmt {
4698  ***      0                    0                    my ( $self, %args ) = @_;
4699                                                  
4700  ***      0                                         my $tbl  = $args{tbl_struct};
4701  ***      0      0                                  my @cols = $args{cols} ? @{$args{cols}} : ();
      ***      0                                      
4702  ***      0                                         my $tp   = $self->{TableParser};
4703  ***      0                                         my $q    = $self->{Quoter};
4704                                                  
4705  ***      0                                         my @del_cols;
4706  ***      0                                         my @del_slice;
4707                                                  
4708  ***      0                                         my $index = $tp->find_best_index($tbl, $args{index});
4709  ***      0      0                                  die "Cannot find an ascendable index in table" unless $index;
4710                                                  
4711  ***      0      0                                  if ( $index ) {
4712  ***      0                                            @del_cols = @{$tbl->{keys}->{$index}->{cols}};
      ***      0                                      
4713                                                     }
4714                                                     else {
4715  ***      0                                            @del_cols = @{$tbl->{cols}};
      ***      0                                      
4716                                                     }
4717  ***      0                                         MKDEBUG && _d('Columns needed for DELETE:', join(', ', @del_cols));
4718                                                  
4719  ***      0                                         my %col_posn = do { my $i = 0; map { $_ => $i++ } @cols };
      ***      0                                      
      ***      0                                      
      ***      0                                      
4720  ***      0                                         foreach my $col ( @del_cols ) {
4721  ***      0      0                                     if ( !exists $col_posn{$col} ) {
4722  ***      0                                               push @cols, $col;
4723  ***      0                                               $col_posn{$col} = $#cols;
4724                                                        }
4725  ***      0                                            push @del_slice, $col_posn{$col};
4726                                                     }
4727  ***      0                                         MKDEBUG && _d('Ordinals needed for DELETE:', join(', ', @del_slice));
4728                                                  
4729  ***      0                                         my $del_stmt = {
4730                                                        cols  => \@cols,
4731                                                        index => $index,
4732                                                        where => '',
4733                                                        slice => [],
4734                                                        scols => [],
4735                                                     };
4736                                                  
4737  ***      0                                         my @clauses;
4738  ***      0                                         foreach my $i ( 0 .. $#del_slice ) {
4739  ***      0                                            my $ord = $del_slice[$i];
4740  ***      0                                            my $col = $cols[$ord];
4741  ***      0                                            my $quo = $q->quote($col);
4742  ***      0      0                                     if ( $tbl->{is_nullable}->{$col} ) {
4743  ***      0                                               push @clauses, "((? IS NULL AND $quo IS NULL) OR ($quo = ?))";
4744  ***      0                                               push @{$del_stmt->{slice}}, $ord, $ord;
      ***      0                                      
4745  ***      0                                               push @{$del_stmt->{scols}}, $col, $col;
      ***      0                                      
4746                                                        }
4747                                                        else {
4748  ***      0                                               push @clauses, "$quo = ?";
4749  ***      0                                               push @{$del_stmt->{slice}}, $ord;
      ***      0                                      
4750  ***      0                                               push @{$del_stmt->{scols}}, $col;
      ***      0                                      
4751                                                        }
4752                                                     }
4753                                                  
4754  ***      0                                         $del_stmt->{where} = '(' . join(' AND ', @clauses) . ')';
4755                                                  
4756  ***      0                                         return $del_stmt;
4757                                                  }
4758                                                  
4759                                                  sub generate_ins_stmt {
4760  ***      0                    0                    my ( $self, %args ) = @_;
4761  ***      0                                         foreach my $arg ( qw(ins_tbl sel_cols) ) {
4762  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
4763                                                     }
4764  ***      0                                         my $ins_tbl  = $args{ins_tbl};
4765  ***      0                                         my @sel_cols = @{$args{sel_cols}};
      ***      0                                      
4766                                                  
4767  ***      0      0                                  die "You didn't specify any SELECT columns" unless @sel_cols;
4768                                                  
4769  ***      0                                         my @ins_cols;
4770  ***      0                                         my @ins_slice;
4771  ***      0                                         for my $i ( 0..$#sel_cols ) {
4772  ***      0      0                                     next unless $ins_tbl->{is_col}->{$sel_cols[$i]};
4773  ***      0                                            push @ins_cols, $sel_cols[$i];
4774  ***      0                                            push @ins_slice, $i;
4775                                                     }
4776                                                  
4777                                                     return {
4778  ***      0                                            cols  => \@ins_cols,
4779                                                        slice => \@ins_slice,
4780                                                     };
4781                                                  }
4782                                                  
4783                                                  sub _d {
4784  ***      0                    0                    my ($package, undef, $line) = caller 0;
4785  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
4786  ***      0                                              map { defined $_ ? $_ : 'undef' }
4787                                                          @_;
4788  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4789                                                  }
4790                                                  
4791                                                  1;
4792                                                  
4793                                                  # ###########################################################################
4794                                                  # End TableNibbler package
4795                                                  # ###########################################################################
4796                                                  
4797                                                  # ###########################################################################
4798                                                  # TableChecksum package 5266
4799                                                  # ###########################################################################
4800                                                  package TableChecksum;
4801                                                  
4802           5                    5            63   use strict;
               5                                 14   
               5                                 41   
4803           5                    5            46   use warnings FATAL => 'all';
               5                                 14   
               5                                 41   
4804           5                    5            31   use English qw(-no_match_vars);
               5                                 14   
               5                                 37   
4805           5                    5            54   use List::Util qw(max);
               5                                 14   
               5                                 36   
4806                                                  
4807  ***      5            50      5            34   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 12   
               5                                 98   
4808                                                  
4809                                                  our %ALGOS = (
4810                                                     CHECKSUM => { pref => 0, hash => 0 },
4811                                                     BIT_XOR  => { pref => 2, hash => 1 },
4812                                                     ACCUM    => { pref => 3, hash => 1 },
4813                                                  );
4814                                                  
4815                                                  sub new {
4816  ***      0                    0                    my ( $class, %args ) = @_;
4817  ***      0                                         foreach my $arg ( qw(Quoter VersionParser) ) {
4818  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
4819                                                     }
4820  ***      0                                         my $self = { %args };
4821  ***      0                                         return bless $self, $class;
4822                                                  }
4823                                                  
4824                                                  sub crc32 {
4825  ***      0                    0                    my ( $self, $string ) = @_;
4826  ***      0                                         my $poly = 0xEDB88320;
4827  ***      0                                         my $crc  = 0xFFFFFFFF;
4828  ***      0                                         foreach my $char ( split(//, $string) ) {
4829  ***      0                                            my $comp = ($crc ^ ord($char)) & 0xFF;
4830  ***      0                                            for ( 1 .. 8 ) {
4831  ***      0      0                                        $comp = $comp & 1 ? $poly ^ ($comp >> 1) : $comp >> 1;
4832                                                        }
4833  ***      0                                            $crc = (($crc >> 8) & 0x00FFFFFF) ^ $comp;
4834                                                     }
4835  ***      0                                         return $crc ^ 0xFFFFFFFF;
4836                                                  }
4837                                                  
4838                                                  sub get_crc_wid {
4839  ***      0                    0                    my ( $self, $dbh, $func ) = @_;
4840  ***      0                                         my $crc_wid = 16;
4841  ***      0      0      0                           if ( uc $func ne 'FNV_64' && uc $func ne 'FNV1A_64' ) {
4842  ***      0                                            eval {
4843  ***      0                                               my ($val) = $dbh->selectrow_array("SELECT $func('a')");
4844  ***      0                                               $crc_wid = max(16, length($val));
4845                                                        };
4846                                                     }
4847  ***      0                                         return $crc_wid;
4848                                                  }
4849                                                  
4850                                                  sub get_crc_type {
4851  ***      0                    0                    my ( $self, $dbh, $func ) = @_;
4852  ***      0                                         my $type   = '';
4853  ***      0                                         my $length = 0;
4854  ***      0                                         my $sql    = "SELECT $func('a')";
4855  ***      0                                         my $sth    = $dbh->prepare($sql);
4856  ***      0                                         eval {
4857  ***      0                                            $sth->execute();
4858  ***      0                                            $type   = $sth->{mysql_type_name}->[0];
4859  ***      0                                            $length = $sth->{mysql_length}->[0];
4860  ***      0                                            MKDEBUG && _d($sql, $type, $length);
4861  ***      0      0      0                              if ( $type eq 'bigint' && $length < 20 ) {
4862  ***      0                                               $type = 'int';
4863                                                        }
4864                                                     };
4865  ***      0                                         $sth->finish;
4866  ***      0                                         MKDEBUG && _d('crc_type:', $type, 'length:', $length);
4867  ***      0                                         return ($type, $length);
4868                                                  }
4869                                                  
4870                                                  sub best_algorithm {
4871  ***      0                    0                    my ( $self, %args ) = @_;
4872  ***      0                                         my ( $alg, $dbh ) = @args{ qw(algorithm dbh) };
4873  ***      0                                         my $vp = $self->{VersionParser};
4874  ***      0                                         my @choices = sort { $ALGOS{$a}->{pref} <=> $ALGOS{$b}->{pref} } keys %ALGOS;
      ***      0                                      
4875  ***      0      0      0                           die "Invalid checksum algorithm $alg"
4876                                                        if $alg && !$ALGOS{$alg};
4877                                                  
4878  ***      0      0      0                           if (
      ***                    0                        
      ***                    0                        
4879                                                        $args{where} || $args{chunk}        # CHECKSUM does whole table
4880                                                        || $args{replicate}                 # CHECKSUM can't do INSERT.. SELECT
4881                                                        || !$vp->version_ge($dbh, '4.1.1')) # CHECKSUM doesn't exist
4882                                                     {
4883  ***      0                                            MKDEBUG && _d('Cannot use CHECKSUM algorithm');
4884  ***      0                                            @choices = grep { $_ ne 'CHECKSUM' } @choices;
      ***      0                                      
4885                                                     }
4886                                                  
4887  ***      0      0                                  if ( !$vp->version_ge($dbh, '4.1.1') ) {
4888  ***      0                                            MKDEBUG && _d('Cannot use BIT_XOR algorithm because MySQL < 4.1.1');
4889  ***      0                                            @choices = grep { $_ ne 'BIT_XOR' } @choices;
      ***      0                                      
4890                                                     }
4891                                                  
4892  ***      0      0      0                           if ( $alg && grep { $_ eq $alg } @choices ) {
      ***      0                                      
4893  ***      0                                            MKDEBUG && _d('User requested', $alg, 'algorithm');
4894  ***      0                                            return $alg;
4895                                                     }
4896                                                  
4897  ***      0      0      0                           if ( $args{count} && grep { $_ ne 'CHECKSUM' } @choices ) {
      ***      0                                      
4898  ***      0                                            MKDEBUG && _d('Not using CHECKSUM algorithm because COUNT desired');
4899  ***      0                                            @choices = grep { $_ ne 'CHECKSUM' } @choices;
      ***      0                                      
4900                                                     }
4901                                                  
4902  ***      0                                         MKDEBUG && _d('Algorithms, in order:', @choices);
4903  ***      0                                         return $choices[0];
4904                                                  }
4905                                                  
4906                                                  sub is_hash_algorithm {
4907  ***      0                    0                    my ( $self, $algorithm ) = @_;
4908  ***      0             0                           return $ALGOS{$algorithm} && $ALGOS{$algorithm}->{hash};
4909                                                  }
4910                                                  
4911                                                  sub choose_hash_func {
4912  ***      0                    0                    my ( $self, %args ) = @_;
4913  ***      0                                         my @funcs = qw(CRC32 FNV1A_64 FNV_64 MD5 SHA1);
4914  ***      0      0                                  if ( $args{function} ) {
4915  ***      0                                            unshift @funcs, $args{function};
4916                                                     }
4917  ***      0                                         my ($result, $error);
4918  ***      0             0                           do {
4919  ***      0                                            my $func;
4920  ***      0                                            eval {
4921  ***      0                                               $func = shift(@funcs);
4922  ***      0                                               my $sql = "SELECT $func('test-string')";
4923  ***      0                                               MKDEBUG && _d($sql);
4924  ***      0                                               $args{dbh}->do($sql);
4925  ***      0                                               $result = $func;
4926                                                        };
4927  ***      0      0      0                              if ( $EVAL_ERROR && $EVAL_ERROR =~ m/failed: (.*?) at \S+ line/ ) {
4928  ***      0                                               $error .= qq{$func cannot be used because "$1"\n};
4929  ***      0                                               MKDEBUG && _d($func, 'cannot be used because', $1);
4930                                                        }
4931                                                     } while ( @funcs && !$result );
4932                                                  
4933  ***      0      0                                  die $error unless $result;
4934  ***      0                                         MKDEBUG && _d('Chosen hash func:', $result);
4935  ***      0                                         return $result;
4936                                                  }
4937                                                  
4938                                                  sub optimize_xor {
4939  ***      0                    0                    my ( $self, %args ) = @_;
4940  ***      0                                         my ($dbh, $func) = @args{qw(dbh function)};
4941                                                  
4942  ***      0      0                                  die "$func never needs the BIT_XOR optimization"
4943                                                        if $func =~ m/^(?:FNV1A_64|FNV_64|CRC32)$/i;
4944                                                  
4945  ***      0                                         my $opt_slice = 0;
4946  ***      0                                         my $unsliced  = uc $dbh->selectall_arrayref("SELECT $func('a')")->[0]->[0];
4947  ***      0                                         my $sliced    = '';
4948  ***      0                                         my $start     = 1;
4949  ***      0      0                                  my $crc_wid   = length($unsliced) < 16 ? 16 : length($unsliced);
4950                                                  
4951  ***      0             0                           do { # Try different positions till sliced result equals non-sliced.
4952  ***      0                                            MKDEBUG && _d('Trying slice', $opt_slice);
4953  ***      0                                            $dbh->do('SET @crc := "", @cnt := 0');
4954  ***      0                                            my $slices = $self->make_xor_slices(
4955                                                           query     => "\@crc := $func('a')",
4956                                                           crc_wid   => $crc_wid,
4957                                                           opt_slice => $opt_slice,
4958                                                        );
4959                                                  
4960  ***      0                                            my $sql = "SELECT CONCAT($slices) AS TEST FROM (SELECT NULL) AS x";
4961  ***      0                                            $sliced = ($dbh->selectrow_array($sql))[0];
4962  ***      0      0                                     if ( $sliced ne $unsliced ) {
4963  ***      0                                               MKDEBUG && _d('Slice', $opt_slice, 'does not work');
4964  ***      0                                               $start += 16;
4965  ***      0                                               ++$opt_slice;
4966                                                        }
4967                                                     } while ( $start < $crc_wid && $sliced ne $unsliced );
4968                                                  
4969  ***      0      0                                  if ( $sliced eq $unsliced ) {
4970  ***      0                                            MKDEBUG && _d('Slice', $opt_slice, 'works');
4971  ***      0                                            return $opt_slice;
4972                                                     }
4973                                                     else {
4974  ***      0                                            MKDEBUG && _d('No slice works');
4975  ***      0                                            return undef;
4976                                                     }
4977                                                  }
4978                                                  
4979                                                  sub make_xor_slices {
4980  ***      0                    0                    my ( $self, %args ) = @_;
4981  ***      0                                         foreach my $arg ( qw(query crc_wid) ) {
4982  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
4983                                                     }
4984  ***      0                                         my ( $query, $crc_wid, $opt_slice ) = @args{qw(query crc_wid opt_slice)};
4985                                                  
4986  ***      0                                         my @slices;
4987                                                     for ( my $start = 1; $start <= $crc_wid; $start += 16 ) {
4988  ***      0                                            my $len = $crc_wid - $start + 1;
4989  ***      0      0                                     if ( $len > 16 ) {
4990  ***      0                                               $len = 16;
4991                                                        }
4992  ***      0                                            push @slices,
4993                                                           "LPAD(CONV(BIT_XOR("
4994                                                           . "CAST(CONV(SUBSTRING(\@crc, $start, $len), 16, 10) AS UNSIGNED))"
4995                                                           . ", 10, 16), $len, '0')";
4996  ***      0                                         }
4997                                                  
4998  ***      0      0      0                           if ( defined $opt_slice && $opt_slice < @slices ) {
4999  ***      0                                            $slices[$opt_slice] =~ s/\@crc/\@crc := $query/;
5000                                                     }
5001                                                     else {
5002  ***      0                                            map { s/\@crc/$query/ } @slices;
      ***      0                                      
5003                                                     }
5004                                                  
5005  ***      0                                         return join(', ', @slices);
5006                                                  }
5007                                                  
5008                                                  sub make_row_checksum {
5009  ***      0                    0                    my ( $self, %args ) = @_;
5010  ***      0                                         my ( $tbl_struct, $func ) = @args{ qw(tbl_struct function) };
5011  ***      0                                         my $q = $self->{Quoter};
5012                                                  
5013  ***      0             0                           my $sep = $args{sep} || '#';
5014  ***      0                                         $sep =~ s/'//g;
5015  ***      0             0                           $sep ||= '#';
5016                                                  
5017  ***      0                                         my %ignorecols = map { $_ => 1 } @{$args{ignorecols}};
      ***      0                                      
      ***      0                                      
5018                                                  
5019  ***      0                                         my %cols = map { lc($_) => 1 }
      ***      0                                      
5020  ***      0                                                    grep { !exists $ignorecols{$_} }
5021  ***      0      0                                             ($args{cols} ? @{$args{cols}} : @{$tbl_struct->{cols}});
      ***      0                                      
5022  ***      0                                         my @cols =
5023                                                        map {
5024  ***      0                                               my $type = $tbl_struct->{type_for}->{$_};
5025  ***      0                                               my $result = $q->quote($_);
5026  ***      0      0      0                                 if ( $type eq 'timestamp' ) {
      ***             0      0                        
      ***             0                               
5027  ***      0                                                  $result .= ' + 0';
5028                                                           }
5029                                                           elsif ( $type =~ m/float|double/ && $args{float_precision} ) {
5030  ***      0                                                  $result = "ROUND($result, $args{float_precision})";
5031                                                           }
5032                                                           elsif ( $type =~ m/varchar/ && $args{trim} ) {
5033  ***      0                                                  $result = "TRIM($result)";
5034                                                           }
5035  ***      0                                               $result;
5036                                                        }
5037                                                        grep {
5038  ***      0                                               $cols{$_}
5039                                                        }
5040  ***      0                                            @{$tbl_struct->{cols}};
5041                                                  
5042  ***      0                                         my $query;
5043  ***      0      0      0                           if ( uc $func ne 'FNV_64' && uc $func ne 'FNV1A_64' ) {
5044  ***      0                                            my @nulls = grep { $cols{$_} } @{$tbl_struct->{null_cols}};
      ***      0                                      
      ***      0                                      
5045  ***      0      0                                     if ( @nulls ) {
5046  ***      0                                               my $bitmap = "CONCAT("
5047  ***      0                                                  . join(', ', map { 'ISNULL(' . $q->quote($_) . ')' } @nulls)
5048                                                              . ")";
5049  ***      0                                               push @cols, $bitmap;
5050                                                        }
5051                                                  
5052  ***      0      0                                     $query = @cols > 1
5053                                                               ? "$func(CONCAT_WS('$sep', " . join(', ', @cols) . '))'
5054                                                               : "$func($cols[0])";
5055                                                     }
5056                                                     else {
5057  ***      0                                            my $fnv_func = uc $func;
5058  ***      0                                            $query = "$fnv_func(" . join(', ', @cols) . ')';
5059                                                     }
5060                                                  
5061  ***      0                                         return $query;
5062                                                  }
5063                                                  
5064                                                  sub make_checksum_query {
5065  ***      0                    0                    my ( $self, %args ) = @_;
5066  ***      0                                         my @required_args = qw(db tbl tbl_struct algorithm crc_wid crc_type);
5067  ***      0                                         foreach my $arg( @required_args ) {
5068  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
5069                                                     }
5070  ***      0                                         my ( $db, $tbl, $tbl_struct, $algorithm,
5071                                                          $crc_wid, $crc_type) = @args{@required_args};
5072  ***      0                                         my $func = $args{function};
5073  ***      0                                         my $q = $self->{Quoter};
5074  ***      0                                         my $result;
5075                                                  
5076  ***      0      0      0                           die "Invalid or missing checksum algorithm"
5077                                                        unless $algorithm && $ALGOS{$algorithm};
5078                                                  
5079  ***      0      0                                  if ( $algorithm eq 'CHECKSUM' ) {
5080  ***      0                                            return "CHECKSUM TABLE " . $q->quote($db, $tbl);
5081                                                     }
5082                                                  
5083  ***      0                                         my $expr = $self->make_row_checksum(%args);
5084                                                  
5085  ***      0      0                                  if ( $algorithm eq 'BIT_XOR' ) {
5086  ***      0      0                                     if ( $crc_type =~ m/int$/ ) {
5087  ***      0                                               $result = "LOWER(CONV(BIT_XOR(CAST($expr AS UNSIGNED)), 10, 16)) AS crc ";
5088                                                        }
5089                                                        else {
5090  ***      0                                               my $slices = $self->make_xor_slices( query => $expr, %args );
5091  ***      0                                               $result = "LOWER(CONCAT($slices)) AS crc ";
5092                                                        }
5093                                                     }
5094                                                     else {
5095  ***      0      0                                     if ( $crc_type =~ m/int$/ ) {
5096  ***      0                                               $result = "RIGHT(MAX("
5097                                                              . "\@crc := CONCAT(LPAD(\@cnt := \@cnt + 1, 16, '0'), "
5098                                                              . "CONV(CAST($func(CONCAT(\@crc, $expr)) AS UNSIGNED), 10, 16))"
5099                                                              . "), $crc_wid) AS crc ";
5100                                                        }
5101                                                        else {
5102  ***      0                                               $result = "RIGHT(MAX("
5103                                                              . "\@crc := CONCAT(LPAD(\@cnt := \@cnt + 1, 16, '0'), "
5104                                                              . "$func(CONCAT(\@crc, $expr)))"
5105                                                              . "), $crc_wid) AS crc ";
5106                                                        }
5107                                                     }
5108  ***      0      0                                  if ( $args{replicate} ) {
5109  ***      0                                            $result = "REPLACE /*PROGRESS_COMMENT*/ INTO $args{replicate} "
5110                                                           . "(db, tbl, chunk, boundaries, this_cnt, this_crc) "
5111                                                           . "SELECT ?, ?, /*CHUNK_NUM*/ ?, COUNT(*) AS cnt, $result";
5112                                                     }
5113                                                     else {
5114  ***      0      0                                     $result = "SELECT "
5115                                                           . ($args{buffer} ? 'SQL_BUFFER_RESULT ' : '')
5116                                                           . "/*PROGRESS_COMMENT*//*CHUNK_NUM*/ COUNT(*) AS cnt, $result";
5117                                                     }
5118  ***      0                                         return $result . "FROM /*DB_TBL*//*INDEX_HINT*//*WHERE*/";
5119                                                  }
5120                                                  
5121                                                  sub find_replication_differences {
5122  ***      0                    0                    my ( $self, $dbh, $table ) = @_;
5123                                                  
5124  ***      0                                         (my $sql = <<"   EOF") =~ s/\s+/ /gm;
5125                                                        SELECT db, tbl, chunk, boundaries,
5126                                                           COALESCE(this_cnt-master_cnt, 0) AS cnt_diff,
5127                                                           COALESCE(
5128                                                              this_crc <> master_crc OR ISNULL(master_crc) <> ISNULL(this_crc),
5129                                                              0
5130                                                           ) AS crc_diff,
5131                                                           this_cnt, master_cnt, this_crc, master_crc
5132                                                        FROM $table
5133                                                        WHERE master_cnt <> this_cnt OR master_crc <> this_crc
5134                                                        OR ISNULL(master_crc) <> ISNULL(this_crc)
5135                                                     EOF
5136                                                  
5137  ***      0                                         MKDEBUG && _d($sql);
5138  ***      0                                         my $diffs = $dbh->selectall_arrayref($sql, { Slice => {} });
5139  ***      0                                         return @$diffs;
5140                                                  }
5141                                                  
5142                                                  sub _d {
5143  ***      0                    0                    my ($package, undef, $line) = caller 0;
5144  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
5145  ***      0                                              map { defined $_ ? $_ : 'undef' }
5146                                                          @_;
5147  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
5148                                                  }
5149                                                  
5150                                                  1;
5151                                                  
5152                                                  # ###########################################################################
5153                                                  # End TableChecksum package
5154                                                  # ###########################################################################
5155                                                  
5156                                                  # ###########################################################################
5157                                                  # TableSyncer package 5266
5158                                                  # ###########################################################################
5159                                                  package TableSyncer;
5160                                                  
5161           5                    5            63   use strict;
               5                                 14   
               5                                 44   
5162           5                    5            36   use warnings FATAL => 'all';
               5                                 12   
               5                                 42   
5163                                                  
5164           5                    5            32   use English qw(-no_match_vars);
               5                                 15   
               5                                 35   
5165           5                    5            50   use Data::Dumper;
               5                                 11   
               5                                 36   
5166                                                  $Data::Dumper::Indent    = 1;
5167                                                  $Data::Dumper::Sortkeys  = 1;
5168                                                  $Data::Dumper::Quotekeys = 0;
5169                                                  
5170  ***      5            50      5            37   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 15   
               5                                 91   
5171                                                  
5172                                                  sub new {
5173  ***      0                    0                    my ( $class, %args ) = @_;
5174  ***      0                                         my @required_args = qw(MasterSlave Quoter VersionParser TableChecksum);
5175  ***      0                                         foreach my $arg ( @required_args ) {
5176  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
5177                                                     }
5178  ***      0                                         my $self = { %args };
5179  ***      0                                         return bless $self, $class;
5180                                                  }
5181                                                  
5182                                                  sub get_best_plugin {
5183  ***      0                    0                    my ( $self, %args ) = @_;
5184  ***      0                                         foreach my $arg ( qw(plugins tbl_struct) ) {
5185  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
5186                                                     }
5187  ***      0                                         MKDEBUG && _d('Getting best plugin');
5188  ***      0                                         foreach my $plugin ( @{$args{plugins}} ) {
      ***      0                                      
5189  ***      0                                            MKDEBUG && _d('Trying plugin', $plugin->name());
5190  ***      0                                            my ($can_sync, %plugin_args) = $plugin->can_sync(%args);
5191  ***      0      0                                     if ( $can_sync ) {
5192  ***      0                                              MKDEBUG && _d('Can sync with', $plugin->name(), Dumper(\%plugin_args));
5193  ***      0                                              return $plugin, %plugin_args;
5194                                                        }
5195                                                     }
5196  ***      0                                         MKDEBUG && _d('No plugin can sync the table');
5197  ***      0                                         return;
5198                                                  }
5199                                                  
5200                                                  sub sync_table {
5201  ***      0                    0                    my ( $self, %args ) = @_;
5202  ***      0                                         my @required_args = qw(plugins src dst tbl_struct cols chunk_size
5203                                                                            RowDiff ChangeHandler);
5204  ***      0                                         foreach my $arg ( @required_args ) {
5205  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
5206                                                     }
5207  ***      0                                         MKDEBUG && _d('Syncing table with args', Dumper(\%args));
5208  ***      0                                         my ($plugins, $src, $dst, $tbl_struct, $cols, $chunk_size, $rd, $ch)
5209                                                        = @args{@required_args};
5210                                                  
5211  ***      0      0                                  $args{index_hint}    = 1 unless defined $args{index_hint};
5212  ***      0             0                           $args{lock}        ||= 0;
5213  ***      0             0                           $args{wait}        ||= 0;
5214  ***      0             0                           $args{transaction} ||= 0;
5215  ***      0             0                           $args{timeout_ok}  ||= 0;
5216                                                  
5217  ***      0                                         my $q  = $self->{Quoter};
5218  ***      0                                         my $vp = $self->{VersionParser};
5219                                                  
5220  ***      0                                         my ($plugin, %plugin_args) = $self->get_best_plugin(%args);
5221  ***      0      0                                  die "No plugin can sync $src->{db}.$src->{tbl}" unless $plugin;
5222                                                  
5223  ***      0                                         my $crc_col = '__crc';
5224  ***      0                                         while ( $tbl_struct->{is_col}->{$crc_col} ) {
5225  ***      0                                            $crc_col = "_$crc_col"; # Prepend more _ until not a column.
5226                                                     }
5227  ***      0                                         MKDEBUG && _d('CRC column:', $crc_col);
5228                                                  
5229  ***      0                                         my $index_hint;
5230  ***      0      0                                  if ( !$args{replicate} ) {
5231  ***      0      0      0                              my $hint = ($vp->version_ge($src->{dbh}, '4.0.9')
5232                                                                    && $vp->version_ge($dst->{dbh}, '4.0.9') ? 'FORCE' : 'USE')
5233                                                                 . ' INDEX';
5234  ***      0      0      0                              if ( $args{chunk_index} ) {
      ***             0                               
5235  ***      0                                               MKDEBUG && _d('Using given chunk index for index hint');
5236  ***      0                                               $index_hint = "$hint (" . $q->quote($args{chunk_index}) . ")";
5237                                                        }
5238                                                        elsif ( $plugin_args{chunk_index} && $args{index_hint} ) {
5239  ***      0                                               MKDEBUG && _d('Using chunk index chosen by plugin for index hint');
5240  ***      0                                               $index_hint = "$hint (" . $q->quote($plugin_args{chunk_index}) . ")";
5241                                                        }
5242  ***      0                                            MKDEBUG && _d('Index hint:', $index_hint);
5243                                                     }
5244                                                     else {
5245  ***      0                                            MKDEBUG && _d('No index hint for --replicate');
5246                                                     }
5247                                                  
5248  ***      0                                         eval {
5249  ***      0                                            $plugin->prepare_to_sync(
5250                                                           %args,
5251                                                           %plugin_args,
5252                                                           dbh         => $src->{dbh},
5253                                                           db          => $src->{db},
5254                                                           tbl         => $src->{tbl},
5255                                                           crc_col     => $crc_col,
5256                                                           index_hint  => $index_hint,
5257                                                        );
5258                                                     };
5259  ***      0      0                                  if ( $EVAL_ERROR ) {
5260  ***      0                                            die 'Failed to prepare TableSync', $plugin->name(), ' plugin: ',
5261                                                           $EVAL_ERROR;
5262                                                     }
5263                                                  
5264  ***      0      0                                  if ( $plugin->uses_checksum() ) {
5265  ***      0                                            eval {
5266  ***      0                                               my ($chunk_sql, $row_sql) = $self->make_checksum_queries(%args);
5267  ***      0                                               $plugin->set_checksum_queries($chunk_sql, $row_sql);
5268                                                        };
5269  ***      0      0                                     if ( $EVAL_ERROR ) {
5270  ***      0                                               die "Failed to make checksum queries: $EVAL_ERROR";
5271                                                        }
5272                                                     } 
5273                                                  
5274  ***      0      0                                  if ( $args{dry_run} ) {
5275  ***      0                                            return $ch->get_changes(), ALGORITHM => $plugin->name();
5276                                                     }
5277                                                  
5278                                                  
5279  ***      0                                         eval {
5280  ***      0                                            $src->{dbh}->do("USE `$src->{db}`");
5281  ***      0                                            $dst->{dbh}->do("USE `$dst->{db}`");
5282                                                     };
5283  ***      0      0                                  if ( $EVAL_ERROR ) {
5284  ***      0                                            die "Failed to USE database on source or destination: $EVAL_ERROR";
5285                                                     }
5286                                                  
5287  ***      0                                         $self->lock_and_wait(%args, lock_level => 2);  # per-table lock
5288                                                     
5289  ***      0                                         my $callback = $args{callback};
5290  ***      0                                         my $cycle    = 0;
5291  ***      0                                         while ( !$plugin->done() ) {
5292                                                  
5293  ***      0                                            MKDEBUG && _d('Beginning sync cycle', $cycle);
5294  ***      0                                            my $src_sql = $plugin->get_sql(
5295                                                           database   => $src->{db},
5296                                                           table      => $src->{tbl},
5297                                                           where      => $args{where},
5298                                                        );
5299  ***      0                                            my $dst_sql = $plugin->get_sql(
5300                                                           database   => $dst->{db},
5301                                                           table      => $dst->{tbl},
5302                                                           where      => $args{where},
5303                                                        );
5304  ***      0      0                                     if ( $args{transaction} ) {
5305  ***      0      0                                        if ( $args{changing_src} ) {
5306  ***      0                                                  $src_sql .= ' FOR UPDATE';
5307  ***      0                                                  $dst_sql .= ' LOCK IN SHARE MODE';
5308                                                           }
5309                                                           else {
5310  ***      0                                                  $src_sql .= ' LOCK IN SHARE MODE';
5311  ***      0                                                  $dst_sql .= ' FOR UPDATE';
5312                                                           }
5313                                                        }
5314  ***      0                                            $plugin->prepare_sync_cycle($src);
5315  ***      0                                            $plugin->prepare_sync_cycle($dst);
5316  ***      0                                            MKDEBUG && _d('src:', $src_sql);
5317  ***      0                                            MKDEBUG && _d('dst:', $dst_sql);
5318  ***      0      0                                     $callback->($src_sql, $dst_sql) if $callback;
5319  ***      0                                            my $src_sth = $src->{dbh}->prepare($src_sql);
5320  ***      0                                            my $dst_sth = $dst->{dbh}->prepare($dst_sql);
5321  ***      0      0                                     if ( $args{buffer_to_client} ) {
5322  ***      0                                               $src_sth->{mysql_use_result} = 1;
5323  ***      0                                               $dst_sth->{mysql_use_result} = 1;
5324                                                        }
5325                                                  
5326  ***      0                                            my $executed_src = 0;
5327  ***      0      0      0                              if ( !$cycle || !$plugin->pending_changes() ) {
5328  ***      0                                               $executed_src
5329                                                              = $self->lock_and_wait(%args, src_sth => $src_sth, lock_level => 1);
5330                                                        }
5331                                                  
5332  ***      0      0                                     $src_sth->execute() unless $executed_src;
5333  ***      0                                            $dst_sth->execute();
5334                                                  
5335  ***      0                                            $rd->compare_sets(
5336                                                           left   => $src_sth,
5337                                                           right  => $dst_sth,
5338                                                           syncer => $plugin,
5339                                                           tbl    => $tbl_struct,
5340                                                        );
5341  ***      0                                            MKDEBUG && _d('Finished sync cycle', $cycle);
5342  ***      0                                            $ch->process_rows(1);
5343                                                  
5344  ***      0                                            $cycle++;
5345                                                     }
5346                                                  
5347  ***      0                                         $ch->process_rows();
5348                                                  
5349  ***      0                                         $self->unlock(%args, lock_level => 2);
5350                                                  
5351  ***      0                                         return $ch->get_changes(), ALGORITHM => $plugin->name();
5352                                                  }
5353                                                  
5354                                                  sub make_checksum_queries {
5355  ***      0                    0                    my ( $self, %args ) = @_;
5356  ***      0                                         my @required_args = qw(src dst tbl_struct);
5357  ***      0                                         foreach my $arg ( @required_args ) {
5358  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
5359                                                     }
5360  ***      0                                         my ($src, $dst, $tbl_struct) = @args{@required_args};
5361  ***      0                                         my $checksum = $self->{TableChecksum};
5362                                                  
5363  ***      0                                         my $src_algo = $checksum->best_algorithm(
5364                                                        algorithm => 'BIT_XOR',
5365                                                        dbh       => $src->{dbh},
5366                                                        where     => 1,
5367                                                        chunk     => 1,
5368                                                        count     => 1,
5369                                                     );
5370  ***      0                                         my $dst_algo = $checksum->best_algorithm(
5371                                                        algorithm => 'BIT_XOR',
5372                                                        dbh       => $dst->{dbh},
5373                                                        where     => 1,
5374                                                        chunk     => 1,
5375                                                        count     => 1,
5376                                                     );
5377  ***      0      0                                  if ( $src_algo ne $dst_algo ) {
5378  ***      0                                            die "Source and destination checksum algorithms are different: ",
5379                                                           "$src_algo on source, $dst_algo on destination"
5380                                                     }
5381  ***      0                                         MKDEBUG && _d('Chosen algo:', $src_algo);
5382                                                  
5383  ***      0                                         my $src_func = $checksum->choose_hash_func(dbh => $src->{dbh}, %args);
5384  ***      0                                         my $dst_func = $checksum->choose_hash_func(dbh => $dst->{dbh}, %args);
5385  ***      0      0                                  if ( $src_func ne $dst_func ) {
5386  ***      0                                            die "Source and destination hash functions are different: ",
5387                                                        "$src_func on source, $dst_func on destination";
5388                                                     }
5389  ***      0                                         MKDEBUG && _d('Chosen hash func:', $src_func);
5390                                                  
5391                                                  
5392  ***      0                                         my $crc_wid    = $checksum->get_crc_wid($src->{dbh}, $src_func);
5393  ***      0                                         my ($crc_type) = $checksum->get_crc_type($src->{dbh}, $src_func);
5394  ***      0                                         my $opt_slice;
5395  ***      0      0      0                           if ( $src_algo eq 'BIT_XOR' && $crc_type !~ m/int$/ ) {
5396  ***      0                                            $opt_slice = $checksum->optimize_xor(
5397                                                           dbh      => $src->{dbh},
5398                                                           function => $src_func
5399                                                        );
5400                                                     }
5401                                                  
5402  ***      0                                         my $chunk_sql = $checksum->make_checksum_query(
5403                                                        %args,
5404                                                        db        => $src->{db},
5405                                                        tbl       => $src->{tbl},
5406                                                        algorithm => $src_algo,
5407                                                        function  => $src_func,
5408                                                        crc_wid   => $crc_wid,
5409                                                        crc_type  => $crc_type,
5410                                                        opt_slice => $opt_slice,
5411                                                        replicate => undef, # replicate means something different to this sub
5412                                                     );                     # than what we use it for; do not pass it!
5413  ***      0                                         MKDEBUG && _d('Chunk sql:', $chunk_sql);
5414  ***      0                                         my $row_sql = $checksum->make_row_checksum(
5415                                                        %args,
5416                                                        function => $src_func,
5417                                                     );
5418  ***      0                                         MKDEBUG && _d('Row sql:', $row_sql);
5419  ***      0                                         return $chunk_sql, $row_sql;
5420                                                  }
5421                                                  
5422                                                  sub lock_table {
5423  ***      0                    0                    my ( $self, $dbh, $where, $db_tbl, $mode ) = @_;
5424  ***      0                                         my $query = "LOCK TABLES $db_tbl $mode";
5425  ***      0                                         MKDEBUG && _d($query);
5426  ***      0                                         $dbh->do($query);
5427  ***      0                                         MKDEBUG && _d('Acquired table lock on', $where, 'in', $mode, 'mode');
5428                                                  }
5429                                                  
5430                                                  sub unlock {
5431  ***      0                    0                    my ( $self, %args ) = @_;
5432                                                  
5433  ***      0                                         foreach my $arg ( qw(src dst lock transaction lock_level) ) {
5434  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
5435                                                     }
5436  ***      0                                         my $src = $args{src};
5437  ***      0                                         my $dst = $args{dst};
5438                                                  
5439  ***      0      0      0                           return unless $args{lock} && $args{lock} <= $args{lock_level};
5440                                                  
5441  ***      0                                         foreach my $dbh ( $src->{dbh}, $dst->{dbh} ) {
5442  ***      0      0                                     if ( $args{transaction} ) {
5443  ***      0                                               MKDEBUG && _d('Committing', $dbh);
5444  ***      0                                               $dbh->commit();
5445                                                        }
5446                                                        else {
5447  ***      0                                               my $sql = 'UNLOCK TABLES';
5448  ***      0                                               MKDEBUG && _d($dbh, $sql);
5449  ***      0                                               $dbh->do($sql);
5450                                                        }
5451                                                     }
5452                                                  
5453  ***      0                                         return;
5454                                                  }
5455                                                  
5456                                                  sub lock_and_wait {
5457  ***      0                    0                    my ( $self, %args ) = @_;
5458  ***      0                                         my $result = 0;
5459                                                  
5460  ***      0                                         foreach my $arg ( qw(src dst lock lock_level) ) {
5461  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
5462                                                     }
5463  ***      0                                         my $src = $args{src};
5464  ***      0                                         my $dst = $args{dst};
5465                                                  
5466  ***      0      0      0                           return unless $args{lock} && $args{lock} == $args{lock_level};
5467                                                  
5468  ***      0                                         foreach my $dbh ( $src->{dbh}, $dst->{dbh} ) {
5469  ***      0      0                                     if ( $args{transaction} ) {
5470  ***      0                                               MKDEBUG && _d('Committing', $dbh);
5471  ***      0                                               $dbh->commit();
5472                                                        }
5473                                                        else {
5474  ***      0                                               my $sql = 'UNLOCK TABLES';
5475  ***      0                                               MKDEBUG && _d($dbh, $sql);
5476  ***      0                                               $dbh->do($sql);
5477                                                        }
5478                                                     }
5479                                                  
5480  ***      0      0                                  if ( $args{lock} == 3 ) {
5481  ***      0                                            my $sql = 'FLUSH TABLES WITH READ LOCK';
5482  ***      0                                            MKDEBUG && _d($src->{dbh}, ',', $sql);
5483  ***      0                                            $src->{dbh}->do($sql);
5484                                                     }
5485                                                     else {
5486  ***      0      0                                     if ( $args{transaction} ) {
5487  ***      0      0                                        if ( $args{src_sth} ) {
5488  ***      0                                                  MKDEBUG && _d('Executing statement on source to lock rows');
5489  ***      0                                                  $args{src_sth}->execute();
5490  ***      0                                                  $result = 1;
5491                                                           }
5492                                                        }
5493                                                        else {
5494  ***      0      0                                        $self->lock_table($src->{dbh}, 'source',
5495                                                              $self->{Quoter}->quote($src->{db}, $src->{tbl}),
5496                                                              $args{changing_src} ? 'WRITE' : 'READ');
5497                                                        }
5498                                                     }
5499                                                  
5500  ***      0                                         eval {
5501  ***      0      0                                     if ( $args{wait} ) {
5502  ***      0                                               $self->{MasterSlave}->wait_for_master(
5503                                                              $src->{misc_dbh}, $dst->{dbh}, $args{wait}, $args{timeout_ok});
5504                                                        }
5505                                                  
5506  ***      0      0                                     if ( $args{changing_src} ) {
5507  ***      0                                               MKDEBUG && _d('Not locking destination because changing source ',
5508                                                              '(syncing via replication or sync-to-master)');
5509                                                        }
5510                                                        else {
5511  ***      0      0                                        if ( $args{lock} == 3 ) {
      ***             0                               
5512  ***      0                                                  my $sql = 'FLUSH TABLES WITH READ LOCK';
5513  ***      0                                                  MKDEBUG && _d($dst->{dbh}, ',', $sql);
5514  ***      0                                                  $dst->{dbh}->do($sql);
5515                                                           }
5516                                                           elsif ( !$args{transaction} ) {
5517  ***      0      0                                           $self->lock_table($dst->{dbh}, 'dest',
5518                                                                 $self->{Quoter}->quote($dst->{db}, $dst->{tbl}),
5519                                                                 $args{execute} ? 'WRITE' : 'READ');
5520                                                           }
5521                                                        }
5522                                                     };
5523                                                  
5524  ***      0      0                                  if ( $EVAL_ERROR ) {
5525  ***      0      0                                     if ( $args{src_sth}->{Active} ) {
5526  ***      0                                               $args{src_sth}->finish();
5527                                                        }
5528  ***      0                                            foreach my $dbh ( $src->{dbh}, $dst->{dbh}, $src->{misc_dbh} ) {
5529  ***      0      0                                        next unless $dbh;
5530  ***      0                                               MKDEBUG && _d('Caught error, unlocking/committing on', $dbh);
5531  ***      0                                               $dbh->do('UNLOCK TABLES');
5532  ***      0      0                                        $dbh->commit() unless $dbh->{AutoCommit};
5533                                                        }
5534  ***      0                                            die $EVAL_ERROR;
5535                                                     }
5536                                                  
5537  ***      0                                         return $result;
5538                                                  }
5539                                                  
5540                                                  sub have_all_privs {
5541  ***      0                    0                    my ( $self, $dbh, $db, $tbl ) = @_;
5542  ***      0                                         my $db_tbl = $self->{Quoter}->quote($db, $tbl);
5543  ***      0                                         my $sql    = "SHOW FULL COLUMNS FROM $db_tbl";
5544  ***      0                                         MKDEBUG && _d('Permissions check:', $sql);
5545  ***      0                                         my $cols       = $dbh->selectall_arrayref($sql, {Slice => {}});
5546  ***      0                                         my ($hdr_name) = grep { m/privileges/i } keys %{$cols->[0]};
      ***      0                                      
      ***      0                                      
5547  ***      0                                         my $privs      = $cols->[0]->{$hdr_name};
5548  ***      0                                         $sql = "DELETE FROM $db_tbl LIMIT 0"; # FULL COLUMNS doesn't show all privs
5549  ***      0                                         MKDEBUG && _d('Permissions check:', $sql);
5550  ***      0                                         eval { $dbh->do($sql); };
      ***      0                                      
5551  ***      0      0                                  my $can_delete = $EVAL_ERROR ? 0 : 1;
5552                                                  
5553  ***      0                                         MKDEBUG && _d('User privs on', $db_tbl, ':', $privs,
5554                                                        ($can_delete ? 'delete' : ''));
5555  ***      0      0      0                           if ( $privs =~ m/select/ && $privs =~ m/insert/ && $privs =~ m/update/ 
      ***                    0                        
      ***                    0                        
5556                                                          && $can_delete ) {
5557  ***      0                                            MKDEBUG && _d('User has all privs');
5558  ***      0                                            return 1;
5559                                                     }
5560  ***      0                                         MKDEBUG && _d('User does not have all privs');
5561  ***      0                                         return 0;
5562                                                  }
5563                                                  
5564                                                  sub _d {
5565  ***      0                    0                    my ($package, undef, $line) = caller 0;
5566  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
5567  ***      0                                              map { defined $_ ? $_ : 'undef' }
5568                                                          @_;
5569  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
5570                                                  }
5571                                                  
5572                                                  1;
5573                                                  
5574                                                  # ###########################################################################
5575                                                  # End TableSyncer package
5576                                                  # ###########################################################################
5577                                                  
5578                                                  # ###########################################################################
5579                                                  # TableSyncChunk package 5266
5580                                                  # ###########################################################################
5581                                                  package TableSyncChunk;
5582                                                  
5583           5                    5            64   use strict;
               5                                 13   
               5                                 45   
5584           5                    5            35   use warnings FATAL => 'all';
               5                                 13   
               5                                 46   
5585                                                  
5586           5                    5            31   use English qw(-no_match_vars);
               5                                 44   
               5                                 36   
5587           5                    5            54   use List::Util qw(max);
               5                                 13   
               5                                 38   
5588           5                    5            52   use Data::Dumper;
               5                                 22   
               5                                 42   
5589                                                  $Data::Dumper::Indent    = 1;
5590                                                  $Data::Dumper::Sortkeys  = 1;
5591                                                  $Data::Dumper::Quotekeys = 0;
5592                                                  
5593  ***      5            50      5            39   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 19   
               5                                 94   
5594                                                  
5595                                                  sub new {
5596  ***      0                    0                    my ( $class, %args ) = @_;
5597  ***      0                                         foreach my $arg ( qw(TableChunker Quoter) ) {
5598  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
5599                                                     }
5600  ***      0                                         my $self = { %args };
5601  ***      0                                         return bless $self, $class;
5602                                                  }
5603                                                  
5604                                                  sub name {
5605  ***      0                    0                    return 'Chunk';
5606                                                  }
5607                                                  
5608                                                  sub can_sync {
5609  ***      0                    0                    my ( $self, %args ) = @_;
5610  ***      0                                         foreach my $arg ( qw(tbl_struct) ) {
5611  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
5612                                                     }
5613                                                  
5614  ***      0                                         my ($exact, @chunkable_cols) = $self->{TableChunker}->find_chunk_columns(
5615                                                        %args,
5616                                                        exact => 1,
5617                                                     );
5618  ***      0      0                                  return unless $exact;
5619                                                  
5620  ***      0                                         my $colno;
5621  ***      0      0      0                           if ( $args{chunk_col} || $args{chunk_index} ) {
5622  ***      0                                            MKDEBUG && _d('Checking requested col', $args{chunk_col},
5623                                                           'and/or index', $args{chunk_index});
5624  ***      0                                            for my $i ( 0..$#chunkable_cols ) {
5625  ***      0      0                                        if ( $args{chunk_col} ) {
5626  ***      0      0                                           next unless $chunkable_cols[$i]->{column} eq $args{chunk_col};
5627                                                           }
5628  ***      0      0                                        if ( $args{chunk_index} ) {
5629  ***      0      0                                           next unless $chunkable_cols[$i]->{index} eq $args{chunk_index};
5630                                                           }
5631  ***      0                                               $colno = $i;
5632  ***      0                                               last;
5633                                                        }
5634                                                  
5635  ***      0      0                                     if ( !$colno ) {
5636  ***      0                                               MKDEBUG && _d('Cannot chunk on column', $args{chunk_col},
5637                                                              'and/or using index', $args{chunk_index});
5638  ***      0                                               return;
5639                                                        }
5640                                                     }
5641                                                     else {
5642  ***      0                                            $colno = 0;  # First, best chunkable column/index.
5643                                                     }
5644                                                  
5645  ***      0                                         MKDEBUG && _d('Can chunk on column', $chunkable_cols[$colno]->{column},
5646                                                        'using index', $chunkable_cols[$colno]->{index});
5647                                                     return (
5648  ***      0                                            1,
5649                                                        chunk_col   => $chunkable_cols[$colno]->{column},
5650                                                        chunk_index => $chunkable_cols[$colno]->{index},
5651                                                     ),
5652                                                  }
5653                                                  
5654                                                  sub prepare_to_sync {
5655  ***      0                    0                    my ( $self, %args ) = @_;
5656  ***      0                                         my @required_args = qw(dbh db tbl tbl_struct cols chunk_col
5657                                                                            chunk_size crc_col ChangeHandler);
5658  ***      0                                         foreach my $arg ( @required_args ) {
5659  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
5660                                                     }
5661  ***      0                                         my $chunker  = $self->{TableChunker};
5662                                                  
5663  ***      0                                         $self->{chunk_col}       = $args{chunk_col};
5664  ***      0                                         $self->{crc_col}         = $args{crc_col};
5665  ***      0                                         $self->{index_hint}      = $args{index_hint};
5666  ***      0                                         $self->{buffer_in_mysql} = $args{buffer_in_mysql};
5667  ***      0                                         $self->{ChangeHandler}   = $args{ChangeHandler};
5668                                                  
5669  ***      0                                         $self->{ChangeHandler}->fetch_back($args{dbh});
5670                                                  
5671  ***      0                                         my @chunks;
5672  ***      0      0                                  if ( !$args{replicate} ) {
5673  ***      0                                            my %range_params = $chunker->get_range_statistics(%args);
5674  ***      0      0                                     if ( !grep { !defined $range_params{$_} } qw(min max rows_in_range) ) {
      ***      0                                      
5675  ***      0                                               $args{chunk_size} = $chunker->size_to_rows(%args);
5676  ***      0                                               @chunks = $chunker->calculate_chunks(%args, %range_params);
5677                                                        }
5678                                                        else {
5679  ***      0                                               MKDEBUG && _d('No range statistics; using single chunk 1=1');
5680  ***      0                                               @chunks = '1=1';
5681                                                        }
5682                                                     }
5683                                                     else {
5684  ***      0                                            MKDEBUG && _d('Using --replicate boundary instead of chunks');
5685  ***      0                                            @chunks = '1=1';
5686                                                     }
5687                                                  
5688  ***      0                                         $self->{chunks}    = \@chunks;
5689  ***      0                                         $self->{chunk_num} = 0;
5690  ***      0                                         $self->{state}     = 0;
5691                                                  
5692  ***      0                                         return;
5693                                                  }
5694                                                  
5695                                                  sub uses_checksum {
5696  ***      0                    0                    return 1;
5697                                                  }
5698                                                  
5699                                                  sub set_checksum_queries {
5700  ***      0                    0                    my ( $self, $chunk_sql, $row_sql ) = @_;
5701  ***      0      0                                  die "I need a chunk_sql argument" unless $chunk_sql;
5702  ***      0      0                                  die "I need a row_sql argument" unless $row_sql;
5703  ***      0                                         $self->{chunk_sql} = $chunk_sql;
5704  ***      0                                         $self->{row_sql} = $row_sql;
5705  ***      0                                         return;
5706                                                  }
5707                                                  
5708                                                  sub prepare_sync_cycle {
5709  ***      0                    0                    my ( $self, $host ) = @_;
5710  ***      0                                         my $sql = 'SET @crc := "", @cnt := 0';
5711  ***      0                                         MKDEBUG && _d($sql);
5712  ***      0                                         $host->{dbh}->do($sql);
5713  ***      0                                         return;
5714                                                  }
5715                                                  
5716                                                  sub get_sql {
5717  ***      0                    0                    my ( $self, %args ) = @_;
5718  ***      0      0                                  if ( $self->{state} ) {  # checksum a chunk of rows
5719  ***      0                                            my $q = $self->{Quoter};
5720  ***      0                                            return 'SELECT /*rows in chunk*/ '
5721                                                           . ($self->{buffer_in_mysql} ? 'SQL_BUFFER_RESULT ' : '')
5722  ***      0                                               . join(', ', map { $q->quote($_) } @{$self->key_cols()})
      ***      0                                      
5723                                                           . ', ' . $self->{row_sql} . " AS $self->{crc_col}"
5724                                                           . ' FROM ' . $self->{Quoter}->quote(@args{qw(database table)})
5725                                                           . ' '. ($self->{index_hint} || '')
5726                                                           . ' WHERE (' . $self->{chunks}->[$self->{chunk_num}] . ')'
5727                                                           . ($args{where} ? " AND ($args{where})" : '')
5728  ***      0      0      0                                 . ' ORDER BY ' . join(', ', map {$q->quote($_) } @{$self->key_cols()});
      ***      0      0                               
5729                                                     }
5730                                                     else {  # checksum the rows
5731  ***      0                                            return $self->{TableChunker}->inject_chunks(
5732                                                           database   => $args{database},
5733                                                           table      => $args{table},
5734                                                           chunks     => $self->{chunks},
5735                                                           chunk_num  => $self->{chunk_num},
5736                                                           query      => $self->{chunk_sql},
5737                                                           index_hint => $self->{index_hint},
5738                                                           where      => [ $args{where} ],
5739                                                        );
5740                                                     }
5741                                                  }
5742                                                  
5743                                                  sub same_row {
5744  ***      0                    0                    my ( $self, $lr, $rr ) = @_;
5745  ***      0      0      0                           if ( $self->{state} ) {  # checksumming rows
      ***             0                               
5746  ***      0      0                                     if ( $lr->{$self->{crc_col}} ne $rr->{$self->{crc_col}} ) {
5747  ***      0                                               $self->{ChangeHandler}->change('UPDATE', $lr, $self->key_cols());
5748                                                        }
5749                                                     }
5750                                                     elsif ( $lr->{cnt} != $rr->{cnt} || $lr->{crc} ne $rr->{crc} ) {
5751  ***      0                                            MKDEBUG && _d('Rows:', Dumper($lr, $rr));
5752  ***      0                                            MKDEBUG && _d('Will examine this chunk before moving to next');
5753  ***      0                                            $self->{state} = 1; # Must examine this chunk row-by-row
5754                                                     }
5755                                                  }
5756                                                  
5757                                                  sub not_in_right {
5758  ***      0                    0                    my ( $self, $lr ) = @_;
5759  ***      0      0                                  die "Called not_in_right in state 0" unless $self->{state};
5760  ***      0                                         $self->{ChangeHandler}->change('INSERT', $lr, $self->key_cols());
5761  ***      0                                         return;
5762                                                  }
5763                                                  
5764                                                  sub not_in_left {
5765  ***      0                    0                    my ( $self, $rr ) = @_;
5766  ***      0      0                                  die "Called not_in_left in state 0" unless $self->{state};
5767  ***      0                                         $self->{ChangeHandler}->change('DELETE', $rr, $self->key_cols());
5768  ***      0                                         return;
5769                                                  }
5770                                                  
5771                                                  sub done_with_rows {
5772  ***      0                    0                    my ( $self ) = @_;
5773  ***      0      0                                  if ( $self->{state} == 1 ) {
5774  ***      0                                            $self->{state} = 2;
5775  ***      0                                            MKDEBUG && _d('Setting state =', $self->{state});
5776                                                     }
5777                                                     else {
5778  ***      0                                            $self->{state} = 0;
5779  ***      0                                            $self->{chunk_num}++;
5780  ***      0                                            MKDEBUG && _d('Setting state =', $self->{state},
5781                                                           'chunk_num =', $self->{chunk_num});
5782                                                     }
5783  ***      0                                         return;
5784                                                  }
5785                                                  
5786                                                  sub done {
5787  ***      0                    0                    my ( $self ) = @_;
5788                                                     MKDEBUG && _d('Done with', $self->{chunk_num}, 'of',
5789  ***      0                                            scalar(@{$self->{chunks}}), 'chunks');
5790  ***      0                                         MKDEBUG && $self->{state} && _d('Chunk differs; must examine rows');
5791  ***      0                                         return $self->{state} == 0
5792  ***      0             0                              && $self->{chunk_num} >= scalar(@{$self->{chunks}})
5793                                                  }
5794                                                  
5795                                                  sub pending_changes {
5796  ***      0                    0                    my ( $self ) = @_;
5797  ***      0      0                                  if ( $self->{state} ) {
5798  ***      0                                            MKDEBUG && _d('There are pending changes');
5799  ***      0                                            return 1;
5800                                                     }
5801                                                     else {
5802  ***      0                                            MKDEBUG && _d('No pending changes');
5803  ***      0                                            return 0;
5804                                                     }
5805                                                  }
5806                                                  
5807                                                  sub key_cols {
5808  ***      0                    0                    my ( $self ) = @_;
5809  ***      0                                         my @cols;
5810  ***      0      0                                  if ( $self->{state} == 0 ) {
5811  ***      0                                            @cols = qw(chunk_num);
5812                                                     }
5813                                                     else {
5814  ***      0                                            @cols = $self->{chunk_col};
5815                                                     }
5816  ***      0                                         MKDEBUG && _d('State', $self->{state},',', 'key cols', join(', ', @cols));
5817  ***      0                                         return \@cols;
5818                                                  }
5819                                                  
5820                                                  sub _d {
5821  ***      0                    0                    my ($package, undef, $line) = caller 0;
5822  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
5823  ***      0                                              map { defined $_ ? $_ : 'undef' }
5824                                                          @_;
5825  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
5826                                                  }
5827                                                  
5828                                                  1;
5829                                                  
5830                                                  # ###########################################################################
5831                                                  # End TableSyncChunk package
5832                                                  # ###########################################################################
5833                                                  
5834                                                  # ###########################################################################
5835                                                  # TableSyncNibble package 5477
5836                                                  # ###########################################################################
5837                                                  package TableSyncNibble;
5838                                                  
5839           5                    5            62   use strict;
               5                                 16   
               5                                 46   
5840           5                    5            33   use warnings FATAL => 'all';
               5                                 17   
               5                                 37   
5841                                                  
5842           5                    5            31   use English qw(-no_match_vars);
               5                                 12   
               5                                 41   
5843           5                    5            52   use List::Util qw(max);
               5                                 15   
               5                                 38   
5844           5                    5            34   use Data::Dumper;
               5                                 10   
               5                                 33   
5845                                                  $Data::Dumper::Indent    = 1;
5846                                                  $Data::Dumper::Sortkeys  = 1;
5847                                                  $Data::Dumper::Quotekeys = 0;
5848                                                  
5849  ***      5            50      5            33   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 13   
               5                                 91   
5850                                                  
5851                                                  sub new {
5852  ***      0                    0                    my ( $class, %args ) = @_;
5853  ***      0                                         foreach my $arg ( qw(TableNibbler TableChunker TableParser Quoter) ) {
5854  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
5855                                                     }
5856  ***      0                                         my $self = { %args };
5857  ***      0                                         return bless $self, $class;
5858                                                  }
5859                                                  
5860                                                  sub name {
5861  ***      0                    0                    return 'Nibble';
5862                                                  }
5863                                                  
5864                                                  sub can_sync {
5865  ***      0                    0                    my ( $self, %args ) = @_;
5866  ***      0                                         foreach my $arg ( qw(tbl_struct) ) {
5867  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
5868                                                     }
5869                                                  
5870  ***      0                                         my $nibble_index = $self->{TableParser}->find_best_index($args{tbl_struct});
5871  ***      0      0                                  if ( $nibble_index ) {
5872  ***      0                                            MKDEBUG && _d('Best nibble index:', Dumper($nibble_index));
5873  ***      0      0                                     if ( !$args{tbl_struct}->{keys}->{$nibble_index}->{is_unique} ) {
5874  ***      0                                               MKDEBUG && _d('Best nibble index is not unique');
5875  ***      0                                               return;
5876                                                        }
5877  ***      0      0      0                              if ( $args{chunk_index} && $args{chunk_index} ne $nibble_index ) {
5878  ***      0                                               MKDEBUG && _d('Best nibble index is not requested index',
5879                                                              $args{chunk_index});
5880  ***      0                                               return;
5881                                                        }
5882                                                     }
5883                                                     else {
5884  ***      0                                            MKDEBUG && _d('No best nibble index returned');
5885  ***      0                                            return;
5886                                                     }
5887                                                  
5888  ***      0                                         my $small_table = 0;
5889  ***      0      0      0                           if ( $args{src} && $args{src}->{dbh} ) {
5890  ***      0                                            my $dbh = $args{src}->{dbh};
5891  ***      0                                            my $db  = $args{src}->{db};
5892  ***      0                                            my $tbl = $args{src}->{tbl};
5893  ***      0                                            my $table_status;
5894  ***      0                                            eval {
5895  ***      0                                               my $sql = "SHOW TABLE STATUS FROM `$db` LIKE "
5896                                                                   . $self->{Quoter}->literal_like($tbl);
5897  ***      0                                               MKDEBUG && _d($sql);
5898  ***      0                                               $table_status = $dbh->selectrow_hashref($sql);
5899                                                        };
5900  ***      0                                            MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
5901  ***      0      0                                     if ( $table_status ) {
5902  ***      0      0                                        my $n_rows   = defined $table_status->{Rows} ? $table_status->{Rows}
      ***             0                               
5903                                                                        : defined $table_status->{rows} ? $table_status->{rows}
5904                                                                        : undef;
5905  ***      0      0      0                                 $small_table = 1 if defined $n_rows && $n_rows <= 100;
5906                                                        }
5907                                                     }
5908  ***      0                                         MKDEBUG && _d('Small table:', $small_table);
5909                                                  
5910  ***      0                                         MKDEBUG && _d('Can nibble using index', $nibble_index);
5911                                                     return (
5912  ***      0                                            1,
5913                                                        chunk_index => $nibble_index,
5914                                                        key_cols    => $args{tbl_struct}->{keys}->{$nibble_index}->{cols},
5915                                                        small_table => $small_table,
5916                                                     );
5917                                                  }
5918                                                  
5919                                                  sub prepare_to_sync {
5920  ***      0                    0                    my ( $self, %args ) = @_;
5921  ***      0                                         my @required_args = qw(dbh db tbl tbl_struct chunk_index key_cols chunk_size
5922                                                                            crc_col ChangeHandler);
5923  ***      0                                         foreach my $arg ( @required_args ) {
5924  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
5925                                                     }
5926                                                  
5927  ***      0                                         $self->{dbh}             = $args{dbh};
5928  ***      0                                         $self->{tbl_struct}      = $args{tbl_struct};
5929  ***      0                                         $self->{crc_col}         = $args{crc_col};
5930  ***      0                                         $self->{index_hint}      = $args{index_hint};
5931  ***      0                                         $self->{key_cols}        = $args{key_cols};
5932  ***      0                                         $self->{chunk_size}      = $self->{TableChunker}->size_to_rows(%args);
5933  ***      0                                         $self->{buffer_in_mysql} = $args{buffer_in_mysql};
5934  ***      0                                         $self->{small_table}     = $args{small_table};
5935  ***      0                                         $self->{ChangeHandler}   = $args{ChangeHandler};
5936                                                  
5937  ***      0                                         $self->{ChangeHandler}->fetch_back($args{dbh});
5938                                                  
5939  ***      0      0                                  if ( !$args{replicate} ) {
5940  ***      0                                            $self->{sel_stmt} = $self->{TableNibbler}->generate_asc_stmt(
5941                                                           %args,
5942                                                           index    => $args{chunk_index}, # expects an index arg, not chunk_index
5943                                                           asc_only => 1,
5944                                                        );
5945                                                     }
5946                                                     else {
5947  ***      0                                            MKDEBUG && _d('Using --replicate boundary instead of nibble boundaries');
5948  ***      0                                            $self->{sel_stmt} = undef;
5949                                                     }
5950                                                  
5951  ***      0                                         $self->{nibble}            = 0;
5952  ***      0                                         $self->{cached_row}        = undef;
5953  ***      0                                         $self->{cached_nibble}     = undef;
5954  ***      0                                         $self->{cached_boundaries} = undef;
5955  ***      0                                         $self->{state}             = 0;
5956                                                  
5957  ***      0                                         return;
5958                                                  }
5959                                                  
5960                                                  sub uses_checksum {
5961  ***      0                    0                    return 1;
5962                                                  }
5963                                                  
5964                                                  sub set_checksum_queries {
5965  ***      0                    0                    my ( $self, $nibble_sql, $row_sql ) = @_;
5966  ***      0      0                                  die "I need a nibble_sql argument" unless $nibble_sql;
5967  ***      0      0                                  die "I need a row_sql argument" unless $row_sql;
5968  ***      0                                         $self->{nibble_sql} = $nibble_sql;
5969  ***      0                                         $self->{row_sql} = $row_sql;
5970  ***      0                                         return;
5971                                                  }
5972                                                  
5973                                                  sub prepare_sync_cycle {
5974  ***      0                    0                    my ( $self, $host ) = @_;
5975  ***      0                                         my $sql = 'SET @crc := "", @cnt := 0';
5976  ***      0                                         MKDEBUG && _d($sql);
5977  ***      0                                         $host->{dbh}->do($sql);
5978  ***      0                                         return;
5979                                                  }
5980                                                  
5981                                                  sub get_sql {
5982  ***      0                    0                    my ( $self, %args ) = @_;
5983  ***      0      0                                  if ( $self->{state} ) {
5984  ***      0                                            my $q = $self->{Quoter};
5985  ***      0                                            return 'SELECT /*rows in nibble*/ '
5986                                                           . ($self->{buffer_in_mysql} ? 'SQL_BUFFER_RESULT ' : '')
5987  ***      0                                               . join(', ', map { $q->quote($_) } @{$self->key_cols()})
      ***      0                                      
5988                                                           . ', ' . $self->{row_sql} . " AS $self->{crc_col}"
5989                                                           . ' FROM ' . $q->quote(@args{qw(database table)})
5990                                                           . ' ' . ($self->{index_hint} ? $self->{index_hint} : '')
5991                                                           . ' WHERE (' . $self->__get_boundaries(%args) . ')'
5992                                                           . ($args{where} ? " AND ($args{where})" : '')
5993  ***      0      0                                        . ' ORDER BY ' . join(', ', map {$q->quote($_) } @{$self->key_cols()});
      ***      0      0                               
      ***             0                               
5994                                                     }
5995                                                     else {
5996  ***      0                                            my $where = $self->__get_boundaries(%args);
5997  ***      0                                            return $self->{TableChunker}->inject_chunks(
5998                                                           database   => $args{database},
5999                                                           table      => $args{table},
6000                                                           chunks     => [ $where ],
6001                                                           chunk_num  => 0,
6002                                                           query      => $self->{nibble_sql},
6003                                                           index_hint => $self->{index_hint},
6004                                                           where      => [ $args{where} ],
6005                                                        );
6006                                                     }
6007                                                  }
6008                                                  
6009                                                  sub __get_boundaries {
6010  ***      0                    0                    my ( $self, %args ) = @_;
6011  ***      0                                         my $q = $self->{Quoter};
6012  ***      0                                         my $s = $self->{sel_stmt};
6013                                                  
6014  ***      0      0                                  if ( !$s ) {
6015  ***      0                                            MKDEBUG && _d('No sel_stmt so WHERE clause 1=1 (for --replicate)');
6016  ***      0                                            return '1=1';
6017                                                     }
6018                                                  
6019  ***      0                                         my $lb;   # Lower boundary part of WHERE
6020  ***      0                                         my $ub;   # Upper boundary part of WHERE
6021  ***      0                                         my $row;  # Next upper boundary row or cached_row
6022                                                  
6023  ***      0      0                                  if ( $self->{cached_boundaries} ) {
6024  ***      0                                            MKDEBUG && _d('Using cached boundaries');
6025  ***      0                                            return $self->{cached_boundaries};
6026                                                     }
6027                                                  
6028  ***      0      0      0                           if ( $self->{cached_row} && $self->{cached_nibble} == $self->{nibble} ) {
6029  ***      0                                            MKDEBUG && _d('Using cached row for boundaries');
6030  ***      0                                            $row = $self->{cached_row};
6031                                                     }
6032                                                     else {
6033  ***      0                                            MKDEBUG && _d('Getting next upper boundary row');
6034  ***      0                                            my $sql;
6035  ***      0                                            ($sql, $lb) = $self->__make_boundary_sql(%args);  # $lb from outer scope!
6036                                                  
6037  ***      0      0      0                              if ( $self->{nibble} == 0 && !$self->{small_table} ) {
6038  ***      0                                               my $explain_index = $self->__get_explain_index($sql);
6039  ***      0      0      0                                 if ( lc($explain_index || '') ne lc($s->{index}) ) {
6040  ***      0      0                                           die 'Cannot nibble table '.$q->quote($args{database}, $args{table})
6041                                                                 . " because MySQL chose "
6042                                                                 . ($explain_index ? "the `$explain_index`" : 'no') . ' index'
6043                                                                 . " instead of the `$s->{index}` index";
6044                                                           }
6045                                                        }
6046                                                  
6047  ***      0                                            $row = $self->{dbh}->selectrow_hashref($sql);
6048  ***      0                                            MKDEBUG && _d($row ? 'Got a row' : "Didn't get a row");
6049                                                     }
6050                                                  
6051  ***      0      0                                  if ( $row ) {
6052  ***      0                                            my $i = 0;
6053  ***      0                                            $ub   = $s->{boundaries}->{'<='};
6054  ***      0             0                              $ub   =~ s/\?/$q->quote_val($row->{$s->{scols}->[$i]}, $self->{tbl_struct}->{is_numeric}->{$s->{scols}->[$i++]} || 0)/eg;
      ***      0                                      
6055                                                     }
6056                                                     else {
6057  ***      0                                            MKDEBUG && _d('No upper boundary');
6058  ***      0                                            $ub = '1=1';
6059                                                     }
6060                                                  
6061  ***      0      0                                  my $where = $lb ? "($lb AND $ub)" : $ub;
6062                                                  
6063  ***      0                                         $self->{cached_row}        = $row;
6064  ***      0                                         $self->{cached_nibble}     = $self->{nibble};
6065  ***      0                                         $self->{cached_boundaries} = $where;
6066                                                  
6067  ***      0                                         MKDEBUG && _d('WHERE clause:', $where);
6068  ***      0                                         return $where;
6069                                                  }
6070                                                  
6071                                                  sub __make_boundary_sql {
6072  ***      0                    0                    my ( $self, %args ) = @_;
6073  ***      0                                         my $lb;
6074  ***      0                                         my $q   = $self->{Quoter};
6075  ***      0                                         my $s   = $self->{sel_stmt};
6076  ***      0                                         my $sql = "SELECT /*nibble boundary $self->{nibble}*/ "
6077  ***      0             0                              . join(',', map { $q->quote($_) } @{$s->{cols}})
      ***      0                                      
6078                                                        . " FROM " . $q->quote($args{database}, $args{table})
6079                                                        . ' ' . ($self->{index_hint} || '');
6080                                                  
6081  ***      0      0                                  if ( $self->{nibble} ) {
6082  ***      0                                            my $tmp = $self->{cached_row};
6083  ***      0                                            my $i   = 0;
6084  ***      0                                            $lb     = $s->{boundaries}->{'>'};
6085  ***      0             0                              $lb     =~ s/\?/$q->quote_val($tmp->{$s->{scols}->[$i]}, $self->{tbl_struct}->{is_numeric}->{$s->{scols}->[$i++]} || 0)/eg;
      ***      0                                      
6086  ***      0                                            $sql   .= ' WHERE ' . $lb;
6087                                                     }
6088  ***      0                                         $sql .= " ORDER BY " . join(',', map { $q->quote($_) } @{$self->{key_cols}})
      ***      0                                      
      ***      0                                      
6089                                                           . ' LIMIT ' . ($self->{chunk_size} - 1) . ', 1';
6090  ***      0                                         MKDEBUG && _d('Lower boundary:', $lb);
6091  ***      0                                         MKDEBUG && _d('Next boundary sql:', $sql);
6092  ***      0                                         return $sql, $lb;
6093                                                  }
6094                                                  
6095                                                  sub __get_explain_index {
6096  ***      0                    0                    my ( $self, $sql ) = @_;
6097  ***      0      0                                  return unless $sql;
6098  ***      0                                         my $explain;
6099  ***      0                                         eval {
6100  ***      0                                            $explain = $self->{dbh}->selectall_arrayref("EXPLAIN $sql",{Slice => {}});
6101                                                     };
6102  ***      0      0                                  if ( $EVAL_ERROR ) {
6103  ***      0                                            MKDEBUG && _d($EVAL_ERROR);
6104  ***      0                                            return;
6105                                                     }
6106  ***      0                                         MKDEBUG && _d('EXPLAIN key:', $explain->[0]->{key}); 
6107  ***      0                                         return $explain->[0]->{key};
6108                                                  }
6109                                                  
6110                                                  sub same_row {
6111  ***      0                    0                    my ( $self, $lr, $rr ) = @_;
6112  ***      0      0      0                           if ( $self->{state} ) {
      ***             0      0                        
      ***                    0                        
6113  ***      0      0                                     if ( $lr->{$self->{crc_col}} ne $rr->{$self->{crc_col}} ) {
6114  ***      0                                               $self->{ChangeHandler}->change('UPDATE', $lr, $self->key_cols());
6115                                                        }
6116                                                     }
6117                                                     elsif ( $lr->{cnt} != $rr->{cnt} || ($lr->{crc} || 0) ne ($rr->{crc} || 0) ) 
6118                                                     {
6119  ***      0                                            MKDEBUG && _d('Rows:', Dumper($lr, $rr));
6120  ***      0                                            MKDEBUG && _d('Will examine this nibble before moving to next');
6121  ***      0                                            $self->{state} = 1; # Must examine this nibble row-by-row
6122                                                     }
6123                                                  }
6124                                                  
6125                                                  sub not_in_right {
6126  ***      0                    0                    my ( $self, $lr ) = @_;
6127  ***      0      0                                  die "Called not_in_right in state 0" unless $self->{state};
6128  ***      0                                         $self->{ChangeHandler}->change('INSERT', $lr, $self->key_cols());
6129                                                  }
6130                                                  
6131                                                  sub not_in_left {
6132  ***      0                    0                    my ( $self, $rr ) = @_;
6133  ***      0      0                                  die "Called not_in_left in state 0" unless $self->{state};
6134  ***      0                                         $self->{ChangeHandler}->change('DELETE', $rr, $self->key_cols());
6135                                                  }
6136                                                  
6137                                                  sub done_with_rows {
6138  ***      0                    0                    my ( $self ) = @_;
6139  ***      0      0                                  if ( $self->{state} == 1 ) {
6140  ***      0                                            $self->{state} = 2;
6141  ***      0                                            MKDEBUG && _d('Setting state =', $self->{state});
6142                                                     }
6143                                                     else {
6144  ***      0                                            $self->{state} = 0;
6145  ***      0                                            $self->{nibble}++;
6146  ***      0                                            delete $self->{cached_boundaries};
6147  ***      0                                            MKDEBUG && _d('Setting state =', $self->{state},
6148                                                           ', nibble =', $self->{nibble});
6149                                                     }
6150                                                  }
6151                                                  
6152                                                  sub done {
6153  ***      0                    0                    my ( $self ) = @_;
6154  ***      0                                         MKDEBUG && _d('Done with nibble', $self->{nibble});
6155  ***      0                                         MKDEBUG && $self->{state} && _d('Nibble differs; must examine rows');
6156  ***      0             0                           return $self->{state} == 0 && $self->{nibble} && !$self->{cached_row};
      ***                    0                        
6157                                                  }
6158                                                  
6159                                                  sub pending_changes {
6160  ***      0                    0                    my ( $self ) = @_;
6161  ***      0      0                                  if ( $self->{state} ) {
6162  ***      0                                            MKDEBUG && _d('There are pending changes');
6163  ***      0                                            return 1;
6164                                                     }
6165                                                     else {
6166  ***      0                                            MKDEBUG && _d('No pending changes');
6167  ***      0                                            return 0;
6168                                                     }
6169                                                  }
6170                                                  
6171                                                  sub key_cols {
6172  ***      0                    0                    my ( $self ) = @_;
6173  ***      0                                         my @cols;
6174  ***      0      0                                  if ( $self->{state} == 0 ) {
6175  ***      0                                            @cols = qw(chunk_num);
6176                                                     }
6177                                                     else {
6178  ***      0                                            @cols = @{$self->{key_cols}};
      ***      0                                      
6179                                                     }
6180  ***      0                                         MKDEBUG && _d('State', $self->{state},',', 'key cols', join(', ', @cols));
6181  ***      0                                         return \@cols;
6182                                                  }
6183                                                  
6184                                                  sub _d {
6185  ***      0                    0                    my ($package, undef, $line) = caller 0;
6186  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
6187  ***      0                                              map { defined $_ ? $_ : 'undef' }
6188                                                          @_;
6189  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
6190                                                  }
6191                                                  
6192                                                  1;
6193                                                  
6194                                                  # ###########################################################################
6195                                                  # End TableSyncNibble package
6196                                                  # ###########################################################################
6197                                                  
6198                                                  # ###########################################################################
6199                                                  # TableSyncGroupBy package 5266
6200                                                  # ###########################################################################
6201                                                  package TableSyncGroupBy;
6202                                                  
6203           5                    5            72   use strict;
               5                                 14   
               5                                 45   
6204           5                    5            56   use warnings FATAL => 'all';
               5                                 18   
               5                                 45   
6205                                                  
6206           5                    5            32   use English qw(-no_match_vars);
               5                                 14   
               5                                 36   
6207                                                  
6208  ***      5            50      5            46   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 14   
               5                                 94   
6209                                                  
6210                                                  sub new {
6211  ***      0                    0                    my ( $class, %args ) = @_;
6212  ***      0                                         foreach my $arg ( qw(Quoter) ) {
6213  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
6214                                                     }
6215  ***      0                                         my $self = { %args };
6216  ***      0                                         return bless $self, $class;
6217                                                  }
6218                                                  
6219                                                  sub name {
6220  ***      0                    0                    return 'GroupBy';
6221                                                  }
6222                                                  
6223                                                  sub can_sync {
6224  ***      0                    0                    return 1;  # We can sync anything.
6225                                                  }
6226                                                  
6227                                                  sub prepare_to_sync {
6228  ***      0                    0                    my ( $self, %args ) = @_;
6229  ***      0                                         my @required_args = qw(tbl_struct cols ChangeHandler);
6230  ***      0                                         foreach my $arg ( @required_args ) {
6231  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
6232                                                     }
6233                                                  
6234  ***      0                                         $self->{cols}            = $args{cols};
6235  ***      0                                         $self->{buffer_in_mysql} = $args{buffer_in_mysql};
6236  ***      0                                         $self->{ChangeHandler}   = $args{ChangeHandler};
6237                                                  
6238  ***      0                                         $self->{count_col} = '__maatkit_count';
6239  ***      0                                         while ( $args{tbl_struct}->{is_col}->{$self->{count_col}} ) {
6240  ***      0                                            $self->{count_col} = "_$self->{count_col}";
6241                                                     }
6242  ***      0                                         MKDEBUG && _d('COUNT column will be named', $self->{count_col});
6243                                                  
6244  ***      0                                         $self->{done} = 0;
6245                                                  
6246  ***      0                                         return;
6247                                                  }
6248                                                  
6249                                                  sub uses_checksum {
6250  ***      0                    0                    return 0;  # We don't need checksum queries.
6251                                                  }
6252                                                  
6253                                                  sub set_checksum_queries {
6254  ***      0                    0                    return;  # This shouldn't be called, but just in case.
6255                                                  }
6256                                                  
6257                                                  sub prepare_sync_cycle {
6258  ***      0                    0                    my ( $self, $host ) = @_;
6259  ***      0                                         return;
6260                                                  }
6261                                                  
6262                                                  sub get_sql {
6263  ***      0                    0                    my ( $self, %args ) = @_;
6264  ***      0                                         my $cols = join(', ', map { $self->{Quoter}->quote($_) } @{$self->{cols}});
      ***      0                                      
      ***      0                                      
6265  ***      0      0      0                           return "SELECT"
6266                                                        . ($self->{buffer_in_mysql} ? ' SQL_BUFFER_RESULT' : '')
6267                                                        . " $cols, COUNT(*) AS $self->{count_col}"
6268                                                        . ' FROM ' . $self->{Quoter}->quote(@args{qw(database table)})
6269                                                        . ' WHERE ' . ( $args{where} || '1=1' )
6270                                                        . " GROUP BY $cols ORDER BY $cols";
6271                                                  }
6272                                                  
6273                                                  sub same_row {
6274  ***      0                    0                    my ( $self, $lr, $rr ) = @_;
6275  ***      0                                         my $cc = $self->{count_col};
6276  ***      0                                         my $lc = $lr->{$cc};
6277  ***      0                                         my $rc = $rr->{$cc};
6278  ***      0                                         my $diff = abs($lc - $rc);
6279  ***      0      0                                  return unless $diff;
6280  ***      0                                         $lr = { %$lr };
6281  ***      0                                         delete $lr->{$cc};
6282  ***      0                                         $rr = { %$rr };
6283  ***      0                                         delete $rr->{$cc};
6284  ***      0                                         foreach my $i ( 1 .. $diff ) {
6285  ***      0      0                                     if ( $lc > $rc ) {
6286  ***      0                                               $self->{ChangeHandler}->change('INSERT', $lr, $self->key_cols());
6287                                                        }
6288                                                        else {
6289  ***      0                                               $self->{ChangeHandler}->change('DELETE', $rr, $self->key_cols());
6290                                                        }
6291                                                     }
6292                                                  }
6293                                                  
6294                                                  sub not_in_right {
6295  ***      0                    0                    my ( $self, $lr ) = @_;
6296  ***      0                                         $lr = { %$lr };
6297  ***      0                                         my $cnt = delete $lr->{$self->{count_col}};
6298  ***      0                                         foreach my $i ( 1 .. $cnt ) {
6299  ***      0                                            $self->{ChangeHandler}->change('INSERT', $lr, $self->key_cols());
6300                                                     }
6301                                                  }
6302                                                  
6303                                                  sub not_in_left {
6304  ***      0                    0                    my ( $self, $rr ) = @_;
6305  ***      0                                         $rr = { %$rr };
6306  ***      0                                         my $cnt = delete $rr->{$self->{count_col}};
6307  ***      0                                         foreach my $i ( 1 .. $cnt ) {
6308  ***      0                                            $self->{ChangeHandler}->change('DELETE', $rr, $self->key_cols());
6309                                                     }
6310                                                  }
6311                                                  
6312                                                  sub done_with_rows {
6313  ***      0                    0                    my ( $self ) = @_;
6314  ***      0                                         $self->{done} = 1;
6315                                                  }
6316                                                  
6317                                                  sub done {
6318  ***      0                    0                    my ( $self ) = @_;
6319  ***      0                                         return $self->{done};
6320                                                  }
6321                                                  
6322                                                  sub key_cols {
6323  ***      0                    0                    my ( $self ) = @_;
6324  ***      0                                         return $self->{cols};
6325                                                  }
6326                                                  
6327                                                  sub pending_changes {
6328  ***      0                    0                    my ( $self ) = @_;
6329  ***      0                                         return;
6330                                                  }
6331                                                  
6332                                                  sub _d {
6333  ***      0                    0                    my ($package, undef, $line) = caller 0;
6334  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
6335  ***      0                                              map { defined $_ ? $_ : 'undef' }
6336                                                          @_;
6337  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
6338                                                  }
6339                                                  
6340                                                  1;
6341                                                  
6342                                                  # ###########################################################################
6343                                                  # End TableSyncGroupBy package
6344                                                  # ###########################################################################
6345                                                  
6346                                                  # ###########################################################################
6347                                                  # Outfile package 5266
6348                                                  # ###########################################################################
6349                                                  package Outfile;
6350                                                  
6351           5                    5            50   use strict;
               5                                 15   
               5                                 37   
6352           5                    5            36   use warnings FATAL => 'all';
               5                                 36   
               5                                 42   
6353           5                    5            33   use English qw(-no_match_vars);
               5                                 13   
               5                                 34   
6354                                                  
6355           5                    5            49   use List::Util qw(min);
               5                                 25   
               5                                 34   
6356                                                  
6357  ***      5            50      5            33   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 13   
               5                                125   
6358                                                  
6359                                                  sub new {
6360  ***      0                    0                    my ( $class, %args ) = @_;
6361  ***      0                                         my $self = {};
6362  ***      0                                         return bless $self, $class;
6363                                                  }
6364                                                  
6365                                                  sub write {
6366  ***      0                    0                    my ( $self, $fh, $rows ) = @_;
6367  ***      0                                         foreach my $row ( @$rows ) {
6368  ***      0      0                                     print $fh escape($row), "\n"
6369                                                           or die "Cannot write to outfile: $OS_ERROR\n";
6370                                                     }
6371  ***      0                                         return;
6372                                                  }
6373                                                  
6374                                                  sub escape {
6375  ***      0                    0                    my ( $row ) = @_;
6376  ***      0      0                                  return join("\t", map {
6377  ***      0                                            s/([\t\n\\])/\\$1/g if defined $_;  # Escape tabs etc
6378  ***      0      0                                     defined $_ ? $_ : '\N';             # NULL = \N
6379                                                     } @$row);
6380                                                  }
6381                                                  
6382                                                  sub _d {
6383  ***      0                    0                    my ($package, undef, $line) = caller 0;
6384  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
6385  ***      0                                              map { defined $_ ? $_ : 'undef' }
6386                                                          @_;
6387  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
6388                                                  }
6389                                                  
6390                                                  1;
6391                                                  # ###########################################################################
6392                                                  # End Outfile package
6393                                                  # ###########################################################################
6394                                                  
6395                                                  # ###########################################################################
6396                                                  # MockSyncStream package 5266
6397                                                  # ###########################################################################
6398                                                  package MockSyncStream;
6399                                                  
6400                                                  
6401           5                    5            43   use strict;
               5                                 14   
               5                                 39   
6402           5                    5            36   use warnings FATAL => 'all';
               5                                 14   
               5                                 33   
6403                                                  
6404           5                    5            55   use English qw(-no_match_vars);
               5                                 12   
               5                                 33   
6405                                                  
6406  ***      5            50      5            53   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 15   
               5                                145   
6407                                                  
6408                                                  sub new {
6409  ***      0                    0                    my ( $class, %args ) = @_;
6410  ***      0                                         foreach my $arg ( qw(query cols same_row not_in_left not_in_right) ) {
6411  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
6412                                                     }
6413  ***      0                                         return bless { %args }, $class;
6414                                                  }
6415                                                  
6416                                                  sub get_sql {
6417  ***      0                    0                    my ( $self ) = @_;
6418  ***      0                                         return $self->{query};
6419                                                  }
6420                                                  
6421                                                  sub same_row {
6422  ***      0                    0                    my ( $self, $lr, $rr ) = @_;
6423  ***      0                                         return $self->{same_row}->($lr, $rr);
6424                                                  }
6425                                                  
6426                                                  sub not_in_right {
6427  ***      0                    0                    my ( $self, $lr ) = @_;
6428  ***      0                                         return $self->{not_in_right}->($lr);
6429                                                  }
6430                                                  
6431                                                  sub not_in_left {
6432  ***      0                    0                    my ( $self, $rr ) = @_;
6433  ***      0                                         return $self->{not_in_left}->($rr);
6434                                                  }
6435                                                  
6436                                                  sub done_with_rows {
6437  ***      0                    0                    my ( $self ) = @_;
6438  ***      0                                         $self->{done} = 1;
6439                                                  }
6440                                                  
6441                                                  sub done {
6442  ***      0                    0                    my ( $self ) = @_;
6443  ***      0                                         return $self->{done};
6444                                                  }
6445                                                  
6446                                                  sub key_cols {
6447  ***      0                    0                    my ( $self ) = @_;
6448  ***      0                                         return $self->{cols};
6449                                                  }
6450                                                  
6451                                                  sub prepare {
6452  ***      0                    0                    my ( $self, $dbh ) = @_;
6453  ***      0                                         return;
6454                                                  }
6455                                                  
6456                                                  sub pending_changes {
6457  ***      0                    0                    my ( $self ) = @_;
6458  ***      0                                         return;
6459                                                  }
6460                                                  
6461                                                  sub get_result_set_struct {
6462  ***      0                    0                    my ( $dbh, $sth ) = @_;
6463  ***      0                                         my @cols     = @{$sth->{NAME}};
      ***      0                                      
6464  ***      0                                         my @types    = map { $dbh->type_info($_)->{TYPE_NAME} } @{$sth->{TYPE}};
      ***      0                                      
      ***      0                                      
6465  ***      0      0                                  my @nullable = map { $dbh->type_info($_)->{NULLABLE} == 1 ? 1 : 0 } @{$sth->{TYPE}};
      ***      0                                      
      ***      0                                      
6466  ***      0                                         my @p = @{$sth->{PRECISION}};
      ***      0                                      
6467  ***      0                                         my @s = @{$sth->{SCALE}};
      ***      0                                      
6468                                                  
6469  ***      0                                         my $struct   = {
6470                                                        cols => \@cols, 
6471                                                     };
6472                                                  
6473  ***      0                                         for my $i ( 0..$#cols ) {
6474  ***      0                                            my $col  = $cols[$i];
6475  ***      0                                            my $type = $types[$i];
6476  ***      0                                            $struct->{is_col}->{$col}      = 1;
6477  ***      0                                            $struct->{col_posn}->{$col}    = $i;
6478  ***      0                                            $struct->{type_for}->{$col}    = $type;
6479  ***      0                                            $struct->{is_nullable}->{$col} = $nullable[$i];
6480  ***      0      0                                     $struct->{is_numeric}->{$col} 
6481                                                           = ($type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ? 1 : 0);
6482  ***      0      0      0                              $struct->{size}->{$col}
      ***             0                               
      ***             0                               
6483                                                           = ($type =~ m/(?:float|double)/)           ? "($s[$i],$p[$i])"
6484                                                           : ($type =~ m/(?:decimal)/)                ? "($p[$i],$s[$i])"
6485                                                           : ($type =~ m/(?:char|varchar)/ && $p[$i]) ? "($p[$i])"
6486                                                           :                                            undef;
6487                                                     }
6488                                                  
6489  ***      0                                         return $struct;
6490                                                  }
6491                                                  
6492                                                  sub as_arrayref {
6493  ***      0                    0                    my ( $sth, $row ) = @_;
6494  ***      0                                         my @cols = @{$sth->{NAME}};
      ***      0                                      
6495  ***      0                                         my @row  = @{$row}{@cols};
      ***      0                                      
6496  ***      0                                         return \@row;
6497                                                  }
6498                                                  
6499                                                  sub _d {
6500  ***      0                    0                    my ($package, undef, $line) = caller 0;
6501  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
6502  ***      0                                              map { defined $_ ? $_ : 'undef' }
6503                                                          @_;
6504  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
6505                                                  }
6506                                                  
6507                                                  1;
6508                                                  
6509                                                  # ###########################################################################
6510                                                  # End MockSyncStream package
6511                                                  # ###########################################################################
6512                                                  
6513                                                  # ###########################################################################
6514                                                  # MockSth package 5266
6515                                                  # ###########################################################################
6516                                                  package MockSth;
6517                                                  
6518           5                    5            61   use strict;
               5                                 15   
               5                                 40   
6519           5                    5            31   use warnings FATAL => 'all';
               5                                 18   
               5                                 37   
6520           5                    5            35   use English qw(-no_match_vars);
               5                                 13   
               5                                 36   
6521                                                  
6522  ***      5            50      5            49   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 20   
               5                                103   
6523                                                  
6524                                                  sub new {
6525  ***      0                    0                    my ( $class, @rows ) = @_;
6526  ***      0                                         my $n_rows = scalar @rows;
6527  ***      0                                         my $self = {
6528                                                        cursor => 0,
6529                                                        Active => $n_rows,
6530                                                        rows   => \@rows,
6531                                                        n_rows => $n_rows,
6532                                                        NAME   => [],
6533                                                     };
6534  ***      0                                         return bless $self, $class;
6535                                                  }
6536                                                  
6537                                                  sub reset {
6538  ***      0                    0                    my ( $self ) = @_;
6539  ***      0                                         $self->{cursor} = 0;
6540  ***      0                                         $self->{Active} = $self->{n_rows};
6541  ***      0                                         return;
6542                                                  }
6543                                                  
6544                                                  sub fetchrow_hashref {
6545  ***      0                    0                    my ( $self ) = @_;
6546  ***      0                                         my $row;
6547  ***      0      0                                  if ( $self->{cursor} < $self->{n_rows} ) {
6548  ***      0                                            $row = $self->{rows}->[$self->{cursor}++];
6549                                                     }
6550  ***      0                                         $self->{Active} = $self->{cursor} < $self->{n_rows};
6551  ***      0                                         return $row;
6552                                                  }
6553                                                  
6554                                                  sub fetchall_arrayref {
6555  ***      0                    0                    my ( $self ) = @_;
6556  ***      0                                         my @rows;
6557  ***      0      0                                  if ( $self->{cursor} < $self->{n_rows} ) {
6558  ***      0                                            my @cols = @{$self->{NAME}};
      ***      0                                      
6559  ***      0      0                                     die "Cannot fetchall_arrayref() unless NAME is set" unless @cols;
6560  ***      0                                            @rows =  map { [ @{$_}{@cols} ] }
      ***      0                                      
      ***      0                                      
6561  ***      0                                               @{$self->{rows}}[ $self->{cursor}..($self->{n_rows} - 1) ];
6562  ***      0                                            $self->{cursor} = $self->{n_rows};
6563                                                     }
6564  ***      0                                         $self->{Active} = $self->{cursor} < $self->{n_rows};
6565  ***      0                                         return \@rows;
6566                                                  }
6567                                                  
6568                                                  sub _d {
6569  ***      0                    0                    my ($package, undef, $line) = caller 0;
6570  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
6571  ***      0                                              map { defined $_ ? $_ : 'undef' }
6572                                                          @_;
6573  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
6574                                                  }
6575                                                  
6576                                                  1;
6577                                                  
6578                                                  # ###########################################################################
6579                                                  # End MockSth package
6580                                                  # ###########################################################################
6581                                                  
6582                                                  # ###########################################################################
6583                                                  # VersionParser package 5266
6584                                                  # ###########################################################################
6585                                                  package VersionParser;
6586                                                  
6587           5                    5            44   use strict;
               5                                 13   
               5                                 41   
6588           5                    5            30   use warnings FATAL => 'all';
               5                                 12   
               5                                 35   
6589                                                  
6590           5                    5            30   use English qw(-no_match_vars);
               5                                 14   
               5                                 35   
6591                                                  
6592  ***      5            50      5            45   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 14   
               5                                 89   
6593                                                  
6594                                                  sub new {
6595  ***      0                    0                    my ( $class ) = @_;
6596  ***      0                                         bless {}, $class;
6597                                                  }
6598                                                  
6599                                                  sub parse {
6600  ***      0                    0                    my ( $self, $str ) = @_;
6601  ***      0                                         my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
6602  ***      0                                         MKDEBUG && _d($str, 'parses to', $result);
6603  ***      0                                         return $result;
6604                                                  }
6605                                                  
6606                                                  sub version_ge {
6607  ***      0                    0                    my ( $self, $dbh, $target ) = @_;
6608  ***      0      0                                  if ( !$self->{$dbh} ) {
6609  ***      0                                            $self->{$dbh} = $self->parse(
6610                                                           $dbh->selectrow_array('SELECT VERSION()'));
6611                                                     }
6612  ***      0      0                                  my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
6613  ***      0                                         MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
6614  ***      0                                         return $result;
6615                                                  }
6616                                                  
6617                                                  sub _d {
6618  ***      0                    0                    my ($package, undef, $line) = caller 0;
6619  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
6620  ***      0                                              map { defined $_ ? $_ : 'undef' }
6621                                                          @_;
6622  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
6623                                                  }
6624                                                  
6625                                                  1;
6626                                                  
6627                                                  # ###########################################################################
6628                                                  # End VersionParser package
6629                                                  # ###########################################################################
6630                                                  
6631                                                  # ###########################################################################
6632                                                  # ReportFormatter package 5266
6633                                                  # ###########################################################################
6634                                                  package ReportFormatter;
6635                                                  
6636           5                    5            45   use strict;
               5                                 17   
               5                                 42   
6637           5                    5            30   use warnings FATAL => 'all';
               5                                 16   
               5                                 37   
6638           5                    5            32   use English qw(-no_match_vars);
               5                                 11   
               5                                 31   
6639           5                    5            55   use List::Util qw(min max);
               5                                 13   
               5                                 37   
6640                                                  
6641  ***      5            50      5            44   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 14   
               5                                 89   
6642                                                  
6643           5                    5            35   use Data::Dumper;
               5                                 13   
               5                                 35   
6644                                                  $Data::Dumper::Indent    = 1;
6645                                                  $Data::Dumper::Sortkeys  = 1;
6646                                                  $Data::Dumper::Quotekeys = 0;
6647                                                  
6648                                                  sub new {
6649  ***      0                    0                    my ( $class, %args ) = @_;
6650  ***      0                                         my @required_args = qw();
6651  ***      0                                         foreach my $arg ( @required_args ) {
6652  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
6653                                                     }
6654  ***      0                                         my $self = {
6655                                                        underline_header  => 1,
6656                                                        line_prefix        => '# ',
6657                                                        line_width         => 78,
6658                                                        truncate_underline => 1,
6659                                                        %args,
6660                                                     };
6661  ***      0                                         return bless $self, $class;
6662                                                  }
6663                                                  
6664                                                  sub set_title {
6665  ***      0                    0                    my ( $self, $title ) = @_;
6666  ***      0                                         $self->{title} = $title;
6667  ***      0                                         return;
6668                                                  }
6669                                                  
6670                                                  sub set_columns {
6671  ***      0                    0                    my ( $self, @cols ) = @_;
6672  ***      0                                         push @{$self->{cols}}, map {
      ***      0                                      
6673  ***      0                                            my $col = $_;
6674  ***      0      0                                     die "Column does not have a name" unless defined $col->{name};
6675  ***      0      0      0                              if ( $col->{fixed_wdith} && $col->{fixed_width} < length $col->{name} ) { 
6676  ***      0                                               die "Fixed width is less than the column name";
6677                                                        }
6678  ***      0                                            $col->{min_val_width} = length $col->{name};
6679  ***      0                                            $col->{max_val_width} = length $col->{name};
6680  ***      0                                            $col;
6681                                                     } @cols;
6682  ***      0                                         return;
6683                                                  }
6684                                                  
6685                                                  sub add_line {
6686  ***      0                    0                    my ( $self, @vals ) = @_;
6687                                                  
6688  ***      0                                         my $n_cols = scalar @{$self->{cols}};
      ***      0                                      
6689  ***      0                                         my $n_vals = scalar @vals;
6690  ***      0      0                                  die "Number of columns ($n_cols) and values ($n_vals) do not match"
6691                                                        unless $n_cols == $n_vals;
6692                                                  
6693  ***      0                                         my @line;
6694  ***      0                                         for my $i ( 0..$#vals ) {
6695  ***      0                                            my $col = $self->{cols}->[$i];
6696  ***      0                                            my $val = $vals[$i];
6697  ***      0                                            my $width = length $val;
6698  ***      0      0      0                              if ( $col->{fixed_width} && $width > $col->{fixed_width} ) {
6699  ***      0      0                                        if ( $col->{truncate} ) {
6700  ***      0                                                  $val  = substr($val, 0, $col->{fixed_width} - 3);
6701  ***      0                                                  $val .= '...';
6702  ***      0                                                  MKDEBUG && _d('Truncated', $vals[$i], 'to', $val);
6703                                                           }
6704                                                           else {
6705  ***      0                                                  die "Value '$val' is too wide for column $col->{name}";
6706                                                           }
6707                                                        }
6708  ***      0                                            $col->{max_val_width} = max($width, $col->{max_val_width});
6709  ***      0                                            push @line, $val;
6710                                                     }
6711  ***      0                                         push @{$self->{lines}}, \@line;
      ***      0                                      
6712                                                  
6713  ***      0                                         return;
6714                                                  }
6715                                                  
6716                                                  sub get_report {
6717  ***      0                    0                    my ( $self ) = @_;
6718  ***      0                                         my @lines;
6719  ***      0             0                           my $p = $self->{line_prefix} || '';
6720                                                  
6721  ***      0      0                                  my $n_cols = scalar @{$self->{cols}}
      ***      0                                      
6722                                                                - ($self->{long_last_column} ? 2 : 1);
6723                                                  
6724  ***      0                                         my $fmt = $p;
6725  ***      0                                         my @col_fmts;
6726  ***      0                                         for my $i ( 0..$n_cols ) {
6727  ***      0                                            my $col = $self->{cols}->[$i];
6728  ***      0      0                                     my $col_fmt = '%'
6729                                                                    . ($col->{right_justify} ? '' : '-')
6730                                                                    . "$col->{max_val_width}"
6731                                                                    . 's';
6732  ***      0                                            push @col_fmts, $col_fmt;
6733                                                     }
6734  ***      0      0                                  if ( $self->{long_last_column} ) {
6735  ***      0                                            push @col_fmts, '%s';
6736                                                     }
6737  ***      0                                         $fmt .= join(' ', @col_fmts);
6738  ***      0                                         MKDEBUG && _d('Format:', $fmt);
6739                                                  
6740  ***      0      0                                  push @lines, sprintf "${p}$self->{title}" if $self->{title};
6741                                                  
6742  ***      0                                         (my $hdr_fmt = $fmt) =~ s/%([^-])/%-$1/g;
6743  ***      0                                         push @lines, sprintf $hdr_fmt, map { $_->{name} } @{$self->{cols}};
      ***      0                                      
      ***      0                                      
6744                                                  
6745  ***      0      0                                  if ( $self->{underline_header} ) {
6746  ***      0                                            my $underline_len = 0;
6747  ***      0                                            my @underlines = map {
6748  ***      0                                               my $underline = '=' x $_->{max_val_width};
6749  ***      0                                               $underline_len += length $underline;
6750  ***      0                                               $underline;
6751  ***      0                                            } @{$self->{cols}};
6752  ***      0                                            $underline_len += (scalar @underlines) - 1;
6753  ***      0      0      0                              if ( $self->{truncate_underline}
6754                                                             && (2 + $underline_len) > $self->{line_width} ) {
6755  ***      0                                               my $over = $self->{line_width} - (2 + $underline_len);
6756  ***      0                                               $underlines[-1] = substr($underlines[-1], 0, $over);
6757                                                        }
6758                                                  
6759  ***      0                                            push @lines, sprintf $fmt, @underlines;
6760                                                     }
6761                                                  
6762  ***      0                                         foreach my $line ( @{$self->{lines}} ) {
      ***      0                                      
6763  ***      0                                            push @lines, sprintf $fmt, @$line;
6764                                                     }
6765                                                  
6766  ***      0                                         return join("\n", @lines) . "\n";
6767                                                  }
6768                                                  
6769                                                  sub _d {
6770  ***      0                    0                    my ($package, undef, $line) = caller 0;
6771  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
6772  ***      0                                              map { defined $_ ? $_ : 'undef' }
6773                                                          @_;
6774  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
6775                                                  }
6776                                                  
6777                                                  1;
6778                                                  
6779                                                  # ###########################################################################
6780                                                  # End ReportFormatter package
6781                                                  # ###########################################################################
6782                                                  
6783                                                  # ###########################################################################
6784                                                  # UpgradeReportFormatter package 5287
6785                                                  # ###########################################################################
6786                                                  
6787                                                  
6788                                                  package UpgradeReportFormatter;
6789                                                  
6790           5                    5            64   use strict;
               5                                 19   
               5                                 47   
6791           5                    5            34   use warnings FATAL => 'all';
               5                                 13   
               5                                 40   
6792           5                    5            34   use English qw(-no_match_vars);
               5                                 14   
               5                                 38   
6793                                                  Transformers->import(qw(make_checksum percentage_of shorten micro_t));
6794                                                  
6795           5                    5            56   use constant MKDEBUG           => $ENV{MKDEBUG};
               5                                 15   
               5                                 60   
6796           5                    5            32   use constant LINE_LENGTH       => 74;
               5                                 15   
               5                                 24   
6797           5                    5            30   use constant MAX_STRING_LENGTH => 10;
               5                                 13   
               5                                 25   
6798                                                  
6799                                                  my %formatting_function = (
6800                                                     ts => sub {
6801                                                        my ( $stats ) = @_;
6802                                                        my $min = parse_timestamp($stats->{min} || '');
6803                                                        my $max = parse_timestamp($stats->{max} || '');
6804                                                        return $min && $max ? "$min to $max" : '';
6805                                                     },
6806                                                  );
6807                                                  
6808                                                  my $bool_format = '# %3s%% %-6s %s';
6809                                                  
6810                                                  sub new {
6811  ***      0                    0                    my ( $class, %args ) = @_;
6812  ***      0                                         return bless { }, $class;
6813                                                  }
6814                                                  
6815                                                  sub event_report {
6816  ***      0                    0                    my ( $self, %args ) = @_;
6817  ***      0                                         my @required_args = qw(where rank worst meta_ea hosts);
6818  ***      0                                         foreach my $arg ( @required_args ) {
6819  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
6820                                                     }
6821  ***      0                                         my ($where, $rank, $worst, $meta_ea, $hosts) = @args{@required_args};
6822  ***      0                                         my $meta_stats = $meta_ea->results;
6823  ***      0                                         my @result;
6824                                                  
6825                                                  
6826  ***      0             0                           my $line = sprintf(
6827                                                        '# Query %d: ID 0x%s at byte %d ',
6828                                                        $rank || 0,
6829                                                        make_checksum($where),
6830                                                        0, # $sample->{pos_in_log} || 0
6831                                                     );
6832  ***      0                                         $line .= ('_' x (LINE_LENGTH - length($line)));
6833  ***      0                                         push @result, $line;
6834                                                  
6835  ***      0                                         my $class = $meta_stats->{classes}->{$where};
6836  ***      0             0                           push @result,
6837                                                        '# Found ' . ($class->{differences}->{sum} || 0)
6838                                                        . ' differences in ' . $class->{sampleno}->{cnt} . " samples:\n";
6839                                                  
6840  ***      0                                         my $fmt = "# %-17s %d\n";
6841  ***      0                                         my @diffs = grep { $_ =~ m/^different_/ } keys %$class;
      ***      0                                      
6842  ***      0                                         foreach my $diff ( sort @diffs ) {
6843  ***      0                                            push @result,
6844                                                           sprintf $fmt, '  ' . make_label($diff), $class->{$diff}->{sum};
6845                                                     }
6846                                                  
6847  ***      0                                         my $report = new ReportFormatter(
6848                                                        underline_header => 0,
6849                                                     );
6850  ***      0                                         $report->set_columns(
6851                                                        { name => '' },
6852  ***      0                                            map { { name => $_->{name}, right_justify => 1 } } @$hosts,
6853                                                     );
6854  ***      0                                         foreach my $thing ( qw(Errors Warnings) ) {
6855  ***      0                                            my @vals = $thing;
6856  ***      0                                            foreach my $host ( @$hosts ) {
6857  ***      0                                               my $ea    = $host->{ea};
6858  ***      0                                               my $stats = $ea->results->{classes}->{$where};
6859  ***      0      0      0                                 if ( $stats && $stats->{$thing} ) {
6860  ***      0                                                  push @vals, shorten($stats->{$thing}->{sum}, d=>1_000, p=>0)
6861                                                           }
6862                                                           else {
6863  ***      0                                                  push @vals, 0;
6864                                                           }
6865                                                        }
6866  ***      0                                            $report->add_line(@vals);
6867                                                     }
6868  ***      0                                         foreach my $thing ( qw(Query_time row_count) ) {
6869  ***      0                                            my @vals;
6870                                                  
6871  ***      0                                            foreach my $host ( @$hosts ) {
6872  ***      0                                               my $ea    = $host->{ea};
6873  ***      0                                               my $stats = $ea->results->{classes}->{$where};
6874  ***      0      0      0                                 if ( $stats && $stats->{$thing} ) {
6875  ***      0                                                  my $vals = $stats->{$thing};
6876  ***      0      0                                           my $func = $thing =~ m/time$/ ? \&micro_t : \&shorten;
6877  ***      0                                                  my $metrics = $ea->calculate_statistical_metrics($vals->{all}, $vals);
6878  ***      0                                                  my @n = (
6879  ***      0                                                     @{$vals}{qw(sum min max)},
6880                                                                 ($vals->{sum} || 0) / ($vals->{cnt} || 1),
6881  ***      0             0                                       @{$metrics}{qw(pct_95 stddev median)},
      ***                    0                        
6882                                                              );
6883  ***      0      0                                           @n = map { defined $_ ? $func->($_) : '' } @n;
      ***      0                                      
6884  ***      0                                                  push @vals, \@n;
6885                                                           }
6886                                                           else {
6887  ***      0                                                  push @vals, undef;
6888                                                           }
6889                                                        }
6890                                                  
6891  ***      0      0      0                              if ( scalar @vals && grep { defined } @vals ) {
      ***      0                                      
6892  ***      0                                               $report->add_line($thing, map { '' } @$hosts);
      ***      0                                      
6893  ***      0                                               my @metrics = qw(sum min max avg pct_95 stddev median);
6894  ***      0                                               for my $i ( 0..$#metrics ) {
6895  ***      0                                                  my @n = '  ' . $metrics[$i];
6896  ***      0      0      0                                    push @n, map { $_ && defined $_->[$i] ? $_->[$i] : '' } @vals;
      ***      0                                      
6897  ***      0                                                  $report->add_line(@n);
6898                                                           }
6899                                                        }
6900                                                     }
6901                                                  
6902  ***      0                                         push @result, $report->get_report();
6903                                                  
6904  ***      0                                         return join("\n", map { s/\s+$//; $_ } @result) . "\n";
      ***      0                                      
      ***      0                                      
6905                                                  }
6906                                                  
6907                                                  sub make_label {
6908  ***      0                    0                    my ( $val ) = @_;
6909                                                  
6910  ***      0                                         $val =~ s/^different_//;
6911  ***      0                                         $val =~ s/_/ /g;
6912                                                  
6913  ***      0                                         return $val;
6914                                                  }
6915                                                  
6916                                                  sub format_string_list {
6917  ***      0                    0                    my ( $stats ) = @_;
6918  ***      0      0                                  if ( exists $stats->{unq} ) {
6919  ***      0                                            my $cnt_for = $stats->{unq};
6920  ***      0      0                                     if ( 1 == keys %$cnt_for ) {
6921  ***      0                                               my ($str) = keys %$cnt_for;
6922  ***      0      0                                        $str = substr($str, 0, LINE_LENGTH - 30) . '...'
6923                                                              if length $str > LINE_LENGTH - 30;
6924  ***      0                                               return (1, $str);
6925                                                        }
6926  ***      0                                            my $line = '';
6927  ***      0      0                                     my @top = sort { $cnt_for->{$b} <=> $cnt_for->{$a} || $a cmp $b }
      ***      0                                      
6928                                                                       keys %$cnt_for;
6929  ***      0                                            my $i = 0;
6930  ***      0                                            foreach my $str ( @top ) {
6931  ***      0                                               my $print_str;
6932  ***      0      0                                        if ( length $str > MAX_STRING_LENGTH ) {
6933  ***      0                                                  $print_str = substr($str, 0, MAX_STRING_LENGTH) . '...';
6934                                                           }
6935                                                           else {
6936  ***      0                                                  $print_str = $str;
6937                                                           }
6938  ***      0      0                                        last if (length $line) + (length $print_str)  > LINE_LENGTH - 27;
6939  ***      0                                               $line .= "$print_str ($cnt_for->{$str}), ";
6940  ***      0                                               $i++;
6941                                                        }
6942  ***      0                                            $line =~ s/, $//;
6943  ***      0      0                                     if ( $i < @top ) {
6944  ***      0                                               $line .= "... " . (@top - $i) . " more";
6945                                                        }
6946  ***      0                                            return (scalar keys %$cnt_for, $line);
6947                                                     }
6948                                                     else {
6949  ***      0                                            return ($stats->{cnt});
6950                                                     }
6951                                                  }
6952                                                  
6953                                                  sub _d {
6954  ***      0                    0                    my ($package, undef, $line) = caller 0;
6955  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
6956  ***      0                                              map { defined $_ ? $_ : 'undef' }
6957                                                          @_;
6958  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
6959                                                  }
6960                                                  
6961                                                  1;
6962                                                  
6963                                                  # ###########################################################################
6964                                                  # End UpgradeReportFormatter package
6965                                                  # ###########################################################################
6966                                                  
6967                                                  # ###########################################################################
6968                                                  # CompareResults package 5285
6969                                                  # ###########################################################################
6970                                                  package CompareResults;
6971                                                  
6972           5                    5            63   use strict;
               5                                 15   
               5                                 40   
6973           5                    5            33   use warnings FATAL => 'all';
               5                                 12   
               5                                 37   
6974           5                    5            33   use English qw(-no_match_vars);
               5                                 26   
               5                                 39   
6975           5                    5            49   use Time::HiRes qw(time);
               5                                 50   
               5                                 44   
6976                                                  
6977  ***      5            50      5            34   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 12   
               5                                 90   
6978                                                  
6979           5                    5            38   use Data::Dumper;
               5                                 13   
               5                                 36   
6980                                                  $Data::Dumper::Indent    = 1;
6981                                                  $Data::Dumper::Sortkeys  = 1;
6982                                                  $Data::Dumper::Quotekeys = 0;
6983                                                  
6984                                                  sub new {
6985  ***      0                    0                    my ( $class, %args ) = @_;
6986  ***      0                                         my @required_args = qw(method base-dir plugins get_id
6987                                                                            QueryParser MySQLDump TableParser TableSyncer Quoter);
6988  ***      0                                         foreach my $arg ( @required_args ) {
6989  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
6990                                                     }
6991  ***      0                                         my $self = {
6992                                                        %args,
6993                                                        diffs   => {},
6994                                                        samples => {},
6995                                                     };
6996  ***      0                                         return bless $self, $class;
6997                                                  }
6998                                                  
6999                                                  sub before_execute {
7000  ***      0                    0                    my ( $self, %args ) = @_;
7001  ***      0                                         my @required_args = qw(event dbh);
7002  ***      0                                         foreach my $arg ( @required_args ) {
7003  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
7004                                                     }
7005  ***      0                                         my ($event, $dbh) = @args{@required_args};
7006  ***      0                                         my $sql;
7007                                                  
7008  ***      0      0                                  if ( $self->{method} eq 'checksum' ) {
7009  ***      0                                            my ($db, $tmp_tbl) = @args{qw(db temp-table)};
7010  ***      0      0                                     $db = $args{'temp-database'} if $args{'temp-database'};
7011  ***      0      0                                     die "Cannot checksum results without a database"
7012                                                           unless $db;
7013                                                  
7014  ***      0                                            $tmp_tbl = $self->{Quoter}->quote($db, $tmp_tbl);
7015  ***      0                                            eval {
7016  ***      0                                               $sql = "DROP TABLE IF EXISTS $tmp_tbl";
7017  ***      0                                               MKDEBUG && _d($sql);
7018  ***      0                                               $dbh->do($sql);
7019                                                  
7020  ***      0                                               $sql = "SET storage_engine=MyISAM";
7021  ***      0                                               MKDEBUG && _d($sql);
7022  ***      0                                               $dbh->do($sql);
7023                                                        };
7024  ***      0      0                                     die "Failed to drop temporary table $tmp_tbl: $EVAL_ERROR"
7025                                                           if $EVAL_ERROR;
7026                                                  
7027  ***      0                                            $event->{tmp_tbl} = $tmp_tbl; 
7028                                                  
7029  ***      0                                            $event->{wrapped_query}
7030                                                           = "CREATE TEMPORARY TABLE $tmp_tbl AS $event->{arg}";
7031  ***      0                                            MKDEBUG && _d('Wrapped query:', $event->{wrapped_query});
7032                                                     }
7033                                                  
7034  ***      0                                         return $event;
7035                                                  }
7036                                                  
7037                                                  sub execute {
7038  ***      0                    0                    my ( $self, %args ) = @_;
7039  ***      0                                         my @required_args = qw(event dbh);
7040  ***      0                                         foreach my $arg ( @required_args ) {
7041  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
7042                                                     }
7043  ***      0                                         my ($event, $dbh) = @args{@required_args};
7044  ***      0                                         my ( $start, $end, $query_time );
7045                                                  
7046                                                  
7047  ***      0                                         MKDEBUG && _d('Executing query');
7048  ***      0                                         $event->{Query_time} = 0;
7049  ***      0      0                                  if ( $self->{method} eq 'rows' ) {
7050  ***      0                                            my $query = $event->{arg};
7051  ***      0                                            my $sth;
7052  ***      0                                            eval {
7053  ***      0                                               $sth = $dbh->prepare($query);
7054                                                        };
7055  ***      0      0                                     die "Failed to prepare query: $EVAL_ERROR" if $EVAL_ERROR;
7056                                                  
7057  ***      0                                            eval {
7058  ***      0                                               $start = time();
7059  ***      0                                               $sth->execute();
7060  ***      0                                               $end   = time();
7061  ***      0                                               $query_time = sprintf '%.6f', $end - $start;
7062                                                        };
7063  ***      0      0                                     die "Failed to execute query: $EVAL_ERROR" if $EVAL_ERROR;
7064                                                  
7065  ***      0                                            $event->{results_sth} = $sth;
7066                                                     }
7067                                                     else {
7068  ***      0      0                                     die "No wrapped query" unless $event->{wrapped_query};
7069  ***      0                                            my $query = $event->{wrapped_query};
7070  ***      0                                            eval {
7071  ***      0                                               $start = time();
7072  ***      0                                               $dbh->do($query);
7073  ***      0                                               $end   = time();
7074  ***      0                                               $query_time = sprintf '%.6f', $end - $start;
7075                                                        };
7076  ***      0      0                                     if ( $EVAL_ERROR ) {
7077  ***      0                                               delete $event->{wrapped_query};
7078  ***      0                                               delete $event->{tmp_tbl};
7079  ***      0                                               die "Failed to execute query: $EVAL_ERROR";
7080                                                        }
7081                                                     }
7082                                                  
7083  ***      0                                         $event->{Query_time} = $query_time;
7084                                                  
7085  ***      0                                         return $event;
7086                                                  }
7087                                                  
7088                                                  sub after_execute {
7089  ***      0                    0                    my ( $self, %args ) = @_;
7090  ***      0                                         my @required_args = qw(event);
7091  ***      0                                         foreach my $arg ( @required_args ) {
7092  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
7093                                                     }
7094  ***      0                                         return $args{event};
7095                                                  }
7096                                                  
7097                                                  sub compare {
7098  ***      0                    0                    my ( $self, %args ) = @_;
7099  ***      0                                         my @required_args = qw(events hosts);
7100  ***      0                                         foreach my $arg ( @required_args ) {
7101  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
7102                                                     }
7103  ***      0                                         my ($events, $hosts) = @args{@required_args};
7104  ***      0      0                                  return $self->{method} eq 'rows' ? $self->_compare_rows(%args)
7105                                                                                      : $self->_compare_checksums(%args);
7106                                                  }
7107                                                  
7108                                                  sub _compare_checksums {
7109  ***      0                    0                    my ( $self, %args ) = @_;
7110  ***      0                                         my @required_args = qw(events hosts);
7111  ***      0                                         foreach my $arg ( @required_args ) {
7112  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
7113                                                     }
7114  ***      0                                         my ($events, $hosts) = @args{@required_args};
7115                                                  
7116  ***      0                                         my $different_row_counts    = 0;
7117  ***      0                                         my $different_column_counts = 0; # TODO
7118  ***      0                                         my $different_column_types  = 0; # TODO
7119  ***      0                                         my $different_checksums     = 0;
7120                                                  
7121  ***      0                                         my $n_events = scalar @$events;
7122  ***      0                                         foreach my $i ( 0..($n_events-1) ) {
7123  ***      0                                            $events->[$i] = $self->_checksum_results(
7124                                                           event => $events->[$i],
7125                                                           dbh   => $hosts->[$i]->{dbh},
7126                                                        );
7127  ***      0      0                                     if ( $i ) {
7128  ***      0      0      0                                 if ( ($events->[0]->{checksum} || 0)
      ***                    0                        
7129                                                                != ($events->[$i]->{checksum}||0) ) {
7130  ***      0                                                  $different_checksums++;
7131                                                           }
7132  ***      0      0      0                                 if ( ($events->[0]->{row_count} || 0)
      ***                    0                        
7133                                                                != ($events->[$i]->{row_count} || 0) ) {
7134  ***      0                                                  $different_row_counts++
7135                                                           }
7136                                                  
7137  ***      0                                               delete $events->[$i]->{wrapped_query};
7138                                                        }
7139                                                     }
7140  ***      0                                         delete $events->[0]->{wrapped_query};
7141                                                  
7142  ***      0             0                           my $item     = $events->[0]->{fingerprint} || $events->[0]->{arg};
7143  ***      0             0                           my $sampleno = $events->[0]->{sampleno} || 0;
7144  ***      0      0                                  if ( $different_checksums ) {
7145  ***      0                                            $self->{diffs}->{checksums}->{$item}->{$sampleno}
7146  ***      0                                               = [ map { $_->{checksum} } @$events ];
7147  ***      0                                            $self->{samples}->{$item}->{$sampleno} = $events->[0]->{arg};
7148                                                     }
7149  ***      0      0                                  if ( $different_row_counts ) {
7150  ***      0                                            $self->{diffs}->{row_counts}->{$item}->{$sampleno}
7151  ***      0                                               = [ map { $_->{row_count} } @$events ];
7152  ***      0                                            $self->{samples}->{$item}->{$sampleno} = $events->[0]->{arg};
7153                                                     }
7154                                                  
7155                                                     return (
7156  ***      0                                            different_row_counts    => $different_row_counts,
7157                                                        different_checksums     => $different_checksums,
7158                                                        different_column_counts => $different_column_counts,
7159                                                        different_column_types  => $different_column_types,
7160                                                     );
7161                                                  }
7162                                                  
7163                                                  sub _checksum_results {
7164  ***      0                    0                    my ( $self, %args ) = @_;
7165  ***      0                                         my @required_args = qw(event dbh);
7166  ***      0                                         foreach my $arg ( @required_args ) {
7167  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
7168                                                     }
7169  ***      0                                         my ($event, $dbh) = @args{@required_args};
7170                                                  
7171  ***      0                                         my $sql;
7172  ***      0                                         my $n_rows       = 0;
7173  ***      0                                         my $tbl_checksum = 0;
7174  ***      0      0      0                           if ( $event->{wrapped_query} && $event->{tmp_tbl} ) {
7175  ***      0                                            my $tmp_tbl = $event->{tmp_tbl};
7176  ***      0                                            eval {
7177  ***      0                                               $sql = "SELECT COUNT(*) FROM $tmp_tbl";
7178  ***      0                                               MKDEBUG && _d($sql);
7179  ***      0                                               ($n_rows) = @{ $dbh->selectcol_arrayref($sql) };
      ***      0                                      
7180                                                  
7181  ***      0                                               $sql = "CHECKSUM TABLE $tmp_tbl";
7182  ***      0                                               MKDEBUG && _d($sql);
7183  ***      0                                               $tbl_checksum = $dbh->selectrow_arrayref($sql)->[1];
7184                                                        };
7185  ***      0      0                                     die "Failed to checksum table: $EVAL_ERROR"
7186                                                           if $EVAL_ERROR;
7187                                                     
7188  ***      0                                            $sql = "DROP TABLE IF EXISTS $tmp_tbl";
7189  ***      0                                            MKDEBUG && _d($sql);
7190  ***      0                                           eval {
7191  ***      0                                               $dbh->do($sql);
7192                                                        };
7193  ***      0                                            MKDEBUG && $EVAL_ERROR && _d('Error:', $EVAL_ERROR);
7194                                                     }
7195                                                     else {
7196  ***      0                                            MKDEBUG && _d("Event doesn't have wrapped query or tmp tbl");
7197                                                     }
7198                                                  
7199  ***      0                                         $event->{row_count} = $n_rows;
7200  ***      0                                         $event->{checksum}  = $tbl_checksum;
7201  ***      0                                         MKDEBUG && _d('row count:', $n_rows, 'checksum:', $tbl_checksum);
7202                                                  
7203  ***      0                                         return $event;
7204                                                  }
7205                                                  
7206                                                  sub _compare_rows {
7207  ***      0                    0                    my ( $self, %args ) = @_;
7208  ***      0                                         my @required_args = qw(events hosts);
7209  ***      0                                         foreach my $arg ( @required_args ) {
7210  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
7211                                                     }
7212  ***      0                                         my ($events, $hosts) = @args{@required_args};
7213                                                  
7214  ***      0                                         my $different_row_counts    = 0;
7215  ***      0                                         my $different_column_counts = 0; # TODO
7216  ***      0                                         my $different_column_types  = 0; # TODO
7217  ***      0                                         my $different_column_values = 0;
7218                                                  
7219  ***      0                                         my $n_events = scalar @$events;
7220  ***      0                                         my $event0   = $events->[0]; 
7221  ***      0             0                           my $item     = $event0->{fingerprint} || $event0->{arg};
7222  ***      0             0                           my $sampleno = $event0->{sampleno} || 0;
7223  ***      0                                         my $dbh      = $hosts->[0]->{dbh};  # doesn't matter which one
7224                                                  
7225  ***      0      0                                  if ( !$event0->{results_sth} ) {
7226  ***      0                                            MKDEBUG && _d("Event 0 doesn't have a results sth");
7227                                                        return (
7228  ***      0                                               different_row_counts    => $different_row_counts,
7229                                                           different_column_values => $different_column_values,
7230                                                           different_column_counts => $different_column_counts,
7231                                                           different_column_types  => $different_column_types,
7232                                                        );
7233                                                     }
7234                                                  
7235  ***      0                                         my $res_struct = MockSyncStream::get_result_set_struct($dbh,
7236                                                        $event0->{results_sth});
7237  ***      0                                         MKDEBUG && _d('Result set struct:', Dumper($res_struct));
7238                                                  
7239  ***      0                                         my @event0_rows      = @{ $event0->{results_sth}->fetchall_arrayref({}) };
      ***      0                                      
7240  ***      0                                         $event0->{row_count} = scalar @event0_rows;
7241  ***      0                                         my $left = new MockSth(@event0_rows);
7242  ***      0                                         $left->{NAME} = [ @{$event0->{results_sth}->{NAME}} ];
      ***      0                                      
7243                                                  
7244                                                     EVENT:
7245  ***      0                                         foreach my $i ( 1..($n_events-1) ) {
7246  ***      0                                            my $event = $events->[$i];
7247  ***      0                                            my $right = $event->{results_sth};
7248                                                  
7249  ***      0                                            $event->{row_count} = 0;
7250                                                  
7251  ***      0                                            my $no_diff      = 1;  # results are identical; this catches 0 row results
7252  ***      0                                            my $outfile      = new Outfile();
7253  ***      0                                            my ($left_outfile, $right_outfile, $n_rows);
7254                                                        my $same_row     = sub {
7255  ***      0                    0                             $event->{row_count}++;  # Keep track of this event's row_count.
7256  ***      0                                                  return;
7257  ***      0                                            };
7258                                                        my $not_in_left  = sub {
7259  ***      0                    0                          my ( $rr ) = @_;
7260  ***      0                                               $no_diff = 0;
7261  ***      0                                               ($right_outfile, $n_rows) = $self->write_to_outfile(
7262                                                              side    => 'right',
7263                                                              sth     => $right,
7264                                                              row     => $rr,
7265                                                              Outfile => $outfile,
7266                                                           );
7267  ***      0                                               return;
7268  ***      0                                            };
7269                                                        my $not_in_right = sub {
7270  ***      0                    0                          my ( $lr ) = @_;
7271  ***      0                                               $no_diff = 0;
7272  ***      0                                               ($left_outfile, undef) = $self->write_to_outfile(
7273                                                              side    => 'left',
7274                                                              sth     => $left,
7275                                                              row     => $lr,
7276                                                              Outfile => $outfile,
7277                                                           ); 
7278  ***      0                                               return;
7279  ***      0                                            };
7280                                                  
7281  ***      0                                            my $rd       = new RowDiff(dbh => $dbh);
7282  ***      0                                            my $mocksync = new MockSyncStream(
7283                                                           query        => $event0->{arg},
7284                                                           cols         => $res_struct->{cols},
7285                                                           same_row     => $same_row,
7286                                                           not_in_left  => $not_in_left,
7287                                                           not_in_right => $not_in_right,
7288                                                        );
7289                                                  
7290  ***      0                                            MKDEBUG && _d('Comparing result sets with MockSyncStream');
7291  ***      0                                            $rd->compare_sets(
7292                                                           left   => $left,
7293                                                           right  => $right,
7294                                                           syncer => $mocksync,
7295                                                           tbl    => $res_struct,
7296                                                        );
7297                                                  
7298  ***      0             0                              $event->{row_count} += $n_rows || 0;
7299                                                  
7300  ***      0                                            MKDEBUG && _d('Left has', $event0->{row_count}, 'rows, right has',
7301                                                           $event->{row_count});
7302                                                  
7303  ***      0      0                                     $different_row_counts++ if $event0->{row_count} != $event->{row_count};
7304  ***      0      0                                     if ( $different_row_counts ) {
7305  ***      0                                               $self->{diffs}->{row_counts}->{$item}->{$sampleno}
7306                                                              = [ $event0->{row_count}, $event->{row_count} ];
7307  ***      0                                               $self->{samples}->{$item}->{$sampleno} = $event0->{arg};
7308                                                        }
7309                                                  
7310  ***      0                                            $left->reset();
7311  ***      0      0                                     if ( $no_diff ) {
7312  ***      0                                               delete $event->{results_sth};
7313  ***      0                                               next EVENT;
7314                                                        }
7315                                                  
7316  ***      0                                            MKDEBUG && _d('Result sets are different');
7317                                                  
7318                                                  
7319  ***      0      0                                     if ( !$left_outfile ) {
7320  ***      0                                               MKDEBUG && _d('Right has extra rows not in left');
7321  ***      0                                               (undef, $left_outfile) = $self->open_outfile(side => 'left');
7322                                                        }
7323  ***      0      0                                     if ( !$right_outfile ) {
7324  ***      0                                               MKDEBUG && _d('Left has extra rows not in right');
7325  ***      0                                               (undef, $right_outfile) = $self->open_outfile(side => 'right');
7326                                                        }
7327                                                  
7328  ***      0             0                              my @diff_rows = $self->diff_rows(
7329                                                           %args,             # for options like max-different-rows
7330                                                           left_dbh        => $hosts->[0]->{dbh},
7331                                                           left_outfile    => $left_outfile,
7332                                                           right_dbh       => $hosts->[$i]->{dbh},
7333                                                           right_outfile   => $right_outfile,
7334                                                           res_struct      => $res_struct,
7335                                                           query           => $event0->{arg},
7336                                                           db              => $args{tmp_db} || $event0->{db},
7337                                                        );
7338                                                  
7339  ***      0      0                                     if ( scalar @diff_rows ) { 
7340  ***      0                                               $different_column_values++; 
7341  ***      0                                               $self->{diffs}->{col_vals}->{$item}->{$sampleno} = \@diff_rows;
7342  ***      0                                               $self->{samples}->{$item}->{$sampleno} = $event0->{arg};
7343                                                        }
7344                                                  
7345  ***      0                                            delete $event->{results_sth};
7346                                                     }
7347  ***      0                                         delete $event0->{results_sth};
7348                                                  
7349                                                     return (
7350  ***      0                                            different_row_counts    => $different_row_counts,
7351                                                        different_column_values => $different_column_values,
7352                                                        different_column_counts => $different_column_counts,
7353                                                        different_column_types  => $different_column_types,
7354                                                     );
7355                                                  }
7356                                                  
7357                                                  sub diff_rows {
7358  ***      0                    0                    my ( $self, %args ) = @_;
7359  ***      0                                         my @required_args = qw(left_dbh left_outfile right_dbh right_outfile
7360                                                                            res_struct db query);
7361  ***      0                                         foreach my $arg ( @required_args ) {
7362  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
7363                                                     }
7364  ***      0                                         my ($left_dbh, $left_outfile, $right_dbh, $right_outfile, $res_struct,
7365                                                         $db, $query)
7366                                                        = @args{@required_args};
7367                                                  
7368  ***      0                                         my $left_tbl  = "`$db`.`mk_upgrade_left`";
7369  ***      0                                         my $right_tbl = "`$db`.`mk_upgrade_right`";
7370  ***      0                                         my $table_ddl = $self->make_table_ddl($res_struct);
7371                                                  
7372  ***      0                                         $left_dbh->do("DROP TABLE IF EXISTS $left_tbl");
7373  ***      0                                         $left_dbh->do("CREATE TABLE $left_tbl $table_ddl");
7374  ***      0                                         $left_dbh->do("LOAD DATA LOCAL INFILE '$left_outfile' "
7375                                                        . "INTO TABLE $left_tbl");
7376                                                  
7377  ***      0                                         $right_dbh->do("DROP TABLE IF EXISTS $right_tbl");
7378  ***      0                                         $right_dbh->do("CREATE TABLE $right_tbl $table_ddl");
7379  ***      0                                         $right_dbh->do("LOAD DATA LOCAL INFILE '$right_outfile' "
7380                                                        . "INTO TABLE $right_tbl");
7381                                                  
7382  ***      0                                         MKDEBUG && _d('Loaded', $left_outfile, 'into table', $left_tbl, 'and',
7383                                                        $right_outfile, 'into table', $right_tbl);
7384                                                  
7385  ***      0      0                                  if ( $args{'add-indexes'} ) {
7386  ***      0                                            $self->add_indexes(
7387                                                           %args,
7388                                                           dsts      => [
7389                                                              { dbh => $left_dbh,  tbl => $left_tbl  },
7390                                                              { dbh => $right_dbh, tbl => $right_tbl },
7391                                                           ],
7392                                                        );
7393                                                     }
7394                                                  
7395  ***      0             0                           my $max_diff = $args{'max-different-rows'} || 1_000;  # 1k=sanity/safety
7396  ***      0                                         my $n_diff   = 0;
7397  ***      0                                         my @missing_rows;  # not currently saved; row counts show missing rows
7398  ***      0                                         my @different_rows;
7399           5                    5            69      use constant LEFT  => 0;
               5                                 16   
               5                                 44   
7400           5                    5            35      use constant RIGHT => 1;
               5                                 12   
               5                                 23   
7401  ***      0                                         my @l_r = (undef, undef);
7402  ***      0                                         my @last_diff_col;
7403  ***      0                                         my $last_diff = 0;
7404                                                     my $key_cmp      = sub {
7405  ***      0                    0                       push @last_diff_col, [@_];
7406  ***      0                                            $last_diff--;
7407  ***      0                                            return;
7408  ***      0                                         };
7409                                                     my $same_row = sub {
7410  ***      0                    0                       my ( $lr, $rr ) = @_;
7411  ***      0      0      0                              if ( $l_r[LEFT] && $l_r[RIGHT] ) {
      ***             0                               
      ***             0                               
7412  ***      0                                               MKDEBUG && _d('Saving different row');
7413  ***      0                                               push @different_rows, $last_diff_col[$last_diff];
7414  ***      0                                               $n_diff++;
7415                                                        }
7416                                                        elsif ( $l_r[LEFT] ) {
7417  ***      0                                               MKDEBUG && _d('Saving not in right row');
7418  ***      0                                               $n_diff++;
7419                                                        }
7420                                                        elsif ( $l_r[RIGHT] ) {
7421  ***      0                                               MKDEBUG && _d('Saving not in left row');
7422  ***      0                                               $n_diff++;
7423                                                        }
7424                                                        else {
7425  ***      0                                               MKDEBUG && _d('No missing or different rows in queue');
7426                                                        }
7427  ***      0                                            @l_r           = (undef, undef);
7428  ***      0                                            @last_diff_col = ();
7429  ***      0                                            $last_diff     = 0;
7430  ***      0                                            return;
7431  ***      0                                         };
7432                                                     my $not_in_left  = sub {
7433  ***      0                    0                       my ( $rr ) = @_;
7434  ***      0      0                                     $same_row->() if $l_r[RIGHT];  # last missing row
7435  ***      0                                            $l_r[RIGHT] = $rr;
7436  ***      0      0      0                              $same_row->(@l_r) if $l_r[LEFT] && $l_r[RIGHT];
7437  ***      0                                            return;
7438  ***      0                                         };
7439                                                     my $not_in_right = sub {
7440  ***      0                    0                       my ( $lr ) = @_;
7441  ***      0      0                                     $same_row->() if $l_r[LEFT];  # last missing row
7442  ***      0                                            $l_r[LEFT] = $lr;
7443  ***      0      0      0                              $same_row->(@l_r) if $l_r[LEFT] && $l_r[RIGHT];
7444  ***      0                                            return;
7445  ***      0                                         };
7446                                                     my $done = sub {
7447  ***      0                    0                       my ( $left, $right ) = @_;
7448  ***      0                                            MKDEBUG && _d('Found', $n_diff, 'of', $max_diff, 'max differences');
7449  ***      0      0                                     if ( $n_diff >= $max_diff ) {
7450  ***      0                                               MKDEBUG && _d('Done comparing rows, got --max-differences', $max_diff);
7451  ***      0                                               $left->finish();
7452  ***      0                                               $right->finish();
7453  ***      0                                               return 1;
7454                                                        }
7455  ***      0                                            return 0;
7456  ***      0                                         };
7457  ***      0                                         my $trf;
7458  ***      0      0                                  if ( my $n = $args{'float-precision'} ) {
7459                                                        $trf = sub {
7460  ***      0                    0                          my ( $l, $r, $tbl, $col ) = @_;
7461  ***      0      0                                        return $l, $r
7462                                                              unless $tbl->{type_for}->{$col} =~ m/(?:float|double|decimal)/;
7463  ***      0                                               my $l_rounded = sprintf "%.${n}f", $l;
7464  ***      0                                               my $r_rounded = sprintf "%.${n}f", $r;
7465  ***      0                                               MKDEBUG && _d('Rounded', $l, 'to', $l_rounded,
7466                                                              'and', $r, 'to', $r_rounded);
7467  ***      0                                               return $l_rounded, $r_rounded;
7468  ***      0                                            };
7469                                                     };
7470                                                  
7471  ***      0                                         my $rd = new RowDiff(
7472                                                        dbh          => $left_dbh,
7473                                                        key_cmp      => $key_cmp,
7474                                                        same_row     => $same_row,
7475                                                        not_in_left  => $not_in_left,
7476                                                        not_in_right => $not_in_right,
7477                                                        done         => $done,
7478                                                        trf          => $trf,
7479                                                     );
7480  ***      0                                         my $ch = new ChangeHandler(
7481                                                        src_db     => $db,
7482                                                        src_tbl    => 'mk_upgrade_left',
7483                                                        dst_db     => $db,
7484                                                        dst_tbl    => 'mk_upgrade_right',
7485                                                        tbl_struct => $res_struct,
7486                                                        queue      => 0,
7487                                                        replace    => 0,
7488                                                        actions    => [],
7489                                                        Quoter     => $self->{Quoter},
7490                                                     );
7491                                                  
7492  ***      0                                         $self->{TableSyncer}->sync_table(
7493                                                        plugins       => $self->{plugins},
7494                                                        src           => {
7495                                                           dbh => $left_dbh,
7496                                                           db  => $db,
7497                                                           tbl => 'mk_upgrade_left',
7498                                                        },
7499                                                        dst           => {
7500                                                           dbh => $right_dbh,
7501                                                           db  => $db,
7502                                                           tbl => 'mk_upgrade_right',
7503                                                        },
7504                                                        tbl_struct    => $res_struct,
7505                                                        cols          => $res_struct->{cols},
7506                                                        chunk_size    => 1_000,
7507                                                        RowDiff       => $rd,
7508                                                        ChangeHandler => $ch,
7509                                                     );
7510                                                  
7511  ***      0      0                                  if ( $n_diff < $max_diff ) {
7512  ***      0      0      0                              $same_row->() if $l_r[LEFT] || $l_r[RIGHT];  # save remaining rows
7513                                                     }
7514                                                  
7515  ***      0                                         return @different_rows;
7516                                                  }
7517                                                  
7518                                                  sub write_to_outfile {
7519  ***      0                    0                    my ( $self, %args ) = @_;
7520  ***      0                                         my @required_args = qw(side row sth Outfile);
7521  ***      0                                         foreach my $arg ( @required_args ) {
7522  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
7523                                                     }
7524  ***      0                                         my ( $side, $row, $sth, $outfile ) = @args{@required_args};
7525  ***      0                                         my ( $fh, $file ) = $self->open_outfile(%args);
7526                                                  
7527  ***      0                                         $outfile->write($fh, [ MockSyncStream::as_arrayref($sth, $row) ]);
7528                                                  
7529  ***      0                                         my $remaining_rows = $sth->fetchall_arrayref();
7530  ***      0                                         $outfile->write($fh, $remaining_rows);
7531                                                  
7532  ***      0                                         my $n_rows = 1 + @$remaining_rows;
7533  ***      0                                         MKDEBUG && _d('Wrote', $n_rows, 'rows');
7534                                                  
7535  ***      0      0                                  close $fh or warn "Cannot close $file: $OS_ERROR";
7536  ***      0                                         return $file, $n_rows;
7537                                                  }
7538                                                  
7539                                                  sub open_outfile {
7540  ***      0                    0                    my ( $self, %args ) = @_;
7541  ***      0                                         my $outfile = $self->{'base-dir'} . "/$args{side}-outfile.txt";
7542  ***      0      0                                  open my $fh, '>', $outfile or die "Cannot open $outfile: $OS_ERROR";
7543  ***      0                                         MKDEBUG && _d('Opened outfile', $outfile);
7544  ***      0                                         return $fh, $outfile;
7545                                                  }
7546                                                  
7547                                                  sub make_table_ddl {
7548  ***      0                    0                    my ( $self, $struct ) = @_;
7549  ***      0                                         my $sql = "(\n"
7550                                                             . (join("\n",
7551                                                                   map {
7552  ***      0                                                          my $name = $_;
7553  ***      0                                                          my $type = $struct->{type_for}->{$_};
7554  ***      0             0                                            my $size = $struct->{size}->{$_} || '';
7555  ***      0                                                          "  `$name` $type$size,";
7556  ***      0                                                       } @{$struct->{cols}}))
7557                                                             . ')';
7558  ***      0                                         $sql =~ s/,\)$/\n)/;
7559  ***      0                                         MKDEBUG && _d('Table ddl:', $sql);
7560  ***      0                                         return $sql;
7561                                                  }
7562                                                  
7563                                                  sub add_indexes {
7564  ***      0                    0                    my ( $self, %args ) = @_;
7565  ***      0                                         my @required_args = qw(query dsts db);
7566  ***      0                                         foreach my $arg ( @required_args ) {
7567  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
7568                                                     }
7569  ***      0                                         my ($query, $dsts) = @args{@required_args};
7570                                                  
7571  ***      0                                         my $qp = $self->{QueryParser};
7572  ***      0                                         my $tp = $self->{TableParser};
7573  ***      0                                         my $q  = $self->{Quoter};
7574  ***      0                                         my $du = $self->{MySQLDump};
7575                                                  
7576  ***      0                                         my @src_tbls = $qp->get_tables($query);
7577  ***      0                                         my @keys;
7578  ***      0                                         foreach my $db_tbl ( @src_tbls ) {
7579  ***      0                                            my ($db, $tbl) = $q->split_unquote($db_tbl, $args{db});
7580  ***      0      0                                     if ( $db ) {
7581  ***      0                                               my $tbl_struct;
7582  ***      0                                               eval {
7583  ***      0                                                  $tbl_struct = $tp->parse(
7584                                                                 $du->get_create_table($dsts->[0]->{dbh}, $q, $db, $tbl)
7585                                                              );
7586                                                           };
7587  ***      0      0                                        if ( $EVAL_ERROR ) {
7588  ***      0                                                  MKDEBUG && _d('Error parsing', $db, '.', $tbl, ':', $EVAL_ERROR);
7589  ***      0                                                  next;
7590                                                           }
7591  ***      0      0                                        push @keys, map {
7592  ***      0                                                  my $def = ($_->{is_unique} ? 'UNIQUE ' : '')
7593                                                                      . "KEY ($_->{colnames})";
7594  ***      0                                                  [$def, $_];
7595  ***      0                                               } grep { $_->{type} eq 'BTREE' } values %{$tbl_struct->{keys}};
      ***      0                                      
7596                                                        }
7597                                                        else {
7598  ***      0                                               MKDEBUG && _d('Cannot get indexes from', $db_tbl, 'because its '
7599                                                              . 'database is unknown');
7600                                                        }
7601                                                     }
7602  ***      0                                         MKDEBUG && _d('Source keys:', Dumper(\@keys));
7603  ***      0      0                                  return unless @keys;
7604                                                  
7605  ***      0                                         for my $dst ( @$dsts ) {
7606  ***      0                                            foreach my $key ( @keys ) {
7607  ***      0                                               my $def = $key->[0];
7608  ***      0                                               my $sql = "ALTER TABLE $dst->{tbl} ADD $key->[0]";
7609  ***      0                                               MKDEBUG && _d($sql);
7610  ***      0                                               eval {
7611  ***      0                                                  $dst->{dbh}->do($sql);
7612                                                           };
7613  ***      0      0                                        if ( $EVAL_ERROR ) {
7614  ***      0                                                  MKDEBUG && _d($EVAL_ERROR);
7615                                                           }
7616                                                           else {
7617                                                           }
7618                                                        }
7619                                                     }
7620                                                  
7621  ***      0                                         return;
7622                                                  }
7623                                                  
7624                                                  sub report {
7625  ***      0                    0                    my ( $self, %args ) = @_;
7626  ***      0                                         my @required_args = qw(hosts);
7627  ***      0                                         foreach my $arg ( @required_args ) {
7628  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
7629                                                     }
7630  ***      0                                         my ($hosts) = @args{@required_args};
7631                                                  
7632  ***      0      0                                  return unless keys %{$self->{diffs}};
      ***      0                                      
7633                                                  
7634  ***      0                                         my $query_id_col = {
7635                                                        name        => 'Query ID',
7636                                                     };
7637  ***      0                                         my @host_cols = map {
7638  ***      0                                            my $col = { name => $_->{name} };
7639  ***      0                                            $col;
7640                                                     } @$hosts;
7641                                                  
7642  ***      0                                         my @reports;
7643  ***      0                                         foreach my $diff ( qw(checksums col_vals row_counts) ) {
7644  ***      0                                            my $report = "_report_diff_$diff";
7645  ***      0                                            push @reports, $self->$report(
7646                                                           query_id_col => $query_id_col,
7647                                                           host_cols    => \@host_cols,
7648                                                           %args
7649                                                        );
7650                                                     }
7651                                                  
7652  ***      0                                         return join("\n", @reports);
7653                                                  }
7654                                                  
7655                                                  sub _report_diff_checksums {
7656  ***      0                    0                    my ( $self, %args ) = @_;
7657  ***      0                                         my @required_args = qw(query_id_col host_cols);
7658  ***      0                                         foreach my $arg ( @required_args ) {
7659  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
7660                                                     }
7661                                                  
7662  ***      0                                         my $get_id = $self->{get_id};
7663                                                  
7664  ***      0      0                                  return unless keys %{$self->{diffs}->{checksums}};
      ***      0                                      
7665                                                  
7666  ***      0                                         my $report = new ReportFormatter();
7667  ***      0                                         $report->set_title('Checksum differences');
7668  ***      0                                         $report->set_columns(
7669                                                        $args{query_id_col},
7670  ***      0                                            @{$args{host_cols}},
7671                                                     );
7672                                                  
7673  ***      0                                         my $diff_checksums = $self->{diffs}->{checksums};
7674  ***      0                                         foreach my $item ( sort keys %$diff_checksums ) {
7675  ***      0                                            map {
7676  ***      0                                               $report->add_line(
7677                                                              $get_id->($item) . '-' . $_,
7678  ***      0                                                  @{$diff_checksums->{$item}->{$_}},
7679                                                           );
7680  ***      0                                            } sort { $a <=> $b } keys %{$diff_checksums->{$item}};
      ***      0                                      
7681                                                     }
7682                                                  
7683  ***      0                                         return $report->get_report();
7684                                                  }
7685                                                  
7686                                                  sub _report_diff_col_vals {
7687  ***      0                    0                    my ( $self, %args ) = @_;
7688  ***      0                                         my @required_args = qw(query_id_col host_cols);
7689  ***      0                                         foreach my $arg ( @required_args ) {
7690  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
7691                                                     }
7692                                                  
7693  ***      0                                         my $get_id = $self->{get_id};
7694                                                  
7695  ***      0      0                                  return unless keys %{$self->{diffs}->{col_vals}};
      ***      0                                      
7696                                                  
7697  ***      0                                         my $report = new ReportFormatter();
7698  ***      0                                         $report->set_title('Column value differences');
7699  ***      0                                         $report->set_columns(
7700                                                        $args{query_id_col},
7701                                                        {
7702                                                           name => 'Column'
7703                                                        },
7704  ***      0                                            @{$args{host_cols}},
7705                                                     );
7706  ***      0                                         my $diff_col_vals = $self->{diffs}->{col_vals};
7707  ***      0                                         foreach my $item ( sort keys %$diff_col_vals ) {
7708  ***      0                                            foreach my $sampleno (sort {$a <=> $b} keys %{$diff_col_vals->{$item}}) {
      ***      0                                      
      ***      0                                      
7709  ***      0                                               map {
7710  ***      0                                                  $report->add_line(
7711                                                                 $get_id->($item) . '-' . $sampleno,
7712                                                                 @$_,
7713                                                              );
7714  ***      0                                               } @{$diff_col_vals->{$item}->{$sampleno}};
7715                                                        }
7716                                                     }
7717                                                  
7718  ***      0                                         return $report->get_report();
7719                                                  }
7720                                                  
7721                                                  sub _report_diff_row_counts {
7722  ***      0                    0                    my ( $self, %args ) = @_;
7723  ***      0                                         my @required_args = qw(query_id_col hosts);
7724  ***      0                                         foreach my $arg ( @required_args ) {
7725  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
7726                                                     }
7727                                                  
7728  ***      0                                         my $get_id = $self->{get_id};
7729                                                  
7730  ***      0      0                                  return unless keys %{$self->{diffs}->{row_counts}};
      ***      0                                      
7731                                                  
7732  ***      0                                         my $report = new ReportFormatter();
7733  ***      0                                         $report->set_title('Row count differences');
7734  ***      0                                         $report->set_columns(
7735                                                        $args{query_id_col},
7736                                                        map {
7737  ***      0                                               my $col = { name => $_->{name}, right_justify => 1  };
7738  ***      0                                               $col;
7739  ***      0                                            } @{$args{hosts}},
7740                                                     );
7741                                                  
7742  ***      0                                         my $diff_row_counts = $self->{diffs}->{row_counts};
7743  ***      0                                         foreach my $item ( sort keys %$diff_row_counts ) {
7744  ***      0                                            map {
7745  ***      0                                               $report->add_line(
7746                                                              $get_id->($item) . '-' . $_,
7747  ***      0                                                  @{$diff_row_counts->{$item}->{$_}},
7748                                                           );
7749  ***      0                                            } sort { $a <=> $b } keys %{$diff_row_counts->{$item}};
      ***      0                                      
7750                                                     }
7751                                                  
7752  ***      0                                         return $report->get_report();
7753                                                  }
7754                                                  
7755                                                  sub samples {
7756  ***      0                    0                    my ( $self, $item ) = @_;
7757  ***      0      0                                  return unless $item;
7758  ***      0                                         my @samples;
7759  ***      0                                         foreach my $sampleno ( keys %{$self->{samples}->{$item}} ) {
      ***      0                                      
7760  ***      0                                            push @samples, $sampleno, $self->{samples}->{$item}->{$sampleno};
7761                                                     }
7762  ***      0                                         return @samples;
7763                                                  }
7764                                                  
7765                                                  sub reset {
7766  ***      0                    0                    my ( $self ) = @_;
7767  ***      0                                         $self->{diffs}   = {};
7768  ***      0                                         $self->{samples} = {};
7769  ***      0                                         return;
7770                                                  }
7771                                                  
7772                                                  sub _d {
7773  ***      0                    0                    my ($package, undef, $line) = caller 0;
7774  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
7775  ***      0                                              map { defined $_ ? $_ : 'undef' }
7776                                                          @_;
7777  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
7778                                                  }
7779                                                  
7780                                                  1;
7781                                                  
7782                                                  # ###########################################################################
7783                                                  # End CompareResults package
7784                                                  # ###########################################################################
7785                                                  
7786                                                  # ###########################################################################
7787                                                  # CompareQueryTimes package 5285
7788                                                  # ###########################################################################
7789                                                  package CompareQueryTimes;
7790                                                  
7791           5                    5            59   use strict;
               5                                 17   
               5                                 40   
7792           5                    5            39   use warnings FATAL => 'all';
               5                                 12   
               5                                 42   
7793           5                    5            32   use English qw(-no_match_vars);
               5                                 13   
               5                                 44   
7794           5                    5            47   use POSIX qw(floor);
               5                                 14   
               5                                 40   
7795                                                  
7796                                                  Transformers->import(qw(micro_t));
7797                                                  
7798  ***      5            50      5            39   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 14   
               5                                 91   
7799                                                  
7800           5                    5            34   use Data::Dumper;
               5                                 15   
               5                                 34   
7801                                                  $Data::Dumper::Indent    = 1;
7802                                                  $Data::Dumper::Sortkeys  = 1;
7803                                                  $Data::Dumper::Quotekeys = 0;
7804                                                  
7805                                                  my @bucket_threshold = qw(500 100  100   500 50   50    20 1   );
7806                                                  
7807                                                  sub new {
7808  ***      0                    0                    my ( $class, %args ) = @_;
7809  ***      0                                         my @required_args = qw(get_id);
7810  ***      0                                         foreach my $arg ( @required_args ) {
7811  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
7812                                                     }
7813  ***      0                                         my $self = {
7814                                                        %args,
7815                                                        diffs   => {},
7816                                                        samples => {},
7817                                                     };
7818  ***      0                                         return bless $self, $class;
7819                                                  }
7820                                                  
7821                                                  sub before_execute {
7822  ***      0                    0                    my ( $self, %args ) = @_;
7823  ***      0                                         my @required_args = qw(event);
7824  ***      0                                         foreach my $arg ( @required_args ) {
7825  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
7826                                                     }
7827  ***      0                                         return $args{event};
7828                                                  }
7829                                                  
7830                                                  sub execute {
7831  ***      0                    0                    my ( $self, %args ) = @_;
7832  ***      0                                         my @required_args = qw(event dbh);
7833  ***      0                                         foreach my $arg ( @required_args ) {
7834  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
7835                                                     }
7836  ***      0                                         my ($event, $dbh) = @args{@required_args};
7837                                                  
7838  ***      0      0                                  if ( exists $event->{Query_time} ) {
7839  ***      0                                            MKDEBUG && _d('Query already executed');
7840  ***      0                                            return $event;
7841                                                     }
7842                                                  
7843  ***      0                                         MKDEBUG && _d('Executing query');
7844  ***      0                                         my $query = $event->{arg};
7845  ***      0                                         my ( $start, $end, $query_time );
7846                                                  
7847  ***      0                                         $event->{Query_time} = 0;
7848  ***      0                                         eval {
7849  ***      0                                            $start = time();
7850  ***      0                                            $dbh->do($query);
7851  ***      0                                            $end   = time();
7852  ***      0                                            $query_time = sprintf '%.6f', $end - $start;
7853                                                     };
7854  ***      0      0                                  die "Failed to execute query: $EVAL_ERROR" if $EVAL_ERROR;
7855                                                  
7856  ***      0                                         $event->{Query_time} = $query_time;
7857                                                  
7858  ***      0                                         return $event;
7859                                                  }
7860                                                  
7861                                                  sub after_execute {
7862  ***      0                    0                    my ( $self, %args ) = @_;
7863  ***      0                                         my @required_args = qw(event);
7864  ***      0                                         foreach my $arg ( @required_args ) {
7865  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
7866                                                     }
7867  ***      0                                         return $args{event};
7868                                                  }
7869                                                  
7870                                                  sub compare {
7871  ***      0                    0                    my ( $self, %args ) = @_;
7872  ***      0                                         my @required_args = qw(events);
7873  ***      0                                         foreach my $arg ( @required_args ) {
7874  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
7875                                                     }
7876  ***      0                                         my ($events) = @args{@required_args};
7877                                                  
7878  ***      0                                         my $different_query_times = 0;
7879                                                  
7880  ***      0                                         my $event0   = $events->[0];
7881  ***      0             0                           my $item     = $event0->{fingerprint} || $event0->{arg};
7882  ***      0             0                           my $sampleno = $event0->{sampleno}    || 0;
7883  ***      0             0                           my $t0       = $event0->{Query_time}  || 0;
7884  ***      0                                         my $b0       = bucket_for($t0);
7885                                                  
7886  ***      0                                         my $n_events = scalar @$events;
7887  ***      0                                         foreach my $i ( 1..($n_events-1) ) {
7888  ***      0                                            my $event = $events->[$i];
7889  ***      0                                            my $t     = $event->{Query_time};
7890  ***      0                                            my $b     = bucket_for($t);
7891                                                  
7892  ***      0      0                                     if ( $b0 != $b ) {
7893  ***      0                                               my $diff = abs($t0 - $t);
7894  ***      0                                               $different_query_times++;
7895  ***      0                                               $self->{diffs}->{big}->{$item}->{$sampleno}
7896                                                              = [ micro_t($t0), micro_t($t), micro_t($diff) ];
7897  ***      0                                               $self->{samples}->{$item}->{$sampleno} = $event0->{arg};
7898                                                        }
7899                                                        else {
7900  ***      0                                               my $inc = percentage_increase($t0, $t);
7901  ***      0      0                                        if ( $inc >= $bucket_threshold[$b0] ) {
7902  ***      0                                                  $different_query_times++;
7903  ***      0                                                  $self->{diffs}->{in_bucket}->{$item}->{$sampleno}
7904                                                                 = [ micro_t($t0), micro_t($t), $inc, $bucket_threshold[$b0] ];
7905  ***      0                                                  $self->{samples}->{$item}->{$sampleno} = $event0->{arg};
7906                                                           }
7907                                                        }
7908                                                     }
7909                                                  
7910                                                     return (
7911  ***      0                                            different_query_times => $different_query_times,
7912                                                     );
7913                                                  }
7914                                                  
7915                                                  sub bucket_for {
7916  ***      0                    0                    my ( $val ) = @_;
7917  ***      0      0                                  die "I need a val" unless defined $val;
7918  ***      0      0                                  return 0 if $val == 0;
7919  ***      0                                         my $bucket = floor(log($val) / log(10)) + 6;
7920  ***      0      0                                  $bucket = $bucket > 7 ? 7 : $bucket < 0 ? 0 : $bucket;
      ***             0                               
7921  ***      0                                         return $bucket;
7922                                                  }
7923                                                  
7924                                                  sub percentage_increase {
7925  ***      0                    0                    my ( $x, $y ) = @_;
7926  ***      0      0                                  return 0 if $x == $y;
7927                                                  
7928  ***      0      0                                  if ( $x > $y ) {
7929  ***      0                                            my $z = $y;
7930  ***      0                                               $y = $x;
7931  ***      0                                               $x = $z;
7932                                                     }
7933                                                  
7934  ***      0      0                                  if ( $x == 0 ) {
7935  ***      0                                            return 1000;  # This should trigger all buckets' thresholds.
7936                                                     }
7937                                                  
7938  ***      0                                         return sprintf '%.2f', (($y - $x) / $x) * 100;
7939                                                  }
7940                                                  
7941                                                  sub report {
7942  ***      0                    0                    my ( $self, %args ) = @_;
7943  ***      0                                         my @required_args = qw(hosts);
7944  ***      0                                         foreach my $arg ( @required_args ) {
7945  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
7946                                                     }
7947  ***      0                                         my ($hosts) = @args{@required_args};
7948                                                  
7949  ***      0      0                                  return unless keys %{$self->{diffs}};
      ***      0                                      
7950                                                  
7951  ***      0                                         my $query_id_col = {
7952                                                        name        => 'Query ID',
7953                                                     };
7954  ***      0                                         my @host_cols = map {
7955  ***      0                                            my $col = { name => $_->{name} };
7956  ***      0                                            $col;
7957                                                     } @$hosts;
7958                                                  
7959  ***      0                                         my @reports;
7960  ***      0                                         foreach my $diff ( qw(big in_bucket) ) {
7961  ***      0                                            my $report = "_report_diff_$diff";
7962  ***      0                                            push @reports, $self->$report(
7963                                                           query_id_col => $query_id_col,
7964                                                           host_cols    => \@host_cols,
7965                                                           %args
7966                                                        );
7967                                                     }
7968                                                  
7969  ***      0                                         return join("\n", @reports);
7970                                                  }
7971                                                  
7972                                                  sub _report_diff_big {
7973  ***      0                    0                    my ( $self, %args ) = @_;
7974  ***      0                                         my @required_args = qw(query_id_col hosts);
7975  ***      0                                         foreach my $arg ( @required_args ) {
7976  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
7977                                                     }
7978                                                  
7979  ***      0                                         my $get_id = $self->{get_id};
7980                                                  
7981  ***      0      0                                  return unless keys %{$self->{diffs}->{big}};
      ***      0                                      
7982                                                  
7983  ***      0                                         my $report = new ReportFormatter();
7984  ***      0                                         $report->set_title('Big query time differences');
7985  ***      0                                         $report->set_columns(
7986                                                        $args{query_id_col},
7987                                                        map {
7988  ***      0                                               my $col = { name => $_->{name}, right_justify => 1  };
7989  ***      0                                               $col;
7990  ***      0                                            } @{$args{hosts}},
7991                                                        { name => 'Difference', right_justify => 1 },
7992                                                     );
7993                                                  
7994  ***      0                                         my $diff_big = $self->{diffs}->{big};
7995  ***      0                                         foreach my $item ( sort keys %$diff_big ) {
7996  ***      0                                            map {
7997  ***      0                                               $report->add_line(
7998                                                              $get_id->($item) . '-' . $_,
7999  ***      0                                                  @{$diff_big->{$item}->{$_}},
8000                                                           );
8001  ***      0                                            } sort { $a <=> $b } keys %{$diff_big->{$item}};
      ***      0                                      
8002                                                     }
8003                                                  
8004  ***      0                                         return $report->get_report();
8005                                                  }
8006                                                  
8007                                                  sub _report_diff_in_bucket {
8008  ***      0                    0                    my ( $self, %args ) = @_;
8009  ***      0                                         my @required_args = qw(query_id_col hosts);
8010  ***      0                                         foreach my $arg ( @required_args ) {
8011  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
8012                                                     }
8013                                                  
8014  ***      0                                         my $get_id = $self->{get_id};
8015                                                  
8016  ***      0      0                                  return unless keys %{$self->{diffs}->{in_bucket}};
      ***      0                                      
8017                                                  
8018  ***      0                                         my $report = new ReportFormatter();
8019  ***      0                                         $report->set_title('Significant query time differences');
8020  ***      0                                         $report->set_columns(
8021                                                        $args{query_id_col},
8022                                                        map {
8023  ***      0                                               my $col = { name => $_->{name}, right_justify => 1  };
8024  ***      0                                               $col;
8025  ***      0                                            } @{$args{hosts}},
8026                                                        { name => '%Increase',  right_justify => 1 },
8027                                                        { name => '%Threshold', right_justify => 1 },
8028                                                     );
8029                                                  
8030  ***      0                                         my $diff_in_bucket = $self->{diffs}->{in_bucket};
8031  ***      0                                         foreach my $item ( sort keys %$diff_in_bucket ) {
8032  ***      0                                            map {
8033  ***      0                                               $report->add_line(
8034                                                              $get_id->($item) . '-' . $_,
8035  ***      0                                                  @{$diff_in_bucket->{$item}->{$_}},
8036                                                           );
8037  ***      0                                            } sort { $a <=> $b } keys %{$diff_in_bucket->{$item}};
      ***      0                                      
8038                                                     }
8039                                                  
8040  ***      0                                         return $report->get_report();
8041                                                  }
8042                                                  
8043                                                  sub samples {
8044  ***      0                    0                    my ( $self, $item ) = @_;
8045  ***      0      0                                  return unless $item;
8046  ***      0                                         my @samples;
8047  ***      0                                         foreach my $sampleno ( keys %{$self->{samples}->{$item}} ) {
      ***      0                                      
8048  ***      0                                            push @samples, $sampleno, $self->{samples}->{$item}->{$sampleno};
8049                                                     }
8050  ***      0                                         return @samples;
8051                                                  }
8052                                                  
8053                                                  sub reset {
8054  ***      0                    0                    my ( $self ) = @_;
8055  ***      0                                         $self->{diffs}   = {};
8056  ***      0                                         $self->{samples} = {};
8057  ***      0                                         return;
8058                                                  }
8059                                                  
8060                                                  sub _d {
8061  ***      0                    0                    my ($package, undef, $line) = caller 0;
8062  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
8063  ***      0                                              map { defined $_ ? $_ : 'undef' }
8064                                                          @_;
8065  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
8066                                                  }
8067                                                  
8068                                                  1;
8069                                                  
8070                                                  # ###########################################################################
8071                                                  # End CompareQueryTimes package
8072                                                  # ###########################################################################
8073                                                  
8074                                                  # ###########################################################################
8075                                                  # CompareWarnings package 5290
8076                                                  # ###########################################################################
8077                                                  package CompareWarnings;
8078                                                  
8079           5                    5            52   use strict;
               5                                 17   
               5                                 43   
8080           5                    5            34   use warnings FATAL => 'all';
               5                                 12   
               5                                 42   
8081           5                    5            32   use English qw(-no_match_vars);
               5                                 13   
               5                                 31   
8082                                                  
8083  ***      5            50      5            45   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 13   
               5                                 88   
8084                                                  
8085           5                    5            35   use Data::Dumper;
               5                                 12   
               5                                 31   
8086                                                  $Data::Dumper::Indent    = 1;
8087                                                  $Data::Dumper::Sortkeys  = 1;
8088                                                  $Data::Dumper::Quotekeys = 0;
8089                                                  
8090                                                  sub new {
8091  ***      0                    0                    my ( $class, %args ) = @_;
8092  ***      0                                         my @required_args = qw(get_id Quoter QueryParser);
8093  ***      0                                         foreach my $arg ( @required_args ) {
8094  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
8095                                                     }
8096  ***      0                                         my $self = {
8097                                                        %args,
8098                                                        diffs   => {},
8099                                                        samples => {},
8100                                                     };
8101  ***      0                                         return bless $self, $class;
8102                                                  }
8103                                                  
8104                                                  sub before_execute {
8105  ***      0                    0                    my ( $self, %args ) = @_;
8106  ***      0                                         my @required_args = qw(event dbh);
8107  ***      0                                         foreach my $arg ( @required_args ) {
8108  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
8109                                                     }
8110  ***      0                                         my ($event, $dbh) = @args{@required_args};
8111  ***      0                                         my $sql;
8112                                                  
8113  ***      0      0                                  return $event unless $self->{'clear-warnings'};
8114                                                  
8115  ***      0      0                                  if ( my $tbl = $self->{'clear-warnings-table'} ) {
8116  ***      0                                            $sql = "SELECT * FROM $tbl LIMIT 1";
8117  ***      0                                            MKDEBUG && _d($sql);
8118  ***      0                                            eval {
8119  ***      0                                               $dbh->do($sql);
8120                                                        };
8121  ***      0      0                                     die "Failed to SELECT from clear warnings table: $EVAL_ERROR"
8122                                                           if $EVAL_ERROR;
8123                                                     }
8124                                                     else {
8125  ***      0                                            my $q    = $self->{Quoter};
8126  ***      0                                            my $qp   = $self->{QueryParser};
8127  ***      0                                            my @tbls = $qp->get_tables($event->{arg});
8128  ***      0                                            my $ok   = 0;
8129                                                        TABLE:
8130  ***      0                                            foreach my $tbl ( @tbls ) {
8131  ***      0                                               $sql = "SELECT * FROM $tbl LIMIT 1";
8132  ***      0                                               MKDEBUG && _d($sql);
8133  ***      0                                               eval {
8134  ***      0                                                  $dbh->do($sql);
8135                                                           };
8136  ***      0      0                                        if ( $EVAL_ERROR ) {
8137  ***      0                                                  MKDEBUG && _d('Failed to clear warnings');
8138                                                           }
8139                                                           else {
8140  ***      0                                                  MKDEBUG && _d('Cleared warnings');
8141  ***      0                                                  $ok = 1;
8142  ***      0                                                  last TABLE;
8143                                                           }
8144                                                        }
8145  ***      0      0                                     die "Failed to clear warnings"
8146                                                           unless $ok;
8147                                                     }
8148                                                  
8149  ***      0                                         return $event;
8150                                                  }
8151                                                  
8152                                                  sub execute {
8153  ***      0                    0                    my ( $self, %args ) = @_;
8154  ***      0                                         my @required_args = qw(event dbh);
8155  ***      0                                         foreach my $arg ( @required_args ) {
8156  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
8157                                                     }
8158  ***      0                                         my ($event, $dbh) = @args{@required_args};
8159                                                  
8160  ***      0      0                                  if ( exists $event->{Query_time} ) {
8161  ***      0                                            MKDEBUG && _d('Query already executed');
8162  ***      0                                            return $event;
8163                                                     }
8164                                                  
8165  ***      0                                         MKDEBUG && _d('Executing query');
8166  ***      0                                         my $query = $event->{arg};
8167  ***      0                                         my ( $start, $end, $query_time );
8168                                                  
8169  ***      0                                         $event->{Query_time} = 0;
8170  ***      0                                         eval {
8171  ***      0                                            $start = time();
8172  ***      0                                            $dbh->do($query);
8173  ***      0                                            $end   = time();
8174  ***      0                                            $query_time = sprintf '%.6f', $end - $start;
8175                                                     };
8176  ***      0      0                                  die "Failed to execute query: $EVAL_ERROR" if $EVAL_ERROR;
8177                                                  
8178  ***      0                                         $event->{Query_time} = $query_time;
8179                                                  
8180  ***      0                                         return $event;
8181                                                  }
8182                                                  
8183                                                  sub after_execute {
8184  ***      0                    0                    my ( $self, %args ) = @_;
8185  ***      0                                         my @required_args = qw(event dbh);
8186  ***      0                                         foreach my $arg ( @required_args ) {
8187  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
8188                                                     }
8189  ***      0                                         my ($event, $dbh) = @args{@required_args};
8190                                                  
8191  ***      0                                         my $warnings;
8192  ***      0                                         my $warning_count;
8193  ***      0                                         eval {
8194  ***      0                                            $warnings      = $dbh->selectall_hashref('SHOW WARNINGS', 'Code');
8195  ***      0                                            $warning_count = $dbh->selectcol_arrayref('SELECT @@warning_count')->[0];
8196                                                     };
8197  ***      0      0                                  die "Failed to SHOW WARNINGS: $EVAL_ERROR"
8198                                                        if $EVAL_ERROR;
8199                                                  
8200  ***      0                                         map {
8201  ***      0                                            $_->{Message} =~ s/Out of range value adjusted/Out of range value/;
8202                                                     } values %$warnings;
8203  ***      0             0                           $event->{warning_count} = $warning_count || 0;
8204  ***      0                                         $event->{warnings}      = $warnings;
8205                                                  
8206  ***      0                                         return $event;
8207                                                  }
8208                                                  
8209                                                  sub compare {
8210  ***      0                    0                    my ( $self, %args ) = @_;
8211  ***      0                                         my @required_args = qw(events);
8212  ***      0                                         foreach my $arg ( @required_args ) {
8213  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
8214                                                     }
8215  ***      0                                         my ($events) = @args{@required_args};
8216                                                  
8217  ***      0                                         my $different_warning_counts = 0;
8218  ***      0                                         my $different_warnings       = 0;
8219  ***      0                                         my $different_warning_levels = 0;
8220                                                  
8221  ***      0                                         my $event0   = $events->[0];
8222  ***      0             0                           my $item     = $event0->{fingerprint} || $event0->{arg};
8223  ***      0             0                           my $sampleno = $event0->{sampleno} || 0;
8224  ***      0                                         my $w0       = $event0->{warnings};
8225                                                  
8226  ***      0                                         my $n_events = scalar @$events;
8227  ***      0                                         foreach my $i ( 1..($n_events-1) ) {
8228  ***      0                                            my $event = $events->[$i];
8229                                                  
8230  ***      0      0      0                              if ( ($event0->{warning_count} || 0) != ($event->{warning_count} || 0) ) {
      ***                    0                        
8231  ***      0                                               MKDEBUG && _d('Warning counts differ:',
8232                                                              $event0->{warning_count}, $event->{warning_count});
8233  ***      0                                               $different_warning_counts++;
8234  ***      0             0                                 $self->{diffs}->{warning_counts}->{$item}->{$sampleno}
      ***                    0                        
8235                                                              = [ $event0->{warning_count} || 0, $event->{warning_count} || 0 ];
8236  ***      0                                               $self->{samples}->{$item}->{$sampleno} = $event0->{arg};
8237                                                        }
8238                                                  
8239  ***      0                                            my $w = $event->{warnings};
8240                                                  
8241  ***      0      0      0                              next if !$w0 && !$w;
8242                                                  
8243  ***      0                                            my %new_warnings;
8244  ***      0                                            foreach my $code ( keys %$w0 ) {
8245  ***      0      0                                        if ( exists $w->{$code} ) {
8246  ***      0      0                                           if ( $w->{$code}->{Level} ne $w0->{$code}->{Level} ) {
8247  ***      0                                                     MKDEBUG && _d('Warning levels differ:',
8248                                                                    $w0->{$code}->{Level}, $w->{$code}->{Level});
8249  ***      0                                                     $different_warning_levels++;
8250  ***      0                                                     $self->{diffs}->{levels}->{$item}->{$sampleno}
8251                                                                    = [ $code, $w0->{$code}->{Level}, $w->{$code}->{Level},
8252                                                                        $w->{$code}->{Message} ];
8253  ***      0                                                     $self->{samples}->{$item}->{$sampleno} = $event0->{arg};
8254                                                              }
8255  ***      0                                                  delete $w->{$code};
8256                                                           }
8257                                                           else {
8258  ***      0                                                  MKDEBUG && _d('Warning gone:', $w0->{$code}->{Message});
8259  ***      0                                                  $different_warnings++;
8260  ***      0                                                  $self->{diffs}->{warnings}->{$item}->{$sampleno}
8261                                                                 = [ 0, $code, $w0->{$code}->{Message} ];
8262  ***      0                                                  $self->{samples}->{$item}->{$sampleno} = $event0->{arg};
8263                                                           }
8264                                                        }
8265                                                  
8266  ***      0                                            foreach my $code ( keys %$w ) {
8267  ***      0                                               MKDEBUG && _d('Warning new:', $w->{$code}->{Message});
8268  ***      0                                               $different_warnings++;
8269  ***      0                                               $self->{diffs}->{warnings}->{$item}->{$sampleno}
8270                                                              = [ $i, $code, $w->{$code}->{Message} ];
8271  ***      0                                               $self->{samples}->{$item}->{$sampleno} = $event0->{arg};
8272                                                        }
8273                                                  
8274  ***      0                                            delete $event->{warnings};
8275                                                     }
8276  ***      0                                         delete $event0->{warnings};
8277                                                  
8278                                                     return (
8279  ***      0                                            different_warning_counts => $different_warning_counts,
8280                                                        different_warnings       => $different_warnings,
8281                                                        different_warning_levels => $different_warning_levels,
8282                                                     );
8283                                                  }
8284                                                  
8285                                                  sub report {
8286  ***      0                    0                    my ( $self, %args ) = @_;
8287  ***      0                                         my @required_args = qw(hosts);
8288  ***      0                                         foreach my $arg ( @required_args ) {
8289  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
8290                                                     }
8291  ***      0                                         my ($hosts) = @args{@required_args};
8292                                                  
8293  ***      0      0                                  return unless keys %{$self->{diffs}};
      ***      0                                      
8294                                                  
8295  ***      0                                         my $query_id_col = {
8296                                                        name        => 'Query ID',
8297                                                     };
8298  ***      0                                         my @host_cols = map {
8299  ***      0                                            my $col = { name => $_->{name} };
8300  ***      0                                            $col;
8301                                                     } @$hosts;
8302                                                  
8303  ***      0                                         my @reports;
8304  ***      0                                         foreach my $diff ( qw(warnings levels warning_counts) ) {
8305  ***      0                                            my $report = "_report_diff_$diff";
8306  ***      0                                            push @reports, $self->$report(
8307                                                           query_id_col => $query_id_col,
8308                                                           host_cols    => \@host_cols,
8309                                                           %args
8310                                                        );
8311                                                     }
8312                                                  
8313  ***      0                                         return join("\n", @reports);
8314                                                  }
8315                                                  
8316                                                  sub _report_diff_warnings {
8317  ***      0                    0                    my ( $self, %args ) = @_;
8318  ***      0                                         my @required_args = qw(query_id_col hosts);
8319  ***      0                                         foreach my $arg ( @required_args ) {
8320  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
8321                                                     }
8322                                                  
8323  ***      0                                         my $get_id = $self->{get_id};
8324                                                  
8325  ***      0      0                                  return unless keys %{$self->{diffs}->{warnings}};
      ***      0                                      
8326                                                  
8327  ***      0                                         my $report = new ReportFormatter(long_last_column => 1);
8328  ***      0                                         $report->set_title('New warnings');
8329  ***      0                                         $report->set_columns(
8330                                                        $args{query_id_col},
8331                                                        { name => 'Host', },
8332                                                        { name => 'Code', right_justify => 1 },
8333                                                        { name => 'Message' },
8334                                                     );
8335                                                  
8336  ***      0                                         my $diff_warnings = $self->{diffs}->{warnings};
8337  ***      0                                         foreach my $item ( sort keys %$diff_warnings ) {
8338  ***      0                                            map {
8339  ***      0                                               my ($hostno, $code, $message) = @{$diff_warnings->{$item}->{$_}};
      ***      0                                      
8340  ***      0                                               $report->add_line(
8341                                                              $get_id->($item) . '-' . $_,
8342                                                              $args{hosts}->[$hostno]->{name}, $code, $message,
8343                                                           );
8344  ***      0                                            } sort { $a <=> $b } keys %{$diff_warnings->{$item}};
      ***      0                                      
8345                                                     }
8346                                                  
8347  ***      0                                         return $report->get_report();
8348                                                  }
8349                                                  
8350                                                  sub _report_diff_levels {
8351  ***      0                    0                    my ( $self, %args ) = @_;
8352  ***      0                                         my @required_args = qw(query_id_col hosts);
8353  ***      0                                         foreach my $arg ( @required_args ) {
8354  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
8355                                                     }
8356                                                  
8357  ***      0                                         my $get_id = $self->{get_id};
8358                                                  
8359  ***      0      0                                  return unless keys %{$self->{diffs}->{levels}};
      ***      0                                      
8360                                                  
8361  ***      0                                         my $report = new ReportFormatter(long_last_column => 1);
8362  ***      0                                         $report->set_title('Warning level differences');
8363  ***      0                                         $report->set_columns(
8364                                                        $args{query_id_col},
8365                                                        { name => 'Code', right_justify => 1 },
8366                                                        map {
8367  ***      0                                               my $col = { name => $_->{name}, right_justify => 1  };
8368  ***      0                                               $col;
8369  ***      0                                            } @{$args{hosts}},
8370                                                        { name => 'Message' },
8371                                                     );
8372                                                  
8373  ***      0                                         my $diff_levels = $self->{diffs}->{levels};
8374  ***      0                                         foreach my $item ( sort keys %$diff_levels ) {
8375  ***      0                                            map {
8376  ***      0                                               $report->add_line(
8377                                                              $get_id->($item) . '-' . $_,
8378  ***      0                                                  @{$diff_levels->{$item}->{$_}},
8379                                                           );
8380  ***      0                                            } sort { $a <=> $b } keys %{$diff_levels->{$item}};
      ***      0                                      
8381                                                     }
8382                                                  
8383  ***      0                                         return $report->get_report();
8384                                                  }
8385                                                  
8386                                                  sub _report_diff_warning_counts {
8387  ***      0                    0                    my ( $self, %args ) = @_;
8388  ***      0                                         my @required_args = qw(query_id_col hosts);
8389  ***      0                                         foreach my $arg ( @required_args ) {
8390  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
8391                                                     }
8392                                                  
8393  ***      0                                         my $get_id = $self->{get_id};
8394                                                  
8395  ***      0      0                                  return unless keys %{$self->{diffs}->{warning_counts}};
      ***      0                                      
8396                                                  
8397  ***      0                                         my $report = new ReportFormatter();
8398  ***      0                                         $report->set_title('Warning count differences');
8399  ***      0                                         $report->set_columns(
8400                                                        $args{query_id_col},
8401                                                        map {
8402  ***      0                                               my $col = { name => $_->{name}, right_justify => 1  };
8403  ***      0                                               $col;
8404  ***      0                                            } @{$args{hosts}},
8405                                                     );
8406                                                  
8407  ***      0                                         my $diff_warning_counts = $self->{diffs}->{warning_counts};
8408  ***      0                                         foreach my $item ( sort keys %$diff_warning_counts ) {
8409  ***      0                                            map {
8410  ***      0                                               $report->add_line(
8411                                                              $get_id->($item) . '-' . $_,
8412  ***      0                                                  @{$diff_warning_counts->{$item}->{$_}},
8413                                                           );
8414  ***      0                                            } sort { $a <=> $b } keys %{$diff_warning_counts->{$item}};
      ***      0                                      
8415                                                     }
8416                                                  
8417  ***      0                                         return $report->get_report();
8418                                                  }
8419                                                  
8420                                                  sub samples {
8421  ***      0                    0                    my ( $self, $item ) = @_;
8422  ***      0      0                                  return unless $item;
8423  ***      0                                         my @samples;
8424  ***      0                                         foreach my $sampleno ( keys %{$self->{samples}->{$item}} ) {
      ***      0                                      
8425  ***      0                                            push @samples, $sampleno, $self->{samples}->{$item}->{$sampleno};
8426                                                     }
8427  ***      0                                         return @samples;
8428                                                  }
8429                                                  
8430                                                  sub reset {
8431  ***      0                    0                    my ( $self ) = @_;
8432  ***      0                                         $self->{diffs}   = {};
8433  ***      0                                         $self->{samples} = {};
8434  ***      0                                         return;
8435                                                  }
8436                                                  
8437                                                  sub _d {
8438  ***      0                    0                    my ($package, undef, $line) = caller 0;
8439  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
8440  ***      0                                              map { defined $_ ? $_ : 'undef' }
8441                                                          @_;
8442  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
8443                                                  }
8444                                                  
8445                                                  1;
8446                                                  
8447                                                  # ###########################################################################
8448                                                  # End CompareWarnings package
8449                                                  # ###########################################################################
8450                                                  
8451                                                  # ###########################################################################
8452                                                  # This is a combination of modules and programs in one -- a runnable module.
8453                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
8454                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
8455                                                  #
8456                                                  # Check at the end of this package for the call to main() which actually runs
8457                                                  # the program.
8458                                                  # ###########################################################################
8459                                                  package mk_upgrade;
8460                                                  
8461           5                    5            59   use English qw(-no_match_vars);
               5                                 17   
               5                                 49   
8462                                                  
8463           5                    5            51   use Data::Dumper;
               5                                 16   
               5                                 36   
8464                                                  $Data::Dumper::Indent    = 1;
8465                                                  $Data::Dumper::Sortkeys  = 1;
8466                                                  $Data::Dumper::Quotekeys = 0;
8467                                                  
8468                                                  Transformers->import(qw(make_checksum));
8469                                                  
8470  ***      5            50      5            39   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               5                                 12   
               5                                 93   
8471                                                  
8472           5                    5            73   use sigtrap 'handler', \&sig_int, 'normal-signals';
               5                                 15   
               5                                 79   
8473                                                  
8474                                                  # Global variables.  Only really essential variables should be here.
8475                                                  my $oktorun = 1;
8476                                                  
8477                                                  sub main {
8478  ***      0                    0                    @ARGV = @_;  # set global ARGV for this package
8479                                                  
8480                                                     # ##########################################################################
8481                                                     # Get configuration information.
8482                                                     # ##########################################################################
8483  ***      0                                         my $dp = new DSNParser();
8484  ***      0                                         my $o  = new OptionParser(
8485                                                        strict      => 0,
8486                                                        dp          => $dp,
8487                                                        prompt      => '[OPTION...] DSN [DSN...] [FILE]',
8488                                                        description => q{compares query execution on two hosts by executing }
8489                                                                     . q{queries in the given file (or STDIN if no file given) }
8490                                                                     . q{and examining the results, errors, warnings, etc. }
8491                                                                     . q{produced on each.},
8492                                                     );
8493  ***      0                                         $o->get_specs();
8494  ***      0                                         $o->get_opts();
8495                                                  
8496  ***      0                                         $dp->prop('set-vars', $o->get('set-vars'));
8497                                                  
8498  ***      0      0                                  if ( !$o->get('help') ) {
8499  ***      0      0                                     if ( @ARGV < 1 ) {
8500  ***      0                                               $o->save_error('Specify at least one host DSN');
8501                                                        }
8502  ***      0      0                                     if ( my $compare_method = $o->get('compare-results-method') ) {
8503  ***      0                                               my %valid_method = qw(checksum 1 rows 1);
8504  ***      0      0                                        $o->save_error("Invalid --compare-results-method: $compare_method")
8505                                                              unless $valid_method{lc $compare_method};
8506                                                        }
8507                                                     }
8508                                                  
8509  ***      0                                         my @files;
8510  ***      0                                         my $hosts        = [];
8511  ***      0                                         my $dsn_defaults = $dp->parse_options($o);
8512  ***      0                                         while ( my $arg = shift @ARGV ) {
8513  ***      0      0                                     if ( !-f $arg ) {
8514  ***      0                                               MKDEBUG && _d($arg, 'is a DSN');
8515  ***      0      0                                        my $dsn = $dp->parse(
8516                                                              $arg,
8517                                                              ($hosts->[-1] ? $hosts->[-1]->{dsn} : undef),
8518                                                              $dsn_defaults
8519                                                           );
8520  ***      0                                               push @$hosts,
8521                                                              {
8522                                                                 dsn  => $dsn,
8523                                                                 name => $dp->as_string($dsn),
8524                                                              };
8525                                                        }
8526                                                        else {
8527  ***      0                                               MKDEBUG && _d($arg, 'is a file');
8528  ***      0                                               push @files, $arg;
8529                                                        }
8530                                                     }
8531  ***      0      0                                  if ( @files == 0 ) {
8532  ***      0                                            push @files, '-'; # Magical STDIN filename.
8533                                                     }
8534                                                  
8535  ***      0      0                                  if ( @$hosts == 0 ) {
8536  ***      0                                            $o->save_error('Specify at least one host DSN');
8537                                                     }
8538                                                  
8539  ***      0                                         $o->usage_or_errors();
8540                                                  
8541  ***      0      0                                  if ( $o->get('explain-hosts') ) {
8542  ***      0                                            foreach my $host ( @$hosts ) {
8543  ***      0                                               print "# DSN: ", $dp->as_string($host->{dsn}), "\n";
8544                                                        }
8545  ***      0                                            return 0;
8546                                                     }
8547                                                  
8548                                                     # ########################################################################
8549                                                     # Connect to the hosts.
8550                                                     # ########################################################################
8551  ***      0                                         foreach my $host ( @$hosts ) {
8552  ***      0                                            $host->{dbh} = get_cxn($dp, $o, $host->{dsn});
8553                                                     }
8554                                                  
8555                                                     # ########################################################################
8556                                                     # Make some common modules.
8557                                                     # ########################################################################
8558  ***      0                                         my $q        = new Quoter();
8559  ***      0                                         my $vp       = new VersionParser();
8560  ***      0                                         my $qp       = new QueryParser();
8561  ***      0                                         my $qr       = new QueryRewriter();
8562  ***      0                                         my $du       = new MySQLDump(cache => 0);
8563  ***      0                                         my $tp       = new TableParser(Quoter => $q);
8564  ***      0                                         my $chunker  = new TableChunker(Quoter => $q, MySQLDump => $du );
8565  ***      0                                         my $nibbler  = new TableNibbler(Quoter => $q, TableParser => $tp );
8566  ***      0                                         my $checksum = new TableChecksum(Quoter => $q, VersionParser => $vp);
8567  ***      0                                         my $syncer   = new TableSyncer(
8568                                                        MasterSlave   => 1,  # I don't think we need this.
8569                                                        Quoter        => $q,
8570                                                        VersionParser => $vp,
8571                                                        TableChecksum => $checksum
8572                                                     );
8573  ***      0                                         my %common_modules  = (
8574                                                        DSNParser     => $dp,
8575                                                        OptionParser  => $o,
8576                                                        QueryParser   => $qp,
8577                                                        QueryRewriter => $qr,
8578                                                        MySQLDump     => $du,
8579                                                        TableParser   => $tp,
8580                                                        Quoter        => $q,
8581                                                        VersionParser => $vp,
8582                                                        TableChunker  => $chunker,
8583                                                        TableNibbler  => $nibbler,
8584                                                        TableChecksum => $checksum,
8585                                                        TableSyncer   => $syncer,
8586                                                     );
8587                                                  
8588                                                     # ########################################################################
8589                                                     # Make compare modules in order.
8590                                                     # ########################################################################
8591  ***      0                                         my $compare = $o->get('compare');
8592  ***      0                                         my @compare_modules;
8593  ***      0      0                                  if ( $compare->{results} ) {
8594  ***      0                                            my $method  = lc $o->get('compare-results-method');
8595  ***      0                                            MKDEBUG && _d('Compare results method:', $method);
8596                                                  
8597  ***      0                                            my $plugins = [];
8598  ***      0      0                                     if ( $method eq 'rows' ) {
8599  ***      0                                               push @$plugins, new TableSyncChunk(%common_modules);
8600  ***      0                                               push @$plugins, new TableSyncNibble(%common_modules);
8601  ***      0                                               push @$plugins, new TableSyncGroupBy(%common_modules);
8602                                                        }
8603                                                  
8604                                                        push @compare_modules, new CompareResults(
8605                                                           method     => $method,
8606                                                           plugins    => $plugins,
8607  ***      0                    0                          get_id     => sub { return make_checksum(@_); },
8608  ***      0                                               'base-dir' => $o->get('base-dir'),
8609                                                           %common_modules,
8610                                                        );
8611                                                     }
8612                                                  
8613  ***      0      0                                  if ( $compare->{query_times} ) {
8614                                                        push @compare_modules, new CompareQueryTimes(
8615  ***      0                    0                          get_id     => sub { return make_checksum(@_); },
8616  ***      0                                               %common_modules,
8617                                                        );
8618                                                     }
8619                                                  
8620  ***      0      0                                  if ( $compare->{warnings} ) {
8621                                                        # SHOW WARNINGS requires MySQL 4.1.
8622  ***      0                                            my $have_warnings = 1;
8623  ***      0                                            foreach my $host ( @$hosts ) {
8624  ***      0      0                                        if ( !$vp->version_ge($host->{dbh}, '4.1.0') ) {
8625  ***      0                                                  warn "Compare warnings DISABLED because host ", $host->{name},
8626                                                                 " MySQL version is less than 4.1";
8627  ***      0                                                  $have_warnings = 0;
8628  ***      0                                                  last;
8629                                                           }
8630                                                        }
8631  ***      0      0                                     if ( $have_warnings ) {
8632                                                           push @compare_modules, new CompareWarnings(
8633                                                              'clear-warnings'       => $o->get('clear-warnings'),
8634                                                              'clear-warnings-table' => $o->get('clear-warnings-table'),
8635  ***      0                    0                             get_id => sub { return make_checksum(@_); },
8636  ***      0                                                  %common_modules,
8637                                                           );
8638                                                        }
8639                                                     }
8640                                                  
8641                                                     # ########################################################################
8642                                                     # Make an EventAggregator for each host and a "meta-aggregator" for all.
8643                                                     # ########################################################################
8644  ***      0                                         my $groupby = 'fingerprint';
8645  ***      0                                         map {
8646  ***      0                                            my $ea = new EventAggregator(
8647                                                           groupby => 'fingerprint',
8648                                                           worst   => 'Query_time',
8649                                                        );
8650  ***      0                                            $_->{ea} = $ea;
8651                                                     } @$hosts;
8652                                                  
8653  ***      0                                         my $meta_ea = new  EventAggregator(
8654                                                        groupby => 'fingerprint',
8655                                                        worst   => 'differences'
8656                                                     );
8657                                                  
8658                                                     # ########################################################################
8659                                                     # Create the event pipeline.
8660                                                     # ########################################################################
8661  ***      0                                         my @callbacks;
8662  ***      0                                         my $stats  = {};
8663  ***      0                                         my $errors = {};
8664  ***      0                                         my $current_db;
8665  ***      0                                         my $tmp_db  = $o->get('temp-database');
8666  ***      0                                         my $tmp_tbl = $o->get('temp-table');
8667                                                  
8668  ***      0      0                                  if ( my $query = $o->get('query') ) {
8669                                                        push @callbacks, sub {
8670  ***      0                    0                          my ( $event, %args ) = @_;
8671  ***      0                                               MKDEBUG && _d('callback: query:', $query);
8672  ***      0      0                                        $args{oktorun}->(0) if $args{oktorun};
8673                                                           return {
8674  ***      0                                                  cmd        => 'Query',
8675                                                              arg        => $query,
8676                                                              pos_in_log => 0,  # for compatibility
8677                                                           };
8678  ***      0                                            };
8679                                                     }
8680                                                     else {
8681  ***      0                                            my $parser = new SlowLogParser();
8682                                                        push @callbacks, sub {
8683  ***      0                    0                          my ( $event, %args ) = @_;
8684  ***      0                                               return $parser->parse_event(%args);
8685  ***      0                                            };
8686                                                     }
8687                                                  
8688                                                     push @callbacks, sub {
8689  ***      0                    0                       my ( $event ) = @_;
8690  ***      0                                            MKDEBUG && _d('callback: check cmd and arg');
8691  ***      0                                            $stats->{events}++;
8692  ***      0      0      0                              if ( ($event->{cmd} || '') ne 'Query' ) {
8693  ***      0                                               MKDEBUG && _d('Skipping non-Query cmd');
8694  ***      0                                               $stats->{not_query}++;
8695  ***      0                                               return;
8696                                                        }
8697  ***      0      0                                     if ( !$event->{arg} ) {
8698  ***      0                                               MKDEBUG && _d('Skipping empty arg');
8699  ***      0                                               $stats->{empty_query}++;
8700  ***      0                                               return;
8701                                                        }
8702  ***      0                                            return $event;
8703  ***      0                                         };
8704                                                  
8705                                                     # User-defined filter.
8706  ***      0      0                                  if ( $o->get('filter') ) {
8707  ***      0                                            my $filter = $o->get('filter');
8708  ***      0      0      0                              if ( -f $filter && -r $filter ) {
8709  ***      0                                               MKDEBUG && _d('Reading file', $filter, 'for --filter code');
8710  ***      0      0                                        open my $fh, "<", $filter or die "Cannot open $filter: $OS_ERROR";
8711  ***      0                                               $filter = do { local $/ = undef; <$fh> };
      ***      0                                      
      ***      0                                      
8712  ***      0                                               close $fh;
8713                                                        }
8714                                                        else {
8715  ***      0                                               $filter = "( $filter )";  # issue 565
8716                                                        }
8717  ***      0                                            my $code   = "sub { MKDEBUG && _d('callback: filter');  my(\$event) = shift; $filter && return \$event; };";
8718  ***      0                                            MKDEBUG && _d('--filter code:', $code);
8719  ***      0      0                                     my $sub = eval $code
8720                                                           or die "Error compiling --filter code: $code\n$EVAL_ERROR";
8721  ***      0                                            push @callbacks, $sub;
8722                                                     }
8723                                                  
8724  ***      0      0                                  if ( $o->get('convert-to-select') ) {
8725                                                        push @callbacks, sub {
8726  ***      0                    0                          my ( $event ) = @_;
8727  ***      0                                               MKDEBUG && _d('callback: convert to select');
8728  ***      0      0                                        return $event if $event->{arg} =~ m/(?:^SELECT|(?:\*\/\s*SELECT))/i;
8729  ***      0                                               my $new_arg = $qr->convert_to_select($event->{arg});
8730  ***      0      0                                        if ( $new_arg =~ m/^SELECT/i ) {
8731  ***      0                                                  $stats->{convert_to_select_ok}++;
8732  ***      0                                                  $event->{original_arg} = $event->{arg};
8733  ***      0                                                  $event->{arg}          = $new_arg;
8734  ***      0                                                  return $event;
8735                                                           }
8736  ***      0                                               MKDEBUG && _d('Convert to SELECT failed:', $event->{arg});
8737  ***      0                                               $stats->{convert_to_select_failed}++;
8738  ***      0                                               return;
8739  ***      0                                            };
8740                                                     }
8741                                                     else {
8742                                                        push @callbacks, sub {
8743  ***      0                    0                          my ( $event ) = @_;
8744  ***      0                                               MKDEBUG && _d('callback: filter non-select');
8745  ***      0      0                                        if ( $event->{arg} !~ m/(?:^SELECT|(?:\*\/\s*SELECT))/i ) {
8746  ***      0                                                  MKDEBUG && _d('Skipping non-SELECT query');
8747  ***      0                                                  $stats->{not_select}++;
8748  ***      0                                                  return;
8749                                                           }
8750  ***      0                                               return $event;
8751  ***      0                                            };
8752                                                     }
8753                                                  
8754                                                     # Do this callback before the fingerprint and sampleno attribs are added.
8755  ***      0                                         my %allowed_attribs = qw(arg 1 db 1 sampleno 1 pos_in_log 1 original_arg 1);
8756                                                     push @callbacks, sub {
8757  ***      0                    0                       my ( $event ) = @_;
8758  ***      0                                            MKDEBUG && _d('callback: remove not-allowed attributes');
8759                                                        # Events will have a lot of attribs from the log that we want
8760                                                        # to remove because 1) we don't need them and 2) we want to avoid
8761                                                        # attrib conflicts (e.g. there's probably a Query_time from the
8762                                                        # log but the compare modules add a Query_time attrib, too).
8763  ***      0      0                                     map { delete $event->{$_} unless $allowed_attribs{$_} } keys %$event;
      ***      0                                      
8764  ***      0                                            return $event;
8765  ***      0                                         };
8766                                                  
8767                                                     push @callbacks, sub {
8768  ***      0                    0                       my ( $event ) = @_;
8769  ***      0                                            MKDEBUG && _d('callback: fingerprint');
8770  ***      0                                            $event->{fingerprint} = $qr->fingerprint($event->{arg});
8771  ***      0                                            return $event;
8772  ***      0                                         };
8773                                                  
8774  ***      0                                         my %samples;
8775  ***      0                                         my %samplenos;
8776                                                     push @callbacks, sub {
8777  ***      0                    0                       my ( $event ) = @_;
8778  ***      0                                            MKDEBUG && _d('callback: sampleno');
8779  ***      0                                            $event->{sampleno} = ++$samplenos{$event->{$groupby}};
8780  ***      0                                            MKDEBUG && _d('Event sampleno', $event->{sampleno});
8781  ***      0                                            return $event;
8782  ***      0                                         };
8783                                                  
8784                                                     # Keep the default database update-to-date.  This helps when queries
8785                                                     # don't use db-qualified tables.
8786                                                     push @callbacks, sub {
8787  ***      0                    0                       my ( $event ) = @_;
8788  ***      0                                            MKDEBUG && _d('callback: current db');
8789  ***      0             0                              my $db = $event->{db} || $event->{Schema} || $hosts->[0]->{dsn}->{D};
      ***                    0                        
8790  ***      0      0      0                              if ( $db && (!$current_db || $db ne $current_db) ) {
      ***                    0                        
8791  ***      0                                               my $sql = "USE `$db`";
8792  ***      0                                               MKDEBUG && _d($sql);
8793  ***      0                                               eval {
8794  ***      0                                                  map { $_->{dbh}->do($sql); } @$hosts;
      ***      0                                      
8795                                                           };
8796  ***      0      0                                        if ( $EVAL_ERROR ) {
8797  ***      0                                                  MKDEBUG && _d('Error:', $EVAL_ERROR);
8798  ***      0      0                                           $EVAL_ERROR =~ m/Unknown database/ ? $stats->{unknown_database}++
8799                                                                          :                        $stats->{use_database_error}++;
8800  ***      0                                                  return;
8801                                                           }
8802  ***      0                                               $current_db = $db;
8803                                                        }
8804  ***      0      0                                     $stats->{no_database}++ unless $current_db;
8805  ***      0                                            return $event;
8806  ***      0                                         };
8807                                                  
8808                                                     # ########################################################################
8809                                                     # Short version: do it!  Long version: this callback does the main work.
8810                                                     # The big picture is:
8811                                                     #   [event] -> exec on hosts -> compare -> aggregate -> [meta-event]
8812                                                     # The single input [event] is duplicated into "host events" which are
8813                                                     # executed on each host.  Each host event goes through three processing,
8814                                                     # or "action", steps for each compare module: before_execute, execute,
8815                                                     # and after_execute.  Each compare module modifies and returns the event.
8816                                                     # (e.g. CompareResults checksum method adds a checksum attribute).  When
8817                                                     # all host events are done, they are collectively passed to each compare
8818                                                     # module which look for differences in the attributes they added.
8819                                                     # (e.g. CompareResults looks for different checksum attribute values.)
8820                                                     # The compare modules return difference attributes that this callback
8821                                                     # aggregates in a meta-event.  The meta-event captures the varying
8822                                                     # differences for this event across all hosts.  The specific difference
8823                                                     # details are reported later when report() is called for compare module.
8824                                                     # ########################################################################
8825                                                     push @callbacks, sub {
8826  ***      0                    0                       my ( $event ) = @_;
8827  ***      0                                            MKDEBUG && _d('callback: execute event on hosts');
8828                                                  
8829  ***      0                                            my @host_events;
8830                                                        HOST:
8831  ***      0                                            foreach my $host ( @$hosts ) { 
8832  ***      0                                               my $dbh        = $host->{dbh};
8833  ***      0                                               my $host_name  = $host->{name};
8834  ***      0                                               my $host_event = { %$event };
8835  ***      0                                               my %bad_module;
8836  ***      0                                               $host_event->{Errors} = 'No';
8837                                                           ACTION:
8838  ***      0                                               foreach my $action ( qw(before_execute execute after_execute) ) {
8839                                                              MODULE:
8840  ***      0                                                  foreach my $c ( @compare_modules ) {
8841  ***      0                                                     my $module = ref $c;
8842  ***      0      0                                              if ( $bad_module{$module} ) {
8843  ***      0                                                        MKDEBUG && _d('Skipping bad module', $module, $action,
8844                                                                       'on', $host_name);
8845  ***      0                                                        $stats->{"${module}_${action}_skipped"}++;
8846  ***      0                                                        next MODULE;
8847                                                                 }
8848  ***      0                                                     MKDEBUG && _d('Doing', $module, $action, 'on', $host_name);
8849  ***      0                                                     eval {
8850  ***      0                                                        $host_event = $c->$action(
8851                                                                       event           => $host_event,
8852                                                                       dbh             => $dbh,
8853                                                                       db              => $current_db,
8854                                                                       'temp-database' => $tmp_db,
8855                                                                       'temp-table'    => $tmp_tbl,
8856                                                                    );
8857                                                                 };
8858  ***      0      0                                              if ( $EVAL_ERROR ) {
8859  ***      0                                                        chomp $EVAL_ERROR;
8860  ***      0                                                        MKDEBUG && _d('Error:', $EVAL_ERROR);
8861  ***      0             0                                          $errors->{$event->{fingerprint}}->{$event->{sampleno} || 0}
8862                                                                       = [$host->{name}, $EVAL_ERROR];
8863  ***      0             0                                          $samples{$event->{fingerprint}}->{$event->{sampleno} || 0}
8864                                                                       = $event->{arg};
8865  ***      0                                                        $host_event->{Errors} = 'Yes';
8866  ***      0                                                        $bad_module{$module}++;
8867  ***      0                                                        $stats->{"${module}_${action}_error"}++;
8868  ***      0                                                        next MODULE;
8869                                                                 }
8870                                                              } 
8871                                                           }
8872                                                  
8873  ***      0      0      0                                 $host_event->{Warnings}
8874                                                              = $host_event->{warning_count}
8875                                                                && $host_event->{warning_count} > 0 ? 'Yes' : 'No';
8876                                                  
8877  ***      0                                               push @host_events, $host_event;
8878                                                        }
8879                                                  
8880                                                        # Compare host events for differences, then aggregate those differences.
8881  ***      0                                            my $n_diffs = 0;
8882  ***      0                                            foreach my $c ( @compare_modules ) {
8883  ***      0                                               MKDEBUG && _d('Doing', ref $c, 'compare');
8884  ***      0                                               my %diffs = $c->compare(
8885                                                              events               => \@host_events,
8886                                                              hosts                => $hosts,
8887                                                              'float-precision'    => $o->get('float-precision'),
8888                                                              'max-different-rows' => $o->get('max-different-rows'),
8889                                                           );
8890  ***      0                                               @{$event}{keys %diffs} = values %diffs;
      ***      0                                      
8891  ***      0                                               map { $n_diffs += $_ } values %diffs;
      ***      0                                      
8892                                                        }
8893  ***      0                                            $event->{differences} = $n_diffs;
8894  ***      0                                            $meta_ea->aggregate($event);
8895                                                  
8896                                                  
8897                                                        # Per-host aggregates must be done after compare() because
8898                                                        # some attributes can only be added to the host events during
8899                                                        # compare(), like row_count for the rows method.
8900  ***      0                                            for my $i ( 0..$#host_events ) {
8901                                                  
8902                                                           # Zero query times.  Do this after compare() but before
8903                                                           # per-host aggregation so that the modules can compare/use
8904                                                           # the query times but the per-host aggregated reports will
8905                                                           # show zeros.
8906  ***      0      0      0                                 if ( exists $host_events[$i]->{Query_time}
8907                                                                && $o->get('zero-query-times') ) {
8908  ***      0                                                  $host_events[$i]->{Query_time} = 0;
8909                                                           }
8910                                                  
8911  ***      0                                               $hosts->[$i]->{ea}->aggregate($host_events[$i]);
8912                                                        }
8913                                                  
8914  ***      0                                            return $event;  # the meta-event
8915  ***      0                                         };
8916                                                  
8917                                                     # ########################################################################
8918                                                     # Daemonize now that everything is setup and ready to work.
8919                                                     # ########################################################################
8920  ***      0                                         my $daemon;
8921  ***      0      0                                  if ( $o->get('daemonize') ) {
      ***             0                               
8922  ***      0                                            $daemon = new Daemon(o=>$o);
8923  ***      0                                            $daemon->daemonize();
8924  ***      0                                            MKDEBUG && _d('I am a daemon now');
8925                                                     }
8926                                                     elsif ( $o->get('pid') ) {
8927                                                        # We're not daemoninzing, it just handles PID stuff.
8928  ***      0                                            $daemon = new Daemon(o=>$o);
8929  ***      0                                            $daemon->make_PID_file();
8930                                                     }
8931                                                  
8932                                                     # ##########################################################################
8933                                                     # Parse the input.
8934                                                     # ##########################################################################
8935  ***      0                                         my $fh;
8936  ***      0                    0                    my $next_event = sub { return <$fh>; };
      ***      0                                      
8937  ***      0                    0                    my $tell       = sub { return tell $fh; };
      ***      0                                      
8938  ***      0                                         my $start = time();
8939  ***      0             0                           my $end   = $start + ($o->get('run-time') || 0); # When we should exit
8940  ***      0                                         my $now   = $start;
8941  ***      0                                         my $iters = 0;
8942                                                     ITERATION:
8943  ***      0             0                           while (  # Quit if instructed to, or if iterations are exceeded.
      ***                    0                        
8944                                                        $oktorun
8945                                                        && (!$o->get('iterations') || $iters++ < $o->get('iterations') )
8946                                                     ) {
8947                                                  
8948                                                        EVENT:
8949  ***      0             0                              while (                                 # Quit if:
      ***                    0                        
8950                                                           $oktorun                             # instructed to quit
8951                                                           && ($start == $end || $now < $end) ) # or time is exceeded
8952                                                        {
8953  ***      0      0                                        if ( !$fh ) {
8954  ***      0                                                  my $file = shift @files;
8955  ***      0      0                                           if ( !$file ) {
8956  ***      0                                                     MKDEBUG && _d('No more files to parse');
8957  ***      0                                                     last EVENT;
8958                                                              }
8959                                                  
8960  ***      0      0                                           if ( $file eq '-' ) {
8961  ***      0                                                     $fh = *STDIN;
8962  ***      0                                                     MKDEBUG && _d('Reading STDIN');
8963                                                              }
8964                                                              else {
8965  ***      0      0                                              if ( !open $fh, "<", $file ) {
8966  ***      0                                                        $fh = undef;
8967  ***      0                                                        warn "Cannot open $file: $OS_ERROR\n";
8968  ***      0                                                        next EVENT;
8969                                                                 }
8970  ***      0                                                     MKDEBUG && _d('Reading', $file);
8971                                                              }
8972                                                           }
8973                                                  
8974  ***      0                                               my $event       = {};
8975  ***      0                                               my $more_events = 1;
8976  ***      0                    0                          my $oktorun_sub = sub { $more_events = $_[0]; };
      ***      0                                      
8977  ***      0                                               eval {
8978  ***      0                                                  foreach my $callback ( @callbacks ) {
8979  ***      0      0                                              last unless $oktorun;  # the global oktorun var
8980  ***      0                                                     $event = $callback->(
8981                                                                    $event,
8982                                                                    event      => $event,  # new interface
8983                                                                    fh         => $fh,
8984                                                                    next_event => $next_event,
8985                                                                    tell       => $tell,
8986                                                                    oktorun    => $oktorun_sub,
8987                                                                 );
8988  ***      0      0                                              last unless $event;
8989                                                              }
8990                                                           };
8991  ***      0                                               $now = time();
8992  ***      0      0                                        if ( $EVAL_ERROR ) {
8993  ***      0                                                  _d($EVAL_ERROR);
8994                                                              # Don't ignore failure to open a file, else we'll get
8995                                                              # "tell() on closed filehandle" errors.
8996  ***      0      0                                           last EVENT if $EVAL_ERROR =~ m/Cannot open/;
8997  ***      0      0                                           last EVENT unless $o->get('continue-on-error');
8998                                                           }
8999  ***      0      0                                        if ( !$more_events ) {
9000  ***      0                                                  MKDEBUG && _d('No more events');
9001  ***      0      0                                           close $fh if $fh;
9002  ***      0                                                  $fh = undef;
9003  ***      0                                                  last EVENT;
9004                                                           }
9005                                                        }  # EVENT
9006                                                  
9007                                                        # ######################################################################
9008                                                        # Done parsing events, now do the report.
9009                                                        # #####################################################################
9010  ***      0      0                                     if ( !$meta_ea->events_processed() ) {
9011  ***      0                                               print "# No events processed.\n";
9012                                                        }
9013                                                  
9014  ***      0                                            my $urf = new UpgradeReportFormatter();
9015  ***      0                                            my ($orderby_attrib, $orderby_func) = split(/:/, $o->get('order-by'));
9016                                                  
9017                                                        # We don't report on all queries, just the worst, i.e. the top
9018                                                        # however many.
9019  ***      0                                            my $limit = $o->get('limit');
9020  ***      0                                            my ($total, $count);
9021  ***      0      0                                     if ( $limit =~ m/^\d+$/ ) {
9022  ***      0                                               $count = $limit;
9023                                                        }
9024                                                        else {
9025                                                           # It's a percentage, so grab as many as needed to get to
9026                                                           # that % of the file.
9027  ***      0                                               ($total, $count) = $limit =~ m/(\d+)/g;
9028  ***      0             0                                 $total *= ($meta_ea->results->{globals}->{$orderby_attrib}->{sum} || 0)
9029                                                                   / 100;
9030                                                        }
9031  ***      0                                            my %top_spec = (
9032                                                           attrib  => $orderby_attrib,
9033                                                           orderby => $orderby_func,
9034                                                           total   => $total,
9035                                                           count   => $count,
9036                                                        );
9037                                                        # The queries that will be reported.
9038  ***      0                                            my @worst = $meta_ea->top_events(%top_spec);
9039                                                  
9040                                                        # ##################################################################
9041                                                        # Do the report for each query.
9042                                                        # ##################################################################
9043  ***      0      0                                     if ( $o->get('reports')->{queries} ) {
9044                                                           ITEM:
9045  ***      0                                               foreach my $rank ( 1 .. @worst ) {
9046  ***      0                                                  my $item       = $worst[$rank - 1]->[0];
9047  ***      0                                                  my $sample     = $meta_ea->results->{samples}->{$item};
9048  ***      0             0                                    my $samp_query = $sample->{arg} || '';
9049                                                  
9050  ***      0                                                  print "\n";
9051  ***      0                                                  print $urf->event_report(
9052                                                                 meta_ea => $meta_ea,
9053                                                                 hosts   => $hosts,
9054                                                                 where   => $item,
9055                                                                 rank    => $rank,
9056                                                                 worst   => 'differences',
9057                                                              );
9058                                                  
9059  ***      0      0                                           if ( $sample->{original_arg} ) {
9060  ***      0                                                     my $orig = $sample->{original_arg};
9061  ***      0      0                                              if ( $o->get('shorten') ) {
9062  ***      0                                                        $orig = $qr->shorten($orig, $o->get('shorten'));
9063                                                                 }
9064  ***      0                                                     print "# Converted non-SELECT:\n#   $orig\n";
9065                                                              }
9066  ***      0      0                                           if ( $o->get('fingerprints') ) {
9067  ***      0                                                     print "# Fingerprint\n#   $item\n";
9068                                                              }
9069  ***      0      0                                           $samp_query = $qr->shorten($samp_query, $o->get('shorten'))
9070                                                                 if $o->get('shorten');
9071  ***      0                                                  print "$samp_query\n";
9072                                                  
9073  ***      0                                                  my $query_id = make_checksum($item);
9074  ***      0                                                  foreach my $c ( @compare_modules ) {
9075  ***      0                                                     my %compare_samples = $c->samples($item);
9076  ***      0                                                     @{$samples{$item}}{keys %compare_samples}
      ***      0                                      
9077                                                                    = values %compare_samples;
9078                                                              }
9079                                                              map {
9080  ***      0                                                        print "/* $query_id-$_ */ $samples{$item}->{$_}\n";
      ***      0                                      
9081  ***      0                                                  } sort { $a <=> $b } keys %{$samples{$item}};
      ***      0                                      
9082                                                           } # Each worst ITEM
9083                                                        }
9084                                                  
9085                                                        # ##################################################################
9086                                                        # Print the other, summary-like reports.
9087                                                        # ##################################################################
9088  ***      0      0                                     if ( $o->get('reports')->{differences} ) {
9089  ***      0                                               foreach my $c ( @compare_modules ) {
9090  ***      0                                                  my $report = $c->report(hosts => $hosts);
9091  ***      0      0                                           print "\n$report" if $report;
9092                                                           }
9093                                                        }
9094                                                  
9095  ***      0      0                                     if ( $o->get('reports')->{errors} ) {
9096  ***      0                                               report_errors(errors => $errors);
9097                                                        }
9098                                                  
9099  ***      0      0                                     if ( $o->get('reports')->{statistics} ) {
9100  ***      0                                               my $fmt = "# %-30s %d\n";
9101  ***      0                                               print "\n# Statistics\n";
9102  ***      0                                               map { printf $fmt, $_, $stats->{$_} } sort keys %$stats;
      ***      0                                      
9103                                                        }
9104                                                  
9105                                                        # ##################################################################
9106                                                        # Reset for the next iteration.
9107                                                        # ##################################################################
9108                                                  
9109                                                        # Reset the start/end/now times so the next iteration will run for the
9110                                                        # same amount of time.
9111  ***      0                                            $start = time();
9112  ***      0             0                              $end   = $start + ($o->get('run-time') || 0); # When we should exit
9113  ***      0                                            $now   = $start;
9114                                                  
9115  ***      0                                            foreach my $ea ( $meta_ea, map { $_->{ea} } @$hosts ) {
      ***      0                                      
9116  ***      0                                               $ea->reset_aggregated_data();
9117                                                        }
9118  ***      0                                            %samples   = ();
9119  ***      0                                            %samplenos = ();
9120  ***      0                                            $errors    = {};
9121                                                  
9122  ***      0                                            foreach my $c ( @compare_modules ) {
9123  ***      0                                               $c->reset();
9124                                                        }
9125                                                     } # ITERATION
9126                                                  
9127                                                  
9128  ***      0                                         foreach my $host ( @$hosts ) {
9129  ***      0      0                                     $host->{dbh}->disconnect() if $host->{dbh};
9130                                                     }
9131                                                  
9132  ***      0                                         return 0;
9133                                                  
9134                                                  } # End main().
9135                                                  
9136                                                  # ############################################################################
9137                                                  # Subroutines.
9138                                                  # ############################################################################
9139                                                  sub report_errors {
9140  ***      0                    0                    my ( %args ) = @_;
9141  ***      0                                         my @required_args = qw(errors);
9142  ***      0                                         foreach my $arg ( @required_args ) {
9143  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
9144                                                     }
9145  ***      0                                         my ($errors) = @args{@required_args};
9146                                                  
9147  ***      0      0                                  return unless keys %$errors;
9148                                                  
9149  ***      0                                         my $rf = new ReportFormatter(
9150                                                        long_last_column => 1,
9151                                                     );
9152  ***      0                                         $rf->set_title('Errors');
9153  ***      0                                         $rf->set_columns(
9154                                                        {
9155                                                           name        => 'Query ID',
9156                                                        },
9157  ***      0                                            map { { name => $_ } } qw(Host Error)
9158                                                     );
9159                                                  
9160  ***      0                                         foreach my $item ( sort keys %$errors ) {
9161  ***      0                                            map {
9162  ***      0                                               my ($host, $error) =  @{$errors->{$item}->{$_}};
      ***      0                                      
9163  ***      0                                               chomp $error;
9164  ***      0                                               $rf->add_line(
9165                                                              make_checksum($item) . '-' . $_,
9166                                                              $host,
9167                                                              $error,
9168                                                           );
9169  ***      0                                            } sort { $a <=> $b } keys %{$errors->{$item}};
      ***      0                                      
9170                                                     }
9171                                                  
9172  ***      0                                         my $report = $rf->get_report();
9173  ***      0      0                                  print "\n$report" if $report;
9174                                                  
9175  ***      0                                         return;
9176                                                  }
9177                                                  
9178                                                  sub get_cxn {
9179  ***      0                    0                    my ( $dp, $o, $dsn ) = @_;
9180  ***      0      0                                  if ( $o->get('ask-pass') ) {
9181  ***      0                                            $dsn->{p} = OptionParser::prompt_noecho("Enter password: ");
9182                                                     }
9183  ***      0                                         my $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), {AutoCommit => 1});
9184  ***      0                                         return $dbh;
9185                                                  }
9186                                                  
9187                                                  # Catches signals so we can exit gracefully.
9188                                                  sub sig_int {
9189  ***      0                    0                    my ( $signal ) = @_;
9190  ***      0      0                                  if ( $oktorun ) {
9191  ***      0                                            print STDERR "# Caught SIG$signal.\n";
9192  ***      0                                            $oktorun = 0;
9193                                                     }
9194                                                     else {
9195  ***      0                                            print STDERR "# Exiting on SIG$signal.\n";
9196  ***      0                                            exit 1;
9197                                                     }
9198                                                  }
9199                                                  
9200                                                  sub _d {
9201  ***      0                    0                    my ($package, undef, $line) = caller 0;
9202  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
9203  ***      0                                              map { defined $_ ? $_ : 'undef' }
9204                                                          @_;
9205  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
9206                                                  }
9207                                                  
9208                                                  # ############################################################################
9209                                                  # Run the program.
9210                                                  # ############################################################################
9211                                                  if ( !caller ) { exit main(@ARGV); }
9212                                                  
9213                                                  1; # Because this is a module as well as a script.
9214                                                  
9215                                                  # #############################################################################
9216                                                  # Documentation.
9217                                                  # #############################################################################
9218                                                  
9219                                                  =pod
9220                                                  
9221                                                  =head1 NAME
9222                                                  
9223                                                  mk-upgrade - Execute queries on multiple servers and check for differences.
9224                                                  
9225                                                  =head1 SYNOPSIS
9226                                                  
9227                                                  Execute and compare all queries in slow.log on host1 to host2:
9228                                                  
9229                                                    mk-upgrade slow.log h=host1 h=host2
9230                                                  
9231                                                  Use mk-query-digest to get, execute and compare queries from tcpdump:
9232                                                  
9233                                                    tcpdump -i eth0 port 3306 -s 65535  -x -n -q -tttt     \
9234                                                      | mk-query-digest --type tcpdump --no-report --print \
9235                                                      | mk-upgrade h=host1 h=host2
9236                                                  
9237                                                  Compare only query times on host1 to host2 and host3:
9238                                                  
9239                                                    mk-upgrade slow.log h=host1 h=host2 h=host3 --compare query_times
9240                                                  
9241                                                  Compare a single query, no slowlog needed:
9242                                                  
9243                                                    mk-upgrade h=host1 h=host2 --query 'SELECT * FROM db.tbl'
9244                                                  
9245                                                  =head1 RISKS
9246                                                  
9247                                                  The following section is included to inform users about the potential risks,
9248                                                  whether known or unknown, of using this tool.  The two main categories of risks
9249                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
9250                                                  tools) and those created by bugs.
9251                                                  
9252                                                  mk-upgrade is a read-only tool that is meant to be used on non-production
9253                                                  servers.  It executes the SQL that you give it as input, which could cause
9254                                                  undesired load on a production server.
9255                                                  
9256                                                  At the time of this release, we know of no bugs that could cause serious harm to
9257                                                  users.
9258                                                  
9259                                                  The authoritative source for updated information is always the online issue
9260                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
9261                                                  see a list of such issues at the following URL:
9262                                                  L<http://www.maatkit.org/bugs/mk-upgrade>.
9263                                                  
9264                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
9265                                                  
9266                                                  =head1 DESCRIPTION
9267                                                  
9268                                                  mk-upgrade executes queries from slowlogs on one or more MySQL server to find
9269                                                  differences in query time, warnings, results, and other aspects of the querys'
9270                                                  execution.  This helps to evaluate upgrades, migrations and configuration
9271                                                  changes.  The comparisons specified by L<"--compare"> determine what
9272                                                  differences can be found.  A report is printed which outlines all the
9273                                                  differences found; see L<"OUTPUT"> below.
9274                                                  
9275                                                  The first DSN (host) specified on the command line is authoritative; it defines
9276                                                  the results to which the other DSNs are compared.  You can "compare" only one
9277                                                  host, in which case there will be no differences but the output can be saved
9278                                                  to be diffed later against the output of another single host "comparison".
9279                                                  
9280                                                  At present, mk-upgrade only reads slowlogs.  Use C<mk-query-digest --print> to
9281                                                  transform other log formats to slowlog.
9282                                                  
9283                                                  DSNs and slowlog files can be specified in any order.  mk-upgrade will
9284                                                  automatically determine if an argument is a DSN or a slowlog file.  If no
9285                                                  slowlog files are given and L<"--query"> is not specified then mk-upgrade
9286                                                  will read from C<STDIN>.
9287                                                  
9288                                                  =head1 OUTPUT
9289                                                  
9290                                                  TODO
9291                                                  
9292                                                  =head1 OPTIONS
9293                                                  
9294                                                  =over
9295                                                  
9296                                                  =item --ask-pass
9297                                                  
9298                                                  Prompt for a password when connecting to MySQL.
9299                                                  
9300                                                  =item --base-dir
9301                                                  
9302                                                  type: string; default: /tmp
9303                                                  
9304                                                  Save outfiles for the C<rows> comparison method in this directory.
9305                                                  
9306                                                  See the C<rows> L<"--compare-results-method">.
9307                                                  
9308                                                  =item --charset
9309                                                  
9310                                                  short form: -A; type: string
9311                                                  
9312                                                  Default character set.  If the value is utf8, sets Perl's binmode on
9313                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
9314                                                  runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
9315                                                  binmode on STDOUT without the utf8 layer, and runs SET NAMES after
9316                                                  connecting to MySQL.
9317                                                  
9318                                                  =item --[no]clear-warnings
9319                                                  
9320                                                  default: yes
9321                                                  
9322                                                  Clear warnings before each warnings comparison.
9323                                                  
9324                                                  If comparing warnings (L<"--compare"> includes C<warnings>), this option
9325                                                  causes mk-upgrade to execute a successful C<SELECT> statement which clears
9326                                                  any warnings left over from previous queries.  This requires a current
9327                                                  database that mk-upgrade usually detects automatically, but in some cases
9328                                                  it might be necessary to specify L<"--temp-database">.  If mk-upgrade can't
9329                                                  auto-detect the current database, it will create a temporary table in the
9330                                                  L<"--temp-database"> called C<mk_upgrade_clear_warnings>.
9331                                                  
9332                                                  =item --clear-warnings-table
9333                                                  
9334                                                  type: string
9335                                                  
9336                                                  Execute C<SELECT * FROM ... LIMIT 1> from this table to clear warnings.
9337                                                  
9338                                                  =item --compare
9339                                                  
9340                                                  type: Hash; default: query_times,results,warnings
9341                                                  
9342                                                  What to compare for each query executed on each host.
9343                                                  
9344                                                  Comparisons determine differences when the queries are executed on the hosts.
9345                                                  More comparisons enable more differences to be detected.  The following
9346                                                  comparisons are available:
9347                                                  
9348                                                  =over
9349                                                  
9350                                                  =item query_times
9351                                                  
9352                                                  Compare query execution times.  If this comparison is disabled, the queries
9353                                                  are still executed so that other comparisons will work, but the query time
9354                                                  attributes are removed from the events.
9355                                                  
9356                                                  =item results
9357                                                  
9358                                                  Compare result sets to find differences in rows, columns, etc.
9359                                                  
9360                                                  What differences can be found depends on the L<"--compare-results-method"> used.
9361                                                  
9362                                                  =item warnings
9363                                                  
9364                                                  Compare warnings from C<SHOW WARNINGS>.  Requires at least MySQL 4.1.
9365                                                  
9366                                                  =back
9367                                                  
9368                                                  =item --compare-results-method
9369                                                  
9370                                                  type: string; default: CHECKSUM; group: Comparisons
9371                                                  
9372                                                  Method to use for L<"--compare"> C<results>.  This option has no effect
9373                                                  if C<--no-compare-results> is given.
9374                                                  
9375                                                  Available compare methods (case-insensitive):
9376                                                  
9377                                                  =over
9378                                                  
9379                                                  =item CHECKSUM
9380                                                  
9381                                                  Do C<CREATE TEMPORARY TABLE `mk_upgrade` AS query> then
9382                                                  C<CHECKSUM TABLE `mk_upgrade`>.  This method is fast and simple but in
9383                                                  rare cases might it be inaccurate because the MySQL manual says:
9384                                                  
9385                                                    [The] fact that two tables produce the same checksum does I<not> mean that
9386                                                    the tables are identical.
9387                                                  
9388                                                  Requires at least MySQL 4.1.
9389                                                  
9390                                                  =item rows
9391                                                  
9392                                                  Compare rows one-by-one to find differences.  This method has advantages
9393                                                  and disadvantages.  Its disadvantages are that it may be slower and it
9394                                                  requires writing and reading outfiles from disk.  Its advantages are that
9395                                                  it is universal (works for all versions of MySQL), it doesn't alter the query
9396                                                  in any way, and it can find column value differences.
9397                                                  
9398                                                  The C<rows> method works as follows:
9399                                                  
9400                                                    1. Rows from each host are compared one-by-one.
9401                                                    2. If no differences are found, comparison stops, else...
9402                                                    3. All remain rows (after the point where they begin to differ)
9403                                                       are written to outfiles.
9404                                                    4. The outfiles are loaded into temporary tables with
9405                                                       C<LOAD DATA LOCAL INFILE>.
9406                                                    5. The temporary tables are analyzed to determine the differences.
9407                                                  
9408                                                  The outfiles are written to the L<"--base-dir">.
9409                                                  
9410                                                  =back
9411                                                  
9412                                                  =item --config
9413                                                  
9414                                                  type: Array
9415                                                  
9416                                                  Read this comma-separated list of config files; if specified, this must be the
9417                                                  first option on the command line.
9418                                                  
9419                                                  =item --continue-on-error
9420                                                  
9421                                                  Continue working even if there is an error.
9422                                                  
9423                                                  =item --convert-to-select
9424                                                  
9425                                                  Convert non-SELECT statements to SELECTs and compare.
9426                                                  
9427                                                  By default non-SELECT statements are not allowed.  This option causes
9428                                                  non-SELECT statments (like UPDATE, INSERT and DELETE) to be converted
9429                                                  to SELECT statements, executed and compared.
9430                                                  
9431                                                  For example, C<DELETE col FROM tbl WHERE id=1> is converted to
9432                                                  C<SELECT col FROM tbl WHERE id=1>.
9433                                                  
9434                                                  =item --daemonize
9435                                                  
9436                                                  Fork to the background and detach from the shell.  POSIX
9437                                                  operating systems only.
9438                                                  
9439                                                  =item --explain-hosts
9440                                                  
9441                                                  Print connection information and exit.
9442                                                  
9443                                                  =item --filter
9444                                                  
9445                                                  type: string
9446                                                  
9447                                                  Discard events for which this Perl code doesn't return true.
9448                                                  
9449                                                  This option is a string of Perl code or a file containing Perl code that gets
9450                                                  compiled into a subroutine with one argument: $event.  This is a hashref.
9451                                                  If the given value is a readable file, then mk-upgrade reads the entire
9452                                                  file and uses its contents as the code.  The file should not contain
9453                                                  a shebang (#!/usr/bin/perl) line.
9454                                                  
9455                                                  If the code returns true, the chain of callbacks continues; otherwise it ends.
9456                                                  The code is the last statement in the subroutine other than C<return $event>. 
9457                                                  The subroutine template is:
9458                                                  
9459                                                    sub { $event = shift; filter && return $event; }
9460                                                  
9461                                                  Filters given on the command line are wrapped inside parentheses like like
9462                                                  C<( filter )>.  For complex, multi-line filters, you must put the code inside
9463                                                  a file so it will not be wrapped inside parentheses.  Either way, the filter
9464                                                  must produce syntactically valid code given the template.  For example, an
9465                                                  if-else branch given on the command line would not be valid:
9466                                                  
9467                                                    --filter 'if () { } else { }'  # WRONG
9468                                                  
9469                                                  Since it's given on the command line, the if-else branch would be wrapped inside
9470                                                  parentheses which is not syntactically valid.  So to accomplish something more
9471                                                  complex like this would require putting the code in a file, for example
9472                                                  filter.txt:
9473                                                  
9474                                                    my $event_ok; if (...) { $event_ok=1; } else { $event_ok=0; } $event_ok
9475                                                  
9476                                                  Then specify C<--filter filter.txt> to read the code from filter.txt.
9477                                                  
9478                                                  If the filter code won't compile, mk-upgrade will die with an error.
9479                                                  If the filter code does compile, an error may still occur at runtime if the
9480                                                  code tries to do something wrong (like pattern match an undefined value).
9481                                                  mk-upgrade does not provide any safeguards so code carefully!
9482                                                  
9483                                                  An example filter that discards everything but SELECT statements:
9484                                                  
9485                                                    --filter '$event->{arg} =~ m/^select/i'
9486                                                  
9487                                                  This is compiled into a subroutine like the following:
9488                                                  
9489                                                    sub { $event = shift; ( $event->{arg} =~ m/^select/i ) && return $event; }
9490                                                  
9491                                                  It is permissible for the code to have side effects (to alter $event).
9492                                                  
9493                                                  You can find an explanation of the structure of $event at
9494                                                  L<http://code.google.com/p/maatkit/wiki/EventAttributes>.
9495                                                  
9496                                                  =item --fingerprints
9497                                                  
9498                                                  Add query fingerprints to the standard query analysis report.  This is mostly
9499                                                  useful for debugging purposes.
9500                                                  
9501                                                  =item --float-precision
9502                                                  
9503                                                  type: int
9504                                                  
9505                                                  Round float, double and decimal values to this many places.
9506                                                  
9507                                                  This option helps eliminate false-positives caused by floating-point
9508                                                  imprecision.
9509                                                  
9510                                                  =item --help
9511                                                  
9512                                                  Show help and exit.
9513                                                  
9514                                                  =item --host
9515                                                  
9516                                                  short form: -h; type: string
9517                                                  
9518                                                  Connect to host.
9519                                                  
9520                                                  =item --iterations
9521                                                  
9522                                                  type: int; default: 1
9523                                                  
9524                                                  How many times to iterate through the collect-and-report cycle.  If 0, iterate
9525                                                  to infinity.  See also L<--run-time>.
9526                                                  
9527                                                  =item --limit
9528                                                  
9529                                                  type: string; default: 95%:20
9530                                                  
9531                                                  Limit output to the given percentage or count.
9532                                                  
9533                                                  If the argument is an integer, report only the top N worst queries.  If the
9534                                                  argument is an integer followed by the C<%> sign, report that percentage of the
9535                                                  worst queries.  If the percentage is followed by a colon and another integer,
9536                                                  report the top percentage or the number specified by that integer, whichever
9537                                                  comes first.
9538                                                  
9539                                                  =item --log
9540                                                  
9541                                                  type: string
9542                                                  
9543                                                  Print all output to this file when daemonized.
9544                                                  
9545                                                  =item --max-different-rows
9546                                                  
9547                                                  type: int; default: 10
9548                                                  
9549                                                  Stop comparing rows for C<--compare-results-method rows> after this many
9550                                                  differences are found.
9551                                                  
9552                                                  =item --order-by
9553                                                  
9554                                                  type: string; default: differences:sum
9555                                                  
9556                                                  Sort events by this attribute and aggregate function.
9557                                                  
9558                                                  =item --password
9559                                                  
9560                                                  short form: -p; type: string
9561                                                  
9562                                                  Password to use when connecting.
9563                                                  
9564                                                  =item --pid
9565                                                  
9566                                                  type: string
9567                                                  
9568                                                  Create the given PID file when daemonized.  The file contains the process
9569                                                  ID of the daemonized instance.  The PID file is removed when the
9570                                                  daemonized instance exits.  The program checks for the existence of the
9571                                                  PID file when starting; if it exists and the process with the matching PID
9572                                                  exists, the program exits.
9573                                                  
9574                                                  =item --port
9575                                                  
9576                                                  short form: -P; type: int
9577                                                  
9578                                                  Port number to use for connection.
9579                                                  
9580                                                  =item --query
9581                                                  
9582                                                  type: string
9583                                                  
9584                                                  Execute and compare this single query; ignores files on command line.
9585                                                  
9586                                                  This option allows you to supply a single query on the command line.  Any
9587                                                  slowlogs also specified on the command line are ignored.
9588                                                  
9589                                                  =item --[no]report
9590                                                  
9591                                                  default: yes
9592                                                  
9593                                                  Print the L<"--reports">.
9594                                                  
9595                                                  =item --reports
9596                                                  
9597                                                  type: Hash; default: queries,differences,errors,statistics
9598                                                  
9599                                                  Print these reports.  Valid reports are queries, differences, errors, and
9600                                                  statistics.
9601                                                  
9602                                                  See L<"OUTPUT"> for more information on the various parts of the report.
9603                                                  
9604                                                  =item --run-time
9605                                                  
9606                                                  type: time
9607                                                  
9608                                                  How long to run before exiting.  The default is to run forever (you can
9609                                                  interrupt with CTRL-C).
9610                                                  
9611                                                  =item --set-vars
9612                                                  
9613                                                  type: string; default: wait_timeout=10000,query_cache_type=0
9614                                                  
9615                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this
9616                                                  string will be appended to SET and executed.
9617                                                  
9618                                                  =item --shorten
9619                                                  
9620                                                  type: int; default: 1024
9621                                                  
9622                                                  Shorten long statements in reports.
9623                                                  
9624                                                  Shortens long statements, replacing the omitted portion with a C</*... omitted
9625                                                  ...*/> comment.  This applies only to the output in reports.  It prevents a
9626                                                  large statement from causing difficulty in a report.  The argument is the
9627                                                  preferred length of the shortened statement.  Not all statements can be
9628                                                  shortened, but very large INSERT and similar statements often can; and so
9629                                                  can IN() lists, although only the first such list in the statement will be
9630                                                  shortened.
9631                                                  
9632                                                  If it shortens something beyond recognition, you can find the original statement
9633                                                  in the log, at the offset shown in the report header (see L<"OUTPUT">).
9634                                                  
9635                                                  =item --socket
9636                                                  
9637                                                  short form: -S; type: string
9638                                                  
9639                                                  Socket file to use for connection.
9640                                                  
9641                                                  =item --temp-database
9642                                                  
9643                                                  type: string
9644                                                  
9645                                                  Use this database for creating temporary tables.
9646                                                  
9647                                                  If given, this database is used for creating temporary tables for the
9648                                                  results comparison (see L<"--compare">).  Otherwise, the current
9649                                                  database (from the last event that specified its database) is used.
9650                                                  
9651                                                  =item --temp-table
9652                                                  
9653                                                  type: string; default: mk_upgrade
9654                                                  
9655                                                  Use this table for checksumming results.
9656                                                  
9657                                                  =item --user
9658                                                  
9659                                                  short form: -u; type: string
9660                                                  
9661                                                  User for login if not current user.
9662                                                  
9663                                                  =item --version
9664                                                  
9665                                                  Show version and exit.
9666                                                  
9667                                                  =item --zero-query-times
9668                                                  
9669                                                  Zero the query times in the report.
9670                                                  
9671                                                  =back
9672                                                  
9673                                                  =head1 DOWNLOADING
9674                                                  
9675                                                  You can download Maatkit from Google Code at
9676                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
9677                                                  easily with a command like the following:
9678                                                  
9679                                                     wget http://www.maatkit.org/get/toolname
9680                                                     or
9681                                                     wget http://www.maatkit.org/trunk/toolname
9682                                                  
9683                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
9684                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
9685                                                  needed.  The first URL gets the latest released version of the tool, and the
9686                                                  second gets the latest trunk code from Subversion.
9687                                                  
9688                                                  =head1 ENVIRONMENT
9689                                                  
9690                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
9691                                                  the Maatkit tools:
9692                                                  
9693                                                     MKDEBUG=1 mk-....
9694                                                  
9695                                                  =head1 SYSTEM REQUIREMENTS
9696                                                  
9697                                                  You need Perl and some core packages that ought to be installed in any
9698                                                  reasonably new version of Perl.
9699                                                  
9700                                                  =head1 BUGS
9701                                                  
9702                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-upgrade>.
9703                                                  
9704                                                  Please use Google Code Issues and Groups to report bugs or request support:
9705                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
9706                                                  discuss Maatkit.
9707                                                  
9708                                                  Please include the complete command-line used to reproduce the problem you are
9709                                                  seeing, the version of all MySQL servers involved, the complete output of the
9710                                                  tool when run with L<"--version">, and if possible, debugging output produced by
9711                                                  running with the C<MKDEBUG=1> environment variable.
9712                                                  
9713                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
9714                                                  
9715                                                  This program is copyright 2009-@CURRENTYEAR@ Percona, Inc.
9716                                                  Feedback and improvements are welcome.
9717                                                  
9718                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
9719                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
9720                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
9721                                                  
9722                                                  This program is free software; you can redistribute it and/or modify it under
9723                                                  the terms of the GNU General Public License as published by the Free Software
9724                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
9725                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
9726                                                  licenses.
9727                                                  
9728                                                  You should have received a copy of the GNU General Public License along with
9729                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
9730                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
9731                                                  
9732                                                  =head1 AUTHOR
9733                                                  
9734                                                  Baron Schwartz, Daniel Nichter
9735                                                  
9736                                                  =head1 ABOUT MAATKIT
9737                                                  
9738                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
9739                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
9740                                                  code contributors.  Both are employed by Percona.  Financial support for
9741                                                  Maatkit development is primarily provided by Percona and its clients. 
9742                                                  
9743                                                  =head1 VERSION
9744                                                  
9745                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5502 $.
9746                                                  
9747                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
101   ***     50      0     30   if (@_ > 2)
110   ***     50      0     10   if (not $dsn)
122   ***     50     40      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
134   ***     50      0     80   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
140          100     40     40   if (not defined $final_props{$key})
147   ***     50      0     40   unless exists $opts{$key}
150   ***     50      0     10   if (my $required = $self->prop('required'))
152   ***      0      0      0   unless $final_props{$key}
161   ***      0      0      0   unless ref $o eq 'OptionParser'
164   ***      0      0      0   if $o->has($_)
174   ***      0      0      0   unless ref $dsn
175   ***      0      0      0   $_ eq 'p' ? :
176   ***      0      0      0   if defined $$dsn{$_}
189   ***      0      0      0   $opts{$key}{'copy'} ? :
203   ***     50      0     10   if ($driver eq 'Pg') { }
235   ***     50      0     10   $cxn_string =~ /charset=utf8/ ? :
244   ***     50      0     10   if (not $have_dbi)
263   ***     50     10      0   if ($cxn_string =~ /mysql/i)
271   ***     50      0     10   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
276   ***      0      0      0   if ($charset eq 'utf8') { }
277   ***      0      0      0   unless binmode STDOUT, ':utf8'
281   ***      0      0      0   unless binmode STDOUT
285   ***     50      0     10   if ($self->prop('set-vars'))
292   ***     50      0     10   if (not $dbh and $EVAL_ERROR)
294   ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
307   ***      0      0      0   if (not $tries)
329   ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
346   ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
356   ***      0      0      0   unless $dsn_1
357   ***      0      0      0   unless $dsn_2
361   ***      0      0      0   if ($args{'overwrite'}) { }
362   ***      0      0      0   defined $$dsn_1{$key} ? :
365   ***      0      0      0   defined $$dsn_2{$key} ? :
374   ***      0      0      0   defined $_ ? :
424   ***      0      0      0   unless defined $args{'cache'}
432   ***      0      0      0   if ($what eq 'table') { }
      ***      0      0      0   elsif ($what eq 'triggers') { }
      ***      0      0      0   elsif ($what eq 'view') { }
434   ***      0      0      0   unless $ddl
435   ***      0      0      0   if ($$ddl[0] eq 'table') { }
449   ***      0      0      0   if ($trgs and @$trgs) { }
452   ***      0      0      0   if ($$trg{'sql_mode'})
456   ***      0      0      0   if ($$trg{'definer'})
488   ***      0      0      0   if (not $new)
495   ***      0      0      0   if ($curr and $new and $curr eq $new)
507   ***      0      0      0   if (not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl})
520   ***      0      0      0   if ($EVAL_ERROR)
530   ***      0      0      0   if ($key) { }
546   ***      0      0      0   if (not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl})
576   ***      0      0      0   if (not $$self{'cache'} or not $$self{'triggers'}{$db})
589   ***      0      0      0   if ($sth->rows)
602   ***      0      0      0   if ($tbl)
610   ***      0      0      0   if (not $$self{'cache'} or not $$self{'databases'} or $like)
613   ***      0      0      0   if ($like)
621   ***      0      0      0   unless $like
629   ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_status'}{$db} or $like)
632   ***      0      0      0   if ($like)
647   ***      0      0      0   unless $like
655   ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_list'}{$db} or $like)
658   ***      0      0      0   if ($like)
666   ***      0      0      0   ($$_[1] || '') eq 'VIEW' ? :
673   ***      0      0      0   unless $like
681   ***      0      0      0   defined $_ ? :
713   ***      0      0      0   unless $args{$arg}
722   ***      0      0      0   unless $ddl
723   ***      0      0      0   if (ref $ddl eq 'ARRAY')
724   ***      0      0      0   if (lc $$ddl[0] eq 'table') { }
734   ***      0      0      0   if (not $ddl =~ /CREATE (?:TEMPORARY )?TABLE `/)
740   ***      0      0      0   if $name
758   ***      0      0      0   unless $type
760   ***      0      0      0   if ($type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/)
764   ***      0      0      0   if (not $def =~ /NOT NULL/)
768   ***      0      0      0   $def =~ /AUTO_INCREMENT/i ? :
799   ***      0      0      0   unless ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
813   ***      0      0      0   if ($index)
816   ***      0      0      0   if (not $best)
817   ***      0      0      0   if ($index) { }
830   ***      0      0      0   unless $where
836   ***      0      0      0   if ($$expl{'possible_keys'}) { }
840   ***      0      0      0   if ($$expl{'key'})
860   ***      0      0      0   unless $args{$arg}
874   ***      0      0      0   if ($EVAL_ERROR)
878   ***      0      0      0   if (not $$row[0] or $$row[0] ne $tbl)
884   ***      0      0      0   unless $args{'all_privs'}
891   ***      0      0      0   if ($EVAL_ERROR)
895   ***      0      0      0   if (not scalar keys %$row)
906   ***      0      0      0   $EVAL_ERROR ? :
911   ***      0      0      0   if (not $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete)
937   ***      0      0      0   if $key =~ /FOREIGN/
942   ***      0      0      0   if (not $engine =~ /MEMORY|HEAP/)
949   ***      0      0      0   if ($$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i)
956   ***      0      0      0   $key =~ /PRIMARY|UNIQUE/ ? :
980   ***      0      0      0   if ($engine =~ /InnoDB/i and not $clustered_key)
982   ***      0      0      0   if ($$this_key{'name'} eq 'PRIMARY') { }
      ***      0      0      0   elsif ($$this_key{'is_unique'} and not $$this_key{'is_nullable'}) { }
1006  ***      0      0      0   if (not $parent =~ /\./ and $$opts{'database'})
1035  ***      0      0      0   if (($$tbl_struct{'engine'} || '') =~ /InnoDB/i) { }
1049  ***      0      0      0   if (@sec_indexes)
1066  ***      0      0      0   defined $_ ? :
1106  ***      0      0      0   unless defined $val
1107  ***      0      0      0   if $val eq ''
1109  ***      0      0      0   if (not defined $is_numeric)
1110  ***      0      0      0   $val =~ /^0|\D/ ? :
1113  ***      0      0      0   if $is_numeric
1123  ***      0      0      0   if (not $tbl)
1132  ***      0      0      0   unless $like
1171  ***      0      0      0   unless $args{$arg}
1177  ***      0      0      0   exists $args{'strict'} ? :
1220  ***      0      0      0   unless open my $fh, '<', $file
1240  ***      0      0      0   unless $para =~ /^=head1 OPTIONS/
1245  ***      0      0      0   if $para =~ /^=over/
1253  ***      0      0      0   unless $para
1256  ***      0      0      0   if (my($option) = $para =~ /^=item --(.*)/)
1263  ***      0      0      0   if ($para =~ /: /) { }
1267  ***      0      0      0   unless $attributes{$attrib}
1271  ***      0      0      0   if ($attribs{'short form'})
1287  ***      0      0      0   if $para =~ /^=item/
1289  ***      0      0      0   if (my($base_option) = $option =~ /^\[no\](.*)/)
1294  ***      0      0      0   $attribs{'short form'} ? :
      ***      0      0      0   $attribs{'negatable'} ? :
      ***      0      0      0   $attribs{'cumulative'} ? :
      ***      0      0      0   $attribs{'type'} ? :
      ***      0      0      0   $attribs{'default'} ? :
      ***      0      0      0   $attribs{'group'} ? :
1306  ***      0      0      0   unless $para
1309  ***      0      0      0   if ($para =~ /^=head1/)
1313  ***      0      0      0   if $para =~ /^=item --/
1317  ***      0      0      0   unless @specs
1328  ***      0      0      0   if (ref $opt) { }
1333  ***      0      0      0   if (not $long)
1338  ***      0      0      0   if exists $$self{'opts'}{$long}
1341  ***      0      0      0   if (length $long == 1)
1346  ***      0      0      0   if ($short) { }
1347  ***      0      0      0   if exists $$self{'short_opts'}{$short}
1356  ***      0      0      0   $$opt{'spec'} =~ /!/ ? :
1357  ***      0      0      0   $$opt{'spec'} =~ /\+/ ? :
1358  ***      0      0      0   $$opt{'desc'} =~ /required/ ? :
1370  ***      0      0      0   if ($type and $type eq 'd' and not $$self{'dp'})
1375  ***      0      0      0   if $type and $type =~ /[HhAadzm]/
1377  ***      0      0      0   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
1378  ***      0      0      0   defined $def ? :
1382  ***      0      0      0   if ($long eq 'config')
1386  ***      0      0      0   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
1399  ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
1404  ***      0      0      0   if ($opt =~ /at least one|one and only one/)
1409  ***      0      0      0   if ($opt =~ /default to/)
1414  ***      0      0      0   if ($opt =~ /restricted to option groups/)
1424  ***      0      0      0   unless $rule_ok
1441  ***      0      0      0   unless exists $$self{'opts'}{$long}
1465  ***      0      0      0   unless exists $$self{'opts'}{$long}
1485  ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***      0      0      0   exists $$self{'opts'}{$opt} ? :
1490  ***      0      0      0   if ($$opt{'is_cumulative'}) { }
1505  ***      0      0      0   $$self{'opts'}{$long}{'is_cumulative'} ? :
      ***      0      0      0   exists $$self{'defaults'}{$long} ? :
1514  ***      0      0      0   if (@ARGV and $ARGV[0] eq '--config')
1518  ***      0      0      0   if ($self->has('config'))
1524  ***      0      0      0   if ($EVAL_ERROR)
1525  ***      0      0      0   $self->got('config') ? :
1540  ***      0      0      0   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
1543  ***      0      0      0   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
1544  ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
1550  ***      0      0      0   if (@ARGV and $$self{'strict'})
1556  ***      0      0      0   if (@set > 1)
1567  ***      0      0      0   if (@set == 0)
1577  ***      0      0      0   if ($$opt{'got'}) { }
      ***      0      0      0   elsif ($$opt{'is_required'}) { }
1578  ***      0      0      0   if (exists $$self{'disables'}{$long})
1585  ***      0      0      0   if (exists $$self{'allowed_groups'}{$long})
1597  ***      0      0      0   if $restricted_opt eq $long
1598  ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
1603  ***      0      0      0   if (@restricted_opts)
1605  ***      0      0      0   if (@restricted_opts == 1) { }
1634  ***      0      0      0   unless $opt and $$opt{'type'}
1637  ***      0      0      0   if ($val and $$opt{'type'} eq 'm') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'd') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'z') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
1640  ***      0      0      0   if (not $suffix)
1646  ***      0      0      0   if ($suffix =~ /[smhd]/) { }
1647  ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1662  ***      0      0      0   if ($from_key)
1673  ***      0      0      0   if (defined $num) { }
1674  ***      0      0      0   if ($factor)
1701  ***      0      0      0   length $opt == 1 ? :
1702  ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
1709  ***      0      0      0   length $opt == 1 ? :
1710  ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
1717  ***      0      0      0   length $opt == 1 ? :
1718  ***      0      0      0   defined $long ? :
1723  ***      0      0      0   length $opt == 1 ? :
1724  ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
1758  ***      0      0      0   if ($$self{'opts'}{'help'}{'got'}) { }
      ***      0      0      0   elsif (scalar @{$$self{'errors'};}) { }
1759  ***      0      0      0   unless print $self->print_usage
1763  ***      0      0      0   unless print $self->print_errors
1772  ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
1781  ***      0      0      0   unless $$self{'got_opts'}
1784  ***      0      0      0   $$_{'is_negatable'} ? :
1788  ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
1804  ***      0      0      0   $group eq 'default' ? :
1810  ***      0      0      0   $$opt{'is_negatable'} ? :
1813  ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
1822  ***      0      0      0   if ($short) { }
1831  ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
1835  ***      0      0      0   if ($$self{'dp'})
1843  ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
1855  ***      0      0      0   if ref $_[0] eq 'OptionParser'
1858  ***      0      0      0   unless print $prompt
1866  ***      0      0      0   unless print "\n"
1869  ***      0      0      0   if ($EVAL_ERROR)
1891  ***      0      0      0   unless open my $fh, '<', $filename
1899  ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
1902  ***      0      0      0   if ($line eq '--')
1907  ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
1925  ***      0      0      0   unless open my $fh, '<', $file
1929  ***      0      0      0   unless $para =~ /^=pod$/m
1933  ***      0      0      0   unless $para =~ /$regex/
1938  ***      0      0      0   unless close $fh
1952  ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
1967  ***      0      0      0   defined $_ ? :
2015  ***      0      0      0   defined $args{'p_ms'} ? :
2016  ***      0      0      0   defined $args{'p_s'} ? :
2019  ***      0      0      0   if $t < 0
2021  ***      0      0      0   if $t =~ /e/
2025  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
2046  ***      0      0      0   $p ? :
2053  ***      0      0      0   unless $secs
2055  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
2060  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
2079  ***      0      0      0   defined $args{'p'} ? :
2080  ***      0      0      0   defined $args{'d'} ? :
2087  ***      0      0      0   $num =~ /\./ || $n ? :
2096  ***      0      0      0   $gmt ? :
2102  ***      0      0      0   if (my($us) = $time =~ /(\.\d+)$/)
2112  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^$mysql_ts$/)
2115  ***      0      0      0   defined $f ? :
      ***      0      0      0   defined $f ? :
2124  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $us) = $val =~ /^$proper_ts$/)
2125  ***      0      0      0   $gmt ? :
2128  ***      0      0      0   if (defined $us)
2140  ***      0      0      0   if (my($n, $suffix) = $val =~ /^$n_ts$/) { }
      ***      0      0      0   elsif (my($ymd, $hms) = $val =~ /^(\d{6})(?:\s+(\d+:\d+:\d+))?/) { }
      ***      0      0      0   elsif (($ymd, $hms) = $val =~ /^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) { }
2141  ***      0      0      0   $suffix eq 'd' ? :
      ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
2151  ***      0      0      0   unless $hms
2156  ***      0      0      0   unless $hms
2161  ***      0      0      0   if $callback and ref $callback eq 'CODE'
2177  ***      0      0      0   defined $_ ? :
2225  ***      0      0      0   unless $args{$arg}
2243  ***      0      0      0   if ($stmt =~ s/$slow_log_hd_line//go)
2245  ***      0      0      0   if (@chunks > 1)
2252  ***      0      0      0   unless $stmt =~ /\A#/
2266  ***      0      0      0   if ($line =~ /^(?:#|use |SET (?:last_insert_id|insert_id|timestamp))/o) { }
2268  ***      0      0      0   if (not $got_ts and my($time) = $line =~ /$slow_log_ts_line/o) { }
      ***      0      0      0   elsif (not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o) { }
      ***      0      0      0   elsif (not $got_ac and $line =~ /^# (?:administrator command:.*)$/) { }
      ***      0      0      0   elsif ($line =~ /^# +[A-Z][A-Za-z_]+: \S+/) { }
      ***      0      0      0   elsif (not $got_db and my($db) = $line =~ /^use ([^;]+)/) { }
      ***      0      0      0   elsif (not $got_set and my($setting) = $line =~ /^SET\s+([^;]*)/) { }
2272  ***      0      0      0   if (not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o)
2315  ***      0      0      0   if (not $found_arg and $pos == $len)
2318  ***      0      0      0   if (defined(my $l = &$next_event())) { }
2335  ***      0      0      0   if ($args{'misc'} and $args{'misc'}{'embed'} and my($e) = $arg =~ /($args{'misc'}{'embed'})/)
2350  ***      0      0      0   if $args{'oktorun'}
2356  ***      0      0      0   defined $_ ? :
2391  ***      0      0      0   unless $args{$arg}
2410  ***      0      0      0   unless $args{'type_for'}
2421  ***      0      0      0   scalar keys %$attributes == 0 ? :
2444  ***      0      0      0   unless defined $group_by
2449  ***      0      0      0   if $$self{'unrolled_loops'}
2452  ***      0      0      0   if ($$self{'n_events'} <= $$self{'unroll_limit'}) { }
2454  ***      0      0      0   if $$self{'detect_attribs'}
2459  ***      0      0      0   if (not exists $$event{$attrib})
2463  ***      0      0      0   unless $alt_attrib
2467  ***      0      0      0   ref $group_by ? :
2472  ***      0      0      0   if (not $handler)
2481  ***      0      0      0   unless $handler
2504  ***      0      0      0   ref $group_by ? :
2519  ***      0      0      0   if (ref $group_by)
2529  ***      0      0      0   if $EVAL_ERROR
2556  ***      0      0      0   unless defined $attrib
2559  ***      0      0      0   if (ref $val eq 'ARRAY')
2563  ***      0      0      0   unless defined $val
2566  ***      0      0      0   $val =~ /^(?:Yes|No)$/ ? :
      ***      0      0      0   $val =~ /^(?:\d+|$float_re)$/o ? :
      ***      0      0      0   $self->type_for($attrib) ? :
2574  ***      0      0      0   $type =~ /num|bool/ ? :
      ***      0      0      0   $type =~ /bool|string/ ? :
      ***      0      0      0   $type eq 'num' ? :
      ***      0      0      0   $type eq 'bool' ? :
2589  ***      0      0      0   if ($args{'trf'})
2595  ***      0      0      0   if ($args{'min'})
2596  ***      0      0      0   $type eq 'num' ? :
2602  ***      0      0      0   if ($args{'max'})
2603  ***      0      0      0   $type eq 'num' ? :
2609  ***      0      0      0   if ($args{'sum'})
2612  ***      0      0      0   if ($args{'cnt'})
2615  ***      0      0      0   if ($args{'all'})
2624  ***      0      0      0   if ($args{'unq'})
2627  ***      0      0      0   if ($args{'wor'})
2628  ***      0      0      0   $type eq 'num' ? :
2637  ***      0      0      0   if ($attrib eq 'Query_time')
2645  ***      0      0      0   if ($args{'all'} and $type eq 'num' and $$self{'attrib_limit'})
2660  ***      0      0      0   $is_array ? :
      ***      0      0      0   $is_array ? :
2672  ***      0      0      0   $is_array ? :
      ***      0      0      0   $is_array ? :
2685  ***      0      0      0   if $EVAL_ERROR
2691  ***      0      0      0   if $val < 1e-06
2693  ***      0      0      0   $idx > 999 ? :
2698         100      5   4995   if $bucket == 0
2699  ***     50      0   4995   if $bucket < 0 or $bucket > 999
2706  ***      0      0      0   if @buck_tens
2737  ***      0      0      0   unless defined $vals and @$vals and $$args{'cnt'}
2741  ***      0      0      0   if ($n_vals == 1 or $$args{'max'} == $$args{'min'}) { }
      ***      0      0      0   elsif ($n_vals == 2) { }
2743  ***      0      0      0   $v > 0 ? :
2744  ***      0      0      0   $bucket < 0 ? :
      ***      0      0      0   $bucket > 7 ? :
2754  ***      0      0      0   $v && $v > 0 ? :
2755  ***      0      0      0   $bucket < 0 ? :
      ***      0      0      0   $bucket > 7 ? :
2767  ***      0      0      0   $n_vals >= 10 ? :
2785  ***      0      0      0   unless $val
2789  ***      0      0      0   if not $bucket_95 and $sum_excl > $top_vals
2791  ***      0      0      0   if (not $median and $total_left <= $mid)
2792  ***      0      0      0   $cutoff % 2 || $val > 1 ? :
2802  ***      0      0      0   $var > 0 ? :
2804  ***      0      0      0   $stddev > $maxstdev ? :
2821  ***      0      0      0   unless $args{$arg}
2830  ***      0      0      0   $global_cnt && $$store{'cnt'} ? :
      ***      0      0      0   $$store{'sum'} && $$store{'cnt'} ? :
2854  ***      0      0      0   if (!$args{'total'} || $total < $args{'total'} and !$args{'count'} || $count < $args{'count'}) { }
      ***      0      0      0   elsif ($args{'ol_attrib'} and !$args{'ol_freq'} || $$classes{$groupby}{$args{'ol_attrib'}}{'cnt'} >= $args{'ol_freq'}) { }
2869  ***      0      0      0   if ($$stats{'pct_95'} >= $args{'ol_limit'})
2882  ***      0      0      0   unless $event
2885  ***      0      0      0   if $_ ne $$self{'groupby'} and not exists $$self{'attributes'}{$_}
2915  ***      0      0      0   unless @attribs
2926  ***      0      0      0   if $EVAL_ERROR
2932  ***      0      0      0   defined $_ ? :
2978  ***      0      0      0   unless $query
2982  ***      0      0      0   if ($ddl_stmt)
2985  ***      0      0      0   if ($query =~ /$ddl_stmt DATABASE\b/i)
2989  ***      0      0      0   if ($ddl_stmt =~ /CREATE/i and $query =~ /$ddl_stmt\b.+?\bSELECT\b/i)
3001  ***      0      0      0   if ($query =~ /^\s*LOCK TABLES/i)
3019  ***      0      0      0   if (not $tbl =~ /[a-zA-Z]/)
3039  ***      0      0      0   unless $query
3055  ***      0      0      0   unless $tbl_refs and $from
3076  ***      0      0      0   if ($tbl_ref =~ /^AS\s+\w+/i)
3084  ***      0      0      0   if $db
3091  ***      0      0      0   unless $query
3100  ***      0      0      0   if (@split_statements == 1) { }
3107  ***      0      0      0   if ($statements[-2] and $statements[-2] =~ /on duplicate key\s+$/i)
3119  ***      0      0      0   unless $query
3129  ***      0      0      0   unless $query
3140  ***      0      0      0   if ($word =~ /^\(?SELECT\b/i) { }
3142  ***      0      0      0   if ($start_pos) { }
3160  ***      0      0      0   unless $sqno
3163  ***      0      0      0   if ($$sq{'done'})
3172  ***      0      0      0   if ($$sq{'lp'} + $lp - ($$sq{'rp'} + $rp) == 0)
3183  ***      0      0      0   unless $sq
3198  ***      0      0      0   if ($type =~ /^SELECT\b/) { }
      ***      0      0      0   elsif ($type =~ /^$data_manip_stmts\b/ or $type =~ /^$data_def_stmts\b/) { }
3214  ***      0      0      0   defined $_ ? :
3265  ***      0      0      0   unless $query
3268  ***      0      0      0   if ($query =~ /$vlc_rf/i)
3285  ***      0      0      0   unless $query =~ /IN\s*\(\s*(?!select)/i
3311  ***      0      0      0   unless @vals > 20
3323  ***      0      0      0   if $query =~ m[\ASELECT /\*!40001 SQL_NO_CACHE \*/ \* FROM `]
3325  ***      0      0      0   if $query =~ m[/\*\w+\.\w+:[0-9]/[0-9]\*/]
3327  ***      0      0      0   if $query =~ /\A# administrator command: /
3329  ***      0      0      0   if $query =~ /\A\s*(call\s+\S+)\(/i
3331  ***      0      0      0   if (my($beginning) = $query =~ /\A((?:INSERT|REPLACE)(?: IGNORE)?\s+INTO.+?VALUES\s*\(.*?\))\s*,\s*\(/is)
3337  ***      0      0      0   if $query =~ s/\Ause \S+\Z/use ?/i
3365  ***      0      0      0   if $query =~ /\A\s*call\s+(\S+)\(/i
3367  ***      0      0      0   if ($query =~ /\A# administrator command:/)
3372  ***      0      0      0   if $query =~ /\A\s*use\s+/
3374  ***      0      0      0   if $query =~ /\A\s*UNLOCK TABLES/i
3376  ***      0      0      0   if $query =~ /\A\s*xa\s+(\S+)/i
3381  ***      0      0      0   if ($query =~ /\A\s*SHOW\s+/i)
3384  ***      0      0      0   unless scalar @what
3387  ***      0      0      0   if ($what[0] =~ /CREATE/ or $what[1] and $what[1] =~ /STATUS/ or $what[0] =~ /MASTER/) { }
3393  ***      0      0      0   $what[0] =~ /GLOBAL/ ? :
3401  ***      0      0      0   if ($dds)
3403  ***      0      0      0   if $obj
3408  ***      0      0      0   $obj ? :
3425  ***      0      0      0   unless $qp
3433  ***      0      0      0   if $table
3446  ***      0      0      0   if ($args{'generic'}) { }
3448  ***      0      0      0   unless $cmd
3449  ***      0      0      0   $arg ? :
3457  ***      0      0      0   if ($args{'trf'})
3466  ***      0      0      0   unless $query
3485  ***      0      0      0   unless $query =~ s/
                 \A.*?
                 update\s+(.*?)
                 \s+set\b(.*?)
                 (?:\s*where\b(.*?))?
                 (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
                 \Z
              /__update_to_select($1, $2, $3, $4);/eisx or $query =~ s/
                    \A.*?
                    (?:insert|replace)\s+
                    .*?\binto\b(.*?)\(([^\)]+)\)\s*
                    values?\s*(\(.*?\))\s*
                    (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
                    \Z
                 /__insert_to_select($1, $2, $3);/eisx
3499  ***      0      0      0   $1 =~ /\*/ ? :
3508  ***      0      0      0   if ($join =~ /\bjoin\b/)
3522  ***      0      0      0   if (@cols == @vals) { }
3533  ***      0      0      0   $where ? :
      ***      0      0      0   $limit ? :
3540  ***      0      0      0   unless $query
3541  ***      0      0      0   $query =~ /\A\s*select/i ? :
3548  ***      0      0      0   defined $_ ? :
3577  ***      0      0      0   unless $args{$arg}
3580  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
3596  ***      0      0      0   unless defined(my $pid = fork)
3597  ***      0      0      0   if ($pid)
3604  ***      0      0      0   unless POSIX::setsid()
3605  ***      0      0      0   unless chdir '/'
3611  ***      0      0      0   if (-t STDIN)
3613  ***      0      0      0   unless open STDIN, '/dev/null'
3617  ***      0      0      0   if ($$self{'log_file'}) { }
3619  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
3623  ***      0      0      0   unless open STDERR, '>&STDOUT'
3627  ***      0      0      0   if (-t STDOUT)
3629  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
3632  ***      0      0      0   if (-t STDERR)
3634  ***      0      0      0   unless open STDERR, '>', '/dev/null'
3645  ***      0      0      0   $self ? :
3647  ***      0      0      0   if ($PID_file and -f $PID_file) { }
3650  ***      0      0      0   if $EVAL_ERROR
3652  ***      0      0      0   if ($pid) { }
3654  ***      0      0      0   if ($pid_is_alive) { }
3676  ***      0      0      0   if (exists $$self{'child'})
3688  ***      0      0      0   if (not $PID_file)
3695  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
3697  ***      0      0      0   unless print $PID_FH $PID
3699  ***      0      0      0   unless close $PID_FH
3708  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
3709  ***      0      0      0   unless unlink $$self{'PID_file'}
3721  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
3727  ***      0      0      0   defined $_ ? :
3757  ***      0      0      0   unless defined $args{$arg}
3784  ***      0      0      0   $$self{'replace'} && $action ne 'DELETE' ? :
3786  ***      0      0      0   if ($$self{'queue'}) { }
3794  ***      0      0      0   if ($EVAL_ERROR =~ /$DUPE_KEY/) { }
      ***      0      0      0   elsif ($EVAL_ERROR) { }
3809  ***      0      0      0   if ($$self{'replace'})
3810  ***      0      0      0   $action eq 'DELETE' ? :
3819  ***      0      0      0   if ($queue_level and $queue_level < $$self{'queue'})
3838  ***      0      0      0   if (not $error_count++ and $EVAL_ERROR =~ /$DUPE_KEY/) { }
      ***      0      0      0   elsif ($EVAL_ERROR) { }
3863  ***      0      0      0   if ($$self{'replace'})
3869  ***      0      0      0   if (my $dbh = $$self{'fetch_back'}) { }
3890  ***      0      0      0   if ($$self{'replace'})
3905  ***      0      0      0   if (my $dbh = $$self{'fetch_back'}) { }
3928  ***      0      0      0   defined $val ? :
3942  ***      0      0      0   if ($$self{'tbl_struct'}) { }
3949  ***      0      0      0   if (not defined $$pos{$_}) { }
3958  ***      0      0      0   if @not_in_tbl
3968  ***      0      0      0   defined $_ ? :
3994  ***      0      0      0   unless $args{'dbh'}
4010  ***      0      0      0   !$lr && !$left_done ? :
4014  ***      0      0      0   !$lr || $EVAL_ERROR ? :
4020  ***      0      0      0   !$rr && !$right_done ? :
4024  ***      0      0      0   !$rr || $EVAL_ERROR ? :
4031  ***      0      0      0   if ($lr and $rr)
4035  ***      0      0      0   if ($lr or $rr)
4036  ***      0      0      0   if ($lr and $rr and defined $cmp and $cmp == 0) { }
      ***      0      0      0   elsif (not $rr or defined $cmp and $cmp < 0) { }
4039  ***      0      0      0   if $$self{'same_row'}
4045  ***      0      0      0   if $$self{'not_in_right'}
4051  ***      0      0      0   if $$self{'not_in_left'}
4055  ***      0      0      0   if $done and &$done($left, $right)
4069  ***      0      0      0   if (not defined $l or not defined $r) { }
4071  ***      0      0      0   defined $r ? :
      ***      0      0      0   defined $l ? :
4074  ***      0      0      0   if ($$tbl{'is_numeric'}{$col}) { }
      ***      0      0      0   elsif ($l ne $r) { }
4076  ***      0      0      0   if $trf
4078  ***      0      0      0   if ($cmp)
4080  ***      0      0      0   if $callback
4087  ***      0      0      0   if ($coll and $coll ne 'latin1_swedish_ci' || $l =~ /[^\040-\177]/ || $r =~ /[^\040-\177]/) { }
4096  ***      0      0      0   if ($cmp)
4098  ***      0      0      0   if $callback
4109  ***      0      0      0   if (not $$self{'sth'}{$collation})
4110  ***      0      0      0   if (not $$self{'charset_for'})
4131  ***      0      0      0   defined $_ ? :
4164  ***      0      0      0   unless $args{$arg}
4179  ***      0      0      0   unless $args{$arg}
4186  ***      0      0      0   unless $$index{'type'} eq 'BTREE'
4190  ***      0      0      0   if ($args{'exact'})
4191  ***      0      0      0   unless $$index{'is_unique'} and @{$$index{'cols'};} == 1
4204  ***      0      0      0   unless $int_types{$$tbl_struct{'type_for'}{$col}} or $real_types{$$tbl_struct{'type_for'}{$col}}
4210  ***      0      0      0   if $args{'exact'} and scalar @candidate_cols
4220  ***      0      0      0   if ($$tbl_struct{'keys'}{'PRIMARY'})
4243  ***      0      0      0   unless defined $args{$arg}
4254  ***      0      0      0   if ($col_type =~ /(?:int|year|float|double|decimal)$/) { }
      ***      0      0      0   elsif ($col_type eq 'timestamp') { }
      ***      0      0      0   elsif ($col_type eq 'date') { }
      ***      0      0      0   elsif ($col_type eq 'time') { }
      ***      0      0      0   elsif ($col_type eq 'datetime') { }
4286  ***      0      0      0   if (not defined $start_point)
4290  ***      0      0      0   if (not defined $end_point or $end_point < $start_point)
4299  ***      0      0      0   if ($int_types{$col_type})
4303  ***      0      0      0   if ($args{'exact'})
4309  ***      0      0      0   if ($start_point < $end_point) { }
4315  ***      0      0      0   if ($iter++ == 0) { }
4325  ***      0      0      0   if (@chunks) { }
4329  ***      0      0      0   $nullable ? :
4331  ***      0      0      0   if ($nullable)
4347  ***      0      0      0   unless $args{$arg}
4357  ***      0      0      0   unless $args{$arg}
4366  ***      0      0      0   if ($suffix) { }
      ***      0      0      0   elsif ($num) { }
4367  ***      0      0      0   $suffix eq 'M' ? :
      ***      0      0      0   $suffix eq 'k' ? :
4379  ***      0      0      0   if ($suffix or $args{'avg_row_length'})
4382  ***      0      0      0   if (not defined $n_rows)
4383  ***      0      0      0   $avg_row_length ? :
4387  ***      0      0      0   wantarray ? :
4394  ***      0      0      0   unless $args{$arg}
4399  ***      0      0      0   $where ? :
4407  ***      0      0      0   if ($EVAL_ERROR)
4409  ***      0      0      0   if ($EVAL_ERROR =~ /in your SQL syntax/) { }
4416  ***      0      0      0   $where ? :
4429  ***      0      0      0   $val =~ /\d[:-]/ ? :
4435  ***      0      0      0   unless defined $args{$arg}
4444  ***      0      0      0   if ($args{'where'} and grep {$_;} @{$args{'where'};})
4467  ***      0      0      0   if $start =~ /e/
4468  ***      0      0      0   if $end =~ /e/
4473  ***      0      0      0   if ($end > $start) { }
4519  ***      0      0      0   unless $check eq $time
4530  ***      0      0      0   defined $_ ? :
4558  ***      0      0      0   unless $args{$arg}
4568  ***      0      0      0   unless defined $args{$arg}
4571  ***      0      0      0   $args{'cols'} ? :
4574  ***      0      0      0   unless exists $$tbl_struct{'keys'}{$index}
4583  ***      0      0      0   if ($args{'asc_first'})
4590  ***      0      0      0   if (not exists $col_posn{$col})
4606  ***      0      0      0   if (@asc_slice)
4618  ***      0      0      0   $args{'asc_only'} ? :
4630  ***      0      0      0   unless defined $args{$arg}
4651  ***      0      0      0   if ($$is_nullable{$col}) { }
4667  ***      0      0      0   if ($$is_nullable{$col}) { }
4668  ***      0      0      0   if ($type =~ /=/ and $end) { }
      ***      0      0      0   elsif ($type =~ />/) { }
4683  ***      0      0      0   $type =~ /=/ && $end ? :
4701  ***      0      0      0   $args{'cols'} ? :
4709  ***      0      0      0   unless $index
4711  ***      0      0      0   if ($index) { }
4721  ***      0      0      0   if (not exists $col_posn{$col})
4742  ***      0      0      0   if ($$tbl{'is_nullable'}{$col}) { }
4762  ***      0      0      0   unless $args{$arg}
4767  ***      0      0      0   unless @sel_cols
4772  ***      0      0      0   unless $$ins_tbl{'is_col'}{$sel_cols[$i]}
4785  ***      0      0      0   defined $_ ? :
4818  ***      0      0      0   unless defined $args{$arg}
4831  ***      0      0      0   $comp & 1 ? :
4841  ***      0      0      0   if (uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64')
4861  ***      0      0      0   if ($type eq 'bigint' and $length < 20)
4875  ***      0      0      0   if $alg and not $ALGOS{$alg}
4878  ***      0      0      0   if ($args{'where'} or $args{'chunk'} or $args{'replicate'} or not $vp->version_ge($dbh, '4.1.1'))
4887  ***      0      0      0   if (not $vp->version_ge($dbh, '4.1.1'))
4892  ***      0      0      0   if ($alg and grep {$_ eq $alg;} @choices)
4897  ***      0      0      0   if ($args{'count'} and grep {$_ ne 'CHECKSUM';} @choices)
4914  ***      0      0      0   if ($args{'function'})
4927  ***      0      0      0   if ($EVAL_ERROR and $EVAL_ERROR =~ /failed: (.*?) at \S+ line/)
4933  ***      0      0      0   unless $result
4942  ***      0      0      0   if $func =~ /^(?:FNV1A_64|FNV_64|CRC32)$/i
4949  ***      0      0      0   length $unsliced < 16 ? :
4962  ***      0      0      0   if ($sliced ne $unsliced)
4969  ***      0      0      0   if ($sliced eq $unsliced) { }
4982  ***      0      0      0   unless defined $args{$arg}
4989  ***      0      0      0   if ($len > 16)
4998  ***      0      0      0   if (defined $opt_slice and $opt_slice < @slices) { }
5021  ***      0      0      0   $args{'cols'} ? :
5026  ***      0      0      0   if ($type eq 'timestamp') { }
      ***      0      0      0   elsif ($type =~ /float|double/ and $args{'float_precision'}) { }
      ***      0      0      0   elsif ($type =~ /varchar/ and $args{'trim'}) { }
5043  ***      0      0      0   if (uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64') { }
5045  ***      0      0      0   if (@nulls)
5052  ***      0      0      0   @cols > 1 ? :
5068  ***      0      0      0   unless $args{$arg}
5076  ***      0      0      0   unless $algorithm and $ALGOS{$algorithm}
5079  ***      0      0      0   if ($algorithm eq 'CHECKSUM')
5085  ***      0      0      0   if ($algorithm eq 'BIT_XOR') { }
5086  ***      0      0      0   if ($crc_type =~ /int$/) { }
5095  ***      0      0      0   if ($crc_type =~ /int$/) { }
5108  ***      0      0      0   if ($args{'replicate'}) { }
5114  ***      0      0      0   $args{'buffer'} ? :
5144  ***      0      0      0   defined $_ ? :
5176  ***      0      0      0   unless defined $args{$arg}
5185  ***      0      0      0   unless $args{$arg}
5191  ***      0      0      0   if ($can_sync)
5205  ***      0      0      0   unless $args{$arg}
5211  ***      0      0      0   unless defined $args{'index_hint'}
5221  ***      0      0      0   unless $plugin
5230  ***      0      0      0   if (not $args{'replicate'}) { }
5231  ***      0      0      0   $vp->version_ge($$src{'dbh'}, '4.0.9') && $vp->version_ge($$dst{'dbh'}, '4.0.9') ? :
5234  ***      0      0      0   if ($args{'chunk_index'}) { }
      ***      0      0      0   elsif ($plugin_args{'chunk_index'} and $args{'index_hint'}) { }
5259  ***      0      0      0   if ($EVAL_ERROR)
5264  ***      0      0      0   if ($plugin->uses_checksum)
5269  ***      0      0      0   if ($EVAL_ERROR)
5274  ***      0      0      0   if ($args{'dry_run'})
5283  ***      0      0      0   if ($EVAL_ERROR)
5304  ***      0      0      0   if ($args{'transaction'})
5305  ***      0      0      0   if ($args{'changing_src'}) { }
5318  ***      0      0      0   if $callback
5321  ***      0      0      0   if ($args{'buffer_to_client'})
5327  ***      0      0      0   if (not $cycle or not $plugin->pending_changes)
5332  ***      0      0      0   unless $executed_src
5358  ***      0      0      0   unless $args{$arg}
5377  ***      0      0      0   if ($src_algo ne $dst_algo)
5385  ***      0      0      0   if ($src_func ne $dst_func)
5395  ***      0      0      0   if ($src_algo eq 'BIT_XOR' and not $crc_type =~ /int$/)
5434  ***      0      0      0   unless defined $args{$arg}
5439  ***      0      0      0   unless $args{'lock'} and $args{'lock'} <= $args{'lock_level'}
5442  ***      0      0      0   if ($args{'transaction'}) { }
5461  ***      0      0      0   unless defined $args{$arg}
5466  ***      0      0      0   unless $args{'lock'} and $args{'lock'} == $args{'lock_level'}
5469  ***      0      0      0   if ($args{'transaction'}) { }
5480  ***      0      0      0   if ($args{'lock'} == 3) { }
5486  ***      0      0      0   if ($args{'transaction'}) { }
5487  ***      0      0      0   if ($args{'src_sth'})
5494  ***      0      0      0   $args{'changing_src'} ? :
5501  ***      0      0      0   if ($args{'wait'})
5506  ***      0      0      0   if ($args{'changing_src'}) { }
5511  ***      0      0      0   if ($args{'lock'} == 3) { }
      ***      0      0      0   elsif (not $args{'transaction'}) { }
5517  ***      0      0      0   $args{'execute'} ? :
5524  ***      0      0      0   if ($EVAL_ERROR)
5525  ***      0      0      0   if ($args{'src_sth'}{'Active'})
5529  ***      0      0      0   unless $dbh
5532  ***      0      0      0   unless $$dbh{'AutoCommit'}
5551  ***      0      0      0   $EVAL_ERROR ? :
5555  ***      0      0      0   if ($privs =~ /select/ and $privs =~ /insert/ and $privs =~ /update/ and $can_delete)
5566  ***      0      0      0   defined $_ ? :
5598  ***      0      0      0   unless defined $args{$arg}
5611  ***      0      0      0   unless defined $args{$arg}
5618  ***      0      0      0   unless $exact
5621  ***      0      0      0   if ($args{'chunk_col'} or $args{'chunk_index'}) { }
5625  ***      0      0      0   if ($args{'chunk_col'})
5626  ***      0      0      0   unless $chunkable_cols[$i]{'column'} eq $args{'chunk_col'}
5628  ***      0      0      0   if ($args{'chunk_index'})
5629  ***      0      0      0   unless $chunkable_cols[$i]{'index'} eq $args{'chunk_index'}
5635  ***      0      0      0   if (not $colno)
5659  ***      0      0      0   unless defined $args{$arg}
5672  ***      0      0      0   if (not $args{'replicate'}) { }
5674  ***      0      0      0   if (not grep {not defined $range_params{$_};} 'min', 'max', 'rows_in_range') { }
5701  ***      0      0      0   unless $chunk_sql
5702  ***      0      0      0   unless $row_sql
5718  ***      0      0      0   if ($$self{'state'}) { }
5728  ***      0      0      0   $$self{'buffer_in_mysql'} ? :
      ***      0      0      0   $args{'where'} ? :
5745  ***      0      0      0   if ($$self{'state'}) { }
      ***      0      0      0   elsif ($$lr{'cnt'} != $$rr{'cnt'} or $$lr{'crc'} ne $$rr{'crc'}) { }
5746  ***      0      0      0   if ($$lr{$$self{'crc_col'}} ne $$rr{$$self{'crc_col'}})
5759  ***      0      0      0   unless $$self{'state'}
5766  ***      0      0      0   unless $$self{'state'}
5773  ***      0      0      0   if ($$self{'state'} == 1) { }
5797  ***      0      0      0   if ($$self{'state'}) { }
5810  ***      0      0      0   if ($$self{'state'} == 0) { }
5822  ***      0      0      0   defined $_ ? :
5854  ***      0      0      0   unless defined $args{$arg}
5867  ***      0      0      0   unless defined $args{$arg}
5871  ***      0      0      0   if ($nibble_index) { }
5873  ***      0      0      0   if (not $args{'tbl_struct'}{'keys'}{$nibble_index}{'is_unique'})
5877  ***      0      0      0   if ($args{'chunk_index'} and $args{'chunk_index'} ne $nibble_index)
5889  ***      0      0      0   if ($args{'src'} and $args{'src'}{'dbh'})
5901  ***      0      0      0   if ($table_status)
5902  ***      0      0      0   defined $$table_status{'rows'} ? :
      ***      0      0      0   defined $$table_status{'Rows'} ? :
5905  ***      0      0      0   if defined $n_rows and $n_rows <= 100
5924  ***      0      0      0   unless defined $args{$arg}
5939  ***      0      0      0   if (not $args{'replicate'}) { }
5966  ***      0      0      0   unless $nibble_sql
5967  ***      0      0      0   unless $row_sql
5983  ***      0      0      0   if ($$self{'state'}) { }
5993  ***      0      0      0   $$self{'buffer_in_mysql'} ? :
      ***      0      0      0   $$self{'index_hint'} ? :
      ***      0      0      0   $args{'where'} ? :
6014  ***      0      0      0   if (not $s)
6023  ***      0      0      0   if ($$self{'cached_boundaries'})
6028  ***      0      0      0   if ($$self{'cached_row'} and $$self{'cached_nibble'} == $$self{'nibble'}) { }
6037  ***      0      0      0   if ($$self{'nibble'} == 0 and not $$self{'small_table'})
6039  ***      0      0      0   if (lc($explain_index || '') ne lc $$s{'index'})
6040  ***      0      0      0   $explain_index ? :
6051  ***      0      0      0   if ($row) { }
6061  ***      0      0      0   $lb ? :
6081  ***      0      0      0   if ($$self{'nibble'})
6097  ***      0      0      0   unless $sql
6102  ***      0      0      0   if ($EVAL_ERROR)
6112  ***      0      0      0   if ($$self{'state'}) { }
      ***      0      0      0   elsif ($$lr{'cnt'} != $$rr{'cnt'} or ($$lr{'crc'} || 0) ne ($$rr{'crc'} || 0)) { }
6113  ***      0      0      0   if ($$lr{$$self{'crc_col'}} ne $$rr{$$self{'crc_col'}})
6127  ***      0      0      0   unless $$self{'state'}
6133  ***      0      0      0   unless $$self{'state'}
6139  ***      0      0      0   if ($$self{'state'} == 1) { }
6161  ***      0      0      0   if ($$self{'state'}) { }
6174  ***      0      0      0   if ($$self{'state'} == 0) { }
6186  ***      0      0      0   defined $_ ? :
6213  ***      0      0      0   unless $args{$arg}
6231  ***      0      0      0   unless defined $args{$arg}
6265  ***      0      0      0   $$self{'buffer_in_mysql'} ? :
6279  ***      0      0      0   unless $diff
6285  ***      0      0      0   if ($lc > $rc) { }
6334  ***      0      0      0   defined $_ ? :
6368  ***      0      0      0   unless print $fh escape($row), "\n"
6376  ***      0      0      0   if defined $_
6378  ***      0      0      0   defined $_ ? :
6384  ***      0      0      0   defined $_ ? :
6411  ***      0      0      0   unless defined $args{$arg}
6465  ***      0      0      0   $dbh->type_info($_)->{'NULLABLE'} == 1 ? :
6480  ***      0      0      0   $type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ? :
6482  ***      0      0      0   $type =~ /(?:char|varchar)/ && $p[$i] ? :
      ***      0      0      0   $type =~ /(?:decimal)/ ? :
      ***      0      0      0   $type =~ /(?:float|double)/ ? :
6501  ***      0      0      0   defined $_ ? :
6547  ***      0      0      0   if ($$self{'cursor'} < $$self{'n_rows'})
6557  ***      0      0      0   if ($$self{'cursor'} < $$self{'n_rows'})
6559  ***      0      0      0   unless @cols
6570  ***      0      0      0   defined $_ ? :
6608  ***      0      0      0   if (not $$self{$dbh})
6612  ***      0      0      0   $$self{$dbh} ge $self->parse($target) ? :
6619  ***      0      0      0   defined $_ ? :
6652  ***      0      0      0   unless $args{$arg}
6674  ***      0      0      0   unless defined $$col{'name'}
6675  ***      0      0      0   if ($$col{'fixed_wdith'} and $$col{'fixed_width'} < length $$col{'name'})
6690  ***      0      0      0   unless $n_cols == $n_vals
6698  ***      0      0      0   if ($$col{'fixed_width'} and $width > $$col{'fixed_width'})
6699  ***      0      0      0   if ($$col{'truncate'}) { }
6721  ***      0      0      0   $$self{'long_last_column'} ? :
6728  ***      0      0      0   $$col{'right_justify'} ? :
6734  ***      0      0      0   if ($$self{'long_last_column'})
6740  ***      0      0      0   if $$self{'title'}
6745  ***      0      0      0   if ($$self{'underline_header'})
6753  ***      0      0      0   if ($$self{'truncate_underline'} and 2 + $underline_len > $$self{'line_width'})
6771  ***      0      0      0   defined $_ ? :
6819  ***      0      0      0   unless $args{$arg}
6859  ***      0      0      0   if ($stats and $$stats{$thing}) { }
6874  ***      0      0      0   if ($stats and $$stats{$thing}) { }
6876  ***      0      0      0   $thing =~ /time$/ ? :
6883  ***      0      0      0   defined $_ ? :
6891  ***      0      0      0   if (scalar @vals and grep {defined $_;} @vals)
6896  ***      0      0      0   $_ && defined $$_[$i] ? :
6918  ***      0      0      0   if (exists $$stats{'unq'}) { }
6920  ***      0      0      0   if (1 == keys %$cnt_for)
6922  ***      0      0      0   if length $str > 44
6927  ***      0      0      0   unless $$cnt_for{$b} <=> $$cnt_for{$a}
6932  ***      0      0      0   if (length $str > 10) { }
6938  ***      0      0      0   if length($line) + length($print_str) > 47
6943  ***      0      0      0   if ($i < @top)
6955  ***      0      0      0   defined $_ ? :
6989  ***      0      0      0   unless $args{$arg}
7003  ***      0      0      0   unless $args{$arg}
7008  ***      0      0      0   if ($$self{'method'} eq 'checksum')
7010  ***      0      0      0   if $args{'temp-database'}
7011  ***      0      0      0   unless $db
7024  ***      0      0      0   if $EVAL_ERROR
7041  ***      0      0      0   unless $args{$arg}
7049  ***      0      0      0   if ($$self{'method'} eq 'rows') { }
7055  ***      0      0      0   if $EVAL_ERROR
7063  ***      0      0      0   if $EVAL_ERROR
7068  ***      0      0      0   unless $$event{'wrapped_query'}
7076  ***      0      0      0   if ($EVAL_ERROR)
7092  ***      0      0      0   unless $args{$arg}
7101  ***      0      0      0   unless $args{$arg}
7104  ***      0      0      0   $$self{'method'} eq 'rows' ? :
7112  ***      0      0      0   unless $args{$arg}
7127  ***      0      0      0   if ($i)
7128  ***      0      0      0   if (($$events[0]{'checksum'} || 0) != ($$events[$i]{'checksum'} || 0))
7132  ***      0      0      0   if (($$events[0]{'row_count'} || 0) != ($$events[$i]{'row_count'} || 0))
7144  ***      0      0      0   if ($different_checksums)
7149  ***      0      0      0   if ($different_row_counts)
7167  ***      0      0      0   unless $args{$arg}
7174  ***      0      0      0   if ($$event{'wrapped_query'} and $$event{'tmp_tbl'}) { }
7185  ***      0      0      0   if $EVAL_ERROR
7210  ***      0      0      0   unless $args{$arg}
7225  ***      0      0      0   if (not $$event0{'results_sth'})
7303  ***      0      0      0   if $$event0{'row_count'} != $$event{'row_count'}
7304  ***      0      0      0   if ($different_row_counts)
7311  ***      0      0      0   if ($no_diff)
7319  ***      0      0      0   if (not $left_outfile)
7323  ***      0      0      0   if (not $right_outfile)
7339  ***      0      0      0   if (scalar @diff_rows)
7362  ***      0      0      0   unless $args{$arg}
7385  ***      0      0      0   if ($args{'add-indexes'})
7411  ***      0      0      0   if ($l_r[0] and $l_r[1]) { }
      ***      0      0      0   elsif ($l_r[0]) { }
      ***      0      0      0   elsif ($l_r[1]) { }
7434  ***      0      0      0   if $l_r[1]
7436  ***      0      0      0   if $l_r[0] and $l_r[1]
7441  ***      0      0      0   if $l_r[0]
7443  ***      0      0      0   if $l_r[0] and $l_r[1]
7449  ***      0      0      0   if ($n_diff >= $max_diff)
7458  ***      0      0      0   if (my $n = $args{'float-precision'})
7461  ***      0      0      0   unless $$tbl{'type_for'}{$col} =~ /(?:float|double|decimal)/
7511  ***      0      0      0   if ($n_diff < $max_diff)
7512  ***      0      0      0   if $l_r[0] or $l_r[1]
7522  ***      0      0      0   unless $args{$arg}
7535  ***      0      0      0   unless close $fh
7542  ***      0      0      0   unless open my $fh, '>', $outfile
7567  ***      0      0      0   unless $args{$arg}
7580  ***      0      0      0   if ($db) { }
7587  ***      0      0      0   if ($EVAL_ERROR)
7591  ***      0      0      0   $$_{'is_unique'} ? :
7603  ***      0      0      0   unless @keys
7613  ***      0      0      0   if ($EVAL_ERROR) { }
7628  ***      0      0      0   unless $args{$arg}
7632  ***      0      0      0   unless keys %{$$self{'diffs'};}
7659  ***      0      0      0   unless $args{$arg}
7664  ***      0      0      0   unless keys %{$$self{'diffs'}{'checksums'};}
7690  ***      0      0      0   unless $args{$arg}
7695  ***      0      0      0   unless keys %{$$self{'diffs'}{'col_vals'};}
7725  ***      0      0      0   unless $args{$arg}
7730  ***      0      0      0   unless keys %{$$self{'diffs'}{'row_counts'};}
7757  ***      0      0      0   unless $item
7774  ***      0      0      0   defined $_ ? :
7811  ***      0      0      0   unless $args{$arg}
7825  ***      0      0      0   unless $args{$arg}
7834  ***      0      0      0   unless $args{$arg}
7838  ***      0      0      0   if (exists $$event{'Query_time'})
7854  ***      0      0      0   if $EVAL_ERROR
7865  ***      0      0      0   unless $args{$arg}
7874  ***      0      0      0   unless $args{$arg}
7892  ***      0      0      0   if ($b0 != $b) { }
7901  ***      0      0      0   if ($inc >= $bucket_threshold[$b0])
7917  ***      0      0      0   unless defined $val
7918  ***      0      0      0   if $val == 0
7920  ***      0      0      0   $bucket < 0 ? :
      ***      0      0      0   $bucket > 7 ? :
7926  ***      0      0      0   if $x == $y
7928  ***      0      0      0   if ($x > $y)
7934  ***      0      0      0   if ($x == 0)
7945  ***      0      0      0   unless $args{$arg}
7949  ***      0      0      0   unless keys %{$$self{'diffs'};}
7976  ***      0      0      0   unless $args{$arg}
7981  ***      0      0      0   unless keys %{$$self{'diffs'}{'big'};}
8011  ***      0      0      0   unless $args{$arg}
8016  ***      0      0      0   unless keys %{$$self{'diffs'}{'in_bucket'};}
8045  ***      0      0      0   unless $item
8062  ***      0      0      0   defined $_ ? :
8094  ***      0      0      0   unless $args{$arg}
8108  ***      0      0      0   unless $args{$arg}
8113  ***      0      0      0   unless $$self{'clear-warnings'}
8115  ***      0      0      0   if (my $tbl = $$self{'clear-warnings-table'}) { }
8121  ***      0      0      0   if $EVAL_ERROR
8136  ***      0      0      0   if ($EVAL_ERROR) { }
8145  ***      0      0      0   unless $ok
8156  ***      0      0      0   unless $args{$arg}
8160  ***      0      0      0   if (exists $$event{'Query_time'})
8176  ***      0      0      0   if $EVAL_ERROR
8187  ***      0      0      0   unless $args{$arg}
8197  ***      0      0      0   if $EVAL_ERROR
8213  ***      0      0      0   unless $args{$arg}
8230  ***      0      0      0   if (($$event0{'warning_count'} || 0) != ($$event{'warning_count'} || 0))
8241  ***      0      0      0   if not $w0 and not $w
8245  ***      0      0      0   if (exists $$w{$code}) { }
8246  ***      0      0      0   if ($$w{$code}{'Level'} ne $$w0{$code}{'Level'})
8289  ***      0      0      0   unless $args{$arg}
8293  ***      0      0      0   unless keys %{$$self{'diffs'};}
8320  ***      0      0      0   unless $args{$arg}
8325  ***      0      0      0   unless keys %{$$self{'diffs'}{'warnings'};}
8354  ***      0      0      0   unless $args{$arg}
8359  ***      0      0      0   unless keys %{$$self{'diffs'}{'levels'};}
8390  ***      0      0      0   unless $args{$arg}
8395  ***      0      0      0   unless keys %{$$self{'diffs'}{'warning_counts'};}
8422  ***      0      0      0   unless $item
8439  ***      0      0      0   defined $_ ? :
8498  ***      0      0      0   if (not $o->get('help'))
8499  ***      0      0      0   if (@ARGV < 1)
8502  ***      0      0      0   if (my $compare_method = $o->get('compare-results-method'))
8504  ***      0      0      0   unless $valid_method{lc $compare_method}
8513  ***      0      0      0   if (not -f $arg) { }
8515  ***      0      0      0   $$hosts[-1] ? :
8531  ***      0      0      0   if (@files == 0)
8535  ***      0      0      0   if (@$hosts == 0)
8541  ***      0      0      0   if ($o->get('explain-hosts'))
8593  ***      0      0      0   if ($$compare{'results'})
8598  ***      0      0      0   if ($method eq 'rows')
8613  ***      0      0      0   if ($$compare{'query_times'})
8620  ***      0      0      0   if ($$compare{'warnings'})
8624  ***      0      0      0   if (not $vp->version_ge($$host{'dbh'}, '4.1.0'))
8631  ***      0      0      0   if ($have_warnings)
8668  ***      0      0      0   if (my $query = $o->get('query')) { }
8672  ***      0      0      0   if $args{'oktorun'}
8692  ***      0      0      0   if (($$event{'cmd'} || '') ne 'Query')
8697  ***      0      0      0   if (not $$event{'arg'})
8706  ***      0      0      0   if ($o->get('filter'))
8708  ***      0      0      0   if (-f $filter and -r $filter) { }
8710  ***      0      0      0   unless open my $fh, '<', $filter
8719  ***      0      0      0   unless my $sub = eval $code
8724  ***      0      0      0   if ($o->get('convert-to-select')) { }
8728  ***      0      0      0   if $$event{'arg'} =~ m[(?:^SELECT|(?:\*/\s*SELECT))]i
8730  ***      0      0      0   if ($new_arg =~ /^SELECT/i)
8745  ***      0      0      0   if (not $$event{'arg'} =~ m[(?:^SELECT|(?:\*/\s*SELECT))]i)
8763  ***      0      0      0   unless $allowed_attribs{$_}
8790  ***      0      0      0   if ($db and !$current_db || $db ne $current_db)
8796  ***      0      0      0   if ($EVAL_ERROR)
8798  ***      0      0      0   $EVAL_ERROR =~ /Unknown database/ ? :
8804  ***      0      0      0   unless $current_db
8842  ***      0      0      0   if ($bad_module{$module})
8858  ***      0      0      0   if ($EVAL_ERROR)
8873  ***      0      0      0   $$host_event{'warning_count'} && $$host_event{'warning_count'} > 0 ? :
8906  ***      0      0      0   if (exists $host_events[$i]{'Query_time'} and $o->get('zero-query-times'))
8921  ***      0      0      0   if ($o->get('daemonize')) { }
      ***      0      0      0   elsif ($o->get('pid')) { }
8953  ***      0      0      0   if (not $fh)
8955  ***      0      0      0   if (not $file)
8960  ***      0      0      0   if ($file eq '-') { }
8965  ***      0      0      0   if (not open $fh, '<', $file)
8979  ***      0      0      0   unless $oktorun
8988  ***      0      0      0   unless $event
8992  ***      0      0      0   if ($EVAL_ERROR)
8996  ***      0      0      0   if $EVAL_ERROR =~ /Cannot open/
8997  ***      0      0      0   unless $o->get('continue-on-error')
8999  ***      0      0      0   if (not $more_events)
9001  ***      0      0      0   if $fh
9010  ***      0      0      0   if (not $meta_ea->events_processed)
9021  ***      0      0      0   if ($limit =~ /^\d+$/) { }
9043  ***      0      0      0   if ($o->get('reports')->{'queries'})
9059  ***      0      0      0   if ($$sample{'original_arg'})
9061  ***      0      0      0   if ($o->get('shorten'))
9066  ***      0      0      0   if ($o->get('fingerprints'))
9069  ***      0      0      0   if $o->get('shorten')
9088  ***      0      0      0   if ($o->get('reports')->{'differences'})
9091  ***      0      0      0   if $report
9095  ***      0      0      0   if ($o->get('reports')->{'errors'})
9099  ***      0      0      0   if ($o->get('reports')->{'statistics'})
9129  ***      0      0      0   if $$host{'dbh'}
9143  ***      0      0      0   unless $args{$arg}
9147  ***      0      0      0   unless keys %$errors
9173  ***      0      0      0   if $report
9180  ***      0      0      0   if ($o->get('ask-pass'))
9190  ***      0      0      0   if ($oktorun) { }
9202  ***      0      0      0   defined $_ ? :


Conditions
----------

and 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
4210  ***      0      0      0   $args{'exact'} and scalar @candidate_cols

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
134   ***     66     40     40      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33     80      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
256   ***     66     10      0     10   not $dbh and $tries--
292   ***     33     10      0      0   not $dbh and $EVAL_ERROR
449   ***      0      0      0      0   $trgs and @$trgs
495   ***      0      0      0      0   $curr and $new
      ***      0      0      0      0   $curr and $new and $curr eq $new
911   ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete
949   ***      0      0      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000'
      ***      0      0      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i
980   ***      0      0      0      0   $engine =~ /InnoDB/i and not $clustered_key
982   ***      0      0      0      0   $$this_key{'is_unique'} and not $$this_key{'is_nullable'}
1006  ***      0      0      0      0   not $parent =~ /\./ and $$opts{'database'}
1370  ***      0      0      0      0   $type and $type eq 'd'
      ***      0      0      0      0   $type and $type eq 'd' and not $$self{'dp'}
1375  ***      0      0      0      0   $type and $type =~ /[HhAadzm]/
1514  ***      0      0      0      0   @ARGV and $ARGV[0] eq '--config'
1543  ***      0      0      0      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
1550  ***      0      0      0      0   @ARGV and $$self{'strict'}
1634  ***      0      0      0      0   $opt and $$opt{'type'}
1637  ***      0      0      0      0   $val and $$opt{'type'} eq 'm'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'd'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'z'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'a'
1702  ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
1710  ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
1724  ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
1813  ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
1907  ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
2025  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
2083  ***      0      0      0      0   $num >= $d and $n < @units - 1
2161  ***      0      0      0      0   $callback and ref $callback eq 'CODE'
2268  ***      0      0      0      0   not $got_ts and my($time) = $line =~ /$slow_log_ts_line/o
      ***      0      0      0      0   not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o
      ***      0      0      0      0   not $got_ac and $line =~ /^# (?:administrator command:.*)$/
      ***      0      0      0      0   not $got_db and my($db) = $line =~ /^use ([^;]+)/
      ***      0      0      0      0   not $got_set and my($setting) = $line =~ /^SET\s+([^;]*)/
2272  ***      0      0      0      0   not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o
2315  ***      0      0      0      0   not $found_arg and $pos == $len
2335  ***      0      0      0      0   $args{'misc'} and $args{'misc'}{'embed'}
      ***      0      0      0      0   $args{'misc'} and $args{'misc'}{'embed'} and my($e) = $arg =~ /($args{'misc'}{'embed'})/
2645  ***      0      0      0      0   $args{'all'} and $type eq 'num'
      ***      0      0      0      0   $args{'all'} and $type eq 'num' and $$self{'attrib_limit'}
2737  ***      0      0      0      0   defined $vals and @$vals
      ***      0      0      0      0   defined $vals and @$vals and $$args{'cnt'}
2754  ***      0      0      0      0   $v && $v > 0
2789  ***      0      0      0      0   not $bucket_95 and $sum_excl > $top_vals
2791  ***      0      0      0      0   not $median and $total_left <= $mid
2830  ***      0      0      0      0   $global_cnt && $$store{'cnt'}
      ***      0      0      0      0   $$store{'sum'} && $$store{'cnt'}
2854  ***      0      0      0      0   !$args{'total'} || $total < $args{'total'} and !$args{'count'} || $count < $args{'count'}
      ***      0      0      0      0   $args{'ol_attrib'} and !$args{'ol_freq'} || $$classes{$groupby}{$args{'ol_attrib'}}{'cnt'} >= $args{'ol_freq'}
2885  ***      0      0      0      0   $_ ne $$self{'groupby'} and not exists $$self{'attributes'}{$_}
2989  ***      0      0      0      0   $ddl_stmt =~ /CREATE/i and $query =~ /$ddl_stmt\b.+?\bSELECT\b/i
3055  ***      0      0      0      0   $tbl_refs and $from
3107  ***      0      0      0      0   $statements[-2] and $statements[-2] =~ /on duplicate key\s+$/i
3289  ***      0      0      0      0   $length > 0 and $query_length > $length
      ***      0      0      0      0   $length > 0 and $query_length > $length and $query_length < ($last_length || $query_length + 1)
3387  ***      0      0      0      0   $what[1] and $what[1] =~ /STATUS/
3647  ***      0      0      0      0   $PID_file and -f $PID_file
3708  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
3784  ***      0      0      0      0   $$self{'replace'} && $action ne 'DELETE'
3819  ***      0      0      0      0   $queue_level and $queue_level < $$self{'queue'}
3838  ***      0      0      0      0   not $error_count++ and $EVAL_ERROR =~ /$DUPE_KEY/
4009  ***      0      0      0      0   $left_done && $right_done
4010  ***      0      0      0      0   !$lr && !$left_done
4020  ***      0      0      0      0   !$rr && !$right_done
4031  ***      0      0      0      0   $lr and $rr
4036  ***      0      0      0      0   $lr and $rr
      ***      0      0      0      0   $lr and $rr and defined $cmp
      ***      0      0      0      0   $lr and $rr and defined $cmp and $cmp == 0
      ***      0      0      0      0   defined $cmp and $cmp < 0
4055  ***      0      0      0      0   $done and &$done($left, $right)
4087  ***      0      0      0      0   $coll and $coll ne 'latin1_swedish_ci' || $l =~ /[^\040-\177]/ || $r =~ /[^\040-\177]/
4188  ***      0      0      0      0   defined $_ and next
4191  ***      0      0      0      0   $$index{'is_unique'} and @{$$index{'cols'};} == 1
4444  ***      0      0      0      0   $args{'where'} and grep {$_;} @{$args{'where'};}
4668  ***      0      0      0      0   $type =~ /=/ and $end
4683  ***      0      0      0      0   $type =~ /=/ && $end
4841  ***      0      0      0      0   uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64'
4861  ***      0      0      0      0   $type eq 'bigint' and $length < 20
4875  ***      0      0      0      0   $alg and not $ALGOS{$alg}
4892  ***      0      0      0      0   $alg and grep {$_ eq $alg;} @choices
4897  ***      0      0      0      0   $args{'count'} and grep {$_ ne 'CHECKSUM';} @choices
4908  ***      0      0      0      0   $ALGOS{$algorithm} && $ALGOS{$algorithm}{'hash'}
4918  ***      0      0      0      0   @funcs and not $result
4927  ***      0      0      0      0   $EVAL_ERROR and $EVAL_ERROR =~ /failed: (.*?) at \S+ line/
4951  ***      0      0      0      0   $start < $crc_wid and $sliced ne $unsliced
4998  ***      0      0      0      0   defined $opt_slice and $opt_slice < @slices
5026  ***      0      0      0      0   $type =~ /float|double/ and $args{'float_precision'}
      ***      0      0      0      0   $type =~ /varchar/ and $args{'trim'}
5043  ***      0      0      0      0   uc $func ne 'FNV_64' and uc $func ne 'FNV1A_64'
5076  ***      0      0      0      0   $algorithm and $ALGOS{$algorithm}
5231  ***      0      0      0      0   $vp->version_ge($$src{'dbh'}, '4.0.9') && $vp->version_ge($$dst{'dbh'}, '4.0.9')
5234  ***      0      0      0      0   $plugin_args{'chunk_index'} and $args{'index_hint'}
5395  ***      0      0      0      0   $src_algo eq 'BIT_XOR' and not $crc_type =~ /int$/
5439  ***      0      0      0      0   $args{'lock'} and $args{'lock'} <= $args{'lock_level'}
5466  ***      0      0      0      0   $args{'lock'} and $args{'lock'} == $args{'lock_level'}
5555  ***      0      0      0      0   $privs =~ /select/ and $privs =~ /insert/
      ***      0      0      0      0   $privs =~ /select/ and $privs =~ /insert/ and $privs =~ /update/
      ***      0      0      0      0   $privs =~ /select/ and $privs =~ /insert/ and $privs =~ /update/ and $can_delete
5792  ***      0      0      0      0   $$self{'state'} == 0 && $$self{'chunk_num'} >= scalar @{$$self{'chunks'};}
5877  ***      0      0      0      0   $args{'chunk_index'} and $args{'chunk_index'} ne $nibble_index
5889  ***      0      0      0      0   $args{'src'} and $args{'src'}{'dbh'}
5905  ***      0      0      0      0   defined $n_rows and $n_rows <= 100
6028  ***      0      0      0      0   $$self{'cached_row'} and $$self{'cached_nibble'} == $$self{'nibble'}
6037  ***      0      0      0      0   $$self{'nibble'} == 0 and not $$self{'small_table'}
6156  ***      0      0      0      0   $$self{'state'} == 0 && $$self{'nibble'}
      ***      0      0      0      0   $$self{'state'} == 0 && $$self{'nibble'} && !$$self{'cached_row'}
6482  ***      0      0      0      0   $type =~ /(?:char|varchar)/ && $p[$i]
6675  ***      0      0      0      0   $$col{'fixed_wdith'} and $$col{'fixed_width'} < length $$col{'name'}
6698  ***      0      0      0      0   $$col{'fixed_width'} and $width > $$col{'fixed_width'}
6753  ***      0      0      0      0   $$self{'truncate_underline'} and 2 + $underline_len > $$self{'line_width'}
6859  ***      0      0      0      0   $stats and $$stats{$thing}
6874  ***      0      0      0      0   $stats and $$stats{$thing}
6891  ***      0      0      0      0   scalar @vals and grep {defined $_;} @vals
6896  ***      0      0      0      0   $_ && defined $$_[$i]
7174  ***      0      0      0      0   $$event{'wrapped_query'} and $$event{'tmp_tbl'}
7411  ***      0      0      0      0   $l_r[0] and $l_r[1]
7436  ***      0      0      0      0   $l_r[0] and $l_r[1]
7443  ***      0      0      0      0   $l_r[0] and $l_r[1]
8241  ***      0      0      0      0   not $w0 and not $w
8708  ***      0      0      0      0   -f $filter and -r $filter
8790  ***      0      0      0      0   $db and !$current_db || $db ne $current_db
8873  ***      0      0      0      0   $$host_event{'warning_count'} && $$host_event{'warning_count'} > 0
8906  ***      0      0      0      0   exists $host_events[$i]{'Query_time'} and $o->get('zero-query-times')
8943  ***      0      0      0      0   $oktorun and !$o->get('iterations') || $iters++ < $o->get('iterations')
8949  ***      0      0      0      0   $oktorun and $start == $end || $now < $end

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
44    ***     50      0      5   $ENV{'MKDEBUG'} || 0
115   ***     50      0     10   $prev ||= {}
116   ***     50      0     10   $defaults ||= {}
189   ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
202   ***     50      0     10   $self->prop('dbidriver') || ''
206   ***      0      0      0   $$info{'D'} || ''
212   ***     50      0     10   $$info{'D'} || ''
234   ***     50     10      0   $opts ||= {}
329   ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
345   ***      0      0      0   $level ||= 0
346   ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
396   ***     50      0      5   $ENV{'MKDEBUG'} || 0
666   ***      0      0      0   $$_[1] || ''
706   ***     50      0      5   $ENV{'MKDEBUG'} || 0
925   ***      0      0      0   $engine || undef
948   ***      0      0      0   $type || $special || 'BTREE'
1035  ***      0      0      0   $$tbl_struct{'engine'} || ''
1037  ***      0      0      0   $clustered_key ||= ''
1088  ***     50      0      5   $ENV{'MKDEBUG'} || 0
1155  ***     50      0      5   $ENV{'MKDEBUG'} || 0
1175  ***      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
1177  ***      0      0      0   $args{'prompt'} || '<options>'
      ***      0      0      0   $args{'dp'} || undef
1219  ***      0      0      0   $file ||= '/home/daniel/dev/maatkit/mk-upgrade/mk-upgrade'
1360  ***      0      0      0   $$opt{'group'} ||= 'default'
1642  ***      0      0      0   $s || 's'
1651  ***      0      0      0   $prefix || ''
1679  ***      0      0      0   $pre || ''
1686  ***      0      0      0   $val || ''
1689  ***      0      0      0   $val || ''
1747  ***      0      0      0   $$self{'description'} || ''
1815  ***      0      0      0   $s ||= 's'
1841  ***      0      0      0   $$opt{'type'} || ''
1991  ***     50      0      5   $ENV{'MKDEBUG'} || 0
2045  ***      0      0      0   $args{'p'} || 0
2047  ***      0      0      0   $of ||= 1
2052  ***      0      0      0   $secs ||= 0
2199  ***     50      0      5   $ENV{'MKDEBUG'} || 0
2393  ***      0      0      0   $args{'attributes'} || {}
2421  ***      0      0      0   $args{'unroll_limit'} || 1000
2468  ***      0      0      0   $$self{'result_classes'}{$val}{$attrib} ||= {}
2469  ***      0      0      0   $$self{'result_globals'}{$attrib} ||= {}
2742  ***      0      0      0   $$args{'max'} || 0
2757  ***      0      0      0   $$args{'max'} || 0
2758  ***      0      0      0   $$args{'min'} || 0
2803  ***      0      0      0   $$args{'max'} || 0
      ***      0      0      0   $$args{'min'} || 0
2953  ***     50      0      5   $ENV{'MKDEBUG'} || 0
3169  ***      0      0      0   $word =~ tr/(// || 0
3170  ***      0      0      0   $word =~ tr/)// || 0
3236  ***     50      0      5   $ENV{'MKDEBUG'} || 0
3572  ***     50      0      5   $ENV{'MKDEBUG'} || 0
3752  ***     50      0      5   $ENV{'MKDEBUG'} || 0
3990  ***     50      0      5   $ENV{'MKDEBUG'} || 0
4159  ***     50      0      5   $ENV{'MKDEBUG'} || 0
4450  ***      0      0      0   $args{'index_hint'} || ''
4552  ***     50      0      5   $ENV{'MKDEBUG'} || 0
4807  ***     50      0      5   $ENV{'MKDEBUG'} || 0
5013  ***      0      0      0   $args{'sep'} || '#'
5015  ***      0      0      0   $sep ||= '#'
5170  ***     50      0      5   $ENV{'MKDEBUG'} || 0
5212  ***      0      0      0   $args{'lock'} ||= 0
5213  ***      0      0      0   $args{'wait'} ||= 0
5214  ***      0      0      0   $args{'transaction'} ||= 0
5215  ***      0      0      0   $args{'timeout_ok'} ||= 0
5593  ***     50      0      5   $ENV{'MKDEBUG'} || 0
5728  ***      0      0      0   $$self{'index_hint'} || ''
5849  ***     50      0      5   $ENV{'MKDEBUG'} || 0
6039  ***      0      0      0   $explain_index || ''
6054  ***      0      0      0   $$self{'tbl_struct'}{'is_numeric'}{$$s{'scols'}[$i++]} || 0
6077  ***      0      0      0   $$self{'index_hint'} || ''
6085  ***      0      0      0   $$self{'tbl_struct'}{'is_numeric'}{$$s{'scols'}[$i++]} || 0
6112  ***      0      0      0   $$lr{'crc'} || 0
      ***      0      0      0   $$rr{'crc'} || 0
6208  ***     50      0      5   $ENV{'MKDEBUG'} || 0
6265  ***      0      0      0   $args{'where'} || '1=1'
6357  ***     50      0      5   $ENV{'MKDEBUG'} || 0
6406  ***     50      0      5   $ENV{'MKDEBUG'} || 0
6522  ***     50      0      5   $ENV{'MKDEBUG'} || 0
6592  ***     50      0      5   $ENV{'MKDEBUG'} || 0
6641  ***     50      0      5   $ENV{'MKDEBUG'} || 0
6719  ***      0      0      0   $$self{'line_prefix'} || ''
6826  ***      0      0      0   $rank || 0
6836  ***      0      0      0   $$class{'differences'}{'sum'} || 0
6881  ***      0      0      0   $$vals{'sum'} || 0
      ***      0      0      0   $$vals{'cnt'} || 1
6977  ***     50      0      5   $ENV{'MKDEBUG'} || 0
7128  ***      0      0      0   $$events[0]{'checksum'} || 0
      ***      0      0      0   $$events[$i]{'checksum'} || 0
7132  ***      0      0      0   $$events[0]{'row_count'} || 0
      ***      0      0      0   $$events[$i]{'row_count'} || 0
7143  ***      0      0      0   $$events[0]{'sampleno'} || 0
7222  ***      0      0      0   $$event0{'sampleno'} || 0
7298  ***      0      0      0   $n_rows || 0
7395  ***      0      0      0   $args{'max-different-rows'} || 1000
7554  ***      0      0      0   $$struct{'size'}{$_} || ''
7798  ***     50      0      5   $ENV{'MKDEBUG'} || 0
7882  ***      0      0      0   $$event0{'sampleno'} || 0
7883  ***      0      0      0   $$event0{'Query_time'} || 0
8083  ***     50      0      5   $ENV{'MKDEBUG'} || 0
8203  ***      0      0      0   $warning_count || 0
8223  ***      0      0      0   $$event0{'sampleno'} || 0
8230  ***      0      0      0   $$event0{'warning_count'} || 0
      ***      0      0      0   $$event{'warning_count'} || 0
8234  ***      0      0      0   $$event0{'warning_count'} || 0
      ***      0      0      0   $$event{'warning_count'} || 0
8470  ***     50      0      5   $ENV{'MKDEBUG'} || 0
8692  ***      0      0      0   $$event{'cmd'} || ''
8861  ***      0      0      0   $$event{'sampleno'} or 0
8863  ***      0      0      0   $$event{'sampleno'} or 0
8939  ***      0      0      0   $o->get('run-time') || 0
9028  ***      0      0      0   $meta_ea->results->{'globals'}{$orderby_attrib}{'sum'} || 0
9048  ***      0      0      0   $$sample{'arg'} || ''
9112  ***      0      0      0   $o->get('run-time') || 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
225   ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
226   ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
227   ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
228   ***      0      0      0      0   $$dsn{'u'} ||= $user
229   ***      0      0      0      0   $$dsn{'D'} ||= $db
507   ***      0      0      0      0   not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl}
546   ***      0      0      0      0   not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl}
576   ***      0      0      0      0   not $$self{'cache'} or not $$self{'triggers'}{$db}
610   ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'} or $like
629   ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db} or $like
643   ***      0      0      0      0   $tbl{'type'} || $tbl{'comment'}
      ***      0      0      0      0   $tbl{'engine'} ||= $tbl{'type'} || $tbl{'comment'}
655   ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db} or $like
799   ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'}
      ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
878   ***      0      0      0      0   not $$row[0] or $$row[0] ne $tbl
899   ***      0      0      0      0   $$row{'privileges'} || $$row{'Privileges'}
948   ***      0      0      0      0   $type || $special
1174  ***      0      0      0      0   $program_name ||= $PROGRAM_NAME
1175  ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
1637  ***      0      0      0      0   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
2055  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
2087  ***      0      0      0      0   $num =~ /\./ || $n
2236  ***      0      0      0      0   defined($stmt = shift @$pending) or defined($stmt = &$next_event())
2482  ***      0      0      0      0   $$samples{$val} ||= $event
2699  ***     33      0      0   4995   $bucket < 0 or $bucket > 999
2741  ***      0      0      0      0   $n_vals == 1 or $$args{'max'} == $$args{'min'}
2792  ***      0      0      0      0   $cutoff % 2 || $val > 1
2854  ***      0      0      0      0   !$args{'total'} || $total < $args{'total'}
      ***      0      0      0      0   !$args{'count'} || $count < $args{'count'}
      ***      0      0      0      0   !$args{'ol_freq'} || $$classes{$groupby}{$args{'ol_attrib'}}{'cnt'} >= $args{'ol_freq'}
3083  ***      0      0      0      0   $alias or $tbl
3198  ***      0      0      0      0   $type =~ /^$data_manip_stmts\b/ or $type =~ /^$data_def_stmts\b/
3289  ***      0      0      0      0   $last_length || $query_length + 1
3387  ***      0      0      0      0   $what[0] =~ /CREATE/ or $what[1] and $what[1] =~ /STATUS/
      ***      0      0      0      0   $what[0] =~ /CREATE/ or $what[1] and $what[1] =~ /STATUS/ or $what[0] =~ /MASTER/
3424  ***      0      0      0      0   $args{'QueryParser'} || $$self{'QueryParser'}
3485  ***      0      0      0      0   $query =~ s/
                 \A.*?
                 update\s+(.*?)
                 \s+set\b(.*?)
                 (?:\s*where\b(.*?))?
                 (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
                 \Z
              /__update_to_select($1, $2, $3, $4);/eisx or $query =~ s/
                    \A.*?
                    (?:insert|replace)\s+
                    .*?\binto\b(.*?)\(([^\)]+)\)\s*
                    values?\s*(\(.*?\))\s*
                    (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
                    \Z
                 /__insert_to_select($1, $2, $3);/eisx
3721  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
4014  ***      0      0      0      0   !$lr || $EVAL_ERROR
4024  ***      0      0      0      0   !$rr || $EVAL_ERROR
4035  ***      0      0      0      0   $lr or $rr
4036  ***      0      0      0      0   not $rr or defined $cmp and $cmp < 0
4069  ***      0      0      0      0   not defined $l or not defined $r
4087  ***      0      0      0      0   $coll ne 'latin1_swedish_ci' || $l =~ /[^\040-\177]/
      ***      0      0      0      0   $coll ne 'latin1_swedish_ci' || $l =~ /[^\040-\177]/ || $r =~ /[^\040-\177]/
4204  ***      0      0      0      0   $int_types{$$tbl_struct{'type_for'}{$col}} or $real_types{$$tbl_struct{'type_for'}{$col}}
4290  ***      0      0      0      0   not defined $end_point or $end_point < $start_point
4302  ***      0      0      0      0   $interval ||= $args{'chunk_size'}
4379  ***      0      0      0      0   $suffix or $args{'avg_row_length'}
4878  ***      0      0      0      0   $args{'where'} or $args{'chunk'}
      ***      0      0      0      0   $args{'where'} or $args{'chunk'} or $args{'replicate'}
      ***      0      0      0      0   $args{'where'} or $args{'chunk'} or $args{'replicate'} or not $vp->version_ge($dbh, '4.1.1')
5327  ***      0      0      0      0   not $cycle or not $plugin->pending_changes
5621  ***      0      0      0      0   $args{'chunk_col'} or $args{'chunk_index'}
5745  ***      0      0      0      0   $$lr{'cnt'} != $$rr{'cnt'} or $$lr{'crc'} ne $$rr{'crc'}
6112  ***      0      0      0      0   $$lr{'cnt'} != $$rr{'cnt'} or ($$lr{'crc'} || 0) ne ($$rr{'crc'} || 0)
7142  ***      0      0      0      0   $$events[0]{'fingerprint'} || $$events[0]{'arg'}
7221  ***      0      0      0      0   $$event0{'fingerprint'} || $$event0{'arg'}
7328  ***      0      0      0      0   $args{'tmp_db'} || $$event0{'db'}
7512  ***      0      0      0      0   $l_r[0] or $l_r[1]
7881  ***      0      0      0      0   $$event0{'fingerprint'} || $$event0{'arg'}
8222  ***      0      0      0      0   $$event0{'fingerprint'} || $$event0{'arg'}
8789  ***      0      0      0      0   $$event{'db'} || $$event{'Schema'}
      ***      0      0      0      0   $$event{'db'} || $$event{'Schema'} || $$hosts[0]{'dsn'}{'D'}
8790  ***      0      0      0      0   !$current_db || $db ne $current_db
8943  ***      0      0      0      0   !$o->get('iterations') || $iters++ < $o->get('iterations')
8949  ***      0      0      0      0   $start == $end || $now < $end


Covered Subroutines
-------------------

Subroutine                    Count Location                                           
----------------------------- ----- ---------------------------------------------------
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1081
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1082
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1086
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1088
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1148
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1149
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1151
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1152
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1153
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1155
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1985
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1986
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1987
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1988
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1989
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1991
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:20  
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:21  
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2194
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2195
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2196
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2197
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2199
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2373
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2374
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2375
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2377
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2378
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2379
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2380
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2381
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2382
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2949
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2950
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2951
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2953
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:32  
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3229
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3230
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3234
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3236
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:33  
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:34  
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:35  
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3566
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3567
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3569
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3570
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3572
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3742
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3743
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3747
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3752
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:391 
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:392 
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:394 
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:396 
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3983
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3984
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3988
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3990
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4146
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4147
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4151
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4152
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4153
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4154
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4159
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:44  
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4547
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4548
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4550
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4552
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4802
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4803
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4804
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4805
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4807
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5161
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5162
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5164
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5165
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5170
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5583
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5584
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5586
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5587
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5588
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5593
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5839
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5840
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5842
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5843
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5844
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5849
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6203
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6204
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6206
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6208
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6351
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6352
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6353
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6355
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6357
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6401
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6402
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6404
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6406
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6518
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6519
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6520
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6522
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6587
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6588
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6590
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6592
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6636
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6637
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6638
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6639
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6641
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6643
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6790
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6791
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6792
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6795
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6796
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6797
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6972
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6973
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6974
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6975
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6977
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6979
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:698 
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:699 
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:700 
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:701 
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:706 
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7399
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7400
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7791
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7792
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7793
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7794
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7798
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7800
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8079
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8080
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8081
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8083
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8085
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8461
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8463
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8470
BEGIN                             5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8472
bucket_value                   5000 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2697
get_cxn_params                   10 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:199 
get_dbh                          10 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:233 
new                               5 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:47  
parse                            10 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:109 
prop                             30 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:100 

Uncovered Subroutines
---------------------

Subroutine                    Count Location                                           
----------------------------- ----- ---------------------------------------------------
DESTROY                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3720
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1538
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2915
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7255
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7259
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7270
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7405
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7410
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7433
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7440
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7447
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7460
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8607
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8615
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8635
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8670
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8683
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8689
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8726
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8743
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8757
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8768
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8777
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8787
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8826
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8936
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8937
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8976
__delete_to_select                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3507
__get_boundaries                  0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6010
__get_explain_index               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6096
__insert_to_select                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3515
__make_boundary_sql               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6072
__queue                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3807
__shorten                         0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3309
__update_to_select                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3532
_checksum_results                 0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7164
_compare_checksums                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7109
_compare_rows                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7207
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1065
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1966
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2176
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2355
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2931
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3213
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3547
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3726
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:373 
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3967
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4130
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4529
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4784
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5143
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5565
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5821
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6185
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6333
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6383
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6500
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6569
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6618
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6770
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:680 
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6954
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7773
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8061
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8438
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:9201
_distill_tables                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3423
_distill_verbs                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3363
_get_participants                 0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1438
_make_PID_file                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3685
_make_unrolled_loops              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2496
_parse_specs                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1324
_pod_to_specs                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1218
_read_config_file                 0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1890
_remove_PID_file                  0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3707
_report_diff_big                  0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7973
_report_diff_checksums            0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7656
_report_diff_col_vals             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7687
_report_diff_in_bucket            0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8008
_report_diff_levels               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8351
_report_diff_row_counts           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7722
_report_diff_warning_counts       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8387
_report_diff_warnings             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8317
_set_option                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1484
_use_db                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:487 
_validate_type                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1633
add_indexes                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7564
add_line                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6686
add_new_attributes                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2881
after_execute                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7089
after_execute                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7862
after_execute                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8184
aggregate                         0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2441
any_unix_timestamp                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2138
as_arrayref                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6493
as_string                         0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:173 
attributes                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2545
before_execute                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7000
before_execute                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7822
before_execute                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8105
best_algorithm                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4871
bucket_for                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7916
bucket_idx                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2690
buckets_of                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2706
calculate_chunks                  0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4240
calculate_statistical_metrics     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2729
can_sync                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5609
can_sync                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5865
can_sync                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6224
change                            0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3781
check_PID_file                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3644
check_table                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:857 
choose_hash_func                  0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4912
clean_query                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3118
clone                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1943
compare                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7098
compare                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7871
compare                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8210
compare_sets                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4000
convert_select_list               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3498
convert_to_select                 0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3465
copy                              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:355 
crc32                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4825
daemonize                         0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3593
db_cmp                            0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4108
descr                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1746
diff_rows                         0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7358
disconnect                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:338 
distill                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3444
done                              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5787
done                              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6153
done                              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6318
done                              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6442
done_with_rows                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5772
done_with_rows                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6138
done_with_rows                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6313
done_with_rows                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6437
dump                              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:430 
errors                            0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1736
escape                            0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6375
event_report                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6816
events_processed                  0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2907
execute                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7038
execute                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7831
execute                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8153
fetch_back                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3767
fetchall_arrayref                 0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6555
fetchrow_hashref                  0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6545
fill_in_dsn                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:221 
find_best_index                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:811 
find_chunk_columns                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4177
find_possible_keys                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:829 
find_replication_differences      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5122
fingerprint                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3321
format_string_list                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6917
generate_asc_stmt                 0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4565
generate_cmp_where                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4628
generate_del_stmt                 0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4698
generate_ins_stmt                 0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4760
get                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1700
get_aliases                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3038
get_attributes                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2902
get_best_plugin                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5183
get_changes                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3935
get_columns                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:544 
get_crc_type                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4851
get_crc_wid                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4839
get_create_table                  0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:506 
get_cxn                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:9179
get_databases                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:609 
get_defaults                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1474
get_defaults_files                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1213
get_engine                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:922 
get_first_chunkable_column        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4345
get_fks                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:996 
get_groups                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1479
get_hostname                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:328 
get_keys                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:929 
get_opts                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1501
get_range_statistics              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4391
get_report                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6717
get_result_set_struct             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6462
get_specs                         0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1206
get_sql                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5717
get_sql                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5982
get_sql                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6263
get_sql                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6417
get_table_list                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:654 
get_table_status                  0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:628 
get_tables                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2977
get_tmp_table                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:564 
get_triggers                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:575 
got                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1708
has                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1716
has_derived_table                 0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3031
have_all_privs                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5541
inject_chunks                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4433
is_hash_algorithm                 0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4907
key_cmp                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4062
key_cols                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5808
key_cols                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6172
key_cols                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6323
key_cols                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6447
literal_like                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1131
lock_and_wait                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5457
lock_table                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5423
main                              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8478
make_DELETE                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3853
make_INSERT                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3888
make_PID_file                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3675
make_REPLACE                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3897
make_UPDATE                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3861
make_alt_attrib                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2912
make_checksum                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2169
make_checksum_queries             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5355
make_checksum_query               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5065
make_handler                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2555
make_label                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6908
make_row                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3903
make_row_checksum                 0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5009
make_table_ddl                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7548
make_where_clause                 0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3925
make_xor_slices                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4980
metrics                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2819
micro_t                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2014
name                              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5605
name                              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5861
name                              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6220
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1091
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1169
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2202
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2389
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2972
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3258
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3575
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3755
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3993
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4162
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:423 
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4555
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4816
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5173
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5596
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5852
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6211
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6360
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6409
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6525
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6595
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6649
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6811
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6985
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:710 
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7808
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8091
not_in_left                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5765
not_in_left                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6132
not_in_left                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6304
not_in_left                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6432
not_in_right                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5758
not_in_right                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6126
not_in_right                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6295
not_in_right                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6427
open_outfile                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7540
optimize_xor                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4939
opts                              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1450
parse                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6600
parse                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:721 
parse_event                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2222
parse_options                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:160 
parse_timestamp                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2111
pending_changes                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5796
pending_changes                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6160
pending_changes                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6328
pending_changes                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6457
percentage_increase               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7925
percentage_of                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2044
prepare                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6452
prepare_sync_cycle                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5709
prepare_sync_cycle                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5974
prepare_sync_cycle                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6258
prepare_to_sync                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5655
prepare_to_sync                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5920
prepare_to_sync                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6228
print_active_handles              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:344 
print_errors                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1770
print_usage                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1780
process_rows                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3816
prompt                            0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1741
prompt_noecho                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1855
query_type                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3195
quote                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1096
quote                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4428
quote_val                         0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1104
range_date                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4489
range_datetime                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4496
range_num                         0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4463
range_time                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4482
range_timestamp                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4504
read_para_after                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1924
remove_auto_increment             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1025
remove_secondary_indexes          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1031
report                            0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7625
report                            0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7942
report                            0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8286
report_errors                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:9140
reset                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6538
reset                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7766
reset                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8054
reset                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8431
reset_aggregated_data             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2427
results                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2536
same_row                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5744
same_row                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6111
same_row                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6274
same_row                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6422
samples                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7756
samples                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8044
samples                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:8421
save_error                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1731
secs_to_time                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2051
set                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1722
set_checksum_queries              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5700
set_checksum_queries              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5965
set_checksum_queries              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6254
set_columns                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6671
set_defaults                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1462
set_title                         0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6665
short_opts                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1456
shorten                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2078
shorten                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3275
sig_int                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:9189
size_to_rows                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4354
sort_cols                         0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3940
sort_indexes                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:792 
split                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3090
split_subquery                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3128
split_unquote                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1120
strip_comments                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3264
sync_table                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5201
take_action                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3773
timestampdiff                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4511
top_events                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2843
ts                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2095
type_for                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2550
unix_timestamp                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2123
unlock                            0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5431
usage                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:182 
usage_or_errors                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1757
uses_checksum                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5696
uses_checksum                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:5961
uses_checksum                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6250
version_ge                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6607
wrap_in_derived                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3539
write                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:6366
write_to_outfile                  0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:7519


