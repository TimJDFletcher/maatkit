---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...kit/mk-upgrade/mk-upgrade   43.6   26.7   24.8   58.3    n/a  100.0   38.4
Total                          43.6   26.7   24.8   58.3    n/a  100.0   38.4
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          mk-upgrade.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Sun Aug  9 15:13:15 2009
Finish:       Sun Aug  9 15:13:16 2009

/home/daniel/dev/maatkit/mk-upgrade/mk-upgrade

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This program is copyright 2009-@CURRENTYEAR@ Percona Inc.
4                                                     # Feedback and improvements are welcome.
5                                                     #
6                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
7                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
8                                                     # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
9                                                     #
10                                                    # This program is free software; you can redistribute it and/or modify it under
11                                                    # the terms of the GNU General Public License as published by the Free Software
12                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
13                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
14                                                    # licenses.
15                                                    #
16                                                    # You should have received a copy of the GNU General Public License along with
17                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
18                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
19                                                    
20             1                    1             9   use strict;
               1                                  2   
               1                                  6   
21             1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  8   
22                                                    
23                                                    our $VERSION = '@VERSION@';
24                                                    our $DISTRIB = '@DISTRIB@';
25                                                    our $SVN_REV = sprintf("%d", (q$Revision: 4424 $ =~ m/(\d+)/g, 0));
26                                                    
27                                                    # ###########################################################################
28                                                    # DSNParser package 4103
29                                                    # ###########################################################################
30             1                    1             6   use strict;
               1                                  3   
               1                                  8   
31             1                    1             5   use warnings FATAL => 'all';
               1                                  2   
               1                                  4   
32                                                    
33                                                    package DSNParser;
34                                                    
35             1                    1            11   use DBI;
               1                                  4   
               1                                 10   
36             1                    1             7   use Data::Dumper;
               1                                  2   
               1                                  9   
37                                                    $Data::Dumper::Indent    = 0;
38                                                    $Data::Dumper::Quotekeys = 0;
39             1                    1             7   use English qw(-no_match_vars);
               1                                  2   
               1                                  8   
40                                                    
41             1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                 10   
42                                                    
43                                                    sub new {
44             9                    9            97      my ( $class, @opts ) = @_;
45             9                                663      my $self = {
46                                                          opts => {
47                                                             A => {
48                                                                desc => 'Default character set',
49                                                                dsn  => 'charset',
50                                                                copy => 1,
51                                                             },
52                                                             D => {
53                                                                desc => 'Database to use',
54                                                                dsn  => 'database',
55                                                                copy => 1,
56                                                             },
57                                                             F => {
58                                                                desc => 'Only read default options from the given file',
59                                                                dsn  => 'mysql_read_default_file',
60                                                                copy => 1,
61                                                             },
62                                                             h => {
63                                                                desc => 'Connect to host',
64                                                                dsn  => 'host',
65                                                                copy => 1,
66                                                             },
67                                                             p => {
68                                                                desc => 'Password to use when connecting',
69                                                                dsn  => 'password',
70                                                                copy => 1,
71                                                             },
72                                                             P => {
73                                                                desc => 'Port number to use for connection',
74                                                                dsn  => 'port',
75                                                                copy => 1,
76                                                             },
77                                                             S => {
78                                                                desc => 'Socket file to use for connection',
79                                                                dsn  => 'mysql_socket',
80                                                                copy => 1,
81                                                             },
82                                                             u => {
83                                                                desc => 'User for login if not current user',
84                                                                dsn  => 'user',
85                                                                copy => 1,
86                                                             },
87                                                          },
88                                                       };
89             9                                 69      foreach my $opt ( @opts ) {
90    ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
91    ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
92                                                       }
93             9                                 86      return bless $self, $class;
94                                                    }
95                                                    
96                                                    sub prop {
97            54                   54           293      my ( $self, $prop, $value ) = @_;
98    ***     54     50                         263      if ( @_ > 2 ) {
99    ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
100   ***      0                                  0         $self->{$prop} = $value;
101                                                      }
102           54                                398      return $self->{$prop};
103                                                   }
104                                                   
105                                                   sub parse {
106           18                   18           144      my ( $self, $dsn, $prev, $defaults ) = @_;
107   ***     18     50                          85      if ( !$dsn ) {
108   ***      0                                  0         MKDEBUG && _d('No DSN to parse');
109   ***      0                                  0         return;
110                                                      }
111           18                                 46      MKDEBUG && _d('Parsing', $dsn);
112           18           100                   90      $prev     ||= {};
113   ***     18            50                   92      $defaults ||= {};
114           18                                 55      my %given_props;
115           18                                 56      my %final_props;
116           18                                 57      my %opts = %{$self->{opts}};
              18                                254   
117                                                   
118           18                                181      foreach my $dsn_part ( split(/,/, $dsn) ) {
119   ***     35     50                         346         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
120           35                                205            $given_props{$prop_key} = $prop_val;
121                                                         }
122                                                         else {
123   ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
124   ***      0                                  0            $given_props{h} = $dsn_part;
125                                                         }
126                                                      }
127                                                   
128           18                                 98      foreach my $key ( keys %opts ) {
129          144                                329         MKDEBUG && _d('Finding value for', $key);
130          144                                522         $final_props{$key} = $given_props{$key};
131          144    100    100                 1383         if (   !defined $final_props{$key}
      ***                   66                        
132                                                              && defined $prev->{$key} && $opts{$key}->{copy} )
133                                                         {
134            1                                  4            $final_props{$key} = $prev->{$key};
135            1                                  2            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
136                                                         }
137          144    100                         652         if ( !defined $final_props{$key} ) {
138          108                                368            $final_props{$key} = $defaults->{$key};
139          108                                308            MKDEBUG && _d('Copying value for', $key, 'from defaults');
140                                                         }
141                                                      }
142                                                   
143           18                                 96      foreach my $key ( keys %given_props ) {
144   ***     35     50                         174         die "Unrecognized DSN part '$key' in '$dsn'\n"
145                                                            unless exists $opts{$key};
146                                                      }
147   ***     18     50                         111      if ( (my $required = $self->prop('required')) ) {
148   ***      0                                  0         foreach my $key ( keys %$required ) {
149   ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
150                                                         }
151                                                      }
152                                                   
153           18                                128      return \%final_props;
154                                                   }
155                                                   
156                                                   sub parse_options {
157   ***      0                    0             0      my ( $self, $o ) = @_;
158   ***      0      0                           0      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
159   ***      0                                  0      my $dsn_string
160                                                         = join(',',
161   ***      0      0                           0             map  { "$_=".$o->get($_); }
162   ***      0                                  0             grep { $o->has($_) && $o->get($_) }
163   ***      0                                  0             keys %{$self->{opts}}
164                                                           );
165   ***      0                                  0      MKDEBUG && _d('DSN string made from options:', $dsn_string);
166   ***      0                                  0      return $self->parse($dsn_string);
167                                                   }
168                                                   
169                                                   sub as_string {
170           32                   32           165      my ( $self, $dsn ) = @_;
171   ***     32     50                         160      return $dsn unless ref $dsn;
172   ***     64     50                         495      return join(',',
173          256    100                        1783         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
174           32                                494         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
175                                                         sort keys %$dsn );
176                                                   }
177                                                   
178                                                   sub usage {
179   ***      0                    0             0      my ( $self ) = @_;
180   ***      0                                  0      my $usage
181                                                         = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
182                                                         . "  KEY  COPY  MEANING\n"
183                                                         . "  ===  ====  =============================================\n";
184   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
185   ***      0                                  0      foreach my $key ( sort keys %opts ) {
186   ***      0      0      0                    0         $usage .= "  $key    "
187                                                                .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
188                                                                .  ($opts{$key}->{desc} || '[No description]')
189                                                                . "\n";
190                                                      }
191   ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
192   ***      0                                  0      return $usage;
193                                                   }
194                                                   
195                                                   sub get_cxn_params {
196           18                   18            82      my ( $self, $info ) = @_;
197           18                                 50      my $dsn;
198           18                                 49      my %opts = %{$self->{opts}};
              18                                159   
199   ***     18            50                  100      my $driver = $self->prop('dbidriver') || '';
200   ***     18     50                          82      if ( $driver eq 'Pg' ) {
201   ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
202   ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
203   ***      0             0                    0                        grep { defined $info->{$_} }
204                                                                        qw(h P));
205                                                      }
206                                                      else {
207           36                                268         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
208           90                                361            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
209   ***     18            50                  241                        grep { defined $info->{$_} }
210                                                                        qw(F h P S A))
211                                                            . ';mysql_read_default_group=client';
212                                                      }
213           18                                 76      MKDEBUG && _d($dsn);
214           18                                232      return ($dsn, $info->{u}, $info->{p});
215                                                   }
216                                                   
217                                                   sub fill_in_dsn {
218   ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
219   ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
220   ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
221   ***      0                                  0      $user =~ s/@.*//;
222   ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
223   ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
224   ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
225   ***      0             0                    0      $dsn->{u} ||= $user;
226   ***      0             0                    0      $dsn->{D} ||= $db;
227                                                   }
228                                                   
229                                                   sub get_dbh {
230           18                   18           115      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
231   ***     18            50                   82      $opts ||= {};
232   ***     18     50                         190      my $defaults = {
233                                                         AutoCommit         => 0,
234                                                         RaiseError         => 1,
235                                                         PrintError         => 0,
236                                                         ShowErrorStatement => 1,
237                                                         mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
238                                                      };
239           18                                103      @{$defaults}{ keys %$opts } = values %$opts;
              18                                 75   
240                                                   
241           18                                 50      my $dbh;
242           18                                 63      my $tries = 2;
243   ***     18            66                  227      while ( !$dbh && $tries-- ) {
244                                                         MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
245           18                                 51            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
246                                                   
247           18                                 64         eval {
248           18                                220            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
249                                                   
250   ***     18     50                         177            if ( $cxn_string =~ m/mysql/i ) {
251           18                                 46               my $sql;
252                                                   
253           18                                 70               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
254                                                                    . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
255           18                                 56               MKDEBUG && _d($dbh, ':', $sql);
256           18                               3078               $dbh->do($sql);
257                                                   
258   ***     18     50                         170               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
259   ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
260   ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
261   ***      0                                  0                  $dbh->do($sql);
262   ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
263   ***      0      0                           0                  if ( $charset eq 'utf8' ) {
264   ***      0      0                           0                     binmode(STDOUT, ':utf8')
265                                                                        or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
266                                                                  }
267                                                                  else {
268   ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
269                                                                  }
270                                                               }
271                                                   
272   ***     18     50                         117               if ( $self->prop('setvars') ) {
273   ***      0                                  0                  $sql = "SET " . $self->prop('setvars');
274   ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
275   ***      0                                  0                  $dbh->do($sql);
276                                                               }
277                                                            }
278                                                         };
279   ***     18     50     33                  174         if ( !$dbh && $EVAL_ERROR ) {
280   ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
281   ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
282   ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
283   ***      0                                  0               delete $defaults->{mysql_enable_utf8};
284                                                            }
285   ***      0      0                           0            if ( !$tries ) {
286   ***      0                                  0               die $EVAL_ERROR;
287                                                            }
288                                                         }
289                                                      }
290                                                   
291           18                                 47      MKDEBUG && _d('DBH info: ',
292                                                         $dbh,
293                                                         Dumper($dbh->selectrow_hashref(
294                                                            'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
295                                                         'Connection info:',      $dbh->{mysql_hostinfo},
296                                                         'Character set info:',   Dumper($dbh->selectall_arrayref(
297                                                                        'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
298                                                         '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
299                                                         '$DBI::VERSION:',        $DBI::VERSION,
300                                                      );
301                                                   
302           18                                 94      return $dbh;
303                                                   }
304                                                   
305                                                   sub get_hostname {
306   ***      0                    0             0      my ( $self, $dbh ) = @_;
307   ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
308   ***      0                                  0         return $host;
309                                                      }
310   ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
311                                                         'SELECT /*!50038 @@hostname, */ 1');
312   ***      0                                  0      return $hostname;
313                                                   }
314                                                   
315                                                   sub disconnect {
316   ***      0                    0             0      my ( $self, $dbh ) = @_;
317   ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
318   ***      0                                  0      $dbh->disconnect;
319                                                   }
320                                                   
321                                                   sub print_active_handles {
322   ***      0                    0             0      my ( $self, $thing, $level ) = @_;
323   ***      0             0                    0      $level ||= 0;
324   ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
325                                                         $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
326                                                         or die "Cannot print: $OS_ERROR";
327   ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
328   ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
329                                                      }
330                                                   }
331                                                   
332                                                   sub copy {
333   ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
334   ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
335   ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
336   ***      0                                  0      my %new_dsn = map {
337   ***      0                                  0         my $key = $_;
338   ***      0                                  0         my $val;
339   ***      0      0                           0         if ( $args{overwrite} ) {
340   ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
341                                                         }
342                                                         else {
343   ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
344                                                         }
345   ***      0                                  0         $key => $val;
346   ***      0                                  0      } keys %{$self->{opts}};
347   ***      0                                  0      return \%new_dsn;
348                                                   }
349                                                   
350                                                   sub _d {
351   ***      0                    0             0      my ($package, undef, $line) = caller 0;
352   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
353   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
354                                                           @_;
355   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
356                                                   }
357                                                   
358                                                   1;
359                                                   
360                                                   # ###########################################################################
361                                                   # End DSNParser package
362                                                   # ###########################################################################
363                                                   
364                                                   # ###########################################################################
365                                                   # MySQLDump package 4160
366                                                   # ###########################################################################
367                                                   package MySQLDump;
368                                                   
369            1                    1             7   use strict;
               1                                  2   
               1                                  7   
370            1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  9   
371                                                   
372            1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  4   
373                                                   
374            1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  7   
375                                                   
376                                                   ( our $before = <<'EOF') =~ s/^   //gm;
377                                                      /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
378                                                      /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
379                                                      /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
380                                                      /*!40101 SET NAMES utf8 */;
381                                                      /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
382                                                      /*!40103 SET TIME_ZONE='+00:00' */;
383                                                      /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
384                                                      /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
385                                                      /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
386                                                      /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
387                                                   EOF
388                                                   
389                                                   ( our $after = <<'EOF') =~ s/^   //gm;
390                                                      /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
391                                                      /*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
392                                                      /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
393                                                      /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
394                                                      /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
395                                                      /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
396                                                      /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
397                                                      /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
398                                                   EOF
399                                                   
400                                                   sub new {
401            7                    7            48      my ( $class, %args ) = @_;
402   ***      7     50                          55      $args{cache} = 1 unless defined $args{cache};
403            7                                 47      my $self = bless \%args, $class;
404            7                                 32      return $self;
405                                                   }
406                                                   
407                                                   sub dump {
408   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl, $what ) = @_;
409                                                   
410   ***      0      0                           0      if ( $what eq 'table' ) {
      ***             0                               
      ***             0                               
411   ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
412   ***      0      0                           0         return unless $ddl;
413   ***      0      0                           0         if ( $ddl->[0] eq 'table' ) {
414   ***      0                                  0            return $before
415                                                               . 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
416                                                               . $ddl->[1] . ";\n";
417                                                         }
418                                                         else {
419   ***      0                                  0            return 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
420                                                               . '/*!50001 DROP VIEW IF EXISTS '
421                                                               . $quoter->quote($tbl) . "*/;\n/*!50001 "
422                                                               . $self->get_tmp_table($dbh, $quoter, $db, $tbl) . "*/;\n";
423                                                         }
424                                                      }
425                                                      elsif ( $what eq 'triggers' ) {
426   ***      0                                  0         my $trgs = $self->get_triggers($dbh, $quoter, $db, $tbl);
427   ***      0      0      0                    0         if ( $trgs && @$trgs ) {
428   ***      0                                  0            my $result = $before . "\nDELIMITER ;;\n";
429   ***      0                                  0            foreach my $trg ( @$trgs ) {
430   ***      0      0                           0               if ( $trg->{sql_mode} ) {
431   ***      0                                  0                  $result .= qq{/*!50003 SET SESSION SQL_MODE='$trg->{sql_mode}' */;;\n};
432                                                               }
433   ***      0                                  0               $result .= "/*!50003 CREATE */ ";
434   ***      0      0                           0               if ( $trg->{definer} ) {
435   ***      0                                  0                  my ( $user, $host )
436   ***      0                                  0                     = map { s/'/''/g; "'$_'"; }
      ***      0                                  0   
437                                                                       split('@', $trg->{definer}, 2);
438   ***      0                                  0                  $result .= "/*!50017 DEFINER=$user\@$host */ ";
439                                                               }
440   ***      0                                  0               $result .= sprintf("/*!50003 TRIGGER %s %s %s ON %s\nFOR EACH ROW %s */;;\n\n",
441                                                                  $quoter->quote($trg->{trigger}),
442   ***      0                                  0                  @{$trg}{qw(timing event)},
443                                                                  $quoter->quote($trg->{table}),
444                                                                  $trg->{statement});
445                                                            }
446   ***      0                                  0            $result .= "DELIMITER ;\n\n/*!50003 SET SESSION SQL_MODE=\@OLD_SQL_MODE */;\n\n";
447   ***      0                                  0            return $result;
448                                                         }
449                                                         else {
450   ***      0                                  0            return undef;
451                                                         }
452                                                      }
453                                                      elsif ( $what eq 'view' ) {
454   ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
455   ***      0                                  0         return '/*!50001 DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
456                                                            . '/*!50001 DROP VIEW IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
457                                                            . '/*!50001 ' . $ddl->[1] . "*/;\n";
458                                                      }
459                                                      else {
460   ***      0                                  0         die "You didn't say what to dump.";
461                                                      }
462                                                   }
463                                                   
464                                                   sub _use_db {
465           14                   14            84      my ( $self, $dbh, $quoter, $new ) = @_;
466   ***     14     50                          69      if ( !$new ) {
467   ***      0                                  0         MKDEBUG && _d('No new DB to use');
468   ***      0                                  0         return;
469                                                      }
470           14                                 43      my $sql = 'SELECT DATABASE()';
471           14                                 33      MKDEBUG && _d($sql);
472           14                                 30      my $curr = $dbh->selectrow_array($sql);
473   ***     14     50     33                 1789      if ( $curr && $new && $curr eq $new ) {
      ***                   33                        
474           14                                 37         MKDEBUG && _d('Current and new DB are the same');
475           14                                 62         return $curr;
476                                                      }
477   ***      0                                  0      $sql = 'USE ' . $quoter->quote($new);
478   ***      0                                  0      MKDEBUG && _d($sql);
479   ***      0                                  0      $dbh->do($sql);
480   ***      0                                  0      return $curr;
481                                                   }
482                                                   
483                                                   sub get_create_table {
484           14                   14            98      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
485   ***     14    100     66                  242      if ( !$self->{cache} || !$self->{tables}->{$db}->{$tbl} ) {
486            7                                 50         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
487                                                            . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
488                                                            . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
489                                                            . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
490            7                                 17         MKDEBUG && _d($sql);
491            7                                 18         eval { $dbh->do($sql); };
               7                               1010   
492            7                                 39         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
493            7                                 62         my $curr_db = $self->_use_db($dbh, $quoter, $db);
494            7                                 42         $sql = "SHOW CREATE TABLE " . $quoter->quote($db, $tbl);
495            7                                 19         MKDEBUG && _d($sql);
496            7                                 18         my $href;
497            7                                 24         eval { $href = $dbh->selectrow_hashref($sql); };
               7                                 21   
498   ***      7     50                          54         if ( $EVAL_ERROR ) {
499   ***      0                                  0            warn "Failed to $sql.  The table may be damaged.\nError: $EVAL_ERROR";
500   ***      0                                  0            return;
501                                                         }
502            7                                 37         $self->_use_db($dbh, $quoter, $curr_db);
503            7                                 25         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
504                                                            . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
505            7                                 15         MKDEBUG && _d($sql);
506            7                                669         $dbh->do($sql);
507            7                                 56         my ($key) = grep { m/create table/i } keys %$href;
              14                                128   
508   ***      7     50                          38         if ( $key ) {
509            7                                 17            MKDEBUG && _d('This table is a base table');
510            7                                105            $self->{tables}->{$db}->{$tbl} = [ 'table', $href->{$key} ];
511                                                         }
512                                                         else {
513   ***      0                                  0            MKDEBUG && _d('This table is a view');
514   ***      0                                  0            ($key) = grep { m/create view/i } keys %$href;
      ***      0                                  0   
515   ***      0                                  0            $self->{tables}->{$db}->{$tbl} = [ 'view', $href->{$key} ];
516                                                         }
517                                                      }
518           14                                 99      return $self->{tables}->{$db}->{$tbl};
519                                                   }
520                                                   
521                                                   sub get_columns {
522   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
523   ***      0                                  0      MKDEBUG && _d('Get columns for', $db, $tbl);
524   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{columns}->{$db}->{$tbl} ) {
525   ***      0                                  0         my $curr_db = $self->_use_db($dbh, $quoter, $db);
526   ***      0                                  0         my $sql = "SHOW COLUMNS FROM " . $quoter->quote($db, $tbl);
527   ***      0                                  0         MKDEBUG && _d($sql);
528   ***      0                                  0         my $cols = $dbh->selectall_arrayref($sql, { Slice => {} });
529   ***      0                                  0         $self->_use_db($dbh, $quoter, $curr_db);
530   ***      0                                  0         $self->{columns}->{$db}->{$tbl} = [
531                                                            map {
532   ***      0                                  0               my %row;
533   ***      0                                  0               @row{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
534   ***      0                                  0               \%row;
535                                                            } @$cols
536                                                         ];
537                                                      }
538   ***      0                                  0      return $self->{columns}->{$db}->{$tbl};
539                                                   }
540                                                   
541                                                   sub get_tmp_table {
542   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
543   ***      0                                  0      my $result = 'CREATE TABLE ' . $quoter->quote($tbl) . " (\n";
544   ***      0                                  0      $result .= join(",\n",
545   ***      0                                  0         map { '  ' . $quoter->quote($_->{field}) . ' ' . $_->{type} }
546   ***      0                                  0         @{$self->get_columns($dbh, $quoter, $db, $tbl)});
547   ***      0                                  0      $result .= "\n)";
548   ***      0                                  0      MKDEBUG && _d($result);
549   ***      0                                  0      return $result;
550                                                   }
551                                                   
552                                                   sub get_triggers {
553   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
554   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{triggers}->{$db} ) {
555   ***      0                                  0         $self->{triggers}->{$db} = {};
556   ***      0                                  0         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
557                                                            . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
558                                                            . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
559                                                            . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
560   ***      0                                  0         MKDEBUG && _d($sql);
561   ***      0                                  0         eval { $dbh->do($sql); };
      ***      0                                  0   
562   ***      0                                  0         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
563   ***      0                                  0         $sql = "SHOW TRIGGERS FROM " . $quoter->quote($db);
564   ***      0                                  0         MKDEBUG && _d($sql);
565   ***      0                                  0         my $sth = $dbh->prepare($sql);
566   ***      0                                  0         $sth->execute();
567   ***      0      0                           0         if ( $sth->rows ) {
568   ***      0                                  0            my $trgs = $sth->fetchall_arrayref({});
569   ***      0                                  0            foreach my $trg (@$trgs) {
570   ***      0                                  0               my %trg;
571   ***      0                                  0               @trg{ map { lc $_ } keys %$trg } = values %$trg;
      ***      0                                  0   
572   ***      0                                  0               push @{ $self->{triggers}->{$db}->{ $trg{table} } }, \%trg;
      ***      0                                  0   
573                                                            }
574                                                         }
575   ***      0                                  0         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
576                                                            . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
577   ***      0                                  0         MKDEBUG && _d($sql);
578   ***      0                                  0         $dbh->do($sql);
579                                                      }
580   ***      0      0                           0      if ( $tbl ) {
581   ***      0                                  0         return $self->{triggers}->{$db}->{$tbl};
582                                                      }
583   ***      0                                  0      return values %{$self->{triggers}->{$db}};
      ***      0                                  0   
584                                                   }
585                                                   
586                                                   sub get_databases {
587   ***      0                    0             0      my ( $self, $dbh, $quoter, $like ) = @_;
588   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{databases} || $like ) {
      ***                    0                        
589   ***      0                                  0         my $sql = 'SHOW DATABASES';
590   ***      0                                  0         my @params;
591   ***      0      0                           0         if ( $like ) {
592   ***      0                                  0            $sql .= ' LIKE ?';
593   ***      0                                  0            push @params, $like;
594                                                         }
595   ***      0                                  0         my $sth = $dbh->prepare($sql);
596   ***      0                                  0         MKDEBUG && _d($sql, @params);
597   ***      0                                  0         $sth->execute( @params );
598   ***      0                                  0         my @dbs = map { $_->[0] } @{$sth->fetchall_arrayref()};
      ***      0                                  0   
      ***      0                                  0   
599   ***      0      0                           0         $self->{databases} = \@dbs unless $like;
600   ***      0                                  0         return @dbs;
601                                                      }
602   ***      0                                  0      return @{$self->{databases}};
      ***      0                                  0   
603                                                   }
604                                                   
605                                                   sub get_table_status {
606   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
607   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_status}->{$db} || $like ) {
      ***                    0                        
608   ***      0                                  0         my $sql = "SHOW TABLE STATUS FROM " . $quoter->quote($db);
609   ***      0                                  0         my @params;
610   ***      0      0                           0         if ( $like ) {
611   ***      0                                  0            $sql .= ' LIKE ?';
612   ***      0                                  0            push @params, $like;
613                                                         }
614   ***      0                                  0         MKDEBUG && _d($sql, @params);
615   ***      0                                  0         my $sth = $dbh->prepare($sql);
616   ***      0                                  0         $sth->execute(@params);
617   ***      0                                  0         my @tables = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
618   ***      0                                  0         @tables = map {
619   ***      0                                  0            my %tbl; # Make a copy with lowercased keys
620   ***      0                                  0            @tbl{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
621   ***      0             0                    0            $tbl{engine} ||= $tbl{type} || $tbl{comment};
      ***                    0                        
622   ***      0                                  0            delete $tbl{type};
623   ***      0                                  0            \%tbl;
624                                                         } @tables;
625   ***      0      0                           0         $self->{table_status}->{$db} = \@tables unless $like;
626   ***      0                                  0         return @tables;
627                                                      }
628   ***      0                                  0      return @{$self->{table_status}->{$db}};
      ***      0                                  0   
629                                                   }
630                                                   
631                                                   sub get_table_list {
632   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
633   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_list}->{$db} || $like ) {
      ***                    0                        
634   ***      0                                  0         my $sql = "SHOW /*!50002 FULL*/ TABLES FROM " . $quoter->quote($db);
635   ***      0                                  0         my @params;
636   ***      0      0                           0         if ( $like ) {
637   ***      0                                  0            $sql .= ' LIKE ?';
638   ***      0                                  0            push @params, $like;
639                                                         }
640   ***      0                                  0         MKDEBUG && _d($sql, @params);
641   ***      0                                  0         my $sth = $dbh->prepare($sql);
642   ***      0                                  0         $sth->execute(@params);
643   ***      0                                  0         my @tables = @{$sth->fetchall_arrayref()};
      ***      0                                  0   
644   ***      0      0      0                    0         @tables = map {
645   ***      0                                  0            my %tbl = (
646                                                               name   => $_->[0],
647                                                               engine => ($_->[1] || '') eq 'VIEW' ? 'VIEW' : '',
648                                                            );
649   ***      0                                  0            \%tbl;
650                                                         } @tables;
651   ***      0      0                           0         $self->{table_list}->{$db} = \@tables unless $like;
652   ***      0                                  0         return @tables;
653                                                      }
654   ***      0                                  0      return @{$self->{table_list}->{$db}};
      ***      0                                  0   
655                                                   }
656                                                   
657                                                   sub _d {
658   ***      0                    0             0      my ($package, undef, $line) = caller 0;
659   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
660   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
661                                                           @_;
662   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
663                                                   }
664                                                   
665                                                   1;
666                                                   
667                                                   # ###########################################################################
668                                                   # End MySQLDump package
669                                                   # ###########################################################################
670                                                   
671                                                   # ###########################################################################
672                                                   # TableParser package 4397
673                                                   # ###########################################################################
674                                                   package TableParser;
675                                                   
676            1                    1            11   use strict;
               1                                  3   
               1                                  9   
677            1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  8   
678            1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  7   
679                                                   
680            1                    1             8   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  9   
681                                                   
682                                                   sub new {
683            7                    7            38      my ( $class ) = @_;
684            7                                 59      return bless {}, $class;
685                                                   }
686                                                   
687                                                   
688                                                   sub parse {
689           14                   14            78      my ( $self, $ddl, $opts ) = @_;
690   ***     14     50                         143      return unless $ddl;
691   ***     14     50                          81      if ( ref $ddl eq 'ARRAY' ) {
692   ***     14     50                          76         if ( lc $ddl->[0] eq 'table' ) {
693           14                                 65            $ddl = $ddl->[1];
694                                                         }
695                                                         else {
696                                                            return {
697   ***      0                                  0               engine => 'VIEW',
698                                                            };
699                                                         }
700                                                      }
701                                                   
702   ***     14     50                         175      if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
703   ***      0                                  0         die "Cannot parse table definition; is ANSI quoting "
704                                                            . "enabled or SQL_QUOTE_SHOW_CREATE disabled?";
705                                                      }
706                                                   
707           14                                301      $ddl =~ s/(`[^`]+`)/\L$1/g;
708                                                   
709           14                                 98      my $engine = $self->get_engine($ddl);
710                                                   
711           14                                264      my @defs   = $ddl =~ m/^(\s+`.*?),?$/gm;
712           14                                 63      my @cols   = map { $_ =~ m/`([^`]+)`/ } @defs;
              42                                254   
713           14                                 48      MKDEBUG && _d('Columns:', join(', ', @cols));
714                                                   
715           14                                 40      my %def_for;
716           14                                110      @def_for{@cols} = @defs;
717                                                   
718           14                                 40      my (@nums, @null);
719           14                                 49      my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
720           14                                 68      foreach my $col ( @cols ) {
721           42                                139         my $def = $def_for{$col};
722           42                                270         my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
723   ***     42     50                         172         die "Can't determine column type for $def" unless $type;
724           42                                156         $type_for{$col} = $type;
725   ***     42     50                         238         if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
726           42                                141            push @nums, $col;
727           42                                164            $is_numeric{$col} = 1;
728                                                         }
729   ***     42     50                         205         if ( $def !~ m/NOT NULL/ ) {
730   ***      0                                  0            push @null, $col;
731   ***      0                                  0            $is_nullable{$col} = 1;
732                                                         }
733   ***     42     50                         250         $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
734                                                      }
735                                                   
736           14                                127      my ($keys, $clustered_key) = $self->get_keys($ddl, $opts, \%is_nullable);
737                                                   
738                                                      return {
739           42                                215         cols           => \@cols,
740           42                                438         col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
741           14                                144         is_col         => { map { $_ => 1 } @cols },
742                                                         null_cols      => \@null,
743                                                         is_nullable    => \%is_nullable,
744                                                         is_autoinc     => \%is_autoinc,
745                                                         clustered_key  => $clustered_key,
746                                                         keys           => $keys,
747                                                         defs           => \%def_for,
748                                                         numeric_cols   => \@nums,
749                                                         is_numeric     => \%is_numeric,
750                                                         engine         => $engine,
751                                                         type_for       => \%type_for,
752                                                      };
753                                                   }
754                                                   
755                                                   sub sort_indexes {
756   ***      0                    0             0      my ( $self, $tbl ) = @_;
757                                                   
758                                                      my @indexes
759   ***      0                                  0         = sort {
760   ***      0                                  0            (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
761                                                            || ( !$tbl->{keys}->{$a}->{is_unique} <=> !$tbl->{keys}->{$b}->{is_unique} )
762                                                            || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
763   ***      0      0      0                    0            || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      ***      0             0                    0   
764                                                         }
765                                                         grep {
766   ***      0                                  0            $tbl->{keys}->{$_}->{type} eq 'BTREE'
767                                                         }
768   ***      0                                  0         sort keys %{$tbl->{keys}};
769                                                   
770   ***      0                                  0      MKDEBUG && _d('Indexes sorted best-first:', join(', ', @indexes));
771   ***      0                                  0      return @indexes;
772                                                   }
773                                                   
774                                                   sub find_best_index {
775   ***      0                    0             0      my ( $self, $tbl, $index ) = @_;
776   ***      0                                  0      my $best;
777   ***      0      0                           0      if ( $index ) {
778   ***      0                                  0         ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
      ***      0                                  0   
      ***      0                                  0   
779                                                      }
780   ***      0      0                           0      if ( !$best ) {
781   ***      0      0                           0         if ( $index ) {
782   ***      0                                  0            die "Index '$index' does not exist in table";
783                                                         }
784                                                         else {
785   ***      0                                  0            ($best) = $self->sort_indexes($tbl);
786                                                         }
787                                                      }
788   ***      0                                  0      MKDEBUG && _d('Best index found is', $best);
789   ***      0                                  0      return $best;
790                                                   }
791                                                   
792                                                   sub find_possible_keys {
793   ***      0                    0             0      my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
794   ***      0      0                           0      return () unless $where;
795   ***      0                                  0      my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
796                                                         . ' WHERE ' . $where;
797   ***      0                                  0      MKDEBUG && _d($sql);
798   ***      0                                  0      my $expl = $dbh->selectrow_hashref($sql);
799   ***      0                                  0      $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
      ***      0                                  0   
800   ***      0      0                           0      if ( $expl->{possible_keys} ) {
801   ***      0                                  0         MKDEBUG && _d('possible_keys =', $expl->{possible_keys});
802   ***      0                                  0         my @candidates = split(',', $expl->{possible_keys});
803   ***      0                                  0         my %possible   = map { $_ => 1 } @candidates;
      ***      0                                  0   
804   ***      0      0                           0         if ( $expl->{key} ) {
805   ***      0                                  0            MKDEBUG && _d('MySQL chose', $expl->{key});
806   ***      0                                  0            unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
      ***      0                                  0   
807   ***      0                                  0            MKDEBUG && _d('Before deduping:', join(', ', @candidates));
808   ***      0                                  0            my %seen;
809   ***      0                                  0            @candidates = grep { !$seen{$_}++ } @candidates;
      ***      0                                  0   
810                                                         }
811   ***      0                                  0         MKDEBUG && _d('Final list:', join(', ', @candidates));
812   ***      0                                  0         return @candidates;
813                                                      }
814                                                      else {
815   ***      0                                  0         MKDEBUG && _d('No keys in possible_keys');
816   ***      0                                  0         return ();
817                                                      }
818                                                   }
819                                                   
820                                                   sub table_exists {
821   ***      0                    0             0      my ( $self, $dbh, $db, $tbl, $q, $can_insert ) = @_;
822   ***      0                                  0      my $result = 0;
823   ***      0                                  0      my $db_tbl = $q->quote($db, $tbl);
824   ***      0                                  0      my $sql    = "SHOW FULL COLUMNS FROM $db_tbl";
825   ***      0                                  0      MKDEBUG && _d($sql);
826   ***      0                                  0      eval {
827   ***      0                                  0         my $sth = $dbh->prepare($sql);
828   ***      0                                  0         $sth->execute();
829   ***      0                                  0         my @columns = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
830   ***      0      0                           0         if ( $can_insert ) {
831   ***      0             0                    0            $result = grep { ($_->{Privileges} || '') =~ m/insert/ } @columns;
      ***      0                                  0   
832                                                         }
833                                                         else {
834   ***      0                                  0            $result = 1;
835                                                         }
836                                                      };
837   ***      0                                  0      if ( MKDEBUG && $EVAL_ERROR ) {
838                                                         _d($EVAL_ERROR);
839                                                      }
840   ***      0                                  0      return $result;
841                                                   }
842                                                   
843                                                   sub get_engine {
844           28                   28           148      my ( $self, $ddl, $opts ) = @_;
845           28                                321      my ( $engine ) = $ddl =~ m/\).*?(?:ENGINE|TYPE)=(\w+)/;
846           28                                 73      MKDEBUG && _d('Storage engine:', $engine);
847   ***     28            50                  159      return $engine || undef;
848                                                   }
849                                                   
850                                                   sub get_keys {
851           14                   14            85      my ( $self, $ddl, $opts, $is_nullable ) = @_;
852           14                                 68      my $engine        = $self->get_engine($ddl);
853           14                                 47      my $keys          = {};
854           14                                 42      my $clustered_key = undef;
855                                                   
856                                                      KEY:
857           14                                104      foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {
858                                                   
859   ***      0      0                           0         next KEY if $key =~ m/FOREIGN/;
860                                                   
861   ***      0                                  0         MKDEBUG && _d('Parsed key:', $key);
862                                                   
863   ***      0      0                           0         if ( $engine !~ m/MEMORY|HEAP/ ) {
864   ***      0                                  0            $key =~ s/USING HASH/USING BTREE/;
865                                                         }
866                                                   
867   ***      0                                  0         my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
868   ***      0                                  0         my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
869   ***      0             0                    0         $type = $type || $special || 'BTREE';
      ***                    0                        
870   ***      0      0      0                    0         if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
      ***                    0                        
871                                                            && $engine =~ m/HEAP|MEMORY/i )
872                                                         {
873   ***      0                                  0            $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
874                                                         }
875                                                   
876   ***      0                                  0         my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
877   ***      0      0                           0         my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
878   ***      0                                  0         my @cols;
879   ***      0                                  0         my @col_prefixes;
880   ***      0                                  0         foreach my $col_def ( split(',', $cols) ) {
881   ***      0                                  0            my ($name, $prefix) = $col_def =~ m/`([^`]+)`(?:\((\d+)\))?/;
882   ***      0                                  0            push @cols, $name;
883   ***      0                                  0            push @col_prefixes, $prefix;
884                                                         }
885   ***      0                                  0         $name =~ s/`//g;
886                                                   
887   ***      0                                  0         MKDEBUG && _d('Key', $name, 'cols:', join(', ', @cols));
888                                                   
889   ***      0                                  0         $keys->{$name} = {
890                                                            name         => $name,
891                                                            type         => $type,
892                                                            colnames     => $cols,
893                                                            cols         => \@cols,
894                                                            col_prefixes => \@col_prefixes,
895                                                            is_unique    => $unique,
896   ***      0                                  0            is_nullable  => scalar(grep { $is_nullable->{$_} } @cols),
897   ***      0                                  0            is_col       => { map { $_ => 1 } @cols },
898                                                         };
899                                                   
900   ***      0      0      0                    0         if ( $engine =~ m/InnoDB/i && !$clustered_key ) {
901   ***      0                                  0            my $this_key = $keys->{$name};
902   ***      0      0      0                    0            if ( $this_key->{name} eq 'PRIMARY' ) {
      ***             0                               
903   ***      0                                  0               $clustered_key = 'PRIMARY';
904                                                            }
905                                                            elsif ( $this_key->{is_unique} && !$this_key->{is_nullable} ) {
906   ***      0                                  0               $clustered_key = $this_key->{name};
907                                                            }
908   ***      0                                  0            MKDEBUG && $clustered_key && _d('This key is the clustered key');
909                                                         }
910                                                      }
911                                                   
912           14                                 72      return $keys, $clustered_key;
913                                                   }
914                                                   
915                                                   sub get_fks {
916   ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
917   ***      0                                  0      my $fks = {};
918                                                   
919   ***      0                                  0      foreach my $fk (
920                                                         $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg )
921                                                      {
922   ***      0                                  0         my ( $name ) = $fk =~ m/CONSTRAINT `(.*?)`/;
923   ***      0                                  0         my ( $cols ) = $fk =~ m/FOREIGN KEY \(([^\)]+)\)/;
924   ***      0                                  0         my ( $parent, $parent_cols ) = $fk =~ m/REFERENCES (\S+) \(([^\)]+)\)/;
925                                                   
926   ***      0      0      0                    0         if ( $parent !~ m/\./ && $opts->{database} ) {
927   ***      0                                  0            $parent = "`$opts->{database}`.$parent";
928                                                         }
929                                                   
930   ***      0                                  0         $fks->{$name} = {
931                                                            name           => $name,
932                                                            colnames       => $cols,
933   ***      0                                  0            cols           => [ map { s/[ `]+//g; $_; } split(',', $cols) ],
      ***      0                                  0   
934                                                            parent_tbl     => $parent,
935                                                            parent_colnames=> $parent_cols,
936   ***      0                                  0            parent_cols    => [ map { s/[ `]+//g; $_; } split(',', $parent_cols) ],
      ***      0                                  0   
937                                                         };
938                                                      }
939                                                   
940   ***      0                                  0      return $fks;
941                                                   }
942                                                   
943                                                   sub remove_auto_increment {
944   ***      0                    0             0      my ( $self, $ddl ) = @_;
945   ***      0                                  0      $ddl =~ s/(^\).*?) AUTO_INCREMENT=\d+\b/$1/m;
946   ***      0                                  0      return $ddl;
947                                                   }
948                                                   
949                                                   sub _d {
950   ***      0                    0             0      my ($package, undef, $line) = caller 0;
951   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
952   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
953                                                           @_;
954   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
955                                                   }
956                                                   
957                                                   1;
958                                                   
959                                                   # ###########################################################################
960                                                   # End TableParser package
961                                                   # ###########################################################################
962                                                   
963                                                   # ###########################################################################
964                                                   # Quoter package 3186
965                                                   # ###########################################################################
966            1                    1            15   use strict;
               1                                  3   
               1                                  5   
967            1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  6   
968                                                   
969                                                   package Quoter;
970                                                   
971            1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  6   
972                                                   
973            1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  9   
974                                                   
975                                                   sub new {
976            7                    7            32      my ( $class ) = @_;
977            7                                 42      bless {}, $class;
978                                                   }
979                                                   
980                                                   sub quote {
981           77                   77           451      my ( $self, @vals ) = @_;
982           77                                304      foreach my $val ( @vals ) {
983          154                                640         $val =~ s/`/``/g;
984                                                      }
985           77                                314      return join('.', map { '`' . $_ . '`' } @vals);
             154                                863   
986                                                   }
987                                                   
988                                                   sub quote_val {
989   ***      0                    0             0      my ( $self, @vals ) = @_;
990                                                      return join(', ',
991                                                         map {
992   ***      0      0                           0            if ( defined $_ ) {
      ***      0                                  0   
993   ***      0                                  0               $_ =~ s/(['\\])/\\$1/g;
994   ***      0      0      0                    0               $_ eq '' || $_ =~ m/^0|\D/ ? "'$_'" : $_;
995                                                            }
996                                                            else {
997   ***      0                                  0               'NULL';
998                                                            }
999                                                         } @vals
1000                                                     );
1001                                                  }
1002                                                  
1003                                                  sub split_unquote {
1004  ***      0                    0             0      my ( $self, $db_tbl, $default_db ) = @_;
1005  ***      0                                  0      $db_tbl =~ s/`//g;
1006  ***      0                                  0      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
1007  ***      0      0                           0      if ( !$tbl ) {
1008  ***      0                                  0         $tbl = $db;
1009  ***      0                                  0         $db  = $default_db;
1010                                                     }
1011  ***      0                                  0      return ($db, $tbl);
1012                                                  }
1013                                                  
1014                                                  1;
1015                                                  
1016                                                  # ###########################################################################
1017                                                  # End Quoter package
1018                                                  # ###########################################################################
1019                                                  
1020                                                  # ###########################################################################
1021                                                  # OptionParser package 4406
1022                                                  # ###########################################################################
1023                                                  package OptionParser;
1024                                                  
1025           1                    1             6   use strict;
               1                                  2   
               1                                  6   
1026           1                    1             5   use warnings FATAL => 'all';
               1                                  3   
               1                                  4   
1027                                                  
1028           1                    1            25   use Getopt::Long;
               1                                  3   
               1                                  7   
1029           1                    1            12   use List::Util qw(max);
               1                                  2   
               1                                 12   
1030           1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  6   
1031                                                  
1032           1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  8   
1033                                                  
1034                                                  my $POD_link_re = '[LC]<"?([^">]+)"?>';
1035                                                  
1036                                                  my %attributes = (
1037                                                     'type'       => 1,
1038                                                     'short form' => 1,
1039                                                     'group'      => 1,
1040                                                     'default'    => 1,
1041                                                     'cumulative' => 1,
1042                                                     'negatable'  => 1,
1043                                                  );
1044                                                  
1045                                                  sub new {
1046           8                    8           198      my ( $class, %args ) = @_;
1047           8                                 55      foreach my $arg ( qw(description) ) {
1048  ***      8     50                          61         die "I need a $arg argument" unless $args{$arg};
1049                                                     }
1050           8                                123      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
1051  ***      8            50                   40      $program_name ||= $PROGRAM_NAME;
1052  ***      8            33                   90      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                   33                        
      ***                   50                        
1053                                                  
1054  ***      8     50     50                  563      my $self = {
      ***                   50                        
1055                                                        description    => $args{description},
1056                                                        prompt         => $args{prompt} || '<options>',
1057                                                        strict         => (exists $args{strict} ? $args{strict} : 1),
1058                                                        dp             => $args{dp}     || undef,
1059                                                        program_name   => $program_name,
1060                                                        opts           => {},
1061                                                        got_opts       => 0,
1062                                                        short_opts     => {},
1063                                                        defaults       => {},
1064                                                        groups         => {},
1065                                                        allowed_groups => {},
1066                                                        errors         => [],
1067                                                        rules          => [],  # desc of rules for --help
1068                                                        mutex          => [],  # rule: opts are mutually exclusive
1069                                                        atleast1       => [],  # rule: at least one opt is required
1070                                                        disables       => {},  # rule: opt disables other opts 
1071                                                        defaults_to    => {},  # rule: opt defaults to value of other opt
1072                                                        default_files  => [
1073                                                           "/etc/maatkit/maatkit.conf",
1074                                                           "/etc/maatkit/$program_name.conf",
1075                                                           "$home/.maatkit.conf",
1076                                                           "$home/.$program_name.conf",
1077                                                        ],
1078                                                     };
1079           8                                 97      return bless $self, $class;
1080                                                  }
1081                                                  
1082                                                  sub get_specs {
1083           8                    8            35      my ( $self, $file ) = @_;
1084           8                                 73      my @specs = $self->_pod_to_specs($file);
1085           8                                162      $self->_parse_specs(@specs);
1086           8                                 42      return;
1087                                                  }
1088                                                  
1089                                                  sub get_defaults_files {
1090           8                    8            34      my ( $self ) = @_;
1091           8                                 26      return @{$self->{default_files}};
               8                                 83   
1092                                                  }
1093                                                  
1094                                                  sub _pod_to_specs {
1095           8                    8            35      my ( $self, $file ) = @_;
1096  ***      8            50                   45      $file ||= __FILE__;
1097  ***      8     50                         201      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
1098                                                  
1099           8                                233      my %types = (
1100                                                        string => 's', # standard Getopt type
1101                                                        'int'  => 'i', # standard Getopt type
1102                                                        float  => 'f', # standard Getopt type
1103                                                        Hash   => 'H', # hash, formed from a comma-separated list
1104                                                        hash   => 'h', # hash as above, but only if a value is given
1105                                                        Array  => 'A', # array, similar to Hash
1106                                                        array  => 'a', # array, similar to hash
1107                                                        DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
1108                                                        size   => 'z', # size with kMG suffix (powers of 2^10)
1109                                                        'time' => 'm', # time, with an optional suffix of s/h/m/d
1110                                                     );
1111           8                                 29      my @specs = ();
1112           8                                 28      my @rules = ();
1113           8                                 19      my $para;
1114                                                  
1115           8                                 71      local $INPUT_RECORD_SEPARATOR = '';
1116           8                                173      while ( $para = <$fh> ) {
1117        4744    100                       35099         next unless $para =~ m/^=head1 OPTIONS/;
1118           8                                 27         last;
1119                                                     }
1120                                                  
1121           8                                 49      while ( $para = <$fh> ) {
1122  ***      8     50                          63         last if $para =~ m/^=over/;
1123  ***      0                                  0         chomp $para;
1124  ***      0                                  0         $para =~ s/\s+/ /g;
1125  ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
1126  ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
1127  ***      0                                  0         push @rules, $para;
1128                                                     }
1129                                                  
1130  ***      8     50                          39      die 'POD has no OPTIONS section' unless $para;
1131                                                  
1132           8                                 27      do {
1133         192    100                        1296         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
1134         184                                494            chomp $para;
1135         184                                403            MKDEBUG && _d($para);
1136         184                                431            my %attribs;
1137                                                  
1138         184                                642            $para = <$fh>; # read next paragraph, possibly attributes
1139                                                  
1140         184    100                         733            if ( $para =~ m/: / ) { # attributes
1141         128                                616               $para =~ s/\s+\Z//g;
1142         192                               1029               %attribs = map {
1143         128                                629                     my ( $attrib, $val) = split(/: /, $_);
1144  ***    192     50                         860                     die "Unrecognized attribute for --$option: $attrib"
1145                                                                       unless $attributes{$attrib};
1146         192                               1095                     ($attrib, $val);
1147                                                                 } split(/; /, $para);
1148         128    100                         609               if ( $attribs{'short form'} ) {
1149          48                                247                  $attribs{'short form'} =~ s/-//;
1150                                                              }
1151         128                                561               $para = <$fh>; # read next paragraph, probably short help desc
1152                                                           }
1153                                                           else {
1154          56                                139               MKDEBUG && _d('Option has no attributes');
1155                                                           }
1156                                                  
1157         184                               1232            $para =~ s/\s+\Z//g;
1158         184                               1218            $para =~ s/\s+/ /g;
1159         184                                635            $para =~ s/$POD_link_re/$1/go;
1160                                                  
1161         184                                766            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
1162         184                                435            MKDEBUG && _d('Short help:', $para);
1163                                                  
1164  ***    184     50                         738            die "No description after option spec $option" if $para =~ m/^=item/;
1165                                                  
1166         184    100                        1001            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
1167          32                                 88               $option = $base_option;
1168          32                                118               $attribs{'negatable'} = 1;
1169                                                           }
1170                                                  
1171         184    100                        3313            push @specs, {
                    100                               
      ***            50                               
                    100                               
                    100                               
                    100                               
1172                                                              spec  => $option
1173                                                                 . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
1174                                                                 . ($attribs{'negatable'}  ? '!'                          : '' )
1175                                                                 . ($attribs{'cumulative'} ? '+'                          : '' )
1176                                                                 . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
1177                                                              desc  => $para
1178                                                                 . ($attribs{default} ? " (default $attribs{default})" : ''),
1179                                                              group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
1180                                                           };
1181                                                        }
1182         192                               1168         while ( $para = <$fh> ) {
1183  ***    376     50                        1293            last unless $para;
1184                                                  
1185                                                  
1186         376    100                        1412            if ( $para =~ m/^=head1/ ) {
1187           8                                 24               $para = undef; # Can't 'last' out of a do {} block.
1188           8                                 44               last;
1189                                                           }
1190         368    100                        2382            last if $para =~ m/^=item --/;
1191                                                        }
1192                                                     } while ( $para );
1193                                                  
1194  ***      8     50                          37      die 'No valid specs in POD OPTIONS' unless @specs;
1195                                                  
1196           8                                 83      close $fh;
1197           8                                 25      return @specs, @rules;
1198                                                  }
1199                                                  
1200                                                  sub _parse_specs {
1201           8                    8            57      my ( $self, @specs ) = @_;
1202           8                                 29      my %disables; # special rule that requires deferred checking
1203                                                  
1204           8                                 43      foreach my $opt ( @specs ) {
1205  ***    184     50                         697         if ( ref $opt ) { # It's an option spec, not a rule.
1206                                                           MKDEBUG && _d('Parsing opt spec:',
1207         184                                411               map { ($_, '=>', $opt->{$_}) } keys %$opt);
1208                                                  
1209         184                               1378            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
1210  ***    184     50                         776            if ( !$long ) {
1211  ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
1212                                                           }
1213         184                                965            $opt->{long} = $long;
1214                                                  
1215  ***    184     50                         843            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
1216         184                                943            $self->{opts}->{$long} = $opt;
1217                                                  
1218  ***    184     50                         743            if ( length $long == 1 ) {
1219  ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
1220  ***      0                                  0               $self->{short_opts}->{$long} = $long;
1221                                                           }
1222                                                  
1223         184    100                         595            if ( $short ) {
1224  ***     48     50                         230               die "Duplicate short option -$short"
1225                                                                 if exists $self->{short_opts}->{$short};
1226          48                                198               $self->{short_opts}->{$short} = $long;
1227          48                                170               $opt->{short} = $short;
1228                                                           }
1229                                                           else {
1230         136                                497               $opt->{short} = undef;
1231                                                           }
1232                                                  
1233         184    100                         999            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
1234  ***    184     50                         947            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
1235  ***    184     50                        1080            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
1236                                                  
1237  ***    184            50                  751            $opt->{group} ||= 'default';
1238         184                               1013            $self->{groups}->{ $opt->{group} }->{$long} = 1;
1239                                                  
1240         184                                633            $opt->{value} = undef;
1241         184                                615            $opt->{got}   = 0;
1242                                                  
1243         184                                955            my ( $type ) = $opt->{spec} =~ m/=(.)/;
1244         184                                690            $opt->{type} = $type;
1245         184                                403            MKDEBUG && _d($long, 'type:', $type);
1246                                                  
1247  ***    184     50     66                 1506            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                   33                        
1248  ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
1249                                                                 . "was given when this OptionParser object was created";
1250                                                           }
1251                                                  
1252         184    100    100                 1847            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
1253                                                  
1254         184    100                        1935            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
1255  ***     32     50                         192               $self->{defaults}->{$long} = defined $def ? $def : 1;
1256          32                                 79               MKDEBUG && _d($long, 'default:', $def);
1257                                                           }
1258                                                  
1259         184    100                         723            if ( $long eq 'config' ) {
1260           8                                 47               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
1261                                                           }
1262                                                  
1263  ***    184     50                         966            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
1264  ***      0                                  0               $disables{$long} = $dis;
1265  ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
1266                                                           }
1267                                                  
1268         184                                905            $self->{opts}->{$long} = $opt;
1269                                                        }
1270                                                        else { # It's an option rule, not a spec.
1271  ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
1272  ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
1273  ***      0                                  0            my @participants = $self->_get_participants($opt);
1274  ***      0                                  0            my $rule_ok = 0;
1275                                                  
1276  ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
1277  ***      0                                  0               $rule_ok = 1;
1278  ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
1279  ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
1280                                                           }
1281  ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
1282  ***      0                                  0               $rule_ok = 1;
1283  ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
1284  ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
1285                                                           }
1286  ***      0      0                           0            if ( $opt =~ m/default to/ ) {
1287  ***      0                                  0               $rule_ok = 1;
1288  ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
1289  ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
1290                                                           }
1291  ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
1292  ***      0                                  0               $rule_ok = 1;
1293  ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
1294  ***      0                                  0               my @groups = split(',', $groups);
1295  ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
1296  ***      0                                  0                  s/\s+//;
1297  ***      0                                  0                  $_ => 1;
1298                                                              } @groups;
1299                                                           }
1300                                                  
1301  ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
1302                                                        }
1303                                                     }
1304                                                  
1305           8                                 54      foreach my $long ( keys %disables ) {
1306  ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
1307  ***      0                                  0         $self->{disables}->{$long} = \@participants;
1308  ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
1309                                                     }
1310                                                  
1311           8                                 46      return; 
1312                                                  }
1313                                                  
1314                                                  sub _get_participants {
1315  ***      0                    0             0      my ( $self, $str ) = @_;
1316  ***      0                                  0      my @participants;
1317  ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
1318  ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
1319                                                           unless exists $self->{opts}->{$long};
1320  ***      0                                  0         push @participants, $long;
1321                                                     }
1322  ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
1323  ***      0                                  0      return @participants;
1324                                                  }
1325                                                  
1326                                                  sub opts {
1327  ***      0                    0             0      my ( $self ) = @_;
1328  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1329  ***      0                                  0      return %opts;
1330                                                  }
1331                                                  
1332                                                  sub opt_values {
1333  ***      0                    0             0      my ( $self ) = @_;
1334  ***      0      0                           0      my %opts = map {
1335  ***      0                                  0         my $opt = $self->{opts}->{$_}->{short} ? $self->{opts}->{$_}->{short}
1336                                                                : $_;
1337  ***      0                                  0         $opt => $self->{opts}->{$_}->{value}
1338  ***      0                                  0      } keys %{$self->{opts}};
1339  ***      0                                  0      return %opts;
1340                                                  }
1341                                                  
1342                                                  sub short_opts {
1343  ***      0                    0             0      my ( $self ) = @_;
1344  ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
1345  ***      0                                  0      return %short_opts;
1346                                                  }
1347                                                  
1348                                                  sub set_defaults {
1349  ***      0                    0             0      my ( $self, %defaults ) = @_;
1350  ***      0                                  0      $self->{defaults} = {};
1351  ***      0                                  0      foreach my $long ( keys %defaults ) {
1352  ***      0      0                           0         die "Cannot set default for nonexistent option $long"
1353                                                           unless exists $self->{opts}->{$long};
1354  ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
1355  ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
1356                                                     }
1357  ***      0                                  0      return;
1358                                                  }
1359                                                  
1360                                                  sub get_defaults {
1361  ***      0                    0             0      my ( $self ) = @_;
1362  ***      0                                  0      return $self->{defaults};
1363                                                  }
1364                                                  
1365                                                  sub get_groups {
1366  ***      0                    0             0      my ( $self ) = @_;
1367  ***      0                                  0      return $self->{groups};
1368                                                  }
1369                                                  
1370                                                  sub _set_option {
1371           7                    7            37      my ( $self, $opt, $val ) = @_;
1372  ***      7      0                          17      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
1373                                                              : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
1374                                                              : die "Getopt::Long gave a nonexistent option: $opt";
1375                                                  
1376           7                                 14      $opt = $self->{opts}->{$long};
1377  ***      7     50                          48      if ( $opt->{is_cumulative} ) {
1378  ***      0                                  0         $opt->{value}++;
1379                                                     }
1380                                                     else {
1381           7                                 28         $opt->{value} = $val;
1382                                                     }
1383           7                                 28      $opt->{got} = 1;
1384           7                                 33      MKDEBUG && _d('Got option', $long, '=', $val);
1385                                                  }
1386                                                  
1387                                                  sub get_opts {
1388           8                    8            34      my ( $self ) = @_; 
1389                                                  
1390           8                                 27      foreach my $long ( keys %{$self->{opts}} ) {
               8                                103   
1391         184                                765         $self->{opts}->{$long}->{got} = 0;
1392  ***    184     50                        1536         $self->{opts}->{$long}->{value}
                    100                               
1393                                                           = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
1394                                                           : $self->{opts}->{$long}->{is_cumulative} ? 0
1395                                                           : undef;
1396                                                     }
1397           8                                 48      $self->{got_opts} = 0;
1398                                                  
1399           8                                 47      $self->{errors} = [];
1400                                                  
1401  ***      8     50     33                  118      if ( @ARGV && $ARGV[0] eq "--config" ) {
1402  ***      0                                  0         shift @ARGV;
1403  ***      0                                  0         $self->_set_option('config', shift @ARGV);
1404                                                     }
1405  ***      8     50                          83      if ( $self->has('config') ) {
1406           8                                 24         my @extra_args;
1407           8                                 85         foreach my $filename ( split(',', $self->get('config')) ) {
1408          32                                 89            eval {
1409          32                                195               push @ARGV, $self->_read_config_file($filename);
1410                                                           };
1411  ***     32     50                         164            if ( $EVAL_ERROR ) {
1412  ***     32     50                         157               if ( $self->got('config') ) {
1413  ***      0                                  0                  die $EVAL_ERROR;
1414                                                              }
1415                                                              elsif ( MKDEBUG ) {
1416                                                                 _d($EVAL_ERROR);
1417                                                              }
1418                                                           }
1419                                                        }
1420           8                                 55         unshift @ARGV, @extra_args;
1421                                                     }
1422                                                  
1423           8                                109      Getopt::Long::Configure('no_ignore_case', 'bundling');
1424                                                     GetOptions(
1425         176                    7          1483         map    { $_->{spec} => sub { $self->_set_option(@_); } }
               7                                 52   
             184                                750   
1426           8                                 60         grep   { $_->{long} ne 'config' } # --config is handled specially above.
1427  ***      8     50                          32         values %{$self->{opts}}
1428                                                     ) or $self->save_error('Error parsing options');
1429                                                  
1430  ***      8     50     33                  402      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
1431  ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
1432                                                           $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
1433                                                              or die "Cannot print: $OS_ERROR";
1434  ***      0                                  0         exit 0;
1435                                                     }
1436                                                  
1437  ***      8     50     33                   83      if ( @ARGV && $self->{strict} ) {
1438  ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
1439                                                     }
1440                                                  
1441           8                                 24      foreach my $mutex ( @{$self->{mutex}} ) {
               8                                 56   
1442  ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
1443  ***      0      0                           0         if ( @set > 1 ) {
1444  ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
1445  ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
1446                                                                   . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
1447                                                                   . ' are mutually exclusive.';
1448  ***      0                                  0            $self->save_error($err);
1449                                                        }
1450                                                     }
1451                                                  
1452           8                                 26      foreach my $required ( @{$self->{atleast1}} ) {
               8                                 45   
1453  ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
1454  ***      0      0                           0         if ( @set == 0 ) {
1455  ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
1456  ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
1457                                                                   .' or --'.$self->{opts}->{$required->[-1]}->{long};
1458  ***      0                                  0            $self->save_error("Specify at least one of $err");
1459                                                        }
1460                                                     }
1461                                                  
1462           8                                 38      foreach my $long ( keys %{$self->{opts}} ) {
               8                                 80   
1463         184                                702         my $opt = $self->{opts}->{$long};
1464         184    100                        1120         if ( $opt->{got} ) {
      ***            50                               
1465  ***      7     50                          43            if ( exists $self->{disables}->{$long} ) {
1466  ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
1467  ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
1468  ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
1469                                                                 'because', $long,'disables them');
1470                                                           }
1471                                                  
1472  ***      7     50                          43            if ( exists $self->{allowed_groups}->{$long} ) {
1473                                                  
1474  ***      0                                  0               my @restricted_groups = grep {
1475  ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
1476  ***      0                                  0               } keys %{$self->{groups}};
1477                                                  
1478  ***      0                                  0               my @restricted_opts;
1479  ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
1480  ***      0                                  0                  RESTRICTED_OPT:
1481  ***      0                                  0                  foreach my $restricted_opt (
1482                                                                    keys %{$self->{groups}->{$restricted_group}} )
1483                                                                 {
1484  ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
1485  ***      0      0                           0                     push @restricted_opts, $restricted_opt
1486                                                                       if $self->{opts}->{$restricted_opt}->{got};
1487                                                                 }
1488                                                              }
1489                                                  
1490  ***      0      0                           0               if ( @restricted_opts ) {
1491  ***      0                                  0                  my $err;
1492  ***      0      0                           0                  if ( @restricted_opts == 1 ) {
1493  ***      0                                  0                     $err = "--$restricted_opts[0]";
1494                                                                 }
1495                                                                 else {
1496  ***      0                                  0                     $err = join(', ',
1497  ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
1498  ***      0                                  0                               grep { $_ } 
1499                                                                              @restricted_opts[0..scalar(@restricted_opts) - 2]
1500                                                                           )
1501                                                                         . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
1502                                                                 }
1503  ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
1504                                                              }
1505                                                           }
1506                                                  
1507                                                        }
1508                                                        elsif ( $opt->{is_required} ) { 
1509  ***      0                                  0            $self->save_error("Required option --$long must be specified");
1510                                                        }
1511                                                  
1512         184                                697         $self->_validate_type($opt);
1513                                                     }
1514                                                  
1515           8                                 46      $self->{got_opts} = 1;
1516           8                                 27      return;
1517                                                  }
1518                                                  
1519                                                  sub _validate_type {
1520         184                  184           668      my ( $self, $opt ) = @_;
1521  ***    184    100     66                 1728      return unless $opt && $opt->{type};
1522          96                                344      my $val = $opt->{value};
1523                                                  
1524  ***     96     50     66                 2361      if ( $val && $opt->{type} eq 'm' ) {
      ***            50     66                        
      ***            50     66                        
      ***            50     66                        
      ***           100     33                        
      ***                   33                        
      ***                   66                        
1525  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
1526  ***      0                                  0         my ( $num, $suffix ) = $val =~ m/(\d+)([a-z])?$/;
1527  ***      0      0                           0         if ( !$suffix ) {
1528  ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
1529  ***      0             0                    0            $suffix = $s || 's';
1530  ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
1531                                                              $opt->{long}, '(value:', $val, ')');
1532                                                        }
1533  ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
1534  ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
1535                                                                : $suffix eq 'm' ? $num * 60       # Minutes
1536                                                                : $suffix eq 'h' ? $num * 3600     # Hours
1537                                                                :                  $num * 86400;   # Days
1538  ***      0                                  0            $opt->{value} = $val;
1539  ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
1540                                                        }
1541                                                        else {
1542  ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
1543                                                        }
1544                                                     }
1545                                                     elsif ( $val && $opt->{type} eq 'd' ) {
1546  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
1547  ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
1548  ***      0                                  0         my $default = {};
1549  ***      0      0                           0         if ( $from_key ) {
1550  ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
1551  ***      0                                  0            $default = $self->{opts}->{$from_key}->{value};
1552                                                        }
1553  ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $default);
1554                                                     }
1555                                                     elsif ( $val && $opt->{type} eq 'z' ) {
1556  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
1557  ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
1558  ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
1559  ***      0      0                           0         if ( defined $num ) {
1560  ***      0      0                           0            if ( $factor ) {
1561  ***      0                                  0               $num *= $factor_for{$factor};
1562  ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
1563                                                                 'to num', $num, '* factor', $factor);
1564                                                           }
1565  ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
1566                                                        }
1567                                                        else {
1568  ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
1569                                                        }
1570                                                     }
1571                                                     elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
1572  ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
1573                                                     }
1574                                                     elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
1575  ***      8            50                  135         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
1576                                                     }
1577                                                     else {
1578          88                                212         MKDEBUG && _d('Nothing to validate for option',
1579                                                           $opt->{long}, 'type', $opt->{type}, 'value', $val);
1580                                                     }
1581                                                  
1582          96                                335      return;
1583                                                  }
1584                                                  
1585                                                  sub get {
1586         204                  204           899      my ( $self, $opt ) = @_;
1587  ***    204     50                         951      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1588  ***    204     50     33                 2063      die "Option $opt does not exist"
1589                                                        unless $long && exists $self->{opts}->{$long};
1590         204                               1688      return $self->{opts}->{$long}->{value};
1591                                                  }
1592                                                  
1593                                                  sub got {
1594          32                   32           144      my ( $self, $opt ) = @_;
1595  ***     32     50                         142      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1596  ***     32     50     33                  336      die "Option $opt does not exist"
1597                                                        unless $long && exists $self->{opts}->{$long};
1598          32                                219      return $self->{opts}->{$long}->{got};
1599                                                  }
1600                                                  
1601                                                  sub has {
1602           8                    8            43      my ( $self, $opt ) = @_;
1603  ***      8     50                          45      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1604  ***      8     50                          69      return defined $long ? exists $self->{opts}->{$long} : 0;
1605                                                  }
1606                                                  
1607                                                  sub set {
1608           2                    2            29      my ( $self, $opt, $val ) = @_;
1609  ***      2     50                          15      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1610  ***      2     50     33                   32      die "Option $opt does not exist"
1611                                                        unless $long && exists $self->{opts}->{$long};
1612           2                                 13      $self->{opts}->{$long}->{value} = $val;
1613           2                                  7      return;
1614                                                  }
1615                                                  
1616                                                  sub save_error {
1617  ***      0                    0             0      my ( $self, $error ) = @_;
1618  ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
1619                                                  }
1620                                                  
1621                                                  sub errors {
1622  ***      0                    0             0      my ( $self ) = @_;
1623  ***      0                                  0      return $self->{errors};
1624                                                  }
1625                                                  
1626                                                  sub prompt {
1627  ***      0                    0             0      my ( $self ) = @_;
1628  ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
1629                                                  }
1630                                                  
1631                                                  sub descr {
1632  ***      0                    0             0      my ( $self ) = @_;
1633  ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
1634                                                                . "  For more details, please use the --help option, "
1635                                                                . "or try 'perldoc $PROGRAM_NAME' "
1636                                                                . "for complete documentation.";
1637  ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
1638  ***      0                                  0      $descr =~ s/ +$//mg;
1639  ***      0                                  0      return $descr;
1640                                                  }
1641                                                  
1642                                                  sub usage_or_errors {
1643           8                    8            36      my ( $self ) = @_;
1644  ***      8     50                          56      if ( $self->{opts}->{help}->{got} ) {
      ***      8     50                          45   
1645  ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
1646  ***      0                                  0         exit 0;
1647                                                     }
1648                                                     elsif ( scalar @{$self->{errors}} ) {
1649  ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
1650  ***      0                                  0         exit 0;
1651                                                     }
1652           8                                 24      return;
1653                                                  }
1654                                                  
1655                                                  sub print_errors {
1656  ***      0                    0             0      my ( $self ) = @_;
1657  ***      0                                  0      my $usage = $self->prompt() . "\n";
1658  ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
1659  ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
1660                                                                . "\n";
1661                                                     }
1662  ***      0                                  0      return $usage . "\n" . $self->descr();
1663                                                  }
1664                                                  
1665                                                  sub print_usage {
1666  ***      0                    0             0      my ( $self ) = @_;
1667  ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
1668  ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
1669                                                  
1670  ***      0      0                           0      my $maxl = max(
1671  ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
1672                                                        @opts);
1673                                                  
1674  ***      0      0                           0      my $maxs = max(0,
1675  ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
1676  ***      0                                  0         values %{$self->{short_opts}});
1677                                                  
1678  ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
1679  ***      0                                  0      my $rcol = 80 - $lcol - 6;
1680  ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
1681                                                  
1682  ***      0                                  0      $maxs = max($lcol - 3, $maxs);
1683                                                  
1684  ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
1685                                                  
1686  ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
1687  ***      0                                  0      push @groups, 'default';
1688                                                  
1689  ***      0                                  0      foreach my $group ( reverse @groups ) {
1690  ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
1691  ***      0                                  0         foreach my $opt (
      ***      0                                  0   
1692  ***      0                                  0            sort { $a->{long} cmp $b->{long} }
1693                                                           grep { $_->{group} eq $group }
1694                                                           @opts )
1695                                                        {
1696  ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
1697  ***      0                                  0            my $short = $opt->{short};
1698  ***      0                                  0            my $desc  = $opt->{desc};
1699  ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
1700  ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
1701  ***      0             0                    0               $s    ||= 's';
1702  ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
1703  ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
1704                                                                     . "d=days; if no suffix, $s is used.";
1705                                                           }
1706  ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
1707  ***      0                                  0            $desc =~ s/ +$//mg;
1708  ***      0      0                           0            if ( $short ) {
1709  ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
1710                                                           }
1711                                                           else {
1712  ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
1713                                                           }
1714                                                        }
1715                                                     }
1716                                                  
1717  ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
1718  ***      0                                  0         $usage .= "\nRules:\n\n";
1719  ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
1720                                                     }
1721  ***      0      0                           0      if ( $self->{dp} ) {
1722  ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
1723                                                     }
1724  ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
1725  ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
1726  ***      0                                  0         my $val   = $opt->{value};
1727  ***      0             0                    0         my $type  = $opt->{type} || '';
1728  ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
1729  ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
1730                                                                  : !defined $val             ? '(No value)'
1731                                                                  : $type eq 'd'              ? $self->{dp}->as_string($val)
1732                                                                  : $type =~ m/H|h/           ? join(',', sort keys %$val)
1733                                                                  : $type =~ m/A|a/           ? join(',', @$val)
1734                                                                  :                             $val;
1735  ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
1736                                                     }
1737  ***      0                                  0      return $usage;
1738                                                  }
1739                                                  
1740                                                  sub prompt_noecho {
1741  ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
1742  ***      0                                  0      my ( $prompt ) = @_;
1743  ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
1744  ***      0      0                           0      print $prompt
1745                                                        or die "Cannot print: $OS_ERROR";
1746  ***      0                                  0      my $response;
1747  ***      0                                  0      eval {
1748  ***      0                                  0         require Term::ReadKey;
1749  ***      0                                  0         Term::ReadKey::ReadMode('noecho');
1750  ***      0                                  0         chomp($response = <STDIN>);
1751  ***      0                                  0         Term::ReadKey::ReadMode('normal');
1752  ***      0      0                           0         print "\n"
1753                                                           or die "Cannot print: $OS_ERROR";
1754                                                     };
1755  ***      0      0                           0      if ( $EVAL_ERROR ) {
1756  ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
1757                                                     }
1758  ***      0                                  0      return $response;
1759                                                  }
1760                                                  
1761                                                  if ( MKDEBUG ) {
1762                                                     print '# ', $^X, ' ', $], "\n";
1763                                                     my $uname = `uname -a`;
1764                                                     if ( $uname ) {
1765                                                        $uname =~ s/\s+/ /g;
1766                                                        print "# $uname\n";
1767                                                     }
1768                                                     printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
1769                                                        $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
1770                                                        ($main::SVN_REV || ''), __LINE__);
1771                                                     print('# Arguments: ',
1772                                                        join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
1773                                                  }
1774                                                  
1775                                                  sub _read_config_file {
1776          32                   32           158      my ( $self, $filename ) = @_;
1777  ***     32     50                          87      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
1778  ***      0                                  0      my @args;
1779  ***      0                                  0      my $prefix = '--';
1780  ***      0                                  0      my $parse  = 1;
1781                                                  
1782                                                     LINE:
1783  ***      0                                  0      while ( my $line = <$fh> ) {
1784  ***      0                                  0         chomp $line;
1785  ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
1786  ***      0                                  0         $line =~ s/\s+#.*$//g;
1787  ***      0                                  0         $line =~ s/^\s+|\s+$//g;
1788  ***      0      0                           0         if ( $line eq '--' ) {
1789  ***      0                                  0            $prefix = '';
1790  ***      0                                  0            $parse  = 0;
1791  ***      0                                  0            next LINE;
1792                                                        }
1793  ***      0      0      0                    0         if ( $parse
      ***             0                               
1794                                                           && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
1795                                                        ) {
1796  ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
1797                                                        }
1798                                                        elsif ( $line =~ m/./ ) {
1799  ***      0                                  0            push @args, $line;
1800                                                        }
1801                                                        else {
1802  ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
1803                                                        }
1804                                                     }
1805  ***      0                                  0      close $fh;
1806  ***      0                                  0      return @args;
1807                                                  }
1808                                                  
1809                                                  sub read_para_after {
1810  ***      0                    0             0      my ( $self, $file, $regex ) = @_;
1811  ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
1812  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
1813  ***      0                                  0      my $para;
1814  ***      0                                  0      while ( $para = <$fh> ) {
1815  ***      0      0                           0         next unless $para =~ m/^=pod$/m;
1816  ***      0                                  0         last;
1817                                                     }
1818  ***      0                                  0      while ( $para = <$fh> ) {
1819  ***      0      0                           0         next unless $para =~ m/$regex/;
1820  ***      0                                  0         last;
1821                                                     }
1822  ***      0                                  0      $para = <$fh>;
1823  ***      0                                  0      chomp($para);
1824  ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
1825  ***      0                                  0      return $para;
1826                                                  }
1827                                                  
1828                                                  sub clone {
1829  ***      0                    0             0      my ( $self ) = @_;
1830                                                  
1831  ***      0                                  0      my %clone = map {
1832  ***      0                                  0         my $hashref  = $self->{$_};
1833  ***      0                                  0         my $val_copy = {};
1834  ***      0                                  0         foreach my $key ( keys %$hashref ) {
1835  ***      0                                  0            my $ref = ref $hashref->{$key};
1836  ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
1837  ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
1838  ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
1839                                                                             : $hashref->{$key};
1840                                                        }
1841  ***      0                                  0         $_ => $val_copy;
1842                                                     } qw(opts short_opts defaults);
1843                                                  
1844  ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
1845  ***      0                                  0         $clone{$scalar} = $self->{$scalar};
1846                                                     }
1847                                                  
1848  ***      0                                  0      return bless \%clone;     
1849                                                  }
1850                                                  
1851                                                  sub _d {
1852  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1853  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1854  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1855                                                          @_;
1856  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1857                                                  }
1858                                                  
1859                                                  1;
1860                                                  
1861                                                  # ###########################################################################
1862                                                  # End OptionParser package
1863                                                  # ###########################################################################
1864                                                  
1865                                                  # ###########################################################################
1866                                                  # Transformers package 4299
1867                                                  # ###########################################################################
1868                                                  
1869                                                  package Transformers;
1870                                                  
1871           1                    1            10   use strict;
               1                                  3   
               1                                  7   
1872           1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  6   
1873           1                    1             7   use English qw(-no_match_vars);
               1                                  2   
               1                                  6   
1874           1                    1            16   use Time::Local qw(timelocal);
               1                                  3   
               1                                 11   
1875           1                    1             7   use Digest::MD5 qw(md5_hex);
               1                                  3   
               1                                  7   
1876                                                  
1877           1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  7   
1878                                                  
1879                                                  require Exporter;
1880                                                  our @ISA         = qw(Exporter);
1881                                                  our %EXPORT_TAGS = ();
1882                                                  our @EXPORT      = ();
1883                                                  our @EXPORT_OK   = qw(
1884                                                     micro_t
1885                                                     percentage_of
1886                                                     secs_to_time
1887                                                     shorten
1888                                                     ts
1889                                                     parse_timestamp
1890                                                     unix_timestamp
1891                                                     any_unix_timestamp
1892                                                     make_checksum
1893                                                  );
1894                                                  
1895                                                  our $mysql_ts  = qr/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?/;
1896                                                  our $proper_ts = qr/(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(?:\.\d+)?/;
1897                                                  our $n_ts      = qr/(\d{1,5})([shmd]?)/; # Limit \d{1,5} because \d{6} looks
1898                                                  
1899                                                  sub micro_t {
1900  ***      0                    0             0      my ( $t, %args ) = @_;
1901  ***      0      0                           0      my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
1902  ***      0      0                           0      my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
1903  ***      0                                  0      my $f;
1904                                                  
1905  ***      0      0                           0      $t = 0 if $t < 0;
1906                                                  
1907  ***      0      0                           0      $t = sprintf('%.17f', $t) if $t =~ /e/;
1908                                                  
1909  ***      0                                  0      $t =~ s/\.(\d{1,6})\d*/\.$1/;
1910                                                  
1911  ***      0      0      0                    0      if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
1912  ***      0                                  0         $f = ($t * 1000000) . 'us';
1913                                                     }
1914                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
1915  ***      0                                  0         $f = sprintf("%.${p_ms}f", $t * 1000);
1916  ***      0                                  0         $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
1917                                                     }
1918                                                     elsif ($t >= 1) {
1919  ***      0                                  0         $f = sprintf("%.${p_s}f", $t);
1920  ***      0                                  0         $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
1921                                                     }
1922                                                     else {
1923  ***      0                                  0         $f = 0;  # $t should = 0 at this point
1924                                                     }
1925                                                  
1926  ***      0                                  0      return $f;
1927                                                  }
1928                                                  
1929                                                  sub percentage_of {
1930  ***      0                    0             0      my ( $is, $of, %args ) = @_;
1931  ***      0             0                    0      my $p   = $args{p} || 0; # float precision
1932  ***      0      0                           0      my $fmt = $p ? "%.${p}f" : "%d";
1933  ***      0             0                    0      return sprintf $fmt, ($is * 100) / ($of ||= 1);
1934                                                  }
1935                                                  
1936                                                  sub secs_to_time {
1937  ***      0                    0             0      my ( $secs, $fmt ) = @_;
1938  ***      0             0                    0      $secs ||= 0;
1939  ***      0      0                           0      return '00:00' unless $secs;
1940                                                  
1941  ***      0      0      0                    0      $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
1942                                                            : $secs >= 3_600  ? 'h'
1943                                                            :                   'm';
1944                                                  
1945                                                     return
1946  ***      0      0                           0         $fmt eq 'd' ? sprintf(
      ***             0                               
1947                                                           "%d+%02d:%02d:%02d",
1948                                                           int($secs / 86_400),
1949                                                           int(($secs % 86_400) / 3_600),
1950                                                           int(($secs % 3_600) / 60),
1951                                                           $secs % 60)
1952                                                        : $fmt eq 'h' ? sprintf(
1953                                                           "%02d:%02d:%02d",
1954                                                           int(($secs % 86_400) / 3_600),
1955                                                           int(($secs % 3_600) / 60),
1956                                                           $secs % 60)
1957                                                        : sprintf(
1958                                                           "%02d:%02d",
1959                                                           int(($secs % 3_600) / 60),
1960                                                           $secs % 60);
1961                                                  }
1962                                                  
1963                                                  sub shorten {
1964  ***      0                    0             0      my ( $num, %args ) = @_;
1965  ***      0      0                           0      my $p = defined $args{p} ? $args{p} : 2;     # float precision
1966  ***      0      0                           0      my $d = defined $args{d} ? $args{d} : 1_024; # divisor
1967  ***      0                                  0      my $n = 0;
1968  ***      0                                  0      my @units = ('', qw(k M G T P E Z Y));
1969  ***      0             0                    0      while ( $num >= $d && $n < @units - 1 ) {
1970  ***      0                                  0         $num /= $d;
1971  ***      0                                  0         ++$n;
1972                                                     }
1973  ***      0      0      0                    0      return sprintf(
1974                                                        $num =~ m/\./ || $n
1975                                                           ? "%.${p}f%s"
1976                                                           : '%d',
1977                                                        $num, $units[$n]);
1978                                                  }
1979                                                  
1980                                                  sub ts {
1981  ***      0                    0             0      my ( $time ) = @_;
1982  ***      0                                  0      my ( $sec, $min, $hour, $mday, $mon, $year )
1983                                                        = localtime($time);
1984  ***      0                                  0      $mon  += 1;
1985  ***      0                                  0      $year += 1900;
1986  ***      0                                  0      return sprintf("%d-%02d-%02dT%02d:%02d:%02d",
1987                                                        $year, $mon, $mday, $hour, $min, $sec);
1988                                                  }
1989                                                  
1990                                                  sub parse_timestamp {
1991  ***      0                    0             0      my ( $val ) = @_;
1992  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $f)
1993                                                           = $val =~ m/^$mysql_ts$/ )
1994                                                     {
1995  ***      0      0                           0         return sprintf "%d-%02d-%02d %02d:%02d:"
      ***             0                               
1996                                                                       . (defined $f ? '%02.6f' : '%02d'),
1997                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
1998                                                     }
1999  ***      0                                  0      return $val;
2000                                                  }
2001                                                  
2002                                                  sub unix_timestamp {
2003  ***      0                    0             0      my ( $val ) = @_;
2004  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s)
2005                                                       = $val =~ m/^$proper_ts$/ )
2006                                                     {
2007  ***      0                                  0         return timelocal($s, $i, $h, $d, $m - 1, $y);
2008                                                     }
2009  ***      0                                  0      return $val;
2010                                                  }
2011                                                  
2012                                                  sub any_unix_timestamp {
2013  ***      0                    0             0      my ( $val, $callback ) = @_;
2014                                                  
2015  ***      0      0                           0      if ( my ($n, $suffix) = $val =~ m/^$n_ts$/ ) {
      ***             0                               
      ***             0                               
2016  ***      0      0                           0         $n = $suffix eq 's' ? $n            # Seconds
      ***             0                               
      ***             0                               
      ***             0                               
2017                                                           : $suffix eq 'm' ? $n * 60       # Minutes
2018                                                           : $suffix eq 'h' ? $n * 3600     # Hours
2019                                                           : $suffix eq 'd' ? $n * 86400    # Days
2020                                                           :                  $n;           # default: Seconds
2021  ***      0                                  0         MKDEBUG && _d('ts is now - N[shmd]:', $n);
2022  ***      0                                  0         return time - $n;
2023                                                     }
2024                                                     elsif ( my ($ymd, $hms) = $val =~ m/^(\d{6})(?:\s+(\d+:\d+:\d+))?/ ) {
2025  ***      0                                  0         MKDEBUG && _d('ts is MySQL slow log timestamp');
2026  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
2027  ***      0                                  0         return unix_timestamp(parse_timestamp($val));
2028                                                     }
2029                                                     elsif ( ($ymd, $hms) = $val =~ m/^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) {
2030  ***      0                                  0         MKDEBUG && _d('ts is properly formatted timestamp');
2031  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
2032  ***      0                                  0         return unix_timestamp($val);
2033                                                     }
2034                                                     else {
2035  ***      0                                  0         MKDEBUG && _d('ts is MySQL expression');
2036  ***      0      0      0                    0         return $callback->($val) if $callback && ref $callback eq 'CODE';
2037                                                     }
2038                                                  
2039  ***      0                                  0      MKDEBUG && _d('Unknown ts type:', $val);
2040  ***      0                                  0      return;
2041                                                  }
2042                                                  
2043                                                  sub make_checksum {
2044  ***      0                    0             0      my ( $val ) = @_;
2045  ***      0                                  0      my $checksum = uc substr(md5_hex($val), -16);
2046  ***      0                                  0      MKDEBUG && _d($checksum, 'checksum for', $val);
2047  ***      0                                  0      return $checksum;
2048                                                  }
2049                                                  
2050                                                  sub _d {
2051  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2052  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2053  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2054                                                          @_;
2055  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2056                                                  }
2057                                                  
2058                                                  1;
2059                                                  
2060                                                  # ###########################################################################
2061                                                  # End Transformers package
2062                                                  # ###########################################################################
2063                                                  
2064                                                  # ###########################################################################
2065                                                  # QueryRewriter package 4281
2066                                                  # ###########################################################################
2067           1                    1             7   use strict;
               1                                  3   
               1                                  5   
2068           1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  7   
2069                                                  
2070                                                  package QueryRewriter;
2071                                                  
2072           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  6   
2073                                                  
2074           1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  7   
2075                                                  
2076                                                  our $verbs   = qr{^SHOW|^FLUSH|^COMMIT|^ROLLBACK|^BEGIN|SELECT|INSERT
2077                                                                    |UPDATE|DELETE|REPLACE|^SET|UNION|^START}xi;
2078                                                  my $quote_re = qr/"(?:(?!(?<!\\)").)*"|'(?:(?!(?<!\\)').)*'/; # Costly!
2079                                                  my $bal;
2080                                                  $bal         = qr/
2081                                                                    \(
2082                                                                    (?:
2083                                                                       (?> [^()]+ )    # Non-parens without backtracking
2084                                                                       |
2085                                                                       (??{ $bal })    # Group with matching parens
2086                                                                    )*
2087                                                                    \)
2088                                                                   /x;
2089                                                  
2090                                                  my $olc_re = qr/(?:--|#)[^'"\r\n]*(?=[\r\n]|\Z)/;  # One-line comments
2091                                                  my $mlc_re = qr#/\*[^!].*?\*/#sm;                  # But not /*!version */
2092                                                  
2093                                                  sub new {
2094  ***      0                    0             0      my ( $class, %args ) = @_;
2095  ***      0                                  0      my $self = { %args };
2096  ***      0                                  0      return bless $self, $class;
2097                                                  }
2098                                                  
2099                                                  sub strip_comments {
2100  ***      0                    0             0      my ( $self, $query ) = @_;
2101  ***      0                                  0      $query =~ s/$olc_re//go;
2102  ***      0                                  0      $query =~ s/$mlc_re//go;
2103  ***      0                                  0      return $query;
2104                                                  }
2105                                                  
2106                                                  sub shorten {
2107  ***      0                    0             0      my ( $self, $query, $length ) = @_;
2108  ***      0                                  0      $query =~ s{
2109                                                        \A(
2110                                                           (?:INSERT|REPLACE)
2111                                                           (?:\s+LOW_PRIORITY|DELAYED|HIGH_PRIORITY|IGNORE)?
2112                                                           (?:\s\w+)*\s+\S+\s+VALUES\s*\(.*?\)
2113                                                        )
2114                                                        \s*,\s*\(.*?(ON\s+DUPLICATE|\Z)}
2115                                                        {$1 /*... omitted ...*/$2}xsi;
2116                                                  
2117  ***      0      0                           0      return $query unless $query =~ m/IN\s*\(\s*(?!select)/i;
2118                                                  
2119  ***      0      0      0                    0      if ( $length && length($query) > $length ) {
2120  ***      0                                  0         my ($left, $mid, $right) = $query =~ m{
2121                                                           (\A.*?\bIN\s*\()     # Everything up to the opening of IN list
2122                                                           ([^\)]+)             # Contents of the list
2123                                                           (\).*\Z)             # The rest of the query
2124                                                        }xsi;
2125  ***      0      0                           0         if ( $left ) {
2126  ***      0                                  0            my $targ = $length - length($left) - length($right);
2127  ***      0                                  0            my @vals = split(/,/, $mid);
2128  ***      0                                  0            my @left = shift @vals;
2129  ***      0                                  0            my @right;
2130  ***      0                                  0            my $len  = length($left[0]);
2131  ***      0             0                    0            while ( @vals && $len < $targ / 2 ) {
2132  ***      0                                  0               $len += length($vals[0]) + 1;
2133  ***      0                                  0               push @left, shift @vals;
2134                                                           }
2135  ***      0             0                    0            while ( @vals && $len < $targ ) {
2136  ***      0                                  0               $len += length($vals[-1]) + 1;
2137  ***      0                                  0               unshift @right, pop @vals;
2138                                                           }
2139  ***      0      0                           0            $query = $left . join(',', @left)
2140                                                                  . (@right ? ',' : '')
2141                                                                  . " /*... omitted " . scalar(@vals) . " items ...*/ "
2142                                                                  . join(',', @right) . $right;
2143                                                        }
2144                                                     }
2145                                                  
2146  ***      0                                  0      return $query;
2147                                                  }
2148                                                  
2149                                                  sub fingerprint {
2150  ***      0                    0             0      my ( $self, $query ) = @_;
2151                                                  
2152  ***      0      0                           0      $query =~ m#\ASELECT /\*!40001 SQL_NO_CACHE \*/ \* FROM `# # mysqldump query
2153                                                        && return 'mysqldump';
2154  ***      0      0                           0      $query =~ m#/\*\w+\.\w+:[0-9]/[0-9]\*/#     # mk-table-checksum, etc query
2155                                                        && return 'maatkit';
2156  ***      0      0                           0      $query =~ m/\A# administrator command: /
2157                                                        && return $query;
2158  ***      0      0                           0      $query =~ m/\A\s*(call\s+\S+)\(/i
2159                                                        && return lc($1); # Warning! $1 used, be careful.
2160  ***      0      0                           0      if ( my ($beginning) = $query =~ m/\A((?:INSERT|REPLACE)(?: IGNORE)? INTO .+? VALUES \(.*?\)),\(/i ) {
2161  ***      0                                  0         $query = $beginning; # Shorten multi-value INSERT statements ASAP
2162                                                     }
2163                                                  
2164  ***      0                                  0      $query =~ s/$olc_re//go;
2165  ***      0                                  0      $query =~ s/$mlc_re//go;
2166  ***      0      0                           0      $query =~ s/\Ause \S+\Z/use ?/i       # Abstract the DB in USE
2167                                                        && return $query;
2168                                                  
2169  ***      0                                  0      $query =~ s/\\["']//g;                # quoted strings
2170  ***      0                                  0      $query =~ s/".*?"/?/sg;               # quoted strings
2171  ***      0                                  0      $query =~ s/'.*?'/?/sg;               # quoted strings
2172  ***      0                                  0      $query =~ s/[0-9+-][0-9a-f.xb+-]*/?/g;# Anything vaguely resembling numbers
2173  ***      0                                  0      $query =~ s/[xb.+-]\?/?/g;            # Clean up leftovers
2174  ***      0                                  0      $query =~ s/\A\s+//;                  # Chop off leading whitespace
2175  ***      0                                  0      chomp $query;                         # Kill trailing whitespace
2176  ***      0                                  0      $query =~ tr[ \n\t\r\f][ ]s;          # Collapse whitespace
2177  ***      0                                  0      $query = lc $query;
2178  ***      0                                  0      $query =~ s/\bnull\b/?/g;             # Get rid of NULLs
2179  ***      0                                  0      $query =~ s{                          # Collapse IN and VALUES lists
2180                                                                 \b(in|values?)(?:[\s,]*\([\s?,]*\))+
2181                                                                }
2182                                                                {$1(?+)}gx;
2183  ***      0                                  0      $query =~ s{                          # Collapse UNION
2184                                                                 \b(select\s.*?)(?:(\sunion(?:\sall)?)\s\1)+
2185                                                                }
2186                                                                {$1 /*repeat$2*/}xg;
2187  ***      0                                  0      $query =~ s/\blimit \?(?:, ?\?| offset \?)?/limit ?/; # LIMIT
2188  ***      0                                  0      return $query;
2189                                                  }
2190                                                  
2191                                                  sub distill {
2192  ***      0                    0             0      my ( $self, $query, %args ) = @_;
2193  ***      0             0                    0      my $qp = $args{qp} || $self->{QueryParser};
2194  ***      0      0                           0      die "I need a qp argument" unless $qp;
2195                                                  
2196  ***      0      0                           0      $query =~ m/\A\s*call\s+(\S+)\(/i
2197                                                        && return "CALL $1"; # Warning! $1 used, be careful.
2198  ***      0      0                           0      $query =~ m/\A# administrator/
2199                                                        && return "ADMIN";
2200  ***      0      0                           0      $query =~ m/\A\s*use\s+/
2201                                                        && return "USE";
2202                                                  
2203  ***      0                                  0      eval $QueryParser::data_def_stmts;
2204  ***      0                                  0      eval $QueryParser::tbl_ident;
2205  ***      0                                  0      my ( $dds ) = $query =~ /^\s*($QueryParser::data_def_stmts)\b/i;
2206  ***      0      0                           0      if ( $dds ) {
2207  ***      0                                  0         my ( $obj ) = $query =~ m/$dds.+(DATABASE|TABLE)\b/i;
2208  ***      0      0                           0         $obj = uc $obj if $obj;
2209  ***      0                                  0         MKDEBUG && _d('Data def statment:', $dds, $obj);
2210  ***      0                                  0         my ($db_or_tbl)
2211                                                           = $query =~ m/(?:TABLE|DATABASE)\s+($QueryParser::tbl_ident)(\s+.*)?/i;
2212  ***      0                                  0         MKDEBUG && _d('Matches db or table:', $db_or_tbl);
2213  ***      0      0                           0         $obj .= ($db_or_tbl ? " $db_or_tbl" : '');
2214  ***      0      0                           0         return uc($dds) . ($obj ? " $obj" : '');
2215                                                     }
2216                                                  
2217  ***      0                                  0      my @verbs = $query =~ m/\b($verbs)\b/gio;
2218  ***      0                                  0      @verbs    = do {
2219  ***      0                                  0         my $last = '';
2220  ***      0                                  0         grep { my $pass = $_ ne $last; $last = $_; $pass } map { uc } @verbs;
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
2221                                                     };
2222  ***      0                                  0      my $verbs = join(q{ }, @verbs);
2223  ***      0                                  0      $verbs =~ s/( UNION SELECT)+/ UNION/g;
2224                                                  
2225  ***      0                                  0      my @tables = map {
2226  ***      0                                  0         $_ =~ s/`//g;
2227  ***      0                                  0         $_ =~ s/(_?)[0-9]+/$1?/g;
2228  ***      0                                  0         $_;
2229                                                     } $qp->get_tables($query);
2230                                                  
2231  ***      0                                  0      @tables = do {
2232  ***      0                                  0         my $last = '';
2233  ***      0                                  0         grep { my $pass = $_ ne $last; $last = $_; $pass } @tables;
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
2234                                                     };
2235                                                  
2236  ***      0                                  0      $query = join(q{ }, $verbs, @tables);
2237  ***      0                                  0      return $query;
2238                                                  }
2239                                                  
2240                                                  sub convert_to_select {
2241  ***      0                    0             0      my ( $self, $query ) = @_;
2242  ***      0      0                           0      return unless $query;
2243  ***      0                                  0      $query =~ s{
      ***      0                                  0   
2244                                                                   \A.*?
2245                                                                   update\s+(.*?)
2246                                                                   \s+set\b(.*?)
2247                                                                   (?:\s*where\b(.*?))?
2248                                                                   (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
2249                                                                   \Z
2250                                                                }
2251                                                                {__update_to_select($1, $2, $3, $4)}exsi
2252  ***      0                                  0         || $query =~ s{
2253                                                                      \A.*?
2254                                                                      (?:insert|replace)\s+
2255                                                                      .*?\binto\b(.*?)\(([^\)]+)\)\s*
2256                                                                      values?\s*(\(.*?\))\s*
2257                                                                      (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
2258                                                                      \Z
2259                                                                   }
2260                                                                   {__insert_to_select($1, $2, $3)}exsi
2261  ***      0      0      0                    0         || $query =~ s{
2262                                                                      \A.*?
2263                                                                      delete\s+(.*?)
2264                                                                      \bfrom\b(.*)
2265                                                                      \Z
2266                                                                   }
2267                                                                   {__delete_to_select($1, $2)}exsi;
2268  ***      0                                  0      $query =~ s/\s*on\s+duplicate\s+key\s+update.*\Z//si;
2269  ***      0                                  0      $query =~ s/\A.*?(?=\bSELECT\s*\b)//ism;
2270  ***      0                                  0      return $query;
2271                                                  }
2272                                                  
2273                                                  sub convert_select_list {
2274  ***      0                    0             0      my ( $self, $query ) = @_;
2275  ***      0      0                           0      $query =~ s{
      ***      0                                  0   
2276                                                                 \A\s*select(.*?)\bfrom\b
2277                                                                }
2278                                                                {$1 =~ m/\*/ ? "select 1 from" : "select isnull(coalesce($1)) from"}exi;
2279  ***      0                                  0      return $query;
2280                                                  }
2281                                                  
2282                                                  sub __delete_to_select {
2283  ***      0                    0             0      my ( $delete, $join ) = @_;
2284  ***      0      0                           0      if ( $join =~ m/\bjoin\b/ ) {
2285  ***      0                                  0         return "select 1 from $join";
2286                                                     }
2287  ***      0                                  0      return "select * from $join";
2288                                                  }
2289                                                  
2290                                                  sub __insert_to_select {
2291  ***      0                    0             0      my ( $tbl, $cols, $vals ) = @_;
2292  ***      0                                  0      MKDEBUG && _d('Args:', @_);
2293  ***      0                                  0      my @cols = split(/,/, $cols);
2294  ***      0                                  0      MKDEBUG && _d('Cols:', @cols);
2295  ***      0                                  0      $vals =~ s/^\(|\)$//g; # Strip leading/trailing parens
2296  ***      0                                  0      my @vals = $vals =~ m/($quote_re|[^,]*${bal}[^,]*|[^,]+)/g;
2297  ***      0                                  0      MKDEBUG && _d('Vals:', @vals);
2298  ***      0      0                           0      if ( @cols == @vals ) {
2299  ***      0                                  0         return "select * from $tbl where "
2300  ***      0                                  0            . join(' and ', map { "$cols[$_]=$vals[$_]" } (0..$#cols));
2301                                                     }
2302                                                     else {
2303  ***      0                                  0         return "select * from $tbl limit 1";
2304                                                     }
2305                                                  }
2306                                                  
2307                                                  sub __update_to_select {
2308  ***      0                    0             0      my ( $from, $set, $where, $limit ) = @_;
2309  ***      0      0                           0      return "select $set from $from "
      ***             0                               
2310                                                        . ( $where ? "where $where" : '' )
2311                                                        . ( $limit ? " $limit "      : '' );
2312                                                  }
2313                                                  
2314                                                  sub wrap_in_derived {
2315  ***      0                    0             0      my ( $self, $query ) = @_;
2316  ***      0      0                           0      return unless $query;
2317  ***      0      0                           0      return $query =~ m/\A\s*select/i
2318                                                        ? "select 1 from ($query) as x limit 1"
2319                                                        : $query;
2320                                                  }
2321                                                  
2322                                                  sub _d {
2323  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2324  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2325  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2326                                                          @_;
2327  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2328                                                  }
2329                                                  
2330                                                  1;
2331                                                  
2332                                                  # ###########################################################################
2333                                                  # End QueryRewriter package
2334                                                  # ###########################################################################
2335                                                  
2336                                                  # ###########################################################################
2337                                                  # SlowLogParser package 3980
2338                                                  # ###########################################################################
2339                                                  package SlowLogParser;
2340                                                  
2341           1                    1             7   use strict;
               1                                  3   
               1                                  6   
2342           1                    1             6   use warnings FATAL => 'all';
               1                                  5   
               1                                  7   
2343           1                    1             5   use English qw(-no_match_vars);
               1                                  2   
               1                                  6   
2344           1                    1             6   use Data::Dumper;
               1                                  2   
               1                                  6   
2345                                                  
2346           1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  7   
2347                                                  
2348                                                  sub new {
2349           8                    8            42      my ( $class ) = @_;
2350           8                                 71      bless {}, $class;
2351                                                  }
2352                                                  
2353                                                  my $slow_log_ts_line = qr/^# Time: ([0-9: ]{15})/;
2354                                                  my $slow_log_uh_line = qr/# User\@Host: ([^\[]+|\[[^[]+\]).*?@ (\S*) \[(.*)\]/;
2355                                                  my $slow_log_hd_line = qr{
2356                                                        ^(?:
2357                                                        T[cC][pP]\s[pP]ort:\s+\d+ # case differs on windows/unix
2358                                                        |
2359                                                        [/A-Z].*mysqld,\sVersion.*(?:started\swith:|embedded\slibrary)
2360                                                        |
2361                                                        Time\s+Id\s+Command
2362                                                        ).*\n
2363                                                     }xm;
2364                                                  
2365                                                  sub parse_event {
2366          24                   24           156      my ( $self, $fh, $misc, @callbacks ) = @_;
2367          24                                 92      my $oktorun_here = 1;
2368  ***     24     50                         141      my $oktorun      = $misc->{oktorun} ? $misc->{oktorun} : \$oktorun_here;
2369          24                                 74      my $num_events   = 0;
2370                                                  
2371          24                                 60      my @pending;
2372          24                                181      local $INPUT_RECORD_SEPARATOR = ";\n#";
2373          24                                107      my $trimlen    = length($INPUT_RECORD_SEPARATOR);
2374          24                                124      my $pos_in_log = tell($fh);
2375          24                                 60      my $stmt;
2376                                                  
2377                                                     EVENT:
2378  ***     24            66                  651      while ( $$oktorun
      ***                   66                        
2379                                                             && (defined($stmt = shift @pending) or defined($stmt = <$fh>)) ) {
2380          16                                117         my @properties = ('cmd', 'Query', 'pos_in_log', $pos_in_log);
2381          16                                 60         $pos_in_log = tell($fh);
2382                                                  
2383  ***     16     50                         231         if ( $stmt =~ s/$slow_log_hd_line//go ){ # Throw away header lines in log
2384  ***      0                                  0            my @chunks = split(/$INPUT_RECORD_SEPARATOR/o, $stmt);
2385  ***      0      0                           0            if ( @chunks > 1 ) {
2386  ***      0                                  0               MKDEBUG && _d("Found multiple chunks");
2387  ***      0                                  0               $stmt = shift @chunks;
2388  ***      0                                  0               unshift @pending, @chunks;
2389                                                           }
2390                                                        }
2391                                                  
2392          16    100                         119         $stmt = '#' . $stmt unless $stmt =~ m/\A#/;
2393          16                                120         $stmt =~ s/;\n#?\Z//;
2394                                                  
2395                                                  
2396          16                                 64         my ($got_ts, $got_uh, $got_ac, $got_db, $got_set, $got_embed);
2397          16                                 48         my $pos = 0;
2398          16                                 55         my $len = length($stmt);
2399          16                                 47         my $found_arg = 0;
2400                                                        LINE:
2401          16                                149         while ( $stmt =~ m/^(.*)$/mg ) { # /g is important, requires scalar match.
2402          80                                282            $pos     = pos($stmt);  # Be careful not to mess this up!
2403          80                                326            my $line = $1;          # Necessary for /g and pos() to work.
2404          80                                198            MKDEBUG && _d($line);
2405                                                  
2406          80    100                         419            if ($line =~ m/^(?:#|use |SET (?:last_insert_id|insert_id|timestamp))/o) {
2407                                                  
2408  ***     64    100     66                 1326               if ( !$got_ts && (my ( $time ) = $line =~ m/$slow_log_ts_line/o)) {
      ***           100     66                        
      ***            50     33                        
      ***           100     33                        
      ***            50      0                        
      ***             0                               
2409          16                                 42                  MKDEBUG && _d("Got ts", $time);
2410          16                                 67                  push @properties, 'ts', $time;
2411          16                                 53                  ++$got_ts;
2412  ***     16     50     33                  236                  if ( !$got_uh
2413                                                                    && ( my ( $user, $host, $ip ) = $line =~ m/$slow_log_uh_line/o )
2414                                                                 ) {
2415  ***      0                                  0                     MKDEBUG && _d("Got user, host, ip", $user, $host, $ip);
2416  ***      0                                  0                     push @properties, 'user', $user, 'host', $host, 'ip', $ip;
2417  ***      0                                  0                     ++$got_uh;
2418                                                                 }
2419                                                              }
2420                                                  
2421                                                              elsif ( !$got_uh
2422                                                                    && ( my ( $user, $host, $ip ) = $line =~ m/$slow_log_uh_line/o )
2423                                                              ) {
2424          16                                 42                  MKDEBUG && _d("Got user, host, ip", $user, $host, $ip);
2425          16                                116                  push @properties, 'user', $user, 'host', $host, 'ip', $ip;
2426          16                                 51                  ++$got_uh;
2427                                                              }
2428                                                  
2429                                                              elsif (!$got_ac && $line =~ m/^# (?:administrator command:.*)$/) {
2430  ***      0                                  0                  MKDEBUG && _d("Got admin command");
2431  ***      0                                  0                  push @properties, 'cmd', 'Admin', 'arg', $line;
2432  ***      0                                  0                  push @properties, 'bytes', length($properties[-1]);
2433  ***      0                                  0                  ++$found_arg;
2434  ***      0                                  0                  ++$got_ac;
2435                                                              }
2436                                                  
2437                                                              elsif ( $line =~ m/^# +[A-Z][A-Za-z_]+: \S+/ ) { # Make the test cheap!
2438          16                                 41                  MKDEBUG && _d("Got some line with properties");
2439          16                                296                  my @temp = $line =~ m/(\w+):\s+(\d+(?:\.\d+)?|\S+|\Z)/g;
2440          16                                114                  push @properties, @temp;
2441                                                              }
2442                                                  
2443                                                              elsif ( !$got_db && (my ( $db ) = $line =~ m/^use ([^;]+)/ ) ) {
2444          16                                 38                  MKDEBUG && _d("Got a default database:", $db);
2445          16                                 60                  push @properties, 'db', $db;
2446          16                                 54                  ++$got_db;
2447                                                              }
2448                                                  
2449                                                              elsif (!$got_set && (my ($setting) = $line =~ m/^SET\s+([^;]*)/)) {
2450  ***      0                                  0                  MKDEBUG && _d("Got some setting:", $setting);
2451  ***      0                                  0                  push @properties, split(/,|\s*=\s*/, $setting);
2452  ***      0                                  0                  ++$got_set;
2453                                                              }
2454                                                  
2455  ***     64     50     33                  881               if ( !$found_arg && $pos == $len ) {
2456  ***      0                                  0                  MKDEBUG && _d("Did not find arg, looking for special cases");
2457  ***      0                                  0                  local $INPUT_RECORD_SEPARATOR = ";\n";
2458  ***      0      0                           0                  if ( defined(my $l = <$fh>) ) {
2459  ***      0                                  0                     chomp $l;
2460  ***      0                                  0                     MKDEBUG && _d("Found admin statement", $l);
2461  ***      0                                  0                     push @properties, 'cmd', 'Admin', 'arg', '#' . $l;
2462  ***      0                                  0                     push @properties, 'bytes', length($properties[-1]);
2463  ***      0                                  0                     $found_arg++;
2464                                                                 }
2465                                                                 else {
2466  ***      0                                  0                     MKDEBUG && _d("I can't figure out what to do with this line");
2467  ***      0                                  0                     next EVENT;
2468                                                                 }
2469                                                              }
2470                                                           }
2471                                                           else {
2472          16                                 43               MKDEBUG && _d("Got the query/arg line");
2473          16                                 90               my $arg = substr($stmt, $pos - length($line));
2474          16                                 76               push @properties, 'arg', $arg, 'bytes', length($arg);
2475  ***     16     50     33                  198               if ( $misc && $misc->{embed}
      ***                   33                        
2476                                                                 && ( my ($e) = $arg =~ m/($misc->{embed})/)
2477                                                              ) {
2478  ***      0                                  0                  push @properties, $e =~ m/$misc->{capture}/g;
2479                                                              }
2480          16                                 62               last LINE;
2481                                                           }
2482                                                        }
2483                                                  
2484          16                                 38         MKDEBUG && _d('Properties of event:', Dumper(\@properties));
2485          16                                261         my $event = { @properties };
2486          16                                 74         foreach my $callback ( @callbacks ) {
2487  ***     92     50                         393            last unless $event = $callback->($event);
2488                                                        }
2489          16                                 48         ++$num_events;
2490  ***     16     50                         160         last EVENT unless @pending;
2491                                                     }
2492          24                                209      return $num_events;
2493                                                  }
2494                                                  
2495                                                  sub _d {
2496  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2497  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2498  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2499                                                          @_;
2500  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2501                                                  }
2502                                                  
2503                                                  1;
2504                                                  
2505                                                  # ###########################################################################
2506                                                  # End SlowLogParser package
2507                                                  # ###########################################################################
2508                                                  
2509                                                  # ###########################################################################
2510                                                  # EventAggregator package 4131
2511                                                  # ###########################################################################
2512                                                  package EventAggregator;
2513                                                  
2514           1                    1             6   use strict;
               1                                  3   
               1                                  5   
2515           1                    1             5   use warnings FATAL => 'all';
               1                                  3   
               1                                  5   
2516           1                    1             5   use English qw(-no_match_vars);
               1                                  3   
               1                                  5   
2517                                                  
2518           1                    1             6   use constant MKDEBUG      => $ENV{MKDEBUG};
               1                                  2   
               1                                  6   
2519           1                    1             7   use constant BUCK_SIZE    => 1.05;
               1                                  2   
               1                                  5   
2520           1                    1             5   use constant BASE_LOG     => log(BUCK_SIZE);
               1                                  2   
               1                                  5   
2521           1                    1            10   use constant BASE_OFFSET  => abs(1 - log(0.000001) / BASE_LOG); # 284.1617969
               1                                  2   
               1                                  4   
2522           1                    1             5   use constant NUM_BUCK     => 1000;
               1                                  3   
               1                                  4   
2523           1                    1             6   use constant MIN_BUCK     => .000001;
               1                                  3   
               1                                  4   
2524                                                  
2525                                                  our @buckets  = map { 0 } (0..NUM_BUCK-1);
2526                                                  
2527                                                  my @buck_vals = map { bucket_value($_); } (0..NUM_BUCK-1);
2528                                                  
2529                                                  sub new {
2530  ***      0                    0             0      my ( $class, %args ) = @_;
2531  ***      0                                  0      foreach my $arg ( qw(groupby worst) ) {
2532  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
2533                                                     }
2534  ***      0             0                    0      my $attributes = $args{attributes} || {};
2535  ***      0                                  0      my $self = {
2536                                                        groupby        => $args{groupby},
2537                                                        detect_attribs => scalar keys %$attributes == 0 ? 1 : 0,
2538                                                        all_attribs    => [ keys %$attributes ],
2539                                                        ignore_attribs => {
2540  ***      0                                  0            map  { $_ => $args{attributes}->{$_} }
2541  ***      0                                  0            grep { $_ ne $args{groupby} }
2542  ***      0                                  0            @{$args{ignore_attributes}}
2543                                                        },
2544                                                        attributes     => {
2545  ***      0                                  0            map  { $_ => $args{attributes}->{$_} }
2546  ***      0                                  0            grep { $_ ne $args{groupby} }
2547                                                           keys %$attributes
2548                                                        },
2549                                                        alt_attribs    => {
2550  ***      0                                  0            map  { $_ => make_alt_attrib(@{$args{attributes}->{$_}}) }
      ***      0                                  0   
2551  ***      0      0                           0            grep { $_ ne $args{groupby} }
2552                                                           keys %$attributes
2553                                                        },
2554                                                        worst        => $args{worst},
2555                                                        unroll_limit => $args{unroll_limit} || 1000,
2556                                                        attrib_limit => $args{attrib_limit},
2557                                                        result_classes => {},
2558                                                        result_globals => {},
2559                                                        result_samples => {},
2560                                                        n_events       => 0,
2561                                                        unrolled_loops => undef,
2562  ***      0      0      0                    0         type_for       => { %{$args{type_for} || {}} },
2563                                                     };
2564  ***      0                                  0      return bless $self, $class;
2565                                                  }
2566                                                  
2567                                                  sub reset_aggregated_data {
2568  ***      0                    0             0      my ( $self ) = @_;
2569  ***      0                                  0      foreach my $class ( values %{$self->{result_classes}} ) {
      ***      0                                  0   
2570  ***      0                                  0         foreach my $attrib ( values %$class ) {
2571  ***      0                                  0            delete @{$attrib}{keys %$attrib};
      ***      0                                  0   
2572                                                        }
2573                                                     }
2574  ***      0                                  0      foreach my $class ( values %{$self->{result_globals}} ) {
      ***      0                                  0   
2575  ***      0                                  0         delete @{$class}{keys %$class};
      ***      0                                  0   
2576                                                     }
2577  ***      0                                  0      delete @{$self->{result_samples}}{keys %{$self->{result_samples}}};
      ***      0                                  0   
      ***      0                                  0   
2578  ***      0                                  0      $self->{n_events} = 0;
2579                                                  }
2580                                                  
2581                                                  sub aggregate {
2582  ***      0                    0             0      my ( $self, $event ) = @_;
2583                                                  
2584  ***      0                                  0      my $group_by = $event->{$self->{groupby}};
2585  ***      0      0                           0      return unless defined $group_by;
2586                                                  
2587  ***      0                                  0      $self->{n_events}++;
2588  ***      0                                  0      MKDEBUG && _d('event', $self->{n_events});
2589                                                  
2590  ***      0      0                           0      return $self->{unrolled_loops}->($self, $event, $group_by)
2591                                                        if $self->{unrolled_loops};
2592                                                  
2593  ***      0      0                           0      if ( $self->{n_events} <= $self->{unroll_limit} ) {
2594                                                  
2595  ***      0      0                           0         $self->add_new_attributes($event) if $self->{detect_attribs};
2596                                                  
2597  ***      0                                  0         ATTRIB:
2598  ***      0                                  0         foreach my $attrib ( keys %{$self->{attributes}} ) {
2599                                                  
2600  ***      0      0                           0            if ( !exists $event->{$attrib} ) {
2601  ***      0                                  0               MKDEBUG && _d("attrib doesn't exist in event:", $attrib);
2602  ***      0                                  0               my $alt_attrib = $self->{alt_attribs}->{$attrib}->($event);
2603  ***      0                                  0               MKDEBUG && _d('alt attrib:', $alt_attrib);
2604  ***      0      0                           0               next ATTRIB unless $alt_attrib;
2605                                                           }
2606                                                  
2607                                                           GROUPBY:
2608  ***      0      0                           0            foreach my $val ( ref $group_by ? @$group_by : ($group_by) ) {
2609  ***      0             0                    0               my $class_attrib  = $self->{result_classes}->{$val}->{$attrib} ||= {};
2610  ***      0             0                    0               my $global_attrib = $self->{result_globals}->{$attrib} ||= {};
2611  ***      0                                  0               my $samples       = $self->{result_samples};
2612  ***      0                                  0               my $handler = $self->{handlers}->{ $attrib };
2613  ***      0      0                           0               if ( !$handler ) {
2614  ***      0                                  0                  $handler = $self->make_handler(
2615                                                                    $attrib,
2616                                                                    $event,
2617                                                                    wor => $self->{worst} eq $attrib,
2618                                                                    alt => $self->{attributes}->{$attrib},
2619                                                                 );
2620  ***      0                                  0                  $self->{handlers}->{$attrib} = $handler;
2621                                                              }
2622  ***      0      0                           0               next GROUPBY unless $handler;
2623  ***      0             0                    0               $samples->{$val} ||= $event; # Initialize to the first event.
2624  ***      0                                  0               $handler->($event, $class_attrib, $global_attrib, $samples, $group_by);
2625                                                           }
2626                                                        }
2627                                                     }
2628                                                     else {
2629  ***      0                                  0         $self->_make_unrolled_loops($event);
2630  ***      0                                  0         $self->{unrolled_loops}->($self, $event, $group_by);
2631                                                     }
2632                                                  
2633  ***      0                                  0      return;
2634                                                  }
2635                                                  
2636                                                  sub _make_unrolled_loops {
2637  ***      0                    0             0      my ( $self, $event ) = @_;
2638                                                  
2639  ***      0                                  0      my $group_by = $event->{$self->{groupby}};
2640                                                  
2641  ***      0                                  0      my @attrs   = grep { $self->{handlers}->{$_} } keys %{$self->{attributes}};
      ***      0                                  0   
      ***      0                                  0   
2642  ***      0                                  0      my $globs   = $self->{result_globals}; # Global stats for each
2643  ***      0                                  0      my $samples = $self->{result_samples};
2644                                                  
2645  ***      0      0                           0      my @lines = (
2646                                                        'my ( $self, $event, $group_by ) = @_;',
2647                                                        'my ($val, $class, $global, $idx);',
2648                                                        (ref $group_by ? ('foreach my $group_by ( @$group_by ) {') : ()),
2649                                                        'my $temp = $self->{result_classes}->{ $group_by }
2650                                                           ||= { map { $_ => { } } @attrs };',
2651                                                        '$samples->{$group_by} ||= $event;', # Always start with the first.
2652                                                     );
2653  ***      0                                  0      foreach my $i ( 0 .. $#attrs ) {
2654  ***      0                                  0         push @lines, (
2655                                                           '$class  = $temp->{"'  . $attrs[$i] . '"};',
2656                                                           '$global = $globs->{"' . $attrs[$i] . '"};',
2657                                                           $self->{unrolled_for}->{$attrs[$i]},
2658                                                        );
2659                                                     }
2660  ***      0      0                           0      if ( ref $group_by ) {
2661  ***      0                                  0         push @lines, '}'; # Close the loop opened above
2662                                                     }
2663  ***      0                                  0      @lines = map { s/^/   /gm; $_ } @lines; # Indent for debugging
      ***      0                                  0   
      ***      0                                  0   
2664  ***      0                                  0      unshift @lines, 'sub {';
2665  ***      0                                  0      push @lines, '}';
2666                                                  
2667  ***      0                                  0      my $code = join("\n", @lines);
2668  ***      0                                  0      MKDEBUG && _d('Unrolled subroutine:', @lines);
2669  ***      0                                  0      my $sub = eval $code;
2670  ***      0      0                           0      die $EVAL_ERROR if $EVAL_ERROR;
2671  ***      0                                  0      $self->{unrolled_loops} = $sub;
2672                                                  
2673  ***      0                                  0      return;
2674                                                  }
2675                                                  
2676                                                  sub results {
2677  ***      0                    0             0      my ( $self ) = @_;
2678                                                     return {
2679  ***      0                                  0         classes => $self->{result_classes},
2680                                                        globals => $self->{result_globals},
2681                                                        samples => $self->{result_samples},
2682                                                     };
2683                                                  }
2684                                                  
2685                                                  sub attributes {
2686  ***      0                    0             0      my ( $self ) = @_;
2687  ***      0                                  0      return $self->{type_for};
2688                                                  }
2689                                                  
2690                                                  sub type_for {
2691  ***      0                    0             0      my ( $self, $attrib ) = @_;
2692  ***      0                                  0      return $self->{type_for}->{$attrib};
2693                                                  }
2694                                                  
2695                                                  sub make_handler {
2696  ***      0                    0             0      my ( $self, $attrib, $event, %args ) = @_;
2697  ***      0      0                           0      die "I need an attrib" unless defined $attrib;
2698  ***      0                                  0      my ($val) = grep { defined $_ } map { $event->{$_} } @{ $args{alt} };
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
2699  ***      0                                  0      my $is_array = 0;
2700  ***      0      0                           0      if (ref $val eq 'ARRAY') {
2701  ***      0                                  0         $is_array = 1;
2702  ***      0                                  0         $val      = $val->[0];
2703                                                     }
2704  ***      0      0                           0      return unless defined $val; # Can't decide type if it's undef.
2705                                                  
2706  ***      0                                  0      my $float_re = qr{[+-]?(?:(?=\d|[.])\d+(?:[.])\d{0,})(?:E[+-]?\d+)?}i;
2707  ***      0      0                           0      my $type = $self->type_for($attrib)         ? $self->type_for($attrib)
      ***             0                               
      ***             0                               
2708                                                              : $val  =~ m/^(?:\d+|$float_re)$/o ? 'num'
2709                                                              : $val  =~ m/^(?:Yes|No)$/         ? 'bool'
2710                                                              :                                    'string';
2711  ***      0                                  0      MKDEBUG && _d('Type for', $attrib, 'is', $type,
2712                                                        '(sample:', $val, '), is array:', $is_array);
2713  ***      0                                  0      $self->{type_for}->{$attrib} = $type;
2714                                                  
2715  ***      0      0                           0      %args = ( # Set up defaults
      ***             0                               
      ***             0                               
      ***             0                               
2716                                                        min => 1,
2717                                                        max => 1,
2718                                                        sum => $type =~ m/num|bool/    ? 1 : 0,
2719                                                        cnt => 1,
2720                                                        unq => $type =~ m/bool|string/ ? 1 : 0,
2721                                                        all => $type eq 'num'          ? 1 : 0,
2722                                                        glo => 1,
2723                                                        trf => ($type eq 'bool') ? q{(($val || '') eq 'Yes') ? 1 : 0} : undef,
2724                                                        wor => 0,
2725                                                        alt => [],
2726                                                        %args,
2727                                                     );
2728                                                  
2729  ***      0                                  0      my @lines = ("# type: $type"); # Lines of code for the subroutine
2730  ***      0      0                           0      if ( $args{trf} ) {
2731  ***      0                                  0         push @lines, q{$val = } . $args{trf} . ';';
2732                                                     }
2733                                                  
2734  ***      0                                  0      foreach my $place ( qw($class $global) ) {
2735  ***      0                                  0         my @tmp;
2736  ***      0      0                           0         if ( $args{min} ) {
2737  ***      0      0                           0            my $op   = $type eq 'num' ? '<' : 'lt';
2738  ***      0                                  0            push @tmp, (
2739                                                              'PLACE->{min} = $val if !defined PLACE->{min} || $val '
2740                                                                 . $op . ' PLACE->{min};',
2741                                                           );
2742                                                        }
2743  ***      0      0                           0         if ( $args{max} ) {
2744  ***      0      0                           0            my $op = ($type eq 'num') ? '>' : 'gt';
2745  ***      0                                  0            push @tmp, (
2746                                                              'PLACE->{max} = $val if !defined PLACE->{max} || $val '
2747                                                                 . $op . ' PLACE->{max};',
2748                                                           );
2749                                                        }
2750  ***      0      0                           0         if ( $args{sum} ) {
2751  ***      0                                  0            push @tmp, 'PLACE->{sum} += $val;';
2752                                                        }
2753  ***      0      0                           0         if ( $args{cnt} ) {
2754  ***      0                                  0            push @tmp, '++PLACE->{cnt};';
2755                                                        }
2756  ***      0      0                           0         if ( $args{all} ) {
2757  ***      0                                  0            push @tmp, (
2758                                                              'exists PLACE->{all} or PLACE->{all} = [ @buckets ];',
2759                                                              '++PLACE->{all}->[ EventAggregator::bucket_idx($val) ];',
2760                                                           );
2761                                                        }
2762  ***      0                                  0         push @lines, map { s/PLACE/$place/g; $_ } @tmp;
      ***      0                                  0   
      ***      0                                  0   
2763                                                     }
2764                                                  
2765  ***      0      0                           0      if ( $args{unq} ) {
2766  ***      0                                  0         push @lines, '++$class->{unq}->{$val};';
2767                                                     }
2768  ***      0      0                           0      if ( $args{wor} ) {
2769  ***      0      0                           0         my $op = $type eq 'num' ? '>=' : 'ge';
2770  ***      0                                  0         push @lines, (
2771                                                           'if ( $val ' . $op . ' ($class->{max} || 0) ) {',
2772                                                           '   $samples->{$group_by} = $event;',
2773                                                           '}',
2774                                                        );
2775                                                     }
2776                                                  
2777  ***      0                                  0      my @limit;
2778  ***      0      0      0                    0      if ( $args{all} && $type eq 'num' && $self->{attrib_limit} ) {
      ***                    0                        
2779  ***      0                                  0         push @limit, (
2780                                                           "if ( \$val > $self->{attrib_limit} ) {",
2781                                                           '   $val = $class->{last} ||= 0;',
2782                                                           '}',
2783                                                           '$class->{last} = $val;',
2784                                                        );
2785                                                     }
2786                                                  
2787  ***      0                                  0      my @unrolled = (
2788                                                        "\$val = \$event->{'$attrib'};",
2789                                                        ($is_array ? ('foreach my $val ( @$val ) {') : ()),
2790  ***      0                                  0         (map { "\$val = \$event->{'$_'} unless defined \$val;" }
2791  ***      0                                  0            grep { $_ ne $attrib } @{$args{alt}}),
      ***      0                                  0   
2792                                                        'defined $val && do {',
2793  ***      0      0                           0         ( map { s/^/   /gm; $_ } (@limit, @lines) ), # Indent for debugging
      ***      0      0                           0   
2794                                                        '};',
2795                                                        ($is_array ? ('}') : ()),
2796                                                     );
2797  ***      0                                  0      $self->{unrolled_for}->{$attrib} = join("\n", @unrolled);
2798                                                  
2799  ***      0                                  0      unshift @lines, (
2800                                                        'sub {',
2801                                                        'my ( $event, $class, $global, $samples, $group_by ) = @_;',
2802                                                        'my ($val, $idx);', # NOTE: define all variables here
2803                                                        "\$val = \$event->{'$attrib'};",
2804  ***      0                                  0         (map { "\$val = \$event->{'$_'} unless defined \$val;" }
2805  ***      0      0                           0            grep { $_ ne $attrib } @{$args{alt}}),
      ***      0      0                           0   
2806                                                        'return unless defined $val;',
2807                                                        ($is_array ? ('foreach my $val ( @$val ) {') : ()),
2808                                                        @limit,
2809                                                        ($is_array ? ('}') : ()),
2810                                                     );
2811  ***      0                                  0      push @lines, '}';
2812  ***      0                                  0      my $code = join("\n", @lines);
2813  ***      0                                  0      $self->{code_for}->{$attrib} = $code;
2814                                                  
2815  ***      0                                  0      MKDEBUG && _d('Metric handler for', $attrib, ':', @lines);
2816  ***      0                                  0      my $sub = eval join("\n", @lines);
2817  ***      0      0                           0      die if $EVAL_ERROR;
2818  ***      0                                  0      return $sub;
2819                                                  }
2820                                                  
2821                                                  sub bucket_idx {
2822  ***      0                    0             0      my ( $val ) = @_;
2823  ***      0      0                           0      return 0 if $val < MIN_BUCK;
2824  ***      0                                  0      my $idx = int(BASE_OFFSET + log($val)/BASE_LOG);
2825  ***      0      0                           0      return $idx > (NUM_BUCK-1) ? (NUM_BUCK-1) : $idx;
2826                                                  }
2827                                                  
2828                                                  sub bucket_value {
2829        1000                 1000          2946      my ( $bucket ) = @_;
2830        1000    100                        3479      return 0 if $bucket == 0;
2831  ***    999     50     33                 7214      die "Invalid bucket: $bucket" if $bucket < 0 || $bucket > (NUM_BUCK-1);
2832         999                               4441      return (BUCK_SIZE**($bucket-1)) * MIN_BUCK;
2833                                                  }
2834                                                  
2835                                                  {
2836                                                     my @buck_tens;
2837                                                     sub buckets_of {
2838  ***      0      0             0             0         return @buck_tens if @buck_tens;
2839                                                  
2840  ***      0                                  0         my $start_bucket  = 0;
2841  ***      0                                  0         my @base10_starts = (0);
2842  ***      0                                  0         map { push @base10_starts, (10**$_)*MIN_BUCK } (1..7);
      ***      0                                  0   
2843                                                  
2844  ***      0                                  0         for my $base10_bucket ( 0..($#base10_starts-1) ) {
2845  ***      0                                  0            my $next_bucket = bucket_idx( $base10_starts[$base10_bucket+1] );
2846  ***      0                                  0            MKDEBUG && _d('Base 10 bucket', $base10_bucket, 'maps to',
2847                                                              'base 1.05 buckets', $start_bucket, '..', $next_bucket-1);
2848  ***      0                                  0            for my $base1_05_bucket ($start_bucket..($next_bucket-1)) {
2849  ***      0                                  0               $buck_tens[$base1_05_bucket] = $base10_bucket;
2850                                                           }
2851  ***      0                                  0            $start_bucket = $next_bucket;
2852                                                        }
2853                                                  
2854  ***      0                                  0         map { $buck_tens[$_] = 7 } ($start_bucket..(NUM_BUCK-1));
      ***      0                                  0   
2855                                                  
2856  ***      0                                  0         return @buck_tens;
2857                                                     }
2858                                                  }
2859                                                  
2860                                                  sub calculate_statistical_metrics {
2861  ***      0                    0             0      my ( $self, $vals, $args ) = @_;
2862  ***      0                                  0      my $statistical_metrics = {
2863                                                        pct_95    => 0,
2864                                                        stddev    => 0,
2865                                                        median    => 0,
2866                                                        cutoff    => undef,
2867                                                     };
2868                                                  
2869  ***      0      0      0                    0      return $statistical_metrics
      ***                    0                        
2870                                                        unless defined $vals && @$vals && $args->{cnt};
2871                                                  
2872  ***      0                                  0      my $n_vals = $args->{cnt};
2873  ***      0      0      0                    0      if ( $n_vals == 1 || $args->{max} == $args->{min} ) {
      ***             0                               
2874  ***      0             0                    0         my $v      = $args->{max} || 0;
2875  ***      0      0                           0         my $bucket = int(6 + ( log($v > 0 ? $v : MIN_BUCK) / log(10)));
2876  ***      0      0                           0         $bucket    = $bucket > 7 ? 7 : $bucket < 0 ? 0 : $bucket;
      ***             0                               
2877                                                        return {
2878  ***      0                                  0            pct_95 => $v,
2879                                                           stddev => 0,
2880                                                           median => $v,
2881                                                           cutoff => $n_vals,
2882                                                        };
2883                                                     }
2884                                                     elsif ( $n_vals == 2 ) {
2885  ***      0                                  0         foreach my $v ( $args->{min}, $args->{max} ) {
2886  ***      0      0      0                    0            my $bucket = int(6 + ( log($v && $v > 0 ? $v : MIN_BUCK) / log(10)));
2887  ***      0      0                           0            $bucket = $bucket > 7 ? 7 : $bucket < 0 ? 0 : $bucket;
      ***             0                               
2888                                                        }
2889  ***      0             0                    0         my $v      = $args->{max} || 0;
2890  ***      0             0                    0         my $mean = (($args->{min} || 0) + $v) / 2;
2891                                                        return {
2892  ***      0                                  0            pct_95 => $v,
2893                                                           stddev => sqrt((($v - $mean) ** 2) *2),
2894                                                           median => $mean,
2895                                                           cutoff => $n_vals,
2896                                                        };
2897                                                     }
2898                                                  
2899  ***      0      0                           0      my $cutoff = $n_vals >= 10 ? int ( $n_vals * 0.95 ) : $n_vals;
2900  ***      0                                  0      $statistical_metrics->{cutoff} = $cutoff;
2901                                                  
2902  ***      0                                  0      my $total_left = $n_vals;
2903  ***      0                                  0      my $top_vals   = $n_vals - $cutoff; # vals > 95th
2904  ***      0                                  0      my $sum_excl   = 0;
2905  ***      0                                  0      my $sum        = 0;
2906  ***      0                                  0      my $sumsq      = 0;
2907  ***      0                                  0      my $mid        = int($n_vals / 2);
2908  ***      0                                  0      my $median     = 0;
2909  ***      0                                  0      my $prev       = NUM_BUCK-1; # Used for getting median when $cutoff is odd
2910  ***      0                                  0      my $bucket_95  = 0; # top bucket in 95th
2911                                                  
2912  ***      0                                  0      MKDEBUG && _d('total vals:', $total_left, 'top vals:', $top_vals, 'mid:', $mid);
2913                                                  
2914                                                     BUCKET:
2915  ***      0                                  0      for my $bucket ( reverse 0..(NUM_BUCK-1) ) {
2916  ***      0                                  0         my $val = $vals->[$bucket];
2917  ***      0      0                           0         next BUCKET unless $val; 
2918                                                  
2919  ***      0                                  0         $total_left -= $val;
2920  ***      0                                  0         $sum_excl   += $val;
2921  ***      0      0      0                    0         $bucket_95   = $bucket if !$bucket_95 && $sum_excl > $top_vals;
2922                                                  
2923  ***      0      0      0                    0         if ( !$median && $total_left <= $mid ) {
2924  ***      0      0      0                    0            $median = (($cutoff % 2) || ($val > 1)) ? $buck_vals[$bucket]
2925                                                                   : ($buck_vals[$bucket] + $buck_vals[$prev]) / 2;
2926                                                        }
2927                                                  
2928  ***      0                                  0         $sum    += $val * $buck_vals[$bucket];
2929  ***      0                                  0         $sumsq  += $val * ($buck_vals[$bucket]**2);
2930  ***      0                                  0         $prev   =  $bucket;
2931                                                     }
2932                                                  
2933  ***      0                                  0      my $var      = $sumsq/$n_vals - ( ($sum/$n_vals) ** 2 );
2934  ***      0      0                           0      my $stddev   = $var > 0 ? sqrt($var) : 0;
2935  ***      0             0                    0      my $maxstdev = (($args->{max} || 0) - ($args->{min} || 0)) / 2;
      ***                    0                        
2936  ***      0      0                           0      $stddev      = $stddev > $maxstdev ? $maxstdev : $stddev;
2937                                                  
2938  ***      0                                  0      MKDEBUG && _d('sum:', $sum, 'sumsq:', $sumsq, 'stddev:', $stddev,
2939                                                        'median:', $median, 'prev bucket:', $prev,
2940                                                        'total left:', $total_left, 'sum excl', $sum_excl,
2941                                                        'bucket 95:', $bucket_95, $buck_vals[$bucket_95]);
2942                                                  
2943  ***      0                                  0      $statistical_metrics->{stddev} = $stddev;
2944  ***      0                                  0      $statistical_metrics->{pct_95} = $buck_vals[$bucket_95];
2945  ***      0                                  0      $statistical_metrics->{median} = $median;
2946                                                  
2947  ***      0                                  0      return $statistical_metrics;
2948                                                  }
2949                                                  
2950                                                  sub metrics {
2951  ***      0                    0             0      my ( $self, %args ) = @_;
2952  ***      0                                  0      foreach my $arg ( qw(attrib where) ) {
2953  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
2954                                                     }
2955  ***      0                                  0      my $stats = $self->results;
2956  ***      0                                  0      my $store = $stats->{classes}->{$args{where}}->{$args{attrib}};
2957                                                  
2958  ***      0                                  0      my $global_cnt = $stats->{globals}->{$args{attrib}}->{cnt};
2959  ***      0                                  0      my $metrics    = $self->calculate_statistical_metrics($store->{all}, $store);
2960                                                  
2961                                                     return {
2962  ***      0      0      0                    0         cnt    => $store->{cnt},
      ***             0      0                        
2963                                                        pct    => $global_cnt && $store->{cnt} ? $store->{cnt} / $global_cnt : 0,
2964                                                        sum    => $store->{sum},
2965                                                        min    => $store->{min},
2966                                                        max    => $store->{max},
2967                                                        avg    => $store->{sum} && $store->{cnt} ? $store->{sum} / $store->{cnt} : 0,
2968                                                        median => $metrics->{median},
2969                                                        pct_95 => $metrics->{pct_95},
2970                                                        stddev => $metrics->{stddev},
2971                                                     };
2972                                                  }
2973                                                  
2974                                                  sub top_events {
2975  ***      0                    0             0      my ( $self, %args ) = @_;
2976  ***      0                                  0      my $classes = $self->{result_classes};
2977  ***      0                                  0      my @sorted = reverse sort { # Sorted list of $groupby values
2978  ***      0                                  0         $classes->{$a}->{$args{attrib}}->{$args{orderby}}
2979                                                           <=> $classes->{$b}->{$args{attrib}}->{$args{orderby}}
2980                                                        } grep {
2981  ***      0                                  0            defined $classes->{$_}->{$args{attrib}}->{$args{orderby}}
2982                                                        } keys %$classes;
2983  ***      0                                  0      my @chosen;
2984  ***      0                                  0      my ($total, $count) = (0, 0);
2985  ***      0                                  0      foreach my $groupby ( @sorted ) {
2986  ***      0      0      0                    0         if ( 
      ***             0      0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
2987                                                           (!$args{total} || $total < $args{total} )
2988                                                           && ( !$args{count} || $count < $args{count} )
2989                                                        ) {
2990  ***      0                                  0            push @chosen, [$groupby, 'top'];
2991                                                        }
2992                                                  
2993                                                        elsif ( $args{ol_attrib} && (!$args{ol_freq}
2994                                                           || $classes->{$groupby}->{$args{ol_attrib}}->{cnt} >= $args{ol_freq})
2995                                                        ) {
2996  ***      0                                  0            MKDEBUG && _d('Calculating statistical_metrics');
2997  ***      0                                  0            my $stats = $self->calculate_statistical_metrics(
2998                                                              $classes->{$groupby}->{$args{ol_attrib}}->{all},
2999                                                              $classes->{$groupby}->{$args{ol_attrib}}
3000                                                           );
3001  ***      0      0                           0            if ( $stats->{pct_95} >= $args{ol_limit} ) {
3002  ***      0                                  0               push @chosen, [$groupby, 'outlier'];
3003                                                           }
3004                                                        }
3005                                                  
3006  ***      0                                  0         $total += $classes->{$groupby}->{$args{attrib}}->{$args{orderby}};
3007  ***      0                                  0         $count++;
3008                                                     }
3009  ***      0                                  0      return @chosen;
3010                                                  }
3011                                                  
3012                                                  sub add_new_attributes {
3013  ***      0                    0             0      my ( $self, $event ) = @_;
3014  ***      0      0                           0      return unless $event;
3015                                                  
3016  ***      0                                  0      map {
3017  ***      0      0      0                    0         my $attrib = $_;
3018  ***      0                                  0         $self->{attributes}->{$attrib}  = [$attrib];
3019  ***      0                                  0         $self->{alt_attribs}->{$attrib} = make_alt_attrib($attrib);
3020  ***      0                                  0         push @{$self->{all_attribs}}, $attrib;
      ***      0                                  0   
3021  ***      0                                  0         MKDEBUG && _d('Added new attribute:', $attrib);
3022                                                     }
3023                                                     grep {
3024  ***      0                                  0         $_ ne $self->{groupby}
3025                                                        && !exists $self->{attributes}->{$_}
3026                                                        && !exists $self->{ignore_attribs}->{$_}
3027                                                     }
3028                                                     keys %$event;
3029                                                  
3030  ***      0                                  0      return;
3031                                                  }
3032                                                  
3033                                                  sub get_attributes {
3034  ***      0                    0             0      my ( $self ) = @_;
3035  ***      0                                  0      return @{$self->{all_attribs}};
      ***      0                                  0   
3036                                                  }
3037                                                  
3038                                                  sub events_processed {
3039  ***      0                    0             0      my ( $self ) = @_;
3040  ***      0                                  0      return $self->{n_events};
3041                                                  }
3042                                                  
3043                                                  sub make_alt_attrib {
3044  ***      0                    0             0      my ( @attribs ) = @_;
3045                                                  
3046  ***      0                                  0      my $attrib = shift @attribs;  # Primary attribute.
3047  ***      0      0             0             0      return sub {} unless @attribs;  # No alternates.
      ***      0                                  0   
3048                                                  
3049  ***      0                                  0      my @lines;
3050  ***      0                                  0      push @lines, 'sub { my ( $event ) = @_; my $alt_attrib;';
3051  ***      0                                  0      push @lines, map  {
3052  ***      0                                  0            "\$alt_attrib = '$_' if !defined \$alt_attrib "
3053                                                           . "&& exists \$event->{'$_'};"
3054                                                        } @attribs;
3055  ***      0                                  0      push @lines, 'return $alt_attrib; }';
3056  ***      0                                  0      MKDEBUG && _d('alt attrib sub for', $attrib, ':', @lines);
3057  ***      0                                  0      my $sub = eval join("\n", @lines);
3058  ***      0      0                           0      die if $EVAL_ERROR;
3059  ***      0                                  0      return $sub;
3060                                                  }
3061                                                  
3062                                                  sub _d {
3063  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3064  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3065  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3066                                                          @_;
3067  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3068                                                  }
3069                                                  
3070                                                  1;
3071                                                  
3072                                                  # ###########################################################################
3073                                                  # End EventAggregator package
3074                                                  # ###########################################################################
3075                                                  
3076                                                  # ###########################################################################
3077                                                  # QueryParser package 4418
3078                                                  # ###########################################################################
3079                                                  package QueryParser;
3080                                                  
3081           1                    1             8   use strict;
               1                                  3   
               1                                  6   
3082           1                    1             9   use warnings FATAL => 'all';
               1                                  3   
               1                                  7   
3083           1                    1             5   use English qw(-no_match_vars);
               1                                  3   
               1                                  6   
3084                                                  
3085           1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  7   
3086                                                  our $tbl_ident = qr/(?:`[^`]+`|\w+)(?:\.(?:`[^`]+`|\w+))?/;
3087                                                  our $tbl_regex = qr{
3088                                                           \b(?:FROM|JOIN|(?<!KEY\s)UPDATE|INTO) # Words that precede table names
3089                                                           \b\s*
3090                                                           ($tbl_ident
3091                                                              (?: (?:\s+ (?:AS\s+)? \w+)?, \s*$tbl_ident )*
3092                                                           )
3093                                                        }xio;
3094                                                  our $has_derived = qr{
3095                                                        \b(?:FROM|JOIN|,)
3096                                                        \s*\(\s*SELECT
3097                                                     }xi;
3098                                                  
3099                                                  our $data_def_stmts = qr/(?:CREATE|ALTER|TRUNCATE|DROP|RENAME)/i;
3100                                                  
3101                                                  sub new {
3102           8                    8            38      my ( $class ) = @_;
3103           8                                 63      bless {}, $class;
3104                                                  }
3105                                                  
3106                                                  sub get_tables {
3107          52                   52           234      my ( $self, $query ) = @_;
3108  ***     52     50                         220      return unless $query;
3109          52                                118      MKDEBUG && _d('Getting tables for', $query);
3110                                                  
3111          52                                662      my ( $ddl_stmt ) = $query =~ /^\s*($data_def_stmts)\b/i;
3112          52    100                         241      if ( $ddl_stmt ) {
3113          24                                 62         MKDEBUG && _d('Special table type:', $ddl_stmt);
3114          24                                119         $query =~ s/IF NOT EXISTS//i;
3115  ***     24     50                         167         if ( $query =~ m/$ddl_stmt DATABASE\b/i ) {
3116  ***      0                                  0            MKDEBUG && _d('Query alters a database, not a table');
3117  ***      0                                  0            return ();
3118                                                        }
3119  ***     24     50     33                  419         if ( $ddl_stmt =~ m/CREATE/i && $query =~ m/$ddl_stmt\b.+?\bSELECT\b/i ) {
3120          24                                224            my ($select) = $query =~ m/\b(SELECT\b.+)/i;
3121          24                                 70            MKDEBUG && _d('CREATE TABLE ... SELECT:', $select);
3122          24                                132            return $self->get_tables($select);
3123                                                        }
3124  ***      0                                  0         my ($tbl) = $query =~ m/TABLE\s+($tbl_ident)(\s+.*)?/i;
3125  ***      0                                  0         MKDEBUG && _d('Matches table:', $tbl);
3126  ***      0                                  0         return ($tbl);
3127                                                     }
3128                                                  
3129          28                                166      $query =~ s/ (?:LOW_PRIORITY|IGNORE|STRAIGHT_JOIN)//ig;
3130                                                  
3131          28                                155      $query =~ s/\\["']//g;                # quoted strings
3132          28                                 94      $query =~ s/".*?"/?/sg;               # quoted strings
3133          28                                101      $query =~ s/'.*?'/?/sg;               # quoted strings
3134                                                  
3135          28                                 84      my @tables;
3136          28                                413      foreach my $tbls ( $query =~ m/$tbl_regex/gio ) {
3137          28                                 76         MKDEBUG && _d('Match tables:', $tbls);
3138          28                                177         foreach my $tbl ( split(',', $tbls) ) {
3139          28                                434            $tbl =~ s/\s*($tbl_ident)(\s+.*)?/$1/gio;
3140          28                                201            push @tables, $tbl;
3141                                                        }
3142                                                     }
3143          28                                197      return @tables;
3144                                                  }
3145                                                  
3146                                                  sub has_derived_table {
3147  ***      0                    0             0      my ( $self, $query ) = @_;
3148  ***      0                                  0      my $match = $query =~ m/$has_derived/;
3149  ***      0                                  0      MKDEBUG && _d($query, 'has ' . ($match ? 'a' : 'no') . ' derived table');
3150  ***      0                                  0      return $match;
3151                                                  }
3152                                                  
3153                                                  sub get_aliases {
3154  ***      0                    0             0      my ( $self, $query ) = @_;
3155  ***      0      0                           0      return unless $query;
3156  ***      0                                  0      my $aliases;
3157                                                  
3158  ***      0                                  0      $query =~ s/ (?:LOW_PRIORITY|IGNORE|STRAIGHT_JOIN)//ig;
3159                                                  
3160  ***      0                                  0      $query =~ s/ (?:INNER|OUTER|CROSS|LEFT|RIGHT|NATURAL)//ig;
3161                                                  
3162  ***      0                                  0      my ($tbl_refs, $from) = $query =~ m{
3163                                                        (
3164                                                           (FROM|INTO|UPDATE)\b\s*   # Keyword before table refs
3165                                                           .+?                       # Table refs
3166                                                        )
3167                                                        (?:\s+|\z)                   # If the query does not end with the table
3168                                                        (?:WHERE|ORDER|LIMIT|HAVING|SET|VALUES|\z) # Keyword after table refs
3169                                                     }ix;
3170                                                  
3171  ***      0      0      0                    0      die "Failed to parse table references from $query"
3172                                                        unless $tbl_refs && $from;
3173                                                  
3174  ***      0                                  0      MKDEBUG && _d('tbl refs:', $tbl_refs);
3175                                                  
3176  ***      0                                  0      my $before_tbl = qr/(?:,|JOIN|\s|$from)+/i;
3177                                                  
3178  ***      0                                  0      my $after_tbl  = qr/(?:,|JOIN|ON|USING|\z)/i;
3179                                                  
3180  ***      0                                  0      $tbl_refs =~ s/ = /=/g;
3181                                                  
3182  ***      0                                  0      while (
3183                                                        $tbl_refs =~ m{
3184                                                           $before_tbl\b\s*
3185                                                              ( ($tbl_ident) (?:\s+ (?:AS\s+)? (\w+))? )
3186                                                           \s*$after_tbl
3187                                                        }xgio )
3188                                                     {
3189  ***      0                                  0         my ( $tbl_ref, $db_tbl, $alias ) = ($1, $2, $3);
3190  ***      0                                  0         MKDEBUG && _d('Match table:', $tbl_ref);
3191                                                  
3192  ***      0      0                           0         if ( $tbl_ref =~ m/^AS\s+\w+/i ) {
3193  ***      0                                  0            MKDEBUG && _d('Subquery', $tbl_ref);
3194  ***      0                                  0            $aliases->{$alias} = undef;
3195  ***      0                                  0            next;
3196                                                        }
3197                                                  
3198  ***      0                                  0         my ( $db, $tbl ) = $db_tbl =~ m/^(?:(.*?)\.)?(.*)/;
3199  ***      0             0                    0         $aliases->{$alias || $tbl} = $tbl;
3200  ***      0      0                           0         $aliases->{DATABASE}->{$tbl} = $db if $db;
3201                                                     }
3202  ***      0                                  0      return $aliases;
3203                                                  }
3204                                                  
3205                                                  sub split {
3206  ***      0                    0             0      my ( $self, $query ) = @_;
3207  ***      0      0                           0      return unless $query;
3208  ***      0                                  0      $query = remove_comments($query);
3209  ***      0                                  0      $query =~ s/^\s+//;      # Remove leading spaces.
3210  ***      0                                  0      $query =~ s/\s{2,}/ /g;  # Remove extra spaces.
3211  ***      0                                  0      MKDEBUG && _d('Splitting', $query);
3212                                                  
3213  ***      0                                  0      my $verbs = qr{SELECT|INSERT|UPDATE|DELETE|REPLACE|UNION|CREATE}i;
3214                                                  
3215  ***      0                                  0      my @split_statements = grep { $_ } split(m/\b($verbs\b(?!(?:\s*\()))/io, $query);
      ***      0                                  0   
3216                                                  
3217  ***      0                                  0      my @statements;
3218  ***      0      0                           0      if ( @split_statements == 1 ) {
3219  ***      0                                  0         push @statements, $query;
3220                                                     }
3221                                                     else {
3222                                                        for ( my $i = 0; $i <= $#split_statements; $i += 2 ) {
3223  ***      0                                  0            push @statements, $split_statements[$i].$split_statements[$i+1];
3224  ***      0                                  0         }
3225                                                     }
3226                                                  
3227  ***      0                                  0      MKDEBUG && _d('statements:', map { $_ ? "<$_>" : 'none' } @statements);
3228  ***      0                                  0      return @statements;
3229                                                  }
3230                                                  
3231                                                  sub remove_comments {
3232  ***      0                    0             0      my ( $query ) = @_;
3233  ***      0      0                           0      return unless $query;
3234  ***      0                                  0      $query =~ s!/\*.*?\*/! !g;
3235  ***      0                                  0      return $query;
3236                                                  }
3237                                                  
3238                                                  sub _d {
3239  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3240  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3241  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3242                                                          @_;
3243  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3244                                                  }
3245                                                  
3246                                                  1;
3247                                                  
3248                                                  # ###########################################################################
3249                                                  # End QueryParser package
3250                                                  # ###########################################################################
3251                                                  
3252                                                  # ###########################################################################
3253                                                  # Daemon package 3976
3254                                                  # ###########################################################################
3255                                                  
3256                                                  package Daemon;
3257                                                  
3258           1                    1             7   use strict;
               1                                  3   
               1                                  5   
3259           1                    1             5   use warnings FATAL => 'all';
               1                                  3   
               1                                  9   
3260                                                  
3261           1                    1            13   use POSIX qw(setsid);
               1                                  3   
               1                                  7   
3262           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  8   
3263                                                  
3264           1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  9   
3265                                                  
3266                                                  sub new {
3267  ***      0                    0             0      my ( $class, %args ) = @_;
3268  ***      0                                  0      foreach my $arg ( qw(o) ) {
3269  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3270                                                     }
3271  ***      0                                  0      my $o = $args{o};
3272  ***      0      0                           0      my $self = {
      ***             0                               
3273                                                        o        => $o,
3274                                                        log_file => $o->has('log') ? $o->get('log') : undef,
3275                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
3276                                                     };
3277                                                  
3278  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
3279                                                  
3280  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
3281  ***      0                                  0      return bless $self, $class;
3282                                                  }
3283                                                  
3284                                                  sub daemonize {
3285  ***      0                    0             0      my ( $self ) = @_;
3286                                                  
3287  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
3288  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
3289  ***      0      0                           0      if ( $pid ) {
3290  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
3291  ***      0                                  0         exit;
3292                                                     }
3293                                                  
3294  ***      0                                  0      $self->{child} = 1;
3295                                                  
3296  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
3297  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
3298                                                  
3299  ***      0                                  0      $self->_make_PID_file();
3300                                                  
3301  ***      0      0                           0      if ( -t STDIN ) {
3302  ***      0                                  0         close STDIN;
3303  ***      0      0                           0         open  STDIN, '/dev/null'
3304                                                           or die "Cannot reopen STDIN to /dev/null";
3305                                                     }
3306                                                  
3307  ***      0      0                           0      if ( $self->{log_file} ) {
3308  ***      0                                  0         close STDOUT;
3309  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
3310                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
3311                                                  
3312  ***      0                                  0         close STDERR;
3313  ***      0      0                           0         open  STDERR, ">&STDOUT"
3314                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR";
3315                                                     }
3316                                                  
3317  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
3318  ***      0                                  0      return;
3319                                                  }
3320                                                  
3321                                                  sub check_PID_file {
3322  ***      0                    0             0      my ( $self, $file ) = @_;
3323  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
3324  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
3325  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
3326  ***      0                                  0         my $pid;
3327  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
3328  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
3329  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
3330  ***      0      0                           0         if ( $pid ) {
3331  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
3332  ***      0      0                           0            if ( $pid_is_alive ) {
3333  ***      0                                  0               die "The PID file $PID_file already exists "
3334                                                                 . " and the PID that it contains, $pid, is running";
3335                                                           }
3336                                                           else {
3337  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
3338                                                                 . "contains, $pid, is not running";
3339                                                           }
3340                                                        }
3341                                                        else {
3342  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
3343                                                              . "contain a PID";
3344                                                        }
3345                                                     }
3346                                                     else {
3347  ***      0                                  0         MKDEBUG && _d('No PID file');
3348                                                     }
3349  ***      0                                  0      return;
3350                                                  }
3351                                                  
3352                                                  sub make_PID_file {
3353  ***      0                    0             0      my ( $self ) = @_;
3354  ***      0      0                           0      if ( exists $self->{child} ) {
3355  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
3356                                                     }
3357  ***      0                                  0      $self->_make_PID_file();
3358  ***      0                                  0      $self->{rm_PID_file} = 1;
3359  ***      0                                  0      return;
3360                                                  }
3361                                                  
3362                                                  sub _make_PID_file {
3363  ***      0                    0             0      my ( $self ) = @_;
3364                                                  
3365  ***      0                                  0      my $PID_file = $self->{PID_file};
3366  ***      0      0                           0      if ( !$PID_file ) {
3367  ***      0                                  0         MKDEBUG && _d('No PID file to create');
3368  ***      0                                  0         return;
3369                                                     }
3370                                                  
3371  ***      0                                  0      $self->check_PID_file();
3372                                                  
3373  ***      0      0                           0      open my $PID_FH, '>', $PID_file
3374                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
3375  ***      0      0                           0      print $PID_FH $PID
3376                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
3377  ***      0      0                           0      close $PID_FH
3378                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
3379                                                  
3380  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
3381  ***      0                                  0      return;
3382                                                  }
3383                                                  
3384                                                  sub _remove_PID_file {
3385  ***      0                    0             0      my ( $self ) = @_;
3386  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
3387  ***      0      0                           0         unlink $self->{PID_file}
3388                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
3389  ***      0                                  0         MKDEBUG && _d('Removed PID file');
3390                                                     }
3391                                                     else {
3392  ***      0                                  0         MKDEBUG && _d('No PID to remove');
3393                                                     }
3394  ***      0                                  0      return;
3395                                                  }
3396                                                  
3397                                                  sub DESTROY {
3398  ***      0                    0             0      my ( $self ) = @_;
3399  ***      0      0      0                    0      $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
3400  ***      0                                  0      return;
3401                                                  }
3402                                                  
3403                                                  sub _d {
3404  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3405  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3406  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3407                                                          @_;
3408  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3409                                                  }
3410                                                  
3411                                                  1;
3412                                                  
3413                                                  # ###########################################################################
3414                                                  # End Daemon package
3415                                                  # ###########################################################################
3416                                                  
3417                                                  # ###########################################################################
3418                                                  # QueryExecutor package 4421
3419                                                  # ###########################################################################
3420                                                  package QueryExecutor;
3421                                                  
3422           1                    1             8   use strict;
               1                                  2   
               1                                  7   
3423           1                    1             5   use warnings FATAL => 'all';
               1                                  2   
               1                                  7   
3424                                                  
3425           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  5   
3426           1                    1            12   use Time::HiRes qw(time);
               1                                  4   
               1                                  4   
3427           1                    1             7   use Data::Dumper;
               1                                  2   
               1                                  8   
3428                                                  $Data::Dumper::Indent    = 1;
3429                                                  $Data::Dumper::Sortkeys  = 1;
3430                                                  $Data::Dumper::Quotekeys = 0;
3431                                                  
3432           1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  8   
3433                                                  
3434                                                  sub new {
3435           8                    8            43      my ( $class, %args ) = @_;
3436           8                                 57      foreach my $arg ( qw() ) {
3437  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3438                                                     }
3439           8                                 30      my $self = {};
3440           8                                 62      return bless $self, $class;
3441                                                  }
3442                                                  
3443                                                  sub exec {
3444          16                   16           189      my ( $self, %args ) = @_;
3445          16                                101      foreach my $arg ( qw(query hosts pre_exec_callbacks post_exec_callbacks) ) {
3446  ***     64     50                         330         die "I need a $arg argument" unless $args{$arg};
3447                                                     }
3448          16                                 62      my $query = $args{query};
3449          16                                 60      my $hosts = $args{hosts};
3450          16                                 52      my $pre   = $args{pre_exec_callbacks};
3451          16                                 55      my $post  = $args{post_exec_callbacks};
3452          16                                 55      my $dp    = $args{DSNParser};
3453                                                  
3454          16                                 38      MKDEBUG && _d('Executing query:', $query);
3455                                                  
3456          16                                 40      my @results;
3457          16                                 48      my $hostno = -1;
3458                                                     HOST:
3459          16                                 65      foreach my $host ( @$hosts ) {
3460          32                                104         $hostno++;  # Increment this now because we might not reach loop's end.
3461          32                                140         $results[$hostno] = {};
3462          32                                114         my $results       = $results[$hostno];
3463          32                                134         my $dbh           = $host->{dbh};
3464          32                                120         my $dsn           = $host->{dsn};
3465  ***     32     50     33                  462         my $host_name     = $dp && $dsn ? $dp->as_string($dsn) : $hostno + 1;
3466          32                                299         my %callback_args = (
3467                                                           query     => $query,
3468                                                           dbh       => $dbh,
3469                                                           host_name => $host_name,
3470                                                           results   => $results,
3471                                                        );
3472                                                  
3473          32                                 80         MKDEBUG && _d('Starting execution on host', $host_name);
3474                                                  
3475          32                                147         foreach my $callback ( @$pre ) {
3476          28                                163            my ($name, $res) = $callback->(%callback_args);
3477          28                                238            _check_results($name, $res, $host_name, \@results);
3478          28                                188            $results->{$name} = $res;
3479                                                        }
3480                                                  
3481                                                        {
3482          32                                105            my ($name, $res) = ('Query_time', { error=>undef, Query_time=>-1, });
              32                                226   
3483          32                                119            my ( $start, $end, $query_time );
3484          32                                121            eval {
3485          32                                248               $start = time();
3486          32                               8876               $dbh->do($query);
3487          16                                140               $end   = time();
3488          16                                348               $query_time = sprintf '%.6f', $end - $start;
3489                                                           };
3490          32    100                         193            if ( $EVAL_ERROR ) {
3491          16                                 37               MKDEBUG && _d('Error executing query on host', $hostno+1, ':',
3492                                                                 $EVAL_ERROR);
3493          16                                 91               $res->{error} = $EVAL_ERROR;
3494                                                           }
3495                                                           else {
3496          16                                101               $res->{Query_time} = $query_time;
3497                                                           }
3498          32                                190            _check_results($name, $res, $host_name, \@results);
3499          32                                165            $results->{$name} = $res;
3500                                                        }
3501                                                  
3502          32                                158         foreach my $callback ( @$post ) {
3503          84                                533            my ($name, $res) = $callback->(%callback_args);
3504          84                                517            _check_results($name, $res, $host_name, \@results);
3505          84                                493            $results->{$name} = $res;
3506                                                        }
3507                                                  
3508          32                                198         MKDEBUG && _d('Results for host', $host_name, ':', Dumper($results));
3509                                                     } # HOST
3510                                                  
3511          16                                148      return @results;
3512                                                  }
3513                                                  
3514                                                  sub get_warnings {
3515          28                   28           243      my ( $self, %args ) = @_;
3516          28                                156      foreach my $arg ( qw(dbh) ) {
3517  ***     28     50                         197         die "I need a $arg argument" unless $args{$arg};
3518                                                     }
3519          28                                100      my $dbh   = $args{dbh};
3520          28                                 86      my $error = undef;
3521          28                                 85      my $name  = 'warnings';
3522          28                                 73      MKDEBUG && _d($name);
3523                                                  
3524          28                                 72      my $warnings;
3525          28                                 78      my $warning_count;
3526          28                                 83      eval {
3527          28                                 95         $warnings      = $dbh->selectall_hashref('SHOW WARNINGS', 'Code');
3528          28                                222         $warning_count = $dbh->selectall_arrayref('SELECT @@warning_count',
3529                                                           { Slice => {} });
3530                                                     };
3531  ***     28     50                         261      if ( $EVAL_ERROR ) {
3532  ***      0                                  0         MKDEBUG && _d('Error getting warnings:', $EVAL_ERROR);
3533  ***      0                                  0         $error = $EVAL_ERROR;
3534                                                     }
3535                                                  
3536          28           100                  364      my $results = {
3537                                                        error => $error,
3538                                                        codes => $warnings,
3539                                                        count => $warning_count->[0]->{'@@warning_count'} || 0,
3540                                                     };
3541          28                                246      return $name, $results;
3542                                                  }
3543                                                  
3544                                                  sub clear_warnings {
3545          28                   28           254      my ( $self, %args ) = @_;
3546          28                                165      foreach my $arg ( qw(dbh query QueryParser) ) {
3547  ***     84     50                         439         die "I need a $arg argument" unless $args{$arg};
3548                                                     }
3549          28                                114      my $dbh     = $args{dbh};
3550          28                                105      my $query   = $args{query};
3551          28                                 97      my $qparser = $args{QueryParser};
3552          28                                 92      my $error   = undef;
3553          28                                 91      my $name    = 'clear_warnings';
3554          28                                 70      MKDEBUG && _d($name);
3555                                                  
3556          28                                179      my @tables = $qparser->get_tables($query);
3557  ***     28     50                         135      if ( @tables ) {
3558          28                                 74         MKDEBUG && _d('tables:', @tables);
3559          28                                143         my $sql = "SELECT * FROM $tables[0] LIMIT 0";
3560          28                                 75         MKDEBUG && _d($sql);
3561          28                                 80         eval {
3562          28                               4156            $dbh->do($sql);
3563                                                        };
3564  ***     28     50                         192         if ( $EVAL_ERROR ) {
3565  ***      0                                  0            MKDEBUG && _d('Error clearning warnings:', $EVAL_ERROR);
3566  ***      0                                  0            $error = $EVAL_ERROR;
3567                                                        }
3568                                                     }
3569                                                     else {
3570  ***      0                                  0         $error = "Cannot clear warnings because the tables for this query cannot "
3571                                                           . "be parsed.";
3572                                                     }
3573                                                  
3574          28                                312      return $name, { error=>$error };
3575                                                  }
3576                                                  
3577                                                  sub pre_checksum_results {
3578          28                   28           288      my ( $self, %args ) = @_;
3579          28                                165      foreach my $arg ( qw(dbh database tmp_table Quoter) ) {
3580  ***    112     50                         521         die "I need a $arg argument" unless $args{$arg};
3581                                                     }
3582          28                                110      my $dbh     = $args{dbh};
3583          28                                 98      my $db      = $args{database};
3584          28                                 92      my $tmp_tbl = $args{tmp_table};
3585          28                                 91      my $q       = $args{Quoter};
3586          28                                 77      my $error   = undef;
3587          28                                 79      my $name    = 'pre_checksum_results';
3588          28                                 67      MKDEBUG && _d($name);
3589                                                  
3590          28                                123      my $tmp_db_tbl = $q->quote($db, $tmp_tbl);
3591          28                                 92      eval {
3592          28                              10740         $dbh->do("DROP TABLE IF EXISTS $tmp_db_tbl");
3593          28                               3662         $dbh->do("SET storage_engine=MyISAM");
3594                                                     };
3595  ***     28     50                         175      if ( $EVAL_ERROR ) {
3596  ***      0                                  0         MKDEBUG && _d('Error dropping table', $tmp_db_tbl, ':', $EVAL_ERROR);
3597  ***      0                                  0         $error = $EVAL_ERROR;
3598                                                     }
3599          28                                385      return $name, { error=>$error };
3600                                                  }
3601                                                  
3602                                                  sub checksum_results {
3603          28                   28           346      my ( $self, %args ) = @_;
3604          28                                205      foreach my $arg ( qw(dbh database tmp_table MySQLDump TableParser Quoter) ) {
3605  ***    168     50                         760         die "I need a $arg argument" unless $args{$arg};
3606                                                     }
3607          28                                100      my $dbh     = $args{dbh};
3608          28                                 98      my $db      = $args{database};
3609          28                                 92      my $tmp_tbl = $args{tmp_table};
3610          28                                 97      my $du      = $args{MySQLDump};
3611          28                                 90      my $tp      = $args{TableParser};
3612          28                                 84      my $q       = $args{Quoter};
3613          28                                 85      my $error   = undef;
3614          28                                 92      my @errors  = ();
3615          28                                 81      my $name    = 'checksum_results';
3616          28                                 67      MKDEBUG && _d($name);
3617                                                  
3618          28                                145      my $tmp_db_tbl = $q->quote($db, $tmp_tbl);
3619          28                                 83      my $tbl_checksum;
3620          28                                 69      my $n_rows;
3621          28                                 70      my $tbl_struct;
3622          28                                 80      eval {
3623          28                                 73         $n_rows = $dbh->selectall_arrayref("SELECT COUNT(*) FROM $tmp_db_tbl")->[0]->[0];
3624          14                                 38         $tbl_checksum = $dbh->selectall_arrayref("CHECKSUM TABLE $tmp_db_tbl")->[0]->[1];
3625                                                     };
3626          28    100                        2288      if ( $EVAL_ERROR ) {
3627          14                                 40         MKDEBUG && _d('Error counting rows or checksumming', $tmp_db_tbl, ':',
3628                                                           $EVAL_ERROR);
3629          14                                 54         $error = $EVAL_ERROR;
3630          14                                 61         push @errors, $error;
3631                                                     }
3632                                                     else {
3633          14                                 43         eval {
3634          14                                133            my $ddl = $du->get_create_table($dbh, $q, $db, $tmp_tbl);
3635          14                                 36            MKDEBUG && _d('tmp table ddl:', Dumper($ddl));
3636  ***     14     50                          78            if ( $ddl->[0] eq 'table' ) {
3637          14                                 94               $tbl_struct = $tp->parse($ddl)
3638                                                           }
3639                                                        };
3640  ***     14     50                          92         if ( $EVAL_ERROR ) {
3641  ***      0                                  0            MKDEBUG && _d('Failed to parse', $tmp_db_tbl, ':', $EVAL_ERROR); 
3642  ***      0                                  0            $error = $EVAL_ERROR;
3643  ***      0                                  0            push @errors, $error;
3644                                                        }
3645                                                     }
3646                                                  
3647          28                                124      my $sql = "DROP TABLE IF EXISTS $tmp_db_tbl";
3648          28                                 62      MKDEBUG && _d($sql);
3649          28                                 72      eval { $dbh->do($sql); };
              28                               7287   
3650  ***     28     50                         163      if ( $EVAL_ERROR ) {
3651  ***      0                                  0         MKDEBUG && _d('Error dropping tmp table:', $EVAL_ERROR);
3652  ***      0                                  0         $error = $EVAL_ERROR;
3653  ***      0                                  0         push @errors, $error;
3654                                                     }
3655                                                  
3656          28    100                         271      if ( !defined $n_rows ) { # 0 rows returned is ok.
3657          14                                 52         $error = "SELECT COUNT(*) for getting the number of rows didn't return a value";
3658          14                                 54         push @errors, $error;
3659          14                                 35         MKDEBUG && _d($error);
3660                                                     }
3661          28    100                         132      if ( !$tbl_checksum ) {
3662          14                                 34         $error = "CHECKSUM TABLE didn't return a value";
3663          14                                 50         push @errors, $error;
3664          14                                 32         MKDEBUG && _d($error);
3665                                                     }
3666                                                  
3667  ***     28     50                         136      @errors = () if @errors == 1;
3668                                                  
3669          28           100                  469      my $results = {
                           100                        
3670                                                        error        => $error,
3671                                                        errors       => \@errors,
3672                                                        checksum     => $tbl_checksum || 0,
3673                                                        n_rows       => $n_rows || 0,
3674                                                        table_struct => $tbl_struct,
3675                                                     };
3676          28                                317      return $name, $results;
3677                                                  }
3678                                                  
3679                                                  sub _check_results {
3680         144                  144           809      my ( $name, $res, $host_name, $all_res ) = @_;
3681  ***    144     50                         666      _die_bad_op('Operation did not return a name!', @_)
3682                                                        unless $name;
3683  ***    144     50     50                  768      _die_bad_op('Operation did not return any results!', @_)
3684                                                        unless $res || (scalar keys %$res);
3685  ***    144     50                         692      _die_bad_op("Operation results do no have an 'error' key")
3686                                                        unless exists $res->{error};
3687  ***    144     50     66                 1050      _die_bad_op("Operation error is blank string!")
3688                                                        if defined $res->{error} && !$res->{error};
3689  ***    144     50     66                 1030      _die_bad_op("Operation errors is not an arrayref!")
3690                                                        if $res->{errors} && ref $res->{errors} ne 'ARRAY';
3691         144                                444      return;
3692                                                  }
3693                                                  
3694                                                  sub _die_bad_op {
3695  ***      0                    0             0      my ( $msg, $name, $res, $host_name, $all_res ) = @_;
3696  ***      0      0                           0      die "$msg\n"
3697                                                        . "Host name: " . ($host_name ? $host_name : 'UNKNOWN') . "\n"
3698                                                        . "Current results: " . Dumper($res)
3699                                                        . "Prior results: "   . Dumper($all_res)
3700                                                  }
3701                                                  
3702                                                  sub _d {
3703  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3704  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3705  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3706                                                          @_;
3707  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3708                                                  }
3709                                                  
3710                                                  1;
3711                                                  
3712                                                  # ###########################################################################
3713                                                  # End QueryExecutor package
3714                                                  # ###########################################################################
3715                                                  
3716                                                  # ###########################################################################
3717                                                  # QueryRanker package 4422
3718                                                  # ###########################################################################
3719                                                  package QueryRanker;
3720                                                  
3721                                                  
3722           1                    1             7   use strict;
               1                                  3   
               1                                  6   
3723           1                    1             7   use warnings FATAL => 'all';
               1                                  2   
               1                                  6   
3724                                                  
3725           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  6   
3726           1                    1             7   use POSIX qw(floor);
               1                                  2   
               1                                  6   
3727                                                  
3728           1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  6   
3729                                                  
3730                                                  my @bucket_threshold = qw(500 100  100   500 50   50    20 1   );
3731                                                  my @bucket_labels    = qw(1us 10us 100us 1ms 10ms 100ms 1s 10s+);
3732                                                  
3733                                                  my %ranker_for = (
3734                                                     Query_time       => \&rank_query_times,
3735                                                     warnings         => \&rank_warnings,
3736                                                     checksum_results => \&rank_result_sets,
3737                                                  );
3738                                                  
3739                                                  sub new {
3740           8                    8            47      my ( $class, %args ) = @_;
3741           8                                 47      foreach my $arg ( qw() ) {
3742  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3743                                                     }
3744           8                                 30      my $self = {
3745                                                     };
3746           8                                 59      return bless $self, $class;
3747                                                  }
3748                                                  
3749                                                  sub rank_results {
3750          16                   16            90      my ( $self, @results ) = @_;
3751  ***     16     50                          88      return unless @results > 1;
3752                                                  
3753          16                                 50      my $rank           = 0;
3754          16                                 54      my @reasons        = ();
3755          16                                 61      my $master_results = shift @results;
3756                                                  
3757                                                     RESULTS:
3758          16                                124      foreach my $results ( keys %$master_results ) {
3759          72                                268         my $compare = $ranker_for{$results};
3760          72    100                         292         if ( !$compare ) {
3761          28                                 67            MKDEBUG && _d('No ranker for', $results);
3762          28                                108            next RESULTS;
3763                                                        }
3764                                                  
3765          44                                155         my $master = $master_results->{$results};
3766                                                  
3767          44                                116         HOST:
3768                                                        my $i = 1;  # host1/i=1 is master so...
3769          44                                150         foreach my $host_results ( @results ) {
3770          44                                122            $i++; # ...we start with host2/i=2
3771  ***     44     50                         197            if ( !exists $host_results->{$results} ) {
3772  ***      0                                  0               warn "Host$i doesn't have $results results";
3773  ***      0                                  0               next HOST;
3774                                                           }
3775                                                  
3776          44                                148            my $host = $host_results->{$results};
3777                                                  
3778          44                                251            my @res = $compare->($self, $master, $host);
3779          44                                146            $rank += shift @res;
3780          44                                249            push @reasons, @res;
3781                                                        } 
3782                                                     }
3783                                                  
3784          16                                128      return $rank, @reasons;
3785                                                  }
3786                                                  
3787                                                  sub rank_query_times {
3788          16                   16            84      my ( $self, $host1, $host2 ) = @_;
3789          16                                 52      my $rank    = 0;   # total rank
3790          16                                 50      my @reasons = ();  # all reasons
3791          16                                 51      my @res     = ();  # ($rank, @reasons) for each comparison
3792                                                  
3793          16    100                         108      if ( $host1->{Query_time} == -1 ) {
3794           8                                 26         $rank += 100;
3795  ***      8            50                   65         push @reasons, 'Query failed to execute on host1: '
3796                                                              . ($host1->{error} || 'unknown error')
3797                                                              . " (rank+100)";
3798                                                     }
3799          16    100                          95      if ( $host2->{Query_time} == -1 ) {
3800           8                                 24         $rank += 100;
3801  ***      8            50                   56         push @reasons, 'Query failed to execute on host2: '
3802                                                              . ($host2->{error} || 'unknown error')
3803                                                              . " (rank+100)";
3804                                                     }
3805                                                  
3806  ***     16    100     66                  169      if ( $host1->{Query_time} >= 0 && $host2->{Query_time} >= 0 ) {
3807           8                                 70         @res = $self->compare_query_times(
3808                                                           $host1->{Query_time}, $host2->{Query_time});
3809           8                                 31         $rank += shift @res;
3810           8                                 30         push @reasons, @res;
3811                                                     }
3812                                                  
3813          16                                 96      return $rank, @reasons;
3814                                                  }
3815                                                  
3816                                                  sub rank_warnings {
3817          14                   14            68      my ( $self, $host1, $host2 ) = @_;
3818          14                                 49      my $rank    = 0;   # total rank
3819          14                                 45      my @reasons = ();  # all reasons
3820          14                                 48      my @res     = ();  # ($rank, @reasons) for each comparison
3821                                                  
3822  ***     14    100     66                  159      if ( $host1->{count} > 0 || $host2->{count} > 0 ) {
3823           7                                 31         $rank += 1;
3824           7                                 38         push @reasons, "Query has warnings (rank+1)";
3825                                                     }
3826                                                  
3827  ***     14     50                         107      if ( my $diff = abs($host1->{count} - $host2->{count}) ) {
3828  ***      0                                  0         $rank += $diff;
3829  ***      0                                  0         push @reasons, "Warning counts differ by $diff (rank+$diff)";
3830                                                     }
3831                                                  
3832          14                                139      @res = $self->compare_warnings($host1->{codes}, $host2->{codes});
3833          14                                 48      $rank += shift @res;
3834          14                                 47      push @reasons, @res;
3835                                                  
3836          14                                 73      return $rank, @reasons;
3837                                                  }
3838                                                  
3839                                                  sub compare_query_times {
3840           8                    8            45      my ( $self, $t1, $t2 ) = @_;
3841  ***      8     50                          40      die "I need a t1 argument" unless defined $t1;
3842  ***      8     50                          32      die "I need a t2 argument" unless defined $t2;
3843                                                  
3844           8                                 22      MKDEBUG && _d('host1 query time:', $t1, 'host2 query time:', $t2);
3845                                                  
3846           8                                 45      my $t1_bucket = bucket_for($t1);
3847           8                                 79      my $t2_bucket = bucket_for($t2);
3848                                                  
3849           8    100                          42      if ( $t1_bucket != $t2_bucket ) {
3850           1                                  4         my $rank_inc = 2 * abs($t1_bucket - $t2_bucket);
3851           1                                 12         return $rank_inc, "Query times differ significantly: "
3852                                                           . "host1 in ".$bucket_labels[$t1_bucket]." range, "
3853                                                           . "host2 in ".$bucket_labels[$t2_bucket]." range (rank+2)";
3854                                                     }
3855                                                  
3856           7                                 59      my $inc = percentage_increase($t1, $t2);
3857  ***      7     50                          62      if ( $inc >= $bucket_threshold[$t1_bucket] ) {
3858  ***      0                                  0         return 1, "Query time increase $inc\% exceeds "
3859                                                           . $bucket_threshold[$t1_bucket] . "\% increase threshold for "
3860                                                           . $bucket_labels[$t1_bucket] . " range (rank+1)";
3861                                                     }
3862                                                  
3863           7                                 43      return (0);  # No significant difference.
3864                                                  }
3865                                                  
3866                                                  sub compare_warnings {
3867          14                   14            70      my ( $self, $warnings1, $warnings2 ) = @_;
3868  ***     14     50                          68      die "I need a warnings1 argument" unless defined $warnings1;
3869  ***     14     50                          71      die "I need a warnings2 argument" unless defined $warnings2;
3870                                                  
3871          14                                 35      my %new_warnings;
3872          14                                 44      my $rank_inc = 0;
3873          14                                 38      my @reasons;
3874                                                  
3875          14                                 89      foreach my $code ( keys %$warnings1 ) {
3876  ***      7     50                          37         if ( exists $warnings2->{$code} ) {
3877  ***      7     50                          63            if ( $warnings2->{$code}->{Level} ne $warnings1->{$code}->{Level} ) {
3878  ***      0                                  0               $rank_inc += 2;
3879  ***      0                                  0               push @reasons, "Error $code changes level: "
3880                                                                 . $warnings1->{$code}->{Level} . " on host1, "
3881                                                                 . $warnings2->{$code}->{Level} . " on host2 (rank+2)";
3882                                                           }
3883                                                        }
3884                                                        else {
3885  ***      0                                  0            MKDEBUG && _d('New warning on host1:', $code);
3886  ***      0                                  0            push @reasons, "Error $code on host1 is new (rank+3)";
3887  ***      0                                  0            %{ $new_warnings{$code} } = %{ $warnings1->{$code} };
      ***      0                                  0   
      ***      0                                  0   
3888                                                        }
3889                                                     }
3890                                                  
3891          14                                 78      foreach my $code ( keys %$warnings2 ) {
3892  ***      7     50     33                   57         if ( !exists $warnings1->{$code} && !exists $new_warnings{$code} ) {
3893  ***      0                                  0            MKDEBUG && _d('New warning on host2:', $code);
3894  ***      0                                  0            push @reasons, "Error $code on host2 is new (rank+3)";
3895  ***      0                                  0            %{ $new_warnings{$code} } = %{ $warnings2->{$code} };
      ***      0                                  0   
      ***      0                                  0   
3896                                                        }
3897                                                     }
3898                                                  
3899          14                                 70      $rank_inc += 3 * scalar keys %new_warnings;
3900                                                  
3901                                                  
3902          14                                 80      return $rank_inc, @reasons;
3903                                                  }
3904                                                  
3905                                                  sub rank_result_sets {
3906          14                   14            76      my ( $self, $host1, $host2 ) = @_;
3907          14                                 47      my $rank    = 0;   # total rank
3908          14                                 44      my @reasons = ();  # all reasons
3909          14                                 43      my @res     = ();  # ($rank, @reasons) for each comparison
3910                                                  
3911  ***     14     50                          86      if ( $host1->{checksum} ne $host2->{checksum} ) {
3912  ***      0                                  0         $rank += 50;
3913  ***      0                                  0         push @reasons, "Table checksums do not match (rank+50)";
3914                                                     }
3915                                                  
3916  ***     14     50                         100      if ( $host1->{n_rows} != $host2->{n_rows} ) {
3917  ***      0                                  0         $rank += 50;
3918  ***      0                                  0         push @reasons, "Number of rows do not match (rank+50)";
3919                                                     }
3920                                                  
3921  ***     14    100     66                  132      if ( $host1->{table_struct} && $host2->{table_struct} ) {
3922           7                                 57         @res = $self->compare_table_structs(
3923                                                           $host1->{table_struct},
3924                                                           $host2->{table_struct}
3925                                                        );
3926           7                                 23         $rank += shift @res;
3927           7                                 23         push @reasons, @res;
3928                                                     }
3929                                                     else {
3930           7                                 24         $rank += 10;
3931           7                                 26         push @reasons, 'The temporary tables could not be parsed (rank+10)';
3932                                                     }
3933                                                  
3934          14                                 64      return $rank, @reasons;
3935                                                  }
3936                                                  
3937                                                  sub compare_table_structs {
3938           7                    7            30      my ( $self, $s1, $s2 ) = @_;
3939  ***      7     50                          30      die "I need a s1 argument" unless defined $s1;
3940  ***      7     50                          30      die "I need a s2 argument" unless defined $s2;
3941                                                  
3942           7                                 21      my $rank_inc = 0;
3943           7                                 21      my @reasons  = ();
3944                                                  
3945  ***      7     50                          20      if ( scalar @{$s1->{cols}} != scalar @{$s2->{cols}} ) {
               7                                 32   
               7                                 39   
3946  ***      0                                  0         my $inc = 2 * abs( scalar @{$s1->{cols}} - scalar @{$s2->{cols}} );
      ***      0                                  0   
      ***      0                                  0   
3947  ***      0                                  0         $rank_inc += $inc;
3948  ***      0                                  0         push @reasons, 'Tables have different columns counts: '
3949  ***      0                                  0            . scalar @{$s1->{cols}} . ' columns on host1, '
3950  ***      0                                  0            . scalar @{$s2->{cols}} . " columns on host2 (rank+$inc)";
3951                                                     }
3952                                                  
3953           7                                 21      my %host1_missing_cols = %{$s2->{type_for}};  # Make a copy to modify.
               7                                 73   
3954           7                                 26      my @host2_missing_cols;
3955           7                                 21      foreach my $col ( keys %{$s1->{type_for}} ) {
               7                                 56   
3956  ***     21     50                          93         if ( exists $s2->{type_for}->{$col} ) {
3957  ***     21     50                         125            if ( $s1->{type_for}->{$col} ne $s2->{type_for}->{$col} ) {
3958  ***      0                                  0               $rank_inc += 3;
3959  ***      0                                  0               push @reasons, "Types for $col column differ: "
3960                                                                 . "'$s1->{type_for}->{$col}' on host1, "
3961                                                                 . "'$s2->{type_for}->{$col}' on host2 (rank+3)";
3962                                                           }
3963          21                                 86            delete $host1_missing_cols{$col};
3964                                                        }
3965                                                        else {
3966  ***      0                                  0            push @host2_missing_cols, $col;
3967                                                        }
3968                                                     }
3969                                                  
3970           7                                 34      foreach my $col ( @host2_missing_cols ) {
3971  ***      0                                  0         $rank_inc += 5;
3972  ***      0                                  0         push @reasons, "Column $col exists on host1 but not on host2 (rank+5)";
3973                                                     }
3974           7                                 33      foreach my $col ( keys %host1_missing_cols ) {
3975  ***      0                                  0         $rank_inc += 5;
3976  ***      0                                  0         push @reasons, "Column $col exists on host2 but not on host1 (rank+5)";
3977                                                     }
3978                                                  
3979           7                                 37      return $rank_inc, @reasons;
3980                                                  }
3981                                                  
3982                                                  sub bucket_for {
3983          16                   16            64      my ( $val ) = @_;
3984  ***     16     50                          74      die "I need a val" unless defined $val;
3985  ***     16     50                          72      return 0 if $val == 0;
3986          16                                169      my $bucket = floor(log($val) / log(10)) + 6;
3987  ***     16     50                          90      $bucket = $bucket > 7 ? 7 : $bucket < 0 ? 0 : $bucket;
      ***            50                               
3988          16                                 59      return $bucket;
3989                                                  }
3990                                                  
3991                                                  sub percentage_increase {
3992           7                    7            37      my ( $x, $y ) = @_;
3993  ***      7     50                          36      return 0 if $x == $y;
3994                                                  
3995           7    100                          35      if ( $x > $y ) {
3996           6                                 20         my $z = $y;
3997           6                                 19            $y = $x;
3998           6                                 21            $x = $z;
3999                                                     }
4000                                                  
4001  ***      7     50                          40      if ( $x == 0 ) {
4002  ***      0                                  0         return 1000;  # This should trigger all buckets' thresholds.
4003                                                     }
4004                                                  
4005           7                                126      return sprintf '%.2f', (($y - $x) / $x) * 100;
4006                                                  }
4007                                                  
4008                                                  sub _d {
4009  ***      0                    0             0      my ($package, undef, $line) = caller 0;
4010  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
4011  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
4012                                                          @_;
4013  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4014                                                  }
4015                                                  
4016                                                  1;
4017                                                  
4018                                                  # ###########################################################################
4019                                                  # End QueryRanker package
4020                                                  # ###########################################################################
4021                                                  
4022                                                  # ###########################################################################
4023                                                  # This is a combination of modules and programs in one -- a runnable module.
4024                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
4025                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
4026                                                  #
4027                                                  # Check at the end of this package for the call to main() which actually runs
4028                                                  # the program.
4029                                                  # ###########################################################################
4030                                                  package mk_upgrade;
4031                                                  
4032           1                    1             9   use English qw(-no_match_vars);
               1                                  2   
               1                                  7   
4033                                                  
4034           1                    1             6   use Data::Dumper;
               1                                  3   
               1                                  6   
4035                                                  $Data::Dumper::Indent    = 1;
4036                                                  $Data::Dumper::Sortkeys  = 1;
4037                                                  $Data::Dumper::Quotekeys = 0;
4038                                                  
4039                                                  Transformers->import(qw());
4040                                                  
4041           1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  7   
4042                                                  
4043           1                    1            16   use sigtrap 'handler', \&sig_int, 'normal-signals';
               1                                  3   
               1                                 14   
4044                                                  
4045                                                  # Global variables.  Only really essential variables should be here.
4046                                                  my $oktorun = 1;
4047                                                  
4048                                                  sub main {
4049           8                    8           122      @ARGV = @_;  # set global ARGV for this package
4050                                                  
4051                                                     # ##########################################################################
4052                                                     # Get configuration information.
4053                                                     # ##########################################################################
4054           8                                170      my $dp = new DSNParser();
4055           8                                184      my $o  = new OptionParser(
4056                                                        strict      => 0,
4057                                                        dp          => $dp,
4058                                                        prompt      => '[OPTION...] HOST-1-DSN HOST-2-DSN FILE',
4059                                                        description => q{compares two hosts by executing queries in the given }
4060                                                                     . q{file (or STDIN if no file given) and examining the }
4061                                                                     . q{results, errors, warnings, etc. produced on each.},
4062                                                     );
4063           8                                 50      $o->get_specs();
4064           8                                 90      $o->get_opts();
4065                                                  
4066  ***      8     50                          44      if ( !$o->get('help') ) {
4067  ***      8     50                          41         if ( @ARGV < 2 ) {
4068  ***      0                                  0            $o->save_error('Specify at least two host DSNs');
4069                                                        }
4070                                                     }
4071                                                  
4072           8    100                          36      $o->set('all-errors', 0) unless $o->get('errors');
4073                                                  
4074           8                                 76      $o->usage_or_errors();
4075                                                  
4076                                                     # ########################################################################
4077                                                     # Parse the host DSNs and make sure that we can connect to each.
4078                                                     # ########################################################################
4079           8                                100      my $host1_dsn = $dp->parse(shift @ARGV);
4080           8                                 74      my $host1_dbh = get_cxn($dp, $o, $host1_dsn);
4081           8                                 58      my $host2_dsn = $dp->parse(shift @ARGV, $host1_dsn);
4082           8                                 47      my $host2_dbh = get_cxn($dp, $o, $host2_dsn);
4083           8                                 91      my $hosts     = [
4084                                                        {
4085                                                           dbh => $host1_dbh,
4086                                                           dsn => $host1_dsn,
4087                                                        },
4088                                                        {
4089                                                           dbh => $host2_dbh,
4090                                                           dsn => $host2_dsn,
4091                                                        },
4092                                                     ];
4093                                                  
4094                                                     # ########################################################################
4095                                                     # Make some common modules.
4096                                                     # ########################################################################
4097           8                                158      my $parser  = new SlowLogParser();
4098           8                                157      my $qparser = new QueryParser();
4099           8                                132      my $qexec   = new QueryExecutor();
4100           8                                135      my $qranker = new QueryRanker();
4101                                                  
4102                                                     # ########################################################################
4103                                                     # Set up an array of callbacks to transform, filter and process events.
4104                                                     # Results are saved in %results and compared and reported after all
4105                                                     # events have been processed.
4106                                                     # ########################################################################
4107           8                                 21      my @callbacks;
4108           8                                 22      my %results;
4109                                                  
4110                                                     # For the moment we only support deterministic SELECT queries.
4111                                                     # There's no filter/transformation for non-deterministic functions yet,
4112                                                     # just a simple filter to remove non-SELECTs.
4113                                                     # TODO: this will become QueryFilter.
4114                                                     push @callbacks, sub {
4115          16                   16            70         my ( $event ) = @_;
4116  ***     16     50                          93         return unless $event->{cmd} eq 'Query';
4117  ***     16     50                          81         return unless $event->{arg};
4118  ***     16     50                         119         if ( $event->{arg} =~ m/(?:^SELECT|(?:\*\/\s*SELECT))/i ) {
4119          16                                 97            return $event; # Query passes.
4120                                                        }
4121  ***      0                                  0         MKDEBUG && _d('Not a SELECT query');
4122  ***      0                                  0         return;  # Query fails.
4123           8                                123      };
4124                                                  
4125                                                     # User-defined filter.
4126  ***      8     50                          58      if ( $o->get('filter') ) {
4127  ***      0                                  0         my $filter = $o->get('filter');
4128  ***      0                                  0         my $code   = "sub { my (\$event) = shift; $filter && return \$event; };";
4129  ***      0                                  0         MKDEBUG && _d('--filter code:', $code);
4130  ***      0      0                           0         my $sub = eval $code or die;
4131  ***      0                                  0         push @callbacks, $sub;
4132                                                     }
4133                                                  
4134                                                     # Now we should have only the queries that we want, and they should
4135                                                     # have all appropriate transformations.  The real work begins here.
4136                                                  
4137           8                                 25      my $current_db;
4138                                                     push @callbacks, sub {
4139          16                   16            62         my ( $event ) = @_;
4140          16                                 69         my $db = $event->{db}; 
4141  ***     16    100     66                  221         if ( $db && (!$current_db || $db ne $current_db) ) {
      ***                   66                        
4142           8                                 26            eval {
4143           8                               9564               $host1_dbh->do("USE $db");
4144           8                                880               $host2_dbh->do("USE $db");  
4145                                                           };
4146  ***      8     50                          50            if ( $EVAL_ERROR ) {
4147  ***      0                                  0               warn "Failed to USE $db: $EVAL_ERROR";
4148                                                           }
4149                                                           else {
4150           8                                 27               $current_db  = $db;
4151           8                                 25               MKDEBUG && _d('USE', $db);
4152                                                           }
4153                                                        }
4154          16                                112         return $event;
4155           8                                112      };
4156                                                  
4157                                                     # Create pre- and post-QueryExecutor::exec() callbacks for each comparison.
4158                                                     # These subs return to QueryExecutor::exec(), not mk-upgrade.  exec()
4159                                                     # returns a list of each host's results to mk-upgrade.
4160           8                                 40      my $tmp_tbl_db = $o->get('tmp-table-database');
4161           8                                 21      my $tmp_tbl_wrap;
4162           8                                 22      my @pre_qe_callbacks;
4163           8                                 21      my @post_qe_callbacks;
4164                                                  
4165           8    100                          37      if ( $o->get('compare-warnings') ) {
4166           7                   28            69         push @post_qe_callbacks, sub { return $qexec->get_warnings(@_); };
              28                                195   
4167           7                   28            64         push @post_qe_callbacks, sub { return $qexec->clear_warnings(@_, QueryParser => $qparser); };
              28                                189   
4168                                                     }
4169                                                  
4170           8    100                          44      if ( $o->get('compare-results') ) {
4171           7                                 28         my $tmp_tbl = 'mk_upgrade';
4172           7                                117         my $du      = new MySQLDump();
4173           7                                111         my $tp      = new TableParser();
4174           7                                 97         my $q       = new Quoter();
4175                                                  
4176                                                        # One thing exec() won't do is prepend "CREATE TEMPORARY TABLE ... AS"
4177                                                        # to the query.  We must do this.  This is a mk-upgrade callback sub.
4178                                                        push @callbacks, sub {
4179          14                   14            59            my ( $event ) = @_;
4180          14                                 64            my $query = $event->{arg};
4181  ***     14     50                          54            return unless $query;
4182  ***     14            33                  187            my $tmp_db_tbl = $q->quote($tmp_tbl_db || $current_db, $tmp_tbl);
4183          14                                 72            $tmp_tbl_wrap = "CREATE TEMPORARY TABLE $tmp_db_tbl AS ";
4184          14                                 66            $event->{arg} = "$tmp_tbl_wrap$query";
4185          14                                 86            return $event;
4186           7                                 93         };
4187                                                  
4188                                                        # This drops the tmp table and sets the default engine to MyISAM.
4189                                                        # NOTE: This return to QueryExecutor::exec(), not mk-upgrade.
4190                                                        push @pre_qe_callbacks, sub {
4191  ***     28            33     28           374            return $qexec->pre_checksum_results(
4192                                                              @_,
4193                                                              database  => $tmp_tbl_db || $current_db,
4194                                                              tmp_table => $tmp_tbl,
4195                                                              Quoter    => $q,
4196                                                           );
4197           7                                605         };
4198                                                  
4199                                                        # NOTE: This return to QueryExecutor::exec(), not mk-upgrade.
4200                                                        push @post_qe_callbacks, sub {
4201  ***     28            33     28           420            return $qexec->checksum_results(
4202                                                              @_,
4203                                                              database    => $tmp_tbl_db || $current_db,
4204                                                              tmp_table   => $tmp_tbl,
4205                                                              Quoter      => $q,
4206                                                              TableParser => $tp,
4207                                                              MySQLDump   => $du,
4208                                                           );
4209           7                                 85         };
4210                                                     }
4211                                                  
4212                                                     # This is the main mk-upgrade callback which calls QueryExecutor::exec().
4213                                                     # This callback gets the results and passes them to the next callback
4214                                                     # which will rank them.
4215                                                     push @callbacks, sub {
4216          16                   16            67         my ( $event ) = @_;
4217          16                                 66         my $query = $event->{arg};
4218          16                                 61         eval {
4219          16                                140            my @results = $qexec->exec(
4220                                                              query                => $query,
4221                                                              hosts                => $hosts,
4222                                                              DSNParser            => $dp,
4223                                                              pre_exec_callbacks   => \@pre_qe_callbacks,
4224                                                              post_exec_callbacks  => \@post_qe_callbacks,
4225                                                           );
4226                                                  
4227          16                                 95            $event->{results} = \@results;
4228                                                        };
4229  ***     16     50                          80         if ( $EVAL_ERROR ) {
4230                                                           # This shouldn't happen because QueryExecutor operations are supposed
4231                                                           # to eval everything they do and capture all their own errors.
4232  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR, Dumper($event));
4233  ***      0                                  0            print "The query executor failed to execute this query:\n"
4234                                                              . "$query\n"
4235                                                              . "Error: $EVAL_ERROR";
4236  ***      0                                  0            return;
4237                                                        }
4238                                                  
4239          16                                120         return $event;
4240           8                                105      };
4241                                                  
4242           8    100                          40      if ( $o->get('compare-results') ) {
4243                                                        push @callbacks, sub {
4244          14                   14            59            my ( $event ) = @_;
4245          14                                 64            my $query = $event->{arg};
4246          14                                162            $query =~ s/^$tmp_tbl_wrap//;
4247          14                                 58            $event->{arg} = $query;
4248          14                                 81            return $event;
4249           7                                 62         };
4250                                                     }
4251                                                  
4252                                                     # Rank and save the query's results from the previous callback.
4253                                                     # After all queries have been executed and ranked, they will be
4254                                                     # sorted and reported by rank.  For now we save the whole event,
4255                                                     # but later when we do aggregation this will cost too much memory.
4256           8                                 29      my @events;
4257                                                     push @callbacks, sub {
4258          16                   16            70         my ( $event ) = @_;
4259          16                                 65         my $results = $event->{results};
4260  ***     16     50                          68         die "Got an event without results" unless $results;
4261                                                  
4262          16                                 51         eval {
4263          16                                147            my ($rank, @reasons) = $qranker->rank_results(@$results); 
4264          16                                 81            $event->{rank}    = $rank;
4265          16                                118            $event->{reasons} = \@reasons;
4266          16                                 77            push @events, $event;
4267                                                        };
4268  ***     16     50                          74         if ( $EVAL_ERROR ) {
4269                                                           # This really should not happen.
4270  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR, Dumper($event));
4271  ***      0                                  0            print "An unexpected error occurred while ranking the "
4272                                                              . "query's results: $EVAL_ERROR";
4273  ***      0                                  0            return;
4274                                                        }
4275                                                  
4276          16                                110         return $event;
4277           8                                 78      };
4278                                                  
4279                                                     # ########################################################################
4280                                                     # Daemonize now that everything is setup and ready to work.
4281                                                     # ########################################################################
4282           8                                 22      my $daemon;
4283  ***      8     50                          37      if ( $o->get('daemonize') ) {
4284  ***      0                                  0         $daemon = new Daemon(o=>$o);
4285  ***      0                                  0         $daemon->daemonize();
4286  ***      0                                  0         MKDEBUG && _d('I am a daemon now');
4287                                                     }
4288                                                  
4289                                                     # ##########################################################################
4290                                                     # Parse input and process events.
4291                                                     # ##########################################################################
4292  ***      8     50                          55      if ( @ARGV == 0 ) {
4293  ***      0                                  0         MKDEBUG && _d('Reading STDIN');
4294  ***      0                                  0         push @ARGV, '-'; # Magical STDIN filename.
4295                                                     }
4296                                                  
4297           8                                 35      my $start = time();
4298  ***      8            50                   33      my $end   = $start + ($o->get('run-time') || 0); # When we should exit
4299           8                                 25      my $now   = $start;
4300                                                  
4301                                                     FILE:
4302  ***      8            33                  162      while (                                 # Quit if:
      ***                   33                        
      ***                   66                        
4303                                                        $oktorun                             # instructed to quit
4304                                                        && ($start == $end || $now < $end)   # or time is exceeded
4305                                                        && @ARGV )                           # or there's no more files
4306                                                     {
4307           8                                 34         my $file = shift @ARGV;
4308           8                                 24         MKDEBUG && _d('Parsing', $file);
4309           8                                 21         my $fh;
4310  ***      8     50                          38         if ( $file eq '-' ) {
4311  ***      0                                  0            $fh = *STDIN;
4312                                                        }
4313                                                        else {
4314  ***      8     50                         339            if ( !open $fh, "<", $file ) {
4315  ***      0                                  0               warn "Cannot open $file: $OS_ERROR";
4316  ***      0                                  0               next FILE;
4317                                                           }
4318                                                        }
4319                                                  
4320           8                                 26         my $events;
4321                                                        EVENT:
4322  ***      8            33                   97         while ( $oktorun
      ***                   33                        
4323                                                                && ($start == $end || $now < $end) ) {
4324          24                                 76            eval {
4325          24                                175               $events = $parser->parse_event($fh, undef, @callbacks);
4326                                                           };
4327  ***     24     50                         101            if ( $EVAL_ERROR ) {
4328  ***      0                                  0               _d($EVAL_ERROR);
4329                                                              # Don't ignore failure to open a file, else we'll get
4330                                                              # "tell() on closed filehandle" errors.
4331  ***      0      0                           0               last EVENT if $EVAL_ERROR =~ m/Cannot open/;
4332  ***      0      0                           0               last EVENT unless $o->get('continue-on-error');
4333                                                           }
4334          24    100                         100            last EVENT unless $events;
4335          16                                247            $now = time();
4336                                                        }
4337                                                  
4338           8                                 89         close $fh;
4339           8                                 27         $now = time();
4340                                                     }
4341                                                  
4342                                                     # ######################################################################
4343                                                     # Report results.
4344                                                     # ######################################################################
4345                                                     QUERY:
4346           8                                 17      foreach my $event ( sort { $b->{rank} <=> $a->{rank} } @events ) {
               8                                 43   
4347          16                                108         my $query         = $event->{arg};
4348          16                                 71         my $host1_results = $event->{results}->[0];
4349          16                                 66         my $host2_results = $event->{results}->[1];
4350                                                  
4351  ***     16     50                          85         if ( $o->get('dump-results') ) {
4352  ***      0                                  0            print Dumper($event->{results});
4353  ***      0                                  0            next QUERY;
4354                                                        }
4355                                                  
4356          16                                114         print "# Rank: $event->{rank}\n";
4357                                                  
4358          16                                 74         my $t1 = $host1_results->{Query_time}->{Query_time};
4359          16                                 64         my $t2 = $host1_results->{Query_time}->{Query_time};
4360          16    100                         270         printf "# Host1_Query_time: %.6f  Host2_Query_time: %.6f\n",
                    100                               
4361                                                           ($t1 >= 0 ? $t1 : 0),  # Query_time may be -1 if the query failed to
4362                                                           ($t2 >= 0 ? $t2 : 0);  # execute.  Make it 0 though to print pretty.
4363                                                  
4364          16    100                          72         if ( $o->get('compare-warnings') ) {
4365          14                                132            printf "# Host1_Warning_count: %d  Host2_Warning_count: %d\n",
4366                                                              $host1_results->{warnings}->{count},
4367                                                              $host2_results->{warnings}->{count};
4368                                                        }
4369                                                  
4370          16    100                          70         if ( $o->get('compare-results') ) {
4371          14                                127            printf "# Host1_Resultset_checksum: %d  Host2_Resultset_checksum: %d\n",
4372                                                              $host1_results->{checksum_results}->{checksum},
4373                                                              $host2_results->{checksum_results}->{checksum};
4374          14                                 99            printf "# Host1_Resultset_rows: %d  Host2_Resultset_rows: %d\n",
4375                                                              $host1_results->{checksum_results}->{n_rows},
4376                                                              $host2_results->{checksum_results}->{n_rows};
4377                                                        }
4378                                                  
4379                                                        # Print errors and reasons in a /* comment block */ before the query.
4380          16    100    100                   73         if ( $o->get('reasons') || $o->get('errors') ) {
4381          14                                 49            print "/*\n";
4382          14    100                          55            print_errors($event->{results}, $o->get('all-errors'))
4383                                                              if $o->get('errors');
4384          14    100                          63            print_reasons($event->{reasons})
4385                                                              if $o->get('reasons');
4386          14                                 49            print "*/\n";
4387                                                        }
4388                                                  
4389          16                                 83         print "$query\n";
4390                                                     }
4391                                                  
4392           8                               1295      $host1_dbh->disconnect();
4393           8                                600      $host2_dbh->disconnect();
4394           8                               2482      return 0;
4395                                                  
4396                                                  } # End main().
4397                                                  
4398                                                  # ############################################################################
4399                                                  # Subroutines.
4400                                                  # ############################################################################
4401                                                  sub print_errors {
4402          12                   12            52      my ( $results, $all ) = @_;
4403          12                                 36      my $n_errors = 0;
4404                                                  
4405          12                                 41      print "ERRORS: ";
4406          12                                 66      for my $i ( 1..(scalar @$results) ) {
4407          24                                 95         my $hostname = "Host$i";
4408                                                  
4409                                                        # Each element is a hashref of operation results, and each op
4410                                                        # result should have an error key and maybe an errors arrayref.
4411          24                                 96         my $ops = $results->[$i - 1]; 
4412                                                  
4413          24                                135         foreach my $op ( keys %$ops ) {
4414         104                                352            my $op_res = $ops->{$op};
4415         104                                336            my $last_error = $op_res->{error};
4416         104    100                         373            if ( $last_error ) {
4417          22                                 66               chomp $last_error;  # Usually an $EVAL_ERROR that has a \n already.
4418          22                                117               print "\n\n$hostname $op Last_error: $last_error\n";
4419          22                                 63               $n_errors++;
4420                                                           }
4421         104    100    100                  791            if ( $all && $op_res->{errors} && scalar @{$op_res->{errors}} ) {
               4           100                   27   
4422           2                                  6               for my $j ( 1..(scalar @{$op_res->{errors}}) ) {
               2                                 10   
4423           6                                 27                  my $error = $op_res->{errors}->[$j-1];
4424           6                                 14                  chomp $error;
4425           6                                 32                  print "Error_$j: $error\n";
4426                                                              }
4427                                                           }
4428                                                        }
4429                                                     }
4430          12    100                          60      print '', ($n_errors ? "\n" : "None\n\n");
4431                                                  
4432          12                                 38      return;
4433                                                  }
4434                                                  sub print_reasons {
4435          12                   12            46      my ( $reasons ) = @_;
4436          12                                 45      print "REASONS: ";
4437          12    100                          50      if ( @$reasons ) {
4438           7                                 22         print "\n\n";
4439           7                                 36         for my $i ( 0..(scalar @$reasons - 1) ) {
4440          23                                165            print $i+1, ". $reasons->[$i]\n";
4441                                                        }
4442           7                                 24         print "\n";
4443                                                     }
4444                                                     else {
4445           5                                 19         print "None\n\n";
4446                                                     }
4447          12                                 35      return;
4448                                                  }
4449                                                  
4450                                                  sub get_cxn {
4451          16                   16            83      my ( $dp, $o, $dsn ) = @_;
4452  ***     16     50                          85      if ( $o->get('ask-pass') ) {
4453  ***      0                                  0         $dsn->{p} = OptionParser::prompt_noecho("Enter password: ");
4454                                                     }
4455          16                                113      my $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), {AutoCommit => 1});
4456          16                                118      return $dbh;
4457                                                  }
4458                                                  
4459                                                  # Catches signals so we can exit gracefully.
4460                                                  # TODO: test this
4461                                                  # TODO: break wait for <$fh> with SIGINT.  Possibly by closing all $fh?
4462                                                  sub sig_int {
4463  ***      0                    0             0      my ( $signal ) = @_;
4464  ***      0      0                           0      if ( $oktorun ) {
4465  ***      0                                  0         print STDERR "# Caught SIG$signal.\n";
4466  ***      0                                  0         $oktorun = 0;
4467                                                     }
4468                                                     else {
4469  ***      0                                  0         print STDERR "# Exiting on SIG$signal.\n";
4470  ***      0                                  0         exit(1);
4471                                                     }
4472                                                  }
4473                                                  
4474                                                  sub _d {
4475           1                    1            13      my ($package, undef, $line) = caller 0;
4476  ***      1     50                           9      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
               1                                 12   
               1                                 14   
4477           1                                 10           map { defined $_ ? $_ : 'undef' }
4478                                                          @_;
4479           1                                  6      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4480                                                  }
4481                                                  
4482                                                  # ############################################################################
4483                                                  # Run the program.
4484                                                  # ############################################################################
4485                                                  if ( !caller ) { exit main(@ARGV); }
4486                                                  
4487                                                  1; # Because this is a module as well as a script.
4488                                                  
4489                                                  # #############################################################################
4490                                                  # Documentation.
4491                                                  # #############################################################################
4492                                                  
4493                                                  =pod
4494                                                  
4495                                                  =head1 NAME
4496                                                  
4497                                                  mk-upgrade - Compare SQL statements on different MySQL servers.
4498                                                  
4499                                                  =head1 SYNOPSIS
4500                                                  
4501                                                  Compare queries in slow.log on host1 to host2:
4502                                                  
4503                                                     mk-upgrade h=host1 h=host2 slow.log
4504                                                  
4505                                                  Use mk-upgrade to parse tcpdump and compare queries:
4506                                                  
4507                                                    mk-upgrade --type tcpdump --report '' --print tcpdump.txt | mk-upgrade h=host1 h=host2
4508                                                  
4509                                                  =head1 DESCRIPTION
4510                                                  
4511                                                  mk-upgrade compares and ranks how the results of SQL statements differ when
4512                                                  executed on different MySQL servers.  These ranked differences help to test
4513                                                  upgrade (or downgrade) compatibility.  The higher a query ranks, the greater
4514                                                  its results differ.
4515                                                  
4516                                                  mk-upgrade reads only slow logs.  mk-upgrade can be used to parse and
4517                                                  transform other input sources into a slow log using its C<--print --report ''>
4518                                                  options.
4519                                                  
4520                                                  At present, queries are not fingerprinted or aggregated.  Every query is
4521                                                  executed, compared and ranked individually.  This will change later.
4522                                                  
4523                                                  =head1 OUTPUT
4524                                                  
4525                                                  Output is like a slow log: header lines that start with C<#> followed by
4526                                                  a query.  Like a slow log, the headers have attribute-value pairs like
4527                                                  C<attribute: value> where each pair is the result of some L<"COMPARISONS">
4528                                                  option.  Each attribute name begins with the host to which its value applies,
4529                                                  and each header line corresponds to one part of a comparison.  The first header
4530                                                  line is special: it's the query's difference rank.  The higher its rank, the
4531                                                  more its comparisons differ on the hosts.
4532                                                  
4533                                                  Here's a simple example:
4534                                                  
4535                                                    # Rank: 5
4536                                                    # host1_Query_time: 0.123003  host2_Query_time: 0.231002
4537                                                    # host1_warnings_count: 0  host2_warnings_count: 1
4538                                                    SELECT id FROM table WHERE id < 10;
4539                                                  
4540                                                  =head1 OPTIONS
4541                                                  
4542                                                  =over
4543                                                  
4544                                                  =item --all-errors
4545                                                  
4546                                                  Print all errors for all comparisons.
4547                                                  
4548                                                  Normally only the last error for each comparion is printed, but some
4549                                                  comparisons will save multiple errors.
4550                                                  
4551                                                  =item --ask-pass
4552                                                  
4553                                                  Prompt for a password when connecting to MySQL.
4554                                                  
4555                                                  =item --charset
4556                                                  
4557                                                  short form: -A; type: string
4558                                                  
4559                                                  Default character set.  If the value is utf8, sets Perl's binmode on
4560                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
4561                                                  runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
4562                                                  binmode on STDOUT without the utf8 layer, and runs SET NAMES after
4563                                                  connecting to MySQL.
4564                                                  
4565                                                  =item --config
4566                                                  
4567                                                  type: Array
4568                                                  
4569                                                  Read this comma-separated list of config files; if specified, this must be the
4570                                                  first option on the command line.
4571                                                  
4572                                                  =item --continue-on-error
4573                                                  
4574                                                  Continue parsing even if there is an error.
4575                                                  
4576                                                  =item --daemonize
4577                                                  
4578                                                  Fork to the background and detach from the shell.  POSIX
4579                                                  operating systems only.
4580                                                  
4581                                                  =item --dump-results
4582                                                  
4583                                                  Don't print a human-readable report, just dump the raw results.
4584                                                  
4585                                                  =item --[no]errors
4586                                                  
4587                                                  default: yes
4588                                                  
4589                                                  Print last error for each operation (if any).
4590                                                  
4591                                                  The last error for each query and each comparison is printed in a /* comment
4592                                                  block */ before the query.  C<--no-errors> will disable L<"--all-errors">.
4593                                                  See also L<"--all-errors"> and L<"--[no]reasons">.
4594                                                  
4595                                                  =item --filter
4596                                                  
4597                                                  type: string
4598                                                  
4599                                                  Discard events for which this Perl code doesn't return true.
4600                                                  
4601                                                  This option is a string of Perl code or a file containing Perl code that gets
4602                                                  compiled into a subroutine with one argument: $event.  This is a hashref.
4603                                                  If the given value is a readable file, then mk-upgrade reads the entire
4604                                                  file and uses its contents as the code.  The file should not contain
4605                                                  a shebang (#!/usr/bin/perl) line.
4606                                                  
4607                                                  If the code returns true, the chain of callbacks continues; otherwise it ends.
4608                                                  The code is the last statement in the subroutine other than C<return $event>. 
4609                                                  The subroutine template is:
4610                                                  
4611                                                    sub { $event = shift; filter && return $event; }
4612                                                  
4613                                                  Therefore, filter must produce syntactically valid code given that template.
4614                                                  For example, an if-else branch would not be valid:
4615                                                  
4616                                                    --filter 'if () { } else { }'  # WRONG
4617                                                  
4618                                                  To accomplish something more complex like this would require a more complex
4619                                                  filter:
4620                                                  
4621                                                    --filter 'my $event_ok; if (...) { $event_ok=1; } else { $event_ok=0 } $event_ok'  # OK
4622                                                  
4623                                                  If the filter code won't compile, mk-upgrade will die with an error.
4624                                                  If the filter code does compile, an error may still occur at runtime if the
4625                                                  code tries to do something wrong (like pattern match an undefined value).
4626                                                  mk-upgrade does not provide any safeguards so code carefully!
4627                                                  
4628                                                  An example filter that discards everything but SELECT statements:
4629                                                  
4630                                                    --filter '$event->{arg} =~ m/^select/i'
4631                                                  
4632                                                  This is compiled into a subroutine like the following:
4633                                                  
4634                                                    sub { $event = shift; $event->{arg} =~ m/^select/i && return $event; }
4635                                                  
4636                                                  It is permissible for the code to have side effects (to alter $event).
4637                                                  
4638                                                  You can find an explanation of the structure of $event at
4639                                                  L<http://code.google.com/p/maatkit/wiki/EventAttributes>.
4640                                                  
4641                                                  =item --help
4642                                                  
4643                                                  Show help and exit.
4644                                                  
4645                                                  =item --host
4646                                                  
4647                                                  short form: -h; type: string
4648                                                  
4649                                                  Connect to host.
4650                                                  
4651                                                  =item --log
4652                                                  
4653                                                  type: string
4654                                                  
4655                                                  Print all output to this file when daemonized.
4656                                                  
4657                                                  =item --password
4658                                                  
4659                                                  short form: -p; type: string
4660                                                  
4661                                                  Password to use when connecting.
4662                                                  
4663                                                  =item --pid
4664                                                  
4665                                                  type: string
4666                                                  
4667                                                  Create the given PID file when daemonized.  The file contains the process
4668                                                  ID of the daemonized instance.  The PID file is removed when the
4669                                                  daemonized instance exits.  The program checks for the existence of the
4670                                                  PID file when starting; if it exists and the process with the matching PID
4671                                                  exists, the program exits.
4672                                                  
4673                                                  =item --port
4674                                                  
4675                                                  short form: -P; type: int
4676                                                  
4677                                                  Port number to use for connection.
4678                                                  
4679                                                  =item --[no]reasons
4680                                                  
4681                                                  default: yes
4682                                                  
4683                                                  Print reasons for each query explaining its rank.
4684                                                  
4685                                                  The rank reasons are printed in a /* comment block */ before the query.
4686                                                  See also L<"--[no]errors">.
4687                                                  
4688                                                  =item --run-time
4689                                                  
4690                                                  type: time
4691                                                  
4692                                                  How long to run before exiting.  The default is to run forever (you can
4693                                                  interrupt with CTRL-C).
4694                                                  
4695                                                  =item --socket
4696                                                  
4697                                                  short form: -S; type: string
4698                                                  
4699                                                  Socket file to use for connection.
4700                                                  
4701                                                  =item --tmp-table-database
4702                                                  
4703                                                  type: string
4704                                                  
4705                                                  Use this database for creating temporary tables.
4706                                                  
4707                                                  If given, this database is used for creating temporary tables for the
4708                                                  results comparison (see L<"--[no]compare-results">).  Otherwise, the current
4709                                                  database (from the last event that specified its database) is used.
4710                                                  
4711                                                  =item --user
4712                                                  
4713                                                  short form: -u; type: string
4714                                                  
4715                                                  User for login if not current user.
4716                                                  
4717                                                  =item --version
4718                                                  
4719                                                  Show version and exit.
4720                                                  
4721                                                  =back
4722                                                  
4723                                                  =head2 COMPARISONS
4724                                                  
4725                                                  These comparisons determine the differences for various aspects of a query
4726                                                  when executed on the different hosts.  The more comparisons made, the more
4727                                                  difference can be detected.  Results for each comparison and each host are
4728                                                  reported in the query's header (see L<"OUTPUT">).
4729                                                  
4730                                                  =over
4731                                                  
4732                                                  =item --[no]compare-results
4733                                                  
4734                                                  default: yes; group: Comparisons
4735                                                  
4736                                                  Compare result set checksum, number of rows, and number and types of columns.
4737                                                  
4738                                                  =item --[no]compare-warnings
4739                                                  
4740                                                  default: yes; group: Comparisons
4741                                                  
4742                                                  Compare warnings and errors.
4743                                                  
4744                                                  =back
4745                                                  
4746                                                  =head1 DOWNLOADING
4747                                                  
4748                                                  You can download Maatkit from Google Code at
4749                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
4750                                                  easily with a command like the following:
4751                                                  
4752                                                     wget http://www.maatkit.org/get/toolname
4753                                                     or
4754                                                     wget http://www.maatkit.org/trunk/toolname
4755                                                  
4756                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
4757                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
4758                                                  needed.  The first URL gets the latest released version of the tool, and the
4759                                                  second gets the latest trunk code from Subversion.
4760                                                  
4761                                                  =head1 ENVIRONMENT
4762                                                  
4763                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
4764                                                  the Maatkit tools:
4765                                                  
4766                                                     MKDEBUG=1 mk-....
4767                                                  
4768                                                  =head1 SYSTEM REQUIREMENTS
4769                                                  
4770                                                  You need Perl and some core packages that ought to be installed in any
4771                                                  reasonably new version of Perl.
4772                                                  
4773                                                  =head1 BUGS
4774                                                  
4775                                                  Please use Google Code Issues and Groups to report bugs or request support:
4776                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
4777                                                  discuss Maatkit.
4778                                                  
4779                                                  Please include the complete command-line used to reproduce the problem you are
4780                                                  seeing, the version of all MySQL servers involved, the complete output of the
4781                                                  tool when run with L<"--version">, and if possible, debugging output produced by
4782                                                  running with the C<MKDEBUG=1> environment variable.
4783                                                  
4784                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
4785                                                  
4786                                                  This program is copyright 2009-@CURRENTYEAR@ Percona, Inc.
4787                                                  Feedback and improvements are welcome.
4788                                                  
4789                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
4790                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
4791                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
4792                                                  
4793                                                  This program is free software; you can redistribute it and/or modify it under
4794                                                  the terms of the GNU General Public License as published by the Free Software
4795                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
4796                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
4797                                                  licenses.
4798                                                  
4799                                                  You should have received a copy of the GNU General Public License along with
4800                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
4801                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
4802                                                  
4803                                                  =head1 AUTHOR
4804                                                  
4805                                                  Baron Schwartz, Daniel Nichter
4806                                                  
4807                                                  =head1 VERSION
4808                                                  
4809                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 4424 $.
4810                                                  
4811                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
98    ***     50      0     54   if (@_ > 2)
107   ***     50      0     18   if (not $dsn)
119   ***     50     35      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
131          100      1    143   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
137          100    108     36   if (not defined $final_props{$key})
144   ***     50      0     35   unless exists $opts{$key}
147   ***     50      0     18   if (my $required = $self->prop('required'))
149   ***      0      0      0   unless $final_props{$key}
158   ***      0      0      0   unless ref $o eq 'OptionParser'
161   ***      0      0      0   if $o->has($_)
171   ***     50      0     32   unless ref $dsn
172   ***     50      0     64   $_ eq 'p' ? :
173          100     64    192   if defined $$dsn{$_}
186   ***      0      0      0   $opts{$key}{'copy'} ? :
200   ***     50      0     18   if ($driver eq 'Pg') { }
232   ***     50      0     18   $cxn_string =~ /charset=utf8/ ? :
250   ***     50     18      0   if ($cxn_string =~ /mysql/i)
258   ***     50      0     18   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
263   ***      0      0      0   if ($charset eq 'utf8') { }
264   ***      0      0      0   unless binmode STDOUT, ':utf8'
268   ***      0      0      0   unless binmode STDOUT
272   ***     50      0     18   if ($self->prop('setvars'))
279   ***     50      0     18   if (not $dbh and $EVAL_ERROR)
281   ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/)
285   ***      0      0      0   if (not $tries)
307   ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
324   ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
334   ***      0      0      0   unless $dsn_1
335   ***      0      0      0   unless $dsn_2
339   ***      0      0      0   if ($args{'overwrite'}) { }
340   ***      0      0      0   defined $$dsn_1{$key} ? :
343   ***      0      0      0   defined $$dsn_2{$key} ? :
352   ***      0      0      0   defined $_ ? :
402   ***     50      7      0   unless defined $args{'cache'}
410   ***      0      0      0   if ($what eq 'table') { }
      ***      0      0      0   elsif ($what eq 'triggers') { }
      ***      0      0      0   elsif ($what eq 'view') { }
412   ***      0      0      0   unless $ddl
413   ***      0      0      0   if ($$ddl[0] eq 'table') { }
427   ***      0      0      0   if ($trgs and @$trgs) { }
430   ***      0      0      0   if ($$trg{'sql_mode'})
434   ***      0      0      0   if ($$trg{'definer'})
466   ***     50      0     14   if (not $new)
473   ***     50     14      0   if ($curr and $new and $curr eq $new)
485          100      7      7   if (not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl})
498   ***     50      0      7   if ($EVAL_ERROR)
508   ***     50      7      0   if ($key) { }
524   ***      0      0      0   if (not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl})
554   ***      0      0      0   if (not $$self{'cache'} or not $$self{'triggers'}{$db})
567   ***      0      0      0   if ($sth->rows)
580   ***      0      0      0   if ($tbl)
588   ***      0      0      0   if (not $$self{'cache'} or not $$self{'databases'} or $like)
591   ***      0      0      0   if ($like)
599   ***      0      0      0   unless $like
607   ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_status'}{$db} or $like)
610   ***      0      0      0   if ($like)
625   ***      0      0      0   unless $like
633   ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_list'}{$db} or $like)
636   ***      0      0      0   if ($like)
644   ***      0      0      0   ($$_[1] || '') eq 'VIEW' ? :
651   ***      0      0      0   unless $like
659   ***      0      0      0   defined $_ ? :
690   ***     50      0     14   unless $ddl
691   ***     50     14      0   if (ref $ddl eq 'ARRAY')
692   ***     50     14      0   if (lc $$ddl[0] eq 'table') { }
702   ***     50      0     14   if (not $ddl =~ /CREATE (?:TEMPORARY )?TABLE `/)
723   ***     50      0     42   unless $type
725   ***     50     42      0   if ($type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/)
729   ***     50      0     42   if (not $def =~ /NOT NULL/)
733   ***     50      0     42   $def =~ /AUTO_INCREMENT/i ? :
763   ***      0      0      0   unless ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
777   ***      0      0      0   if ($index)
780   ***      0      0      0   if (not $best)
781   ***      0      0      0   if ($index) { }
794   ***      0      0      0   unless $where
800   ***      0      0      0   if ($$expl{'possible_keys'}) { }
804   ***      0      0      0   if ($$expl{'key'})
830   ***      0      0      0   if ($can_insert) { }
859   ***      0      0      0   if $key =~ /FOREIGN/
863   ***      0      0      0   if (not $engine =~ /MEMORY|HEAP/)
870   ***      0      0      0   if ($$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i)
877   ***      0      0      0   $key =~ /PRIMARY|UNIQUE/ ? :
900   ***      0      0      0   if ($engine =~ /InnoDB/i and not $clustered_key)
902   ***      0      0      0   if ($$this_key{'name'} eq 'PRIMARY') { }
      ***      0      0      0   elsif ($$this_key{'is_unique'} and not $$this_key{'is_nullable'}) { }
926   ***      0      0      0   if (not $parent =~ /\./ and $$opts{'database'})
951   ***      0      0      0   defined $_ ? :
992   ***      0      0      0   if (defined $_) { }
994   ***      0      0      0   $_ eq '' || $_ =~ /^0|\D/ ? :
1007  ***      0      0      0   if (not $tbl)
1048  ***     50      0      8   unless $args{$arg}
1054  ***     50      8      0   exists $args{'strict'} ? :
1097  ***     50      0      8   unless open my $fh, '<', $file
1117         100   4736      8   unless $para =~ /^=head1 OPTIONS/
1122  ***     50      8      0   if $para =~ /^=over/
1130  ***     50      0      8   unless $para
1133         100    184      8   if (my($option) = $para =~ /^=item --(.*)/)
1140         100    128     56   if ($para =~ /: /) { }
1144  ***     50      0    192   unless $attributes{$attrib}
1148         100     48     80   if ($attribs{'short form'})
1164  ***     50      0    184   if $para =~ /^=item/
1166         100     32    152   if (my($base_option) = $option =~ /^\[no\](.*)/)
1171         100     48    136   $attribs{'short form'} ? :
             100     32    152   $attribs{'negatable'} ? :
      ***     50      0    184   $attribs{'cumulative'} ? :
             100     96     88   $attribs{'type'} ? :
             100     32    152   $attribs{'default'} ? :
             100     16    168   $attribs{'group'} ? :
1183  ***     50      0    376   unless $para
1186         100      8    368   if ($para =~ /^=head1/)
1190         100    184    184   if $para =~ /^=item --/
1194  ***     50      0      8   unless @specs
1205  ***     50    184      0   if (ref $opt) { }
1210  ***     50      0    184   if (not $long)
1215  ***     50      0    184   if exists $$self{'opts'}{$long}
1218  ***     50      0    184   if (length $long == 1)
1223         100     48    136   if ($short) { }
1224  ***     50      0     48   if exists $$self{'short_opts'}{$short}
1233         100     32    152   $$opt{'spec'} =~ /!/ ? :
1234  ***     50      0    184   $$opt{'spec'} =~ /\+/ ? :
1235  ***     50      0    184   $$opt{'desc'} =~ /required/ ? :
1247  ***     50      0    184   if ($type and $type eq 'd' and not $$self{'dp'})
1252         100     16    168   if $type and $type =~ /[HhAadzm]/
1254         100     32    152   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
1255  ***     50     32      0   defined $def ? :
1259         100      8    176   if ($long eq 'config')
1263  ***     50      0    184   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
1276  ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
1281  ***      0      0      0   if ($opt =~ /at least one|one and only one/)
1286  ***      0      0      0   if ($opt =~ /default to/)
1291  ***      0      0      0   if ($opt =~ /restricted to option groups/)
1301  ***      0      0      0   unless $rule_ok
1318  ***      0      0      0   unless exists $$self{'opts'}{$long}
1334  ***      0      0      0   $$self{'opts'}{$_}{'short'} ? :
1352  ***      0      0      0   unless exists $$self{'opts'}{$long}
1372  ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50      7      0   exists $$self{'opts'}{$opt} ? :
1377  ***     50      0      7   if ($$opt{'is_cumulative'}) { }
1392  ***     50      0    144   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100     40    144   exists $$self{'defaults'}{$long} ? :
1401  ***     50      0      8   if (@ARGV and $ARGV[0] eq '--config')
1405  ***     50      8      0   if ($self->has('config'))
1411  ***     50     32      0   if ($EVAL_ERROR)
1412  ***     50      0     32   $self->got('config') ? :
1427  ***     50      0      8   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
1430  ***     50      0      8   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
1431  ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
1437  ***     50      0      8   if (@ARGV and $$self{'strict'})
1443  ***      0      0      0   if (@set > 1)
1454  ***      0      0      0   if (@set == 0)
1464         100      7    177   if ($$opt{'got'}) { }
      ***     50      0    177   elsif ($$opt{'is_required'}) { }
1465  ***     50      0      7   if (exists $$self{'disables'}{$long})
1472  ***     50      0      7   if (exists $$self{'allowed_groups'}{$long})
1484  ***      0      0      0   if $restricted_opt eq $long
1485  ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
1490  ***      0      0      0   if (@restricted_opts)
1492  ***      0      0      0   if (@restricted_opts == 1) { }
1521         100     88     96   unless $opt and $$opt{'type'}
1524  ***     50      0     96   if ($val and $$opt{'type'} eq 'm') { }
      ***     50      0     96   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0     96   elsif ($val and $$opt{'type'} eq 'z') { }
      ***     50      0     96   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100      8     88   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
1527  ***      0      0      0   if (not $suffix)
1533  ***      0      0      0   if ($suffix =~ /[smhd]/) { }
1534  ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1549  ***      0      0      0   if ($from_key)
1559  ***      0      0      0   if (defined $num) { }
1560  ***      0      0      0   if ($factor)
1587  ***     50      0    204   length $opt == 1 ? :
1588  ***     50      0    204   unless $long and exists $$self{'opts'}{$long}
1595  ***     50      0     32   length $opt == 1 ? :
1596  ***     50      0     32   unless $long and exists $$self{'opts'}{$long}
1603  ***     50      0      8   length $opt == 1 ? :
1604  ***     50      8      0   defined $long ? :
1609  ***     50      0      2   length $opt == 1 ? :
1610  ***     50      0      2   unless $long and exists $$self{'opts'}{$long}
1644  ***     50      0      8   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0      8   elsif (scalar @{$$self{'errors'};}) { }
1645  ***      0      0      0   unless print $self->print_usage
1649  ***      0      0      0   unless print $self->print_errors
1658  ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
1667  ***      0      0      0   unless $$self{'got_opts'}
1670  ***      0      0      0   $$_{'is_negatable'} ? :
1674  ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
1690  ***      0      0      0   $group eq 'default' ? :
1696  ***      0      0      0   $$opt{'is_negatable'} ? :
1699  ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
1708  ***      0      0      0   if ($short) { }
1717  ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
1721  ***      0      0      0   if ($$self{'dp'})
1729  ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
1741  ***      0      0      0   if ref $_[0] eq 'OptionParser'
1744  ***      0      0      0   unless print $prompt
1752  ***      0      0      0   unless print "\n"
1755  ***      0      0      0   if ($EVAL_ERROR)
1777  ***     50     32      0   unless open my $fh, '<', $filename
1785  ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
1788  ***      0      0      0   if ($line eq '--')
1793  ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
1811  ***      0      0      0   unless open my $fh, '<', $file
1815  ***      0      0      0   unless $para =~ /^=pod$/m
1819  ***      0      0      0   unless $para =~ /$regex/
1824  ***      0      0      0   unless close $fh
1838  ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
1853  ***      0      0      0   defined $_ ? :
1901  ***      0      0      0   defined $args{'p_ms'} ? :
1902  ***      0      0      0   defined $args{'p_s'} ? :
1905  ***      0      0      0   if $t < 0
1907  ***      0      0      0   if $t =~ /e/
1911  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
1932  ***      0      0      0   $p ? :
1939  ***      0      0      0   unless $secs
1941  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
1946  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
1965  ***      0      0      0   defined $args{'p'} ? :
1966  ***      0      0      0   defined $args{'d'} ? :
1973  ***      0      0      0   $num =~ /\./ || $n ? :
1992  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^$mysql_ts$/)
1995  ***      0      0      0   defined $f ? :
      ***      0      0      0   defined $f ? :
2004  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s) = $val =~ /^$proper_ts$/)
2015  ***      0      0      0   if (my($n, $suffix) = $val =~ /^$n_ts$/) { }
      ***      0      0      0   elsif (my($ymd, $hms) = $val =~ /^(\d{6})(?:\s+(\d+:\d+:\d+))?/) { }
      ***      0      0      0   elsif (($ymd, $hms) = $val =~ /^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) { }
2016  ***      0      0      0   $suffix eq 'd' ? :
      ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
2026  ***      0      0      0   unless $hms
2031  ***      0      0      0   unless $hms
2036  ***      0      0      0   if $callback and ref $callback eq 'CODE'
2052  ***      0      0      0   defined $_ ? :
2117  ***      0      0      0   unless $query =~ /IN\s*\(\s*(?!select)/i
2119  ***      0      0      0   if ($length and length $query > $length)
2125  ***      0      0      0   if ($left)
2139  ***      0      0      0   @right ? :
2152  ***      0      0      0   if $query =~ m[\ASELECT /\*!40001 SQL_NO_CACHE \*/ \* FROM `]
2154  ***      0      0      0   if $query =~ m[/\*\w+\.\w+:[0-9]/[0-9]\*/]
2156  ***      0      0      0   if $query =~ /\A# administrator command: /
2158  ***      0      0      0   if $query =~ /\A\s*(call\s+\S+)\(/i
2160  ***      0      0      0   if (my($beginning) = $query =~ /\A((?:INSERT|REPLACE)(?: IGNORE)? INTO .+? VALUES \(.*?\)),\(/i)
2166  ***      0      0      0   if $query =~ s/\Ause \S+\Z/use ?/i
2194  ***      0      0      0   unless $qp
2196  ***      0      0      0   if $query =~ /\A\s*call\s+(\S+)\(/i
2198  ***      0      0      0   if $query =~ /\A# administrator/
2200  ***      0      0      0   if $query =~ /\A\s*use\s+/
2206  ***      0      0      0   if ($dds)
2208  ***      0      0      0   if $obj
2213  ***      0      0      0   $db_or_tbl ? :
2214  ***      0      0      0   $obj ? :
2242  ***      0      0      0   unless $query
2261  ***      0      0      0   unless $query =~ s/
                 \A.*?
                 update\s+(.*?)
                 \s+set\b(.*?)
                 (?:\s*where\b(.*?))?
                 (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
                 \Z
              /__update_to_select($1, $2, $3, $4);/eisx or $query =~ s/
                    \A.*?
                    (?:insert|replace)\s+
                    .*?\binto\b(.*?)\(([^\)]+)\)\s*
                    values?\s*(\(.*?\))\s*
                    (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
                    \Z
                 /__insert_to_select($1, $2, $3);/eisx
2275  ***      0      0      0   $1 =~ /\*/ ? :
2284  ***      0      0      0   if ($join =~ /\bjoin\b/)
2298  ***      0      0      0   if (@cols == @vals) { }
2309  ***      0      0      0   $where ? :
      ***      0      0      0   $limit ? :
2316  ***      0      0      0   unless $query
2317  ***      0      0      0   $query =~ /\A\s*select/i ? :
2324  ***      0      0      0   defined $_ ? :
2368  ***     50      0     24   $$misc{'oktorun'} ? :
2383  ***     50      0     16   if ($stmt =~ s/$slow_log_hd_line//go)
2385  ***      0      0      0   if (@chunks > 1)
2392         100      8      8   unless $stmt =~ /\A#/
2406         100     64     16   if ($line =~ /^(?:#|use |SET (?:last_insert_id|insert_id|timestamp))/o) { }
2408         100     16     48   if (not $got_ts and my($time) = $line =~ /$slow_log_ts_line/o) { }
             100     16     32   elsif (not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o) { }
      ***     50      0     32   elsif (not $got_ac and $line =~ /^# (?:administrator command:.*)$/) { }
             100     16     16   elsif ($line =~ /^# +[A-Z][A-Za-z_]+: \S+/) { }
      ***     50     16      0   elsif (not $got_db and my($db) = $line =~ /^use ([^;]+)/) { }
      ***      0      0      0   elsif (not $got_set and my($setting) = $line =~ /^SET\s+([^;]*)/) { }
2412  ***     50      0     16   if (not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o)
2455  ***     50      0     64   if (not $found_arg and $pos == $len)
2458  ***      0      0      0   if (defined(my $l = <$fh>)) { }
2475  ***     50      0     16   if ($misc and $$misc{'embed'} and my($e) = $arg =~ /($$misc{'embed'})/)
2487  ***     50      0     92   unless $event = &$callback($event)
2490  ***     50     16      0   unless @pending
2497  ***      0      0      0   defined $_ ? :
2532  ***      0      0      0   unless $args{$arg}
2551  ***      0      0      0   unless $args{'type_for'}
2562  ***      0      0      0   scalar keys %$attributes == 0 ? :
2585  ***      0      0      0   unless defined $group_by
2590  ***      0      0      0   if $$self{'unrolled_loops'}
2593  ***      0      0      0   if ($$self{'n_events'} <= $$self{'unroll_limit'}) { }
2595  ***      0      0      0   if $$self{'detect_attribs'}
2600  ***      0      0      0   if (not exists $$event{$attrib})
2604  ***      0      0      0   unless $alt_attrib
2608  ***      0      0      0   ref $group_by ? :
2613  ***      0      0      0   if (not $handler)
2622  ***      0      0      0   unless $handler
2645  ***      0      0      0   ref $group_by ? :
2660  ***      0      0      0   if (ref $group_by)
2670  ***      0      0      0   if $EVAL_ERROR
2697  ***      0      0      0   unless defined $attrib
2700  ***      0      0      0   if (ref $val eq 'ARRAY')
2704  ***      0      0      0   unless defined $val
2707  ***      0      0      0   $val =~ /^(?:Yes|No)$/ ? :
      ***      0      0      0   $val =~ /^(?:\d+|$float_re)$/o ? :
      ***      0      0      0   $self->type_for($attrib) ? :
2715  ***      0      0      0   $type =~ /num|bool/ ? :
      ***      0      0      0   $type =~ /bool|string/ ? :
      ***      0      0      0   $type eq 'num' ? :
      ***      0      0      0   $type eq 'bool' ? :
2730  ***      0      0      0   if ($args{'trf'})
2736  ***      0      0      0   if ($args{'min'})
2737  ***      0      0      0   $type eq 'num' ? :
2743  ***      0      0      0   if ($args{'max'})
2744  ***      0      0      0   $type eq 'num' ? :
2750  ***      0      0      0   if ($args{'sum'})
2753  ***      0      0      0   if ($args{'cnt'})
2756  ***      0      0      0   if ($args{'all'})
2765  ***      0      0      0   if ($args{'unq'})
2768  ***      0      0      0   if ($args{'wor'})
2769  ***      0      0      0   $type eq 'num' ? :
2778  ***      0      0      0   if ($args{'all'} and $type eq 'num' and $$self{'attrib_limit'})
2793  ***      0      0      0   $is_array ? :
      ***      0      0      0   $is_array ? :
2805  ***      0      0      0   $is_array ? :
      ***      0      0      0   $is_array ? :
2817  ***      0      0      0   if $EVAL_ERROR
2823  ***      0      0      0   if $val < 1e-06
2825  ***      0      0      0   $idx > 999 ? :
2830         100      1    999   if $bucket == 0
2831  ***     50      0    999   if $bucket < 0 or $bucket > 999
2838  ***      0      0      0   if @buck_tens
2869  ***      0      0      0   unless defined $vals and @$vals and $$args{'cnt'}
2873  ***      0      0      0   if ($n_vals == 1 or $$args{'max'} == $$args{'min'}) { }
      ***      0      0      0   elsif ($n_vals == 2) { }
2875  ***      0      0      0   $v > 0 ? :
2876  ***      0      0      0   $bucket < 0 ? :
      ***      0      0      0   $bucket > 7 ? :
2886  ***      0      0      0   $v && $v > 0 ? :
2887  ***      0      0      0   $bucket < 0 ? :
      ***      0      0      0   $bucket > 7 ? :
2899  ***      0      0      0   $n_vals >= 10 ? :
2917  ***      0      0      0   unless $val
2921  ***      0      0      0   if not $bucket_95 and $sum_excl > $top_vals
2923  ***      0      0      0   if (not $median and $total_left <= $mid)
2924  ***      0      0      0   $cutoff % 2 || $val > 1 ? :
2934  ***      0      0      0   $var > 0 ? :
2936  ***      0      0      0   $stddev > $maxstdev ? :
2953  ***      0      0      0   unless $args{$arg}
2962  ***      0      0      0   $global_cnt && $$store{'cnt'} ? :
      ***      0      0      0   $$store{'sum'} && $$store{'cnt'} ? :
2986  ***      0      0      0   if (!$args{'total'} || $total < $args{'total'} and !$args{'count'} || $count < $args{'count'}) { }
      ***      0      0      0   elsif ($args{'ol_attrib'} and !$args{'ol_freq'} || $$classes{$groupby}{$args{'ol_attrib'}}{'cnt'} >= $args{'ol_freq'}) { }
3001  ***      0      0      0   if ($$stats{'pct_95'} >= $args{'ol_limit'})
3014  ***      0      0      0   unless $event
3017  ***      0      0      0   if $_ ne $$self{'groupby'} and not exists $$self{'attributes'}{$_}
3047  ***      0      0      0   unless @attribs
3058  ***      0      0      0   if $EVAL_ERROR
3064  ***      0      0      0   defined $_ ? :
3108  ***     50      0     52   unless $query
3112         100     24     28   if ($ddl_stmt)
3115  ***     50      0     24   if ($query =~ /$ddl_stmt DATABASE\b/i)
3119  ***     50     24      0   if ($ddl_stmt =~ /CREATE/i and $query =~ /$ddl_stmt\b.+?\bSELECT\b/i)
3155  ***      0      0      0   unless $query
3171  ***      0      0      0   unless $tbl_refs and $from
3192  ***      0      0      0   if ($tbl_ref =~ /^AS\s+\w+/i)
3200  ***      0      0      0   if $db
3207  ***      0      0      0   unless $query
3218  ***      0      0      0   if (@split_statements == 1) { }
3233  ***      0      0      0   unless $query
3240  ***      0      0      0   defined $_ ? :
3269  ***      0      0      0   unless $args{$arg}
3272  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
3288  ***      0      0      0   unless defined(my $pid = fork)
3289  ***      0      0      0   if ($pid)
3296  ***      0      0      0   unless POSIX::setsid()
3297  ***      0      0      0   unless chdir '/'
3301  ***      0      0      0   if (-t STDIN)
3303  ***      0      0      0   unless open STDIN, '/dev/null'
3307  ***      0      0      0   if ($$self{'log_file'})
3309  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
3313  ***      0      0      0   unless open STDERR, '>&STDOUT'
3323  ***      0      0      0   $self ? :
3325  ***      0      0      0   if ($PID_file and -f $PID_file) { }
3328  ***      0      0      0   if $EVAL_ERROR
3330  ***      0      0      0   if ($pid) { }
3332  ***      0      0      0   if ($pid_is_alive) { }
3354  ***      0      0      0   if (exists $$self{'child'})
3366  ***      0      0      0   if (not $PID_file)
3373  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
3375  ***      0      0      0   unless print $PID_FH $PID
3377  ***      0      0      0   unless close $PID_FH
3386  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
3387  ***      0      0      0   unless unlink $$self{'PID_file'}
3399  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
3405  ***      0      0      0   defined $_ ? :
3437  ***      0      0      0   unless $args{$arg}
3446  ***     50      0     64   unless $args{$arg}
3465  ***     50     32      0   $dp && $dsn ? :
3490         100     16     16   if ($EVAL_ERROR) { }
3517  ***     50      0     28   unless $args{$arg}
3531  ***     50      0     28   if ($EVAL_ERROR)
3547  ***     50      0     84   unless $args{$arg}
3557  ***     50     28      0   if (@tables) { }
3564  ***     50      0     28   if ($EVAL_ERROR)
3580  ***     50      0    112   unless $args{$arg}
3595  ***     50      0     28   if ($EVAL_ERROR)
3605  ***     50      0    168   unless $args{$arg}
3626         100     14     14   if ($EVAL_ERROR) { }
3636  ***     50     14      0   if ($$ddl[0] eq 'table')
3640  ***     50      0     14   if ($EVAL_ERROR)
3650  ***     50      0     28   if ($EVAL_ERROR)
3656         100     14     14   if (not defined $n_rows)
3661         100     14     14   if (not $tbl_checksum)
3667  ***     50      0     28   if @errors == 1
3681  ***     50      0    144   unless $name
3683  ***     50      0    144   unless $res or scalar keys %$res
3685  ***     50      0    144   unless exists $$res{'error'}
3687  ***     50      0    144   if defined $$res{'error'} and not $$res{'error'}
3689  ***     50      0    144   if $$res{'errors'} and ref $$res{'errors'} ne 'ARRAY'
3696  ***      0      0      0   $host_name ? :
3704  ***      0      0      0   defined $_ ? :
3742  ***      0      0      0   unless $args{$arg}
3751  ***     50      0     16   unless @results > 1
3760         100     28     44   if (not $compare)
3771  ***     50      0     44   if (not exists $$host_results{$results})
3793         100      8      8   if ($$host1{'Query_time'} == -1)
3799         100      8      8   if ($$host2{'Query_time'} == -1)
3806         100      8      8   if ($$host1{'Query_time'} >= 0 and $$host2{'Query_time'} >= 0)
3822         100      7      7   if ($$host1{'count'} > 0 or $$host2{'count'} > 0)
3827  ***     50      0     14   if (my $diff = abs $$host1{'count'} - $$host2{'count'})
3841  ***     50      0      8   unless defined $t1
3842  ***     50      0      8   unless defined $t2
3849         100      1      7   if ($t1_bucket != $t2_bucket)
3857  ***     50      0      7   if ($inc >= $bucket_threshold[$t1_bucket])
3868  ***     50      0     14   unless defined $warnings1
3869  ***     50      0     14   unless defined $warnings2
3876  ***     50      7      0   if (exists $$warnings2{$code}) { }
3877  ***     50      0      7   if ($$warnings2{$code}{'Level'} ne $$warnings1{$code}{'Level'})
3892  ***     50      0      7   if (not exists $$warnings1{$code} and not exists $new_warnings{$code})
3911  ***     50      0     14   if ($$host1{'checksum'} ne $$host2{'checksum'})
3916  ***     50      0     14   if ($$host1{'n_rows'} != $$host2{'n_rows'})
3921         100      7      7   if ($$host1{'table_struct'} and $$host2{'table_struct'}) { }
3939  ***     50      0      7   unless defined $s1
3940  ***     50      0      7   unless defined $s2
3945  ***     50      0      7   if (scalar @{$$s1{'cols'};} != scalar @{$$s2{'cols'};})
3956  ***     50     21      0   if (exists $$s2{'type_for'}{$col}) { }
3957  ***     50      0     21   if ($$s1{'type_for'}{$col} ne $$s2{'type_for'}{$col})
3984  ***     50      0     16   unless defined $val
3985  ***     50      0     16   if $val == 0
3987  ***     50      0     16   $bucket < 0 ? :
      ***     50      0     16   $bucket > 7 ? :
3993  ***     50      0      7   if $x == $y
3995         100      6      1   if ($x > $y)
4001  ***     50      0      7   if ($x == 0)
4010  ***      0      0      0   defined $_ ? :
4066  ***     50      8      0   if (not $o->get('help'))
4067  ***     50      0      8   if (@ARGV < 2)
4072         100      2      6   unless $o->get('errors')
4116  ***     50      0     16   unless $$event{'cmd'} eq 'Query'
4117  ***     50      0     16   unless $$event{'arg'}
4118  ***     50     16      0   if ($$event{'arg'} =~ m[(?:^SELECT|(?:\*/\s*SELECT))]i)
4126  ***     50      0      8   if ($o->get('filter'))
4130  ***      0      0      0   unless my $sub = eval $code
4141         100      8      8   if ($db and !$current_db || $db ne $current_db)
4146  ***     50      0      8   if ($EVAL_ERROR) { }
4165         100      7      1   if ($o->get('compare-warnings'))
4170         100      7      1   if ($o->get('compare-results'))
4181  ***     50      0     14   unless $query
4229  ***     50      0     16   if ($EVAL_ERROR)
4242         100      7      1   if ($o->get('compare-results'))
4260  ***     50      0     16   unless $results
4268  ***     50      0     16   if ($EVAL_ERROR)
4283  ***     50      0      8   if ($o->get('daemonize'))
4292  ***     50      0      8   if (@ARGV == 0)
4310  ***     50      0      8   if ($file eq '-') { }
4314  ***     50      0      8   if (not open $fh, '<', $file)
4327  ***     50      0     24   if ($EVAL_ERROR)
4331  ***      0      0      0   if $EVAL_ERROR =~ /Cannot open/
4332  ***      0      0      0   unless $o->get('continue-on-error')
4334         100      8     16   unless $events
4351  ***     50      0     16   if ($o->get('dump-results'))
4360         100      8      8   $t1 >= 0 ? :
             100      8      8   $t2 >= 0 ? :
4364         100     14      2   if ($o->get('compare-warnings'))
4370         100     14      2   if ($o->get('compare-results'))
4380         100     14      2   if ($o->get('reasons') or $o->get('errors'))
4382         100     12      2   if $o->get('errors')
4384         100     12      2   if $o->get('reasons')
4416         100     22     82   if ($last_error)
4421         100      2    102   if ($all and $$op_res{'errors'} and scalar @{$$op_res{'errors'};})
4430         100      6      6   $n_errors ? :
4437         100      7      5   if (@$reasons) { }
4452  ***     50      0     16   if ($o->get('ask-pass'))
4464  ***      0      0      0   if ($oktorun) { }
4476  ***     50      1      0   defined $_ ? :


Conditions
----------

and 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
4421         100    100      4   $all and $$op_res{'errors'} and scalar @{$$op_res{'errors'};}

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
131          100     35    108      1   not defined $final_props{$key} and defined $$prev{$key}
      ***     66    143      0      1   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
243   ***     66     18      0     18   not $dbh and $tries--
279   ***     33     18      0      0   not $dbh and $EVAL_ERROR
427   ***      0      0      0      0   $trgs and @$trgs
473   ***     33      0      0     14   $curr and $new
      ***     33      0      0     14   $curr and $new and $curr eq $new
870   ***      0      0      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000'
      ***      0      0      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i
900   ***      0      0      0      0   $engine =~ /InnoDB/i and not $clustered_key
902   ***      0      0      0      0   $$this_key{'is_unique'} and not $$this_key{'is_nullable'}
926   ***      0      0      0      0   not $parent =~ /\./ and $$opts{'database'}
1247  ***     66     88     96      0   $type and $type eq 'd'
      ***     33    184      0      0   $type and $type eq 'd' and not $$self{'dp'}
1252         100     88     80     16   $type and $type =~ /[HhAadzm]/
1401  ***     33      0      8      0   @ARGV and $ARGV[0] eq '--config'
1430  ***     33      0      8      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
1437  ***     33      0      8      0   @ARGV and $$self{'strict'}
1521  ***     66      0     88     96   $opt and $$opt{'type'}
1524  ***     66     88      8      0   $val and $$opt{'type'} eq 'm'
      ***     66     88      8      0   $val and $$opt{'type'} eq 'd'
      ***     66     88      8      0   $val and $$opt{'type'} eq 'z'
      ***     66     88      8      0   defined $val and $$opt{'type'} eq 'h'
      ***     33     88      0      0   defined $val and $$opt{'type'} eq 'a'
1588  ***     33      0      0    204   $long and exists $$self{'opts'}{$long}
1596  ***     33      0      0     32   $long and exists $$self{'opts'}{$long}
1610  ***     33      0      0      2   $long and exists $$self{'opts'}{$long}
1699  ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
1793  ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1911  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
1969  ***      0      0      0      0   $num >= $d and $n < @units - 1
2036  ***      0      0      0      0   $callback and ref $callback eq 'CODE'
2119  ***      0      0      0      0   $length and length $query > $length
2131  ***      0      0      0      0   @vals and $len < $targ / 2
2135  ***      0      0      0      0   @vals and $len < $targ
2378  ***     66      0      8     16   $$oktorun and defined($stmt = shift @pending) || defined($stmt = <$fh>)
2408  ***     66     48      0     16   not $got_ts and my($time) = $line =~ /$slow_log_ts_line/o
      ***     66     32      0     16   not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o
      ***     33      0     32      0   not $got_ac and $line =~ /^# (?:administrator command:.*)$/
      ***     33      0      0     16   not $got_db and my($db) = $line =~ /^use ([^;]+)/
      ***      0      0      0      0   not $got_set and my($setting) = $line =~ /^SET\s+([^;]*)/
2412  ***     33      0     16      0   not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o
2455  ***     33      0     64      0   not $found_arg and $pos == $len
2475  ***     33      0     16      0   $misc and $$misc{'embed'}
      ***     33     16      0      0   $misc and $$misc{'embed'} and my($e) = $arg =~ /($$misc{'embed'})/
2778  ***      0      0      0      0   $args{'all'} and $type eq 'num'
      ***      0      0      0      0   $args{'all'} and $type eq 'num' and $$self{'attrib_limit'}
2869  ***      0      0      0      0   defined $vals and @$vals
      ***      0      0      0      0   defined $vals and @$vals and $$args{'cnt'}
2886  ***      0      0      0      0   $v && $v > 0
2921  ***      0      0      0      0   not $bucket_95 and $sum_excl > $top_vals
2923  ***      0      0      0      0   not $median and $total_left <= $mid
2962  ***      0      0      0      0   $global_cnt && $$store{'cnt'}
      ***      0      0      0      0   $$store{'sum'} && $$store{'cnt'}
2986  ***      0      0      0      0   !$args{'total'} || $total < $args{'total'} and !$args{'count'} || $count < $args{'count'}
      ***      0      0      0      0   $args{'ol_attrib'} and !$args{'ol_freq'} || $$classes{$groupby}{$args{'ol_attrib'}}{'cnt'} >= $args{'ol_freq'}
3017  ***      0      0      0      0   $_ ne $$self{'groupby'} and not exists $$self{'attributes'}{$_}
3119  ***     33      0      0     24   $ddl_stmt =~ /CREATE/i and $query =~ /$ddl_stmt\b.+?\bSELECT\b/i
3171  ***      0      0      0      0   $tbl_refs and $from
3325  ***      0      0      0      0   $PID_file and -f $PID_file
3386  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
3465  ***     33      0      0     32   $dp && $dsn
3687  ***     66    114     30      0   defined $$res{'error'} and not $$res{'error'}
3689  ***     66    116     28      0   $$res{'errors'} and ref $$res{'errors'} ne 'ARRAY'
3806  ***     66      8      0      8   $$host1{'Query_time'} >= 0 and $$host2{'Query_time'} >= 0
3892  ***     33      7      0      0   not exists $$warnings1{$code} and not exists $new_warnings{$code}
3921  ***     66      7      0      7   $$host1{'table_struct'} and $$host2{'table_struct'}
4141  ***     66      0      8      8   $db and !$current_db || $db ne $current_db
4302  ***     33      0      0     16   $oktorun and $start == $end || $now < $end
      ***     66      0      8      8   $oktorun and $start == $end || $now < $end and @ARGV
4322  ***     33      0      0     24   $oktorun and $start == $end || $now < $end
4421         100     84     16      4   $all and $$op_res{'errors'}

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
112          100      8     10   $prev ||= {}
113   ***     50      0     18   $defaults ||= {}
186   ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
199   ***     50      0     18   $self->prop('dbidriver') || ''
203   ***      0      0      0   $$info{'D'} || ''
209   ***     50      0     18   $$info{'D'} || ''
231   ***     50     18      0   $opts ||= {}
307   ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
323   ***      0      0      0   $level ||= 0
324   ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
644   ***      0      0      0   $$_[1] || ''
831   ***      0      0      0   $$_{'Privileges'} || ''
847   ***     50     28      0   $engine || undef
869   ***      0      0      0   $type || $special || 'BTREE'
1051  ***     50      8      0   $program_name ||= $PROGRAM_NAME
1052  ***     50      8      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
1054  ***     50      8      0   $args{'prompt'} || '<options>'
      ***     50      8      0   $args{'dp'} || undef
1096  ***     50      0      8   $file ||= '../mk-upgrade'
1237  ***     50    184      0   $$opt{'group'} ||= 'default'
1529  ***      0      0      0   $s || 's'
1565  ***      0      0      0   $pre || ''
1572  ***      0      0      0   $val || ''
1575  ***     50      8      0   $val || ''
1633  ***      0      0      0   $$self{'description'} || ''
1701  ***      0      0      0   $s ||= 's'
1727  ***      0      0      0   $$opt{'type'} || ''
1931  ***      0      0      0   $args{'p'} || 0
1933  ***      0      0      0   $of ||= 1
1938  ***      0      0      0   $secs ||= 0
2534  ***      0      0      0   $args{'attributes'} || {}
2562  ***      0      0      0   $args{'unroll_limit'} || 1000
2609  ***      0      0      0   $$self{'result_classes'}{$val}{$attrib} ||= {}
2610  ***      0      0      0   $$self{'result_globals'}{$attrib} ||= {}
2874  ***      0      0      0   $$args{'max'} || 0
2889  ***      0      0      0   $$args{'max'} || 0
2890  ***      0      0      0   $$args{'min'} || 0
2935  ***      0      0      0   $$args{'max'} || 0
      ***      0      0      0   $$args{'min'} || 0
3536         100     14     14   $$warning_count[0]{'@@warning_count'} || 0
3669         100     14     14   $tbl_checksum || 0
             100     14     14   $n_rows || 0
3683  ***     50    144      0   $res or scalar keys %$res
3795  ***     50      8      0   $$host1{'error'} || 'unknown error'
3801  ***     50      8      0   $$host2{'error'} || 'unknown error'
4298  ***     50      0      8   $o->get('run-time') || 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
222   ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
223   ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
224   ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
225   ***      0      0      0      0   $$dsn{'u'} ||= $user
226   ***      0      0      0      0   $$dsn{'D'} ||= $db
485   ***     66      0      7      7   not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl}
524   ***      0      0      0      0   not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl}
554   ***      0      0      0      0   not $$self{'cache'} or not $$self{'triggers'}{$db}
588   ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'} or $like
607   ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db} or $like
621   ***      0      0      0      0   $tbl{'type'} || $tbl{'comment'}
      ***      0      0      0      0   $tbl{'engine'} ||= $tbl{'type'} || $tbl{'comment'}
633   ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db} or $like
763   ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'}
      ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
869   ***      0      0      0      0   $type || $special
994   ***      0      0      0      0   $_ eq '' || $_ =~ /^0|\D/
1052  ***     33      8      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***     33      8      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
1524  ***     33      0      0     96   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***     66      8      0     88   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1941  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
1973  ***      0      0      0      0   $num =~ /\./ || $n
2193  ***      0      0      0      0   $args{'qp'} || $$self{'QueryParser'}
2261  ***      0      0      0      0   $query =~ s/
                 \A.*?
                 update\s+(.*?)
                 \s+set\b(.*?)
                 (?:\s*where\b(.*?))?
                 (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
                 \Z
              /__update_to_select($1, $2, $3, $4);/eisx or $query =~ s/
                    \A.*?
                    (?:insert|replace)\s+
                    .*?\binto\b(.*?)\(([^\)]+)\)\s*
                    values?\s*(\(.*?\))\s*
                    (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
                    \Z
                 /__insert_to_select($1, $2, $3);/eisx
2378  ***     66      0     16      8   defined($stmt = shift @pending) || defined($stmt = <$fh>)
2623  ***      0      0      0      0   $$samples{$val} ||= $event
2831  ***     33      0      0    999   $bucket < 0 or $bucket > 999
2873  ***      0      0      0      0   $n_vals == 1 or $$args{'max'} == $$args{'min'}
2924  ***      0      0      0      0   $cutoff % 2 || $val > 1
2986  ***      0      0      0      0   !$args{'total'} || $total < $args{'total'}
      ***      0      0      0      0   !$args{'count'} || $count < $args{'count'}
      ***      0      0      0      0   !$args{'ol_freq'} || $$classes{$groupby}{$args{'ol_attrib'}}{'cnt'} >= $args{'ol_freq'}
3199  ***      0      0      0      0   $alias or $tbl
3399  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
3822  ***     66      7      0      7   $$host1{'count'} > 0 or $$host2{'count'} > 0
4141  ***     66      8      0      8   !$current_db || $db ne $current_db
4182  ***     33      0     14      0   $tmp_tbl_db || $current_db
4191  ***     33      0     28      0   $tmp_tbl_db || $current_db
4201  ***     33      0     28      0   $tmp_tbl_db || $current_db
4302  ***     33     16      0      0   $start == $end || $now < $end
4322  ***     33     24      0      0   $start == $end || $now < $end
4380         100     12      2      2   $o->get('reasons') or $o->get('errors')


Covered Subroutines
-------------------

Subroutine                    Count Location                                           
----------------------------- ----- ---------------------------------------------------
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1025
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1026
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1028
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1029
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1030
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1032
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1871
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1872
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1873
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1874
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1875
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1877
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:20  
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2067
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2068
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2072
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2074
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:21  
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2341
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2342
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2343
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2344
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2346
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2514
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2515
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2516
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2518
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2519
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2520
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2521
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2522
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2523
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:30  
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3081
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3082
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3083
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3085
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:31  
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3258
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3259
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3261
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3262
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3264
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3422
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3423
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3425
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3426
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3427
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3432
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:35  
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:36  
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:369 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:370 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:372 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3722
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3723
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3725
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3726
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3728
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:374 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:39  
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4032
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4034
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4041
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4043
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:41  
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:676 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:677 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:678 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:680 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:966 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:967 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:971 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:973 
__ANON__                          7 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1425
__ANON__                         16 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4115
__ANON__                         16 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4139
__ANON__                         28 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4166
__ANON__                         28 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4167
__ANON__                         14 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4179
__ANON__                         28 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4191
__ANON__                         28 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4201
__ANON__                         16 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4216
__ANON__                         14 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4244
__ANON__                         16 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4258
_check_results                  144 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3680
_d                                1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4475
_parse_specs                      8 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1201
_pod_to_specs                     8 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1095
_read_config_file                32 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1776
_set_option                       7 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1371
_use_db                          14 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:465 
_validate_type                  184 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1520
as_string                        32 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:170 
bucket_for                       16 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3983
bucket_value                   1000 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2829
checksum_results                 28 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3603
clear_warnings                   28 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3545
compare_query_times               8 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3840
compare_table_structs             7 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3938
compare_warnings                 14 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3867
exec                             16 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3444
get                             204 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1586
get_create_table                 14 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:484 
get_cxn                          16 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4451
get_cxn_params                   18 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:196 
get_dbh                          18 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:230 
get_defaults_files                8 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1090
get_engine                       28 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:844 
get_keys                         14 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:851 
get_opts                          8 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1388
get_specs                         8 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1083
get_tables                       52 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3107
get_warnings                     28 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3515
got                              32 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1594
has                               8 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1602
main                              8 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4049
new                               8 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1046
new                               8 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2349
new                               8 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3102
new                               8 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3435
new                               8 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3740
new                               7 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:401 
new                               9 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:44  
new                               7 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:683 
new                               7 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:976 
parse                            18 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:106 
parse                            14 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:689 
parse_event                      24 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2366
percentage_increase               7 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3992
pre_checksum_results             28 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3578
print_errors                     12 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4402
print_reasons                    12 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4435
prop                             54 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:97  
quote                            77 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:981 
rank_query_times                 16 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3788
rank_result_sets                 14 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3906
rank_results                     16 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3750
rank_warnings                    14 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3817
set                               2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1608
usage_or_errors                   8 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1643

Uncovered Subroutines
---------------------

Subroutine                    Count Location                                           
----------------------------- ----- ---------------------------------------------------
DESTROY                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3398
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3047
__delete_to_select                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2283
__insert_to_select                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2291
__update_to_select                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2308
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1852
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2051
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2323
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2496
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3063
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3239
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3404
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:351 
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3703
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4009
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:658 
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:950 
_die_bad_op                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3695
_get_participants                 0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1315
_make_PID_file                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3363
_make_unrolled_loops              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2637
_remove_PID_file                  0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3385
add_new_attributes                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3013
aggregate                         0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2582
any_unix_timestamp                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2013
attributes                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2686
bucket_idx                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2822
buckets_of                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2838
calculate_statistical_metrics     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2861
check_PID_file                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3322
clone                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1829
convert_select_list               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2274
convert_to_select                 0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2241
copy                              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:333 
daemonize                         0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3285
descr                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1632
disconnect                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:316 
distill                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2192
dump                              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:408 
errors                            0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1622
events_processed                  0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3039
fill_in_dsn                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:218 
find_best_index                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:775 
find_possible_keys                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:793 
fingerprint                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2150
get_aliases                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3154
get_attributes                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3034
get_columns                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:522 
get_databases                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:587 
get_defaults                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1361
get_fks                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:916 
get_groups                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1366
get_hostname                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:306 
get_table_list                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:632 
get_table_status                  0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:606 
get_tmp_table                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:542 
get_triggers                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:553 
has_derived_table                 0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3147
make_PID_file                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3353
make_alt_attrib                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3044
make_checksum                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2044
make_handler                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2696
metrics                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2951
micro_t                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1900
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2094
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2530
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3267
opt_values                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1333
opts                              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1327
parse_options                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:157 
parse_timestamp                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1991
percentage_of                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1930
print_active_handles              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:322 
print_errors                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1656
print_usage                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1666
prompt                            0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1627
prompt_noecho                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1741
quote_val                         0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:989 
read_para_after                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1810
remove_auto_increment             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:944 
remove_comments                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3232
reset_aggregated_data             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2568
results                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2677
save_error                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1617
secs_to_time                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1937
set_defaults                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1349
short_opts                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1343
shorten                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1964
shorten                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2107
sig_int                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4463
sort_indexes                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:756 
split                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3206
split_unquote                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1004
strip_comments                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2100
table_exists                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:821 
top_events                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2975
ts                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1981
type_for                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2691
unix_timestamp                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2003
usage                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:179 
wrap_in_derived                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2315


