---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...kit/mk-upgrade/mk-upgrade   31.1   16.0   15.7   48.4    n/a  100.0   26.5
Total                          31.1   16.0   15.7   48.4    n/a  100.0   26.5
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          mk-upgrade.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Mon Jun 29 14:43:24 2009
Finish:       Mon Jun 29 14:43:25 2009

/home/daniel/dev/maatkit/mk-upgrade/mk-upgrade

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This program is copyright 2009-@CURRENTYEAR@ Percona Inc.
4                                                     # Feedback and improvements are welcome.
5                                                     #
6                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
7                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
8                                                     # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
9                                                     #
10                                                    # This program is free software; you can redistribute it and/or modify it under
11                                                    # the terms of the GNU General Public License as published by the Free Software
12                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
13                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
14                                                    # licenses.
15                                                    #
16                                                    # You should have received a copy of the GNU General Public License along with
17                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
18                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
19                                                    
20             1                    1             8   use strict;
               1                                  3   
               1                                  6   
21             1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  9   
22                                                    
23                                                    our $VERSION = '@VERSION@';
24                                                    our $DISTRIB = '@DISTRIB@';
25                                                    our $SVN_REV = sprintf("%d", (q$Revision: 4004 $ =~ m/(\d+)/g, 0));
26                                                    
27                                                    # ###########################################################################
28                                                    # DSNParser package 3963
29                                                    # ###########################################################################
30             1                    1             6   use strict;
               1                                  2   
               1                                 10   
31             1                    1             5   use warnings FATAL => 'all';
               1                                  2   
               1                                  5   
32                                                    
33                                                    package DSNParser;
34                                                    
35             1                    1            11   use DBI;
               1                                  4   
               1                                  9   
36             1                    1             7   use Data::Dumper;
               1                                  2   
               1                                 10   
37                                                    $Data::Dumper::Indent    = 0;
38                                                    $Data::Dumper::Quotekeys = 0;
39             1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  8   
40                                                    
41             1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                 11   
42                                                    
43                                                    sub new {
44             3                    3            38      my ( $class, @opts ) = @_;
45             3                                120      my $self = {
46                                                          opts => {
47                                                             A => {
48                                                                desc => 'Default character set',
49                                                                dsn  => 'charset',
50                                                                copy => 1,
51                                                             },
52                                                             D => {
53                                                                desc => 'Database to use',
54                                                                dsn  => 'database',
55                                                                copy => 1,
56                                                             },
57                                                             F => {
58                                                                desc => 'Only read default options from the given file',
59                                                                dsn  => 'mysql_read_default_file',
60                                                                copy => 1,
61                                                             },
62                                                             h => {
63                                                                desc => 'Connect to host',
64                                                                dsn  => 'host',
65                                                                copy => 1,
66                                                             },
67                                                             p => {
68                                                                desc => 'Password to use when connecting',
69                                                                dsn  => 'password',
70                                                                copy => 1,
71                                                             },
72                                                             P => {
73                                                                desc => 'Port number to use for connection',
74                                                                dsn  => 'port',
75                                                                copy => 1,
76                                                             },
77                                                             S => {
78                                                                desc => 'Socket file to use for connection',
79                                                                dsn  => 'mysql_socket',
80                                                                copy => 1,
81                                                             },
82                                                             u => {
83                                                                desc => 'User for login if not current user',
84                                                                dsn  => 'user',
85                                                                copy => 1,
86                                                             },
87                                                          },
88                                                       };
89             3                                 16      foreach my $opt ( @opts ) {
90    ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
91    ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
92                                                       }
93             3                                 31      return bless $self, $class;
94                                                    }
95                                                    
96                                                    sub prop {
97            18                   18            79      my ( $self, $prop, $value ) = @_;
98    ***     18     50                          86      if ( @_ > 2 ) {
99    ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
100   ***      0                                  0         $self->{$prop} = $value;
101                                                      }
102           18                                132      return $self->{$prop};
103                                                   }
104                                                   
105                                                   sub parse {
106            6                    6            36      my ( $self, $dsn, $prev, $defaults ) = @_;
107   ***      6     50                          58      if ( !$dsn ) {
108   ***      0                                  0         MKDEBUG && _d('No DSN to parse');
109   ***      0                                  0         return;
110                                                      }
111            6                                 13      MKDEBUG && _d('Parsing', $dsn);
112            6           100                   29      $prev     ||= {};
113   ***      6            50                   29      $defaults ||= {};
114            6                                 18      my %given_props;
115            6                                 15      my %final_props;
116            6                                 18      my %opts = %{$self->{opts}};
               6                                 85   
117                                                   
118            6                                 61      foreach my $dsn_part ( split(/,/, $dsn) ) {
119   ***     11     50                         111         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
120           11                                 64            $given_props{$prop_key} = $prop_val;
121                                                         }
122                                                         else {
123   ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
124   ***      0                                  0            $given_props{h} = $dsn_part;
125                                                         }
126                                                      }
127                                                   
128            6                                 32      foreach my $key ( keys %opts ) {
129           48                                 97         MKDEBUG && _d('Finding value for', $key);
130           48                                159         $final_props{$key} = $given_props{$key};
131           48    100    100                  420         if (   !defined $final_props{$key}
      ***                   66                        
132                                                              && defined $prev->{$key} && $opts{$key}->{copy} )
133                                                         {
134            1                                  4            $final_props{$key} = $prev->{$key};
135            1                                  3            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
136                                                         }
137           48    100                         203         if ( !defined $final_props{$key} ) {
138           36                                115            $final_props{$key} = $defaults->{$key};
139           36                                108            MKDEBUG && _d('Copying value for', $key, 'from defaults');
140                                                         }
141                                                      }
142                                                   
143            6                                 33      foreach my $key ( keys %given_props ) {
144   ***     11     50                          51         die "Unrecognized DSN part '$key' in '$dsn'\n"
145                                                            unless exists $opts{$key};
146                                                      }
147   ***      6     50                          36      if ( (my $required = $self->prop('required')) ) {
148   ***      0                                  0         foreach my $key ( keys %$required ) {
149   ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
150                                                         }
151                                                      }
152                                                   
153            6                                 38      return \%final_props;
154                                                   }
155                                                   
156                                                   sub parse_options {
157   ***      0                    0             0      my ( $self, $o ) = @_;
158   ***      0      0                           0      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
159   ***      0                                  0      my $dsn_string
160                                                         = join(',',
161   ***      0      0                           0             map  { "$_=".$o->get($_); }
162   ***      0                                  0             grep { $o->has($_) && $o->get($_) }
163   ***      0                                  0             keys %{$self->{opts}}
164                                                           );
165   ***      0                                  0      MKDEBUG && _d('DSN string made from options:', $dsn_string);
166   ***      0                                  0      return $self->parse($dsn_string);
167                                                   }
168                                                   
169                                                   sub as_string {
170   ***      0                    0             0      my ( $self, $dsn ) = @_;
171   ***      0      0                           0      return $dsn unless ref $dsn;
172   ***      0      0                           0      return join(',',
173   ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
174   ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
175                                                         sort keys %$dsn );
176                                                   }
177                                                   
178                                                   sub usage {
179   ***      0                    0             0      my ( $self ) = @_;
180   ***      0                                  0      my $usage
181                                                         = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
182                                                         . "  KEY  COPY  MEANING\n"
183                                                         . "  ===  ====  =============================================\n";
184   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
185   ***      0                                  0      foreach my $key ( sort keys %opts ) {
186   ***      0      0      0                    0         $usage .= "  $key    "
187                                                                .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
188                                                                .  ($opts{$key}->{desc} || '[No description]')
189                                                                . "\n";
190                                                      }
191   ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
192   ***      0                                  0      return $usage;
193                                                   }
194                                                   
195                                                   sub get_cxn_params {
196            6                    6            28      my ( $self, $info ) = @_;
197            6                                 18      my $dsn;
198            6                                 18      my %opts = %{$self->{opts}};
               6                                 50   
199   ***      6            50                   32      my $driver = $self->prop('dbidriver') || '';
200   ***      6     50                          27      if ( $driver eq 'Pg' ) {
201   ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
202   ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
203   ***      0             0                    0                        grep { defined $info->{$_} }
204                                                                        qw(h P));
205                                                      }
206                                                      else {
207           12                                114         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
208           30                                106            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
209   ***      6            50                   68                        grep { defined $info->{$_} }
210                                                                        qw(F h P S A))
211                                                            . ';mysql_read_default_group=client';
212                                                      }
213            6                                 17      MKDEBUG && _d($dsn);
214            6                                 64      return ($dsn, $info->{u}, $info->{p});
215                                                   }
216                                                   
217                                                   sub fill_in_dsn {
218   ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
219   ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
220   ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
221   ***      0                                  0      $user =~ s/@.*//;
222   ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
223   ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
224   ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
225   ***      0             0                    0      $dsn->{u} ||= $user;
226   ***      0             0                    0      $dsn->{D} ||= $db;
227                                                   }
228                                                   
229                                                   sub get_dbh {
230            6                    6            37      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
231   ***      6            50                   30      $opts ||= {};
232   ***      6     50                          51      my $defaults = {
233                                                         AutoCommit        => 0,
234                                                         RaiseError        => 1,
235                                                         PrintError        => 0,
236                                                         mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
237                                                      };
238            6                                 31      @{$defaults}{ keys %$opts } = values %$opts;
               6                                 23   
239                                                   
240            6                                 19      my $dbh;
241            6                                 17      my $tries = 2;
242   ***      6            66                   56      while ( !$dbh && $tries-- ) {
243                                                         MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
244            6                                 17            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
245                                                   
246            6                                 21         eval {
247            6                                 57            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
248                                                   
249   ***      6     50                          55            if ( $cxn_string =~ m/mysql/i ) {
250            6                                 16               my $sql;
251                                                   
252            6                                 24               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
253                                                                    . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
254            6                                 12               MKDEBUG && _d($dbh, ':', $sql);
255            6                                716               $dbh->do($sql);
256                                                   
257   ***      6     50                          48               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
258   ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
259   ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
260   ***      0                                  0                  $dbh->do($sql);
261   ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
262   ***      0      0                           0                  if ( $charset eq 'utf8' ) {
263   ***      0      0                           0                     binmode(STDOUT, ':utf8')
264                                                                        or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
265                                                                  }
266                                                                  else {
267   ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
268                                                                  }
269                                                               }
270                                                   
271   ***      6     50                          38               if ( $self->prop('setvars') ) {
272   ***      0                                  0                  $sql = "SET " . $self->prop('setvars');
273   ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
274   ***      0                                  0                  $dbh->do($sql);
275                                                               }
276                                                            }
277                                                         };
278   ***      6     50     33                   90         if ( !$dbh && $EVAL_ERROR ) {
279   ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
280   ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
281   ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
282   ***      0                                  0               delete $defaults->{mysql_enable_utf8};
283                                                            }
284   ***      0      0                           0            if ( !$tries ) {
285   ***      0                                  0               die $EVAL_ERROR;
286                                                            }
287                                                         }
288                                                      }
289                                                   
290            6                                 15      MKDEBUG && _d('DBH info: ',
291                                                         $dbh,
292                                                         Dumper($dbh->selectrow_hashref(
293                                                            'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
294                                                         'Connection info:',      $dbh->{mysql_hostinfo},
295                                                         'Character set info:',   Dumper($dbh->selectall_arrayref(
296                                                                        'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
297                                                         '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
298                                                         '$DBI::VERSION:',        $DBI::VERSION,
299                                                      );
300                                                   
301            6                                 31      return $dbh;
302                                                   }
303                                                   
304                                                   sub get_hostname {
305   ***      0                    0             0      my ( $self, $dbh ) = @_;
306   ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
307   ***      0                                  0         return $host;
308                                                      }
309   ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
310                                                         'SELECT /*!50038 @@hostname, */ 1');
311   ***      0                                  0      return $hostname;
312                                                   }
313                                                   
314                                                   sub disconnect {
315   ***      0                    0             0      my ( $self, $dbh ) = @_;
316   ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
317   ***      0                                  0      $dbh->disconnect;
318                                                   }
319                                                   
320                                                   sub print_active_handles {
321   ***      0                    0             0      my ( $self, $thing, $level ) = @_;
322   ***      0             0                    0      $level ||= 0;
323   ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
324                                                         $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
325                                                         or die "Cannot print: $OS_ERROR";
326   ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
327   ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
328                                                      }
329                                                   }
330                                                   
331                                                   sub copy {
332   ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
333   ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
334   ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
335   ***      0                                  0      my %new_dsn = map {
336   ***      0                                  0         my $key = $_;
337   ***      0                                  0         my $val;
338   ***      0      0                           0         if ( $args{overwrite} ) {
339   ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
340                                                         }
341                                                         else {
342   ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
343                                                         }
344   ***      0                                  0         $key => $val;
345   ***      0                                  0      } keys %{$self->{opts}};
346   ***      0                                  0      return \%new_dsn;
347                                                   }
348                                                   
349                                                   sub _d {
350   ***      0                    0             0      my ($package, undef, $line) = caller 0;
351   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
352   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
353                                                           @_;
354   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
355                                                   }
356                                                   
357                                                   1;
358                                                   
359                                                   # ###########################################################################
360                                                   # End DSNParser package
361                                                   # ###########################################################################
362                                                   
363                                                   # ###########################################################################
364                                                   # Quoter package 3186
365                                                   # ###########################################################################
366            1                    1             8   use strict;
               1                                  2   
               1                                  9   
367            1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  9   
368                                                   
369                                                   package Quoter;
370                                                   
371            1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  8   
372                                                   
373            1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  8   
374                                                   
375                                                   sub new {
376   ***      0                    0             0      my ( $class ) = @_;
377   ***      0                                  0      bless {}, $class;
378                                                   }
379                                                   
380                                                   sub quote {
381   ***      0                    0             0      my ( $self, @vals ) = @_;
382   ***      0                                  0      foreach my $val ( @vals ) {
383   ***      0                                  0         $val =~ s/`/``/g;
384                                                      }
385   ***      0                                  0      return join('.', map { '`' . $_ . '`' } @vals);
      ***      0                                  0   
386                                                   }
387                                                   
388                                                   sub quote_val {
389   ***      0                    0             0      my ( $self, @vals ) = @_;
390                                                      return join(', ',
391                                                         map {
392   ***      0      0                           0            if ( defined $_ ) {
      ***      0                                  0   
393   ***      0                                  0               $_ =~ s/(['\\])/\\$1/g;
394   ***      0      0      0                    0               $_ eq '' || $_ =~ m/^0|\D/ ? "'$_'" : $_;
395                                                            }
396                                                            else {
397   ***      0                                  0               'NULL';
398                                                            }
399                                                         } @vals
400                                                      );
401                                                   }
402                                                   
403                                                   sub split_unquote {
404   ***      0                    0             0      my ( $self, $db_tbl, $default_db ) = @_;
405   ***      0                                  0      $db_tbl =~ s/`//g;
406   ***      0                                  0      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
407   ***      0      0                           0      if ( !$tbl ) {
408   ***      0                                  0         $tbl = $db;
409   ***      0                                  0         $db  = $default_db;
410                                                      }
411   ***      0                                  0      return ($db, $tbl);
412                                                   }
413                                                   
414                                                   1;
415                                                   
416                                                   # ###########################################################################
417                                                   # End Quoter package
418                                                   # ###########################################################################
419                                                   
420                                                   # ###########################################################################
421                                                   # OptionParser package 3945
422                                                   # ###########################################################################
423                                                   package OptionParser;
424                                                   
425            1                    1            10   use strict;
               1                                  2   
               1                                  7   
426            1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  8   
427                                                   
428            1                    1            16   use Getopt::Long;
               1                                  3   
               1                                  7   
429            1                    1             6   use List::Util qw(max);
               1                                  3   
               1                                 16   
430            1                    1             7   use English qw(-no_match_vars);
               1                                  3   
               1                                  6   
431                                                   
432            1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  8   
433                                                   
434                                                   my $POD_link_re = '[LC]<"?([^">]+)"?>';
435                                                   
436                                                   my %attributes = (
437                                                      'type'       => 1,
438                                                      'short form' => 1,
439                                                      'group'      => 1,
440                                                      'default'    => 1,
441                                                      'cumulative' => 1,
442                                                      'negatable'  => 1,
443                                                   );
444                                                   
445                                                   sub new {
446            2                    2            30      my ( $class, %args ) = @_;
447            2                                 10      foreach my $arg ( qw(description) ) {
448   ***      2     50                          13         die "I need a $arg argument" unless $args{$arg};
449                                                      }
450            2                                 25      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
451   ***      2            50                    9      $program_name ||= $PROGRAM_NAME;
452                                                   
453   ***      2     50     50                   76      my $self = {
      ***                   50                        
454                                                         description    => $args{description},
455                                                         prompt         => $args{prompt} || '<options>',
456                                                         strict         => (exists $args{strict} ? $args{strict} : 1),
457                                                         dp             => $args{dp}     || undef,
458                                                         program_name   => $program_name,
459                                                         opts           => {},
460                                                         got_opts       => 0,
461                                                         short_opts     => {},
462                                                         defaults       => {},
463                                                         groups         => {},
464                                                         allowed_groups => {},
465                                                         errors         => [],
466                                                         rules          => [],  # desc of rules for --help
467                                                         mutex          => [],  # rule: opts are mutually exclusive
468                                                         atleast1       => [],  # rule: at least one opt is required
469                                                         disables       => {},  # rule: opt disables other opts 
470                                                         defaults_to    => {},  # rule: opt defaults to value of other opt
471                                                         default_files  => [
472                                                            "/etc/maatkit/maatkit.conf",
473                                                            "/etc/maatkit/$program_name.conf",
474                                                            "$ENV{HOME}/.maatkit.conf",
475                                                            "$ENV{HOME}/.$program_name.conf",
476                                                         ],
477                                                      };
478            2                                 33      return bless $self, $class;
479                                                   }
480                                                   
481                                                   sub get_specs {
482            2                    2             8      my ( $self, $file ) = @_;
483            2                                 11      my @specs = $self->_pod_to_specs($file);
484            2                                 37      $self->_parse_specs(@specs);
485            2                                  7      return;
486                                                   }
487                                                   
488                                                   sub get_defaults_files {
489            2                    2             7      my ( $self ) = @_;
490            2                                 12      return @{$self->{default_files}};
               2                                 19   
491                                                   }
492                                                   
493                                                   sub _pod_to_specs {
494            2                    2             7      my ( $self, $file ) = @_;
495   ***      2            50                   11      $file ||= __FILE__;
496   ***      2     50                          61      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
497                                                   
498            2                                 52      my %types = (
499                                                         string => 's', # standard Getopt type
500                                                         'int'  => 'i', # standard Getopt type
501                                                         float  => 'f', # standard Getopt type
502                                                         Hash   => 'H', # hash, formed from a comma-separated list
503                                                         hash   => 'h', # hash as above, but only if a value is given
504                                                         Array  => 'A', # array, similar to Hash
505                                                         array  => 'a', # array, similar to hash
506                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
507                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
508                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
509                                                      );
510            2                                  6      my @specs = ();
511            2                                  6      my @rules = ();
512            2                                  4      my $para;
513                                                   
514            2                                 11      local $INPUT_RECORD_SEPARATOR = '';
515            2                                 39      while ( $para = <$fh> ) {
516         1146    100                        7156         next unless $para =~ m/^=head1 OPTIONS/;
517            2                                  7         last;
518                                                      }
519                                                   
520            2                                 14      while ( $para = <$fh> ) {
521   ***      2     50                          14         last if $para =~ m/^=over/;
522   ***      0                                  0         chomp $para;
523   ***      0                                  0         $para =~ s/\s+/ /g;
524   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
525   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
526   ***      0                                  0         push @rules, $para;
527                                                      }
528                                                   
529   ***      2     50                          12      die 'POD has no OPTIONS section' unless $para;
530                                                   
531            2                                  8      do {
532           36    100                         229         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
533           34                                 86            chomp $para;
534           34                                 89            MKDEBUG && _d($para);
535           34                                 78            my %attribs;
536                                                   
537           34                                108            $para = <$fh>; # read next paragraph, possibly attributes
538                                                   
539           34    100                         126            if ( $para =~ m/: / ) { # attributes
540           22                                 97               $para =~ s/\s+\Z//g;
541           34                                157               %attribs = map {
542           22                                113                     my ( $attrib, $val) = split(/: /, $_);
543   ***     34     50                         146                     die "Unrecognized attribute for --$option: $attrib"
544                                                                        unless $attributes{$attrib};
545           34                                176                     ($attrib, $val);
546                                                                  } split(/; /, $para);
547           22    100                          94               if ( $attribs{'short form'} ) {
548           12                                 56                  $attribs{'short form'} =~ s/-//;
549                                                               }
550           22                                 90               $para = <$fh>; # read next paragraph, probably short help desc
551                                                            }
552                                                            else {
553           12                                 27               MKDEBUG && _d('Option has no attributes');
554                                                            }
555                                                   
556           34                                220            $para =~ s/\s+\Z//g;
557           34                                220            $para =~ s/\s+/ /g;
558           34                                132            $para =~ s/$POD_link_re/$1/go;
559                                                   
560           34                                121            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
561           34                                 71            MKDEBUG && _d('Short help:', $para);
562                                                   
563   ***     34     50                         132            die "No description after option spec $option" if $para =~ m/^=item/;
564                                                   
565   ***     34     50                         139            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
566   ***      0                                  0               $option = $base_option;
567   ***      0                                  0               $attribs{'negatable'} = 1;
568                                                            }
569                                                   
570           34    100                         540            push @specs, {
      ***            50                               
      ***            50                               
                    100                               
      ***            50                               
      ***            50                               
571                                                               spec  => $option
572                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
573                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
574                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
575                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
576                                                               desc  => $para
577                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
578                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
579                                                            };
580                                                         }
581           36                                198         while ( $para = <$fh> ) {
582   ***     50     50                         157            last unless $para;
583                                                   
584                                                   
585           50    100                         186            if ( $para =~ m/^=head1/ ) {
586            2                                  7               $para = undef; # Can't 'last' out of a do {} block.
587            2                                  9               last;
588                                                            }
589           48    100                         291            last if $para =~ m/^=item --/;
590                                                         }
591                                                      } while ( $para );
592                                                   
593   ***      2     50                           9      die 'No valid specs in POD OPTIONS' unless @specs;
594                                                   
595            2                                 31      close $fh;
596            2                                  8      return @specs, @rules;
597                                                   }
598                                                   
599                                                   sub _parse_specs {
600            2                    2            12      my ( $self, @specs ) = @_;
601            2                                  8      my %disables; # special rule that requires deferred checking
602                                                   
603            2                                 11      foreach my $opt ( @specs ) {
604   ***     34     50                         112         if ( ref $opt ) { # It's an option spec, not a rule.
605                                                            MKDEBUG && _d('Parsing opt spec:',
606           34                                 68               map { ($_, '=>', $opt->{$_}) } keys %$opt);
607                                                   
608           34                                228            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
609   ***     34     50                         136            if ( !$long ) {
610   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
611                                                            }
612           34                                106            $opt->{long} = $long;
613                                                   
614   ***     34     50                         152            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
615           34                                145            $self->{opts}->{$long} = $opt;
616                                                   
617   ***     34     50                         128            if ( length $long == 1 ) {
618   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
619   ***      0                                  0               $self->{short_opts}->{$long} = $long;
620                                                            }
621                                                   
622           34    100                         136            if ( $short ) {
623   ***     12     50                          51               die "Duplicate short option -$short"
624                                                                  if exists $self->{short_opts}->{$short};
625           12                                 45               $self->{short_opts}->{$short} = $long;
626           12                                 39               $opt->{short} = $short;
627                                                            }
628                                                            else {
629           22                                 72               $opt->{short} = undef;
630                                                            }
631                                                   
632   ***     34     50                         164            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
633   ***     34     50                         164            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
634   ***     34     50                         172            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
635                                                   
636   ***     34            50                  129            $opt->{group} ||= 'default';
637           34                                163            $self->{groups}->{ $opt->{group} }->{$long} = 1;
638                                                   
639           34                                100            $opt->{value} = undef;
640           34                                101            $opt->{got}   = 0;
641                                                   
642           34                                160            my ( $type ) = $opt->{spec} =~ m/=(.)/;
643           34                                116            $opt->{type} = $type;
644           34                                 68            MKDEBUG && _d($long, 'type:', $type);
645                                                   
646   ***     34     50     66                  263            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                   33                        
647   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
648                                                                  . "was given when this OptionParser object was created";
649                                                            }
650                                                   
651           34    100    100                  223            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
652                                                   
653   ***     34     50                         160            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
654   ***      0      0                           0               if ( $opt->{is_negatable} ) {
655   ***      0      0                           0                  $def = $def eq 'yes' ? 1
      ***             0                               
656                                                                       : $def eq 'no'  ? 0
657                                                                       : $def;
658                                                               }
659   ***      0      0                           0               $self->{defaults}->{$long} = defined $def ? $def : 1;
660   ***      0                                  0               MKDEBUG && _d($long, 'default:', $def);
661                                                            }
662                                                   
663           34    100                         127            if ( $long eq 'config' ) {
664            2                                 12               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
665                                                            }
666                                                   
667   ***     34     50                         154            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
668   ***      0                                  0               $disables{$long} = $dis;
669   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
670                                                            }
671                                                   
672           34                                157            $self->{opts}->{$long} = $opt;
673                                                         }
674                                                         else { # It's an option rule, not a spec.
675   ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
676   ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
677   ***      0                                  0            my @participants = $self->_get_participants($opt);
678   ***      0                                  0            my $rule_ok = 0;
679                                                   
680   ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
681   ***      0                                  0               $rule_ok = 1;
682   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
683   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
684                                                            }
685   ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
686   ***      0                                  0               $rule_ok = 1;
687   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
688   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
689                                                            }
690   ***      0      0                           0            if ( $opt =~ m/default to/ ) {
691   ***      0                                  0               $rule_ok = 1;
692   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
693   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
694                                                            }
695   ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
696   ***      0                                  0               $rule_ok = 1;
697   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
698   ***      0                                  0               my @groups = split(',', $groups);
699   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
700   ***      0                                  0                  s/\s+//;
701   ***      0                                  0                  $_ => 1;
702                                                               } @groups;
703                                                            }
704                                                   
705   ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
706                                                         }
707                                                      }
708                                                   
709            2                                 16      foreach my $long ( keys %disables ) {
710   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
711   ***      0                                  0         $self->{disables}->{$long} = \@participants;
712   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
713                                                      }
714                                                   
715            2                                  9      return; 
716                                                   }
717                                                   
718                                                   sub _get_participants {
719   ***      0                    0             0      my ( $self, $str ) = @_;
720   ***      0                                  0      my @participants;
721   ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
722   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
723                                                            unless exists $self->{opts}->{$long};
724   ***      0                                  0         push @participants, $long;
725                                                      }
726   ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
727   ***      0                                  0      return @participants;
728                                                   }
729                                                   
730                                                   sub opts {
731   ***      0                    0             0      my ( $self ) = @_;
732   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
733   ***      0                                  0      return %opts;
734                                                   }
735                                                   
736                                                   sub opt_values {
737   ***      0                    0             0      my ( $self ) = @_;
738   ***      0      0                           0      my %opts = map {
739   ***      0                                  0         my $opt = $self->{opts}->{$_}->{short} ? $self->{opts}->{$_}->{short}
740                                                                 : $_;
741   ***      0                                  0         $opt => $self->{opts}->{$_}->{value}
742   ***      0                                  0      } keys %{$self->{opts}};
743   ***      0                                  0      return %opts;
744                                                   }
745                                                   
746                                                   sub short_opts {
747   ***      0                    0             0      my ( $self ) = @_;
748   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
749   ***      0                                  0      return %short_opts;
750                                                   }
751                                                   
752                                                   sub set_defaults {
753   ***      0                    0             0      my ( $self, %defaults ) = @_;
754   ***      0                                  0      $self->{defaults} = {};
755   ***      0                                  0      foreach my $long ( keys %defaults ) {
756   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
757                                                            unless exists $self->{opts}->{$long};
758   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
759   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
760                                                      }
761   ***      0                                  0      return;
762                                                   }
763                                                   
764                                                   sub get_defaults {
765   ***      0                    0             0      my ( $self ) = @_;
766   ***      0                                  0      return $self->{defaults};
767                                                   }
768                                                   
769                                                   sub get_groups {
770   ***      0                    0             0      my ( $self ) = @_;
771   ***      0                                  0      return $self->{groups};
772                                                   }
773                                                   
774                                                   sub _set_option {
775   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
776   ***      0      0                           0      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***             0                               
777                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
778                                                               : die "Getopt::Long gave a nonexistent option: $opt";
779                                                   
780   ***      0                                  0      $opt = $self->{opts}->{$long};
781   ***      0      0                           0      if ( $opt->{is_cumulative} ) {
782   ***      0                                  0         $opt->{value}++;
783                                                      }
784                                                      else {
785   ***      0                                  0         $opt->{value} = $val;
786                                                      }
787   ***      0                                  0      $opt->{got} = 1;
788   ***      0                                  0      MKDEBUG && _d('Got option', $long, '=', $val);
789                                                   }
790                                                   
791                                                   sub get_opts {
792            2                    2             8      my ( $self ) = @_; 
793                                                   
794            2                                  6      foreach my $long ( keys %{$self->{opts}} ) {
               2                                 18   
795           34                                128         $self->{opts}->{$long}->{got} = 0;
796   ***     34     50                         257         $self->{opts}->{$long}->{value}
                    100                               
797                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
798                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
799                                                            : undef;
800                                                      }
801            2                                 10      $self->{got_opts} = 0;
802                                                   
803            2                                  8      $self->{errors} = [];
804                                                   
805   ***      2     50     33                   28      if ( @ARGV && $ARGV[0] eq "--config" ) {
806   ***      0                                  0         shift @ARGV;
807   ***      0                                  0         $self->_set_option('config', shift @ARGV);
808                                                      }
809   ***      2     50                          14      if ( $self->has('config') ) {
810            2                                  6         my @extra_args;
811            2                                 16         foreach my $filename ( split(',', $self->get('config')) ) {
812            8                                 22            eval {
813            8                                 41               push @ARGV, $self->_read_config_file($filename);
814                                                            };
815   ***      8     50                          38            if ( $EVAL_ERROR ) {
816   ***      8     50                          38               if ( $self->got('config') ) {
817   ***      0                                  0                  die $EVAL_ERROR;
818                                                               }
819                                                               elsif ( MKDEBUG ) {
820                                                                  _d($EVAL_ERROR);
821                                                               }
822                                                            }
823                                                         }
824            2                                 11         unshift @ARGV, @extra_args;
825                                                      }
826                                                   
827            2                                 19      Getopt::Long::Configure('no_ignore_case', 'bundling');
828                                                      GetOptions(
829   ***     32                    0           211         map    { $_->{spec} => sub { $self->_set_option(@_); } }
      ***      0                                  0   
              34                                124   
830            2                                 17         grep   { $_->{long} ne 'config' } # --config is handled specially above.
831   ***      2     50                           7         values %{$self->{opts}}
832                                                      ) or $self->save_error('Error parsing options');
833                                                   
834   ***      2     50     33                   66      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
835   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
836                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
837                                                               or die "Cannot print: $OS_ERROR";
838   ***      0                                  0         exit 0;
839                                                      }
840                                                   
841   ***      2     50     33                   21      if ( @ARGV && $self->{strict} ) {
842   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
843                                                      }
844                                                   
845            2                                  6      foreach my $mutex ( @{$self->{mutex}} ) {
               2                                 12   
846   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
847   ***      0      0                           0         if ( @set > 1 ) {
848   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
849   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
850                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
851                                                                    . ' are mutually exclusive.';
852   ***      0                                  0            $self->save_error($err);
853                                                         }
854                                                      }
855                                                   
856            2                                  5      foreach my $required ( @{$self->{atleast1}} ) {
               2                                  9   
857   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
858   ***      0      0                           0         if ( @set == 0 ) {
859   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
860   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
861                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
862   ***      0                                  0            $self->save_error("Specify at least one of $err");
863                                                         }
864                                                      }
865                                                   
866            2                                  6      foreach my $long ( keys %{$self->{opts}} ) {
               2                                 15   
867           34                                131         my $opt = $self->{opts}->{$long};
868   ***     34     50                         173         if ( $opt->{got} ) {
      ***            50                               
869   ***      0      0                           0            if ( exists $self->{disables}->{$long} ) {
870   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
871   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
872   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
873                                                                  'because', $long,'disables them');
874                                                            }
875                                                   
876   ***      0      0                           0            if ( exists $self->{allowed_groups}->{$long} ) {
877                                                   
878   ***      0                                  0               my @restricted_groups = grep {
879   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
880   ***      0                                  0               } keys %{$self->{groups}};
881                                                   
882   ***      0                                  0               my @restricted_opts;
883   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
884   ***      0                                  0                  RESTRICTED_OPT:
885   ***      0                                  0                  foreach my $restricted_opt (
886                                                                     keys %{$self->{groups}->{$restricted_group}} )
887                                                                  {
888   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
889   ***      0      0                           0                     push @restricted_opts, $restricted_opt
890                                                                        if $self->{opts}->{$restricted_opt}->{got};
891                                                                  }
892                                                               }
893                                                   
894   ***      0      0                           0               if ( @restricted_opts ) {
895   ***      0                                  0                  my $err;
896   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
897   ***      0                                  0                     $err = "--$restricted_opts[0]";
898                                                                  }
899                                                                  else {
900   ***      0                                  0                     $err = join(', ',
901   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
902   ***      0                                  0                               grep { $_ } 
903                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
904                                                                            )
905                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
906                                                                  }
907   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
908                                                               }
909                                                            }
910                                                   
911                                                         }
912                                                         elsif ( $opt->{is_required} ) { 
913   ***      0                                  0            $self->save_error("Required option --$long must be specified");
914                                                         }
915                                                   
916           34                                117         $self->_validate_type($opt);
917                                                      }
918                                                   
919            2                                 11      $self->{got_opts} = 1;
920            2                                  6      return;
921                                                   }
922                                                   
923                                                   sub _validate_type {
924           34                   34           112      my ( $self, $opt ) = @_;
925   ***     34    100     66                  283      return unless $opt && $opt->{type};
926           22                                 64      my $val = $opt->{value};
927                                                   
928   ***     22     50     66                  504      if ( $val && $opt->{type} eq 'm' ) {
      ***            50     66                        
      ***            50     66                        
      ***            50     66                        
      ***           100     33                        
      ***                   33                        
      ***                   66                        
929   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
930   ***      0                                  0         my ( $num, $suffix ) = $val =~ m/(\d+)([a-z])?$/;
931   ***      0      0                           0         if ( !$suffix ) {
932   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
933   ***      0             0                    0            $suffix = $s || 's';
934   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
935                                                               $opt->{long}, '(value:', $val, ')');
936                                                         }
937   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
938   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
939                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
940                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
941                                                                 :                  $num * 86400;   # Days
942   ***      0                                  0            $opt->{value} = $val;
943   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
944                                                         }
945                                                         else {
946   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
947                                                         }
948                                                      }
949                                                      elsif ( $val && $opt->{type} eq 'd' ) {
950   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
951   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
952   ***      0                                  0         my $default = {};
953   ***      0      0                           0         if ( $from_key ) {
954   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
955   ***      0                                  0            $default = $self->{dp}->parse(
956                                                               $self->{dp}->as_string($self->{opts}->{$from_key}->{value}) );
957                                                         }
958   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $default);
959                                                      }
960                                                      elsif ( $val && $opt->{type} eq 'z' ) {
961   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
962   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
963   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
964   ***      0      0                           0         if ( defined $num ) {
965   ***      0      0                           0            if ( $factor ) {
966   ***      0                                  0               $num *= $factor_for{$factor};
967   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
968                                                                  'to num', $num, '* factor', $factor);
969                                                            }
970   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
971                                                         }
972                                                         else {
973   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
974                                                         }
975                                                      }
976                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
977   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
978                                                      }
979                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
980   ***      2            50                   28         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
981                                                      }
982                                                      else {
983           20                                 45         MKDEBUG && _d('Nothing to validate for option',
984                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
985                                                      }
986                                                   
987           22                                 69      return;
988                                                   }
989                                                   
990                                                   sub get {
991           18                   18            76      my ( $self, $opt ) = @_;
992   ***     18     50                         482      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
993   ***     18     50     33                  185      die "Option $opt does not exist"
994                                                         unless $long && exists $self->{opts}->{$long};
995           18                                137      return $self->{opts}->{$long}->{value};
996                                                   }
997                                                   
998                                                   sub got {
999            8                    8            31      my ( $self, $opt ) = @_;
1000  ***      8     50                          36      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1001  ***      8     50     33                   77      die "Option $opt does not exist"
1002                                                        unless $long && exists $self->{opts}->{$long};
1003           8                                 47      return $self->{opts}->{$long}->{got};
1004                                                  }
1005                                                  
1006                                                  sub has {
1007           2                    2             9      my ( $self, $opt ) = @_;
1008  ***      2     50                          12      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1009  ***      2     50                          16      return defined $long ? exists $self->{opts}->{$long} : 0;
1010                                                  }
1011                                                  
1012                                                  sub set {
1013  ***      0                    0             0      my ( $self, $opt, $val ) = @_;
1014  ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1015  ***      0      0      0                    0      die "Option $opt does not exist"
1016                                                        unless $long && exists $self->{opts}->{$long};
1017  ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
1018  ***      0                                  0      return;
1019                                                  }
1020                                                  
1021                                                  sub save_error {
1022  ***      0                    0             0      my ( $self, $error ) = @_;
1023  ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
1024                                                  }
1025                                                  
1026                                                  sub errors {
1027  ***      0                    0             0      my ( $self ) = @_;
1028  ***      0                                  0      return $self->{errors};
1029                                                  }
1030                                                  
1031                                                  sub prompt {
1032  ***      0                    0             0      my ( $self ) = @_;
1033  ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
1034                                                  }
1035                                                  
1036                                                  sub descr {
1037  ***      0                    0             0      my ( $self ) = @_;
1038  ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
1039                                                                . "  For more details, please use the --help option, "
1040                                                                . "or try 'perldoc $PROGRAM_NAME' "
1041                                                                . "for complete documentation.";
1042  ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
1043  ***      0                                  0      $descr =~ s/ +$//mg;
1044  ***      0                                  0      return $descr;
1045                                                  }
1046                                                  
1047                                                  sub usage_or_errors {
1048           2                    2             7      my ( $self ) = @_;
1049  ***      2     50                          14      if ( $self->{opts}->{help}->{got} ) {
      ***      2     50                          12   
1050  ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
1051  ***      0                                  0         exit 0;
1052                                                     }
1053                                                     elsif ( scalar @{$self->{errors}} ) {
1054  ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
1055  ***      0                                  0         exit 0;
1056                                                     }
1057           2                                  5      return;
1058                                                  }
1059                                                  
1060                                                  sub print_errors {
1061  ***      0                    0             0      my ( $self ) = @_;
1062  ***      0                                  0      my $usage = $self->prompt() . "\n";
1063  ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
1064  ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
1065                                                                . "\n";
1066                                                     }
1067  ***      0                                  0      return $usage . "\n" . $self->descr();
1068                                                  }
1069                                                  
1070                                                  sub print_usage {
1071  ***      0                    0             0      my ( $self ) = @_;
1072  ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
1073  ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
1074                                                  
1075  ***      0      0                           0      my $maxl = max(
1076  ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
1077                                                        @opts);
1078                                                  
1079  ***      0      0                           0      my $maxs = max(0,
1080  ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
1081  ***      0                                  0         values %{$self->{short_opts}});
1082                                                  
1083  ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
1084  ***      0                                  0      my $rcol = 80 - $lcol - 6;
1085  ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
1086                                                  
1087  ***      0                                  0      $maxs = max($lcol - 3, $maxs);
1088                                                  
1089  ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
1090                                                  
1091  ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
1092  ***      0                                  0      push @groups, 'default';
1093                                                  
1094  ***      0                                  0      foreach my $group ( reverse @groups ) {
1095  ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
1096  ***      0                                  0         foreach my $opt (
      ***      0                                  0   
1097  ***      0                                  0            sort { $a->{long} cmp $b->{long} }
1098                                                           grep { $_->{group} eq $group }
1099                                                           @opts )
1100                                                        {
1101  ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
1102  ***      0                                  0            my $short = $opt->{short};
1103  ***      0                                  0            my $desc  = $opt->{desc};
1104  ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
1105  ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
1106  ***      0             0                    0               $s    ||= 's';
1107  ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
1108  ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
1109                                                                     . "d=days; if no suffix, $s is used.";
1110                                                           }
1111  ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
1112  ***      0                                  0            $desc =~ s/ +$//mg;
1113  ***      0      0                           0            if ( $short ) {
1114  ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
1115                                                           }
1116                                                           else {
1117  ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
1118                                                           }
1119                                                        }
1120                                                     }
1121                                                  
1122  ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
1123  ***      0                                  0         $usage .= "\nRules:\n\n";
1124  ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
1125                                                     }
1126  ***      0      0                           0      if ( $self->{dp} ) {
1127  ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
1128                                                     }
1129  ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
1130  ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
1131  ***      0                                  0         my $val   = $opt->{value};
1132  ***      0             0                    0         my $type  = $opt->{type} || '';
1133  ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
1134  ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
1135                                                                  : !defined $val             ? '(No value)'
1136                                                                  : $type eq 'd'              ? $self->{dp}->as_string($val)
1137                                                                  : $type =~ m/H|h/           ? join(',', sort keys %$val)
1138                                                                  : $type =~ m/A|a/           ? join(',', @$val)
1139                                                                  :                             $val;
1140  ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
1141                                                     }
1142  ***      0                                  0      return $usage;
1143                                                  }
1144                                                  
1145                                                  sub prompt_noecho {
1146  ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
1147  ***      0                                  0      my ( $prompt ) = @_;
1148  ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
1149  ***      0      0                           0      print $prompt
1150                                                        or die "Cannot print: $OS_ERROR";
1151  ***      0                                  0      my $response;
1152  ***      0                                  0      eval {
1153  ***      0                                  0         require Term::ReadKey;
1154  ***      0                                  0         Term::ReadKey::ReadMode('noecho');
1155  ***      0                                  0         chomp($response = <STDIN>);
1156  ***      0                                  0         Term::ReadKey::ReadMode('normal');
1157  ***      0      0                           0         print "\n"
1158                                                           or die "Cannot print: $OS_ERROR";
1159                                                     };
1160  ***      0      0                           0      if ( $EVAL_ERROR ) {
1161  ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
1162                                                     }
1163  ***      0                                  0      return $response;
1164                                                  }
1165                                                  
1166                                                  if ( MKDEBUG ) {
1167                                                     print '# ', $^X, ' ', $], "\n";
1168                                                     my $uname = `uname -a`;
1169                                                     if ( $uname ) {
1170                                                        $uname =~ s/\s+/ /g;
1171                                                        print "# $uname\n";
1172                                                     }
1173                                                     printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
1174                                                        $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
1175                                                        ($main::SVN_REV || ''), __LINE__);
1176                                                     print('# Arguments: ',
1177                                                        join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
1178                                                  }
1179                                                  
1180                                                  sub _read_config_file {
1181           8                    8            33      my ( $self, $filename ) = @_;
1182  ***      8     50                          21      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
1183  ***      0                                  0      my @args;
1184  ***      0                                  0      my $prefix = '--';
1185  ***      0                                  0      my $parse  = 1;
1186                                                  
1187                                                     LINE:
1188  ***      0                                  0      while ( my $line = <$fh> ) {
1189  ***      0                                  0         chomp $line;
1190  ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
1191  ***      0                                  0         $line =~ s/\s+#.*$//g;
1192  ***      0                                  0         $line =~ s/^\s+|\s+$//g;
1193  ***      0      0                           0         if ( $line eq '--' ) {
1194  ***      0                                  0            $prefix = '';
1195  ***      0                                  0            $parse  = 0;
1196  ***      0                                  0            next LINE;
1197                                                        }
1198  ***      0      0      0                    0         if ( $parse
      ***             0                               
1199                                                           && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
1200                                                        ) {
1201  ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
1202                                                        }
1203                                                        elsif ( $line =~ m/./ ) {
1204  ***      0                                  0            push @args, $line;
1205                                                        }
1206                                                        else {
1207  ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
1208                                                        }
1209                                                     }
1210  ***      0                                  0      close $fh;
1211  ***      0                                  0      return @args;
1212                                                  }
1213                                                  
1214                                                  sub read_para_after {
1215  ***      0                    0             0      my ( $self, $file, $regex ) = @_;
1216  ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
1217  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
1218  ***      0                                  0      my $para;
1219  ***      0                                  0      while ( $para = <$fh> ) {
1220  ***      0      0                           0         next unless $para =~ m/^=pod$/m;
1221  ***      0                                  0         last;
1222                                                     }
1223  ***      0                                  0      while ( $para = <$fh> ) {
1224  ***      0      0                           0         next unless $para =~ m/$regex/;
1225  ***      0                                  0         last;
1226                                                     }
1227  ***      0                                  0      $para = <$fh>;
1228  ***      0                                  0      chomp($para);
1229  ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
1230  ***      0                                  0      return $para;
1231                                                  }
1232                                                  
1233                                                  sub clone {
1234  ***      0                    0             0      my ( $self ) = @_;
1235                                                  
1236  ***      0                                  0      my %clone = map {
1237  ***      0                                  0         my $hashref  = $self->{$_};
1238  ***      0                                  0         my $val_copy = {};
1239  ***      0                                  0         foreach my $key ( keys %$hashref ) {
1240  ***      0                                  0            my $ref = ref $hashref->{$key};
1241  ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
1242  ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
1243  ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
1244                                                                             : $hashref->{$key};
1245                                                        }
1246  ***      0                                  0         $_ => $val_copy;
1247                                                     } qw(opts short_opts defaults);
1248                                                  
1249  ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
1250  ***      0                                  0         $clone{$scalar} = $self->{$scalar};
1251                                                     }
1252                                                  
1253  ***      0                                  0      return bless \%clone;     
1254                                                  }
1255                                                  
1256                                                  sub _d {
1257  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1258  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1259  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1260                                                          @_;
1261  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1262                                                  }
1263                                                  
1264                                                  1;
1265                                                  
1266                                                  # ###########################################################################
1267                                                  # End OptionParser package
1268                                                  # ###########################################################################
1269                                                  
1270                                                  # ###########################################################################
1271                                                  # Transformers package 3972
1272                                                  # ###########################################################################
1273                                                  
1274                                                  package Transformers;
1275                                                  
1276           1                    1            10   use strict;
               1                                  2   
               1                                  7   
1277           1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  7   
1278           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  7   
1279           1                    1            14   use Time::Local qw(timelocal);
               1                                  4   
               1                                 10   
1280           1                    1             7   use Digest::MD5 qw(md5_hex);
               1                                  2   
               1                                  7   
1281                                                  
1282           1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  6   
1283                                                  
1284                                                  require Exporter;
1285                                                  our @ISA         = qw(Exporter);
1286                                                  our %EXPORT_TAGS = ();
1287                                                  our @EXPORT      = ();
1288                                                  our @EXPORT_OK   = qw(
1289                                                     micro_t
1290                                                     percentage_of
1291                                                     secs_to_time
1292                                                     shorten
1293                                                     ts
1294                                                     parse_timestamp
1295                                                     unix_timestamp
1296                                                     make_checksum
1297                                                  );
1298                                                  
1299                                                  sub micro_t {
1300  ***      0                    0             0      my ( $t, %args ) = @_;
1301  ***      0      0                           0      my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
1302  ***      0      0                           0      my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
1303  ***      0                                  0      my $f;
1304                                                  
1305  ***      0      0                           0      $t = 0 if $t < 0;
1306                                                  
1307  ***      0      0                           0      $t = sprintf('%.17f', $t) if $t =~ /e/;
1308                                                  
1309  ***      0                                  0      $t =~ s/\.(\d{1,6})\d*/\.$1/;
1310                                                  
1311  ***      0      0      0                    0      if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
1312  ***      0                                  0         $f = ($t * 1000000) . 'us';
1313                                                     }
1314                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
1315  ***      0                                  0         $f = sprintf("%.${p_ms}f", $t * 1000);
1316  ***      0                                  0         $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
1317                                                     }
1318                                                     elsif ($t >= 1) {
1319  ***      0                                  0         $f = sprintf("%.${p_s}f", $t);
1320  ***      0                                  0         $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
1321                                                     }
1322                                                     else {
1323  ***      0                                  0         $f = 0;  # $t should = 0 at this point
1324                                                     }
1325                                                  
1326  ***      0                                  0      return $f;
1327                                                  }
1328                                                  
1329                                                  sub percentage_of {
1330  ***      0                    0             0      my ( $is, $of, %args ) = @_;
1331  ***      0             0                    0      my $p   = $args{p} || 0; # float precision
1332  ***      0      0                           0      my $fmt = $p ? "%.${p}f" : "%d";
1333  ***      0             0                    0      return sprintf $fmt, ($is * 100) / ($of ||= 1);
1334                                                  }
1335                                                  
1336                                                  sub secs_to_time {
1337  ***      0                    0             0      my ( $secs, $fmt ) = @_;
1338  ***      0             0                    0      $secs ||= 0;
1339  ***      0      0                           0      return '00:00' unless $secs;
1340                                                  
1341  ***      0      0      0                    0      $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
1342                                                            : $secs >= 3_600  ? 'h'
1343                                                            :                   'm';
1344                                                  
1345                                                     return
1346  ***      0      0                           0         $fmt eq 'd' ? sprintf(
      ***             0                               
1347                                                           "%d+%02d:%02d:%02d",
1348                                                           int($secs / 86_400),
1349                                                           int(($secs % 86_400) / 3_600),
1350                                                           int(($secs % 3_600) / 60),
1351                                                           $secs % 60)
1352                                                        : $fmt eq 'h' ? sprintf(
1353                                                           "%02d:%02d:%02d",
1354                                                           int(($secs % 86_400) / 3_600),
1355                                                           int(($secs % 3_600) / 60),
1356                                                           $secs % 60)
1357                                                        : sprintf(
1358                                                           "%02d:%02d",
1359                                                           int(($secs % 3_600) / 60),
1360                                                           $secs % 60);
1361                                                  }
1362                                                  
1363                                                  sub shorten {
1364  ***      0                    0             0      my ( $num, %args ) = @_;
1365  ***      0      0                           0      my $p = defined $args{p} ? $args{p} : 2;     # float precision
1366  ***      0      0                           0      my $d = defined $args{d} ? $args{d} : 1_024; # divisor
1367  ***      0                                  0      my $n = 0;
1368  ***      0                                  0      my @units = ('', qw(k M G T P E Z Y));
1369  ***      0             0                    0      while ( $num >= $d && $n < @units - 1 ) {
1370  ***      0                                  0         $num /= $d;
1371  ***      0                                  0         ++$n;
1372                                                     }
1373  ***      0      0      0                    0      return sprintf(
1374                                                        $num =~ m/\./ || $n
1375                                                           ? "%.${p}f%s"
1376                                                           : '%d',
1377                                                        $num, $units[$n]);
1378                                                  }
1379                                                  
1380                                                  sub ts {
1381  ***      0                    0             0      my ( $time ) = @_;
1382  ***      0                                  0      my ( $sec, $min, $hour, $mday, $mon, $year )
1383                                                        = localtime($time);
1384  ***      0                                  0      $mon  += 1;
1385  ***      0                                  0      $year += 1900;
1386  ***      0                                  0      return sprintf("%d-%02d-%02dT%02d:%02d:%02d",
1387                                                        $year, $mon, $mday, $hour, $min, $sec);
1388                                                  }
1389                                                  
1390                                                  sub parse_timestamp {
1391  ***      0                    0             0      my ( $val ) = @_;
1392  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $f)
1393                                                           = $val =~ m/^(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?$/ )
1394                                                     {
1395  ***      0      0                           0         return sprintf "%d-%02d-%02d %02d:%02d:"
      ***             0                               
1396                                                                       . (defined $f ? '%02.6f' : '%02d'),
1397                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
1398                                                     }
1399  ***      0                                  0      return $val;
1400                                                  }
1401                                                  
1402                                                  sub unix_timestamp {
1403  ***      0                    0             0      my ( $val ) = @_;
1404  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s)
1405                                                       = $val =~ m/^(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(?:\.\d+)?$/ )
1406                                                     {
1407  ***      0                                  0         return timelocal($s, $i, $h, $d, $m - 1, $y);
1408                                                     }
1409  ***      0                                  0      return $val;
1410                                                  }
1411                                                  
1412                                                  sub make_checksum {
1413  ***      0                    0             0      my ( $val ) = @_;
1414  ***      0                                  0      my $checksum = uc substr(md5_hex($val), -16);
1415  ***      0                                  0      MKDEBUG && _d($checksum, 'checksum for', $val);
1416  ***      0                                  0      return $checksum;
1417                                                  }
1418                                                  
1419                                                  sub _d {
1420  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1421  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1422  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1423                                                          @_;
1424  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1425                                                  }
1426                                                  
1427                                                  1;
1428                                                  
1429                                                  # ###########################################################################
1430                                                  # End Transformers package
1431                                                  # ###########################################################################
1432                                                  
1433                                                  # ###########################################################################
1434                                                  # QueryRewriter package 3383
1435                                                  # ###########################################################################
1436           1                    1            11   use strict;
               1                                  3   
               1                                  6   
1437           1                    1             5   use warnings FATAL => 'all';
               1                                  3   
               1                                  6   
1438                                                  
1439                                                  package QueryRewriter;
1440                                                  
1441           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  6   
1442                                                  
1443           1                    1            10   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  7   
1444                                                  
1445                                                  our $verbs   = qr{^SHOW|^FLUSH|^COMMIT|^ROLLBACK|^BEGIN|SELECT|INSERT
1446                                                                    |UPDATE|DELETE|REPLACE|^SET|UNION|^START}xi;
1447                                                  my $quote_re = qr/"(?:(?!(?<!\\)").)*"|'(?:(?!(?<!\\)').)*'/; # Costly!
1448                                                  my $bal;
1449                                                  $bal         = qr/
1450                                                                    \(
1451                                                                    (?:
1452                                                                       (?> [^()]+ )    # Non-parens without backtracking
1453                                                                       |
1454                                                                       (??{ $bal })    # Group with matching parens
1455                                                                    )*
1456                                                                    \)
1457                                                                   /x;
1458                                                  
1459                                                  my $olc_re = qr/(?:--|#)[^'"\r\n]*(?=[\r\n]|\Z)/;  # One-line comments
1460                                                  my $mlc_re = qr#/\*[^!].*?\*/#sm;                  # But not /*!version */
1461                                                  
1462                                                  sub new {
1463  ***      0                    0             0      my ( $class, %args ) = @_;
1464  ***      0                                  0      my $self = { %args };
1465  ***      0                                  0      return bless $self, $class;
1466                                                  }
1467                                                  
1468                                                  sub strip_comments {
1469  ***      0                    0             0      my ( $self, $query ) = @_;
1470  ***      0                                  0      $query =~ s/$olc_re//go;
1471  ***      0                                  0      $query =~ s/$mlc_re//go;
1472  ***      0                                  0      return $query;
1473                                                  }
1474                                                  
1475                                                  sub shorten {
1476  ***      0                    0             0      my ( $self, $query, $length ) = @_;
1477  ***      0                                  0      $query =~ s{
1478                                                        \A(
1479                                                           (?:INSERT|REPLACE)
1480                                                           (?:\s+LOW_PRIORITY|DELAYED|HIGH_PRIORITY|IGNORE)?
1481                                                           (?:\s\w+)*\s+\S+\s+VALUES\s*\(.*?\)
1482                                                        )
1483                                                        \s*,\s*\(.*?(ON\s+DUPLICATE|\Z)}
1484                                                        {$1 /*... omitted ...*/$2}xsi;
1485                                                  
1486  ***      0      0                           0      return $query unless $query =~ m/IN\s*\(\s*(?!select)/i;
1487                                                  
1488  ***      0      0      0                    0      if ( $length && length($query) > $length ) {
1489  ***      0                                  0         my ($left, $mid, $right) = $query =~ m{
1490                                                           (\A.*?\bIN\s*\()     # Everything up to the opening of IN list
1491                                                           ([^\)]+)             # Contents of the list
1492                                                           (\).*\Z)             # The rest of the query
1493                                                        }xsi;
1494  ***      0      0                           0         if ( $left ) {
1495  ***      0                                  0            my $targ = $length - length($left) - length($right);
1496  ***      0                                  0            my @vals = split(/,/, $mid);
1497  ***      0                                  0            my @left = shift @vals;
1498  ***      0                                  0            my @right;
1499  ***      0                                  0            my $len  = length($left[0]);
1500  ***      0             0                    0            while ( @vals && $len < $targ / 2 ) {
1501  ***      0                                  0               $len += length($vals[0]) + 1;
1502  ***      0                                  0               push @left, shift @vals;
1503                                                           }
1504  ***      0             0                    0            while ( @vals && $len < $targ ) {
1505  ***      0                                  0               $len += length($vals[-1]) + 1;
1506  ***      0                                  0               unshift @right, pop @vals;
1507                                                           }
1508  ***      0      0                           0            $query = $left . join(',', @left)
1509                                                                  . (@right ? ',' : '')
1510                                                                  . " /*... omitted " . scalar(@vals) . " items ...*/ "
1511                                                                  . join(',', @right) . $right;
1512                                                        }
1513                                                     }
1514                                                  
1515  ***      0                                  0      return $query;
1516                                                  }
1517                                                  
1518                                                  sub fingerprint {
1519  ***      0                    0             0      my ( $self, $query ) = @_;
1520                                                  
1521  ***      0      0                           0      $query =~ m#\ASELECT /\*!40001 SQL_NO_CACHE \*/ \* FROM `# # mysqldump query
1522                                                        && return 'mysqldump';
1523  ***      0      0                           0      $query =~ m#/\*\w+\.\w+:[0-9]/[0-9]\*/#     # mk-table-checksum, etc query
1524                                                        && return 'maatkit';
1525  ***      0      0                           0      $query =~ m/\A# administrator command: /
1526                                                        && return $query;
1527  ***      0      0                           0      $query =~ m/\A\s*(call\s+\S+)\(/i
1528                                                        && return lc($1); # Warning! $1 used, be careful.
1529  ***      0      0                           0      if ( my ($beginning) = $query =~ m/\A((?:INSERT|REPLACE)(?: IGNORE)? INTO .+? VALUES \(.*?\)),\(/i ) {
1530  ***      0                                  0         $query = $beginning; # Shorten multi-value INSERT statements ASAP
1531                                                     }
1532                                                  
1533  ***      0                                  0      $query =~ s/$olc_re//go;
1534  ***      0                                  0      $query =~ s/$mlc_re//go;
1535  ***      0      0                           0      $query =~ s/\Ause \S+\Z/use ?/i       # Abstract the DB in USE
1536                                                        && return $query;
1537                                                  
1538  ***      0                                  0      $query =~ s/\\["']//g;                # quoted strings
1539  ***      0                                  0      $query =~ s/".*?"/?/sg;               # quoted strings
1540  ***      0                                  0      $query =~ s/'.*?'/?/sg;               # quoted strings
1541  ***      0                                  0      $query =~ s/[0-9+-][0-9a-f.xb+-]*/?/g;# Anything vaguely resembling numbers
1542  ***      0                                  0      $query =~ s/[xb.+-]\?/?/g;            # Clean up leftovers
1543  ***      0                                  0      $query =~ s/\A\s+//;                  # Chop off leading whitespace
1544  ***      0                                  0      chomp $query;                         # Kill trailing whitespace
1545  ***      0                                  0      $query =~ tr[ \n\t\r\f][ ]s;          # Collapse whitespace
1546  ***      0                                  0      $query = lc $query;
1547  ***      0                                  0      $query =~ s/\bnull\b/?/g;             # Get rid of NULLs
1548  ***      0                                  0      $query =~ s{                          # Collapse IN and VALUES lists
1549                                                                 \b(in|values?)(?:[\s,]*\([\s?,]*\))+
1550                                                                }
1551                                                                {$1(?+)}gx;
1552  ***      0                                  0      $query =~ s{                          # Collapse UNION
1553                                                                 \b(select\s.*?)(?:(\sunion(?:\sall)?)\s\1)+
1554                                                                }
1555                                                                {$1 /*repeat$2*/}xg;
1556  ***      0                                  0      $query =~ s/\blimit \?(?:, ?\?| offset \?)?/limit ?/; # LIMIT
1557  ***      0                                  0      return $query;
1558                                                  }
1559                                                  
1560                                                  sub distill {
1561  ***      0                    0             0      my ( $self, $query, %args ) = @_;
1562  ***      0             0                    0      my $qp = $args{qp} || $self->{QueryParser};
1563  ***      0      0                           0      die "I need a qp argument" unless $qp;
1564                                                  
1565  ***      0      0                           0      $query =~ m/\A\s*call\s+(\S+)\(/i
1566                                                        && return "CALL $1"; # Warning! $1 used, be careful.
1567  ***      0      0                           0      $query =~ m/\A# administrator/
1568                                                        && return "ADMIN";
1569  ***      0      0                           0      $query =~ m/\A\s*use\s+/
1570                                                        && return "USE";
1571                                                  
1572  ***      0                                  0      my @verbs = $query =~ m/\b($verbs)\b/gio;
1573  ***      0                                  0      @verbs    = do {
1574  ***      0                                  0         my $last = '';
1575  ***      0                                  0         grep { my $pass = $_ ne $last; $last = $_; $pass } map { uc } @verbs;
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
1576                                                     };
1577  ***      0                                  0      my $verbs = join(q{ }, @verbs);
1578  ***      0                                  0      $verbs =~ s/( UNION SELECT)+/ UNION/g;
1579                                                  
1580  ***      0                                  0      my @tables = map {
1581  ***      0                                  0         $_ =~ s/`//g;
1582  ***      0                                  0         $_ =~ s/(_?)[0-9]+/$1?/g;
1583  ***      0                                  0         $_;
1584                                                     } $qp->get_tables($query);
1585                                                  
1586  ***      0                                  0      @tables = do {
1587  ***      0                                  0         my $last = '';
1588  ***      0                                  0         grep { my $pass = $_ ne $last; $last = $_; $pass } @tables;
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
1589                                                     };
1590                                                  
1591  ***      0                                  0      $query = join(q{ }, $verbs, @tables);
1592  ***      0                                  0      return $query;
1593                                                  }
1594                                                  
1595                                                  sub convert_to_select {
1596  ***      0                    0             0      my ( $self, $query ) = @_;
1597  ***      0      0                           0      return unless $query;
1598  ***      0                                  0      $query =~ s{
      ***      0                                  0   
1599                                                                   \A.*?
1600                                                                   update\s+(.*?)
1601                                                                   \s+set\b(.*?)
1602                                                                   (?:\s*where\b(.*?))?
1603                                                                   (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
1604                                                                   \Z
1605                                                                }
1606                                                                {__update_to_select($1, $2, $3, $4)}exsi
1607  ***      0                                  0         || $query =~ s{
1608                                                                      \A.*?
1609                                                                      (?:insert|replace)\s+
1610                                                                      .*?\binto\b(.*?)\(([^\)]+)\)\s*
1611                                                                      values?\s*(\(.*?\))\s*
1612                                                                      (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
1613                                                                      \Z
1614                                                                   }
1615                                                                   {__insert_to_select($1, $2, $3)}exsi
1616  ***      0      0      0                    0         || $query =~ s{
1617                                                                      \A.*?
1618                                                                      delete\s+(.*?)
1619                                                                      \bfrom\b(.*)
1620                                                                      \Z
1621                                                                   }
1622                                                                   {__delete_to_select($1, $2)}exsi;
1623  ***      0                                  0      $query =~ s/\s*on\s+duplicate\s+key\s+update.*\Z//si;
1624  ***      0                                  0      $query =~ s/\A.*?(?=\bSELECT\s*\b)//ism;
1625  ***      0                                  0      return $query;
1626                                                  }
1627                                                  
1628                                                  sub convert_select_list {
1629  ***      0                    0             0      my ( $self, $query ) = @_;
1630  ***      0      0                           0      $query =~ s{
      ***      0                                  0   
1631                                                                 \A\s*select(.*?)\bfrom\b
1632                                                                }
1633                                                                {$1 =~ m/\*/ ? "select 1 from" : "select isnull(coalesce($1)) from"}exi;
1634  ***      0                                  0      return $query;
1635                                                  }
1636                                                  
1637                                                  sub __delete_to_select {
1638  ***      0                    0             0      my ( $delete, $join ) = @_;
1639  ***      0      0                           0      if ( $join =~ m/\bjoin\b/ ) {
1640  ***      0                                  0         return "select 1 from $join";
1641                                                     }
1642  ***      0                                  0      return "select * from $join";
1643                                                  }
1644                                                  
1645                                                  sub __insert_to_select {
1646  ***      0                    0             0      my ( $tbl, $cols, $vals ) = @_;
1647  ***      0                                  0      MKDEBUG && _d('Args:', @_);
1648  ***      0                                  0      my @cols = split(/,/, $cols);
1649  ***      0                                  0      MKDEBUG && _d('Cols:', @cols);
1650  ***      0                                  0      $vals =~ s/^\(|\)$//g; # Strip leading/trailing parens
1651  ***      0                                  0      my @vals = $vals =~ m/($quote_re|[^,]*${bal}[^,]*|[^,]+)/g;
1652  ***      0                                  0      MKDEBUG && _d('Vals:', @vals);
1653  ***      0      0                           0      if ( @cols == @vals ) {
1654  ***      0                                  0         return "select * from $tbl where "
1655  ***      0                                  0            . join(' and ', map { "$cols[$_]=$vals[$_]" } (0..$#cols));
1656                                                     }
1657                                                     else {
1658  ***      0                                  0         return "select * from $tbl limit 1";
1659                                                     }
1660                                                  }
1661                                                  
1662                                                  sub __update_to_select {
1663  ***      0                    0             0      my ( $from, $set, $where, $limit ) = @_;
1664  ***      0      0                           0      return "select $set from $from "
      ***             0                               
1665                                                        . ( $where ? "where $where" : '' )
1666                                                        . ( $limit ? " $limit "      : '' );
1667                                                  }
1668                                                  
1669                                                  sub wrap_in_derived {
1670  ***      0                    0             0      my ( $self, $query ) = @_;
1671  ***      0      0                           0      return unless $query;
1672  ***      0      0                           0      return $query =~ m/\A\s*select/i
1673                                                        ? "select 1 from ($query) as x limit 1"
1674                                                        : $query;
1675                                                  }
1676                                                  
1677                                                  sub _d {
1678  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1679  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1680  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1681                                                          @_;
1682  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1683                                                  }
1684                                                  
1685                                                  1;
1686                                                  
1687                                                  # ###########################################################################
1688                                                  # End QueryRewriter package
1689                                                  # ###########################################################################
1690                                                  
1691                                                  # ###########################################################################
1692                                                  # Processlist package 3571
1693                                                  # ###########################################################################
1694                                                  package Processlist;
1695                                                  
1696           1                    1             7   use strict;
               1                                  3   
               1                                  9   
1697           1                    1             7   use warnings FATAL => 'all';
               1                                  2   
               1                                  5   
1698           1                    1             5   use English qw(-no_match_vars);
               1                                  3   
               1                                  5   
1699                                                  
1700           1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  7   
1701                                                  use constant {
1702           1                                 13      ID      => 0,
1703                                                     USER    => 1,
1704                                                     HOST    => 2,
1705                                                     DB      => 3,
1706                                                     COMMAND => 4,
1707                                                     TIME    => 5,
1708                                                     STATE   => 6,
1709                                                     INFO    => 7,
1710                                                     START   => 8, # Calculated start time of statement
1711                                                     ETIME   => 9, # Exec time of SHOW PROCESSLIST (margin of error in START)
1712                                                     FSEEN   => 10, # First time ever seen
1713           1                    1             6   };
               1                                  3   
1714                                                  
1715                                                  sub new {
1716  ***      0                    0             0      my ( $class ) = @_;
1717  ***      0                                  0      bless {}, $class;
1718                                                  }
1719                                                  
1720                                                  sub parse_event {
1721  ***      0                    0             0      my ( $self, $code, $misc, @callbacks ) = @_;
1722  ***      0                                  0      my $num_events = 0;
1723                                                  
1724  ***      0                                  0      my @curr = sort { $a->[ID] <=> $b->[ID] } @{$code->()};
      ***      0                                  0   
      ***      0                                  0   
1725  ***      0             0                    0      my @prev = @{$misc->{prev} ||= []};
      ***      0                                  0   
1726  ***      0                                  0      my @new; # Will become next invocation's @prev
1727  ***      0                                  0      my ($curr, $prev); # Rows from each source
1728                                                  
1729  ***      0             0                    0      do {
      ***                    0                        
      ***                    0                        
1730  ***      0      0      0                    0         if ( !$curr && @curr ) {
1731  ***      0                                  0            MKDEBUG && _d('Fetching row from curr');
1732  ***      0                                  0            $curr = shift @curr;
1733                                                        }
1734  ***      0      0      0                    0         if ( !$prev && @prev ) {
1735  ***      0                                  0            MKDEBUG && _d('Fetching row from prev');
1736  ***      0                                  0            $prev = shift @prev;
1737                                                        }
1738  ***      0      0      0                    0         if ( $curr || $prev ) {
1739  ***      0      0      0                    0            if ( $curr && $prev && $curr->[ID] == $prev->[ID] ) {
      ***             0      0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
1740  ***      0                                  0               MKDEBUG && _d('$curr and $prev are the same cxn');
1741  ***      0      0                           0               my $fudge = $curr->[TIME] =~ m/\D/ ? 0.001 : 1; # Micro-precision?
1742  ***      0                                  0               my $is_new = 0;
1743  ***      0      0                           0               if ( $prev->[INFO] ) {
1744  ***      0      0      0                    0                  if (!$curr->[INFO] || $prev->[INFO] ne $curr->[INFO]) {
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
1745  ***      0                                  0                     MKDEBUG && _d('$curr has a new query');
1746  ***      0                                  0                     $is_new = 1;
1747                                                                 }
1748                                                                 elsif (defined $curr->[TIME] && $curr->[TIME] < $prev->[TIME]) {
1749  ***      0                                  0                     MKDEBUG && _d('$curr time is less than $prev time');
1750  ***      0                                  0                     $is_new = 1;
1751                                                                 }
1752                                                                 elsif ( $curr->[INFO] && defined $curr->[TIME]
1753                                                                    && $misc->{time} - $curr->[TIME] - $prev->[START]
1754                                                                       - $prev->[ETIME] - $misc->{etime} > $fudge
1755                                                                 ) {
1756  ***      0                                  0                     MKDEBUG && _d('$curr has same query that restarted');
1757  ***      0                                  0                     $is_new = 1;
1758                                                                 }
1759  ***      0      0                           0                  if ( $is_new ) {
1760  ***      0                                  0                     fire_event( $prev, $misc->{time}, @callbacks );
1761                                                                 }
1762                                                              }
1763  ***      0      0                           0               if ( $curr->[INFO] ) {
1764  ***      0      0      0                    0                  if ( $prev->[INFO] && !$is_new ) {
1765  ***      0                                  0                     MKDEBUG && _d('Pushing old history item back onto $prev');
1766  ***      0                                  0                     push @new, [ @$prev ];
1767                                                                 }
1768                                                                 else {
1769  ***      0                                  0                     MKDEBUG && _d('Pushing new history item onto $prev');
1770  ***      0                                  0                     push @new,
1771                                                                       [ @$curr, int($misc->{time} - $curr->[TIME]),
1772                                                                          $misc->{etime}, $misc->{time} ];
1773                                                                 }
1774                                                              }
1775  ***      0                                  0               $curr = $prev = undef; # Fetch another from each.
1776                                                           }
1777                                                           elsif ( !$curr
1778                                                                 || ( $curr && $prev && $curr->[ID] > $prev->[ID] )) {
1779  ***      0                                  0               MKDEBUG && _d('$curr is not in $prev');
1780  ***      0                                  0               fire_event( $prev, $misc->{time}, @callbacks );
1781  ***      0                                  0               $prev = undef;
1782                                                           }
1783                                                           else { # This else must be entered, to prevent infinite loops.
1784  ***      0                                  0               MKDEBUG && _d('$prev is not in $curr');
1785  ***      0      0      0                    0               if ( $curr->[INFO] && defined $curr->[TIME] ) {
1786  ***      0                                  0                  MKDEBUG && _d('Pushing new history item onto $prev');
1787  ***      0                                  0                  push @new,
1788                                                                    [ @$curr, int($misc->{time} - $curr->[TIME]),
1789                                                                       $misc->{etime}, $misc->{time} ];
1790                                                              }
1791  ***      0                                  0               $curr = undef; # No infinite loops.
1792                                                           }
1793                                                        }
1794                                                     } while ( @curr || @prev || $curr || $prev );
1795                                                  
1796  ***      0                                  0      @{$misc->{prev}} = @new;
      ***      0                                  0   
1797                                                  
1798  ***      0                                  0      return $num_events;
1799                                                  }
1800                                                  
1801                                                  sub fire_event {
1802  ***      0                    0             0      my ( $row, $time, @callbacks ) = @_;
1803  ***      0                                  0      my $Query_time = $row->[TIME];
1804  ***      0      0                           0      if ( $row->[TIME] < $time - $row->[FSEEN] ) {
1805  ***      0                                  0         $Query_time = $time - $row->[FSEEN];
1806                                                     }
1807  ***      0                                  0      my $event = {
1808                                                        id         => $row->[ID],
1809                                                        db         => $row->[DB],
1810                                                        user       => $row->[USER],
1811                                                        host       => $row->[HOST],
1812                                                        arg        => $row->[INFO],
1813                                                        bytes      => length($row->[INFO]),
1814                                                        ts         => $row->[START] + $row->[TIME], # Query END time
1815                                                        Query_time => $Query_time,
1816                                                        Lock_time  => 0,               # TODO
1817                                                     };
1818  ***      0                                  0      foreach my $callback ( @callbacks ) {
1819  ***      0      0                           0         last unless $event = $callback->($event);
1820                                                     }
1821                                                  }
1822                                                  
1823                                                  sub find {
1824  ***      0                    0             0      my ( $self, $proclist, %find_spec ) = @_;
1825  ***      0                                  0      my @matches;
1826                                                     QUERY:
1827  ***      0                                  0      foreach my $query ( @$proclist ) {
1828  ***      0                                  0         my $matched = 0;
1829  ***      0      0      0                    0         if ( $find_spec{busy_time} && ($query->{Command} || '') eq 'Query' ) {
      ***                    0                        
1830  ***      0      0                           0            if ( $query->{Time} < $find_spec{busy_time} ) {
1831  ***      0                                  0               MKDEBUG && _d("Query isn't running long enough");
1832  ***      0                                  0               next QUERY;
1833                                                           }
1834  ***      0                                  0            $matched++;
1835                                                        }
1836                                                        PROPERTY:
1837  ***      0                                  0         foreach my $property ( qw(Id User Host db State Command Info) ) {
1838  ***      0                                  0            my $filter = "_find_match_$property";
1839  ***      0      0      0                    0            if ( defined $find_spec{ignore}->{$property}
1840                                                              && $self->$filter($query, $find_spec{ignore}->{$property})
1841                                                           ) {
1842  ***      0                                  0               MKDEBUG && _d("Query matches 'ignore' filter on $property, skipping");
1843  ***      0                                  0               next QUERY;
1844                                                           }
1845  ***      0      0                           0            if ( defined $find_spec{match}->{$property} ) {
1846  ***      0      0                           0               if ( !$self->$filter($query, $find_spec{match}->{$property}) ) {
1847  ***      0                                  0                  MKDEBUG && _d("Query doesn't match 'match' filter on $property, skipping");
1848  ***      0                                  0                  next QUERY;
1849                                                              }
1850  ***      0                                  0               $matched++;
1851                                                           }
1852                                                        }
1853  ***      0      0                           0         if ( $matched ) {
1854  ***      0                                  0            MKDEBUG && _d("Query passed all defined filters, adding");
1855  ***      0                                  0            push @matches, $query;
1856                                                        }
1857                                                     }
1858  ***      0      0      0                    0      if ( @matches && $find_spec{only_oldest} ) {
1859  ***      0                                  0         my ( $oldest ) = reverse sort { $a->{Time} <=> $b->{Time} } @matches;
      ***      0                                  0   
1860  ***      0                                  0         @matches = $oldest;
1861                                                     }
1862  ***      0                                  0      return @matches;
1863                                                  }
1864                                                  
1865                                                  sub _find_match_Id {
1866  ***      0                    0             0      my ( $self, $query, $property ) = @_;
1867  ***      0             0                    0      return defined $property && defined $query->{Id} && $query->{Id} == $property;
      ***                    0                        
1868                                                  }
1869                                                  
1870                                                  sub _find_match_User {
1871  ***      0                    0             0      my ( $self, $query, $property ) = @_;
1872  ***      0             0                    0      return defined $property && defined $query->{User}
      ***                    0                        
1873                                                        && $query->{User} =~ m/$property/;
1874                                                  }
1875                                                  
1876                                                  sub _find_match_Host {
1877  ***      0                    0             0      my ( $self, $query, $property ) = @_;
1878  ***      0             0                    0      return defined $property && defined $query->{Host}
      ***                    0                        
1879                                                        && $query->{Host} =~ m/$property/;
1880                                                  }
1881                                                  
1882                                                  sub _find_match_db {
1883  ***      0                    0             0      my ( $self, $query, $property ) = @_;
1884  ***      0             0                    0      return defined $property && defined $query->{db}
      ***                    0                        
1885                                                        && $query->{db} =~ m/$property/;
1886                                                  }
1887                                                  
1888                                                  sub _find_match_State {
1889  ***      0                    0             0      my ( $self, $query, $property ) = @_;
1890  ***      0             0                    0      return defined $property && defined $query->{State}
      ***                    0                        
1891                                                        && $query->{State} =~ m/$property/;
1892                                                  }
1893                                                  
1894                                                  sub _find_match_Command {
1895  ***      0                    0             0      my ( $self, $query, $property ) = @_;
1896  ***      0             0                    0      return defined $property && defined $query->{Command}
      ***                    0                        
1897                                                        && $query->{Command} =~ m/$property/;
1898                                                  }
1899                                                  
1900                                                  sub _find_match_Info {
1901  ***      0                    0             0      my ( $self, $query, $property ) = @_;
1902  ***      0             0                    0      return defined $property && defined $query->{Info}
      ***                    0                        
1903                                                        && $query->{Info} =~ m/$property/;
1904                                                  }
1905                                                  
1906                                                  sub _d {
1907  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1908  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1909  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1910                                                          @_;
1911  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1912                                                  }
1913                                                  
1914                                                  1;
1915                                                  
1916                                                  # ###########################################################################
1917                                                  # End Processlist package
1918                                                  # ###########################################################################
1919                                                  
1920                                                  # ###########################################################################
1921                                                  # TcpdumpParser package 3951
1922                                                  # ###########################################################################
1923                                                  package TcpdumpParser;
1924                                                  
1925                                                  
1926           1                    1             7   use strict;
               1                                  3   
               1                                  5   
1927           1                    1             5   use warnings FATAL => 'all';
               1                                  3   
               1                                  6   
1928           1                    1             5   use English qw(-no_match_vars);
               1                                  3   
               1                                  5   
1929           1                    1             7   use Data::Dumper;
               1                                  3   
               1                                  5   
1930                                                  $Data::Dumper::Indent   = 1;
1931                                                  $Data::Dumper::Sortkeys = 1;
1932                                                  
1933           1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  7   
1934                                                  
1935                                                  sub new {
1936  ***      0                    0             0      my ( $class, %args ) = @_;
1937  ***      0                                  0      my $self = {};
1938  ***      0                                  0      return bless $self, $class;
1939                                                  }
1940                                                  
1941                                                  sub parse_event {
1942  ***      0                    0             0      my ( $self, $fh, $misc, @callbacks ) = @_;
1943  ***      0                                  0      my $oktorun_here = 1;
1944  ***      0      0                           0      my $oktorun      = $misc->{oktorun} ? $misc->{oktorun} : \$oktorun_here;
1945  ***      0                                  0      my $num_packets = 0;
1946                                                  
1947  ***      0      0                           0      if ( !$fh ) {
1948  ***      0                                  0         MKDEBUG && _d('No filehandle');
1949  ***      0                                  0         return 0;
1950                                                     }
1951                                                  
1952  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = "\n20";
1953                                                  
1954  ***      0                                  0      my $pos_in_log = tell($fh);
1955  ***      0             0                    0      while ( $$oktorun && defined(my $raw_packet = <$fh>) ) {
1956  ***      0                                  0         $raw_packet =~ s/\n20\Z//;
1957  ***      0      0                           0         $raw_packet = "20$raw_packet" unless $raw_packet =~ m/\A20/;
1958                                                  
1959  ***      0                                  0         MKDEBUG && _d('packet:', ++$num_packets, 'pos:', $pos_in_log);
1960  ***      0                                  0         my $packet = $self->_parse_packet($raw_packet);
1961  ***      0                                  0         $packet->{pos_in_log} = $pos_in_log;
1962  ***      0                                  0         $packet->{raw_packet} = $raw_packet;
1963                                                  
1964  ***      0                                  0         foreach my $callback ( @callbacks ) {
1965  ***      0      0                           0            last unless $packet = $callback->($packet);
1966                                                        }
1967                                                  
1968  ***      0                                  0         $pos_in_log = tell($fh) - 1;
1969                                                     }
1970                                                  
1971  ***      0                                  0      MKDEBUG && _d('Done parsing packets;', $num_packets, 'parsed');
1972  ***      0                                  0      return $num_packets;
1973                                                  }
1974                                                  
1975                                                  sub _parse_packet {
1976  ***      0                    0             0      my ( $self, $packet ) = @_;
1977  ***      0      0                           0      die "I need a packet" unless $packet;
1978                                                  
1979  ***      0                                  0      my ( $ts, $source, $dest )  = $packet =~ m/\A(\S+ \S+) IP (\S+) > (\S+):/;
1980  ***      0                                  0      my ( $src_host, $src_port ) = $source =~ m/((?:\d+\.){3}\d+)\.(\w+)/;
1981  ***      0                                  0      my ( $dst_host, $dst_port ) = $dest   =~ m/((?:\d+\.){3}\d+)\.(\w+)/;
1982                                                  
1983  ***      0                                  0      (my $data = join('', $packet =~ m/\t0x[0-9a-f]+:  (.*)/g)) =~ s/\s+//g; 
1984                                                  
1985  ***      0                                  0      my $ip_hlen = hex(substr($data, 1, 1)); # Num of 32-bit words in header.
1986  ***      0                                  0      my $ip_plen = hex(substr($data, 4, 4)); # Num of BYTES in IPv4 datagram.
1987  ***      0      0                           0      my $complete = length($data) == 2 * $ip_plen ? 1 : 0;
1988                                                  
1989  ***      0                                  0      my $tcp_hlen = hex(substr($data, ($ip_hlen + 3) * 8, 1));
1990                                                  
1991  ***      0                                  0      my $seq = hex(substr($data, ($ip_hlen + 1) * 8, 8));
1992  ***      0                                  0      my $ack = hex(substr($data, ($ip_hlen + 2) * 8, 8));
1993                                                  
1994  ***      0                                  0      $data = substr($data, ($ip_hlen + $tcp_hlen) * 8);
1995                                                  
1996  ***      0      0                           0      my $pkt = {
      ***             0                               
1997                                                        ts        => $ts,
1998                                                        seq       => $seq,
1999                                                        ack       => $ack,
2000                                                        src_host  => $src_host,
2001                                                        src_port  => $src_port,
2002                                                        dst_host  => $dst_host,
2003                                                        dst_port  => $dst_port,
2004                                                        complete  => $complete,
2005                                                        ip_hlen   => $ip_hlen,
2006                                                        tcp_hlen  => $tcp_hlen,
2007                                                        dgram_len => $ip_plen,
2008                                                        data_len  => $ip_plen - (($ip_hlen + $tcp_hlen) * 4),
2009                                                        data      => $data ? substr($data, 0, 8).(length $data > 8 ? '...' : '')
2010                                                                           : '',
2011                                                     };
2012  ***      0                                  0      MKDEBUG && _d('packet:', Dumper($pkt));
2013  ***      0                                  0      $pkt->{data} = $data;
2014  ***      0                                  0      return $pkt;
2015                                                  }
2016                                                  
2017                                                  sub _d {
2018  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2019  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2020  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2021                                                          @_;
2022  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2023                                                  }
2024                                                  
2025                                                  1;
2026                                                  
2027                                                  # ###########################################################################
2028                                                  # End TcpdumpParser package
2029                                                  # ###########################################################################
2030                                                  
2031                                                  # ###########################################################################
2032                                                  # MySQLProtocolParser package 3986
2033                                                  # ###########################################################################
2034                                                  package MySQLProtocolParser;
2035                                                  
2036                                                  
2037           1                    1             7   use strict;
               1                                  3   
               1                                  4   
2038           1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  9   
2039           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  4   
2040                                                  
2041                                                  eval {
2042                                                     require IO::Uncompress::Inflate;
2043                                                     IO::Uncompress::Inflate->import(qw(inflate $InflateError));
2044                                                  };
2045                                                  
2046           1                    1             6   use Data::Dumper;
               1                                  2   
               1                                  5   
2047                                                  $Data::Dumper::Indent    = 1;
2048                                                  $Data::Dumper::Sortkeys  = 1;
2049                                                  $Data::Dumper::Quotekeys = 0;
2050                                                  
2051                                                  require Exporter;
2052                                                  our @ISA         = qw(Exporter);
2053                                                  our %EXPORT_TAGS = ();
2054                                                  our @EXPORT      = ();
2055                                                  our @EXPORT_OK   = qw(
2056                                                     parse_error_packet
2057                                                     parse_ok_packet
2058                                                     parse_server_handshake_packet
2059                                                     parse_client_handshake_packet
2060                                                     parse_com_packet
2061                                                     parse_flags
2062                                                  );
2063                                                  
2064           1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  6   
               1                                  7   
2065                                                  use constant {
2066           1                                 34      COM_SLEEP               => '00',
2067                                                     COM_QUIT                => '01',
2068                                                     COM_INIT_DB             => '02',
2069                                                     COM_QUERY               => '03',
2070                                                     COM_FIELD_LIST          => '04',
2071                                                     COM_CREATE_DB           => '05',
2072                                                     COM_DROP_DB             => '06',
2073                                                     COM_REFRESH             => '07',
2074                                                     COM_SHUTDOWN            => '08',
2075                                                     COM_STATISTICS          => '09',
2076                                                     COM_PROCESS_INFO        => '0a',
2077                                                     COM_CONNECT             => '0b',
2078                                                     COM_PROCESS_KILL        => '0c',
2079                                                     COM_DEBUG               => '0d',
2080                                                     COM_PING                => '0e',
2081                                                     COM_TIME                => '0f',
2082                                                     COM_DELAYED_INSERT      => '10',
2083                                                     COM_CHANGE_USER         => '11',
2084                                                     COM_BINLOG_DUMP         => '12',
2085                                                     COM_TABLE_DUMP          => '13',
2086                                                     COM_CONNECT_OUT         => '14',
2087                                                     COM_REGISTER_SLAVE      => '15',
2088                                                     COM_STMT_PREPARE        => '16',
2089                                                     COM_STMT_EXECUTE        => '17',
2090                                                     COM_STMT_SEND_LONG_DATA => '18',
2091                                                     COM_STMT_CLOSE          => '19',
2092                                                     COM_STMT_RESET          => '1a',
2093                                                     COM_SET_OPTION          => '1b',
2094                                                     COM_STMT_FETCH          => '1c',
2095                                                     SERVER_QUERY_NO_GOOD_INDEX_USED => 16,
2096                                                     SERVER_QUERY_NO_INDEX_USED      => 32,
2097           1                    1             7   };
               1                                  7   
2098                                                  
2099                                                  my %com_for = (
2100                                                     '00' => 'COM_SLEEP',
2101                                                     '01' => 'COM_QUIT',
2102                                                     '02' => 'COM_INIT_DB',
2103                                                     '03' => 'COM_QUERY',
2104                                                     '04' => 'COM_FIELD_LIST',
2105                                                     '05' => 'COM_CREATE_DB',
2106                                                     '06' => 'COM_DROP_DB',
2107                                                     '07' => 'COM_REFRESH',
2108                                                     '08' => 'COM_SHUTDOWN',
2109                                                     '09' => 'COM_STATISTICS',
2110                                                     '0a' => 'COM_PROCESS_INFO',
2111                                                     '0b' => 'COM_CONNECT',
2112                                                     '0c' => 'COM_PROCESS_KILL',
2113                                                     '0d' => 'COM_DEBUG',
2114                                                     '0e' => 'COM_PING',
2115                                                     '0f' => 'COM_TIME',
2116                                                     '10' => 'COM_DELAYED_INSERT',
2117                                                     '11' => 'COM_CHANGE_USER',
2118                                                     '12' => 'COM_BINLOG_DUMP',
2119                                                     '13' => 'COM_TABLE_DUMP',
2120                                                     '14' => 'COM_CONNECT_OUT',
2121                                                     '15' => 'COM_REGISTER_SLAVE',
2122                                                     '16' => 'COM_STMT_PREPARE',
2123                                                     '17' => 'COM_STMT_EXECUTE',
2124                                                     '18' => 'COM_STMT_SEND_LONG_DATA',
2125                                                     '19' => 'COM_STMT_CLOSE',
2126                                                     '1a' => 'COM_STMT_RESET',
2127                                                     '1b' => 'COM_SET_OPTION',
2128                                                     '1c' => 'COM_STMT_FETCH',
2129                                                  );
2130                                                  
2131                                                  my %flag_for = (
2132                                                     'CLIENT_LONG_PASSWORD'     => 1,       # new more secure passwords 
2133                                                     'CLIENT_FOUND_ROWS'        => 2,       # Found instead of affected rows 
2134                                                     'CLIENT_LONG_FLAG'         => 4,       # Get all column flags 
2135                                                     'CLIENT_CONNECT_WITH_DB'   => 8,       # One can specify db on connect 
2136                                                     'CLIENT_NO_SCHEMA'         => 16,      # Don't allow database.table.column 
2137                                                     'CLIENT_COMPRESS'          => 32,      # Can use compression protocol 
2138                                                     'CLIENT_ODBC'              => 64,      # Odbc client 
2139                                                     'CLIENT_LOCAL_FILES'       => 128,     # Can use LOAD DATA LOCAL 
2140                                                     'CLIENT_IGNORE_SPACE'      => 256,     # Ignore spaces before '(' 
2141                                                     'CLIENT_PROTOCOL_41'       => 512,     # New 4.1 protocol 
2142                                                     'CLIENT_INTERACTIVE'       => 1024,    # This is an interactive client 
2143                                                     'CLIENT_SSL'               => 2048,    # Switch to SSL after handshake 
2144                                                     'CLIENT_IGNORE_SIGPIPE'    => 4096,    # IGNORE sigpipes 
2145                                                     'CLIENT_TRANSACTIONS'      => 8192,    # Client knows about transactions 
2146                                                     'CLIENT_RESERVED'          => 16384,   # Old flag for 4.1 protocol  
2147                                                     'CLIENT_SECURE_CONNECTION' => 32768,   # New 4.1 authentication 
2148                                                     'CLIENT_MULTI_STATEMENTS'  => 65536,   # Enable/disable multi-stmt support 
2149                                                     'CLIENT_MULTI_RESULTS'     => 131072,  # Enable/disable multi-results 
2150                                                  );
2151                                                  
2152                                                  sub new {
2153  ***      0                    0             0      my ( $class, %args ) = @_;
2154  ***      0                                  0      my $self = {
2155                                                        server      => $args{server},
2156                                                        version     => '41',
2157                                                        sessions    => {},
2158                                                        o           => $args{o},
2159                                                        raw_packets => [],  # Raw tcpdump packets before event.
2160                                                     };
2161  ***      0                                  0      return bless $self, $class;
2162                                                  }
2163                                                  
2164                                                  sub parse_packet {
2165  ***      0                    0             0      my ( $self, $packet, $misc ) = @_;
2166                                                  
2167  ***      0                                  0      my $from  = "$packet->{src_host}:$packet->{src_port}";
2168  ***      0                                  0      my $to    = "$packet->{dst_host}:$packet->{dst_port}";
2169  ***      0      0      0                    0      $self->{server} ||= $from =~ m/:(?:3306|mysql)$/ ? $from
      ***             0                               
2170                                                                       : $to   =~ m/:(?:3306|mysql)$/ ? $to
2171                                                                       :                                undef;
2172  ***      0      0                           0      my $client = $from eq $self->{server} ? $to : $from;
2173  ***      0                                  0      MKDEBUG && _d('Client:', $client);
2174                                                  
2175  ***      0      0                           0      if ( !exists $self->{sessions}->{$client} ) {
2176  ***      0                                  0         MKDEBUG && _d('New session');
2177  ***      0                                  0         $self->{sessions}->{$client} = {
2178                                                           client      => $client,
2179                                                           ts          => $packet->{ts},
2180                                                           state       => undef,
2181                                                           compress    => undef,
2182                                                        };
2183                                                     };
2184  ***      0                                  0      my $session = $self->{sessions}->{$client};
2185  ***      0                                  0      $packet->{session_state} = $session->{state};
2186                                                  
2187  ***      0      0                           0      if ( $packet->{data_len} == 0 ) {
2188  ***      0                                  0         MKDEBUG && _d('No TCP/MySQL data');
2189  ***      0      0      0                    0         if ( ($session->{state} || '') eq 'closing' ) {
2190  ***      0                                  0            delete $self->{sessions}->{$session->{client}};
2191  ***      0                                  0            MKDEBUG && _d('Session deleted'); 
2192                                                        }
2193  ***      0                                  0         return;
2194                                                     }
2195                                                  
2196  ***      0      0                           0      if ( $session->{compress} ) {
2197  ***      0      0                           0         return unless uncompress_packet($packet);
2198                                                     }
2199                                                  
2200  ***      0                                  0      remove_mysql_header($packet);
2201                                                  
2202  ***      0                                  0      my $event;
2203  ***      0      0                           0      if ( $from eq $self->{server} ) {
      ***             0                               
2204  ***      0                                  0         $event = $self->_packet_from_server($packet, $session, $misc);
2205                                                     }
2206                                                     elsif ( $from eq $client ) {
2207  ***      0                                  0         $event = $self->_packet_from_client($packet, $session, $misc);
2208                                                     }
2209                                                     else {
2210  ***      0                                  0         MKDEBUG && _d('Packet origin unknown');
2211                                                     }
2212                                                  
2213  ***      0                                  0      MKDEBUG && _d('Done parsing packet; client state:', $session->{state});
2214  ***      0                                  0      return $event;
2215                                                  }
2216                                                  
2217                                                  sub _packet_from_server {
2218  ***      0                    0             0      my ( $self, $packet, $session, $misc ) = @_;
2219  ***      0      0                           0      die "I need a packet"  unless $packet;
2220  ***      0      0                           0      die "I need a session" unless $session;
2221                                                  
2222  ***      0                                  0      MKDEBUG && _d('Packet is from server; client state:', $session->{state});
2223  ***      0                                  0      push @{$self->{raw_packets}}, $packet->{raw_packet};
      ***      0                                  0   
2224                                                  
2225  ***      0      0      0                    0      if ( ($session->{server_seq} || '') eq $packet->{seq} ) {
2226  ***      0                                  0         MKDEBUG && _d('TCP retransmission');
2227  ***      0                                  0         return;
2228                                                     }
2229  ***      0                                  0      $session->{server_seq} = $packet->{seq};
2230                                                     
2231  ***      0                                  0      my $data = $packet->{data};
2232                                                  
2233                                                  
2234  ***      0                                  0      my ( $first_byte ) = substr($data, 0, 2, '');
2235  ***      0                                  0      MKDEBUG && _d('First byte of packet:', $first_byte);
2236  ***      0      0                           0      if ( !$first_byte ) {
2237  ***      0                                  0         $self->fail_session($session, 'no first byte');
2238  ***      0                                  0         return;
2239                                                     }
2240                                                  
2241  ***      0      0                           0      if ( !$session->{state} ) {
2242  ***      0      0      0                    0         if ( $first_byte eq '0a'
      ***                    0                        
2243                                                             && length $data >= 33
2244                                                             && $data =~ m/00{13}/ )
2245                                                        {
2246  ***      0                                  0            my $handshake = parse_server_handshake_packet($data);
2247  ***      0      0                           0            if ( !$handshake ) {
2248  ***      0                                  0               $self->fail_session($session, 'failed to parse server handshake');
2249  ***      0                                  0               return;
2250                                                           }
2251  ***      0                                  0            $session->{state}     = 'server_handshake';
2252  ***      0                                  0            $session->{thread_id} = $handshake->{thread_id};
2253                                                        }
2254                                                        else {
2255  ***      0                                  0            MKDEBUG && _d('Ignoring mid-stream server response');
2256  ***      0                                  0            return;
2257                                                        }
2258                                                     }
2259                                                     else {
2260  ***      0      0      0                    0         if ( $first_byte eq '00' ) { 
      ***             0                               
      ***             0                               
2261  ***      0      0      0                    0            if ( ($session->{state} || '') eq 'client_auth' ) {
      ***             0                               
2262  ***      0                                  0               $session->{state} = 'ready';
2263                                                  
2264  ***      0                                  0               $session->{compress} = $session->{will_compress};
2265  ***      0                                  0               delete $session->{will_compress};
2266  ***      0                                  0               MKDEBUG && $session->{compress} && _d('Packets will be compressed');
2267                                                  
2268  ***      0                                  0               MKDEBUG && _d('Admin command: Connect');
2269  ***      0                                  0               return $self->_make_event(
2270                                                                 {  cmd => 'Admin',
2271                                                                    arg => 'administrator command: Connect',
2272                                                                    ts  => $packet->{ts}, # Events are timestamped when they end
2273                                                                 },
2274                                                                 $packet, $session
2275                                                              );
2276                                                           }
2277                                                           elsif ( $session->{cmd} ) {
2278  ***      0                                  0               my $ok  = parse_ok_packet($data);
2279  ***      0      0                           0               if ( !$ok ) {
2280  ***      0                                  0                  $self->fail_session($session, 'failed to parse OK packet');
2281  ***      0                                  0                  return;
2282                                                              }
2283  ***      0                                  0               my $com = $session->{cmd}->{cmd};
2284  ***      0                                  0               my $arg;
2285                                                  
2286  ***      0      0                           0               if ( $com eq COM_QUERY ) {
2287  ***      0                                  0                  $com = 'Query';
2288  ***      0                                  0                  $arg = $session->{cmd}->{arg};
2289                                                              }
2290                                                              else {
2291  ***      0                                  0                  $arg = 'administrator command: '
2292                                                                      . ucfirst(lc(substr($com_for{$com}, 4)));
2293  ***      0                                  0                  $com = 'Admin';
2294                                                              }
2295                                                  
2296  ***      0                                  0               $session->{state} = 'ready';
2297  ***      0                                  0               return $self->_make_event(
2298                                                                 {  cmd           => $com,
2299                                                                    arg           => $arg,
2300                                                                    ts            => $packet->{ts},
2301                                                                    Insert_id     => $ok->{insert_id},
2302                                                                    Warning_count => $ok->{warnings},
2303                                                                    Rows_affected => $ok->{affected_rows},
2304                                                                 },
2305                                                                 $packet, $session
2306                                                              );
2307                                                           } 
2308                                                        }
2309                                                        elsif ( $first_byte eq 'ff' ) {
2310  ***      0                                  0            my $error = parse_error_packet($data);
2311  ***      0      0                           0            if ( !$error ) {
2312  ***      0                                  0               $self->fail_session($session, 'failed to parse error packet');
2313  ***      0                                  0               return;
2314                                                           }
2315  ***      0                                  0            my $event;
2316                                                  
2317  ***      0      0                           0            if ( $session->{state} eq 'client_auth' ) {
      ***             0                               
2318  ***      0                                  0               MKDEBUG && _d('Connection failed');
2319  ***      0                                  0               $event = {
2320                                                                 cmd       => 'Admin',
2321                                                                 arg       => 'administrator command: Connect',
2322                                                                 ts        => $packet->{ts},
2323                                                                 Error_no  => $error->{errno},
2324                                                              };
2325  ***      0                                  0               $session->{state} = 'closing';
2326                                                           }
2327                                                           elsif ( $session->{cmd} ) {
2328  ***      0                                  0               my $com = $session->{cmd}->{cmd};
2329  ***      0                                  0               my $arg;
2330                                                  
2331  ***      0      0                           0               if ( $com eq COM_QUERY ) {
2332  ***      0                                  0                  $com = 'Query';
2333  ***      0                                  0                  $arg = $session->{cmd}->{arg};
2334                                                              }
2335                                                              else {
2336  ***      0                                  0                  $arg = 'administrator command: '
2337                                                                      . ucfirst(lc(substr($com_for{$com}, 4)));
2338  ***      0                                  0                  $com = 'Admin';
2339                                                              }
2340  ***      0                                  0               $event = {
2341                                                                 cmd       => $com,
2342                                                                 arg       => $arg,
2343                                                                 ts        => $packet->{ts},
2344                                                                 Error_no  => $error->{errno},
2345                                                              };
2346  ***      0                                  0               $session->{state} = 'ready';
2347                                                           }
2348                                                  
2349  ***      0                                  0            return $self->_make_event($event, $packet, $session);
2350                                                        }
2351                                                        elsif ( $first_byte eq 'fe' && $packet->{mysql_data_len} < 9 ) {
2352  ***      0      0      0                    0            if ( $packet->{mysql_data_len} == 1
      ***                    0                        
2353                                                                && $session->{state} eq 'client_auth'
2354                                                                && $packet->{number} == 2 )
2355                                                           {
2356  ***      0                                  0               MKDEBUG && _d('Server has old password table;',
2357                                                                 'client will resend password using old algorithm');
2358  ***      0                                  0               $session->{state} = 'client_auth_resend';
2359                                                           }
2360                                                           else {
2361  ***      0                                  0               MKDEBUG && _d('Got an EOF packet');
2362  ***      0                                  0               die "You should not have gotten here";
2363                                                           }
2364                                                        }
2365                                                        else {
2366  ***      0      0                           0            if ( $session->{cmd} ) {
2367  ***      0                                  0               MKDEBUG && _d('Got a row/field/result packet');
2368  ***      0                                  0               my $com = $session->{cmd}->{cmd};
2369  ***      0                                  0               MKDEBUG && _d('Responding to client', $com_for{$com});
2370  ***      0                                  0               my $event = { ts  => $packet->{ts} };
2371  ***      0      0                           0               if ( $com eq COM_QUERY ) {
2372  ***      0                                  0                  $event->{cmd} = 'Query';
2373  ***      0                                  0                  $event->{arg} = $session->{cmd}->{arg};
2374                                                              }
2375                                                              else {
2376  ***      0                                  0                  $event->{arg} = 'administrator command: '
2377                                                                      . ucfirst(lc(substr($com_for{$com}, 4)));
2378  ***      0                                  0                  $event->{cmd} = 'Admin';
2379                                                              }
2380                                                  
2381  ***      0      0                           0               if ( $packet->{complete} ) {
2382  ***      0                                  0                  my ( $warning_count, $status_flags )
2383                                                                    = $data =~ m/fe(.{4})(.{4})\Z/;
2384  ***      0      0                           0                  if ( $warning_count ) { 
2385  ***      0                                  0                     $event->{Warnings} = to_num($warning_count);
2386  ***      0                                  0                     my $flags = to_num($status_flags); # TODO set all flags?
2387  ***      0      0                           0                     $event->{No_good_index_used}
2388                                                                       = $flags & SERVER_QUERY_NO_GOOD_INDEX_USED ? 1 : 0;
2389  ***      0      0                           0                     $event->{No_index_used}
2390                                                                       = $flags & SERVER_QUERY_NO_INDEX_USED ? 1 : 0;
2391                                                                 }
2392                                                              }
2393                                                  
2394  ***      0                                  0               $session->{state} = 'ready';
2395  ***      0                                  0               return $self->_make_event($event, $packet, $session);
2396                                                           }
2397                                                           else {
2398  ***      0                                  0               MKDEBUG && _d('Unknown in-stream server response');
2399                                                           }
2400                                                        }
2401                                                     }
2402                                                  
2403  ***      0                                  0      return;
2404                                                  }
2405                                                  
2406                                                  sub _packet_from_client {
2407  ***      0                    0             0      my ( $self, $packet, $session, $misc ) = @_;
2408  ***      0      0                           0      die "I need a packet"  unless $packet;
2409  ***      0      0                           0      die "I need a session" unless $session;
2410                                                  
2411  ***      0                                  0      MKDEBUG && _d('Packet is from client; state:', $session->{state});
2412  ***      0                                  0      push @{$self->{raw_packets}}, $packet->{raw_packet};
      ***      0                                  0   
2413                                                  
2414  ***      0      0      0                    0      if ( ($session->{client_seq} || '') eq $packet->{seq} ) {
2415  ***      0                                  0         MKDEBUG && _d('TCP retransmission');
2416  ***      0                                  0         return;
2417                                                     }
2418  ***      0                                  0      $session->{client_seq} = $packet->{seq};
2419                                                  
2420  ***      0                                  0      my $data  = $packet->{data};
2421  ***      0                                  0      my $ts    = $packet->{ts};
2422                                                  
2423  ***      0      0      0                    0      if ( ($session->{state} || '') eq 'server_handshake' ) {
      ***             0      0                        
      ***             0      0                        
2424  ***      0                                  0         MKDEBUG && _d('Expecting client authentication packet');
2425  ***      0                                  0         my $handshake = parse_client_handshake_packet($data);
2426  ***      0      0                           0         if ( !$handshake ) {
2427  ***      0                                  0            $self->fail_session($session, 'failed to parse client handshake');
2428  ***      0                                  0            return;
2429                                                        }
2430  ***      0                                  0         $session->{state}         = 'client_auth';
2431  ***      0                                  0         $session->{pos_in_log}    = $packet->{pos_in_log};
2432  ***      0                                  0         $session->{user}          = $handshake->{user};
2433  ***      0                                  0         $session->{db}            = $handshake->{db};
2434                                                  
2435  ***      0                                  0         $session->{will_compress} = $handshake->{flags}->{CLIENT_COMPRESS};
2436                                                     }
2437                                                     elsif ( ($session->{state} || '') eq 'client_auth_resend' ) {
2438  ***      0                                  0         MKDEBUG && _d('Client resending password using old algorithm');
2439  ***      0                                  0         $session->{state} = 'client_auth';
2440                                                     }
2441                                                     elsif ( ($session->{state} || '') eq 'awaiting_reply' ) {
2442  ***      0      0                           0         my $arg = $session->{cmd}->{arg} ? substr($session->{cmd}->{arg}, 0, 50)
2443                                                                : 'unknown';
2444  ***      0                                  0         MKDEBUG && _d('More data for previous command:', $arg, '...'); 
2445  ***      0                                  0         return;
2446                                                     }
2447                                                     else {
2448                                                  
2449  ***      0      0                           0         if ( !defined $session->{compress} ) {
2450  ***      0      0                           0            return unless $self->detect_compression($packet, $session);
2451  ***      0                                  0            $data = $packet->{data};
2452                                                        }
2453                                                  
2454  ***      0                                  0         my $com = parse_com_packet($data, $packet->{mysql_data_len});
2455  ***      0      0                           0         if ( !$com ) {
2456  ***      0                                  0            $self->fail_session($session, 'failed to parse COM packet');
2457  ***      0                                  0            return;
2458                                                        }
2459  ***      0                                  0         $session->{state}      = 'awaiting_reply';
2460  ***      0                                  0         $session->{pos_in_log} = $packet->{pos_in_log};
2461  ***      0                                  0         $session->{ts}         = $ts;
2462  ***      0                                  0         $session->{cmd}        = {
2463                                                           cmd => $com->{code},
2464                                                           arg => $com->{data},
2465                                                        };
2466                                                  
2467  ***      0      0                           0         if ( $com->{code} eq COM_QUIT ) { # Fire right away; will cleanup later.
2468  ***      0                                  0            MKDEBUG && _d('Got a COM_QUIT');
2469  ***      0                                  0            $session->{state} = 'closing';
2470  ***      0                                  0            return $self->_make_event(
2471                                                              {  cmd       => 'Admin',
2472                                                                 arg       => 'administrator command: Quit',
2473                                                                 ts        => $ts,
2474                                                              },
2475                                                              $packet, $session
2476                                                           );
2477                                                        }
2478                                                     }
2479                                                  
2480  ***      0                                  0      return;
2481                                                  }
2482                                                  
2483                                                  sub _make_event {
2484  ***      0                    0             0      my ( $self, $event, $packet, $session ) = @_;
2485  ***      0                                  0      MKDEBUG && _d('Making event');
2486                                                  
2487  ***      0                                  0      $self->{raw_packets} = [];
2488                                                  
2489  ***      0                                  0      my ($host, $port) = $session->{client} =~ m/((?:\d+\.){3}\d+)\:(\w+)/;
2490  ***      0      0      0                    0      return $event = {
      ***             0      0                        
      ***                    0                        
2491                                                        cmd        => $event->{cmd},
2492                                                        arg        => $event->{arg},
2493                                                        bytes      => length( $event->{arg} ),
2494                                                        ts         => tcp_timestamp( $event->{ts} ),
2495                                                        host       => $host,
2496                                                        ip         => $host,
2497                                                        port       => $port,
2498                                                        db         => $session->{db},
2499                                                        user       => $session->{user},
2500                                                        Thread_id  => $session->{thread_id},
2501                                                        pos_in_log => $session->{pos_in_log},
2502                                                        Query_time => timestamp_diff($session->{ts}, $packet->{ts}),
2503                                                        Error_no   => ($event->{Error_no} || 0),
2504                                                        Rows_affected      => ($event->{Rows_affected} || 0),
2505                                                        Warning_count      => ($event->{Warning_count} || 0),
2506                                                        No_good_index_used => ($event->{No_good_index_used} ? 'Yes' : 'No'),
2507                                                        No_index_used      => ($event->{No_index_used}      ? 'Yes' : 'No'),
2508                                                     };
2509                                                  }
2510                                                  
2511                                                  sub tcp_timestamp {
2512  ***      0                    0             0      my ( $ts ) = @_;
2513  ***      0                                  0      $ts =~ s/^\d\d(\d\d)-(\d\d)-(\d\d)/$1$2$3/;
2514  ***      0                                  0      return $ts;
2515                                                  }
2516                                                  
2517                                                  sub timestamp_diff {
2518  ***      0                    0             0      my ( $start, $end ) = @_;
2519  ***      0                                  0      my $sd = substr($start, 0, 11, '');
2520  ***      0                                  0      my $ed = substr($end,   0, 11, '');
2521  ***      0                                  0      my ( $sh, $sm, $ss ) = split(/:/, $start);
2522  ***      0                                  0      my ( $eh, $em, $es ) = split(/:/, $end);
2523  ***      0                                  0      my $esecs = ($eh * 3600 + $em * 60 + $es);
2524  ***      0                                  0      my $ssecs = ($sh * 3600 + $sm * 60 + $ss);
2525  ***      0      0                           0      if ( $sd eq $ed ) {
2526  ***      0                                  0         return sprintf '%.6f', $esecs - $ssecs;
2527                                                     }
2528                                                     else { # Assume only one day boundary has been crossed, no DST, etc
2529  ***      0                                  0         return sprintf '%.6f', ( 86_400 - $ssecs ) + $esecs;
2530                                                     }
2531                                                  }
2532                                                  
2533                                                  sub to_string {
2534  ***      0                    0             0      my ( $data ) = @_;
2535  ***      0                                  0      $data = pack('H*', $data);
2536  ***      0                                  0      return $data;
2537                                                  }
2538                                                  
2539                                                  sub to_num {
2540  ***      0                    0             0      my ( $str ) = @_;
2541  ***      0                                  0      my @bytes = $str =~ m/(..)/g;
2542  ***      0                                  0      my $result = 0;
2543  ***      0                                  0      foreach my $i ( 0 .. $#bytes ) {
2544  ***      0                                  0         $result += hex($bytes[$i]) * (16 ** ($i * 2));
2545                                                     }
2546  ***      0                                  0      return $result;
2547                                                  }
2548                                                  
2549                                                  sub get_lcb {
2550  ***      0                    0             0      my ( $string ) = @_;
2551  ***      0                                  0      my $first_byte = hex(substr($$string, 0, 2, ''));
2552  ***      0      0                           0      if ( $first_byte < 251 ) {
      ***             0                               
      ***             0                               
      ***             0                               
2553  ***      0                                  0         return $first_byte;
2554                                                     }
2555                                                     elsif ( $first_byte == 252 ) {
2556  ***      0                                  0         return to_num(substr($$string, 0, 4, ''));
2557                                                     }
2558                                                     elsif ( $first_byte == 253 ) {
2559  ***      0                                  0         return to_num(substr($$string, 0, 6, ''));
2560                                                     }
2561                                                     elsif ( $first_byte == 254 ) {
2562  ***      0                                  0         return to_num(substr($$string, 0, 16, ''));
2563                                                     }
2564                                                  }
2565                                                  
2566                                                  sub parse_error_packet {
2567  ***      0                    0             0      my ( $data ) = @_;
2568  ***      0      0                           0      die "I need data" unless $data;
2569  ***      0                                  0      MKDEBUG && _d('ERROR data:', $data);
2570  ***      0      0                           0      if ( length $data < 16 ) {
2571  ***      0                                  0         MKDEBUG && _d('Error packet is too short:', $data);
2572  ***      0                                  0         return;
2573                                                     }
2574  ***      0                                  0      my $errno    = to_num(substr($data, 0, 4));
2575  ***      0                                  0      my $marker   = to_string(substr($data, 4, 2));
2576  ***      0      0                           0      return unless $marker eq '#';
2577  ***      0                                  0      my $sqlstate = to_string(substr($data, 6, 10));
2578  ***      0                                  0      my $message  = to_string(substr($data, 16));
2579  ***      0                                  0      my $pkt = {
2580                                                        errno    => $errno,
2581                                                        sqlstate => $marker . $sqlstate,
2582                                                        message  => $message,
2583                                                     };
2584  ***      0                                  0      MKDEBUG && _d('Error packet:', Dumper($pkt));
2585  ***      0                                  0      return $pkt;
2586                                                  }
2587                                                  
2588                                                  sub parse_ok_packet {
2589  ***      0                    0             0      my ( $data ) = @_;
2590  ***      0      0                           0      die "I need data" unless $data;
2591  ***      0                                  0      MKDEBUG && _d('OK data:', $data);
2592  ***      0      0                           0      if ( length $data < 12 ) {
2593  ***      0                                  0         MKDEBUG && _d('OK packet is too short:', $data);
2594  ***      0                                  0         return;
2595                                                     }
2596  ***      0                                  0      my $affected_rows = get_lcb(\$data);
2597  ***      0                                  0      my $insert_id     = get_lcb(\$data);
2598  ***      0                                  0      my $status        = to_num(substr($data, 0, 4, ''));
2599  ***      0                                  0      my $warnings      = to_num(substr($data, 0, 4, ''));
2600  ***      0                                  0      my $message       = to_string($data);
2601  ***      0                                  0      my $pkt = {
2602                                                        affected_rows => $affected_rows,
2603                                                        insert_id     => $insert_id,
2604                                                        status        => $status,
2605                                                        warnings      => $warnings,
2606                                                        message       => $message,
2607                                                     };
2608  ***      0                                  0      MKDEBUG && _d('OK packet:', Dumper($pkt));
2609  ***      0                                  0      return $pkt;
2610                                                  }
2611                                                  
2612                                                  sub parse_server_handshake_packet {
2613  ***      0                    0             0      my ( $data ) = @_;
2614  ***      0      0                           0      die "I need data" unless $data;
2615  ***      0                                  0      MKDEBUG && _d('Server handshake data:', $data);
2616  ***      0                                  0      my $handshake_pattern = qr{
2617                                                        ^                 # -----                ----
2618                                                        (.+?)00           # n Null-Term String   server_version
2619                                                        (.{8})            # 4                    thread_id
2620                                                        .{16}             # 8                    scramble_buff
2621                                                        .{2}              # 1                    filler: always 0x00
2622                                                        (.{4})            # 2                    server_capabilities
2623                                                        .{2}              # 1                    server_language
2624                                                        .{4}              # 2                    server_status
2625                                                        .{26}             # 13                   filler: always 0x00
2626                                                     }x;
2627  ***      0                                  0      my ( $server_version, $thread_id, $flags ) = $data =~ m/$handshake_pattern/;
2628  ***      0                                  0      my $pkt = {
2629                                                        server_version => to_string($server_version),
2630                                                        thread_id      => to_num($thread_id),
2631                                                        flags          => parse_flags($flags),
2632                                                     };
2633  ***      0                                  0      MKDEBUG && _d('Server handshake packet:', Dumper($pkt));
2634  ***      0                                  0      return $pkt;
2635                                                  }
2636                                                  
2637                                                  sub parse_client_handshake_packet {
2638  ***      0                    0             0      my ( $data ) = @_;
2639  ***      0      0                           0      die "I need data" unless $data;
2640  ***      0                                  0      MKDEBUG && _d('Client handshake data:', $data);
2641  ***      0                                  0      my ( $flags, $user, $buff_len ) = $data =~ m{
2642                                                        ^
2643                                                        (.{8})         # Client flags
2644                                                        .{10}          # Max packet size, charset
2645                                                        (?:00){23}     # Filler
2646                                                        ((?:..)+?)00   # Null-terminated user name
2647                                                        (..)           # Length-coding byte for scramble buff
2648                                                     }x;
2649                                                  
2650  ***      0      0                           0      if ( !$buff_len ) {
2651  ***      0                                  0         MKDEBUG && _d('Did not match client handshake packet');
2652  ***      0                                  0         return;
2653                                                     }
2654                                                  
2655  ***      0                                  0      my $code_len = hex($buff_len);
2656  ***      0                                  0      my ( $db ) = $data =~ m!
2657                                                        ^.{64}${user}00..   # Everything matched before
2658                                                        (?:..){$code_len}   # The scramble buffer
2659                                                        (.*)00\Z            # The database name
2660                                                     !x;
2661  ***      0      0                           0      my $pkt = {
2662                                                        user  => to_string($user),
2663                                                        db    => $db ? to_string($db) : '',
2664                                                        flags => parse_flags($flags),
2665                                                     };
2666  ***      0                                  0      MKDEBUG && _d('Client handshake packet:', Dumper($pkt));
2667  ***      0                                  0      return $pkt;
2668                                                  }
2669                                                  
2670                                                  sub parse_com_packet {
2671  ***      0                    0             0      my ( $data, $len ) = @_;
2672  ***      0      0                           0      die "I need data"  unless $data;
2673  ***      0      0                           0      die "I need a len" unless $len;
2674  ***      0                                  0      MKDEBUG && _d('COM data:', $data, 'len:', $len);
2675  ***      0                                  0      my $code = substr($data, 0, 2);
2676  ***      0                                  0      my $com  = $com_for{$code};
2677  ***      0      0                           0      if ( !$com ) {
2678  ***      0                                  0         MKDEBUG && _d('Did not match COM packet');
2679  ***      0                                  0         return;
2680                                                     }
2681  ***      0                                  0      $data    = to_string(substr($data, 2, ($len - 1) * 2));
2682  ***      0                                  0      my $pkt = {
2683                                                        code => $code,
2684                                                        com  => $com,
2685                                                        data => $data,
2686                                                     };
2687  ***      0                                  0      MKDEBUG && _d('COM packet:', Dumper($pkt));
2688  ***      0                                  0      return $pkt;
2689                                                  }
2690                                                  
2691                                                  sub parse_flags {
2692  ***      0                    0             0      my ( $flags ) = @_;
2693  ***      0      0                           0      die "I need flags" unless $flags;
2694  ***      0                                  0      MKDEBUG && _d('Flag data:', $flags);
2695  ***      0                                  0      my %flags     = %flag_for;
2696  ***      0                                  0      my $flags_dec = to_num($flags);
2697  ***      0                                  0      foreach my $flag ( keys %flag_for ) {
2698  ***      0                                  0         my $flagno    = $flag_for{$flag};
2699  ***      0      0                           0         $flags{$flag} = ($flags_dec & $flagno ? 1 : 0);
2700                                                     }
2701  ***      0                                  0      return \%flags;
2702                                                  }
2703                                                  
2704                                                  sub uncompress_data {
2705  ***      0                    0             0      my ( $data, $len ) = @_;
2706  ***      0      0                           0      die "I need data" unless $data;
2707  ***      0      0                           0      die "I need a len argument" unless $len;
2708  ***      0      0                           0      die "I need a scalar reference to data" unless ref $data eq 'SCALAR';
2709  ***      0                                  0      MKDEBUG && _d('Uncompressing packet');
2710  ***      0                                  0      our $InflateError;
2711                                                  
2712  ***      0                                  0      my $comp_bin_data = pack('H*', $$data);
2713                                                  
2714  ***      0                                  0      my $uncomp_bin_data = '';
2715  ***      0      0                           0      my $z = new IO::Uncompress::Inflate(
2716                                                        \$comp_bin_data
2717                                                     ) or die "IO::Uncompress::Inflate failed: $InflateError";
2718  ***      0      0                           0      my $status = $z->read(\$uncomp_bin_data, $len)
2719                                                        or die "IO::Uncompress::Inflate failed: $InflateError";
2720                                                  
2721  ***      0                                  0      my $uncomp_data = unpack('H*', $uncomp_bin_data);
2722                                                  
2723  ***      0                                  0      return \$uncomp_data;
2724                                                  }
2725                                                  
2726                                                  sub detect_compression {
2727  ***      0                    0             0      my ( $self, $packet, $session ) = @_;
2728  ***      0                                  0      MKDEBUG && _d('Checking for client compression');
2729  ***      0                                  0      my $com = parse_com_packet($packet->{data}, $packet->{data_len});
2730  ***      0      0      0                    0      if ( $com && $com->{code} eq COM_SLEEP ) {
2731  ***      0                                  0         MKDEBUG && _d('Client is using compression');
2732  ***      0                                  0         $session->{compress} = 1;
2733                                                  
2734  ***      0                                  0         $packet->{data} = $packet->{mysql_hdr} . $packet->{data};
2735  ***      0      0                           0         return 0 unless uncompress_packet($packet);
2736  ***      0                                  0         remove_mysql_header($packet);
2737                                                     }
2738                                                     else {
2739  ***      0                                  0         MKDEBUG && _d('Client is NOT using compression');
2740  ***      0                                  0         $session->{compress} = 0;
2741                                                     }
2742  ***      0                                  0      return 1;
2743                                                  }
2744                                                  
2745                                                  sub uncompress_packet {
2746  ***      0                    0             0      my ( $packet ) = @_;
2747  ***      0      0                           0      die "I need a packet" unless $packet;
2748                                                  
2749                                                  
2750  ***      0                                  0      my $data            = \$packet->{data};
2751  ***      0                                  0      my $comp_hdr        = substr($$data, 0, 14, '');
2752  ***      0                                  0      my $comp_data_len   = to_num(substr($comp_hdr, 0, 6));
2753  ***      0                                  0      my $pkt_num         = to_num(substr($comp_hdr, 6, 2));
2754  ***      0                                  0      my $uncomp_data_len = to_num(substr($comp_hdr, 8, 6));
2755  ***      0                                  0      MKDEBUG && _d('Compression header data:', $comp_hdr,
2756                                                        'compressed data len (bytes)', $comp_data_len,
2757                                                        'number', $pkt_num,
2758                                                        'uncompressed data len (bytes)', $uncomp_data_len);
2759                                                  
2760  ***      0      0                           0      if ( $uncomp_data_len ) {
2761  ***      0                                  0         eval {
2762  ***      0                                  0            $data = uncompress_data($data, $uncomp_data_len);
2763  ***      0                                  0            $packet->{data} = $$data;
2764                                                        };
2765  ***      0      0                           0         if ( $EVAL_ERROR ) {
2766  ***      0                                  0            die "Cannot uncompress packet.  Check that IO::Uncompress::Inflate "
2767                                                              . "is installed.\nError: $EVAL_ERROR";
2768                                                        }
2769                                                     }
2770                                                     else {
2771  ***      0                                  0         MKDEBUG && _d('Packet is not really compressed');
2772  ***      0                                  0         $packet->{data} = $$data;
2773                                                     }
2774                                                  
2775  ***      0                                  0      return 1;
2776                                                  }
2777                                                  
2778                                                  sub remove_mysql_header {
2779  ***      0                    0             0      my ( $packet ) = @_;
2780  ***      0      0                           0      die "I need a packet" unless $packet;
2781                                                  
2782  ***      0                                  0      my $mysql_hdr      = substr($packet->{data}, 0, 8, '');
2783  ***      0                                  0      my $mysql_data_len = to_num(substr($mysql_hdr, 0, 6));
2784  ***      0                                  0      my $pkt_num        = to_num(substr($mysql_hdr, 6, 2));
2785  ***      0                                  0      MKDEBUG && _d('MySQL packet: header data', $mysql_hdr,
2786                                                        'data len (bytes)', $mysql_data_len, 'number', $pkt_num);
2787                                                  
2788  ***      0                                  0      $packet->{mysql_hdr}      = $mysql_hdr;
2789  ***      0                                  0      $packet->{mysql_data_len} = $mysql_data_len;
2790  ***      0                                  0      $packet->{number}         = $pkt_num;
2791                                                  
2792  ***      0                                  0      return;
2793                                                  }
2794                                                  
2795                                                  sub _get_errors_fh {
2796  ***      0                    0             0      my ( $self ) = @_;
2797  ***      0                                  0      my $errors_fh = $self->{errors_fh};
2798  ***      0      0                           0      return $errors_fh if $errors_fh;
2799                                                  
2800  ***      0                                  0      my $o = $self->{o};
2801  ***      0      0      0                    0      if ( $o && $o->has('tcpdump-errors') && $o->got('tcpdump-errors') ) {
      ***                    0                        
2802  ***      0                                  0         my $errors_file = $o->get('tcpdump-errors');
2803  ***      0                                  0         MKDEBUG && _d('tcpdump-errors file:', $errors_file);
2804  ***      0      0                           0         open $errors_fh, '>>', $errors_file
2805                                                           or die "Cannot open tcpdump-errors file $errors_file: $OS_ERROR";
2806                                                     }
2807                                                  
2808  ***      0                                  0      $self->{errors_fh} = $errors_fh;
2809  ***      0                                  0      return $errors_fh;
2810                                                  }
2811                                                  
2812                                                  sub fail_session {
2813  ***      0                    0             0      my ( $self, $session, $reason ) = @_;
2814  ***      0                                  0      my $errors_fh = $self->_get_errors_fh();
2815  ***      0      0                           0      if ( $errors_fh ) {
2816  ***      0                                  0         my $session_dump = '# ' . Dumper($session);
2817  ***      0                                  0         chomp $session_dump;
2818  ***      0                                  0         $session_dump =~ s/\n/\n# /g;
2819  ***      0                                  0         print $errors_fh "$session_dump\n";
2820                                                        {
2821  ***      0                                  0            local $LIST_SEPARATOR = "\n";
      ***      0                                  0   
2822  ***      0                                  0            print $errors_fh "@{$self->{raw_packets}}";
      ***      0                                  0   
2823  ***      0                                  0            print $errors_fh "\n";
2824                                                        }
2825                                                     }
2826  ***      0                                  0      MKDEBUG && _d('Failed session', $session->{client}, 'because', $reason);
2827  ***      0                                  0      delete $self->{sessions}->{$session->{client}};
2828  ***      0                                  0      return;
2829                                                  }
2830                                                  
2831                                                  sub _d {
2832  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2833  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2834  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2835                                                          @_;
2836  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2837                                                  }
2838                                                  
2839                                                  1;
2840                                                  
2841                                                  # ###########################################################################
2842                                                  # End MySQLProtocolParser package
2843                                                  # ###########################################################################
2844                                                  
2845                                                  # ###########################################################################
2846                                                  # SlowLogParser package 3980
2847                                                  # ###########################################################################
2848                                                  package SlowLogParser;
2849                                                  
2850           1                    1            10   use strict;
               1                                  3   
               1                                  8   
2851           1                    1             6   use warnings FATAL => 'all';
               1                                  4   
               1                                  7   
2852           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                 11   
2853           1                    1             8   use Data::Dumper;
               1                                  2   
               1                                  5   
2854                                                  
2855           1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  8   
2856                                                  
2857                                                  sub new {
2858           2                    2             9      my ( $class ) = @_;
2859           2                                 47      bless {}, $class;
2860                                                  }
2861                                                  
2862                                                  my $slow_log_ts_line = qr/^# Time: ([0-9: ]{15})/;
2863                                                  my $slow_log_uh_line = qr/# User\@Host: ([^\[]+|\[[^[]+\]).*?@ (\S*) \[(.*)\]/;
2864                                                  my $slow_log_hd_line = qr{
2865                                                        ^(?:
2866                                                        T[cC][pP]\s[pP]ort:\s+\d+ # case differs on windows/unix
2867                                                        |
2868                                                        [/A-Z].*mysqld,\sVersion.*(?:started\swith:|embedded\slibrary)
2869                                                        |
2870                                                        Time\s+Id\s+Command
2871                                                        ).*\n
2872                                                     }xm;
2873                                                  
2874                                                  sub parse_event {
2875           6                    6            32      my ( $self, $fh, $misc, @callbacks ) = @_;
2876           6                                 17      my $oktorun_here = 1;
2877  ***      6     50                          33      my $oktorun      = $misc->{oktorun} ? $misc->{oktorun} : \$oktorun_here;
2878           6                                 18      my $num_events   = 0;
2879                                                  
2880           6                                 13      my @pending;
2881           6                                 37      local $INPUT_RECORD_SEPARATOR = ";\n#";
2882           6                                 21      my $trimlen    = length($INPUT_RECORD_SEPARATOR);
2883           6                                 28      my $pos_in_log = tell($fh);
2884           6                                 14      my $stmt;
2885                                                  
2886                                                     EVENT:
2887  ***      6            66                  129      while ( $$oktorun
      ***                   66                        
2888                                                             && (defined($stmt = shift @pending) or defined($stmt = <$fh>)) ) {
2889           4                                 23         my @properties = ('cmd', 'Query', 'pos_in_log', $pos_in_log);
2890           4                                 12         $pos_in_log = tell($fh);
2891                                                  
2892  ***      4     50                          59         if ( $stmt =~ s/$slow_log_hd_line//go ){ # Throw away header lines in log
2893  ***      0                                  0            my @chunks = split(/$INPUT_RECORD_SEPARATOR/o, $stmt);
2894  ***      0      0                           0            if ( @chunks > 1 ) {
2895  ***      0                                  0               MKDEBUG && _d("Found multiple chunks");
2896  ***      0                                  0               $stmt = shift @chunks;
2897  ***      0                                  0               unshift @pending, @chunks;
2898                                                           }
2899                                                        }
2900                                                  
2901           4    100                          28         $stmt = '#' . $stmt unless $stmt =~ m/\A#/;
2902           4                                 27         $stmt =~ s/;\n#?\Z//;
2903                                                  
2904                                                  
2905           4                                 14         my ($got_ts, $got_uh, $got_ac, $got_db, $got_set, $got_embed);
2906           4                                 11         my $pos = 0;
2907           4                                 11         my $len = length($stmt);
2908           4                                  9         my $found_arg = 0;
2909                                                        LINE:
2910           4                                 27         while ( $stmt =~ m/^(.*)$/mg ) { # /g is important, requires scalar match.
2911          20                                 56            $pos     = pos($stmt);  # Be careful not to mess this up!
2912          20                                 71            my $line = $1;          # Necessary for /g and pos() to work.
2913          20                                 42            MKDEBUG && _d($line);
2914                                                  
2915          20    100                          90            if ($line =~ m/^(?:#|use |SET (?:last_insert_id|insert_id|timestamp))/o) {
2916                                                  
2917  ***     16    100     66                  273               if ( !$got_ts && (my ( $time ) = $line =~ m/$slow_log_ts_line/o)) {
      ***           100     66                        
      ***            50     33                        
      ***           100     33                        
      ***            50      0                        
      ***             0                               
2918           4                                  9                  MKDEBUG && _d("Got ts", $time);
2919           4                                 14                  push @properties, 'ts', $time;
2920           4                                 11                  ++$got_ts;
2921  ***      4     50     33                   56                  if ( !$got_uh
2922                                                                    && ( my ( $user, $host, $ip ) = $line =~ m/$slow_log_uh_line/o )
2923                                                                 ) {
2924  ***      0                                  0                     MKDEBUG && _d("Got user, host, ip", $user, $host, $ip);
2925  ***      0                                  0                     push @properties, 'user', $user, 'host', $host, 'ip', $ip;
2926  ***      0                                  0                     ++$got_uh;
2927                                                                 }
2928                                                              }
2929                                                  
2930                                                              elsif ( !$got_uh
2931                                                                    && ( my ( $user, $host, $ip ) = $line =~ m/$slow_log_uh_line/o )
2932                                                              ) {
2933           4                                 10                  MKDEBUG && _d("Got user, host, ip", $user, $host, $ip);
2934           4                                 22                  push @properties, 'user', $user, 'host', $host, 'ip', $ip;
2935           4                                 16                  ++$got_uh;
2936                                                              }
2937                                                  
2938                                                              elsif (!$got_ac && $line =~ m/^# (?:administrator command:.*)$/) {
2939  ***      0                                  0                  MKDEBUG && _d("Got admin command");
2940  ***      0                                  0                  push @properties, 'cmd', 'Admin', 'arg', $line;
2941  ***      0                                  0                  push @properties, 'bytes', length($properties[-1]);
2942  ***      0                                  0                  ++$found_arg;
2943  ***      0                                  0                  ++$got_ac;
2944                                                              }
2945                                                  
2946                                                              elsif ( $line =~ m/^# +[A-Z][A-Za-z_]+: \S+/ ) { # Make the test cheap!
2947           4                                  9                  MKDEBUG && _d("Got some line with properties");
2948           4                                 59                  my @temp = $line =~ m/(\w+):\s+(\d+(?:\.\d+)?|\S+|\Z)/g;
2949           4                                 22                  push @properties, @temp;
2950                                                              }
2951                                                  
2952                                                              elsif ( !$got_db && (my ( $db ) = $line =~ m/^use ([^;]+)/ ) ) {
2953           4                                 10                  MKDEBUG && _d("Got a default database:", $db);
2954           4                                 13                  push @properties, 'db', $db;
2955           4                                 12                  ++$got_db;
2956                                                              }
2957                                                  
2958                                                              elsif (!$got_set && (my ($setting) = $line =~ m/^SET\s+([^;]*)/)) {
2959  ***      0                                  0                  MKDEBUG && _d("Got some setting:", $setting);
2960  ***      0                                  0                  push @properties, split(/,|\s*=\s*/, $setting);
2961  ***      0                                  0                  ++$got_set;
2962                                                              }
2963                                                  
2964  ***     16     50     33                  180               if ( !$found_arg && $pos == $len ) {
2965  ***      0                                  0                  MKDEBUG && _d("Did not find arg, looking for special cases");
2966  ***      0                                  0                  local $INPUT_RECORD_SEPARATOR = ";\n";
2967  ***      0      0                           0                  if ( defined(my $l = <$fh>) ) {
2968  ***      0                                  0                     chomp $l;
2969  ***      0                                  0                     MKDEBUG && _d("Found admin statement", $l);
2970  ***      0                                  0                     push @properties, 'cmd', 'Admin', 'arg', '#' . $l;
2971  ***      0                                  0                     push @properties, 'bytes', length($properties[-1]);
2972  ***      0                                  0                     $found_arg++;
2973                                                                 }
2974                                                                 else {
2975  ***      0                                  0                     MKDEBUG && _d("I can't figure out what to do with this line");
2976  ***      0                                  0                     next EVENT;
2977                                                                 }
2978                                                              }
2979                                                           }
2980                                                           else {
2981           4                                 11               MKDEBUG && _d("Got the query/arg line");
2982           4                                 20               my $arg = substr($stmt, $pos - length($line));
2983           4                                 15               push @properties, 'arg', $arg, 'bytes', length($arg);
2984  ***      4     50     33                   50               if ( $misc && $misc->{embed}
      ***                   33                        
2985                                                                 && ( my ($e) = $arg =~ m/($misc->{embed})/)
2986                                                              ) {
2987  ***      0                                  0                  push @properties, $e =~ m/$misc->{capture}/g;
2988                                                              }
2989           4                                 11               last LINE;
2990                                                           }
2991                                                        }
2992                                                  
2993           4                                  9         MKDEBUG && _d('Properties of event:', Dumper(\@properties));
2994           4                                 51         my $event = { @properties };
2995           4                                 15         foreach my $callback ( @callbacks ) {
2996  ***     12     50                          43            last unless $event = $callback->($event);
2997                                                        }
2998           4                                 12         ++$num_events;
2999  ***      4     50                          40         last EVENT unless @pending;
3000                                                     }
3001           6                                 38      return $num_events;
3002                                                  }
3003                                                  
3004                                                  sub _d {
3005  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3006  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3007  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3008                                                          @_;
3009  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3010                                                  }
3011                                                  
3012                                                  1;
3013                                                  
3014                                                  # ###########################################################################
3015                                                  # End SlowLogParser package
3016                                                  # ###########################################################################
3017                                                  
3018                                                  # ###########################################################################
3019                                                  # EventAggregator package 3966
3020                                                  # ###########################################################################
3021                                                  package EventAggregator;
3022                                                  
3023           1                    1            11   use strict;
               1                                  4   
               1                                  6   
3024           1                    1             5   use warnings FATAL => 'all';
               1                                  3   
               1                                  6   
3025           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  5   
3026                                                  
3027           1                    1             6   use constant MKDEBUG      => $ENV{MKDEBUG};
               1                                  8   
               1                                  7   
3028           1                    1             6   use constant BUCK_SIZE    => 1.05;
               1                                  3   
               1                                  4   
3029           1                    1             6   use constant BASE_LOG     => log(BUCK_SIZE);
               1                                  3   
               1                                  9   
3030           1                    1             6   use constant BASE_OFFSET  => abs(1 - log(0.000001) / BASE_LOG); # 284.1617969
               1                                  3   
               1                                  4   
3031           1                    1             6   use constant NUM_BUCK     => 1000;
               1                                  2   
               1                                  5   
3032           1                    1             6   use constant MIN_BUCK     => .000001;
               1                                  3   
               1                                  5   
3033                                                  
3034                                                  our @buckets  = map { 0 } (0..NUM_BUCK-1);
3035                                                  
3036                                                  my @buck_vals = map { bucket_value($_); } (0..NUM_BUCK-1);
3037                                                  
3038                                                  sub new {
3039  ***      0                    0             0      my ( $class, %args ) = @_;
3040  ***      0                                  0      foreach my $arg ( qw(groupby worst) ) {
3041  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3042                                                     }
3043  ***      0             0                    0      my $attributes = $args{attributes} || {};
3044  ***      0                                  0      return bless {
3045                                                        groupby        => $args{groupby},
3046                                                        detect_attribs => scalar keys %$attributes == 0 ? 1 : 0,
3047                                                        all_attribs    => [ keys %$attributes ],
3048                                                        ignore_attribs => {
3049  ***      0                                  0            map  { $_ => $args{attributes}->{$_} }
3050  ***      0                                  0            grep { $_ ne $args{groupby} }
3051  ***      0                                  0            @{$args{ignore_attributes}}
3052                                                        },
3053                                                        attributes     => {
3054  ***      0                                  0            map  { $_ => $args{attributes}->{$_} }
3055  ***      0      0      0                    0            grep { $_ ne $args{groupby} }
3056                                                           keys %$attributes
3057                                                        },
3058                                                        worst        => $args{worst},
3059                                                        unroll_limit => $args{unroll_limit} || 50,
3060                                                        attrib_limit => $args{attrib_limit},
3061                                                        result_classes => {},
3062                                                        result_globals => {},
3063                                                        result_samples => {},
3064                                                        n_events       => 0,
3065                                                     }, $class;
3066                                                  }
3067                                                  
3068                                                  sub reset_aggregated_data {
3069  ***      0                    0             0      my ( $self ) = @_;
3070  ***      0                                  0      foreach my $class ( values %{$self->{result_classes}} ) {
      ***      0                                  0   
3071  ***      0                                  0         foreach my $attrib ( values %$class ) {
3072  ***      0                                  0            delete @{$attrib}{keys %$attrib};
      ***      0                                  0   
3073                                                        }
3074                                                     }
3075  ***      0                                  0      foreach my $class ( values %{$self->{result_globals}} ) {
      ***      0                                  0   
3076  ***      0                                  0         delete @{$class}{keys %$class};
      ***      0                                  0   
3077                                                     }
3078  ***      0                                  0      delete @{$self->{result_samples}}{keys %{$self->{result_samples}}};
      ***      0                                  0   
      ***      0                                  0   
3079  ***      0                                  0      $self->{n_events} = 0;
3080                                                  }
3081                                                  
3082                                                  sub aggregate {
3083  ***      0                    0             0      my ( $self, $event ) = @_;
3084                                                  
3085  ***      0                                  0      my $group_by = $event->{$self->{groupby}};
3086  ***      0      0                           0      return unless defined $group_by;
3087                                                  
3088  ***      0      0                           0      $self->add_new_attributes($event) if $self->{detect_attribs};
3089                                                  
3090  ***      0                                  0      $self->{n_events}++;
3091                                                  
3092  ***      0      0                           0      if ( exists $self->{unrolled_loops} ) {
3093  ***      0                                  0         return $self->{unrolled_loops}->($self, $event, $group_by);
3094                                                     }
3095                                                  
3096  ***      0                                  0      my @attrs = sort keys %{$self->{attributes}};
      ***      0                                  0   
3097                                                     ATTRIB:
3098  ***      0                                  0      foreach my $attrib ( @attrs ) {
3099  ***      0      0                           0         next ATTRIB unless exists $event->{$attrib};
3100                                                        GROUPBY:
3101  ***      0      0                           0         foreach my $val ( ref $group_by ? @$group_by : ($group_by) ) {
3102  ***      0             0                    0            my $class_attrib  = $self->{result_classes}->{$val}->{$attrib} ||= {};
3103  ***      0             0                    0            my $global_attrib = $self->{result_globals}->{$attrib} ||= {};
3104  ***      0                                  0            my $samples       = $self->{result_samples};
3105  ***      0                                  0            my $handler = $self->{handlers}->{ $attrib };
3106  ***      0      0                           0            if ( !$handler ) {
3107  ***      0                                  0               $handler = $self->make_handler(
3108                                                                 $attrib,
3109                                                                 $event,
3110                                                                 wor => $self->{worst} eq $attrib,
3111                                                                 alt => $self->{attributes}->{$attrib},
3112                                                              );
3113  ***      0                                  0               $self->{handlers}->{$attrib} = $handler;
3114                                                           }
3115  ***      0      0                           0            next GROUPBY unless $handler;
3116  ***      0             0                    0            $samples->{$val} ||= $event; # Initialize to the first event.
3117  ***      0                                  0            $handler->($event, $class_attrib, $global_attrib, $samples, $group_by);
3118                                                        }
3119                                                     }
3120                                                  
3121  ***      0      0      0                    0      if ( $self->{n_queries}++ > 50  # ...after 50 events, or
      ***      0             0                    0   
3122                                                          || ( # all attribs have handlers and
3123                                                               !grep { ref $self->{handlers}->{$_} ne 'CODE' } @attrs
3124                                                               && !$self->{detect_attribs}
3125                                                             ) )
3126                                                     {
3127  ***      0                                  0         my @attrs   = grep { $self->{handlers}->{$_} } @attrs;
      ***      0                                  0   
3128  ***      0                                  0         my $globs   = $self->{result_globals}; # Global stats for each
3129  ***      0                                  0         my $samples = $self->{result_samples};
3130                                                  
3131  ***      0      0                           0         my @lines = (
3132                                                           'my ( $self, $event, $group_by ) = @_;',
3133                                                           'my ($val, $class, $global, $idx);',
3134                                                           (ref $group_by ? ('foreach my $group_by ( @$group_by ) {') : ()),
3135                                                           'my $temp = $self->{result_classes}->{ $group_by }
3136                                                              ||= { map { $_ => { } } @attrs };',
3137                                                           '$samples->{$group_by} ||= $event;', # Always start with the first.
3138                                                        );
3139  ***      0                                  0         foreach my $i ( 0 .. $#attrs ) {
3140  ***      0                                  0            push @lines, (
3141                                                              '$class  = $temp->{"'  . $attrs[$i] . '"};',
3142                                                              '$global = $globs->{"' . $attrs[$i] . '"};',
3143                                                              $self->{unrolled_for}->{$attrs[$i]},
3144                                                           );
3145                                                        }
3146  ***      0      0                           0         if ( ref $group_by ) {
3147  ***      0                                  0            push @lines, '}'; # Close the loop opened above
3148                                                        }
3149  ***      0                                  0         @lines = map { s/^/   /gm; $_ } @lines; # Indent for debugging
      ***      0                                  0   
      ***      0                                  0   
3150  ***      0                                  0         unshift @lines, 'sub {';
3151  ***      0                                  0         push @lines, '}';
3152                                                  
3153  ***      0                                  0         my $code = join("\n", @lines);
3154  ***      0                                  0         MKDEBUG && _d('Unrolled subroutine:', @lines);
3155  ***      0                                  0         my $sub = eval $code;
3156  ***      0      0                           0         die if $EVAL_ERROR;
3157  ***      0                                  0         $self->{unrolled_loops} = $sub;
3158                                                     }
3159                                                  
3160  ***      0                                  0      return;
3161                                                  }
3162                                                  
3163                                                  sub results {
3164  ***      0                    0             0      my ( $self ) = @_;
3165                                                     return {
3166  ***      0                                  0         classes => $self->{result_classes},
3167                                                        globals => $self->{result_globals},
3168                                                        samples => $self->{result_samples},
3169                                                     };
3170                                                  }
3171                                                  
3172                                                  sub attributes {
3173  ***      0                    0             0      my ( $self ) = @_;
3174  ***      0                                  0      return $self->{type_for};
3175                                                  }
3176                                                  
3177                                                  sub type_for {
3178  ***      0                    0             0      my ( $self, $attrib ) = @_;
3179  ***      0                                  0      return $self->{type_for}->{$attrib};
3180                                                  }
3181                                                  
3182                                                  sub make_handler {
3183  ***      0                    0             0      my ( $self, $attrib, $event, %args ) = @_;
3184  ***      0      0                           0      die "I need an attrib" unless defined $attrib;
3185  ***      0                                  0      my ($val) = grep { defined $_ } map { $event->{$_} } @{ $args{alt} };
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
3186  ***      0                                  0      my $is_array = 0;
3187  ***      0      0                           0      if (ref $val eq 'ARRAY') {
3188  ***      0                                  0         $is_array = 1;
3189  ***      0                                  0         $val      = $val->[0];
3190                                                     }
3191  ***      0      0                           0      return unless defined $val; # Can't decide type if it's undef.
3192                                                  
3193  ***      0                                  0      my $float_re = qr{[+-]?(?:(?=\d|[.])\d+(?:[.])\d{0,})(?:E[+-]?\d+)?}i;
3194  ***      0      0                           0      my $type = $val  =~ m/^(?:\d+|$float_re)$/o ? 'num'
      ***             0                               
3195                                                              : $val  =~ m/^(?:Yes|No)$/         ? 'bool'
3196                                                              :                                    'string';
3197  ***      0                                  0      MKDEBUG && _d('Type for', $attrib, 'is', $type,
3198                                                        '(sample:', $val, '), is array:', $is_array);
3199  ***      0                                  0      $self->{type_for}->{$attrib} = $type;
3200                                                  
3201  ***      0      0                           0      %args = ( # Set up defaults
      ***             0                               
      ***             0                               
      ***             0                               
3202                                                        min => 1,
3203                                                        max => 1,
3204                                                        sum => $type =~ m/num|bool/    ? 1 : 0,
3205                                                        cnt => 1,
3206                                                        unq => $type =~ m/bool|string/ ? 1 : 0,
3207                                                        all => $type eq 'num'          ? 1 : 0,
3208                                                        glo => 1,
3209                                                        trf => ($type eq 'bool') ? q{($val || '' eq 'Yes') ? 1 : 0} : undef,
3210                                                        wor => 0,
3211                                                        alt => [],
3212                                                        %args,
3213                                                     );
3214                                                  
3215  ***      0                                  0      my @lines = ("# type: $type"); # Lines of code for the subroutine
3216  ***      0      0                           0      if ( $args{trf} ) {
3217  ***      0                                  0         push @lines, q{$val = } . $args{trf} . ';';
3218                                                     }
3219                                                  
3220  ***      0                                  0      foreach my $place ( qw($class $global) ) {
3221  ***      0                                  0         my @tmp;
3222  ***      0      0                           0         if ( $args{min} ) {
3223  ***      0      0                           0            my $op   = $type eq 'num' ? '<' : 'lt';
3224  ***      0                                  0            push @tmp, (
3225                                                              'PLACE->{min} = $val if !defined PLACE->{min} || $val '
3226                                                                 . $op . ' PLACE->{min};',
3227                                                           );
3228                                                        }
3229  ***      0      0                           0         if ( $args{max} ) {
3230  ***      0      0                           0            my $op = ($type eq 'num') ? '>' : 'gt';
3231  ***      0                                  0            push @tmp, (
3232                                                              'PLACE->{max} = $val if !defined PLACE->{max} || $val '
3233                                                                 . $op . ' PLACE->{max};',
3234                                                           );
3235                                                        }
3236  ***      0      0                           0         if ( $args{sum} ) {
3237  ***      0                                  0            push @tmp, 'PLACE->{sum} += $val;';
3238                                                        }
3239  ***      0      0                           0         if ( $args{cnt} ) {
3240  ***      0                                  0            push @tmp, '++PLACE->{cnt};';
3241                                                        }
3242  ***      0      0                           0         if ( $args{all} ) {
3243  ***      0                                  0            push @tmp, (
3244                                                              'exists PLACE->{all} or PLACE->{all} = [ @buckets ];',
3245                                                              '++PLACE->{all}->[ EventAggregator::bucket_idx($val) ];',
3246                                                           );
3247                                                        }
3248  ***      0                                  0         push @lines, map { s/PLACE/$place/g; $_ } @tmp;
      ***      0                                  0   
      ***      0                                  0   
3249                                                     }
3250                                                  
3251  ***      0      0                           0      if ( $args{unq} ) {
3252  ***      0                                  0         push @lines, '++$class->{unq}->{$val};';
3253                                                     }
3254  ***      0      0                           0      if ( $args{wor} ) {
3255  ***      0      0                           0         my $op = $type eq 'num' ? '>=' : 'ge';
3256  ***      0                                  0         push @lines, (
3257                                                           'if ( $val ' . $op . ' ($class->{max} || 0) ) {',
3258                                                           '   $samples->{$group_by} = $event;',
3259                                                           '}',
3260                                                        );
3261                                                     }
3262                                                  
3263  ***      0                                  0      my @limit;
3264  ***      0      0      0                    0      if ( $args{all} && $type eq 'num' && $self->{attrib_limit} ) {
      ***                    0                        
3265  ***      0                                  0         push @limit, (
3266                                                           "if ( \$val > $self->{attrib_limit} ) {",
3267                                                           '   $val = $class->{last} ||= 0;',
3268                                                           '}',
3269                                                           '$class->{last} = $val;',
3270                                                        );
3271                                                     }
3272                                                  
3273  ***      0                                  0      my @unrolled = (
3274                                                        "\$val = \$event->{'$attrib'};",
3275                                                        ($is_array ? ('foreach my $val ( @$val ) {') : ()),
3276  ***      0                                  0         (map { "\$val = \$event->{'$_'} unless defined \$val;" }
3277  ***      0                                  0            grep { $_ ne $attrib } @{$args{alt}}),
      ***      0                                  0   
3278                                                        'defined $val && do {',
3279  ***      0      0                           0         ( map { s/^/   /gm; $_ } (@limit, @lines) ), # Indent for debugging
      ***      0      0                           0   
3280                                                        '};',
3281                                                        ($is_array ? ('}') : ()),
3282                                                     );
3283  ***      0                                  0      $self->{unrolled_for}->{$attrib} = join("\n", @unrolled);
3284                                                  
3285  ***      0                                  0      unshift @lines, (
3286                                                        'sub {',
3287                                                        'my ( $event, $class, $global, $samples, $group_by ) = @_;',
3288                                                        'my ($val, $idx);', # NOTE: define all variables here
3289                                                        "\$val = \$event->{'$attrib'};",
3290  ***      0                                  0         (map { "\$val = \$event->{'$_'} unless defined \$val;" }
3291  ***      0      0                           0            grep { $_ ne $attrib } @{$args{alt}}),
      ***      0      0                           0   
3292                                                        'return unless defined $val;',
3293                                                        ($is_array ? ('foreach my $val ( @$val ) {') : ()),
3294                                                        @limit,
3295                                                        ($is_array ? ('}') : ()),
3296                                                     );
3297  ***      0                                  0      push @lines, '}';
3298  ***      0                                  0      my $code = join("\n", @lines);
3299  ***      0                                  0      $self->{code_for}->{$attrib} = $code;
3300                                                  
3301  ***      0                                  0      MKDEBUG && _d('Metric handler for', $attrib, ':', @lines);
3302  ***      0                                  0      my $sub = eval join("\n", @lines);
3303  ***      0      0                           0      die if $EVAL_ERROR;
3304  ***      0                                  0      return $sub;
3305                                                  }
3306                                                  
3307                                                  sub bucket_idx {
3308  ***      0                    0             0      my ( $val ) = @_;
3309  ***      0      0                           0      return 0 if $val < MIN_BUCK;
3310  ***      0                                  0      my $idx = int(BASE_OFFSET + log($val)/BASE_LOG);
3311  ***      0      0                           0      return $idx > (NUM_BUCK-1) ? (NUM_BUCK-1) : $idx;
3312                                                  }
3313                                                  
3314                                                  sub bucket_value {
3315        1000                 1000          2983      my ( $bucket ) = @_;
3316        1000    100                        3478      return 0 if $bucket == 0;
3317  ***    999     50     33                 7199      die "Invalid bucket: $bucket" if $bucket < 0 || $bucket > (NUM_BUCK-1);
3318         999                               4577      return (BUCK_SIZE**($bucket-1)) * MIN_BUCK;
3319                                                  }
3320                                                  
3321                                                  {
3322                                                     my @buck_tens;
3323                                                     sub buckets_of {
3324  ***      0      0             0             0         return @buck_tens if @buck_tens;
3325                                                  
3326  ***      0                                  0         my $start_bucket  = 0;
3327  ***      0                                  0         my @base10_starts = (0);
3328  ***      0                                  0         map { push @base10_starts, (10**$_)*MIN_BUCK } (1..7);
      ***      0                                  0   
3329                                                  
3330  ***      0                                  0         for my $base10_bucket ( 0..($#base10_starts-1) ) {
3331  ***      0                                  0            my $next_bucket = bucket_idx( $base10_starts[$base10_bucket+1] );
3332  ***      0                                  0            MKDEBUG && _d('Base 10 bucket $base10_bucket maps to',
3333                                                              'base 1.05 buckets', $start_bucket, '..', $next_bucket-1);
3334  ***      0                                  0            for my $base1_05_bucket ($start_bucket..($next_bucket-1)) {
3335  ***      0                                  0               $buck_tens[$base1_05_bucket] = $base10_bucket;
3336                                                           }
3337  ***      0                                  0            $start_bucket = $next_bucket;
3338                                                        }
3339                                                  
3340  ***      0                                  0         map { $buck_tens[$_] = 7 } ($start_bucket..(NUM_BUCK-1));
      ***      0                                  0   
3341                                                  
3342  ***      0                                  0         return @buck_tens;
3343                                                     }
3344                                                  }
3345                                                  
3346                                                  sub calculate_statistical_metrics {
3347  ***      0                    0             0      my ( $self, $vals, $args ) = @_;
3348  ***      0                                  0      my $statistical_metrics = {
3349                                                        pct_95    => 0,
3350                                                        stddev    => 0,
3351                                                        median    => 0,
3352                                                        cutoff    => undef,
3353                                                     };
3354                                                  
3355  ***      0      0      0                    0      return $statistical_metrics
      ***                    0                        
3356                                                        unless defined $vals && @$vals && $args->{cnt};
3357                                                  
3358  ***      0                                  0      my $n_vals = $args->{cnt};
3359  ***      0      0      0                    0      if ( $n_vals == 1 || $args->{max} == $args->{min} ) {
      ***             0                               
3360  ***      0             0                    0         my $v      = $args->{max} || 0;
3361  ***      0      0                           0         my $bucket = int(6 + ( log($v > 0 ? $v : MIN_BUCK) / log(10)));
3362  ***      0      0                           0         $bucket    = $bucket > 7 ? 7 : $bucket < 0 ? 0 : $bucket;
      ***             0                               
3363                                                        return {
3364  ***      0                                  0            pct_95 => $v,
3365                                                           stddev => 0,
3366                                                           median => $v,
3367                                                           cutoff => $n_vals,
3368                                                        };
3369                                                     }
3370                                                     elsif ( $n_vals == 2 ) {
3371  ***      0                                  0         foreach my $v ( $args->{min}, $args->{max} ) {
3372  ***      0      0      0                    0            my $bucket = int(6 + ( log($v && $v > 0 ? $v : MIN_BUCK) / log(10)));
3373  ***      0      0                           0            $bucket = $bucket > 7 ? 7 : $bucket < 0 ? 0 : $bucket;
      ***             0                               
3374                                                        }
3375  ***      0             0                    0         my $v      = $args->{max} || 0;
3376  ***      0             0                    0         my $mean = (($args->{min} || 0) + $v) / 2;
3377                                                        return {
3378  ***      0                                  0            pct_95 => $v,
3379                                                           stddev => sqrt((($v - $mean) ** 2) *2),
3380                                                           median => $mean,
3381                                                           cutoff => $n_vals,
3382                                                        };
3383                                                     }
3384                                                  
3385  ***      0      0                           0      my $cutoff = $n_vals >= 10 ? int ( $n_vals * 0.95 ) : $n_vals;
3386  ***      0                                  0      $statistical_metrics->{cutoff} = $cutoff;
3387                                                  
3388  ***      0                                  0      my $total_left = $n_vals;
3389  ***      0                                  0      my $top_vals   = $n_vals - $cutoff; # vals > 95th
3390  ***      0                                  0      my $sum_excl   = 0;
3391  ***      0                                  0      my $sum        = 0;
3392  ***      0                                  0      my $sumsq      = 0;
3393  ***      0                                  0      my $mid        = int($n_vals / 2);
3394  ***      0                                  0      my $median     = 0;
3395  ***      0                                  0      my $prev       = NUM_BUCK-1; # Used for getting median when $cutoff is odd
3396  ***      0                                  0      my $bucket_95  = 0; # top bucket in 95th
3397                                                  
3398  ***      0                                  0      MKDEBUG && _d('total vals:', $total_left, 'top vals:', $top_vals, 'mid:', $mid);
3399                                                  
3400                                                     BUCKET:
3401  ***      0                                  0      for my $bucket ( reverse 0..(NUM_BUCK-1) ) {
3402  ***      0                                  0         my $val = $vals->[$bucket];
3403  ***      0      0                           0         next BUCKET unless $val; 
3404                                                  
3405  ***      0                                  0         $total_left -= $val;
3406  ***      0                                  0         $sum_excl   += $val;
3407  ***      0      0      0                    0         $bucket_95   = $bucket if !$bucket_95 && $sum_excl > $top_vals;
3408                                                  
3409  ***      0      0      0                    0         if ( !$median && $total_left <= $mid ) {
3410  ***      0      0      0                    0            $median = (($cutoff % 2) || ($val > 1)) ? $buck_vals[$bucket]
3411                                                                   : ($buck_vals[$bucket] + $buck_vals[$prev]) / 2;
3412                                                        }
3413                                                  
3414  ***      0                                  0         $sum    += $val * $buck_vals[$bucket];
3415  ***      0                                  0         $sumsq  += $val * ($buck_vals[$bucket]**2);
3416  ***      0                                  0         $prev   =  $bucket;
3417                                                     }
3418                                                  
3419  ***      0                                  0      my $var      = $sumsq/$n_vals - ( ($sum/$n_vals) ** 2 );
3420  ***      0      0                           0      my $stddev   = $var > 0 ? sqrt($var) : 0;
3421  ***      0             0                    0      my $maxstdev = (($args->{max} || 0) - ($args->{min} || 0)) / 2;
      ***                    0                        
3422  ***      0      0                           0      $stddev      = $stddev > $maxstdev ? $maxstdev : $stddev;
3423                                                  
3424  ***      0                                  0      MKDEBUG && _d('sum:', $sum, 'sumsq:', $sumsq, 'stddev:', $stddev,
3425                                                        'median:', $median, 'prev bucket:', $prev,
3426                                                        'total left:', $total_left, 'sum excl', $sum_excl,
3427                                                        'bucket 95:', $bucket_95, $buck_vals[$bucket_95]);
3428                                                  
3429  ***      0                                  0      $statistical_metrics->{stddev} = $stddev;
3430  ***      0                                  0      $statistical_metrics->{pct_95} = $buck_vals[$bucket_95];
3431  ***      0                                  0      $statistical_metrics->{median} = $median;
3432                                                  
3433  ***      0                                  0      return $statistical_metrics;
3434                                                  }
3435                                                  
3436                                                  sub metrics {
3437  ***      0                    0             0      my ( $self, %args ) = @_;
3438  ***      0                                  0      foreach my $arg ( qw(attrib where) ) {
3439  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3440                                                     }
3441  ***      0                                  0      my $stats = $self->results;
3442  ***      0                                  0      my $store = $stats->{classes}->{$args{where}}->{$args{attrib}};
3443                                                  
3444  ***      0                                  0      my $global_cnt = $stats->{globals}->{$args{attrib}}->{cnt};
3445  ***      0                                  0      my $metrics    = $self->calculate_statistical_metrics($store->{all}, $store);
3446                                                  
3447                                                     return {
3448  ***      0      0      0                    0         cnt    => $store->{cnt},
      ***             0      0                        
3449                                                        pct    => $global_cnt && $store->{cnt} ? $store->{cnt} / $global_cnt : 0,
3450                                                        sum    => $store->{sum},
3451                                                        min    => $store->{min},
3452                                                        max    => $store->{max},
3453                                                        avg    => $store->{sum} && $store->{cnt} ? $store->{sum} / $store->{cnt} : 0,
3454                                                        median => $metrics->{median},
3455                                                        pct_95 => $metrics->{pct_95},
3456                                                        stddev => $metrics->{stddev},
3457                                                     };
3458                                                  }
3459                                                  
3460                                                  sub top_events {
3461  ***      0                    0             0      my ( $self, %args ) = @_;
3462  ***      0                                  0      my $classes = $self->{result_classes};
3463  ***      0                                  0      my @sorted = reverse sort { # Sorted list of $groupby values
3464  ***      0                                  0         $classes->{$a}->{$args{attrib}}->{$args{orderby}}
3465                                                           <=> $classes->{$b}->{$args{attrib}}->{$args{orderby}}
3466                                                        } grep {
3467  ***      0                                  0            defined $classes->{$_}->{$args{attrib}}->{$args{orderby}}
3468                                                        } keys %$classes;
3469  ***      0                                  0      my @chosen;
3470  ***      0                                  0      my ($total, $count) = (0, 0);
3471  ***      0                                  0      foreach my $groupby ( @sorted ) {
3472  ***      0      0      0                    0         if ( 
      ***             0      0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
3473                                                           (!$args{total} || $total < $args{total} )
3474                                                           && ( !$args{count} || $count < $args{count} )
3475                                                        ) {
3476  ***      0                                  0            push @chosen, [$groupby, 'top'];
3477                                                        }
3478                                                  
3479                                                        elsif ( $args{ol_attrib} && (!$args{ol_freq}
3480                                                           || $classes->{$groupby}->{$args{ol_attrib}}->{cnt} >= $args{ol_freq})
3481                                                        ) {
3482  ***      0                                  0            MKDEBUG && _d('Calculating statistical_metrics');
3483  ***      0                                  0            my $stats = $self->calculate_statistical_metrics(
3484                                                              $classes->{$groupby}->{$args{ol_attrib}}->{all},
3485                                                              $classes->{$groupby}->{$args{ol_attrib}}
3486                                                           );
3487  ***      0      0                           0            if ( $stats->{pct_95} >= $args{ol_limit} ) {
3488  ***      0                                  0               push @chosen, [$groupby, 'outlier'];
3489                                                           }
3490                                                        }
3491                                                  
3492  ***      0                                  0         $total += $classes->{$groupby}->{$args{attrib}}->{$args{orderby}};
3493  ***      0                                  0         $count++;
3494                                                     }
3495  ***      0                                  0      return @chosen;
3496                                                  }
3497                                                  
3498                                                  sub add_new_attributes {
3499  ***      0                    0             0      my ( $self, $event ) = @_;
3500  ***      0      0                           0      return unless $event;
3501  ***      0                                  0      map {
3502  ***      0      0      0                    0         $self->{attributes}->{$_} = [$_];
3503  ***      0                                  0         push @{$self->{all_attribs}}, $_;
      ***      0                                  0   
3504  ***      0                                  0         MKDEBUG && _d('Added new attribute:', $_);
3505                                                     }
3506                                                     grep {
3507  ***      0                                  0         $_ ne $self->{groupby}
3508                                                        && !exists $self->{attributes}->{$_}
3509                                                        && !exists $self->{ignore_attribs}->{$_}
3510                                                     }
3511                                                     keys %$event;
3512  ***      0                                  0      return;
3513                                                  }
3514                                                  
3515                                                  sub get_attributes {
3516  ***      0                    0             0      my ( $self ) = @_;
3517  ***      0                                  0      return @{$self->{all_attribs}};
      ***      0                                  0   
3518                                                  }
3519                                                  
3520                                                  sub events_processed {
3521  ***      0                    0             0      my ( $self ) = @_;
3522  ***      0                                  0      return $self->{n_events};
3523                                                  }
3524                                                  
3525                                                  sub _d {
3526  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3527  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3528  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3529                                                          @_;
3530  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3531                                                  }
3532                                                  
3533                                                  1;
3534                                                  
3535                                                  # ###########################################################################
3536                                                  # End EventAggregator package
3537                                                  # ###########################################################################
3538                                                  
3539                                                  # ###########################################################################
3540                                                  # QueryParser package 3637
3541                                                  # ###########################################################################
3542                                                  package QueryParser;
3543                                                  
3544           1                    1             9   use strict;
               1                                  3   
               1                                  6   
3545           1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  6   
3546           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  7   
3547                                                  
3548           1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  8   
3549                                                  our $tbl_ident = qr/(?:`[^`]+`|\w+)(?:\.(?:`[^`]+`|\w+))?/;
3550                                                  our $tbl_regex = qr{
3551                                                           \b(?:FROM|JOIN|(?<!KEY\s)UPDATE|INTO) # Words that precede table names
3552                                                           \b\s*
3553                                                           ($tbl_ident
3554                                                              (?: (?:\s+ (?:AS\s+)? \w+)?, \s*$tbl_ident )*
3555                                                           )
3556                                                        }xio;
3557                                                  our $has_derived = qr{
3558                                                        \b(?:FROM|JOIN|,)
3559                                                        \s*\(\s*SELECT
3560                                                     }xi;
3561                                                  
3562                                                  sub new {
3563  ***      0                    0             0      my ( $class ) = @_;
3564  ***      0                                  0      bless {}, $class;
3565                                                  }
3566                                                  
3567                                                  sub get_tables {
3568  ***      0                    0             0      my ( $self, $query ) = @_;
3569  ***      0      0                           0      return unless $query;
3570  ***      0                                  0      MKDEBUG && _d('Getting tables for', $query);
3571                                                  
3572  ***      0                                  0      $query =~ s/ (?:LOW_PRIORITY|IGNORE|STRAIGHT_JOIN)//ig;
3573                                                  
3574  ***      0                                  0      $query =~ s/\\["']//g;                # quoted strings
3575  ***      0                                  0      $query =~ s/".*?"/?/sg;               # quoted strings
3576  ***      0                                  0      $query =~ s/'.*?'/?/sg;               # quoted strings
3577                                                  
3578  ***      0                                  0      my @tables;
3579  ***      0                                  0      foreach my $tbls ( $query =~ m/$tbl_regex/gio ) {
3580  ***      0                                  0         MKDEBUG && _d('Match tables:', $tbls);
3581  ***      0                                  0         foreach my $tbl ( split(',', $tbls) ) {
3582  ***      0                                  0            $tbl =~ s/\s*($tbl_ident)(\s+.*)?/$1/gio;
3583  ***      0                                  0            push @tables, $tbl;
3584                                                        }
3585                                                     }
3586  ***      0                                  0      return @tables;
3587                                                  }
3588                                                  
3589                                                  sub has_derived_table {
3590  ***      0                    0             0      my ( $self, $query ) = @_;
3591  ***      0                                  0      my $match = $query =~ m/$has_derived/;
3592  ***      0                                  0      MKDEBUG && _d($query, 'has ' . ($match ? 'a' : 'no') . ' derived table');
3593  ***      0                                  0      return $match;
3594                                                  }
3595                                                  
3596                                                  sub get_aliases {
3597  ***      0                    0             0      my ( $self, $query ) = @_;
3598  ***      0      0                           0      return unless $query;
3599  ***      0                                  0      my $aliases;
3600                                                  
3601  ***      0                                  0      $query =~ s/ (?:LOW_PRIORITY|IGNORE|STRAIGHT_JOIN)//ig;
3602                                                  
3603  ***      0                                  0      $query =~ s/ (?:INNER|OUTER|CROSS|LEFT|RIGHT|NATURAL)//ig;
3604                                                  
3605  ***      0                                  0      my ($tbl_refs, $from) = $query =~ m{
3606                                                        (
3607                                                           (FROM|INTO|UPDATE)\b\s*   # Keyword before table refs
3608                                                           .+?                       # Table refs
3609                                                        )
3610                                                        (?:\s+|\z)                   # If the query does not end with the table
3611                                                        (?:WHERE|ORDER|LIMIT|HAVING|SET|VALUES|\z) # Keyword after table refs
3612                                                     }ix;
3613                                                  
3614  ***      0      0      0                    0      die "Failed to parse table references from $query"
3615                                                        unless $tbl_refs && $from;
3616                                                  
3617  ***      0                                  0      MKDEBUG && _d('tbl refs:', $tbl_refs);
3618                                                  
3619  ***      0                                  0      my $before_tbl = qr/(?:,|JOIN|\s|$from)+/i;
3620                                                  
3621  ***      0                                  0      my $after_tbl  = qr/(?:,|JOIN|ON|USING|\z)/i;
3622                                                  
3623  ***      0                                  0      $tbl_refs =~ s/ = /=/g;
3624                                                  
3625  ***      0                                  0      while (
3626                                                        $tbl_refs =~ m{
3627                                                           $before_tbl\b\s*
3628                                                              ( ($tbl_ident) (?:\s+ (?:AS\s+)? (\w+))? )
3629                                                           \s*$after_tbl
3630                                                        }xgio )
3631                                                     {
3632  ***      0                                  0         my ( $tbl_ref, $db_tbl, $alias ) = ($1, $2, $3);
3633  ***      0                                  0         MKDEBUG && _d('Match table:', $tbl_ref);
3634                                                  
3635  ***      0      0                           0         if ( $tbl_ref =~ m/^AS\s+\w+/i ) {
3636  ***      0                                  0            MKDEBUG && _d('Subquery', $tbl_ref);
3637  ***      0                                  0            $aliases->{$alias} = undef;
3638  ***      0                                  0            next;
3639                                                        }
3640                                                  
3641  ***      0                                  0         my ( $db, $tbl ) = $db_tbl =~ m/^(?:(.*?)\.)?(.*)/;
3642  ***      0             0                    0         $aliases->{$alias || $tbl} = $tbl;
3643  ***      0      0                           0         $aliases->{DATABASE}->{$tbl} = $db if $db;
3644                                                     }
3645  ***      0                                  0      return $aliases;
3646                                                  }
3647                                                  
3648                                                  sub _d {
3649  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3650  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3651  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3652                                                          @_;
3653  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3654                                                  }
3655                                                  
3656                                                  1;
3657                                                  
3658                                                  # ###########################################################################
3659                                                  # End QueryParser package
3660                                                  # ###########################################################################
3661                                                  
3662                                                  # ###########################################################################
3663                                                  # Daemon package 3976
3664                                                  # ###########################################################################
3665                                                  
3666                                                  package Daemon;
3667                                                  
3668           1                    1             7   use strict;
               1                                  2   
               1                                  6   
3669           1                    1             5   use warnings FATAL => 'all';
               1                                  2   
               1                                236   
3670                                                  
3671           1                    1            12   use POSIX qw(setsid);
               1                                  4   
               1                                  7   
3672           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  7   
3673                                                  
3674           1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                 10   
3675                                                  
3676                                                  sub new {
3677  ***      0                    0             0      my ( $class, %args ) = @_;
3678  ***      0                                  0      foreach my $arg ( qw(o) ) {
3679  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3680                                                     }
3681  ***      0                                  0      my $o = $args{o};
3682  ***      0      0                           0      my $self = {
      ***             0                               
3683                                                        o        => $o,
3684                                                        log_file => $o->has('log') ? $o->get('log') : undef,
3685                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
3686                                                     };
3687                                                  
3688  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
3689                                                  
3690  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
3691  ***      0                                  0      return bless $self, $class;
3692                                                  }
3693                                                  
3694                                                  sub daemonize {
3695  ***      0                    0             0      my ( $self ) = @_;
3696                                                  
3697  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
3698  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
3699  ***      0      0                           0      if ( $pid ) {
3700  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
3701  ***      0                                  0         exit;
3702                                                     }
3703                                                  
3704  ***      0                                  0      $self->{child} = 1;
3705                                                  
3706  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
3707  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
3708                                                  
3709  ***      0                                  0      $self->_make_PID_file();
3710                                                  
3711  ***      0      0                           0      if ( -t STDIN ) {
3712  ***      0                                  0         close STDIN;
3713  ***      0      0                           0         open  STDIN, '/dev/null'
3714                                                           or die "Cannot reopen STDIN to /dev/null";
3715                                                     }
3716                                                  
3717  ***      0      0                           0      if ( $self->{log_file} ) {
3718  ***      0                                  0         close STDOUT;
3719  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
3720                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
3721                                                  
3722  ***      0                                  0         close STDERR;
3723  ***      0      0                           0         open  STDERR, ">&STDOUT"
3724                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR";
3725                                                     }
3726                                                  
3727  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
3728  ***      0                                  0      return;
3729                                                  }
3730                                                  
3731                                                  sub check_PID_file {
3732  ***      0                    0             0      my ( $self, $file ) = @_;
3733  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
3734  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
3735  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
3736  ***      0                                  0         my $pid;
3737  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
3738  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
3739  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
3740  ***      0      0                           0         if ( $pid ) {
3741  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
3742  ***      0      0                           0            if ( $pid_is_alive ) {
3743  ***      0                                  0               die "The PID file $PID_file already exists "
3744                                                                 . " and the PID that it contains, $pid, is running";
3745                                                           }
3746                                                           else {
3747  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
3748                                                                 . "contains, $pid, is not running";
3749                                                           }
3750                                                        }
3751                                                        else {
3752  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
3753                                                              . "contain a PID";
3754                                                        }
3755                                                     }
3756                                                     else {
3757  ***      0                                  0         MKDEBUG && _d('No PID file');
3758                                                     }
3759  ***      0                                  0      return;
3760                                                  }
3761                                                  
3762                                                  sub make_PID_file {
3763  ***      0                    0             0      my ( $self ) = @_;
3764  ***      0      0                           0      if ( exists $self->{child} ) {
3765  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
3766                                                     }
3767  ***      0                                  0      $self->_make_PID_file();
3768  ***      0                                  0      $self->{rm_PID_file} = 1;
3769  ***      0                                  0      return;
3770                                                  }
3771                                                  
3772                                                  sub _make_PID_file {
3773  ***      0                    0             0      my ( $self ) = @_;
3774                                                  
3775  ***      0                                  0      my $PID_file = $self->{PID_file};
3776  ***      0      0                           0      if ( !$PID_file ) {
3777  ***      0                                  0         MKDEBUG && _d('No PID file to create');
3778  ***      0                                  0         return;
3779                                                     }
3780                                                  
3781  ***      0                                  0      $self->check_PID_file();
3782                                                  
3783  ***      0      0                           0      open my $PID_FH, '>', $PID_file
3784                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
3785  ***      0      0                           0      print $PID_FH $PID
3786                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
3787  ***      0      0                           0      close $PID_FH
3788                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
3789                                                  
3790  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
3791  ***      0                                  0      return;
3792                                                  }
3793                                                  
3794                                                  sub _remove_PID_file {
3795  ***      0                    0             0      my ( $self ) = @_;
3796  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
3797  ***      0      0                           0         unlink $self->{PID_file}
3798                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
3799  ***      0                                  0         MKDEBUG && _d('Removed PID file');
3800                                                     }
3801                                                     else {
3802  ***      0                                  0         MKDEBUG && _d('No PID to remove');
3803                                                     }
3804  ***      0                                  0      return;
3805                                                  }
3806                                                  
3807                                                  sub DESTROY {
3808  ***      0                    0             0      my ( $self ) = @_;
3809  ***      0      0      0                    0      $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
3810  ***      0                                  0      return;
3811                                                  }
3812                                                  
3813                                                  sub _d {
3814  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3815  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3816  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3817                                                          @_;
3818  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3819                                                  }
3820                                                  
3821                                                  1;
3822                                                  
3823                                                  # ###########################################################################
3824                                                  # End Daemon package
3825                                                  # ###########################################################################
3826                                                  
3827                                                  # ###########################################################################
3828                                                  # QueryExecutor package 4003
3829                                                  # ###########################################################################
3830                                                  package QueryExecutor;
3831                                                  
3832           1                    1             7   use strict;
               1                                  6   
               1                                  7   
3833           1                    1            10   use warnings FATAL => 'all';
               1                                  2   
               1                                  7   
3834                                                  
3835           1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  4   
3836           1                    1            12   use Time::HiRes qw(time);
               1                                  3   
               1                                  6   
3837                                                  
3838           1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  8   
3839                                                  
3840                                                  sub new {
3841           2                    2            11      my ( $class, %args ) = @_;
3842           2                                  9      foreach my $arg ( qw() ) {
3843  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3844                                                     }
3845           2                                 13      my $self = {
3846                                                     };
3847           2                                 23      return bless $self, $class;
3848                                                  }
3849                                                  
3850                                                  sub exec {
3851           4                    4            32      my ( $self, %args ) = @_;
3852           4                                 19      foreach my $arg ( qw(query host1_dbh host2_dbh) ) {
3853  ***     12     50                          54         die "I need a $arg argument" unless $args{$arg};
3854                                                     }
3855                                                     return {
3856           4                                 26         host1 => $self->_exec_query($args{query}, $args{host1_dbh}),
3857                                                        host2 => $self->_exec_query($args{query}, $args{host2_dbh}),
3858                                                     };
3859                                                  }
3860                                                  
3861                                                  sub _exec_query {
3862           8                    8            42      my ( $self, $query, $dbh ) = @_;
3863  ***      8     50                          31      die "I need a query" unless $query;
3864  ***      8     50                          26      die "I need a dbh"   unless $dbh;
3865                                                  
3866           8                                 23      my ( $start, $end, $query_time );
3867           8                                 20      eval {
3868           8                                 40         $start = time();
3869           8                                708         $dbh->do($query);
3870           4                                 27         $end   = time();
3871           4                                 81         $query_time = sprintf '%.6f', $end - $start;
3872                                                     };
3873           8    100                          38      if ( $EVAL_ERROR ) {
3874           4                                 34         return $EVAL_ERROR;
3875                                                     }
3876                                                  
3877           4                                 10      my $warnings = $dbh->selectall_hashref('SHOW WARNINGS', 'Code');
3878           4                                 79      my $warning_count = @{$dbh->selectall_arrayref('SELECT @@warning_count',
               4                                 46   
3879                                                        { Slice => {} })}[0]->{'@@warning_count'};
3880                                                  
3881           4                                 46      my $results = {
3882                                                        Query_time    => $query_time,
3883                                                        warnings      => $warnings,
3884                                                        warning_count => $warning_count,
3885                                                     };
3886                                                  
3887           4                                 29      return $results;
3888                                                  }   
3889                                                  
3890                                                  sub _d {
3891  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3892  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3893  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3894                                                          @_;
3895  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3896                                                  }
3897                                                  
3898                                                  1;
3899                                                  
3900                                                  # ###########################################################################
3901                                                  # End QueryExecutor package
3902                                                  # ###########################################################################
3903                                                  
3904                                                  # ###########################################################################
3905                                                  # QueryRanker package 4002
3906                                                  # ###########################################################################
3907                                                  package QueryRanker;
3908                                                  
3909                                                  
3910           1                    1             7   use strict;
               1                                  2   
               1                                  6   
3911           1                    1            10   use warnings FATAL => 'all';
               1                                  2   
               1                                 23   
3912                                                  
3913           1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  6   
3914           1                    1             6   use POSIX qw(floor);
               1                                  8   
               1                                  6   
3915                                                  
3916           1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  6   
3917                                                  
3918                                                  my @bucket_threshold = qw(500 100  100   500 50   50    20 1   );
3919                                                  my @bucket_labels    = qw(1us 10us 100us 1ms 10ms 100ms 1s 10s+);
3920                                                  
3921                                                  sub new {
3922           2                    2             8      my ( $class, %args ) = @_;
3923           2                                  8      foreach my $arg ( qw() ) {
3924  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3925                                                     }
3926           2                                  8      my $self = {
3927                                                     };
3928           2                                 21      return bless $self, $class;
3929                                                  }
3930                                                  
3931                                                  sub rank {
3932           2                    2             7      my ( $self, $results ) = @_;
3933  ***      2     50                           9      die "I need a results argument" unless $results;
3934                                                     
3935           2                                  7      my $rank    = 0;   # total rank
3936           2                                  6      my @reasons = ();  # all reasons
3937           2                                  6      my @res     = ();  # ($rank, @reasons) for each comparison
3938           2                                  6      my $host1   = $results->{host1};
3939           2                                  7      my $host2   = $results->{host2};
3940                                                  
3941           2                                 14      @res = $self->compare_query_times($host1->{Query_time},$host2->{Query_time});
3942           2                                  7      $rank += shift @res;
3943           2                                  6      push @reasons, @res;
3944                                                  
3945  ***      2     50     33                   25      if ( $host1->{warning_count} > 0 || $host2->{warning_count} > 0 ) {
3946  ***      0                                  0         $rank += 1;
3947  ***      0                                  0         push @reasons, "Query has warnings (rank+1)";
3948                                                     }
3949                                                  
3950  ***      2     50                          13      if ( my $diff = abs($host1->{warning_count} - $host2->{warning_count}) ) {
3951  ***      0                                  0         $rank += $diff;
3952  ***      0                                  0         push @reasons, "Warning counts differ by $diff (rank+$diff)";
3953                                                     }
3954                                                  
3955           2                                 14      @res = $self->compare_warnings($host1->{warnings}, $host2->{warnings});
3956           2                                  6      $rank += shift @res;
3957           2                                  6      push @reasons, @res;
3958                                                  
3959           2                                  9      return $rank, @reasons;
3960                                                  }
3961                                                  
3962                                                  sub compare_query_times {
3963           2                    2            11      my ( $self, $t1, $t2 ) = @_;
3964  ***      2     50                           9      die "I need a t1 argument" unless defined $t1;
3965  ***      2     50                          10      die "I need a t2 argument" unless defined $t2;
3966                                                  
3967           2                                 12      my $t1_bucket = bucket_for($t1);
3968           2                                  8      my $t2_bucket = bucket_for($t2);
3969                                                  
3970  ***      2     50                           9      if ( $t1_bucket != $t2_bucket ) {
3971  ***      0                                  0         my $rank_inc = 2 * abs($t1_bucket - $t2_bucket);
3972  ***      0                                  0         return $rank_inc, "Query times differ significantly: "
3973                                                           . "host1 in ".$bucket_labels[$t1_bucket]." range, "
3974                                                           . "host2 in ".$bucket_labels[$t2_bucket]." range (rank+2)";
3975                                                     }
3976                                                  
3977           2                                 12      my $inc = percentage_increase($t1, $t2);
3978  ***      2     50                          13      if ( $inc >= $bucket_threshold[$t1_bucket] ) {
3979  ***      0                                  0         return 1, "Query time increase $inc\% exceeds "
3980                                                           . $bucket_threshold[$t1_bucket] . "\% increase threshold for "
3981                                                           . $bucket_labels[$t1_bucket] . " range (rank+1)";
3982                                                     }
3983                                                  
3984           2                                  8      return (0);  # No significant difference.
3985                                                  }
3986                                                  
3987                                                  sub compare_warnings {
3988           2                    2            10      my ( $self, $warnings1, $warnings2 ) = @_;
3989  ***      2     50                           8      die "I need a warnings1 argument" unless defined $warnings1;
3990  ***      2     50                          47      die "I need a warnings2 argument" unless defined $warnings2;
3991                                                  
3992           2                                  7      my %new_warnings;
3993           2                                  7      my $rank_inc = 0;
3994           2                                  5      my @reasons;
3995                                                  
3996           2                                 13      foreach my $code ( keys %$warnings1 ) {
3997  ***      0      0                           0         if ( exists $warnings2->{$code} ) {
3998  ***      0      0                           0            if ( $warnings2->{$code}->{Level} ne $warnings1->{$code}->{Level} ) {
3999  ***      0                                  0               $rank_inc += 2;
4000  ***      0                                  0               push @reasons, "Error $code changes level: "
4001                                                                 . $warnings1->{$code}->{Level} . " on host1, "
4002                                                                 . $warnings2->{$code}->{Level} . " on host2 (rank+2)";
4003                                                           }
4004                                                        }
4005                                                        else {
4006  ***      0                                  0            MKDEBUG && _d('New warning in warnings1:', $code);
4007  ***      0                                  0            push @reasons, "Error $code on host1 is new (rank+3)";
4008  ***      0                                  0            %{ $new_warnings{$code} } = %{ $warnings1->{$code} };
      ***      0                                  0   
      ***      0                                  0   
4009                                                        }
4010                                                     }
4011                                                  
4012           2                                 10      foreach my $code ( keys %$warnings2 ) {
4013  ***      0      0      0                    0         if ( !exists $warnings1->{$code} && !exists $new_warnings{$code} ) {
4014  ***      0                                  0            MKDEBUG && _d('New warning in warnings2:', $code);
4015  ***      0                                  0            push @reasons, "Error $code on host2 is new (rank+3)";
4016  ***      0                                  0            %{ $new_warnings{$code} } = %{ $warnings2->{$code} };
      ***      0                                  0   
      ***      0                                  0   
4017                                                        }
4018                                                     }
4019                                                  
4020           2                                  9      $rank_inc += 3 * scalar keys %new_warnings;
4021                                                  
4022                                                  
4023           2                                 10      return $rank_inc, @reasons;
4024                                                  }
4025                                                  
4026                                                  sub bucket_for {
4027           4                    4            19      my ( $val ) = @_;
4028  ***      4     50                          20      die "I need a val" unless defined $val;
4029  ***      4     50                          22      return 0 if $val == 0;
4030           4                                 52      my $bucket = floor(log($val) / log(10)) + 6;
4031  ***      4     50                          25      $bucket = $bucket > 7 ? 7 : $bucket < 0 ? 0 : $bucket;
      ***            50                               
4032           4                                 13      return $bucket;
4033                                                  }
4034                                                  
4035                                                  sub percentage_increase {
4036           2                    2             8      my ( $x, $y ) = @_;
4037  ***      2     50                          12      return 0 if $x == $y;
4038                                                  
4039  ***      2     50                           9      if ( $x > $y ) {
4040           2                                  5         my $z = $y;
4041           2                                  5            $y = $x;
4042           2                                  7            $x = $z;
4043                                                     }
4044                                                  
4045  ***      2     50                           8      if ( $x == 0 ) {
4046  ***      0                                  0         return 1000;  # This should trigger all buckets' thresholds.
4047                                                     }
4048                                                  
4049           2                                 25      return sprintf '%.2f', (($y - $x) / $x) * 100;
4050                                                  }
4051                                                  
4052                                                  sub _d {
4053  ***      0                    0             0      my ($package, undef, $line) = caller 0;
4054  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
4055  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
4056                                                          @_;
4057  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4058                                                  }
4059                                                  
4060                                                  1;
4061                                                  
4062                                                  # ###########################################################################
4063                                                  # End QueryRanker package
4064                                                  # ###########################################################################
4065                                                  
4066                                                  # ###########################################################################
4067                                                  # This is a combination of modules and programs in one -- a runnable module.
4068                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
4069                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
4070                                                  #
4071                                                  # Check at the end of this package for the call to main() which actually runs
4072                                                  # the program.
4073                                                  # ###########################################################################
4074                                                  package mk_upgrade;
4075                                                  
4076           1                    1             7   use English qw(-no_match_vars);
               1                                  2   
               1                                  5   
4077           1                    1             7   use Time::HiRes qw(time);
               1                                  2   
               1                                  5   
4078           1                    1             6   use Data::Dumper;
               1                                  2   
               1                                  8   
4079                                                  $Data::Dumper::Indent    = 1;
4080                                                  $Data::Dumper::Sortkeys  = 1;
4081                                                  $Data::Dumper::Quotekeys = 0;
4082                                                  
4083                                                  Transformers->import(qw());
4084                                                  
4085           1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  7   
4086                                                  
4087           1                    1            11   use sigtrap 'handler', \&sig_int, 'normal-signals';
               1                                  2   
               1                                 14   
4088                                                  
4089                                                  # Global variables.  Only really essential variables should be here.
4090                                                  my $oktorun = 1;
4091                                                  
4092                                                  sub main {
4093           2                    2            48      @ARGV = @_;  # set global ARGV for this package
4094                                                  
4095                                                     # ##########################################################################
4096                                                     # Get configuration information.
4097                                                     # ##########################################################################
4098           2                                 46      my $dp = new DSNParser();
4099           2                                 30      my $o  = new OptionParser(
4100                                                        strict      => 0,
4101                                                        dp          => $dp,
4102                                                        prompt      => '[OPTION...] HOST-1-DSN HOST-2-DSN FILE',
4103                                                        description => q{compares two hosts by executing queries in the given }
4104                                                                     . q{file (or STDIN if no file given) and examining the }
4105                                                                     . q{results, errors, warnings, etc. produced on each.},
4106                                                     );
4107           2                                 11      $o->get_specs();
4108           2                                 17      $o->get_opts();
4109                                                  
4110  ***      2     50                          12      if ( !$o->get('help') ) {
4111  ***      2     50                          13         if ( @ARGV < 2 ) {
4112  ***      0                                  0            $o->save_error('Specify at least two host DSNs');
4113                                                        }
4114                                                     }
4115                                                  
4116           2                                 15      $o->usage_or_errors();
4117                                                  
4118                                                     # ########################################################################
4119                                                     # Parse the host DSNs and make sure that we can connect to each.
4120                                                     # ########################################################################
4121                                                     # TODO: make sure host2 dsn inherits from host1 dsn.
4122           2                                 17      my $host1_dsn = $dp->parse(shift @ARGV);
4123           2                                 16      my $host1_dbh = get_cxn($dp, $o, $host1_dsn);
4124           2                                 15      my $host2_dbh = get_cxn($dp, $o, $dp->parse(shift @ARGV, $host1_dsn));
4125                                                  
4126                                                  
4127                                                     # ########################################################################
4128                                                     # Make some common modules.
4129                                                     # ########################################################################
4130           2                                 35      my $parser  = new SlowLogParser();
4131           2                                 27      my $qexec   = new QueryExecutor();
4132           2                                 21      my $qranker = new QueryRanker();
4133                                                  
4134                                                  
4135                                                     # ########################################################################
4136                                                     # Set up an array of callbacks to transform, filter and process events.
4137                                                     # Results are saved in %results and compared and reported after all
4138                                                     # events have been processed.
4139                                                     # ########################################################################
4140           2                                  6      my @callbacks;
4141           2                                  6      my %results;
4142                                                  
4143                                                     # For the moment we only support deterministic SELECT queries.
4144                                                     # There's no filter/transformation for non-deterministic functions yet,
4145                                                     # just a simple filter to remove non-SELECTs.
4146                                                     # TODO: this will become QueryFilter.
4147                                                     push @callbacks, sub {
4148           4                    4            15         my ( $event ) = @_;
4149  ***      4     50                          22         return unless $event->{cmd} eq 'Query';
4150  ***      4     50                          16         return unless $event->{arg};
4151  ***      4     50                          40         return $event if $event->{arg} =~ m/^SELECT/i;  # Query passes.
4152  ***      0                                  0         return;  # Non-SELECT; query fails.
4153           2                                 21      };
4154                                                  
4155                                                     # User-defined filter.
4156  ***      2     50                          11      if ( $o->get('filter') ) {
4157  ***      0                                  0         my $filter = $o->get('filter');
4158  ***      0                                  0         my $code   = "sub { my (\$event) = shift; $filter && return \$event; };";
4159  ***      0                                  0         MKDEBUG && _d('--filter code:', $code);
4160  ***      0      0                           0         my $sub = eval $code or die;
4161  ***      0                                  0         push @callbacks, $sub;
4162                                                     }
4163                                                  
4164                                                     # Now we should have only the queries that we want, and they should
4165                                                     # have all appropriate transformations.  The real work begins here.
4166                                                  
4167                                                     # Execute and time the query on each host.
4168           2                                  7      my $current_db;
4169                                                     push @callbacks, sub {
4170  ***      4            50      4            16         my ( $event ) = @_;
      ***                   50                        
4171           4                                 15         my $db    = $event->{db}; 
4172           4                                 13         my $query = $event->{arg};
4173                                                  
4174                                                        # Set rank=0 so that any potential rank+=N ops won't die because
4175                                                        # rank is undef.
4176  ***      4            50                   29         $results{ $query }->{rank}    ||= 0;
4177  ***      4            50                   21         $results{ $query }->{reasons} ||= ();
4178                                                  
4179           4                                 11         eval {
4180  ***      4    100     66                   49            if ( $db && (!$current_db || $db ne $current_db) ) {
      ***                   66                        
4181           2                                  5               MKDEBUG && _d('USE', $db);
4182           2                                244               $host1_dbh->do("USE $db");
4183           2                                186               $host2_dbh->do("USE $db");  
4184           2                                  9               $current_db = $db;
4185                                                           }
4186                                                  
4187           4                                 28            my $results = $qexec->exec(
4188                                                              query     => $query,
4189                                                              host1_dbh => $host1_dbh,
4190                                                              host2_dbh => $host2_dbh,
4191                                                           );
4192                                                           # Results are compared and reported later.
4193           4                                 22            $results{ $query }->{execution} = $results;
4194                                                        };
4195  ***      4     50                          17         if ( $EVAL_ERROR ) {
4196  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
4197                                                           # Normally results are hashrefs, but strings signal no results
4198                                                           # due to the error given in the string.
4199  ***      0                                  0            $results{ $query }->{execution} = $EVAL_ERROR;
4200                                                        }
4201           4                                 23         return $event;
4202           2                                 32      };
4203                                                  
4204                                                     # Rank the query's execution and warnings.
4205                                                     push @callbacks, sub {
4206           4                    4            14         my ( $event ) = @_;
4207           4                                 17         my $query = $event->{arg};
4208  ***      4    100     66                   40         if ( ref $results{ $query }->{execution}->{host1}
4209                                                             && ref $results{ $query }->{execution}->{host2} ) {
4210           2                                150            my @results = $qranker->rank( $results{ $query }->{execution} ); 
4211           2                                  8            $results{ $query }->{rank} += shift @results;
4212           2                                  6            push @{$results{ $query }->{reasons}}, @results;
               2                                 15   
4213                                                        }
4214                                                        else {
4215           2                                  7            MKDEBUG && _d('No results for event');
4216           2                                 15            $results{ $query }->{rank} += 100;
4217           2                                  5            push @{$results{ $query }->{reasons}},
               2                                 13   
4218                                                              "Query cannot be executed (rank+100)";
4219                                                        }
4220           4                                 24         return $event;
4221           2                                 19      };
4222                                                  
4223                                                  
4224                                                     # ########################################################################
4225                                                     # Daemonize now that everything is setup and ready to work.
4226                                                     # ########################################################################
4227           2                                  6      my $daemon;
4228  ***      2     50                           8      if ( $o->get('daemonize') ) {
4229  ***      0                                  0         $daemon = new Daemon(o=>$o);
4230  ***      0                                  0         $daemon->daemonize();
4231  ***      0                                  0         MKDEBUG && _d('I am a daemon now');
4232                                                     }
4233                                                  
4234                                                  
4235                                                     # ##########################################################################
4236                                                     # Parse input and process events.
4237                                                     # ##########################################################################
4238  ***      2     50                          15      if ( @ARGV == 0 ) {
4239  ***      0                                  0         MKDEBUG && _d('Reading STDIN');
4240  ***      0                                  0         push @ARGV, '-'; # Magical STDIN filename.
4241                                                     }
4242                                                  
4243           2                                 29      my $start = time();
4244  ***      2            50                    9      my $end   = $start + ($o->get('run-time') || 0); # When we should exit
4245           2                                  6      my $now   = $start;
4246                                                  
4247                                                     FILE:
4248  ***      2            33                   36      while (                                 # Quit if:
      ***                   33                        
      ***                   66                        
4249                                                        $oktorun                             # instructed to quit
4250                                                        && ($start == $end || $now < $end)   # or time is exceeded
4251                                                        && @ARGV )                           # or there's no more files
4252                                                     {
4253           2                                  8         my $file = shift @ARGV;
4254           2                                  4         MKDEBUG && _d('Parsing', $file);
4255           2                                  5         my $fh;
4256  ***      2     50                           9         if ( $file eq '-' ) {
4257  ***      0                                  0            $fh = *STDIN;
4258                                                        }
4259                                                        else {
4260  ***      2     50                          73            if ( !open $fh, "<", $file ) {
4261  ***      0                                  0               warn "Cannot open $file: $OS_ERROR";
4262  ***      0                                  0               next FILE;
4263                                                           }
4264                                                        }
4265                                                  
4266           2                                  6         my $events;
4267                                                        EVENT:
4268  ***      2            33                   22         while ( $oktorun
      ***                   33                        
4269                                                                && ($start == $end || $now < $end) ) {
4270           6                                 17            eval {
4271           6                                 38               $events = $parser->parse_event($fh, undef, @callbacks);
4272                                                           };
4273  ***      6     50                          23            if ( $EVAL_ERROR ) {
4274  ***      0                                  0               _d($EVAL_ERROR);
4275  ***      0      0                           0               last EVENT unless $o->get('continue-on-error');
4276                                                           }
4277           6    100                          23            last EVENT unless $events;
4278           4                                 50            $now = time();
4279                                                        }
4280                                                  
4281           2                                 21         close $fh;
4282           2                                  6         $now = time();
4283                                                     }
4284                                                  
4285                                                  
4286                                                     # ######################################################################
4287                                                     # Report results.
4288                                                     # ######################################################################
4289                                                     QUERY:
4290           2                                  4      foreach my $query (
               2                                 10   
4291                                                        sort { $results{$b}->{rank} <=> $results{$a}->{rank} } keys %results )
4292                                                     {
4293  ***      4     50                          25         if ( $o->get('dump-results') ) {
4294  ***      0                                  0            print Dumper($results{$query});
4295  ***      0                                  0            next QUERY;
4296                                                        }
4297                                                  
4298           4                                 29         print "# Rank: $results{$query}->{rank}\n";
4299                                                  
4300           4                                 15         my $reasons = $results{$query}->{reasons};
4301           4    100                          18         print "# Reasons: " . (@$reasons == 0 ? "none\n" : "\n");
4302           4                                 20         for my $i ( 0..(scalar @$reasons - 1) ) {
4303           2                                 19            print '#   ',$i+1,". $reasons->[$i]\n";
4304                                                        }
4305                                                  
4306           4                                 10         print "# Execution Results:\n";
4307           4                                 24         print_execution_results('host1', $results{$query}->{execution}->{host1});
4308           4                                 19         print_execution_results('host2', $results{$query}->{execution}->{host2});
4309                                                  
4310           4                                 17         print "$query\n\n";
4311                                                     }
4312                                                  
4313           2                                 90      $host1_dbh->disconnect();
4314           2                                 49      $host2_dbh->disconnect();
4315           2                                348      return 0;
4316                                                  
4317                                                  } # End main().
4318                                                  
4319                                                  # ############################################################################
4320                                                  # Subroutines.
4321                                                  # ############################################################################
4322                                                  sub print_execution_results {
4323           8                    8            34      my ( $host, $res ) = @_;
4324                                                  
4325           8                                 46      print "#   $host\n"
4326                                                         . "#   " . ('=' x length $host) . "\n";
4327           8    100                          27      if ( ref $res ) {
4328           4                                 14         my $warnings = $res->{warnings};
4329                                                  
4330           4                                 15         print '#   Query time: ', $res->{Query_time}, "\n";
4331           4                                 14         print '#   Warning count: ', $res->{warning_count}, "\n";
4332  ***      4     50                          19         print '#   Warnings: ' . (scalar keys %$warnings == 0 ? "none\n" : "\n");
4333                                                  
4334           4                                 22         foreach my $code ( sort { $b <=> $a } keys %$warnings ) {
      ***      0                                  0   
4335  ***      0                                  0            print "#     $code $warnings->{$code}->{Level} "
4336                                                              . "$warnings->{$code}->{Message}\n";
4337                                                        }
4338                                                     }
4339                                                     else { 
4340           4                                 18         print "#   Error executing query on $host: $res";
4341                                                     }
4342                                                  
4343           8                                 24      print "#\n";  # Spacing between hosts.
4344                                                  
4345           8                                 19      return;
4346                                                  }
4347                                                  
4348                                                  sub get_cxn {
4349           4                    4            19      my ( $dp, $o, $dsn ) = @_;
4350  ***      4     50                          22      if ( $o->get('ask-pass') ) {
4351  ***      0                                  0         $dsn->{p} = OptionParser::prompt_noecho("Enter password: ");
4352                                                     }
4353           4                                 27      my $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), {AutoCommit => 1});
4354           4                                 26      return $dbh;
4355                                                  }
4356                                                  
4357                                                  # Catches signals so we can exit gracefully.
4358                                                  # TODO: test this
4359                                                  # TODO: break wait for <$fh> with SIGINT.  Possibly by closing all $fh?
4360                                                  sub sig_int {
4361  ***      0                    0             0      my ( $signal ) = @_;
4362  ***      0      0                           0      if ( $oktorun ) {
4363  ***      0                                  0         print STDERR "# Caught SIG$signal.\n";
4364  ***      0                                  0         $oktorun = 0;
4365                                                     }
4366                                                     else {
4367  ***      0                                  0         print STDERR "# Exiting on SIG$signal.\n";
4368  ***      0                                  0         exit(1);
4369                                                     }
4370                                                  }
4371                                                  
4372                                                  sub _d {
4373           1                    1             9      my ($package, undef, $line) = caller 0;
4374  ***      1     50                           7      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
               1                                  5   
               1                                  8   
4375           1                                  5           map { defined $_ ? $_ : 'undef' }
4376                                                          @_;
4377           1                                  3      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4378                                                  }
4379                                                  
4380                                                  # ############################################################################
4381                                                  # Run the program.
4382                                                  # ############################################################################
4383                                                  if ( !caller ) { exit main(@ARGV); }
4384                                                  
4385                                                  1; # Because this is a module as well as a script.
4386                                                  
4387                                                  # #############################################################################
4388                                                  # Documentation.
4389                                                  # #############################################################################
4390                                                  
4391                                                  =pod
4392                                                  
4393                                                  =head1 NAME
4394                                                  
4395                                                  mk-upgrade - Compare SQL statements on different MySQL servers.
4396                                                  
4397                                                  =head1 SYNOPSIS
4398                                                  
4399                                                  Compare queries in slow.log on host1 to host2:
4400                                                  
4401                                                     mk-upgrade h=host1 h=host2 slow.log
4402                                                  
4403                                                  Use mk-query-digest to parse tcpdump and compare queries:
4404                                                  
4405                                                    mk-query-digest --type tcpdump --report '' --print tcpdump.txt | mk-upgrade h=host1 h=host2
4406                                                  
4407                                                  =head1 DESCRIPTION
4408                                                  
4409                                                  mk-upgrade compares and ranks how the results of SQL statements differ when
4410                                                  executed on different MySQL servers.  These ranked differences help to test
4411                                                  upgrade (or downgrade) compatibility.  The higher a query ranks, the greater
4412                                                  its results differ.
4413                                                  
4414                                                  mk-upgrade reads only slow logs.  mk-query-digest can be used to parse and
4415                                                  transform other input sources into a slow log using its C<--print --report ''>
4416                                                  options.
4417                                                  
4418                                                  At present, queries are not fingerprinted or aggregated.  Every query is
4419                                                  executed, compared and ranked individually.  This will change later.
4420                                                  
4421                                                  =head1 OPTIONS
4422                                                  
4423                                                  =over
4424                                                  
4425                                                  =item --ask-pass
4426                                                  
4427                                                  Prompt for a password when connecting to MySQL.
4428                                                  
4429                                                  =item --charset
4430                                                  
4431                                                  short form: -A; type: string
4432                                                  
4433                                                  Default character set.  If the value is utf8, sets Perl's binmode on
4434                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
4435                                                  runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
4436                                                  binmode on STDOUT without the utf8 layer, and runs SET NAMES after
4437                                                  connecting to MySQL.
4438                                                  
4439                                                  =item --config
4440                                                  
4441                                                  type: Array
4442                                                  
4443                                                  Read this comma-separated list of config files; if specified, this must be the
4444                                                  first option on the command line.
4445                                                  
4446                                                  =item --continue-on-error
4447                                                  
4448                                                  Continue parsing even if there is an error.
4449                                                  
4450                                                  =item --daemonize
4451                                                  
4452                                                  Fork to the background and detach from the shell.  POSIX
4453                                                  operating systems only.
4454                                                  
4455                                                  =item --dump-results
4456                                                  
4457                                                  Don't print a human-readable report, just dump the raw results.
4458                                                  
4459                                                  =item --filter
4460                                                  
4461                                                  type: string
4462                                                  
4463                                                  Discard events for which this Perl code doesn't return true.
4464                                                  
4465                                                  This option is a string of Perl code that gets compiled into a subroutine with
4466                                                  one argument: $event.  This is a hashref.  If the code returns true, the chain
4467                                                  of callbacks continues; otherwise it ends.  The code is the last statement in
4468                                                  the subroutine other than C<return $event>.
4469                                                  
4470                                                  An example filter that discards everything but SELECT statements:
4471                                                  
4472                                                    --filter '$event->{arg} =~ m/^select/i'
4473                                                  
4474                                                  This is compiled into a subroutine like the following:
4475                                                  
4476                                                    sub { $event = shift; $event->{arg} =~ m/^select/i && return $event; }
4477                                                  
4478                                                  It is permissible for the code to have side effects (to alter $event).
4479                                                  
4480                                                  =item --help
4481                                                  
4482                                                  Show help and exit.
4483                                                  
4484                                                  =item --host
4485                                                  
4486                                                  short form: -h; type: string
4487                                                  
4488                                                  Connect to host.
4489                                                  
4490                                                  =item --log
4491                                                  
4492                                                  type: string
4493                                                  
4494                                                  Print all output to this file when daemonized.
4495                                                  
4496                                                  =item --password
4497                                                  
4498                                                  short form: -p; type: string
4499                                                  
4500                                                  Password to use when connecting.
4501                                                  
4502                                                  =item --pid
4503                                                  
4504                                                  type: string
4505                                                  
4506                                                  Create the given PID file when daemonized.  The file contains the process
4507                                                  ID of the daemonized instance.  The PID file is removed when the
4508                                                  daemonized instance exits.  The program checks for the existence of the
4509                                                  PID file when starting; if it exists and the process with the matching PID
4510                                                  exists, the program exits.
4511                                                  
4512                                                  =item --port
4513                                                  
4514                                                  short form: -P; type: int
4515                                                  
4516                                                  Port number to use for connection.
4517                                                  
4518                                                  =item --run-time
4519                                                  
4520                                                  type: time
4521                                                  
4522                                                  How long to run before exiting.  The default is to run forever (you can
4523                                                  interrupt with CTRL-C).
4524                                                  
4525                                                  =item --socket
4526                                                  
4527                                                  short form: -S; type: string
4528                                                  
4529                                                  Socket file to use for connection.
4530                                                  
4531                                                  =item --user
4532                                                  
4533                                                  short form: -u; type: string
4534                                                  
4535                                                  User for login if not current user.
4536                                                  
4537                                                  =item --version
4538                                                  
4539                                                  Show version and exit.
4540                                                  
4541                                                  =back
4542                                                  
4543                                                  =head1 DOWNLOADING
4544                                                  
4545                                                  You can download Maatkit from Google Code at
4546                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
4547                                                  easily with a command like the following:
4548                                                  
4549                                                     wget http://www.maatkit.org/get/toolname
4550                                                     or
4551                                                     wget http://www.maatkit.org/trunk/toolname
4552                                                  
4553                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
4554                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
4555                                                  needed.  The first URL gets the latest released version of the tool, and the
4556                                                  second gets the latest trunk code from Subversion.
4557                                                  
4558                                                  =head1 SYSTEM REQUIREMENTS
4559                                                  
4560                                                  You need Perl and some core packages that ought to be installed in any
4561                                                  reasonably new version of Perl.
4562                                                  
4563                                                  =head1 ENVIRONMENT
4564                                                  
4565                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
4566                                                  the Maatkit tools:
4567                                                  
4568                                                     MKDEBUG=1 mk-....
4569                                                  
4570                                                  =head1 BUGS
4571                                                  
4572                                                  Please use Google Code Issues and Groups to report bugs or request support:
4573                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
4574                                                  discuss Maatkit.
4575                                                  
4576                                                  Please include the complete command-line used to reproduce the problem you are
4577                                                  seeing, the version of all MySQL servers involved, the complete output of the
4578                                                  tool when run with L<"--version">, and if possible, debugging output produced by
4579                                                  running with the C<MKDEBUG=1> environment variable.
4580                                                  
4581                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
4582                                                  
4583                                                  This program is copyright 2009-@CURRENTYEAR@ Percona, Inc.
4584                                                  Feedback and improvements are welcome.
4585                                                  
4586                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
4587                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
4588                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
4589                                                  
4590                                                  This program is free software; you can redistribute it and/or modify it under
4591                                                  the terms of the GNU General Public License as published by the Free Software
4592                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
4593                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
4594                                                  licenses.
4595                                                  
4596                                                  You should have received a copy of the GNU General Public License along with
4597                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
4598                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
4599                                                  
4600                                                  =head1 AUTHOR
4601                                                  
4602                                                  Baron Schwartz, Daniel Nichter
4603                                                  
4604                                                  =head1 VERSION
4605                                                  
4606                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 4004 $.
4607                                                  
4608                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
98    ***     50      0     18   if (@_ > 2)
107   ***     50      0      6   if (not $dsn)
119   ***     50     11      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
131          100      1     47   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
137          100     36     12   if (not defined $final_props{$key})
144   ***     50      0     11   unless exists $opts{$key}
147   ***     50      0      6   if (my $required = $self->prop('required'))
149   ***      0      0      0   unless $final_props{$key}
158   ***      0      0      0   unless ref $o eq 'OptionParser'
161   ***      0      0      0   if $o->has($_)
171   ***      0      0      0   unless ref $dsn
172   ***      0      0      0   $_ eq 'p' ? :
173   ***      0      0      0   if defined $$dsn{$_}
186   ***      0      0      0   $opts{$key}{'copy'} ? :
200   ***     50      0      6   if ($driver eq 'Pg') { }
232   ***     50      0      6   $cxn_string =~ /charset=utf8/ ? :
249   ***     50      6      0   if ($cxn_string =~ /mysql/i)
257   ***     50      0      6   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
262   ***      0      0      0   if ($charset eq 'utf8') { }
263   ***      0      0      0   unless binmode STDOUT, ':utf8'
267   ***      0      0      0   unless binmode STDOUT
271   ***     50      0      6   if ($self->prop('setvars'))
278   ***     50      0      6   if (not $dbh and $EVAL_ERROR)
280   ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/)
284   ***      0      0      0   if (not $tries)
306   ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
323   ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
333   ***      0      0      0   unless $dsn_1
334   ***      0      0      0   unless $dsn_2
338   ***      0      0      0   if ($args{'overwrite'}) { }
339   ***      0      0      0   defined $$dsn_1{$key} ? :
342   ***      0      0      0   defined $$dsn_2{$key} ? :
351   ***      0      0      0   defined $_ ? :
392   ***      0      0      0   if (defined $_) { }
394   ***      0      0      0   $_ eq '' || $_ =~ /^0|\D/ ? :
407   ***      0      0      0   if (not $tbl)
448   ***     50      0      2   unless $args{$arg}
453   ***     50      2      0   exists $args{'strict'} ? :
496   ***     50      0      2   unless open my $fh, '<', $file
516          100   1144      2   unless $para =~ /^=head1 OPTIONS/
521   ***     50      2      0   if $para =~ /^=over/
529   ***     50      0      2   unless $para
532          100     34      2   if (my($option) = $para =~ /^=item --(.*)/)
539          100     22     12   if ($para =~ /: /) { }
543   ***     50      0     34   unless $attributes{$attrib}
547          100     12     10   if ($attribs{'short form'})
563   ***     50      0     34   if $para =~ /^=item/
565   ***     50      0     34   if (my($base_option) = $option =~ /^\[no\](.*)/)
570          100     12     22   $attribs{'short form'} ? :
      ***     50      0     34   $attribs{'negatable'} ? :
      ***     50      0     34   $attribs{'cumulative'} ? :
             100     22     12   $attribs{'type'} ? :
      ***     50      0     34   $attribs{'default'} ? :
      ***     50      0     34   $attribs{'group'} ? :
582   ***     50      0     50   unless $para
585          100      2     48   if ($para =~ /^=head1/)
589          100     34     14   if $para =~ /^=item --/
593   ***     50      0      2   unless @specs
604   ***     50     34      0   if (ref $opt) { }
609   ***     50      0     34   if (not $long)
614   ***     50      0     34   if exists $$self{'opts'}{$long}
617   ***     50      0     34   if (length $long == 1)
622          100     12     22   if ($short) { }
623   ***     50      0     12   if exists $$self{'short_opts'}{$short}
632   ***     50      0     34   $$opt{'spec'} =~ /!/ ? :
633   ***     50      0     34   $$opt{'spec'} =~ /\+/ ? :
634   ***     50      0     34   $$opt{'desc'} =~ /required/ ? :
646   ***     50      0     34   if ($type and $type eq 'd' and not $$self{'dp'})
651          100      4     30   if $type and $type =~ /[HhAadzm]/
653   ***     50      0     34   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
654   ***      0      0      0   if ($$opt{'is_negatable'})
655   ***      0      0      0   $def eq 'no' ? :
      ***      0      0      0   $def eq 'yes' ? :
659   ***      0      0      0   defined $def ? :
663          100      2     32   if ($long eq 'config')
667   ***     50      0     34   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
680   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
685   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
690   ***      0      0      0   if ($opt =~ /default to/)
695   ***      0      0      0   if ($opt =~ /restricted to option groups/)
705   ***      0      0      0   unless $rule_ok
722   ***      0      0      0   unless exists $$self{'opts'}{$long}
738   ***      0      0      0   $$self{'opts'}{$_}{'short'} ? :
756   ***      0      0      0   unless exists $$self{'opts'}{$long}
776   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***      0      0      0   exists $$self{'opts'}{$opt} ? :
781   ***      0      0      0   if ($$opt{'is_cumulative'}) { }
796   ***     50      0     32   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100      2     32   exists $$self{'defaults'}{$long} ? :
805   ***     50      0      2   if (@ARGV and $ARGV[0] eq '--config')
809   ***     50      2      0   if ($self->has('config'))
815   ***     50      8      0   if ($EVAL_ERROR)
816   ***     50      0      8   $self->got('config') ? :
831   ***     50      0      2   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
834   ***     50      0      2   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
835   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
841   ***     50      0      2   if (@ARGV and $$self{'strict'})
847   ***      0      0      0   if (@set > 1)
858   ***      0      0      0   if (@set == 0)
868   ***     50      0     34   if ($$opt{'got'}) { }
      ***     50      0     34   elsif ($$opt{'is_required'}) { }
869   ***      0      0      0   if (exists $$self{'disables'}{$long})
876   ***      0      0      0   if (exists $$self{'allowed_groups'}{$long})
888   ***      0      0      0   if $restricted_opt eq $long
889   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
894   ***      0      0      0   if (@restricted_opts)
896   ***      0      0      0   if (@restricted_opts == 1) { }
925          100     12     22   unless $opt and $$opt{'type'}
928   ***     50      0     22   if ($val and $$opt{'type'} eq 'm') { }
      ***     50      0     22   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0     22   elsif ($val and $$opt{'type'} eq 'z') { }
      ***     50      0     22   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100      2     20   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
931   ***      0      0      0   if (not $suffix)
937   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
938   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
953   ***      0      0      0   if ($from_key)
964   ***      0      0      0   if (defined $num) { }
965   ***      0      0      0   if ($factor)
992   ***     50      0     18   length $opt == 1 ? :
993   ***     50      0     18   unless $long and exists $$self{'opts'}{$long}
1000  ***     50      0      8   length $opt == 1 ? :
1001  ***     50      0      8   unless $long and exists $$self{'opts'}{$long}
1008  ***     50      0      2   length $opt == 1 ? :
1009  ***     50      2      0   defined $long ? :
1014  ***      0      0      0   length $opt == 1 ? :
1015  ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
1049  ***     50      0      2   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0      2   elsif (scalar @{$$self{'errors'};}) { }
1050  ***      0      0      0   unless print $self->print_usage
1054  ***      0      0      0   unless print $self->print_errors
1063  ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
1072  ***      0      0      0   unless $$self{'got_opts'}
1075  ***      0      0      0   $$_{'is_negatable'} ? :
1079  ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
1095  ***      0      0      0   $group eq 'default' ? :
1101  ***      0      0      0   $$opt{'is_negatable'} ? :
1104  ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
1113  ***      0      0      0   if ($short) { }
1122  ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
1126  ***      0      0      0   if ($$self{'dp'})
1134  ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
1146  ***      0      0      0   if ref $_[0] eq 'OptionParser'
1149  ***      0      0      0   unless print $prompt
1157  ***      0      0      0   unless print "\n"
1160  ***      0      0      0   if ($EVAL_ERROR)
1182  ***     50      8      0   unless open my $fh, '<', $filename
1190  ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
1193  ***      0      0      0   if ($line eq '--')
1198  ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
1216  ***      0      0      0   unless open my $fh, '<', $file
1220  ***      0      0      0   unless $para =~ /^=pod$/m
1224  ***      0      0      0   unless $para =~ /$regex/
1229  ***      0      0      0   unless close $fh
1243  ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
1258  ***      0      0      0   defined $_ ? :
1301  ***      0      0      0   defined $args{'p_ms'} ? :
1302  ***      0      0      0   defined $args{'p_s'} ? :
1305  ***      0      0      0   if $t < 0
1307  ***      0      0      0   if $t =~ /e/
1311  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
1332  ***      0      0      0   $p ? :
1339  ***      0      0      0   unless $secs
1341  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
1346  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
1365  ***      0      0      0   defined $args{'p'} ? :
1366  ***      0      0      0   defined $args{'d'} ? :
1373  ***      0      0      0   $num =~ /\./ || $n ? :
1392  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?$/)
1395  ***      0      0      0   defined $f ? :
      ***      0      0      0   defined $f ? :
1404  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s) = $val =~ /^(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(?:\.\d+)?$/)
1421  ***      0      0      0   defined $_ ? :
1486  ***      0      0      0   unless $query =~ /IN\s*\(\s*(?!select)/i
1488  ***      0      0      0   if ($length and length $query > $length)
1494  ***      0      0      0   if ($left)
1508  ***      0      0      0   @right ? :
1521  ***      0      0      0   if $query =~ m[\ASELECT /\*!40001 SQL_NO_CACHE \*/ \* FROM `]
1523  ***      0      0      0   if $query =~ m[/\*\w+\.\w+:[0-9]/[0-9]\*/]
1525  ***      0      0      0   if $query =~ /\A# administrator command: /
1527  ***      0      0      0   if $query =~ /\A\s*(call\s+\S+)\(/i
1529  ***      0      0      0   if (my($beginning) = $query =~ /\A((?:INSERT|REPLACE)(?: IGNORE)? INTO .+? VALUES \(.*?\)),\(/i)
1535  ***      0      0      0   if $query =~ s/\Ause \S+\Z/use ?/i
1563  ***      0      0      0   unless $qp
1565  ***      0      0      0   if $query =~ /\A\s*call\s+(\S+)\(/i
1567  ***      0      0      0   if $query =~ /\A# administrator/
1569  ***      0      0      0   if $query =~ /\A\s*use\s+/
1597  ***      0      0      0   unless $query
1616  ***      0      0      0   unless $query =~ s/
                 \A.*?
                 update\s+(.*?)
                 \s+set\b(.*?)
                 (?:\s*where\b(.*?))?
                 (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
                 \Z
              /__update_to_select($1, $2, $3, $4);/eisx or $query =~ s/
                    \A.*?
                    (?:insert|replace)\s+
                    .*?\binto\b(.*?)\(([^\)]+)\)\s*
                    values?\s*(\(.*?\))\s*
                    (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
                    \Z
                 /__insert_to_select($1, $2, $3);/eisx
1630  ***      0      0      0   $1 =~ /\*/ ? :
1639  ***      0      0      0   if ($join =~ /\bjoin\b/)
1653  ***      0      0      0   if (@cols == @vals) { }
1664  ***      0      0      0   $where ? :
      ***      0      0      0   $limit ? :
1671  ***      0      0      0   unless $query
1672  ***      0      0      0   $query =~ /\A\s*select/i ? :
1679  ***      0      0      0   defined $_ ? :
1730  ***      0      0      0   if (not $curr and @curr)
1734  ***      0      0      0   if (not $prev and @prev)
1738  ***      0      0      0   if ($curr or $prev)
1739  ***      0      0      0   if ($curr and $prev and $$curr[0] == $$prev[0]) { }
      ***      0      0      0   elsif (not $curr or $curr and $prev and $$curr[0] > $$prev[0]) { }
1741  ***      0      0      0   $$curr[5] =~ /\D/ ? :
1743  ***      0      0      0   if ($$prev[7])
1744  ***      0      0      0   if (not $$curr[7] or $$prev[7] ne $$curr[7]) { }
      ***      0      0      0   elsif (defined $$curr[5] and $$curr[5] < $$prev[5]) { }
      ***      0      0      0   elsif ($$curr[7] and defined $$curr[5] and $$misc{'time'} - $$curr[5] - $$prev[8] - $$prev[9] - $$misc{'etime'} > $fudge) { }
1759  ***      0      0      0   if ($is_new)
1763  ***      0      0      0   if ($$curr[7])
1764  ***      0      0      0   if ($$prev[7] and not $is_new) { }
1785  ***      0      0      0   if ($$curr[7] and defined $$curr[5])
1804  ***      0      0      0   if ($$row[5] < $time - $$row[10])
1819  ***      0      0      0   unless $event = &$callback($event)
1829  ***      0      0      0   if ($find_spec{'busy_time'} and ($$query{'Command'} || '') eq 'Query')
1830  ***      0      0      0   if ($$query{'Time'} < $find_spec{'busy_time'})
1839  ***      0      0      0   if (defined $find_spec{'ignore'}{$property} and $self->$filter($query, $find_spec{'ignore'}{$property}))
1845  ***      0      0      0   if (defined $find_spec{'match'}{$property})
1846  ***      0      0      0   if (not $self->$filter($query, $find_spec{'match'}{$property}))
1853  ***      0      0      0   if ($matched)
1858  ***      0      0      0   if (@matches and $find_spec{'only_oldest'})
1908  ***      0      0      0   defined $_ ? :
1944  ***      0      0      0   $$misc{'oktorun'} ? :
1947  ***      0      0      0   if (not $fh)
1957  ***      0      0      0   unless $raw_packet =~ /\A20/
1965  ***      0      0      0   unless $packet = &$callback($packet)
1977  ***      0      0      0   unless $packet
1987  ***      0      0      0   length $data == 2 * $ip_plen ? :
1996  ***      0      0      0   length $data > 8 ? :
      ***      0      0      0   $data ? :
2019  ***      0      0      0   defined $_ ? :
2169  ***      0      0      0   $to =~ /:(?:3306|mysql)$/ ? :
      ***      0      0      0   $from =~ /:(?:3306|mysql)$/ ? :
2172  ***      0      0      0   $from eq $$self{'server'} ? :
2175  ***      0      0      0   if (not exists $$self{'sessions'}{$client})
2187  ***      0      0      0   if ($$packet{'data_len'} == 0)
2189  ***      0      0      0   if (($$session{'state'} || '') eq 'closing')
2196  ***      0      0      0   if ($$session{'compress'})
2197  ***      0      0      0   unless uncompress_packet($packet)
2203  ***      0      0      0   if ($from eq $$self{'server'}) { }
      ***      0      0      0   elsif ($from eq $client) { }
2219  ***      0      0      0   unless $packet
2220  ***      0      0      0   unless $session
2225  ***      0      0      0   if (($$session{'server_seq'} || '') eq $$packet{'seq'})
2236  ***      0      0      0   if (not $first_byte)
2241  ***      0      0      0   if (not $$session{'state'}) { }
2242  ***      0      0      0   if ($first_byte eq '0a' and length $data >= 33 and $data =~ /00{13}/) { }
2247  ***      0      0      0   if (not $handshake)
2260  ***      0      0      0   if ($first_byte eq '00') { }
      ***      0      0      0   elsif ($first_byte eq 'ff') { }
      ***      0      0      0   elsif ($first_byte eq 'fe' and $$packet{'mysql_data_len'} < 9) { }
2261  ***      0      0      0   if (($$session{'state'} || '') eq 'client_auth') { }
      ***      0      0      0   elsif ($$session{'cmd'}) { }
2279  ***      0      0      0   if (not $ok)
2286  ***      0      0      0   if ($com eq '03') { }
2311  ***      0      0      0   if (not $error)
2317  ***      0      0      0   if ($$session{'state'} eq 'client_auth') { }
      ***      0      0      0   elsif ($$session{'cmd'}) { }
2331  ***      0      0      0   if ($com eq '03') { }
2352  ***      0      0      0   if ($$packet{'mysql_data_len'} == 1 and $$session{'state'} eq 'client_auth' and $$packet{'number'} == 2) { }
2366  ***      0      0      0   if ($$session{'cmd'}) { }
2371  ***      0      0      0   if ($com eq '03') { }
2381  ***      0      0      0   if ($$packet{'complete'})
2384  ***      0      0      0   if ($warning_count)
2387  ***      0      0      0   $flags & 16 ? :
2389  ***      0      0      0   $flags & 32 ? :
2408  ***      0      0      0   unless $packet
2409  ***      0      0      0   unless $session
2414  ***      0      0      0   if (($$session{'client_seq'} || '') eq $$packet{'seq'})
2423  ***      0      0      0   if (($$session{'state'} || '') eq 'server_handshake') { }
      ***      0      0      0   elsif (($$session{'state'} || '') eq 'client_auth_resend') { }
      ***      0      0      0   elsif (($$session{'state'} || '') eq 'awaiting_reply') { }
2426  ***      0      0      0   if (not $handshake)
2442  ***      0      0      0   $$session{'cmd'}{'arg'} ? :
2449  ***      0      0      0   if (not defined $$session{'compress'})
2450  ***      0      0      0   unless $self->detect_compression($packet, $session)
2455  ***      0      0      0   if (not $com)
2467  ***      0      0      0   if ($$com{'code'} eq '01')
2490  ***      0      0      0   $$event{'No_good_index_used'} ? :
      ***      0      0      0   $$event{'No_index_used'} ? :
2525  ***      0      0      0   if ($sd eq $ed) { }
2552  ***      0      0      0   if ($first_byte < 251) { }
      ***      0      0      0   elsif ($first_byte == 252) { }
      ***      0      0      0   elsif ($first_byte == 253) { }
      ***      0      0      0   elsif ($first_byte == 254) { }
2568  ***      0      0      0   unless $data
2570  ***      0      0      0   if (length $data < 16)
2576  ***      0      0      0   unless $marker eq '#'
2590  ***      0      0      0   unless $data
2592  ***      0      0      0   if (length $data < 12)
2614  ***      0      0      0   unless $data
2639  ***      0      0      0   unless $data
2650  ***      0      0      0   if (not $buff_len)
2661  ***      0      0      0   $db ? :
2672  ***      0      0      0   unless $data
2673  ***      0      0      0   unless $len
2677  ***      0      0      0   if (not $com)
2693  ***      0      0      0   unless $flags
2699  ***      0      0      0   $flags_dec & $flagno ? :
2706  ***      0      0      0   unless $data
2707  ***      0      0      0   unless $len
2708  ***      0      0      0   unless ref $data eq 'SCALAR'
2715  ***      0      0      0   unless my $z = 'IO::Uncompress::Inflate'->new(\$comp_bin_data)
2718  ***      0      0      0   unless my $status = $z->read(\$uncomp_bin_data, $len)
2730  ***      0      0      0   if ($com and $$com{'code'} eq '00') { }
2735  ***      0      0      0   unless uncompress_packet($packet)
2747  ***      0      0      0   unless $packet
2760  ***      0      0      0   if ($uncomp_data_len) { }
2765  ***      0      0      0   if ($EVAL_ERROR)
2780  ***      0      0      0   unless $packet
2798  ***      0      0      0   if $errors_fh
2801  ***      0      0      0   if ($o and $o->has('tcpdump-errors') and $o->got('tcpdump-errors'))
2804  ***      0      0      0   unless open $errors_fh, '>>', $errors_file
2815  ***      0      0      0   if ($errors_fh)
2833  ***      0      0      0   defined $_ ? :
2877  ***     50      0      6   $$misc{'oktorun'} ? :
2892  ***     50      0      4   if ($stmt =~ s/$slow_log_hd_line//go)
2894  ***      0      0      0   if (@chunks > 1)
2901         100      2      2   unless $stmt =~ /\A#/
2915         100     16      4   if ($line =~ /^(?:#|use |SET (?:last_insert_id|insert_id|timestamp))/o) { }
2917         100      4     12   if (not $got_ts and my($time) = $line =~ /$slow_log_ts_line/o) { }
             100      4      8   elsif (not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o) { }
      ***     50      0      8   elsif (not $got_ac and $line =~ /^# (?:administrator command:.*)$/) { }
             100      4      4   elsif ($line =~ /^# +[A-Z][A-Za-z_]+: \S+/) { }
      ***     50      4      0   elsif (not $got_db and my($db) = $line =~ /^use ([^;]+)/) { }
      ***      0      0      0   elsif (not $got_set and my($setting) = $line =~ /^SET\s+([^;]*)/) { }
2921  ***     50      0      4   if (not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o)
2964  ***     50      0     16   if (not $found_arg and $pos == $len)
2967  ***      0      0      0   if (defined(my $l = <$fh>)) { }
2984  ***     50      0      4   if ($misc and $$misc{'embed'} and my($e) = $arg =~ /($$misc{'embed'})/)
2996  ***     50      0     12   unless $event = &$callback($event)
2999  ***     50      4      0   unless @pending
3006  ***      0      0      0   defined $_ ? :
3041  ***      0      0      0   unless $args{$arg}
3055  ***      0      0      0   scalar keys %$attributes == 0 ? :
3086  ***      0      0      0   unless defined $group_by
3088  ***      0      0      0   if $$self{'detect_attribs'}
3092  ***      0      0      0   if (exists $$self{'unrolled_loops'})
3099  ***      0      0      0   unless exists $$event{$attrib}
3101  ***      0      0      0   ref $group_by ? :
3106  ***      0      0      0   if (not $handler)
3115  ***      0      0      0   unless $handler
3121  ***      0      0      0   if ($$self{'n_queries'}++ > 50 or not grep {ref $$self{'handlers'}{$_} ne 'CODE';} @attrs && !$$self{'detect_attribs'})
3131  ***      0      0      0   ref $group_by ? :
3146  ***      0      0      0   if (ref $group_by)
3156  ***      0      0      0   if $EVAL_ERROR
3184  ***      0      0      0   unless defined $attrib
3187  ***      0      0      0   if (ref $val eq 'ARRAY')
3191  ***      0      0      0   unless defined $val
3194  ***      0      0      0   $val =~ /^(?:Yes|No)$/ ? :
      ***      0      0      0   $val =~ /^(?:\d+|$float_re)$/o ? :
3201  ***      0      0      0   $type =~ /num|bool/ ? :
      ***      0      0      0   $type =~ /bool|string/ ? :
      ***      0      0      0   $type eq 'num' ? :
      ***      0      0      0   $type eq 'bool' ? :
3216  ***      0      0      0   if ($args{'trf'})
3222  ***      0      0      0   if ($args{'min'})
3223  ***      0      0      0   $type eq 'num' ? :
3229  ***      0      0      0   if ($args{'max'})
3230  ***      0      0      0   $type eq 'num' ? :
3236  ***      0      0      0   if ($args{'sum'})
3239  ***      0      0      0   if ($args{'cnt'})
3242  ***      0      0      0   if ($args{'all'})
3251  ***      0      0      0   if ($args{'unq'})
3254  ***      0      0      0   if ($args{'wor'})
3255  ***      0      0      0   $type eq 'num' ? :
3264  ***      0      0      0   if ($args{'all'} and $type eq 'num' and $$self{'attrib_limit'})
3279  ***      0      0      0   $is_array ? :
      ***      0      0      0   $is_array ? :
3291  ***      0      0      0   $is_array ? :
      ***      0      0      0   $is_array ? :
3303  ***      0      0      0   if $EVAL_ERROR
3309  ***      0      0      0   if $val < 1e-06
3311  ***      0      0      0   $idx > 999 ? :
3316         100      1    999   if $bucket == 0
3317  ***     50      0    999   if $bucket < 0 or $bucket > 999
3324  ***      0      0      0   if @buck_tens
3355  ***      0      0      0   unless defined $vals and @$vals and $$args{'cnt'}
3359  ***      0      0      0   if ($n_vals == 1 or $$args{'max'} == $$args{'min'}) { }
      ***      0      0      0   elsif ($n_vals == 2) { }
3361  ***      0      0      0   $v > 0 ? :
3362  ***      0      0      0   $bucket < 0 ? :
      ***      0      0      0   $bucket > 7 ? :
3372  ***      0      0      0   $v && $v > 0 ? :
3373  ***      0      0      0   $bucket < 0 ? :
      ***      0      0      0   $bucket > 7 ? :
3385  ***      0      0      0   $n_vals >= 10 ? :
3403  ***      0      0      0   unless $val
3407  ***      0      0      0   if not $bucket_95 and $sum_excl > $top_vals
3409  ***      0      0      0   if (not $median and $total_left <= $mid)
3410  ***      0      0      0   $cutoff % 2 || $val > 1 ? :
3420  ***      0      0      0   $var > 0 ? :
3422  ***      0      0      0   $stddev > $maxstdev ? :
3439  ***      0      0      0   unless $args{$arg}
3448  ***      0      0      0   $global_cnt && $$store{'cnt'} ? :
      ***      0      0      0   $$store{'sum'} && $$store{'cnt'} ? :
3472  ***      0      0      0   if (!$args{'total'} || $total < $args{'total'} and !$args{'count'} || $count < $args{'count'}) { }
      ***      0      0      0   elsif ($args{'ol_attrib'} and !$args{'ol_freq'} || $$classes{$groupby}{$args{'ol_attrib'}}{'cnt'} >= $args{'ol_freq'}) { }
3487  ***      0      0      0   if ($$stats{'pct_95'} >= $args{'ol_limit'})
3500  ***      0      0      0   unless $event
3502  ***      0      0      0   if $_ ne $$self{'groupby'} and not exists $$self{'attributes'}{$_}
3527  ***      0      0      0   defined $_ ? :
3569  ***      0      0      0   unless $query
3598  ***      0      0      0   unless $query
3614  ***      0      0      0   unless $tbl_refs and $from
3635  ***      0      0      0   if ($tbl_ref =~ /^AS\s+\w+/i)
3643  ***      0      0      0   if $db
3650  ***      0      0      0   defined $_ ? :
3679  ***      0      0      0   unless $args{$arg}
3682  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
3698  ***      0      0      0   unless defined(my $pid = fork)
3699  ***      0      0      0   if ($pid)
3706  ***      0      0      0   unless POSIX::setsid()
3707  ***      0      0      0   unless chdir '/'
3711  ***      0      0      0   if (-t STDIN)
3713  ***      0      0      0   unless open STDIN, '/dev/null'
3717  ***      0      0      0   if ($$self{'log_file'})
3719  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
3723  ***      0      0      0   unless open STDERR, '>&STDOUT'
3733  ***      0      0      0   $self ? :
3735  ***      0      0      0   if ($PID_file and -f $PID_file) { }
3738  ***      0      0      0   if $EVAL_ERROR
3740  ***      0      0      0   if ($pid) { }
3742  ***      0      0      0   if ($pid_is_alive) { }
3764  ***      0      0      0   if (exists $$self{'child'})
3776  ***      0      0      0   if (not $PID_file)
3783  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
3785  ***      0      0      0   unless print $PID_FH $PID
3787  ***      0      0      0   unless close $PID_FH
3796  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
3797  ***      0      0      0   unless unlink $$self{'PID_file'}
3809  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
3815  ***      0      0      0   defined $_ ? :
3843  ***      0      0      0   unless $args{$arg}
3853  ***     50      0     12   unless $args{$arg}
3863  ***     50      0      8   unless $query
3864  ***     50      0      8   unless $dbh
3873         100      4      4   if ($EVAL_ERROR)
3892  ***      0      0      0   defined $_ ? :
3924  ***      0      0      0   unless $args{$arg}
3933  ***     50      0      2   unless $results
3945  ***     50      0      2   if ($$host1{'warning_count'} > 0 or $$host2{'warning_count'} > 0)
3950  ***     50      0      2   if (my $diff = abs $$host1{'warning_count'} - $$host2{'warning_count'})
3964  ***     50      0      2   unless defined $t1
3965  ***     50      0      2   unless defined $t2
3970  ***     50      0      2   if ($t1_bucket != $t2_bucket)
3978  ***     50      0      2   if ($inc >= $bucket_threshold[$t1_bucket])
3989  ***     50      0      2   unless defined $warnings1
3990  ***     50      0      2   unless defined $warnings2
3997  ***      0      0      0   if (exists $$warnings2{$code}) { }
3998  ***      0      0      0   if ($$warnings2{$code}{'Level'} ne $$warnings1{$code}{'Level'})
4013  ***      0      0      0   if (not exists $$warnings1{$code} and not exists $new_warnings{$code})
4028  ***     50      0      4   unless defined $val
4029  ***     50      0      4   if $val == 0
4031  ***     50      0      4   $bucket < 0 ? :
      ***     50      0      4   $bucket > 7 ? :
4037  ***     50      0      2   if $x == $y
4039  ***     50      2      0   if ($x > $y)
4045  ***     50      0      2   if ($x == 0)
4054  ***      0      0      0   defined $_ ? :
4110  ***     50      2      0   if (not $o->get('help'))
4111  ***     50      0      2   if (@ARGV < 2)
4149  ***     50      0      4   unless $$event{'cmd'} eq 'Query'
4150  ***     50      0      4   unless $$event{'arg'}
4151  ***     50      4      0   if $$event{'arg'} =~ /^SELECT/i
4156  ***     50      0      2   if ($o->get('filter'))
4160  ***      0      0      0   unless my $sub = eval $code
4180         100      2      2   if ($db and !$current_db || $db ne $current_db)
4195  ***     50      0      4   if ($EVAL_ERROR)
4208         100      2      2   if (ref $results{$query}{'execution'}{'host1'} and ref $results{$query}{'execution'}{'host2'}) { }
4228  ***     50      0      2   if ($o->get('daemonize'))
4238  ***     50      0      2   if (@ARGV == 0)
4256  ***     50      0      2   if ($file eq '-') { }
4260  ***     50      0      2   if (not open $fh, '<', $file)
4273  ***     50      0      6   if ($EVAL_ERROR)
4275  ***      0      0      0   unless $o->get('continue-on-error')
4277         100      2      4   unless $events
4293  ***     50      0      4   if ($o->get('dump-results'))
4301         100      2      2   @$reasons == 0 ? :
4327         100      4      4   if (ref $res) { }
4332  ***     50      4      0   scalar keys %$warnings == 0 ? :
4350  ***     50      0      4   if ($o->get('ask-pass'))
4362  ***      0      0      0   if ($oktorun) { }
4374  ***     50      1      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
131          100     11     36      1   not defined $final_props{$key} and defined $$prev{$key}
      ***     66     47      0      1   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
242   ***     66      6      0      6   not $dbh and $tries--
278   ***     33      6      0      0   not $dbh and $EVAL_ERROR
646   ***     66     12     22      0   $type and $type eq 'd'
      ***     33     34      0      0   $type and $type eq 'd' and not $$self{'dp'}
651          100     12     18      4   $type and $type =~ /[HhAadzm]/
805   ***     33      0      2      0   @ARGV and $ARGV[0] eq '--config'
834   ***     33      0      2      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
841   ***     33      0      2      0   @ARGV and $$self{'strict'}
925   ***     66      0     12     22   $opt and $$opt{'type'}
928   ***     66     20      2      0   $val and $$opt{'type'} eq 'm'
      ***     66     20      2      0   $val and $$opt{'type'} eq 'd'
      ***     66     20      2      0   $val and $$opt{'type'} eq 'z'
      ***     66     20      2      0   defined $val and $$opt{'type'} eq 'h'
      ***     33     20      0      0   defined $val and $$opt{'type'} eq 'a'
993   ***     33      0      0     18   $long and exists $$self{'opts'}{$long}
1001  ***     33      0      0      8   $long and exists $$self{'opts'}{$long}
1015  ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
1104  ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
1198  ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1311  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
1369  ***      0      0      0      0   $num >= $d and $n < @units - 1
1488  ***      0      0      0      0   $length and length $query > $length
1500  ***      0      0      0      0   @vals and $len < $targ / 2
1504  ***      0      0      0      0   @vals and $len < $targ
1730  ***      0      0      0      0   not $curr and @curr
1734  ***      0      0      0      0   not $prev and @prev
1739  ***      0      0      0      0   $curr and $prev
      ***      0      0      0      0   $curr and $prev and $$curr[0] == $$prev[0]
      ***      0      0      0      0   $curr and $prev
      ***      0      0      0      0   $curr and $prev and $$curr[0] > $$prev[0]
1744  ***      0      0      0      0   defined $$curr[5] and $$curr[5] < $$prev[5]
      ***      0      0      0      0   $$curr[7] and defined $$curr[5]
      ***      0      0      0      0   $$curr[7] and defined $$curr[5] and $$misc{'time'} - $$curr[5] - $$prev[8] - $$prev[9] - $$misc{'etime'} > $fudge
1764  ***      0      0      0      0   $$prev[7] and not $is_new
1785  ***      0      0      0      0   $$curr[7] and defined $$curr[5]
1829  ***      0      0      0      0   $find_spec{'busy_time'} and ($$query{'Command'} || '') eq 'Query'
1839  ***      0      0      0      0   defined $find_spec{'ignore'}{$property} and $self->$filter($query, $find_spec{'ignore'}{$property})
1858  ***      0      0      0      0   @matches and $find_spec{'only_oldest'}
1867  ***      0      0      0      0   defined $property && defined $$query{'Id'}
      ***      0      0      0      0   defined $property && defined $$query{'Id'} && $$query{'Id'} == $property
1872  ***      0      0      0      0   defined $property && defined $$query{'User'}
      ***      0      0      0      0   defined $property && defined $$query{'User'} && $$query{'User'} =~ /$property/
1878  ***      0      0      0      0   defined $property && defined $$query{'Host'}
      ***      0      0      0      0   defined $property && defined $$query{'Host'} && $$query{'Host'} =~ /$property/
1884  ***      0      0      0      0   defined $property && defined $$query{'db'}
      ***      0      0      0      0   defined $property && defined $$query{'db'} && $$query{'db'} =~ /$property/
1890  ***      0      0      0      0   defined $property && defined $$query{'State'}
      ***      0      0      0      0   defined $property && defined $$query{'State'} && $$query{'State'} =~ /$property/
1896  ***      0      0      0      0   defined $property && defined $$query{'Command'}
      ***      0      0      0      0   defined $property && defined $$query{'Command'} && $$query{'Command'} =~ /$property/
1902  ***      0      0      0      0   defined $property && defined $$query{'Info'}
      ***      0      0      0      0   defined $property && defined $$query{'Info'} && $$query{'Info'} =~ /$property/
1955  ***      0      0      0      0   $$oktorun and defined(my $raw_packet = <$fh>)
2242  ***      0      0      0      0   $first_byte eq '0a' and length $data >= 33
      ***      0      0      0      0   $first_byte eq '0a' and length $data >= 33 and $data =~ /00{13}/
2260  ***      0      0      0      0   $first_byte eq 'fe' and $$packet{'mysql_data_len'} < 9
2352  ***      0      0      0      0   $$packet{'mysql_data_len'} == 1 and $$session{'state'} eq 'client_auth'
      ***      0      0      0      0   $$packet{'mysql_data_len'} == 1 and $$session{'state'} eq 'client_auth' and $$packet{'number'} == 2
2730  ***      0      0      0      0   $com and $$com{'code'} eq '00'
2801  ***      0      0      0      0   $o and $o->has('tcpdump-errors')
      ***      0      0      0      0   $o and $o->has('tcpdump-errors') and $o->got('tcpdump-errors')
2887  ***     66      0      2      4   $$oktorun and defined($stmt = shift @pending) || defined($stmt = <$fh>)
2917  ***     66     12      0      4   not $got_ts and my($time) = $line =~ /$slow_log_ts_line/o
      ***     66      8      0      4   not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o
      ***     33      0      8      0   not $got_ac and $line =~ /^# (?:administrator command:.*)$/
      ***     33      0      0      4   not $got_db and my($db) = $line =~ /^use ([^;]+)/
      ***      0      0      0      0   not $got_set and my($setting) = $line =~ /^SET\s+([^;]*)/
2921  ***     33      0      4      0   not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o
2964  ***     33      0     16      0   not $found_arg and $pos == $len
2984  ***     33      0      4      0   $misc and $$misc{'embed'}
      ***     33      4      0      0   $misc and $$misc{'embed'} and my($e) = $arg =~ /($$misc{'embed'})/
3121  ***      0      0      0      0   @attrs && !$$self{'detect_attribs'}
3264  ***      0      0      0      0   $args{'all'} and $type eq 'num'
      ***      0      0      0      0   $args{'all'} and $type eq 'num' and $$self{'attrib_limit'}
3355  ***      0      0      0      0   defined $vals and @$vals
      ***      0      0      0      0   defined $vals and @$vals and $$args{'cnt'}
3372  ***      0      0      0      0   $v && $v > 0
3407  ***      0      0      0      0   not $bucket_95 and $sum_excl > $top_vals
3409  ***      0      0      0      0   not $median and $total_left <= $mid
3448  ***      0      0      0      0   $global_cnt && $$store{'cnt'}
      ***      0      0      0      0   $$store{'sum'} && $$store{'cnt'}
3472  ***      0      0      0      0   !$args{'total'} || $total < $args{'total'} and !$args{'count'} || $count < $args{'count'}
      ***      0      0      0      0   $args{'ol_attrib'} and !$args{'ol_freq'} || $$classes{$groupby}{$args{'ol_attrib'}}{'cnt'} >= $args{'ol_freq'}
3502  ***      0      0      0      0   $_ ne $$self{'groupby'} and not exists $$self{'attributes'}{$_}
3614  ***      0      0      0      0   $tbl_refs and $from
3735  ***      0      0      0      0   $PID_file and -f $PID_file
3796  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
4013  ***      0      0      0      0   not exists $$warnings1{$code} and not exists $new_warnings{$code}
4180  ***     66      0      2      2   $db and !$current_db || $db ne $current_db
4208  ***     66      2      0      2   ref $results{$query}{'execution'}{'host1'} and ref $results{$query}{'execution'}{'host2'}
4248  ***     33      0      0      4   $oktorun and $start == $end || $now < $end
      ***     66      0      2      2   $oktorun and $start == $end || $now < $end and @ARGV
4268  ***     33      0      0      6   $oktorun and $start == $end || $now < $end

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
112          100      2      4   $prev ||= {}
113   ***     50      0      6   $defaults ||= {}
186   ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
199   ***     50      0      6   $self->prop('dbidriver') || ''
203   ***      0      0      0   $$info{'D'} || ''
209   ***     50      0      6   $$info{'D'} || ''
231   ***     50      6      0   $opts ||= {}
306   ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
322   ***      0      0      0   $level ||= 0
323   ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
451   ***     50      2      0   $program_name ||= $PROGRAM_NAME
453   ***     50      2      0   $args{'prompt'} || '<options>'
      ***     50      2      0   $args{'dp'} || undef
495   ***     50      0      2   $file ||= '../mk-upgrade'
636   ***     50     34      0   $$opt{'group'} ||= 'default'
933   ***      0      0      0   $s || 's'
970   ***      0      0      0   $pre || ''
977   ***      0      0      0   $val || ''
980   ***     50      2      0   $val || ''
1038  ***      0      0      0   $$self{'description'} || ''
1106  ***      0      0      0   $s ||= 's'
1132  ***      0      0      0   $$opt{'type'} || ''
1331  ***      0      0      0   $args{'p'} || 0
1333  ***      0      0      0   $of ||= 1
1338  ***      0      0      0   $secs ||= 0
1725  ***      0      0      0   $$misc{'prev'} ||= []
1829  ***      0      0      0   $$query{'Command'} || ''
2189  ***      0      0      0   $$session{'state'} || ''
2225  ***      0      0      0   $$session{'server_seq'} || ''
2261  ***      0      0      0   $$session{'state'} || ''
2414  ***      0      0      0   $$session{'client_seq'} || ''
2423  ***      0      0      0   $$session{'state'} || ''
      ***      0      0      0   $$session{'state'} || ''
      ***      0      0      0   $$session{'state'} || ''
2490  ***      0      0      0   $$event{'Error_no'} || 0
      ***      0      0      0   $$event{'Rows_affected'} || 0
      ***      0      0      0   $$event{'Warning_count'} || 0
3043  ***      0      0      0   $args{'attributes'} || {}
3055  ***      0      0      0   $args{'unroll_limit'} || 50
3102  ***      0      0      0   $$self{'result_classes'}{$val}{$attrib} ||= {}
3103  ***      0      0      0   $$self{'result_globals'}{$attrib} ||= {}
3360  ***      0      0      0   $$args{'max'} || 0
3375  ***      0      0      0   $$args{'max'} || 0
3376  ***      0      0      0   $$args{'min'} || 0
3421  ***      0      0      0   $$args{'max'} || 0
      ***      0      0      0   $$args{'min'} || 0
4170  ***     50      0      4    ||= 
      ***     50      0      4    ||= 
4176  ***     50      0      4   $results{$query}{'rank'} ||= 0
4177  ***     50      0      4   $results{$query}{'reasons'} ||= ()
4244  ***     50      0      2   $o->get('run-time') || 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
222   ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
223   ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
224   ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
225   ***      0      0      0      0   $$dsn{'u'} ||= $user
226   ***      0      0      0      0   $$dsn{'D'} ||= $db
394   ***      0      0      0      0   $_ eq '' || $_ =~ /^0|\D/
928   ***     33      0      0     22   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***     66      2      0     20   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1341  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
1373  ***      0      0      0      0   $num =~ /\./ || $n
1562  ***      0      0      0      0   $args{'qp'} || $$self{'QueryParser'}
1616  ***      0      0      0      0   $query =~ s/
                 \A.*?
                 update\s+(.*?)
                 \s+set\b(.*?)
                 (?:\s*where\b(.*?))?
                 (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
                 \Z
              /__update_to_select($1, $2, $3, $4);/eisx or $query =~ s/
                    \A.*?
                    (?:insert|replace)\s+
                    .*?\binto\b(.*?)\(([^\)]+)\)\s*
                    values?\s*(\(.*?\))\s*
                    (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
                    \Z
                 /__insert_to_select($1, $2, $3);/eisx
1729  ***      0      0      0      0   @curr or @prev
      ***      0      0      0      0   @curr or @prev or $curr
      ***      0      0      0      0   @curr or @prev or $curr or $prev
1738  ***      0      0      0      0   $curr or $prev
1739  ***      0      0      0      0   not $curr or $curr and $prev and $$curr[0] > $$prev[0]
1744  ***      0      0      0      0   not $$curr[7] or $$prev[7] ne $$curr[7]
2169  ***      0      0      0      0   $$self{'server'} ||= $from =~ /:(?:3306|mysql)$/ ? $from : ($to =~ /:(?:3306|mysql)$/ ? $to : undef)
2887  ***     66      0      4      2   defined($stmt = shift @pending) || defined($stmt = <$fh>)
3116  ***      0      0      0      0   $$samples{$val} ||= $event
3121  ***      0      0      0      0   $$self{'n_queries'}++ > 50 or not grep {ref $$self{'handlers'}{$_} ne 'CODE';} @attrs && !$$self{'detect_attribs'}
3317  ***     33      0      0    999   $bucket < 0 or $bucket > 999
3359  ***      0      0      0      0   $n_vals == 1 or $$args{'max'} == $$args{'min'}
3410  ***      0      0      0      0   $cutoff % 2 || $val > 1
3472  ***      0      0      0      0   !$args{'total'} || $total < $args{'total'}
      ***      0      0      0      0   !$args{'count'} || $count < $args{'count'}
      ***      0      0      0      0   !$args{'ol_freq'} || $$classes{$groupby}{$args{'ol_attrib'}}{'cnt'} >= $args{'ol_freq'}
3642  ***      0      0      0      0   $alias or $tbl
3809  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
3945  ***     33      0      0      2   $$host1{'warning_count'} > 0 or $$host2{'warning_count'} > 0
4180  ***     66      2      0      2   !$current_db || $db ne $current_db
4248  ***     33      4      0      0   $start == $end || $now < $end
4268  ***     33      6      0      0   $start == $end || $now < $end


Covered Subroutines
-------------------

Subroutine                    Count Location                                           
----------------------------- ----- ---------------------------------------------------
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1276
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1277
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1278
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1279
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1280
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1282
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1436
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1437
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1441
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1443
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1696
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1697
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1698
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1700
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1713
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1926
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1927
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1928
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1929
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1933
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:20  
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2037
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2038
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2039
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2046
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2064
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2097
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:21  
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2850
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2851
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2852
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2853
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2855
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:30  
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3023
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3024
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3025
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3027
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3028
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3029
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3030
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3031
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3032
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:31  
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:35  
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3544
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3545
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3546
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3548
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:36  
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:366 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3668
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3669
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:367 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3671
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3672
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3674
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:371 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:373 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3832
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3833
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3835
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3836
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3838
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:39  
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3910
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3911
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3913
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3914
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3916
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4076
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4077
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4078
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4085
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4087
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:41  
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:425 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:426 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:428 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:429 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:430 
BEGIN                             1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:432 
__ANON__                          4 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4148
__ANON__                          4 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4170
__ANON__                          4 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4206
_d                                1 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4373
_exec_query                       8 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3862
_parse_specs                      2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:600 
_pod_to_specs                     2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:494 
_read_config_file                 8 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1181
_validate_type                   34 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:924 
bucket_for                        4 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4027
bucket_value                   1000 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3315
compare_query_times               2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3963
compare_warnings                  2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3988
exec                              4 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3851
get                              18 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:991 
get_cxn                           4 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4349
get_cxn_params                    6 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:196 
get_dbh                           6 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:230 
get_defaults_files                2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:489 
get_opts                          2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:792 
get_specs                         2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:482 
got                               8 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:999 
has                               2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1007
main                              2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4093
new                               2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2858
new                               2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3841
new                               2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3922
new                               3 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:44  
new                               2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:446 
parse                             6 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:106 
parse_event                       6 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2875
percentage_increase               2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4036
print_execution_results           8 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4323
prop                             18 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:97  
rank                              2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3932
usage_or_errors                   2 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1048

Uncovered Subroutines
---------------------

Subroutine                    Count Location                                           
----------------------------- ----- ---------------------------------------------------
DESTROY                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3808
__ANON__                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:829 
__delete_to_select                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1638
__insert_to_select                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1646
__update_to_select                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1663
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1257
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1420
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1678
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1907
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2018
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2832
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3005
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:350 
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3526
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3649
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3814
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3891
_d                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4053
_find_match_Command               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1895
_find_match_Host                  0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1877
_find_match_Id                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1866
_find_match_Info                  0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1901
_find_match_State                 0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1889
_find_match_User                  0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1871
_find_match_db                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1883
_get_errors_fh                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2796
_get_participants                 0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:719 
_make_PID_file                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3773
_make_event                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2484
_packet_from_client               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2407
_packet_from_server               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2218
_parse_packet                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1976
_remove_PID_file                  0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3795
_set_option                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:775 
add_new_attributes                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3499
aggregate                         0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3083
as_string                         0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:170 
attributes                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3173
bucket_idx                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3308
buckets_of                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3324
calculate_statistical_metrics     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3347
check_PID_file                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3732
clone                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1234
convert_select_list               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1629
convert_to_select                 0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1596
copy                              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:332 
daemonize                         0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3695
descr                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1037
detect_compression                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2727
disconnect                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:315 
distill                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1561
errors                            0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1027
events_processed                  0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3521
fail_session                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2813
fill_in_dsn                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:218 
find                              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1824
fingerprint                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1519
fire_event                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1802
get_aliases                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3597
get_attributes                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3516
get_defaults                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:765 
get_groups                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:770 
get_hostname                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:305 
get_lcb                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2550
get_tables                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3568
has_derived_table                 0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3590
make_PID_file                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3763
make_checksum                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1413
make_handler                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3183
metrics                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3437
micro_t                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1300
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1463
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1716
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1936
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2153
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3039
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3563
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3677
new                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:376 
opt_values                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:737 
opts                              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:731 
parse_client_handshake_packet     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2638
parse_com_packet                  0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2671
parse_error_packet                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2567
parse_event                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1721
parse_event                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1942
parse_flags                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2692
parse_ok_packet                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2589
parse_options                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:157 
parse_packet                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2165
parse_server_handshake_packet     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2613
parse_timestamp                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1391
percentage_of                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1330
print_active_handles              0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:321 
print_errors                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1061
print_usage                       0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1071
prompt                            0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1032
prompt_noecho                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1146
quote                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:381 
quote_val                         0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:389 
read_para_after                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1215
remove_mysql_header               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2779
reset_aggregated_data             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3069
results                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3164
save_error                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1022
secs_to_time                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1337
set                               0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1013
set_defaults                      0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:753 
short_opts                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:747 
shorten                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1364
shorten                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1476
sig_int                           0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:4361
split_unquote                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:404 
strip_comments                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1469
tcp_timestamp                     0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2512
timestamp_diff                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2518
to_num                            0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2540
to_string                         0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2534
top_events                        0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3461
ts                                0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1381
type_for                          0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:3178
uncompress_data                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2705
uncompress_packet                 0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:2746
unix_timestamp                    0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1403
usage                             0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:179 
wrap_in_derived                   0 /home/daniel/dev/maatkit/mk-upgrade/mk-upgrade:1670


