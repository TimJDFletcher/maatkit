---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...-slave-move/mk-slave-move   48.2   30.7   35.5   61.8    n/a   98.4   42.8
mk-slave-move.t                94.8   50.0   33.3  100.0    n/a    1.6   85.2
Total                          50.5   31.1   35.4   64.1    n/a  100.0   44.4
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:31:46 2010
Finish:       Thu Jan 28 22:31:46 2010

Run:          ./mk-slave-move.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:31:48 2010
Finish:       Thu Jan 28 22:40:00 2010

/home/daniel/dev/maatkit/mk-slave-move/mk-slave-move

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This is mk-slave-move, a program to move slaves around in a replication
4                                                     # hierarchy (promote, demote, etc).
5                                                     #
6                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
7                                                     # Feedback and improvements are welcome.
8                                                     #
9                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
10                                                    # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
11                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
12                                                    #
13                                                    # This program is free software; you can redistribute it and/or modify it under
14                                                    # the terms of the GNU General Public License as published by the Free Software
15                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
16                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
17                                                    # licenses.
18                                                    #
19                                                    # You should have received a copy of the GNU General Public License along with
20                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
21                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
22                                                    
23             1                    1             8   use strict;
               1                                  3   
               1                                 10   
24             1                    1             7   use warnings FATAL => 'all';
               1                                  3   
               1                                  7   
25                                                    
26                                                    our $VERSION = '@VERSION@';
27                                                    our $DISTRIB = '@DISTRIB@';
28                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5425 $ =~ m/(\d+)/g, 0));
29                                                    
30                                                    # ###########################################################################
31                                                    # OptionParser package 5266
32                                                    # ###########################################################################
33                                                    package OptionParser;
34                                                    
35             1                    1             7   use strict;
               1                                  2   
               1                                  5   
36             1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  9   
37                                                    
38             1                    1            10   use Getopt::Long;
               1                                  4   
               1                                  8   
39             1                    1             9   use List::Util qw(max);
               1                                  3   
               1                                 14   
40             1                    1             9   use English qw(-no_match_vars);
               1                                  2   
               1                                  7   
41                                                    
42    ***      1            50      1             9   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 18   
43                                                    
44                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
45                                                    
46                                                    my %attributes = (
47                                                       'type'       => 1,
48                                                       'short form' => 1,
49                                                       'group'      => 1,
50                                                       'default'    => 1,
51                                                       'cumulative' => 1,
52                                                       'negatable'  => 1,
53                                                    );
54                                                    
55                                                    sub new {
56             2                    2            33      my ( $class, %args ) = @_;
57             2                                 14      foreach my $arg ( qw(description) ) {
58    ***      2     50                          19         die "I need a $arg argument" unless $args{$arg};
59                                                       }
60             2                                 37      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
61    ***      2            50                   13      $program_name ||= $PROGRAM_NAME;
62    ***      2            33                   27      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                   33                        
      ***                   50                        
63                                                    
64    ***      2     50     50                  104      my $self = {
      ***                   50                        
65                                                          description    => $args{description},
66                                                          prompt         => $args{prompt} || '<options>',
67                                                          strict         => (exists $args{strict} ? $args{strict} : 1),
68                                                          dp             => $args{dp}     || undef,
69                                                          program_name   => $program_name,
70                                                          opts           => {},
71                                                          got_opts       => 0,
72                                                          short_opts     => {},
73                                                          defaults       => {},
74                                                          groups         => {},
75                                                          allowed_groups => {},
76                                                          errors         => [],
77                                                          rules          => [],  # desc of rules for --help
78                                                          mutex          => [],  # rule: opts are mutually exclusive
79                                                          atleast1       => [],  # rule: at least one opt is required
80                                                          disables       => {},  # rule: opt disables other opts 
81                                                          defaults_to    => {},  # rule: opt defaults to value of other opt
82                                                          default_files  => [
83                                                             "/etc/maatkit/maatkit.conf",
84                                                             "/etc/maatkit/$program_name.conf",
85                                                             "$home/.maatkit.conf",
86                                                             "$home/.$program_name.conf",
87                                                          ],
88                                                       };
89             2                                 42      return bless $self, $class;
90                                                    }
91                                                    
92                                                    sub get_specs {
93             2                    2            12      my ( $self, $file ) = @_;
94             2                                 14      my @specs = $self->_pod_to_specs($file);
95             2                                 57      $self->_parse_specs(@specs);
96             2                                 11      return;
97                                                    }
98                                                    
99                                                    sub get_defaults_files {
100            2                    2            10      my ( $self ) = @_;
101            2                                  9      return @{$self->{default_files}};
               2                                 29   
102                                                   }
103                                                   
104                                                   sub _pod_to_specs {
105            2                    2            12      my ( $self, $file ) = @_;
106   ***      2            50                   14      $file ||= __FILE__;
107   ***      2     50                         176      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
108                                                   
109            2                                 48      my %types = (
110                                                         string => 's', # standard Getopt type
111                                                         'int'  => 'i', # standard Getopt type
112                                                         float  => 'f', # standard Getopt type
113                                                         Hash   => 'H', # hash, formed from a comma-separated list
114                                                         hash   => 'h', # hash as above, but only if a value is given
115                                                         Array  => 'A', # array, similar to Hash
116                                                         array  => 'a', # array, similar to hash
117                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
118                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
119                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
120                                                      );
121            2                                  9      my @specs = ();
122            2                                  7      my @rules = ();
123            2                                  8      my $para;
124                                                   
125            2                                 18      local $INPUT_RECORD_SEPARATOR = '';
126            2                                 62      while ( $para = <$fh> ) {
127          578    100                        5286         next unless $para =~ m/^=head1 OPTIONS/;
128            2                                 11         last;
129                                                      }
130                                                   
131            2                                 30      while ( $para = <$fh> ) {
132            4    100                          28         last if $para =~ m/^=over/;
133            2                                 10         chomp $para;
134            2                                 34         $para =~ s/\s+/ /g;
135            2                                112         $para =~ s/$POD_link_re/$1/go;
136            2                                  9         MKDEBUG && _d('Option rule:', $para);
137            2                                 27         push @rules, $para;
138                                                      }
139                                                   
140   ***      2     50                          11      die 'POD has no OPTIONS section' unless $para;
141                                                   
142            2                                  8      do {
143           38    100                         336         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
144           36                                127            chomp $para;
145           36                                101            MKDEBUG && _d($para);
146           36                                116            my %attribs;
147                                                   
148           36                                173            $para = <$fh>; # read next paragraph, possibly attributes
149                                                   
150           36    100                         194            if ( $para =~ m/: / ) { # attributes
151           22                                156               $para =~ s/\s+\Z//g;
152           40                                259               %attribs = map {
153           22                                144                     my ( $attrib, $val) = split(/: /, $_);
154   ***     40     50                         227                     die "Unrecognized attribute for --$option: $attrib"
155                                                                        unless $attributes{$attrib};
156           40                                262                     ($attrib, $val);
157                                                                  } split(/; /, $para);
158           22    100                         135               if ( $attribs{'short form'} ) {
159           14                                 90                  $attribs{'short form'} =~ s/-//;
160                                                               }
161           22                                151               $para = <$fh>; # read next paragraph, probably short help desc
162                                                            }
163                                                            else {
164           14                                 41               MKDEBUG && _d('Option has no attributes');
165                                                            }
166                                                   
167           36                                761            $para =~ s/\s+\Z//g;
168           36                                398            $para =~ s/\s+/ /g;
169           36                                166            $para =~ s/$POD_link_re/$1/go;
170                                                   
171           36                                191            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
172           36                                106            MKDEBUG && _d('Short help:', $para);
173                                                   
174   ***     36     50                         191            die "No description after option spec $option" if $para =~ m/^=item/;
175                                                   
176   ***     36     50                         219            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
177   ***      0                                  0               $option = $base_option;
178   ***      0                                  0               $attribs{'negatable'} = 1;
179                                                            }
180                                                   
181           36    100                         834            push @specs, {
      ***            50                               
      ***            50                               
                    100                               
                    100                               
      ***            50                               
182                                                               spec  => $option
183                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
184                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
185                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
186                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
187                                                               desc  => $para
188                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
189                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
190                                                            };
191                                                         }
192           38                                307         while ( $para = <$fh> ) {
193   ***     52     50                         228            last unless $para;
194                                                   
195                                                   
196           52    100                         266            if ( $para =~ m/^=head1/ ) {
197            2                                  9               $para = undef; # Can't 'last' out of a do {} block.
198            2                                 13               last;
199                                                            }
200           50    100                         444            last if $para =~ m/^=item --/;
201                                                         }
202                                                      } while ( $para );
203                                                   
204   ***      2     50                          13      die 'No valid specs in POD OPTIONS' unless @specs;
205                                                   
206            2                                 45      close $fh;
207            2                                  9      return @specs, @rules;
208                                                   }
209                                                   
210                                                   sub _parse_specs {
211            2                    2            20      my ( $self, @specs ) = @_;
212            2                                 10      my %disables; # special rule that requires deferred checking
213                                                   
214            2                                 18      foreach my $opt ( @specs ) {
215           38    100                         190         if ( ref $opt ) { # It's an option spec, not a rule.
216                                                            MKDEBUG && _d('Parsing opt spec:',
217           36                                 95               map { ($_, '=>', $opt->{$_}) } keys %$opt);
218                                                   
219           36                                342            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
220   ***     36     50                         191            if ( !$long ) {
221   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
222                                                            }
223           36                                165            $opt->{long} = $long;
224                                                   
225   ***     36     50                         214            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
226           36                                209            $self->{opts}->{$long} = $opt;
227                                                   
228   ***     36     50                         175            if ( length $long == 1 ) {
229   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
230   ***      0                                  0               $self->{short_opts}->{$long} = $long;
231                                                            }
232                                                   
233           36    100                         153            if ( $short ) {
234   ***     14     50                          86               die "Duplicate short option -$short"
235                                                                  if exists $self->{short_opts}->{$short};
236           14                                 76               $self->{short_opts}->{$short} = $long;
237           14                                 64               $opt->{short} = $short;
238                                                            }
239                                                            else {
240           22                                102               $opt->{short} = undef;
241                                                            }
242                                                   
243   ***     36     50                         248            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
244   ***     36     50                         219            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
245   ***     36     50                         273            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
246                                                   
247   ***     36            50                  188            $opt->{group} ||= 'default';
248           36                                280            $self->{groups}->{ $opt->{group} }->{$long} = 1;
249                                                   
250           36                                145            $opt->{value} = undef;
251           36                                149            $opt->{got}   = 0;
252                                                   
253           36                                252            my ( $type ) = $opt->{spec} =~ m/=(.)/;
254           36                                167            $opt->{type} = $type;
255           36                                101            MKDEBUG && _d($long, 'type:', $type);
256                                                   
257   ***     36     50     66                  405            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                   33                        
258   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
259                                                                  . "was given when this OptionParser object was created";
260                                                            }
261                                                   
262           36    100    100                  332            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
263                                                   
264           36    100                         276            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
265   ***      4     50                          33               $self->{defaults}->{$long} = defined $def ? $def : 1;
266            4                                 14               MKDEBUG && _d($long, 'default:', $def);
267                                                            }
268                                                   
269           36    100                         183            if ( $long eq 'config' ) {
270            2                                 19               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
271                                                            }
272                                                   
273   ***     36     50                         238            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
274   ***      0                                  0               $disables{$long} = $dis;
275   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
276                                                            }
277                                                   
278           36                                229            $self->{opts}->{$long} = $opt;
279                                                         }
280                                                         else { # It's an option rule, not a spec.
281            2                                  9            MKDEBUG && _d('Parsing rule:', $opt); 
282            2                                  6            push @{$self->{rules}}, $opt;
               2                                 16   
283            2                                 20            my @participants = $self->_get_participants($opt);
284            2                                  9            my $rule_ok = 0;
285                                                   
286   ***      2     50                          31            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
287            2                                  8               $rule_ok = 1;
288            2                                  9               push @{$self->{mutex}}, \@participants;
               2                                 19   
289            2                                  8               MKDEBUG && _d(@participants, 'are mutually exclusive');
290                                                            }
291   ***      2     50                          25            if ( $opt =~ m/at least one|one and only one/ ) {
292            2                                  7               $rule_ok = 1;
293            2                                  7               push @{$self->{atleast1}}, \@participants;
               2                                 12   
294            2                                  9               MKDEBUG && _d(@participants, 'require at least one');
295                                                            }
296   ***      2     50                          16            if ( $opt =~ m/default to/ ) {
297   ***      0                                  0               $rule_ok = 1;
298   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
299   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
300                                                            }
301   ***      2     50                          13            if ( $opt =~ m/restricted to option groups/ ) {
302   ***      0                                  0               $rule_ok = 1;
303   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
304   ***      0                                  0               my @groups = split(',', $groups);
305   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
306   ***      0                                  0                  s/\s+//;
307   ***      0                                  0                  $_ => 1;
308                                                               } @groups;
309                                                            }
310                                                   
311   ***      2     50                          16            die "Unrecognized option rule: $opt" unless $rule_ok;
312                                                         }
313                                                      }
314                                                   
315            2                                 16      foreach my $long ( keys %disables ) {
316   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
317   ***      0                                  0         $self->{disables}->{$long} = \@participants;
318   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
319                                                      }
320                                                   
321            2                                 14      return; 
322                                                   }
323                                                   
324                                                   sub _get_participants {
325            2                    2            14      my ( $self, $str ) = @_;
326            2                                 10      my @participants;
327            2                                 38      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
328   ***      8     50                          51         die "Option --$long does not exist while processing rule $str"
329                                                            unless exists $self->{opts}->{$long};
330            8                                 40         push @participants, $long;
331                                                      }
332            2                                  7      MKDEBUG && _d('Participants for', $str, ':', @participants);
333            2                                 22      return @participants;
334                                                   }
335                                                   
336                                                   sub opts {
337   ***      0                    0             0      my ( $self ) = @_;
338   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
339   ***      0                                  0      return %opts;
340                                                   }
341                                                   
342                                                   sub short_opts {
343   ***      0                    0             0      my ( $self ) = @_;
344   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
345   ***      0                                  0      return %short_opts;
346                                                   }
347                                                   
348                                                   sub set_defaults {
349   ***      0                    0             0      my ( $self, %defaults ) = @_;
350   ***      0                                  0      $self->{defaults} = {};
351   ***      0                                  0      foreach my $long ( keys %defaults ) {
352   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
353                                                            unless exists $self->{opts}->{$long};
354   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
355   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
356                                                      }
357   ***      0                                  0      return;
358                                                   }
359                                                   
360                                                   sub get_defaults {
361   ***      0                    0             0      my ( $self ) = @_;
362   ***      0                                  0      return $self->{defaults};
363                                                   }
364                                                   
365                                                   sub get_groups {
366   ***      0                    0             0      my ( $self ) = @_;
367   ***      0                                  0      return $self->{groups};
368                                                   }
369                                                   
370                                                   sub _set_option {
371            3                    3            17      my ( $self, $opt, $val ) = @_;
372   ***      3      0                          10      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
373                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
374                                                               : die "Getopt::Long gave a nonexistent option: $opt";
375                                                   
376            3                                  8      $opt = $self->{opts}->{$long};
377   ***      3     50                          51      if ( $opt->{is_cumulative} ) {
378   ***      0                                  0         $opt->{value}++;
379                                                      }
380                                                      else {
381            3                                 17         $opt->{value} = $val;
382                                                      }
383            3                                 13      $opt->{got} = 1;
384            3                                 16      MKDEBUG && _d('Got option', $long, '=', $val);
385                                                   }
386                                                   
387                                                   sub get_opts {
388            2                    2            12      my ( $self ) = @_; 
389                                                   
390            2                                  7      foreach my $long ( keys %{$self->{opts}} ) {
               2                                 26   
391           36                                189         $self->{opts}->{$long}->{got} = 0;
392   ***     36     50                         391         $self->{opts}->{$long}->{value}
                    100                               
393                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
394                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
395                                                            : undef;
396                                                      }
397            2                                 18      $self->{got_opts} = 0;
398                                                   
399            2                                 12      $self->{errors} = [];
400                                                   
401   ***      2     50     33                   37      if ( @ARGV && $ARGV[0] eq "--config" ) {
402   ***      0                                  0         shift @ARGV;
403   ***      0                                  0         $self->_set_option('config', shift @ARGV);
404                                                      }
405   ***      2     50                          18      if ( $self->has('config') ) {
406            2                                  7         my @extra_args;
407            2                                 19         foreach my $filename ( split(',', $self->get('config')) ) {
408            8                                 27            eval {
409            8                                 52               push @extra_args, $self->_read_config_file($filename);
410                                                            };
411   ***      8     50                          58            if ( $EVAL_ERROR ) {
412   ***      8     50                          42               if ( $self->got('config') ) {
413   ***      0                                  0                  die $EVAL_ERROR;
414                                                               }
415                                                               elsif ( MKDEBUG ) {
416                                                                  _d($EVAL_ERROR);
417                                                               }
418                                                            }
419                                                         }
420            2                                 14         unshift @ARGV, @extra_args;
421                                                      }
422                                                   
423            2                                 26      Getopt::Long::Configure('no_ignore_case', 'bundling');
424                                                      GetOptions(
425           34                    3           327         map    { $_->{spec} => sub { $self->_set_option(@_); } }
               3                                 23   
              36                                185   
426            2                                 18         grep   { $_->{long} ne 'config' } # --config is handled specially above.
427   ***      2     50                           9         values %{$self->{opts}}
428                                                      ) or $self->save_error('Error parsing options');
429                                                   
430   ***      2     50     33                  110      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
431   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
432                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
433                                                               or die "Cannot print: $OS_ERROR";
434   ***      0                                  0         exit 0;
435                                                      }
436                                                   
437   ***      2     50     33                   28      if ( @ARGV && $self->{strict} ) {
438   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
439                                                      }
440                                                   
441            2                                 10      foreach my $mutex ( @{$self->{mutex}} ) {
               2                                 16   
442            2                                 11         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
               8                                 52   
443   ***      2     50                          18         if ( @set > 1 ) {
444   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
445   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
446                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
447                                                                    . ' are mutually exclusive.';
448   ***      0                                  0            $self->save_error($err);
449                                                         }
450                                                      }
451                                                   
452            2                                  8      foreach my $required ( @{$self->{atleast1}} ) {
               2                                 15   
453            2                                 10         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
               8                                 49   
454   ***      2     50                          16         if ( @set == 0 ) {
455   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
456   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
457                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
458   ***      0                                  0            $self->save_error("Specify at least one of $err");
459                                                         }
460                                                      }
461                                                   
462            2                                  9      foreach my $long ( keys %{$self->{opts}} ) {
               2                                 20   
463           36                                169         my $opt = $self->{opts}->{$long};
464           36    100                         254         if ( $opt->{got} ) {
      ***            50                               
465   ***      3     50                          20            if ( exists $self->{disables}->{$long} ) {
466   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
467   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
468   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
469                                                                  'because', $long,'disables them');
470                                                            }
471                                                   
472   ***      3     50                          24            if ( exists $self->{allowed_groups}->{$long} ) {
473                                                   
474   ***      0                                  0               my @restricted_groups = grep {
475   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
476   ***      0                                  0               } keys %{$self->{groups}};
477                                                   
478   ***      0                                  0               my @restricted_opts;
479   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
480   ***      0                                  0                  RESTRICTED_OPT:
481   ***      0                                  0                  foreach my $restricted_opt (
482                                                                     keys %{$self->{groups}->{$restricted_group}} )
483                                                                  {
484   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
485   ***      0      0                           0                     push @restricted_opts, $restricted_opt
486                                                                        if $self->{opts}->{$restricted_opt}->{got};
487                                                                  }
488                                                               }
489                                                   
490   ***      0      0                           0               if ( @restricted_opts ) {
491   ***      0                                  0                  my $err;
492   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
493   ***      0                                  0                     $err = "--$restricted_opts[0]";
494                                                                  }
495                                                                  else {
496   ***      0                                  0                     $err = join(', ',
497   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
498   ***      0                                  0                               grep { $_ } 
499                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
500                                                                            )
501                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
502                                                                  }
503   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
504                                                               }
505                                                            }
506                                                   
507                                                         }
508                                                         elsif ( $opt->{is_required} ) { 
509   ***      0                                  0            $self->save_error("Required option --$long must be specified");
510                                                         }
511                                                   
512           36                                163         $self->_validate_type($opt);
513                                                      }
514                                                   
515            2                                 12      $self->{got_opts} = 1;
516            2                                  8      return;
517                                                   }
518                                                   
519                                                   sub _validate_type {
520           36                   36           176      my ( $self, $opt ) = @_;
521   ***     36    100     66                  415      return unless $opt && $opt->{type};
522           22                                 93      my $val = $opt->{value};
523                                                   
524           22    100    100                  723      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***            50     66                        
      ***            50     66                        
      ***            50     66                        
      ***           100     33                        
      ***                   66                        
      ***                   66                        
525            2                                  7         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
526            2                                 29         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
527   ***      2     50                          12         if ( !$suffix ) {
528   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
529   ***      0             0                    0            $suffix = $s || 's';
530   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
531                                                               $opt->{long}, '(value:', $val, ')');
532                                                         }
533   ***      2     50                          15         if ( $suffix =~ m/[smhd]/ ) {
534   ***      2      0                          21            $val = $suffix eq 's' ? $num            # Seconds
      ***            50                               
      ***            50                               
535                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
536                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
537                                                                 :                  $num * 86400;   # Days
538   ***      2            50                   39            $opt->{value} = ($prefix || '') . $val;
539            2                                  7            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
540                                                         }
541                                                         else {
542   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
543                                                         }
544                                                      }
545                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
546   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
547   ***      0                                  0         my $prev = {};
548   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
549   ***      0      0                           0         if ( $from_key ) {
550   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
551   ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
552                                                         }
553   ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
554   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
555                                                      }
556                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
557   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
558   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
559   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
560   ***      0      0                           0         if ( defined $num ) {
561   ***      0      0                           0            if ( $factor ) {
562   ***      0                                  0               $num *= $factor_for{$factor};
563   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
564                                                                  'to num', $num, '* factor', $factor);
565                                                            }
566   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
567                                                         }
568                                                         else {
569   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
570                                                         }
571                                                      }
572                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
573   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
574                                                      }
575                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
576   ***      2            50                   48         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
577                                                      }
578                                                      else {
579           18                                 53         MKDEBUG && _d('Nothing to validate for option',
580                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
581                                                      }
582                                                   
583           22                                105      return;
584                                                   }
585                                                   
586                                                   sub get {
587           29                   29           162      my ( $self, $opt ) = @_;
588           29    100                         193      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
589   ***     29     50     33                  390      die "Option $opt does not exist"
590                                                         unless $long && exists $self->{opts}->{$long};
591           29                                335      return $self->{opts}->{$long}->{value};
592                                                   }
593                                                   
594                                                   sub got {
595            8                    8            46      my ( $self, $opt ) = @_;
596   ***      8     50                          50      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
597   ***      8     50     33                  105      die "Option $opt does not exist"
598                                                         unless $long && exists $self->{opts}->{$long};
599            8                                 70      return $self->{opts}->{$long}->{got};
600                                                   }
601                                                   
602                                                   sub has {
603           18                   18            91      my ( $self, $opt ) = @_;
604           18    100                         127      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
605           18    100                         207      return defined $long ? exists $self->{opts}->{$long} : 0;
606                                                   }
607                                                   
608                                                   sub set {
609   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
610   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
611   ***      0      0      0                    0      die "Option $opt does not exist"
612                                                         unless $long && exists $self->{opts}->{$long};
613   ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
614   ***      0                                  0      return;
615                                                   }
616                                                   
617                                                   sub save_error {
618   ***      0                    0             0      my ( $self, $error ) = @_;
619   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
620                                                   }
621                                                   
622                                                   sub errors {
623   ***      0                    0             0      my ( $self ) = @_;
624   ***      0                                  0      return $self->{errors};
625                                                   }
626                                                   
627                                                   sub prompt {
628   ***      0                    0             0      my ( $self ) = @_;
629   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
630                                                   }
631                                                   
632                                                   sub descr {
633   ***      0                    0             0      my ( $self ) = @_;
634   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
635                                                                 . "  For more details, please use the --help option, "
636                                                                 . "or try 'perldoc $PROGRAM_NAME' "
637                                                                 . "for complete documentation.";
638   ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
639   ***      0                                  0      $descr =~ s/ +$//mg;
640   ***      0                                  0      return $descr;
641                                                   }
642                                                   
643                                                   sub usage_or_errors {
644            2                    2            10      my ( $self ) = @_;
645   ***      2     50                          17      if ( $self->{opts}->{help}->{got} ) {
      ***      2     50                          14   
646   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
647   ***      0                                  0         exit 0;
648                                                      }
649                                                      elsif ( scalar @{$self->{errors}} ) {
650   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
651   ***      0                                  0         exit 0;
652                                                      }
653            2                                  8      return;
654                                                   }
655                                                   
656                                                   sub print_errors {
657   ***      0                    0             0      my ( $self ) = @_;
658   ***      0                                  0      my $usage = $self->prompt() . "\n";
659   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
660   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
661                                                                 . "\n";
662                                                      }
663   ***      0                                  0      return $usage . "\n" . $self->descr();
664                                                   }
665                                                   
666                                                   sub print_usage {
667   ***      0                    0             0      my ( $self ) = @_;
668   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
669   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
670                                                   
671   ***      0      0                           0      my $maxl = max(
672   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
673                                                         @opts);
674                                                   
675   ***      0      0                           0      my $maxs = max(0,
676   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
677   ***      0                                  0         values %{$self->{short_opts}});
678                                                   
679   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
680   ***      0                                  0      my $rcol = 80 - $lcol - 6;
681   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
682                                                   
683   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
684                                                   
685   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
686                                                   
687   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
688   ***      0                                  0      push @groups, 'default';
689                                                   
690   ***      0                                  0      foreach my $group ( reverse @groups ) {
691   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
692   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
693   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
694                                                            grep { $_->{group} eq $group }
695                                                            @opts )
696                                                         {
697   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
698   ***      0                                  0            my $short = $opt->{short};
699   ***      0                                  0            my $desc  = $opt->{desc};
700   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
701   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
702   ***      0             0                    0               $s    ||= 's';
703   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
704   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
705                                                                      . "d=days; if no suffix, $s is used.";
706                                                            }
707   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
708   ***      0                                  0            $desc =~ s/ +$//mg;
709   ***      0      0                           0            if ( $short ) {
710   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
711                                                            }
712                                                            else {
713   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
714                                                            }
715                                                         }
716                                                      }
717                                                   
718   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
719   ***      0                                  0         $usage .= "\nRules:\n\n";
720   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
721                                                      }
722   ***      0      0                           0      if ( $self->{dp} ) {
723   ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
724                                                      }
725   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
726   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
727   ***      0                                  0         my $val   = $opt->{value};
728   ***      0             0                    0         my $type  = $opt->{type} || '';
729   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
730   ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
731                                                                   : !defined $val             ? '(No value)'
732                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
733                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
734                                                                   : $type =~ m/A|a/           ? join(',', @$val)
735                                                                   :                             $val;
736   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
737                                                      }
738   ***      0                                  0      return $usage;
739                                                   }
740                                                   
741                                                   sub prompt_noecho {
742   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
743   ***      0                                  0      my ( $prompt ) = @_;
744   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
745   ***      0      0                           0      print $prompt
746                                                         or die "Cannot print: $OS_ERROR";
747   ***      0                                  0      my $response;
748   ***      0                                  0      eval {
749   ***      0                                  0         require Term::ReadKey;
750   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
751   ***      0                                  0         chomp($response = <STDIN>);
752   ***      0                                  0         Term::ReadKey::ReadMode('normal');
753   ***      0      0                           0         print "\n"
754                                                            or die "Cannot print: $OS_ERROR";
755                                                      };
756   ***      0      0                           0      if ( $EVAL_ERROR ) {
757   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
758                                                      }
759   ***      0                                  0      return $response;
760                                                   }
761                                                   
762                                                   if ( MKDEBUG ) {
763                                                      print '# ', $^X, ' ', $], "\n";
764                                                      my $uname = `uname -a`;
765                                                      if ( $uname ) {
766                                                         $uname =~ s/\s+/ /g;
767                                                         print "# $uname\n";
768                                                      }
769                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
770                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
771                                                         ($main::SVN_REV || ''), __LINE__);
772                                                      print('# Arguments: ',
773                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
774                                                   }
775                                                   
776                                                   sub _read_config_file {
777            8                    8            44      my ( $self, $filename ) = @_;
778   ***      8     50                          28      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
779   ***      0                                  0      my @args;
780   ***      0                                  0      my $prefix = '--';
781   ***      0                                  0      my $parse  = 1;
782                                                   
783                                                      LINE:
784   ***      0                                  0      while ( my $line = <$fh> ) {
785   ***      0                                  0         chomp $line;
786   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
787   ***      0                                  0         $line =~ s/\s+#.*$//g;
788   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
789   ***      0      0                           0         if ( $line eq '--' ) {
790   ***      0                                  0            $prefix = '';
791   ***      0                                  0            $parse  = 0;
792   ***      0                                  0            next LINE;
793                                                         }
794   ***      0      0      0                    0         if ( $parse
      ***             0                               
795                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
796                                                         ) {
797   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
798                                                         }
799                                                         elsif ( $line =~ m/./ ) {
800   ***      0                                  0            push @args, $line;
801                                                         }
802                                                         else {
803   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
804                                                         }
805                                                      }
806   ***      0                                  0      close $fh;
807   ***      0                                  0      return @args;
808                                                   }
809                                                   
810                                                   sub read_para_after {
811   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
812   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
813   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
814   ***      0                                  0      my $para;
815   ***      0                                  0      while ( $para = <$fh> ) {
816   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
817   ***      0                                  0         last;
818                                                      }
819   ***      0                                  0      while ( $para = <$fh> ) {
820   ***      0      0                           0         next unless $para =~ m/$regex/;
821   ***      0                                  0         last;
822                                                      }
823   ***      0                                  0      $para = <$fh>;
824   ***      0                                  0      chomp($para);
825   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
826   ***      0                                  0      return $para;
827                                                   }
828                                                   
829                                                   sub clone {
830   ***      0                    0             0      my ( $self ) = @_;
831                                                   
832   ***      0                                  0      my %clone = map {
833   ***      0                                  0         my $hashref  = $self->{$_};
834   ***      0                                  0         my $val_copy = {};
835   ***      0                                  0         foreach my $key ( keys %$hashref ) {
836   ***      0                                  0            my $ref = ref $hashref->{$key};
837   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
838   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
839   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
840                                                                              : $hashref->{$key};
841                                                         }
842   ***      0                                  0         $_ => $val_copy;
843                                                      } qw(opts short_opts defaults);
844                                                   
845   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
846   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
847                                                      }
848                                                   
849   ***      0                                  0      return bless \%clone;     
850                                                   }
851                                                   
852                                                   sub _d {
853   ***      0                    0             0      my ($package, undef, $line) = caller 0;
854   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
855   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
856                                                           @_;
857   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
858                                                   }
859                                                   
860                                                   1;
861                                                   
862                                                   # ###########################################################################
863                                                   # End OptionParser package
864                                                   # ###########################################################################
865                                                   
866                                                   # ###########################################################################
867                                                   # DSNParser package 5266
868                                                   # ###########################################################################
869                                                   package DSNParser;
870                                                   
871            1                    1            16   use strict;
               1                                  3   
               1                                 11   
872            1                    1             7   use warnings FATAL => 'all';
               1                                  3   
               1                                  9   
873            1                    1             7   use English qw(-no_match_vars);
               1                                  3   
               1                                 12   
874            1                    1             7   use Data::Dumper;
               1                                  3   
               1                                 17   
875                                                   $Data::Dumper::Indent    = 0;
876                                                   $Data::Dumper::Quotekeys = 0;
877                                                   
878                                                   eval {
879                                                      require DBI;
880                                                   };
881                                                   my $have_dbi = $EVAL_ERROR ? 0 : 1;
882                                                   
883   ***      1            50      1             7   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 18   
884                                                   
885                                                   sub new {
886            3                    3            27      my ( $class, @opts ) = @_;
887            3                                129      my $self = {
888                                                         opts => {
889                                                            A => {
890                                                               desc => 'Default character set',
891                                                               dsn  => 'charset',
892                                                               copy => 1,
893                                                            },
894                                                            D => {
895                                                               desc => 'Database to use',
896                                                               dsn  => 'database',
897                                                               copy => 1,
898                                                            },
899                                                            F => {
900                                                               desc => 'Only read default options from the given file',
901                                                               dsn  => 'mysql_read_default_file',
902                                                               copy => 1,
903                                                            },
904                                                            h => {
905                                                               desc => 'Connect to host',
906                                                               dsn  => 'host',
907                                                               copy => 1,
908                                                            },
909                                                            p => {
910                                                               desc => 'Password to use when connecting',
911                                                               dsn  => 'password',
912                                                               copy => 1,
913                                                            },
914                                                            P => {
915                                                               desc => 'Port number to use for connection',
916                                                               dsn  => 'port',
917                                                               copy => 1,
918                                                            },
919                                                            S => {
920                                                               desc => 'Socket file to use for connection',
921                                                               dsn  => 'mysql_socket',
922                                                               copy => 1,
923                                                            },
924                                                            u => {
925                                                               desc => 'User for login if not current user',
926                                                               dsn  => 'user',
927                                                               copy => 1,
928                                                            },
929                                                         },
930                                                      };
931            3                                 25      foreach my $opt ( @opts ) {
932   ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
933   ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
934                                                      }
935            3                                 35      return bless $self, $class;
936                                                   }
937                                                   
938                                                   sub prop {
939           37                   37           233      my ( $self, $prop, $value ) = @_;
940           37    100                         236      if ( @_ > 2 ) {
941            2                                  5         MKDEBUG && _d('Setting', $prop, 'property');
942            2                                 12         $self->{$prop} = $value;
943                                                      }
944           37                                330      return $self->{$prop};
945                                                   }
946                                                   
947                                                   sub parse {
948           12                   12           272      my ( $self, $dsn, $prev, $defaults ) = @_;
949           12    100                          81      if ( !$dsn ) {
950            1                                  2         MKDEBUG && _d('No DSN to parse');
951            1                                  5         return;
952                                                      }
953           11                                 30      MKDEBUG && _d('Parsing', $dsn);
954           11           100                   65      $prev     ||= {};
955           11           100                   61      $defaults ||= {};
956           11                                 41      my %given_props;
957           11                                 38      my %final_props;
958           11                                 43      my %opts = %{$self->{opts}};
              11                                187   
959                                                   
960           11                                129      foreach my $dsn_part ( split(/,/, $dsn) ) {
961   ***     32     50                         427         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
962           32                                278            $given_props{$prop_key} = $prop_val;
963                                                         }
964                                                         else {
965   ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
966   ***      0                                  0            $given_props{h} = $dsn_part;
967                                                         }
968                                                      }
969                                                   
970           11                                 79      foreach my $key ( keys %opts ) {
971           88                                243         MKDEBUG && _d('Finding value for', $key);
972           88                                397         $final_props{$key} = $given_props{$key};
973           88    100    100                 1070         if (   !defined $final_props{$key}
      ***                   66                        
974                                                              && defined $prev->{$key} && $opts{$key}->{copy} )
975                                                         {
976           13                                 64            $final_props{$key} = $prev->{$key};
977           13                                 41            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
978                                                         }
979           88    100                         616         if ( !defined $final_props{$key} ) {
980           43                                184            $final_props{$key} = $defaults->{$key};
981           43                                157            MKDEBUG && _d('Copying value for', $key, 'from defaults');
982                                                         }
983                                                      }
984                                                   
985           11                                 77      foreach my $key ( keys %given_props ) {
986   ***     32     50                         186         die "Unrecognized DSN part '$key' in '$dsn'\n"
987                                                            unless exists $opts{$key};
988                                                      }
989   ***     11     50                          72      if ( (my $required = $self->prop('required')) ) {
990   ***      0                                  0         foreach my $key ( keys %$required ) {
991   ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
992                                                         }
993                                                      }
994                                                   
995           11                                151      return \%final_props;
996                                                   }
997                                                   
998                                                   sub parse_options {
999            2                    2            10      my ( $self, $o ) = @_;
1000  ***      2     50                          16      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1001           1                                  9      my $dsn_string
1002                                                        = join(',',
1003          16    100                          77             map  { "$_=".$o->get($_); }
1004           2                                 17             grep { $o->has($_) && $o->get($_) }
1005           2                                  9             keys %{$self->{opts}}
1006                                                          );
1007           2                                 10      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1008           2                                 15      return $self->parse($dsn_string);
1009                                                  }
1010                                                  
1011                                                  sub as_string {
1012  ***      0                    0             0      my ( $self, $dsn ) = @_;
1013  ***      0      0                           0      return $dsn unless ref $dsn;
1014  ***      0      0                           0      return join(',',
1015  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1016  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1017                                                        sort keys %$dsn );
1018                                                  }
1019                                                  
1020                                                  sub usage {
1021  ***      0                    0             0      my ( $self ) = @_;
1022  ***      0                                  0      my $usage
1023                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1024                                                        . "  KEY  COPY  MEANING\n"
1025                                                        . "  ===  ====  =============================================\n";
1026  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1027  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1028  ***      0      0      0                    0         $usage .= "  $key    "
1029                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1030                                                               .  ($opts{$key}->{desc} || '[No description]')
1031                                                               . "\n";
1032                                                     }
1033  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1034  ***      0                                  0      return $usage;
1035                                                  }
1036                                                  
1037                                                  sub get_cxn_params {
1038           9                    9            89      my ( $self, $info ) = @_;
1039           9                                 38      my $dsn;
1040           9                                 33      my %opts = %{$self->{opts}};
               9                                110   
1041  ***      9            50                   67      my $driver = $self->prop('dbidriver') || '';
1042  ***      9     50                          55      if ( $driver eq 'Pg' ) {
1043  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1044  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1045  ***      0             0                    0                        grep { defined $info->{$_} }
1046                                                                       qw(h P));
1047                                                     }
1048                                                     else {
1049          21                                178         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1050          45                                210            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1051  ***      9            50                  201                        grep { defined $info->{$_} }
1052                                                                       qw(F h P S A))
1053                                                           . ';mysql_read_default_group=client';
1054                                                     }
1055           9                                 35      MKDEBUG && _d($dsn);
1056           9                                121      return ($dsn, $info->{u}, $info->{p});
1057                                                  }
1058                                                  
1059                                                  sub fill_in_dsn {
1060           3                    3            21      my ( $self, $dbh, $dsn ) = @_;
1061           3                                 12      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1062           3                                 13      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1063           3                              17595      $user =~ s/@.*//;
1064  ***      3            50                  705      $dsn->{h} ||= $vars->{hostname}->{Value};
1065  ***      3            50                   39      $dsn->{S} ||= $vars->{'socket'}->{Value};
1066  ***      3            50                   23      $dsn->{P} ||= $vars->{port}->{Value};
1067  ***      3            50                   22      $dsn->{u} ||= $user;
1068  ***      3            50                  790      $dsn->{D} ||= $db;
1069                                                  }
1070                                                  
1071                                                  sub get_dbh {
1072           9                    9            75      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1073  ***      9            50                   53      $opts ||= {};
1074  ***      9     50                         135      my $defaults = {
1075                                                        AutoCommit         => 0,
1076                                                        RaiseError         => 1,
1077                                                        PrintError         => 0,
1078                                                        ShowErrorStatement => 1,
1079                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1080                                                     };
1081           9                                 61      @{$defaults}{ keys %$opts } = values %$opts;
               9                                 48   
1082                                                  
1083  ***      9     50                          48      if ( !$have_dbi ) {
1084  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1085                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1086                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1087                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1088                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1089                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1090                                                  
1091                                                     }
1092                                                  
1093           9                                 26      my $dbh;
1094           9                                 35      my $tries = 2;
1095  ***      9            66                  119      while ( !$dbh && $tries-- ) {
1096                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1097           9                                 25            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1098                                                  
1099           9                                 33         eval {
1100           9                                107            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1101                                                  
1102  ***      9     50                         124            if ( $cxn_string =~ m/mysql/i ) {
1103           9                                 32               my $sql;
1104                                                  
1105           9                                 43               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1106                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1107           9                                 42               MKDEBUG && _d($dbh, ':', $sql);
1108           9                               4352               $dbh->do($sql);
1109                                                  
1110  ***      9     50                         114               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1111  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1112  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1113  ***      0                                  0                  $dbh->do($sql);
1114  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1115  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1116  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1117                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1118                                                                 }
1119                                                                 else {
1120  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1121                                                                 }
1122                                                              }
1123                                                  
1124           9    100                          78               if ( $self->prop('set-vars') ) {
1125           6                                 36                  $sql = "SET " . $self->prop('set-vars');
1126           6                                 21                  MKDEBUG && _d($dbh, ':', $sql);
1127           6                                669                  $dbh->do($sql);
1128                                                              }
1129                                                           }
1130                                                        };
1131  ***      9     50     33                  129         if ( !$dbh && $EVAL_ERROR ) {
1132  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1133  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1134  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1135  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1136                                                           }
1137                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1138  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1139                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1140                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1141                                                                 . "DBD::mysql is not installed, try:\n"
1142                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1143                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1144                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1145                                                           }
1146  ***      0      0                           0            if ( !$tries ) {
1147  ***      0                                  0               die $EVAL_ERROR;
1148                                                           }
1149                                                        }
1150                                                     }
1151                                                  
1152           9                                 26      MKDEBUG && _d('DBH info: ',
1153                                                        $dbh,
1154                                                        Dumper($dbh->selectrow_hashref(
1155                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1156                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1157                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1158                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1159                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1160                                                        '$DBI::VERSION:',        $DBI::VERSION,
1161                                                     );
1162                                                  
1163           9                                 68      return $dbh;
1164                                                  }
1165                                                  
1166                                                  sub get_hostname {
1167  ***      0                    0             0      my ( $self, $dbh ) = @_;
1168  ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1169  ***      0                                  0         return $host;
1170                                                     }
1171  ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
1172                                                        'SELECT /*!50038 @@hostname, */ 1');
1173  ***      0                                  0      return $hostname;
1174                                                  }
1175                                                  
1176                                                  sub disconnect {
1177  ***      0                    0             0      my ( $self, $dbh ) = @_;
1178  ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
1179  ***      0                                  0      $dbh->disconnect;
1180                                                  }
1181                                                  
1182                                                  sub print_active_handles {
1183  ***      0                    0             0      my ( $self, $thing, $level ) = @_;
1184  ***      0             0                    0      $level ||= 0;
1185  ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1186                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1187                                                        or die "Cannot print: $OS_ERROR";
1188  ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
1189  ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
1190                                                     }
1191                                                  }
1192                                                  
1193                                                  sub copy {
1194  ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1195  ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
1196  ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
1197  ***      0                                  0      my %new_dsn = map {
1198  ***      0                                  0         my $key = $_;
1199  ***      0                                  0         my $val;
1200  ***      0      0                           0         if ( $args{overwrite} ) {
1201  ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1202                                                        }
1203                                                        else {
1204  ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1205                                                        }
1206  ***      0                                  0         $key => $val;
1207  ***      0                                  0      } keys %{$self->{opts}};
1208  ***      0                                  0      return \%new_dsn;
1209                                                  }
1210                                                  
1211                                                  sub _d {
1212  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1213  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1214  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1215                                                          @_;
1216  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1217                                                  }
1218                                                  
1219                                                  1;
1220                                                  
1221                                                  # ###########################################################################
1222                                                  # End DSNParser package
1223                                                  # ###########################################################################
1224                                                  
1225                                                  # ###########################################################################
1226                                                  # MasterSlave package 5362
1227                                                  # ###########################################################################
1228           1                    1            10   use strict;
               1                                  3   
               1                                  8   
1229           1                    1             7   use warnings FATAL => 'all';
               1                                  2   
               1                                  7   
1230                                                  
1231                                                  package MasterSlave;
1232                                                  
1233           1                    1             7   use English qw(-no_match_vars);
               1                                  9   
               1                                  7   
1234           1                    1             9   use List::Util qw(min max);
               1                                  2   
               1                                  6   
1235           1                    1             7   use Data::Dumper;
               1                                  3   
               1                                  6   
1236                                                  $Data::Dumper::Quotekeys = 0;
1237                                                  $Data::Dumper::Indent    = 0;
1238                                                  
1239  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 22   
1240                                                  
1241                                                  sub new {
1242           2                    2            28      bless {}, shift;
1243                                                  }
1244                                                  
1245                                                  sub recurse_to_slaves {
1246  ***      0                    0             0      my ( $self, $args, $level ) = @_;
1247  ***      0             0                    0      $level ||= 0;
1248  ***      0                                  0      my $dp   = $args->{dsn_parser};
1249  ***      0                                  0      my $dsn  = $args->{dsn};
1250                                                  
1251  ***      0                                  0      my $dbh;
1252  ***      0                                  0      eval {
1253  ***      0             0                    0         $dbh = $args->{dbh} || $dp->get_dbh(
1254                                                           $dp->get_cxn_params($dsn), { AutoCommit => 1 });
1255  ***      0                                  0         MKDEBUG && _d('Connected to', $dp->as_string($dsn));
1256                                                     };
1257  ***      0      0                           0      if ( $EVAL_ERROR ) {
1258  ***      0      0                           0         print STDERR "Cannot connect to ", $dp->as_string($dsn), "\n"
1259                                                           or die "Cannot print: $OS_ERROR";
1260  ***      0                                  0         return;
1261                                                     }
1262                                                  
1263  ***      0                                  0      my $sql  = 'SELECT @@SERVER_ID';
1264  ***      0                                  0      MKDEBUG && _d($sql);
1265  ***      0                                  0      my ($id) = $dbh->selectrow_array($sql);
1266  ***      0                                  0      MKDEBUG && _d('Working on server ID', $id);
1267  ***      0                                  0      my $master_thinks_i_am = $dsn->{server_id};
1268  ***      0      0      0                    0      if ( !defined $id
      ***                    0                        
      ***                    0                        
1269                                                         || ( defined $master_thinks_i_am && $master_thinks_i_am != $id )
1270                                                         || $args->{server_ids_seen}->{$id}++
1271                                                     ) {
1272  ***      0                                  0         MKDEBUG && _d('Server ID seen, or not what master said');
1273  ***      0      0                           0         if ( $args->{skip_callback} ) {
1274  ***      0                                  0            $args->{skip_callback}->($dsn, $dbh, $level, $args->{parent});
1275                                                        }
1276  ***      0                                  0         return;
1277                                                     }
1278                                                  
1279  ***      0                                  0      $args->{callback}->($dsn, $dbh, $level, $args->{parent});
1280                                                  
1281  ***      0      0      0                    0      if ( !defined $args->{recurse} || $level < $args->{recurse} ) {
1282                                                  
1283  ***      0      0                           0         my @slaves =
1284  ***      0                                  0            grep { !$_->{master_id} || $_->{master_id} == $id } # Only my slaves.
1285                                                           $self->find_slave_hosts($dp, $dbh, $dsn, $args->{method});
1286                                                  
1287  ***      0                                  0         foreach my $slave ( @slaves ) {
1288  ***      0                                  0            MKDEBUG && _d('Recursing from',
1289                                                              $dp->as_string($dsn), 'to', $dp->as_string($slave));
1290  ***      0                                  0            $self->recurse_to_slaves(
1291                                                              { %$args, dsn => $slave, dbh => undef, parent => $dsn }, $level + 1 );
1292                                                        }
1293                                                     }
1294                                                  }
1295                                                  
1296                                                  sub find_slave_hosts {
1297  ***      0                    0             0      my ( $self, $dsn_parser, $dbh, $dsn, $method ) = @_;
1298                                                  
1299  ***      0                                  0      my @methods = qw(processlist hosts);
1300  ***      0      0                           0      if ( $method ) {
1301  ***      0                                  0         @methods = grep { $_ ne $method } @methods;
      ***      0                                  0   
1302  ***      0                                  0         unshift @methods, $method;
1303                                                     }
1304                                                     else {
1305  ***      0      0      0                    0         if ( ($dsn->{P} || 3306) != 3306 ) {
1306  ***      0                                  0            MKDEBUG && _d('Port number is non-standard; using only hosts method');
1307  ***      0                                  0            @methods = qw(hosts);
1308                                                        }
1309                                                     }
1310  ***      0                                  0      MKDEBUG && _d('Looking for slaves on', $dsn_parser->as_string($dsn),
1311                                                        'using methods', @methods);
1312                                                  
1313  ***      0                                  0      my @slaves;
1314                                                     METHOD:
1315  ***      0                                  0      foreach my $method ( @methods ) {
1316  ***      0                                  0         my $find_slaves = "_find_slaves_by_$method";
1317  ***      0                                  0         MKDEBUG && _d('Finding slaves with', $find_slaves);
1318  ***      0                                  0         @slaves = $self->$find_slaves($dsn_parser, $dbh, $dsn);
1319  ***      0      0                           0         last METHOD if @slaves;
1320                                                     }
1321                                                  
1322  ***      0                                  0      MKDEBUG && _d('Found', scalar(@slaves), 'slaves');
1323  ***      0                                  0      return @slaves;
1324                                                  }
1325                                                  
1326                                                  sub _find_slaves_by_processlist {
1327  ***      0                    0             0      my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
1328                                                  
1329  ***      0                                  0      my @slaves = map  {
1330  ***      0                                  0         my $slave        = $dsn_parser->parse("h=$_", $dsn);
1331  ***      0                                  0         $slave->{source} = 'processlist';
1332  ***      0                                  0         $slave;
1333                                                     }
1334  ***      0                                  0      grep { $_ }
1335                                                     map  {
1336  ***      0                                  0         my ( $host ) = $_->{host} =~ m/^([^:]+):/;
1337  ***      0      0                           0         if ( $host eq 'localhost' ) {
1338  ***      0                                  0            $host = '127.0.0.1'; # Replication never uses sockets.
1339                                                        }
1340  ***      0                                  0         $host;
1341                                                     } $self->get_connected_slaves($dbh);
1342                                                  
1343  ***      0                                  0      return @slaves;
1344                                                  }
1345                                                  
1346                                                  sub _find_slaves_by_hosts {
1347  ***      0                    0             0      my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
1348                                                  
1349  ***      0                                  0      my @slaves;
1350  ***      0                                  0      my $sql = 'SHOW SLAVE HOSTS';
1351  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
1352  ***      0                                  0      @slaves = @{$dbh->selectall_arrayref($sql, { Slice => {} })};
      ***      0                                  0   
1353                                                  
1354  ***      0      0                           0      if ( @slaves ) {
1355  ***      0                                  0         MKDEBUG && _d('Found some SHOW SLAVE HOSTS info');
1356  ***      0                                  0         @slaves = map {
1357  ***      0                                  0            my %hash;
1358  ***      0                                  0            @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
1359  ***      0      0                           0            my $spec = "h=$hash{host},P=$hash{port}"
      ***             0                               
1360                                                              . ( $hash{user} ? ",u=$hash{user}" : '')
1361                                                              . ( $hash{password} ? ",p=$hash{password}" : '');
1362  ***      0                                  0            my $dsn           = $dsn_parser->parse($spec, $dsn);
1363  ***      0                                  0            $dsn->{server_id} = $hash{server_id};
1364  ***      0                                  0            $dsn->{master_id} = $hash{master_id};
1365  ***      0                                  0            $dsn->{source}    = 'hosts';
1366  ***      0                                  0            $dsn;
1367                                                        } @slaves;
1368                                                     }
1369                                                  
1370  ***      0                                  0      return @slaves;
1371                                                  }
1372                                                  
1373                                                  sub get_connected_slaves {
1374  ***      0                    0             0      my ( $self, $dbh ) = @_;
1375                                                  
1376  ***      0                                  0      my $proc =
1377  ***      0                                  0         grep { m/ALL PRIVILEGES.*?\*\.\*|PROCESS/ }
1378  ***      0                                  0         @{$dbh->selectcol_arrayref('SHOW GRANTS')};
1379  ***      0      0                           0      if ( !$proc ) {
1380  ***      0                                  0         die "You do not have the PROCESS privilege";
1381                                                     }
1382                                                  
1383  ***      0                                  0      my $sql = 'SHOW PROCESSLIST';
1384  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
1385  ***      0                                  0      grep { $_->{command} =~ m/Binlog Dump/i }
      ***      0                                  0   
1386                                                     map  { # Lowercase the column names
1387  ***      0                                  0         my %hash;
1388  ***      0                                  0         @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
1389  ***      0                                  0         \%hash;
1390                                                     }
1391  ***      0                                  0      @{$dbh->selectall_arrayref($sql, { Slice => {} })};
1392                                                  }
1393                                                  
1394                                                  sub is_master_of {
1395  ***      0                    0             0      my ( $self, $master, $slave ) = @_;
1396  ***      0      0                           0      my $master_status = $self->get_master_status($master)
1397                                                        or die "The server specified as a master is not a master";
1398  ***      0      0                           0      my $slave_status  = $self->get_slave_status($slave)
1399                                                        or die "The server specified as a slave is not a slave";
1400  ***      0      0                           0      my @connected     = $self->get_connected_slaves($master)
1401                                                        or die "The server specified as a master has no connected slaves";
1402  ***      0                                  0      my (undef, $port) = $master->selectrow_array('SHOW VARIABLES LIKE "port"');
1403                                                  
1404  ***      0      0                           0      if ( $port != $slave_status->{master_port} ) {
1405  ***      0                                  0         die "The slave is connected to $slave_status->{master_port} "
1406                                                           . "but the master's port is $port";
1407                                                     }
1408                                                  
1409  ***      0      0                           0      if ( !grep { $slave_status->{master_user} eq $_->{user} } @connected ) {
      ***      0                                  0   
1410  ***      0                                  0         die "I don't see any slave I/O thread connected with user "
1411                                                           . $slave_status->{master_user};
1412                                                     }
1413                                                  
1414  ***      0      0      0                    0      if ( ($slave_status->{slave_io_state} || '')
1415                                                        eq 'Waiting for master to send event' )
1416                                                     {
1417  ***      0                                  0         my ( $master_log_name, $master_log_num )
1418                                                           = $master_status->{file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
1419  ***      0                                  0         my ( $slave_log_name, $slave_log_num )
1420                                                           = $slave_status->{master_log_file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
1421  ***      0      0      0                    0         if ( $master_log_name ne $slave_log_name
1422                                                           || abs($master_log_num - $slave_log_num) > 1 )
1423                                                        {
1424  ***      0                                  0            die "The slave thinks it is reading from "
1425                                                              . "$slave_status->{master_log_file},  but the "
1426                                                              . "master is writing to $master_status->{file}";
1427                                                        }
1428                                                     }
1429  ***      0                                  0      return 1;
1430                                                  }
1431                                                  
1432                                                  sub get_master_dsn {
1433           4                    4            31      my ( $self, $dbh, $dsn, $dsn_parser ) = @_;
1434  ***      4     50                          29      my $master = $self->get_slave_status($dbh) or return undef;
1435           4                                 35      my $spec   = "h=$master->{master_host},P=$master->{master_port}";
1436           4                                 32      return       $dsn_parser->parse($spec, $dsn);
1437                                                  }
1438                                                  
1439                                                  sub get_slave_status {
1440          14                   14           102      my ( $self, $dbh ) = @_;
1441  ***     14     50                         218      if ( !$self->{not_a_slave}->{$dbh} ) {
1442  ***     14            66                  132         my $sth = $self->{sths}->{$dbh}->{SLAVE_STATUS}
1443                                                              ||= $dbh->prepare('SHOW SLAVE STATUS');
1444          14                                 79         MKDEBUG && _d($dbh, 'SHOW SLAVE STATUS');
1445          14                               4190         $sth->execute();
1446          14                                 74         my ($ss) = @{$sth->fetchall_arrayref({})};
              14                                130   
1447                                                  
1448  ***     14     50     33                  373         if ( $ss && %$ss ) {
1449          14                                206            $ss = { map { lc($_) => $ss->{$_} } keys %$ss }; # lowercase the keys
             462                               3250   
1450          14                                312            return $ss;
1451                                                        }
1452                                                  
1453  ***      0                                  0         MKDEBUG && _d('This server returns nothing for SHOW SLAVE STATUS');
1454  ***      0                                  0         $self->{not_a_slave}->{$dbh}++;
1455                                                     }
1456                                                  }
1457                                                  
1458                                                  sub get_master_status {
1459           5                    5            35      my ( $self, $dbh ) = @_;
1460  ***      5     50                          77      if ( !$self->{not_a_master}->{$dbh} ) {
1461  ***      5            66                   46         my $sth = $self->{sths}->{$dbh}->{MASTER_STATUS}
1462                                                              ||= $dbh->prepare('SHOW MASTER STATUS');
1463           5                                 33         MKDEBUG && _d($dbh, 'SHOW MASTER STATUS');
1464           5                               1010         $sth->execute();
1465           5                                 27         my ($ms) = @{$sth->fetchall_arrayref({})};
               5                                 42   
1466                                                  
1467  ***      5     50     33                  139         if ( $ms && %$ms ) {
1468           5                                 44            $ms = { map { lc($_) => $ms->{$_} } keys %$ms }; # lowercase the keys
              20                                161   
1469  ***      5     50     33                  106            if ( $ms->{file} && $ms->{position} ) {
1470           5                                 37               return $ms;
1471                                                           }
1472                                                        }
1473                                                  
1474  ***      0                                  0         MKDEBUG && _d('This server returns nothing for SHOW MASTER STATUS');
1475  ***      0                                  0         $self->{not_a_master}->{$dbh}++;
1476                                                     }
1477                                                  }
1478                                                  
1479                                                  sub wait_for_master {
1480           1                    1            11      my ( $self, $master, $slave, $time, $timeoutok, $ms ) = @_;
1481           1                                  3      my $result;
1482  ***      1     50                           9      $time = 60 unless defined $time;
1483           1                                  3      MKDEBUG && _d('Waiting for slave to catch up to master timeout ok:',
1484                                                        $timeoutok);
1485  ***      1            50                    5      $ms ||= $self->get_master_status($master);
1486  ***      1     50                           5      if ( $ms ) {
1487           1                                 11         my $query = "SELECT MASTER_POS_WAIT('$ms->{file}', $ms->{position}, $time)";
1488           1                                  4         MKDEBUG && _d($slave, $query);
1489           1                                  4         ($result) = $slave->selectrow_array($query);
1490  ***      1     50                      479850837         my $stat = defined $result ? $result : 'NULL';
1491           1                                  5         MKDEBUG && _d('Result of waiting:', $stat);
1492  ***      1     50     33                   43         if ( $stat eq 'NULL' || $stat < 0 && !$timeoutok ) {
      ***                   33                        
1493  ***      0                                  0            die "MASTER_POS_WAIT returned $stat";
1494                                                        }
1495                                                     }
1496                                                     else {
1497  ***      0                                  0         MKDEBUG && _d('Not waiting: this server is not a master');
1498                                                     }
1499           1                                 10      return $result;
1500                                                  }
1501                                                  
1502                                                  sub stop_slave {
1503           8                    8            48      my ( $self, $dbh ) = @_;
1504  ***      8            66                   70      my $sth = $self->{sths}->{$dbh}->{STOP_SLAVE}
1505                                                           ||= $dbh->prepare('STOP SLAVE');
1506           8                                 56      MKDEBUG && _d($dbh, $sth->{Statement});
1507           8                             2908578      $sth->execute();
1508                                                  }
1509                                                  
1510                                                  sub start_slave {
1511           1                    1             5      my ( $self, $dbh, $pos ) = @_;
1512  ***      1     50                           5      if ( $pos ) {
1513           1                                  8         my $sql = "START SLAVE UNTIL MASTER_LOG_FILE='$pos->{file}', "
1514                                                                . "MASTER_LOG_POS=$pos->{position}";
1515           1                                  3         MKDEBUG && _d($dbh, $sql);
1516           1                              43464         $dbh->do($sql);
1517                                                     }
1518                                                     else {
1519  ***      0             0                    0         my $sth = $self->{sths}->{$dbh}->{START_SLAVE}
1520                                                              ||= $dbh->prepare('START SLAVE');
1521  ***      0                                  0         MKDEBUG && _d($dbh, $sth->{Statement});
1522  ***      0                                  0         $sth->execute();
1523                                                     }
1524                                                  }
1525                                                  
1526                                                  sub catchup_to_master {
1527           1                    1             8      my ( $self, $slave, $master, $time ) = @_;
1528           1                                  6      $self->stop_slave($master);
1529           1                                  5      $self->stop_slave($slave);
1530           1                                 17      my $slave_status  = $self->get_slave_status($slave);
1531           1                                 10      my $slave_pos     = $self->repl_posn($slave_status);
1532           1                                  8      my $master_status = $self->get_master_status($master);
1533           1                                  5      my $master_pos    = $self->repl_posn($master_status);
1534           1                                  2      MKDEBUG && _d('Master position:', $self->pos_to_string($master_pos),
1535                                                        'Slave position:', $self->pos_to_string($slave_pos));
1536  ***      1     50                           8      if ( $self->pos_cmp($slave_pos, $master_pos) < 0 ) {
1537           1                                  3         MKDEBUG && _d('Waiting for slave to catch up to master');
1538           1                                  7         $self->start_slave($slave, $master_pos);
1539           1                                 11         eval {
1540           1                                 15            $self->wait_for_master($master, $slave, $time, 0, $master_status);
1541                                                        };
1542  ***      1     50                          39         if ( $EVAL_ERROR ) {
1543  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1544  ***      0      0                           0            if ( $EVAL_ERROR =~ m/MASTER_POS_WAIT returned NULL/ ) {
1545  ***      0                                  0               $slave_status = $self->get_slave_status($slave);
1546  ***      0      0                           0               if ( !$self->slave_is_running($slave_status) ) {
1547  ***      0                                  0                  MKDEBUG && _d('Master position:',
1548                                                                    $self->pos_to_string($master_pos),
1549                                                                    'Slave position:', $self->pos_to_string($slave_pos));
1550  ***      0                                  0                  $slave_pos = $self->repl_posn($slave_status);
1551  ***      0      0                           0                  if ( $self->pos_cmp($slave_pos, $master_pos) != 0 ) {
1552  ***      0                                  0                     die "$EVAL_ERROR but slave has not caught up to master";
1553                                                                 }
1554  ***      0                                  0                  MKDEBUG && _d('Slave is caught up to master and stopped');
1555                                                              }
1556                                                              else {
1557  ***      0                                  0                  die "$EVAL_ERROR but slave was still running";
1558                                                              }
1559                                                           }
1560                                                           else {
1561  ***      0                                  0               die $EVAL_ERROR;
1562                                                           }
1563                                                        }
1564                                                     }
1565                                                  }
1566                                                  
1567                                                  sub catchup_to_same_pos {
1568           1                    1             8      my ( $self, $s1_dbh, $s2_dbh ) = @_;
1569           1                                  8      $self->stop_slave($s1_dbh);
1570           1                                 10      $self->stop_slave($s2_dbh);
1571           1                                 11      my $s1_status = $self->get_slave_status($s1_dbh);
1572           1                                  8      my $s2_status = $self->get_slave_status($s2_dbh);
1573           1                                  9      my $s1_pos    = $self->repl_posn($s1_status);
1574           1                                  7      my $s2_pos    = $self->repl_posn($s2_status);
1575  ***      1     50                           8      if ( $self->pos_cmp($s1_pos, $s2_pos) < 0 ) {
      ***            50                               
1576  ***      0                                  0         $self->start_slave($s1_dbh, $s2_pos);
1577                                                     }
1578                                                     elsif ( $self->pos_cmp($s2_pos, $s1_pos) < 0 ) {
1579  ***      0                                  0         $self->start_slave($s2_dbh, $s1_pos);
1580                                                     }
1581                                                  
1582           1                                  8      $s1_status = $self->get_slave_status($s1_dbh);
1583           1                                 16      $s2_status = $self->get_slave_status($s2_dbh);
1584           1                                 15      $s1_pos    = $self->repl_posn($s1_status);
1585           1                                  9      $s2_pos    = $self->repl_posn($s2_status);
1586                                                  
1587  ***      1     50     33                   10      if ( $self->slave_is_running($s1_status)
      ***                   33                        
1588                                                       || $self->slave_is_running($s2_status)
1589                                                       || $self->pos_cmp($s1_pos, $s2_pos) != 0)
1590                                                     {
1591  ***      0                                  0         die "The servers aren't both stopped at the same position";
1592                                                     }
1593                                                  
1594                                                  }
1595                                                  
1596                                                  sub change_master_to {
1597           2                    2            16      my ( $self, $dbh, $master_dsn, $master_pos ) = @_;
1598           2                                 13      $self->stop_slave($dbh);
1599           2                                 10      MKDEBUG && _d(Dumper($master_dsn), Dumper($master_pos));
1600           2                                 43      my $sql = "CHANGE MASTER TO MASTER_HOST='$master_dsn->{h}', "
1601                                                        . "MASTER_PORT= $master_dsn->{P}, MASTER_LOG_FILE='$master_pos->{file}', "
1602                                                        . "MASTER_LOG_POS=$master_pos->{position}";
1603           2                                  6      MKDEBUG && _d($dbh, $sql);
1604           2                             461847      $dbh->do($sql);
1605                                                  }
1606                                                  
1607                                                  sub make_sibling_of_master {
1608           1                    1             6      my ( $self, $slave_dbh, $slave_dsn, $dsn_parser, $timeout) = @_;
1609                                                  
1610  ***      1     50                          11      my $master_dsn  = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
1611                                                        or die "This server is not a slave";
1612           1                                  8      my $master_dbh  = $dsn_parser->get_dbh(
1613                                                        $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
1614  ***      1     50                          13      my $gmaster_dsn
1615                                                        = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
1616                                                        or die "This server's master is not a slave";
1617           1                                  7      my $gmaster_dbh = $dsn_parser->get_dbh(
1618                                                        $dsn_parser->get_cxn_params($gmaster_dsn), { AutoCommit => 1 });
1619  ***      1     50                          18      if ( $self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn) ) {
1620  ***      0                                  0         die "The slave's master's master is the slave: master-master replication";
1621                                                     }
1622                                                  
1623           1                                  9      $self->stop_slave($master_dbh);
1624           1                                 13      $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
1625           1                                 15      $self->stop_slave($slave_dbh);
1626                                                  
1627           1                                 15      my $master_status = $self->get_master_status($master_dbh);
1628           1                                 10      my $mslave_status = $self->get_slave_status($master_dbh);
1629           1                                  8      my $slave_status  = $self->get_slave_status($slave_dbh);
1630           1                                 10      my $master_pos    = $self->repl_posn($master_status);
1631           1                                  8      my $slave_pos     = $self->repl_posn($slave_status);
1632                                                  
1633  ***      1     50     33                   16      if ( !$self->slave_is_running($mslave_status)
      ***                   33                        
1634                                                       && !$self->slave_is_running($slave_status)
1635                                                       && $self->pos_cmp($master_pos, $slave_pos) == 0)
1636                                                     {
1637           1                                  7         $self->change_master_to($slave_dbh, $gmaster_dsn,
1638                                                           $self->repl_posn($mslave_status)); # Note it's not $master_pos!
1639                                                     }
1640                                                     else {
1641  ***      0                                  0         die "The servers aren't both stopped at the same position";
1642                                                     }
1643                                                  
1644           1                                 27      $mslave_status = $self->get_slave_status($master_dbh);
1645           1                                 20      $slave_status  = $self->get_slave_status($slave_dbh);
1646           1                                 18      my $mslave_pos = $self->repl_posn($mslave_status);
1647           1                                  7      $slave_pos     = $self->repl_posn($slave_status);
1648  ***      1     50     33                   10      if ( $self->short_host($mslave_status) ne $self->short_host($slave_status)
1649                                                       || $self->pos_cmp($mslave_pos, $slave_pos) != 0)
1650                                                     {
1651  ***      0                                  0         die "The servers don't have the same master/position after the change";
1652                                                     }
1653                                                  }
1654                                                  
1655                                                  sub make_slave_of_sibling {
1656           1                    1            11      my ( $self, $slave_dbh, $slave_dsn, $sib_dbh, $sib_dsn,
1657                                                          $dsn_parser, $timeout) = @_;
1658                                                  
1659  ***      1     50                           9      if ( $self->short_host($slave_dsn) eq $self->short_host($sib_dsn) ) {
1660  ***      0                                  0         die "You are trying to make the slave a slave of itself";
1661                                                     }
1662                                                  
1663  ***      1     50                           9      my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
1664                                                        or die "This server is not a slave";
1665           1                                  9      my $master_dbh1 = $dsn_parser->get_dbh(
1666                                                        $dsn_parser->get_cxn_params($master_dsn1), { AutoCommit => 1 });
1667  ***      1     50                          15      my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
1668                                                        or die "The sibling is not a slave";
1669  ***      1     50                           9      if ( $self->short_host($master_dsn1) ne $self->short_host($master_dsn2) ) {
1670  ***      0                                  0         die "This server isn't a sibling of the slave";
1671                                                     }
1672  ***      1     50                           8      my $sib_master_stat = $self->get_master_status($sib_dbh)
1673                                                        or die "Binary logging is not enabled on the sibling";
1674  ***      1     50                           9      die "The log_slave_updates option is not enabled on the sibling"
1675                                                        unless $self->has_slave_updates($sib_dbh);
1676                                                  
1677           1                                 14      $self->catchup_to_same_pos($slave_dbh, $sib_dbh);
1678                                                  
1679           1                                  9      $sib_master_stat = $self->get_master_status($sib_dbh);
1680           1                                 10      $self->change_master_to($slave_dbh, $sib_dsn,
1681                                                           $self->repl_posn($sib_master_stat));
1682                                                  
1683           1                                 27      my $slave_status = $self->get_slave_status($slave_dbh);
1684           1                                 10      my $slave_pos    = $self->repl_posn($slave_status);
1685           1                                  9      $sib_master_stat = $self->get_master_status($sib_dbh);
1686  ***      1     50     33                   10      if ( $self->short_host($slave_status) ne $self->short_host($sib_dsn)
1687                                                       || $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
1688                                                     {
1689  ***      0                                  0         die "After changing the slave's master, it isn't a slave of the sibling, "
1690                                                           . "or it has a different replication position than the sibling";
1691                                                     }
1692                                                  }
1693                                                  
1694                                                  sub make_slave_of_uncle {
1695  ***      0                    0             0      my ( $self, $slave_dbh, $slave_dsn, $unc_dbh, $unc_dsn,
1696                                                          $dsn_parser, $timeout) = @_;
1697                                                  
1698  ***      0      0                           0      if ( $self->short_host($slave_dsn) eq $self->short_host($unc_dsn) ) {
1699  ***      0                                  0         die "You are trying to make the slave a slave of itself";
1700                                                     }
1701                                                  
1702  ***      0      0                           0      my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
1703                                                        or die "This server is not a slave";
1704  ***      0                                  0      my $master_dbh = $dsn_parser->get_dbh(
1705                                                        $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
1706  ***      0      0                           0      my $gmaster_dsn
1707                                                        = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
1708                                                        or die "The master is not a slave";
1709  ***      0      0                           0      my $unc_master_dsn
1710                                                        = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
1711                                                        or die "The uncle is not a slave";
1712  ***      0      0                           0      if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn)) {
1713  ***      0                                  0         die "The uncle isn't really the slave's uncle";
1714                                                     }
1715                                                  
1716  ***      0      0                           0      my $unc_master_stat = $self->get_master_status($unc_dbh)
1717                                                        or die "Binary logging is not enabled on the uncle";
1718  ***      0      0                           0      die "The log_slave_updates option is not enabled on the uncle"
1719                                                        unless $self->has_slave_updates($unc_dbh);
1720                                                  
1721  ***      0                                  0      $self->catchup_to_same_pos($master_dbh, $unc_dbh);
1722  ***      0                                  0      $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
1723                                                  
1724  ***      0                                  0      my $slave_status  = $self->get_slave_status($slave_dbh);
1725  ***      0                                  0      my $master_status = $self->get_master_status($master_dbh);
1726  ***      0      0                           0      if ( $self->pos_cmp(
1727                                                           $self->repl_posn($slave_status),
1728                                                           $self->repl_posn($master_status)) != 0 )
1729                                                     {
1730  ***      0                                  0         die "The slave is not caught up to its master";
1731                                                     }
1732                                                  
1733  ***      0                                  0      $unc_master_stat = $self->get_master_status($unc_dbh);
1734  ***      0                                  0      $self->change_master_to($slave_dbh, $unc_dsn,
1735                                                        $self->repl_posn($unc_master_stat));
1736                                                  
1737                                                  
1738  ***      0                                  0      $slave_status    = $self->get_slave_status($slave_dbh);
1739  ***      0                                  0      my $slave_pos    = $self->repl_posn($slave_status);
1740  ***      0      0      0                    0      if ( $self->short_host($slave_status) ne $self->short_host($unc_dsn)
1741                                                       || $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
1742                                                     {
1743  ***      0                                  0         die "After changing the slave's master, it isn't a slave of the uncle, "
1744                                                           . "or it has a different replication position than the uncle";
1745                                                     }
1746                                                  }
1747                                                  
1748                                                  sub detach_slave {
1749  ***      0                    0             0      my ( $self, $dbh ) = @_;
1750  ***      0                                  0      $self->stop_slave($dbh);
1751  ***      0      0                           0      my $stat = $self->get_slave_status($dbh)
1752                                                        or die "This server is not a slave";
1753  ***      0                                  0      $dbh->do('CHANGE MASTER TO MASTER_HOST=""');
1754  ***      0                                  0      $dbh->do('RESET SLAVE'); # Wipes out master.info, etc etc
1755  ***      0                                  0      return $stat;
1756                                                  }
1757                                                  
1758                                                  sub slave_is_running {
1759           4                    4            28      my ( $self, $slave_status ) = @_;
1760  ***      4            50                  141      return ($slave_status->{slave_sql_running} || 'No') eq 'Yes';
1761                                                  }
1762                                                  
1763                                                  sub has_slave_updates {
1764           1                    1             7      my ( $self, $dbh ) = @_;
1765           1                                  6      my $sql = q{SHOW VARIABLES LIKE 'log_slave_updates'};
1766           1                                  4      MKDEBUG && _d($dbh, $sql);
1767           1                                  4      my ($name, $value) = $dbh->selectrow_array($sql);
1768  ***      1            33                  394      return $value && $value =~ m/^(1|ON)$/;
1769                                                  }
1770                                                  
1771                                                  sub repl_posn {
1772          14                   14            84      my ( $self, $status ) = @_;
1773  ***     14    100     66                  160      if ( exists $status->{file} && exists $status->{position} ) {
1774                                                        return {
1775           4                                 51            file     => $status->{file},
1776                                                           position => $status->{position},
1777                                                        };
1778                                                     }
1779                                                     else {
1780                                                        return {
1781          10                                125            file     => $status->{relay_master_log_file},
1782                                                           position => $status->{exec_master_log_pos},
1783                                                        };
1784                                                     }
1785                                                  }
1786                                                  
1787                                                  sub get_slave_lag {
1788  ***      0                    0             0      my ( $self, $dbh ) = @_;
1789  ***      0                                  0      my $stat = $self->get_slave_status($dbh);
1790  ***      0                                  0      return $stat->{seconds_behind_master};
1791                                                  }
1792                                                  
1793                                                  sub pos_cmp {
1794           7                    7            50      my ( $self, $a, $b ) = @_;
1795           7                                 51      return $self->pos_to_string($a) cmp $self->pos_to_string($b);
1796                                                  }
1797                                                  
1798                                                  sub short_host {
1799          10                   10            61      my ( $self, $dsn ) = @_;
1800          10                                 47      my ($host, $port);
1801          10    100                          71      if ( $dsn->{master_host} ) {
1802           3                                 17         $host = $dsn->{master_host};
1803           3                                 19         $port = $dsn->{master_port};
1804                                                     }
1805                                                     else {
1806           7                                 38         $host = $dsn->{h};
1807           7                                 36         $port = $dsn->{P};
1808                                                     }
1809  ***     10     50     50                  209      return ($host || '[default]') . ( ($port || 3306) == 3306 ? '' : ":$port" );
      ***                   50                        
1810                                                  }
1811                                                  
1812                                                  sub pos_to_string {
1813          14                   14            73      my ( $self, $pos ) = @_;
1814          14                                 63      my $fmt  = '%s/%020d';
1815          14                                 72      return sprintf($fmt, @{$pos}{qw(file position)});
              14                                648   
1816                                                  }
1817                                                  
1818                                                  sub _d {
1819  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1820  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1821  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1822                                                          @_;
1823  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1824                                                  }
1825                                                  
1826                                                  1;
1827                                                  
1828                                                  # ###########################################################################
1829                                                  # End MasterSlave package
1830                                                  # ###########################################################################
1831                                                  
1832                                                  # ###########################################################################
1833                                                  # Daemon package 5266
1834                                                  # ###########################################################################
1835                                                  
1836                                                  package Daemon;
1837                                                  
1838           1                    1            12   use strict;
               1                                  3   
               1                                  9   
1839           1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  7   
1840                                                  
1841           1                    1             7   use POSIX qw(setsid);
               1                                  2   
               1                                  7   
1842           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                 38   
1843                                                  
1844  ***      1            50      1             8   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 18   
1845                                                  
1846                                                  sub new {
1847  ***      0                    0             0      my ( $class, %args ) = @_;
1848  ***      0                                  0      foreach my $arg ( qw(o) ) {
1849  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1850                                                     }
1851  ***      0                                  0      my $o = $args{o};
1852  ***      0      0                           0      my $self = {
      ***             0                               
1853                                                        o        => $o,
1854                                                        log_file => $o->has('log') ? $o->get('log') : undef,
1855                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
1856                                                     };
1857                                                  
1858  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
1859                                                  
1860  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
1861  ***      0                                  0      return bless $self, $class;
1862                                                  }
1863                                                  
1864                                                  sub daemonize {
1865  ***      0                    0             0      my ( $self ) = @_;
1866                                                  
1867  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
1868  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
1869  ***      0      0                           0      if ( $pid ) {
1870  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
1871  ***      0                                  0         exit;
1872                                                     }
1873                                                  
1874  ***      0                                  0      $self->{child} = 1;
1875                                                  
1876  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
1877  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
1878                                                  
1879  ***      0                                  0      $self->_make_PID_file();
1880                                                  
1881  ***      0                                  0      $OUTPUT_AUTOFLUSH = 1;
1882                                                  
1883  ***      0      0                           0      if ( -t STDIN ) {
1884  ***      0                                  0         close STDIN;
1885  ***      0      0                           0         open  STDIN, '/dev/null'
1886                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
1887                                                     }
1888                                                  
1889  ***      0      0                           0      if ( $self->{log_file} ) {
1890  ***      0                                  0         close STDOUT;
1891  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
1892                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
1893                                                  
1894  ***      0                                  0         close STDERR;
1895  ***      0      0                           0         open  STDERR, ">&STDOUT"
1896                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
1897                                                     }
1898                                                     else {
1899  ***      0      0                           0         if ( -t STDOUT ) {
1900  ***      0                                  0            close STDOUT;
1901  ***      0      0                           0            open  STDOUT, '>', '/dev/null'
1902                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
1903                                                        }
1904  ***      0      0                           0         if ( -t STDERR ) {
1905  ***      0                                  0            close STDERR;
1906  ***      0      0                           0            open  STDERR, '>', '/dev/null'
1907                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
1908                                                        }
1909                                                     }
1910                                                  
1911  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
1912  ***      0                                  0      return;
1913                                                  }
1914                                                  
1915                                                  sub check_PID_file {
1916  ***      0                    0             0      my ( $self, $file ) = @_;
1917  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
1918  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
1919  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
1920  ***      0                                  0         my $pid;
1921  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
1922  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
1923  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
1924  ***      0      0                           0         if ( $pid ) {
1925  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
1926  ***      0      0                           0            if ( $pid_is_alive ) {
1927  ***      0                                  0               die "The PID file $PID_file already exists "
1928                                                                 . " and the PID that it contains, $pid, is running";
1929                                                           }
1930                                                           else {
1931  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
1932                                                                 . "contains, $pid, is not running";
1933                                                           }
1934                                                        }
1935                                                        else {
1936  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
1937                                                              . "contain a PID";
1938                                                        }
1939                                                     }
1940                                                     else {
1941  ***      0                                  0         MKDEBUG && _d('No PID file');
1942                                                     }
1943  ***      0                                  0      return;
1944                                                  }
1945                                                  
1946                                                  sub make_PID_file {
1947  ***      0                    0             0      my ( $self ) = @_;
1948  ***      0      0                           0      if ( exists $self->{child} ) {
1949  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
1950                                                     }
1951  ***      0                                  0      $self->_make_PID_file();
1952  ***      0                                  0      $self->{rm_PID_file} = 1;
1953  ***      0                                  0      return;
1954                                                  }
1955                                                  
1956                                                  sub _make_PID_file {
1957  ***      0                    0             0      my ( $self ) = @_;
1958                                                  
1959  ***      0                                  0      my $PID_file = $self->{PID_file};
1960  ***      0      0                           0      if ( !$PID_file ) {
1961  ***      0                                  0         MKDEBUG && _d('No PID file to create');
1962  ***      0                                  0         return;
1963                                                     }
1964                                                  
1965  ***      0                                  0      $self->check_PID_file();
1966                                                  
1967  ***      0      0                           0      open my $PID_FH, '>', $PID_file
1968                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
1969  ***      0      0                           0      print $PID_FH $PID
1970                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
1971  ***      0      0                           0      close $PID_FH
1972                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
1973                                                  
1974  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
1975  ***      0                                  0      return;
1976                                                  }
1977                                                  
1978                                                  sub _remove_PID_file {
1979  ***      0                    0             0      my ( $self ) = @_;
1980  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
1981  ***      0      0                           0         unlink $self->{PID_file}
1982                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
1983  ***      0                                  0         MKDEBUG && _d('Removed PID file');
1984                                                     }
1985                                                     else {
1986  ***      0                                  0         MKDEBUG && _d('No PID to remove');
1987                                                     }
1988  ***      0                                  0      return;
1989                                                  }
1990                                                  
1991                                                  sub DESTROY {
1992  ***      0                    0             0      my ( $self ) = @_;
1993  ***      0      0      0                    0      $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
1994  ***      0                                  0      return;
1995                                                  }
1996                                                  
1997                                                  sub _d {
1998  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1999  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2000  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2001                                                          @_;
2002  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2003                                                  }
2004                                                  
2005                                                  1;
2006                                                  
2007                                                  # ###########################################################################
2008                                                  # End Daemon package
2009                                                  # ###########################################################################
2010                                                  
2011                                                  # ###########################################################################
2012                                                  # This is a combination of modules and programs in one -- a runnable module.
2013                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
2014                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
2015                                                  #
2016                                                  # Check at the end of this package for the call to main() which actually runs
2017                                                  # the program.
2018                                                  # ###########################################################################
2019                                                  package mk_slave_move;
2020                                                  
2021           1                    1            13   use English qw(-no_match_vars);
               1                                  3   
               1                                  8   
2022           1                    1            11   use List::Util qw(min max);
               1                                  3   
               1                                  7   
2023                                                  
2024  ***      1            50      1             8   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 17   
2025                                                  
2026                                                  sub main {
2027           2                    2            21      @ARGV = @_;  # set global ARGV for this package
2028                                                  
2029                                                     # ########################################################################
2030                                                     # Get configuration information.
2031                                                     # ########################################################################
2032           2                                 33      my $dp = new DSNParser();
2033           2                                 37      my $o  = new OptionParser(
2034                                                        strict      => 0,
2035                                                        prompt      => '<options> SLAVE_DSN [DSN ...]',
2036                                                        description => 'moves replication slave(s) around in the hierarchy.',
2037                                                        dp          => $dp,
2038                                                     );
2039           2                                 15      $o->get_specs();
2040           2                                 21      $o->get_opts();
2041                                                  
2042           2                                 14      $dp->prop('set-vars', $o->get('set-vars'));
2043                                                  
2044           2                                 19      my $dsn_defaults = $dp->parse_options($o);
2045           2                                 13      my $slave_dsn    = $dp->parse(shift @ARGV, $dsn_defaults);
2046           2                                 13      my @dsns;
2047           2                                  9      push @dsns, $slave_dsn;
2048           2                                 21      while ( my $arg = shift(@ARGV)  ) {
2049           1                                  8         my $dsn = $dp->parse($arg, $slave_dsn, $dsn_defaults);
2050           1                                 11         push @dsns, $dsn;
2051                                                     }
2052                                                  
2053  ***      2     50     33                   24      if ( !@dsns ) {
      ***            50     66                        
2054  ***      0                                  0         $o->save_error('At least one DSN is required.');
2055                                                     }
2056                                                     elsif ( @dsns < 2 && !($o->get('sibling-of-master') || $o->get('detach')) ) {
2057  ***      0                                  0         $o->save_error('At least two DSNs are required.');
2058                                                     }
2059                                                  
2060           2                                 17      $o->usage_or_errors();
2061                                                  
2062                                                     # ########################################################################
2063                                                     # If --pid, check it first since we'll die if it already exits.
2064                                                     # ########################################################################
2065           2                                  7      my $daemon;
2066  ***      2     50                          10      if ( $o->get('pid') ) {
2067                                                        # We're not daemoninzing, it just handles PID stuff.  Keep $daemon
2068                                                        # in the the scope of main() because when it's destroyed it automatically
2069                                                        # removes the PID file.
2070  ***      0                                  0         $daemon = new Daemon(o=>$o);
2071  ***      0                                  0         $daemon->make_PID_file();
2072                                                     }
2073                                                  
2074                                                     # ########################################################################
2075                                                     # Connect and go to work.
2076                                                     # ########################################################################
2077           2                                 33      my $ms          = new MasterSlave();
2078           2                                 11      my $exit_status = 0;
2079                                                  
2080  ***      2     50                          11      if ( $o->get('ask-pass') ) {
2081  ***      0                                  0         my $pass = OptionParser::prompt_noecho("Enter password: ");
2082                                                        # Same password for all slave hosts.
2083  ***      0             0                    0         map { $_->{p} ||= $pass } @dsns;
      ***      0                                  0   
2084                                                     }
2085                                                  
2086           2                                  8      $slave_dsn = shift @dsns;  # re-using $slave_dsn from above
2087           2                                 19      my $slave_dbh
2088                                                        = $dp->get_dbh($dp->get_cxn_params($slave_dsn), { AutoCommit => 1 });
2089           2                                 25      $dp->fill_in_dsn($slave_dbh, $slave_dsn);
2090                                                  
2091           2    100                          28      if ( $o->get('sibling-of-master') ) {
      ***            50                               
      ***             0                               
      ***             0                               
2092           1                                  5         $ms->make_sibling_of_master($slave_dbh, $slave_dsn, $dp, $o->get('timeout'));
2093                                                     }
2094                                                     elsif ( $o->get('slave-of-sibling') ) {
2095           1                                  7         my $sib_dsn = shift @dsns;
2096           1                                 11         my $sib_dbh
2097                                                           = $dp->get_dbh($dp->get_cxn_params($sib_dsn), { AutoCommit => 1 });
2098           1                                 14         $dp->fill_in_dsn($sib_dbh, $sib_dsn);
2099           1                                 15         $ms->make_slave_of_sibling(
2100                                                           $slave_dbh, $slave_dsn, $sib_dbh, $sib_dsn, $dp, $o->get('timeout'));
2101                                                     }
2102                                                     elsif ( $o->get('slave-of-uncle') ) {
2103  ***      0                                  0         my $unc_dsn = shift @dsns;
2104  ***      0                                  0         my $unc_dbh
2105                                                           = $dp->get_dbh($dp->get_cxn_params($unc_dsn), { AutoCommit => 1 });
2106  ***      0                                  0         $dp->fill_in_dsn($unc_dbh, $unc_dsn);
2107  ***      0                                  0         $ms->make_slave_of_uncle(
2108                                                           $slave_dbh, $slave_dsn, $unc_dbh, $unc_dsn, $dp, $o->get('timeout'));
2109                                                     }
2110                                                     elsif ( $o->get('detach') ) {
2111  ***      0                                  0         my $stat = $ms->detach_slave($slave_dbh);
2112  ***      0                                  0         print $ms->short_host($slave_dsn),
2113                                                           " was a slave of ", $ms->short_host($stat),
2114                                                           " at position ", $ms->pos_to_string($ms->repl_posn($stat)), "\n";
2115                                                     }
2116                                                     else {
2117  ***      0                                  0         die "Sorry, this functionality isn't implemented yet";
2118                                                     }
2119                                                  
2120           2                                962      return $exit_status;
2121                                                  }
2122                                                  
2123                                                  # ############################################################################
2124                                                  # Subroutines.
2125                                                  # ############################################################################
2126                                                  
2127                                                  sub _d {
2128  ***      0                    0                    my ($package, undef, $line) = caller 0;
2129  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2130  ***      0                                              map { defined $_ ? $_ : 'undef' }
2131                                                          @_;
2132  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2133                                                  }
2134                                                  
2135                                                  # ############################################################################
2136                                                  # Run the program.
2137                                                  # ############################################################################
2138                                                  if ( !caller ) { exit main(@ARGV); }
2139                                                  
2140                                                  1; # Because this is a module as well as a script.
2141                                                  
2142                                                  # ############################################################################
2143                                                  # Documentation.
2144                                                  # ############################################################################
2145                                                  
2146                                                  =pod
2147                                                  
2148                                                  =head1 NAME
2149                                                  
2150                                                  mk-slave-move - Move a MySQL slave around in the replication hierarchy.
2151                                                  
2152                                                  =head1 SYNOPSIS
2153                                                  
2154                                                   mk-slave-move slave --sibling-of-master
2155                                                   mk-slave-move slave --slave-of-sibling sibling
2156                                                   mk-slave-move slave --slave-of-uncle uncle
2157                                                  
2158                                                  =head1 RISKS
2159                                                  
2160                                                  The following section is included to inform users about the potential risks,
2161                                                  whether known or unknown, of using this tool.  The two main categories of risks
2162                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
2163                                                  tools) and those created by bugs.
2164                                                  
2165                                                  mk-slave-move is a read-write tool by default.  It manipulates replication
2166                                                  settings.  Some of the features are incomplete, including some safety checks
2167                                                  such as not moving slaves that have temporary tables open.
2168                                                  
2169                                                  At the time of this release, we know of no bugs that could cause serious harm to
2170                                                  users.
2171                                                  
2172                                                  The authoritative source for updated information is always the online issue
2173                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
2174                                                  see a list of such issues at the following URL:
2175                                                  L<http://www.maatkit.org/bugs/mk-slave-move>.
2176                                                  
2177                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
2178                                                  
2179                                                  =head1 DESCRIPTION
2180                                                  
2181                                                  This tool knows how to disconnect and reconnect slaves to each other, compare
2182                                                  replication positions, and so on.  This makes it able to move a slave around the
2183                                                  replication hierarchy safely and correctly.  It doesn't do anything you can't do
2184                                                  by hand, but it is tedious and error-prone to do this by hand.
2185                                                  
2186                                                  The hosts are given by a DSN.  A DSN is a special syntax that can be either
2187                                                  just a hostname (like C<server.domain.com> or C<1.2.3.4>), or a
2188                                                  C<key=value,key=value> string.  Keys are a single letter:
2189                                                  
2190                                                     KEY MEANING
2191                                                     === =======
2192                                                     h   Connect to host
2193                                                     P   Port number to use for connection
2194                                                     S   Socket file to use for connection
2195                                                     u   User for login if not current user
2196                                                     p   Password to use when connecting
2197                                                     F   Only read default options from the given file
2198                                                  
2199                                                  If you omit any values in the sibling or uncle host, they are filled in with
2200                                                  defaults from the slave host, so you don't need to specify them in both places.
2201                                                  C<mk-slave-move> reads all normal MySQL option files, such as ~/.my.cnf, so
2202                                                  you may not need to specify username, password and other common options at all.
2203                                                  
2204                                                  =head1 EXIT STATUS
2205                                                  
2206                                                  Successful exit status is 0.  Any other value represents the exit status of
2207                                                  the Perl process itself.
2208                                                  
2209                                                  =head1 OPTIONS
2210                                                  
2211                                                  Specify one and only one of L<"--sibling-of-master">, L<"--slave-of-sibling">,
2212                                                  L<"--slave-of-uncle">, or L<"--detach">.
2213                                                  
2214                                                  =over
2215                                                  
2216                                                  =item --ask-pass
2217                                                  
2218                                                  Prompt for a password when connecting to MySQL.
2219                                                  
2220                                                  =item --charset
2221                                                  
2222                                                  short form: -A; type: string
2223                                                  
2224                                                  Default character set.  If the value is utf8, sets Perl's binmode on
2225                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
2226                                                  runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
2227                                                  binmode on STDOUT without the utf8 layer, and runs SET NAMES after
2228                                                  connecting to MySQL.
2229                                                  
2230                                                  =item --config
2231                                                  
2232                                                  type: Array
2233                                                  
2234                                                  Read this comma-separated list of config files; if specified, this must be the
2235                                                  first option on the command line.
2236                                                  
2237                                                  =item --defaults-file
2238                                                  
2239                                                  short form: -F; type: string
2240                                                  
2241                                                  Only read mysql options from the given file.  You must give an absolute
2242                                                  pathname.
2243                                                  
2244                                                  =item --detach
2245                                                  
2246                                                  Make this server forget that it is a slave.
2247                                                  
2248                                                  =item --help
2249                                                  
2250                                                  Show help and exit.
2251                                                  
2252                                                  =item --host
2253                                                  
2254                                                  short form: -h; type: string
2255                                                  
2256                                                  Connect to host.
2257                                                  
2258                                                  =item --password
2259                                                  
2260                                                  short form: -p; type: string
2261                                                  
2262                                                  Password to use when connecting.
2263                                                  
2264                                                  =item --pid
2265                                                  
2266                                                  type: string
2267                                                  
2268                                                  Create the given PID file.  The file contains the process ID of the script.
2269                                                  The PID file is removed when the script exits.  Before starting, the script
2270                                                  checks if the PID file already exists.  If it does not, then the script creates
2271                                                  and writes its own PID to it.  If it does, then the script checks the following:
2272                                                  if the file contains a PID and a process is running with that PID, then
2273                                                  the script dies; or, if there is no process running with that PID, then the
2274                                                  script overwrites the file with its own PID and starts; else, if the file
2275                                                  contains no PID, then the script dies.
2276                                                  
2277                                                  =item --port
2278                                                  
2279                                                  short form: -P; type: int
2280                                                  
2281                                                  Port number to use for connection.
2282                                                  
2283                                                  =item --set-vars
2284                                                  
2285                                                  type: string; default: wait_timeout=10000
2286                                                  
2287                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this
2288                                                  string will be appended to SET and executed.
2289                                                  
2290                                                  =item --sibling-of-master
2291                                                  
2292                                                  Make the server a slave of its grandparent, so it is a sibling of its master.
2293                                                  
2294                                                  The procedure is as follows:
2295                                                  
2296                                                   1. Connect to the server's master.
2297                                                   2. Stop the slave processes on the master.
2298                                                   3. Wait for the server to catch up to its master in replication.
2299                                                   4. Point the slave to the master's master.
2300                                                  
2301                                                  =item --slave-of-sibling
2302                                                  
2303                                                  Make the server a slave of one of its siblings.  Specify the sibling as a DSN.
2304                                                  
2305                                                  The procedure is as follows:
2306                                                  
2307                                                   1. Connect to the sibling and verify that it has the same master.
2308                                                   2. Stop the slave processes on the server and its sibling.
2309                                                   3. If one of the servers is behind the other, make it catch up.
2310                                                   4. Point the slave to its sibling.
2311                                                  
2312                                                  =item --slave-of-uncle
2313                                                  
2314                                                  Make the server a slave of one of its uncles (parent's siblings).  Specify the
2315                                                  uncle as a DSN.
2316                                                  
2317                                                  An "uncle" is a sibling of the server's master.  The procedure is as follows:
2318                                                  
2319                                                   1. Connect to the slave's master and its uncle, and verify that both have the
2320                                                      same master.  (Their common master is the slave's grandparent).
2321                                                   2. Stop the slave processes on the master and uncle.
2322                                                   3. If one of them is behind the other, make it catch up.
2323                                                   4. Point the slave to its uncle.
2324                                                  
2325                                                  =item --socket
2326                                                  
2327                                                  short form: -S; type: string
2328                                                  
2329                                                  Socket file to use for connection.
2330                                                  
2331                                                  =item --timeout
2332                                                  
2333                                                  type: time; default: 10m
2334                                                  
2335                                                  Timeout when waiting for replication to catch up.
2336                                                  
2337                                                  =item --user
2338                                                  
2339                                                  short form: -u; type: string
2340                                                  
2341                                                  User for login if not current user.
2342                                                  
2343                                                  =item --version
2344                                                  
2345                                                  Show version and exit.
2346                                                  
2347                                                  =back
2348                                                  
2349                                                  =head1 DOWNLOADING
2350                                                  
2351                                                  You can download Maatkit from Google Code at
2352                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
2353                                                  easily with a command like the following:
2354                                                  
2355                                                     wget http://www.maatkit.org/get/toolname
2356                                                     or
2357                                                     wget http://www.maatkit.org/trunk/toolname
2358                                                  
2359                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
2360                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
2361                                                  needed.  The first URL gets the latest released version of the tool, and the
2362                                                  second gets the latest trunk code from Subversion.
2363                                                  
2364                                                  =head1 ENVIRONMENT
2365                                                  
2366                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
2367                                                  the Maatkit tools:
2368                                                  
2369                                                     MKDEBUG=1 mk-....
2370                                                  
2371                                                  =head1 SYSTEM REQUIREMENTS
2372                                                  
2373                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
2374                                                  installed in any reasonably new version of Perl.
2375                                                  
2376                                                  =head1 BUGS
2377                                                  
2378                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-slave-move>.
2379                                                  
2380                                                  Please use Google Code Issues and Groups to report bugs or request support:
2381                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
2382                                                  discuss Maatkit.
2383                                                  
2384                                                  Please include the complete command-line used to reproduce the problem you are
2385                                                  seeing, the version of all MySQL servers involved, the complete output of the
2386                                                  tool when run with L<"--version">, and if possible, debugging output produced by
2387                                                  running with the C<MKDEBUG=1> environment variable.
2388                                                  
2389                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
2390                                                  
2391                                                  This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
2392                                                  Feedback and improvements are welcome.
2393                                                  
2394                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
2395                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
2396                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
2397                                                  
2398                                                  This program is free software; you can redistribute it and/or modify it under
2399                                                  the terms of the GNU General Public License as published by the Free Software
2400                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
2401                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
2402                                                  licenses.
2403                                                  
2404                                                  You should have received a copy of the GNU General Public License along with
2405                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
2406                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
2407                                                  
2408                                                  =head1 SEE ALSO
2409                                                  
2410                                                  See also L<mk-table-checksum>, L<mk-table-sync>, L<mk-slave-delay>.
2411                                                  
2412                                                  =head1 AUTHOR
2413                                                  
2414                                                  Baron Schwartz
2415                                                  
2416                                                  =head1 ABOUT MAATKIT
2417                                                  
2418                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
2419                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
2420                                                  code contributors.  Both are employed by Percona.  Financial support for
2421                                                  Maatkit development is primarily provided by Percona and its clients. 
2422                                                  
2423                                                  =head1 VERSION
2424                                                  
2425                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5425 $.
2426                                                  
2427                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
58    ***     50      0      2   unless $args{$arg}
64    ***     50      2      0   exists $args{'strict'} ? :
107   ***     50      0      2   unless open my $fh, '<', $file
127          100    576      2   unless $para =~ /^=head1 OPTIONS/
132          100      2      2   if $para =~ /^=over/
140   ***     50      0      2   unless $para
143          100     36      2   if (my($option) = $para =~ /^=item --(.*)/)
150          100     22     14   if ($para =~ /: /) { }
154   ***     50      0     40   unless $attributes{$attrib}
158          100     14      8   if ($attribs{'short form'})
174   ***     50      0     36   if $para =~ /^=item/
176   ***     50      0     36   if (my($base_option) = $option =~ /^\[no\](.*)/)
181          100     14     22   $attribs{'short form'} ? :
      ***     50      0     36   $attribs{'negatable'} ? :
      ***     50      0     36   $attribs{'cumulative'} ? :
             100     22     14   $attribs{'type'} ? :
             100      4     32   $attribs{'default'} ? :
      ***     50      0     36   $attribs{'group'} ? :
193   ***     50      0     52   unless $para
196          100      2     50   if ($para =~ /^=head1/)
200          100     36     14   if $para =~ /^=item --/
204   ***     50      0      2   unless @specs
215          100     36      2   if (ref $opt) { }
220   ***     50      0     36   if (not $long)
225   ***     50      0     36   if exists $$self{'opts'}{$long}
228   ***     50      0     36   if (length $long == 1)
233          100     14     22   if ($short) { }
234   ***     50      0     14   if exists $$self{'short_opts'}{$short}
243   ***     50      0     36   $$opt{'spec'} =~ /!/ ? :
244   ***     50      0     36   $$opt{'spec'} =~ /\+/ ? :
245   ***     50      0     36   $$opt{'desc'} =~ /required/ ? :
257   ***     50      0     36   if ($type and $type eq 'd' and not $$self{'dp'})
262          100      4     32   if $type and $type =~ /[HhAadzm]/
264          100      4     32   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
265   ***     50      4      0   defined $def ? :
269          100      2     34   if ($long eq 'config')
273   ***     50      0     36   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
286   ***     50      2      0   if ($opt =~ /mutually exclusive|one and only one/)
291   ***     50      2      0   if ($opt =~ /at least one|one and only one/)
296   ***     50      0      2   if ($opt =~ /default to/)
301   ***     50      0      2   if ($opt =~ /restricted to option groups/)
311   ***     50      0      2   unless $rule_ok
328   ***     50      0      8   unless exists $$self{'opts'}{$long}
352   ***      0      0      0   unless exists $$self{'opts'}{$long}
372   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50      3      0   exists $$self{'opts'}{$opt} ? :
377   ***     50      0      3   if ($$opt{'is_cumulative'}) { }
392   ***     50      0     30   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100      6     30   exists $$self{'defaults'}{$long} ? :
401   ***     50      0      2   if (@ARGV and $ARGV[0] eq '--config')
405   ***     50      2      0   if ($self->has('config'))
411   ***     50      8      0   if ($EVAL_ERROR)
412   ***     50      0      8   $self->got('config') ? :
427   ***     50      0      2   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
430   ***     50      0      2   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
431   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
437   ***     50      0      2   if (@ARGV and $$self{'strict'})
443   ***     50      0      2   if (@set > 1)
454   ***     50      0      2   if (@set == 0)
464          100      3     33   if ($$opt{'got'}) { }
      ***     50      0     33   elsif ($$opt{'is_required'}) { }
465   ***     50      0      3   if (exists $$self{'disables'}{$long})
472   ***     50      0      3   if (exists $$self{'allowed_groups'}{$long})
484   ***      0      0      0   if $restricted_opt eq $long
485   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
490   ***      0      0      0   if (@restricted_opts)
492   ***      0      0      0   if (@restricted_opts == 1) { }
521          100     14     22   unless $opt and $$opt{'type'}
524          100      2     20   if ($val and $$opt{'type'} eq 'm') { }
      ***     50      0     20   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0     20   elsif ($val and $$opt{'type'} eq 'z') { }
      ***     50      0     20   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100      2     18   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
527   ***     50      0      2   if (not $suffix)
533   ***     50      2      0   if ($suffix =~ /[smhd]/) { }
534   ***      0      0      0   $suffix eq 'h' ? :
      ***     50      2      0   $suffix eq 'm' ? :
      ***     50      0      2   $suffix eq 's' ? :
549   ***      0      0      0   if ($from_key)
560   ***      0      0      0   if (defined $num) { }
561   ***      0      0      0   if ($factor)
588          100     15     14   length $opt == 1 ? :
589   ***     50      0     29   unless $long and exists $$self{'opts'}{$long}
596   ***     50      0      8   length $opt == 1 ? :
597   ***     50      0      8   unless $long and exists $$self{'opts'}{$long}
604          100     16      2   length $opt == 1 ? :
605          100     16      2   defined $long ? :
610   ***      0      0      0   length $opt == 1 ? :
611   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
645   ***     50      0      2   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0      2   elsif (scalar @{$$self{'errors'};}) { }
646   ***      0      0      0   unless print $self->print_usage
650   ***      0      0      0   unless print $self->print_errors
659   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
668   ***      0      0      0   unless $$self{'got_opts'}
671   ***      0      0      0   $$_{'is_negatable'} ? :
675   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
691   ***      0      0      0   $group eq 'default' ? :
697   ***      0      0      0   $$opt{'is_negatable'} ? :
700   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
709   ***      0      0      0   if ($short) { }
718   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
722   ***      0      0      0   if ($$self{'dp'})
730   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
742   ***      0      0      0   if ref $_[0] eq 'OptionParser'
745   ***      0      0      0   unless print $prompt
753   ***      0      0      0   unless print "\n"
756   ***      0      0      0   if ($EVAL_ERROR)
778   ***     50      8      0   unless open my $fh, '<', $filename
786   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
789   ***      0      0      0   if ($line eq '--')
794   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
812   ***      0      0      0   unless open my $fh, '<', $file
816   ***      0      0      0   unless $para =~ /^=pod$/m
820   ***      0      0      0   unless $para =~ /$regex/
825   ***      0      0      0   unless close $fh
839   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
854   ***      0      0      0   defined $_ ? :
940          100      2     35   if (@_ > 2)
949          100      1     11   if (not $dsn)
961   ***     50     32      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
973          100     13     75   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
979          100     43     45   if (not defined $final_props{$key})
986   ***     50      0     32   unless exists $opts{$key}
989   ***     50      0     11   if (my $required = $self->prop('required'))
991   ***      0      0      0   unless $final_props{$key}
1000  ***     50      0      2   unless ref $o eq 'OptionParser'
1003         100     14      2   if $o->has($_)
1013  ***      0      0      0   unless ref $dsn
1014  ***      0      0      0   $_ eq 'p' ? :
1015  ***      0      0      0   if defined $$dsn{$_}
1028  ***      0      0      0   $opts{$key}{'copy'} ? :
1042  ***     50      0      9   if ($driver eq 'Pg') { }
1074  ***     50      0      9   $cxn_string =~ /charset=utf8/ ? :
1083  ***     50      0      9   if (not $have_dbi)
1102  ***     50      9      0   if ($cxn_string =~ /mysql/i)
1110  ***     50      0      9   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1115  ***      0      0      0   if ($charset eq 'utf8') { }
1116  ***      0      0      0   unless binmode STDOUT, ':utf8'
1120  ***      0      0      0   unless binmode STDOUT
1124         100      6      3   if ($self->prop('set-vars'))
1131  ***     50      0      9   if (not $dbh and $EVAL_ERROR)
1133  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1146  ***      0      0      0   if (not $tries)
1168  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1185  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1195  ***      0      0      0   unless $dsn_1
1196  ***      0      0      0   unless $dsn_2
1200  ***      0      0      0   if ($args{'overwrite'}) { }
1201  ***      0      0      0   defined $$dsn_1{$key} ? :
1204  ***      0      0      0   defined $$dsn_2{$key} ? :
1213  ***      0      0      0   defined $_ ? :
1257  ***      0      0      0   if ($EVAL_ERROR)
1258  ***      0      0      0   unless print STDERR 'Cannot connect to ', $dp->as_string($dsn), "\n"
1268  ***      0      0      0   if (not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++)
1273  ***      0      0      0   if ($$args{'skip_callback'})
1281  ***      0      0      0   if (not defined $$args{'recurse'} or $level < $$args{'recurse'})
1283  ***      0      0      0   unless not $$_{'master_id'}
1300  ***      0      0      0   if ($method) { }
1305  ***      0      0      0   if (($$dsn{'P'} || 3306) != 3306)
1319  ***      0      0      0   if @slaves
1337  ***      0      0      0   if ($host eq 'localhost')
1354  ***      0      0      0   if (@slaves)
1359  ***      0      0      0   $hash{'user'} ? :
      ***      0      0      0   $hash{'password'} ? :
1379  ***      0      0      0   if (not $proc)
1396  ***      0      0      0   unless my $master_status = $self->get_master_status($master)
1398  ***      0      0      0   unless my $slave_status = $self->get_slave_status($slave)
1400  ***      0      0      0   unless my(@connected) = $self->get_connected_slaves($master)
1404  ***      0      0      0   if ($port != $$slave_status{'master_port'})
1409  ***      0      0      0   if (not grep {$$slave_status{'master_user'} eq $$_{'user'};} @connected)
1414  ***      0      0      0   if (($$slave_status{'slave_io_state'} || '') eq 'Waiting for master to send event')
1421  ***      0      0      0   if ($master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1)
1434  ***     50      0      4   unless my $master = $self->get_slave_status($dbh)
1441  ***     50     14      0   if (not $$self{'not_a_slave'}{$dbh})
1448  ***     50     14      0   if ($ss and %$ss)
1460  ***     50      5      0   if (not $$self{'not_a_master'}{$dbh})
1467  ***     50      5      0   if ($ms and %$ms)
1469  ***     50      5      0   if ($$ms{'file'} and $$ms{'position'})
1482  ***     50      0      1   unless defined $time
1486  ***     50      1      0   if ($ms) { }
1490  ***     50      1      0   defined $result ? :
1492  ***     50      0      1   if ($stat eq 'NULL' or $stat < 0 and not $timeoutok)
1512  ***     50      1      0   if ($pos) { }
1536  ***     50      1      0   if ($self->pos_cmp($slave_pos, $master_pos) < 0)
1542  ***     50      0      1   if ($EVAL_ERROR)
1544  ***      0      0      0   if ($EVAL_ERROR =~ /MASTER_POS_WAIT returned NULL/) { }
1546  ***      0      0      0   if (not $self->slave_is_running($slave_status)) { }
1551  ***      0      0      0   if ($self->pos_cmp($slave_pos, $master_pos) != 0)
1575  ***     50      0      1   if ($self->pos_cmp($s1_pos, $s2_pos) < 0) { }
      ***     50      0      1   elsif ($self->pos_cmp($s2_pos, $s1_pos) < 0) { }
1587  ***     50      0      1   if ($self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0)
1610  ***     50      0      1   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
1614  ***     50      0      1   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
1619  ***     50      0      1   if ($self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn))
1633  ***     50      1      0   if (not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0) { }
1648  ***     50      0      1   if ($self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0)
1659  ***     50      0      1   if ($self->short_host($slave_dsn) eq $self->short_host($sib_dsn))
1663  ***     50      0      1   unless my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
1667  ***     50      0      1   unless my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
1669  ***     50      0      1   if ($self->short_host($master_dsn1) ne $self->short_host($master_dsn2))
1672  ***     50      0      1   unless my $sib_master_stat = $self->get_master_status($sib_dbh)
1674  ***     50      0      1   unless $self->has_slave_updates($sib_dbh)
1686  ***     50      0      1   if ($self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
1698  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($unc_dsn))
1702  ***      0      0      0   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
1706  ***      0      0      0   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
1709  ***      0      0      0   unless my $unc_master_dsn = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
1712  ***      0      0      0   if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn))
1716  ***      0      0      0   unless my $unc_master_stat = $self->get_master_status($unc_dbh)
1718  ***      0      0      0   unless $self->has_slave_updates($unc_dbh)
1726  ***      0      0      0   if ($self->pos_cmp($self->repl_posn($slave_status), $self->repl_posn($master_status)) != 0)
1740  ***      0      0      0   if ($self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
1751  ***      0      0      0   unless my $stat = $self->get_slave_status($dbh)
1773         100      4     10   if (exists $$status{'file'} and exists $$status{'position'}) { }
1801         100      3      7   if ($$dsn{'master_host'}) { }
1809  ***     50      0     10   ($port || 3306) == 3306 ? :
1820  ***      0      0      0   defined $_ ? :
1849  ***      0      0      0   unless $args{$arg}
1852  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
1868  ***      0      0      0   unless defined(my $pid = fork)
1869  ***      0      0      0   if ($pid)
1876  ***      0      0      0   unless POSIX::setsid()
1877  ***      0      0      0   unless chdir '/'
1883  ***      0      0      0   if (-t STDIN)
1885  ***      0      0      0   unless open STDIN, '/dev/null'
1889  ***      0      0      0   if ($$self{'log_file'}) { }
1891  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
1895  ***      0      0      0   unless open STDERR, '>&STDOUT'
1899  ***      0      0      0   if (-t STDOUT)
1901  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
1904  ***      0      0      0   if (-t STDERR)
1906  ***      0      0      0   unless open STDERR, '>', '/dev/null'
1917  ***      0      0      0   $self ? :
1919  ***      0      0      0   if ($PID_file and -f $PID_file) { }
1922  ***      0      0      0   if $EVAL_ERROR
1924  ***      0      0      0   if ($pid) { }
1926  ***      0      0      0   if ($pid_is_alive) { }
1948  ***      0      0      0   if (exists $$self{'child'})
1960  ***      0      0      0   if (not $PID_file)
1967  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
1969  ***      0      0      0   unless print $PID_FH $PID
1971  ***      0      0      0   unless close $PID_FH
1980  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
1981  ***      0      0      0   unless unlink $$self{'PID_file'}
1993  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
1999  ***      0      0      0   defined $_ ? :
2053  ***     50      0      2   if (not @dsns) { }
      ***     50      0      2   elsif (@dsns < 2 and not $o->get('sibling-of-master') || $o->get('detach')) { }
2066  ***     50      0      2   if ($o->get('pid'))
2080  ***     50      0      2   if ($o->get('ask-pass'))
2091         100      1      1   if ($o->get('sibling-of-master')) { }
      ***     50      1      0   elsif ($o->get('slave-of-sibling')) { }
      ***      0      0      0   elsif ($o->get('slave-of-uncle')) { }
      ***      0      0      0   elsif ($o->get('detach')) { }
2129  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
257   ***     66     14     22      0   $type and $type eq 'd'
      ***     33     36      0      0   $type and $type eq 'd' and not $$self{'dp'}
262          100     14     18      4   $type and $type =~ /[HhAadzm]/
401   ***     33      0      2      0   @ARGV and $ARGV[0] eq '--config'
430   ***     33      0      2      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
437   ***     33      0      2      0   @ARGV and $$self{'strict'}
521   ***     66      0     14     22   $opt and $$opt{'type'}
524          100     15      5      2   $val and $$opt{'type'} eq 'm'
      ***     66     15      5      0   $val and $$opt{'type'} eq 'd'
      ***     66     15      5      0   $val and $$opt{'type'} eq 'z'
      ***     66     15      5      0   defined $val and $$opt{'type'} eq 'h'
      ***     66     15      3      0   defined $val and $$opt{'type'} eq 'a'
589   ***     33      0      0     29   $long and exists $$self{'opts'}{$long}
597   ***     33      0      0      8   $long and exists $$self{'opts'}{$long}
611   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
700   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
794   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
973          100     32     43     13   not defined $final_props{$key} and defined $$prev{$key}
      ***     66     75      0     13   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1095  ***     66      9      0      9   not $dbh and $tries--
1131  ***     33      9      0      0   not $dbh and $EVAL_ERROR
1268  ***      0      0      0      0   defined $master_thinks_i_am and $master_thinks_i_am != $id
1448  ***     33      0      0     14   $ss and %$ss
1467  ***     33      0      0      5   $ms and %$ms
1469  ***     33      0      0      5   $$ms{'file'} and $$ms{'position'}
1492  ***     33      1      0      0   $stat < 0 and not $timeoutok
1633  ***     33      0      0      1   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status)
      ***     33      0      0      1   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0
1768  ***     33      0      0      1   $value && $value =~ /^(1|ON)$/
1773  ***     66     10      0      4   exists $$status{'file'} and exists $$status{'position'}
1919  ***      0      0      0      0   $PID_file and -f $PID_file
1980  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
2053  ***     66      1      1      0   @dsns < 2 and not $o->get('sibling-of-master') || $o->get('detach')

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
42    ***     50      0      1   $ENV{'MKDEBUG'} || 0
61    ***     50      2      0   $program_name ||= $PROGRAM_NAME
62    ***     50      2      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
64    ***     50      2      0   $args{'prompt'} || '<options>'
      ***     50      2      0   $args{'dp'} || undef
106   ***     50      0      2   $file ||= '/home/daniel/dev/maatkit/mk-slave-move/mk-slave-move'
247   ***     50     36      0   $$opt{'group'} ||= 'default'
529   ***      0      0      0   $s || 's'
538   ***     50      0      2   $prefix || ''
566   ***      0      0      0   $pre || ''
573   ***      0      0      0   $val || ''
576   ***     50      2      0   $val || ''
634   ***      0      0      0   $$self{'description'} || ''
702   ***      0      0      0   $s ||= 's'
728   ***      0      0      0   $$opt{'type'} || ''
883   ***     50      0      1   $ENV{'MKDEBUG'} || 0
954          100      6      5   $prev ||= {}
955          100      1     10   $defaults ||= {}
1028  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1041  ***     50      0      9   $self->prop('dbidriver') || ''
1045  ***      0      0      0   $$info{'D'} || ''
1051  ***     50      0      9   $$info{'D'} || ''
1064  ***     50      3      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1065  ***     50      0      3   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1066  ***     50      3      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1067  ***     50      3      0   $$dsn{'u'} ||= $user
1068  ***     50      0      3   $$dsn{'D'} ||= $db
1073  ***     50      9      0   $opts ||= {}
1168  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1184  ***      0      0      0   $level ||= 0
1185  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1239  ***     50      0      1   $ENV{'MKDEBUG'} || 0
1247  ***      0      0      0   $level ||= 0
1305  ***      0      0      0   $$dsn{'P'} || 3306
1414  ***      0      0      0   $$slave_status{'slave_io_state'} || ''
1485  ***     50      1      0   $ms ||= $self->get_master_status($master)
1760  ***     50      4      0   $$slave_status{'slave_sql_running'} || 'No'
1809  ***     50     10      0   $host || '[default]'
      ***     50     10      0   $port || 3306
1844  ***     50      0      1   $ENV{'MKDEBUG'} || 0
2024  ***     50      0      1   $ENV{'MKDEBUG'} || 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
62    ***     33      2      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***     33      2      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
524   ***     33      0      0     20   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***     66      2      0     18   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1253  ***      0      0      0      0   $$args{'dbh'} || $dp->get_dbh($dp->get_cxn_params($dsn), {'AutoCommit', 1})
1268  ***      0      0      0      0   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id
      ***      0      0      0      0   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++
1281  ***      0      0      0      0   not defined $$args{'recurse'} or $level < $$args{'recurse'}
1421  ***      0      0      0      0   $master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1
1442  ***     66     10      4      0   $$self{'sths'}{$dbh}{'SLAVE_STATUS'} ||= $dbh->prepare('SHOW SLAVE STATUS')
1461  ***     66      3      2      0   $$self{'sths'}{$dbh}{'MASTER_STATUS'} ||= $dbh->prepare('SHOW MASTER STATUS')
1492  ***     33      0      0      1   $stat eq 'NULL' or $stat < 0 and not $timeoutok
1504  ***     66      4      4      0   $$self{'sths'}{$dbh}{'STOP_SLAVE'} ||= $dbh->prepare('STOP SLAVE')
1519  ***      0      0      0      0   $$self{'sths'}{$dbh}{'START_SLAVE'} ||= $dbh->prepare('START SLAVE')
1587  ***     33      0      0      1   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status)
      ***     33      0      0      1   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0
1648  ***     33      0      0      1   $self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0
1686  ***     33      0      0      1   $self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0
1740  ***      0      0      0      0   $self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0
1993  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
2053  ***     33      1      0      0   $o->get('sibling-of-master') || $o->get('detach')
2083  ***      0      0      0      0   $$_{'p'} ||= $pass


Covered Subroutines
-------------------

Subroutine                  Count Location                                                 
--------------------------- ----- ---------------------------------------------------------
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1228
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1229
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1233
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1234
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1235
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1239
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1838
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1839
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1841
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1842
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1844
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:2021
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:2022
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:2024
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:23  
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:24  
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:35  
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:36  
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:38  
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:39  
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:40  
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:42  
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:871 
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:872 
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:873 
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:874 
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:883 
__ANON__                        3 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:425 
_get_participants               2 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:325 
_parse_specs                    2 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:211 
_pod_to_specs                   2 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:105 
_read_config_file               8 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:777 
_set_option                     3 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:371 
_validate_type                 36 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:520 
catchup_to_master               1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1527
catchup_to_same_pos             1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1568
change_master_to                2 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1597
fill_in_dsn                     3 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1060
get                            29 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:587 
get_cxn_params                  9 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1038
get_dbh                         9 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1072
get_defaults_files              2 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:100 
get_master_dsn                  4 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1433
get_master_status               5 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1459
get_opts                        2 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:388 
get_slave_status               14 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1440
get_specs                       2 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:93  
got                             8 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:595 
has                            18 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:603 
has_slave_updates               1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1764
main                            2 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:2027
make_sibling_of_master          1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1608
make_slave_of_sibling           1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1656
new                             2 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1242
new                             2 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:56  
new                             3 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:886 
parse                          12 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:948 
parse_options                   2 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:999 
pos_cmp                         7 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1794
pos_to_string                  14 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1813
prop                           37 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:939 
repl_posn                      14 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1772
short_host                     10 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1799
slave_is_running                4 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1759
start_slave                     1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1511
stop_slave                      8 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1503
usage_or_errors                 2 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:644 
wait_for_master                 1 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1480

Uncovered Subroutines
---------------------

Subroutine                  Count Location                                                 
--------------------------- ----- ---------------------------------------------------------
DESTROY                         0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1992
_d                              0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1212
_d                              0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1819
_d                              0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1998
_d                              0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:2128
_d                              0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:853 
_find_slaves_by_hosts           0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1347
_find_slaves_by_processlist     0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1327
_make_PID_file                  0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1957
_remove_PID_file                0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1979
as_string                       0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1012
check_PID_file                  0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1916
clone                           0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:830 
copy                            0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1194
daemonize                       0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1865
descr                           0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:633 
detach_slave                    0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1749
disconnect                      0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1177
errors                          0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:623 
find_slave_hosts                0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1297
get_connected_slaves            0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1374
get_defaults                    0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:361 
get_groups                      0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:366 
get_hostname                    0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1167
get_slave_lag                   0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1788
is_master_of                    0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1395
make_PID_file                   0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1947
make_slave_of_uncle             0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1695
new                             0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1847
opts                            0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:337 
print_active_handles            0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1183
print_errors                    0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:657 
print_usage                     0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:667 
prompt                          0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:628 
prompt_noecho                   0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:742 
read_para_after                 0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:811 
recurse_to_slaves               0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1246
save_error                      0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:618 
set                             0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:609 
set_defaults                    0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:349 
short_opts                      0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:343 
usage                           0 /home/daniel/dev/maatkit/mk-slave-move/mk-slave-move:1021


mk-slave-move.t

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     BEGIN {
4     ***      1     50     33      1            37      die "The MAATKIT_TRUNK environment variable is not set.  See http://code.google.com/p/maatkit/wiki/Testing"
5                                                           unless $ENV{MAATKIT_TRUNK} && -d $ENV{MAATKIT_TRUNK};
6              1                                  8      unshift @INC, "$ENV{MAATKIT_TRUNK}/common";
7                                                     };
8                                                     
9              1                    1            12   use strict;
               1                                  3   
               1                                  6   
10             1                    1             5   use warnings FATAL => 'all';
               1                                  3   
               1                                  6   
11             1                    1            13   use English qw(-no_match_vars);
               1                                  3   
               1                                 10   
12             1                    1            15   use Test::More;
               1                                  5   
               1                                 16   
13                                                    
14             1                    1            19   use MaatkitTest;
               1                                  4   
               1                                 16   
15             1                    1            15   use Sandbox;
               1                                  3   
               1                                 15   
16             1                                 22   require "$trunk/mk-slave-move/mk-slave-move";
17                                                    
18             1                                 14   my $dp = new DSNParser();
19             1                                 10   my $sb = new Sandbox(basedir => '/tmp', DSNParser => $dp);
20             1                                 62   my $master_dbh  = $sb->get_dbh_for('master');
21             1                                 24   my $slave_1_dbh = $sb->get_dbh_for('slave1');
22                                                    
23                                                    # Reset master and slave relay logs so the second slave
24                                                    # starts faster (i.e. so it doesn't have to replay the
25                                                    # masters logs which is stuff from previous tests that we
26                                                    # don't care about).
27    ***      1     50     33               300302   diag(`$trunk/sandbox/mk-test-env reset`) if $master_dbh && $slave_1_dbh;
28                                                    
29                                                    # Create slave2 as slave of slave1.
30             1                               9027   diag(`/tmp/12347/stop >/dev/null 2>&1`);
31             1                              16589   diag(`rm -rf /tmp/12347 >/dev/null 2>&1`);
32             1                             3972901   diag(`$trunk/sandbox/start-sandbox slave 12347 12346 >/dev/null`);
33             1                                129   my $slave_2_dbh = $sb->get_dbh_for('slave2');
34                                                    
35    ***      1     50                          26   if ( !$master_dbh ) {
      ***            50                               
      ***            50                               
36    ***      0                                  0      plan skip_all => 'Cannot connect to sandbox master';
37                                                    }
38                                                    elsif ( !$slave_1_dbh ) {
39    ***      0                                  0      plan skip_all => 'Cannot connect to sandbox slave';
40                                                    }
41                                                    elsif ( !$slave_2_dbh ) {
42    ***      0                                  0      plan skip_all => 'Cannot connect to second sandbox slave';
43                                                    }
44                                                    else {
45             1                                  9      plan tests => 7;
46                                                    }
47                                                    
48             1                                270   my $output = '';
49                                                    
50                                                    # #############################################################################
51                                                    # Sanity tests.
52                                                    # #############################################################################
53             1                             141560   $output = `$trunk/mk-slave-move/mk-slave-move --help`;
54             1                                 60   like($output, qr/Prompt for a password/, 'It compiles');
55                                                    
56                                                    # #############################################################################
57                                                    # Test the moves.
58                                                    # #############################################################################
59                                                    
60                                                    # Double-check that we're setup correctly.
61             1                                 59   my $row = $slave_2_dbh->selectall_arrayref('SHOW SLAVE STATUS', {Slice => {}});
62             1                                 21   is(
63                                                       $row->[0]->{Master_Port},
64                                                       '12346',
65                                                       'slave2 is slave of slave1 before move'
66                                                    );
67                                                    
68                                                    # Move slave2 from being slave of slave1 to slave of master.
69             1                                692   mk_slave_move::main('--sibling-of-master', 'h=127.1,P=12347,u=msandbox,p=msandbox');
70             1                                 10   $row = $slave_2_dbh->selectall_arrayref('SHOW SLAVE STATUS', {Slice => {}});
71             1                                 29   ok(
72                                                       $row->[0]->{Master_Port} eq '12345',
73                                                       'slave2 is slave of master after --sibling-of-master'
74                                                    );
75                                                    
76                                                    # Move slave2 back to being slave of slave1.
77             1                                952   mk_slave_move::main('--slave-of-sibling', 'h=127.1,u=msandbox,p=msandbox', qw(--port 12347), 'h=127.1,P=12346,u=msandbox,p=msandbox');
78             1                                 11   $row = $slave_2_dbh->selectall_arrayref('SHOW SLAVE STATUS', {Slice => {}});
79             1                                 33   ok(
80                                                       $row->[0]->{Master_Port} eq '12346',
81                                                       'slave2 is slave of slave1 again after --slave-of-sibling'
82                                                    );
83                                                    
84                                                    # #########################################################################
85                                                    # Issue 391: Add --pid option to all scripts
86                                                    # #########################################################################
87             1                               7776   `touch /tmp/mk-script.pid`;
88             1                             370048   $output = `$trunk/mk-slave-move/mk-slave-move --sibling-of-master h=127.1,P=12347,u=msandbox,p=msandbox --pid /tmp/mk-script.pid 2>&1`;
89             1                                104   like(
90                                                       $output,
91                                                       qr{PID file /tmp/mk-script.pid already exists},
92                                                       'Dies if PID file already exists (issue 391)'
93                                                    );
94             1                               7375   `rm -rf /tmp/mk-script.pid`;
95                                                    
96                                                    # Stop and remove slave2.
97             1                             2046436   diag(`/tmp/12347/stop >/dev/null`);
98             1                              58825   diag(`rm -rf /tmp/12347 >/dev/null`);
99                                                    
100                                                   # Make sure the sandbox slave is still running.
101            1                                216   eval { $slave_1_dbh->do('start slave'); };
               1                                628   
102            1                             1000262   sleep 1;
103            1                                 10   is_deeply(
104                                                      $slave_1_dbh->selectrow_hashref('show slave status')->{Slave_IO_Running},
105                                                      'Yes',
106                                                      'Sandbox slave IO running'
107                                                   );
108            1                                  7   is_deeply(
109                                                      $slave_1_dbh->selectrow_hashref('show slave status')->{Slave_SQL_Running},
110                                                      'Yes',
111                                                      'Sandbox slave SQL running'
112                                                   );
113                                                   
114            1                                  7   exit;


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
4     ***     50      0      1   unless $ENV{'MAATKIT_TRUNK'} and -d $ENV{'MAATKIT_TRUNK'}
27    ***     50      1      0   if $master_dbh and $slave_1_dbh
35    ***     50      0      1   if (not $master_dbh) { }
      ***     50      0      1   elsif (not $slave_1_dbh) { }
      ***     50      0      1   elsif (not $slave_2_dbh) { }


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
4     ***     33      0      0      1   $ENV{'MAATKIT_TRUNK'} and -d $ENV{'MAATKIT_TRUNK'}
27    ***     33      0      0      1   $master_dbh and $slave_1_dbh


Covered Subroutines
-------------------

Subroutine Count Location          
---------- ----- ------------------
BEGIN          1 mk-slave-move.t:10
BEGIN          1 mk-slave-move.t:11
BEGIN          1 mk-slave-move.t:12
BEGIN          1 mk-slave-move.t:14
BEGIN          1 mk-slave-move.t:15
BEGIN          1 mk-slave-move.t:4 
BEGIN          1 mk-slave-move.t:9 


