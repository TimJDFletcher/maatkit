---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...-slave-find/mk-slave-find   12.3    2.8    6.3   27.9    n/a    0.0    9.9
mk-slave-find.t                93.8   50.0   33.3  100.0    n/a  100.0   86.4
Total                          15.6    3.5    6.6   32.2    n/a  100.0   12.3
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:31:32 2010
Finish:       Thu Jan 28 22:31:32 2010

Run:          ./mk-slave-find.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:31:34 2010
Finish:       Thu Jan 28 22:31:42 2010

/home/daniel/dev/maatkit/mk-slave-find/mk-slave-find

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This is mk-slave-find, a program to discover replication slaves and execute
4                                                     # commands on them.
5                                                     #
6                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
7                                                     # Feedback and improvements are welcome.
8                                                     #
9                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
10                                                    # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
11                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
12                                                    #
13                                                    # This program is free software; you can redistribute it and/or modify it under
14                                                    # the terms of the GNU General Public License as published by the Free Software
15                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
16                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
17                                                    # licenses.
18                                                    #
19                                                    # You should have received a copy of the GNU General Public License along with
20                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
21                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
22                                                    
23             1                    1             8   use strict;
               1                                  3   
               1                                 10   
24             1                    1             8   use warnings FATAL => 'all';
               1                                  3   
               1                                  8   
25                                                    
26                                                    our $VERSION = '@VERSION@';
27                                                    our $DISTRIB = '@DISTRIB@';
28                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5425 $ =~ m/(\d+)/g, 0));
29                                                    
30                                                    # ###########################################################################
31                                                    # OptionParser package 5266
32                                                    # ###########################################################################
33                                                    package OptionParser;
34                                                    
35             1                    1             6   use strict;
               1                                 21   
               1                                  6   
36             1                    1             7   use warnings FATAL => 'all';
               1                                  4   
               1                                 10   
37                                                    
38             1                    1            11   use Getopt::Long;
               1                                  5   
               1                                  7   
39             1                    1             8   use List::Util qw(max);
               1                                  3   
               1                                 12   
40             1                    1             7   use English qw(-no_match_vars);
               1                                  3   
               1                                  6   
41                                                    
42    ***      1            50      1             8   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 19   
43                                                    
44                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
45                                                    
46                                                    my %attributes = (
47                                                       'type'       => 1,
48                                                       'short form' => 1,
49                                                       'group'      => 1,
50                                                       'default'    => 1,
51                                                       'cumulative' => 1,
52                                                       'negatable'  => 1,
53                                                    );
54                                                    
55                                                    sub new {
56    ***      0                    0             0      my ( $class, %args ) = @_;
57    ***      0                                  0      foreach my $arg ( qw(description) ) {
58    ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
59                                                       }
60    ***      0                                  0      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
61    ***      0             0                    0      $program_name ||= $PROGRAM_NAME;
62    ***      0             0                    0      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                    0                        
      ***                    0                        
63                                                    
64    ***      0      0      0                    0      my $self = {
      ***                    0                        
65                                                          description    => $args{description},
66                                                          prompt         => $args{prompt} || '<options>',
67                                                          strict         => (exists $args{strict} ? $args{strict} : 1),
68                                                          dp             => $args{dp}     || undef,
69                                                          program_name   => $program_name,
70                                                          opts           => {},
71                                                          got_opts       => 0,
72                                                          short_opts     => {},
73                                                          defaults       => {},
74                                                          groups         => {},
75                                                          allowed_groups => {},
76                                                          errors         => [],
77                                                          rules          => [],  # desc of rules for --help
78                                                          mutex          => [],  # rule: opts are mutually exclusive
79                                                          atleast1       => [],  # rule: at least one opt is required
80                                                          disables       => {},  # rule: opt disables other opts 
81                                                          defaults_to    => {},  # rule: opt defaults to value of other opt
82                                                          default_files  => [
83                                                             "/etc/maatkit/maatkit.conf",
84                                                             "/etc/maatkit/$program_name.conf",
85                                                             "$home/.maatkit.conf",
86                                                             "$home/.$program_name.conf",
87                                                          ],
88                                                       };
89    ***      0                                  0      return bless $self, $class;
90                                                    }
91                                                    
92                                                    sub get_specs {
93    ***      0                    0             0      my ( $self, $file ) = @_;
94    ***      0                                  0      my @specs = $self->_pod_to_specs($file);
95    ***      0                                  0      $self->_parse_specs(@specs);
96    ***      0                                  0      return;
97                                                    }
98                                                    
99                                                    sub get_defaults_files {
100   ***      0                    0             0      my ( $self ) = @_;
101   ***      0                                  0      return @{$self->{default_files}};
      ***      0                                  0   
102                                                   }
103                                                   
104                                                   sub _pod_to_specs {
105   ***      0                    0             0      my ( $self, $file ) = @_;
106   ***      0             0                    0      $file ||= __FILE__;
107   ***      0      0                           0      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
108                                                   
109   ***      0                                  0      my %types = (
110                                                         string => 's', # standard Getopt type
111                                                         'int'  => 'i', # standard Getopt type
112                                                         float  => 'f', # standard Getopt type
113                                                         Hash   => 'H', # hash, formed from a comma-separated list
114                                                         hash   => 'h', # hash as above, but only if a value is given
115                                                         Array  => 'A', # array, similar to Hash
116                                                         array  => 'a', # array, similar to hash
117                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
118                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
119                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
120                                                      );
121   ***      0                                  0      my @specs = ();
122   ***      0                                  0      my @rules = ();
123   ***      0                                  0      my $para;
124                                                   
125   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
126   ***      0                                  0      while ( $para = <$fh> ) {
127   ***      0      0                           0         next unless $para =~ m/^=head1 OPTIONS/;
128   ***      0                                  0         last;
129                                                      }
130                                                   
131   ***      0                                  0      while ( $para = <$fh> ) {
132   ***      0      0                           0         last if $para =~ m/^=over/;
133   ***      0                                  0         chomp $para;
134   ***      0                                  0         $para =~ s/\s+/ /g;
135   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
136   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
137   ***      0                                  0         push @rules, $para;
138                                                      }
139                                                   
140   ***      0      0                           0      die 'POD has no OPTIONS section' unless $para;
141                                                   
142   ***      0                                  0      do {
143   ***      0      0                           0         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
144   ***      0                                  0            chomp $para;
145   ***      0                                  0            MKDEBUG && _d($para);
146   ***      0                                  0            my %attribs;
147                                                   
148   ***      0                                  0            $para = <$fh>; # read next paragraph, possibly attributes
149                                                   
150   ***      0      0                           0            if ( $para =~ m/: / ) { # attributes
151   ***      0                                  0               $para =~ s/\s+\Z//g;
152   ***      0                                  0               %attribs = map {
153   ***      0                                  0                     my ( $attrib, $val) = split(/: /, $_);
154   ***      0      0                           0                     die "Unrecognized attribute for --$option: $attrib"
155                                                                        unless $attributes{$attrib};
156   ***      0                                  0                     ($attrib, $val);
157                                                                  } split(/; /, $para);
158   ***      0      0                           0               if ( $attribs{'short form'} ) {
159   ***      0                                  0                  $attribs{'short form'} =~ s/-//;
160                                                               }
161   ***      0                                  0               $para = <$fh>; # read next paragraph, probably short help desc
162                                                            }
163                                                            else {
164   ***      0                                  0               MKDEBUG && _d('Option has no attributes');
165                                                            }
166                                                   
167   ***      0                                  0            $para =~ s/\s+\Z//g;
168   ***      0                                  0            $para =~ s/\s+/ /g;
169   ***      0                                  0            $para =~ s/$POD_link_re/$1/go;
170                                                   
171   ***      0                                  0            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
172   ***      0                                  0            MKDEBUG && _d('Short help:', $para);
173                                                   
174   ***      0      0                           0            die "No description after option spec $option" if $para =~ m/^=item/;
175                                                   
176   ***      0      0                           0            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
177   ***      0                                  0               $option = $base_option;
178   ***      0                                  0               $attribs{'negatable'} = 1;
179                                                            }
180                                                   
181   ***      0      0                           0            push @specs, {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
182                                                               spec  => $option
183                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
184                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
185                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
186                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
187                                                               desc  => $para
188                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
189                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
190                                                            };
191                                                         }
192   ***      0                                  0         while ( $para = <$fh> ) {
193   ***      0      0                           0            last unless $para;
194                                                   
195                                                   
196   ***      0      0                           0            if ( $para =~ m/^=head1/ ) {
197   ***      0                                  0               $para = undef; # Can't 'last' out of a do {} block.
198   ***      0                                  0               last;
199                                                            }
200   ***      0      0                           0            last if $para =~ m/^=item --/;
201                                                         }
202                                                      } while ( $para );
203                                                   
204   ***      0      0                           0      die 'No valid specs in POD OPTIONS' unless @specs;
205                                                   
206   ***      0                                  0      close $fh;
207   ***      0                                  0      return @specs, @rules;
208                                                   }
209                                                   
210                                                   sub _parse_specs {
211   ***      0                    0             0      my ( $self, @specs ) = @_;
212   ***      0                                  0      my %disables; # special rule that requires deferred checking
213                                                   
214   ***      0                                  0      foreach my $opt ( @specs ) {
215   ***      0      0                           0         if ( ref $opt ) { # It's an option spec, not a rule.
216                                                            MKDEBUG && _d('Parsing opt spec:',
217   ***      0                                  0               map { ($_, '=>', $opt->{$_}) } keys %$opt);
218                                                   
219   ***      0                                  0            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
220   ***      0      0                           0            if ( !$long ) {
221   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
222                                                            }
223   ***      0                                  0            $opt->{long} = $long;
224                                                   
225   ***      0      0                           0            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
226   ***      0                                  0            $self->{opts}->{$long} = $opt;
227                                                   
228   ***      0      0                           0            if ( length $long == 1 ) {
229   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
230   ***      0                                  0               $self->{short_opts}->{$long} = $long;
231                                                            }
232                                                   
233   ***      0      0                           0            if ( $short ) {
234   ***      0      0                           0               die "Duplicate short option -$short"
235                                                                  if exists $self->{short_opts}->{$short};
236   ***      0                                  0               $self->{short_opts}->{$short} = $long;
237   ***      0                                  0               $opt->{short} = $short;
238                                                            }
239                                                            else {
240   ***      0                                  0               $opt->{short} = undef;
241                                                            }
242                                                   
243   ***      0      0                           0            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
244   ***      0      0                           0            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
245   ***      0      0                           0            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
246                                                   
247   ***      0             0                    0            $opt->{group} ||= 'default';
248   ***      0                                  0            $self->{groups}->{ $opt->{group} }->{$long} = 1;
249                                                   
250   ***      0                                  0            $opt->{value} = undef;
251   ***      0                                  0            $opt->{got}   = 0;
252                                                   
253   ***      0                                  0            my ( $type ) = $opt->{spec} =~ m/=(.)/;
254   ***      0                                  0            $opt->{type} = $type;
255   ***      0                                  0            MKDEBUG && _d($long, 'type:', $type);
256                                                   
257   ***      0      0      0                    0            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                    0                        
258   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
259                                                                  . "was given when this OptionParser object was created";
260                                                            }
261                                                   
262   ***      0      0      0                    0            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
263                                                   
264   ***      0      0                           0            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
265   ***      0      0                           0               $self->{defaults}->{$long} = defined $def ? $def : 1;
266   ***      0                                  0               MKDEBUG && _d($long, 'default:', $def);
267                                                            }
268                                                   
269   ***      0      0                           0            if ( $long eq 'config' ) {
270   ***      0                                  0               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
271                                                            }
272                                                   
273   ***      0      0                           0            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
274   ***      0                                  0               $disables{$long} = $dis;
275   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
276                                                            }
277                                                   
278   ***      0                                  0            $self->{opts}->{$long} = $opt;
279                                                         }
280                                                         else { # It's an option rule, not a spec.
281   ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
282   ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
283   ***      0                                  0            my @participants = $self->_get_participants($opt);
284   ***      0                                  0            my $rule_ok = 0;
285                                                   
286   ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
287   ***      0                                  0               $rule_ok = 1;
288   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
289   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
290                                                            }
291   ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
292   ***      0                                  0               $rule_ok = 1;
293   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
294   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
295                                                            }
296   ***      0      0                           0            if ( $opt =~ m/default to/ ) {
297   ***      0                                  0               $rule_ok = 1;
298   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
299   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
300                                                            }
301   ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
302   ***      0                                  0               $rule_ok = 1;
303   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
304   ***      0                                  0               my @groups = split(',', $groups);
305   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
306   ***      0                                  0                  s/\s+//;
307   ***      0                                  0                  $_ => 1;
308                                                               } @groups;
309                                                            }
310                                                   
311   ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
312                                                         }
313                                                      }
314                                                   
315   ***      0                                  0      foreach my $long ( keys %disables ) {
316   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
317   ***      0                                  0         $self->{disables}->{$long} = \@participants;
318   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
319                                                      }
320                                                   
321   ***      0                                  0      return; 
322                                                   }
323                                                   
324                                                   sub _get_participants {
325   ***      0                    0             0      my ( $self, $str ) = @_;
326   ***      0                                  0      my @participants;
327   ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
328   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
329                                                            unless exists $self->{opts}->{$long};
330   ***      0                                  0         push @participants, $long;
331                                                      }
332   ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
333   ***      0                                  0      return @participants;
334                                                   }
335                                                   
336                                                   sub opts {
337   ***      0                    0             0      my ( $self ) = @_;
338   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
339   ***      0                                  0      return %opts;
340                                                   }
341                                                   
342                                                   sub short_opts {
343   ***      0                    0             0      my ( $self ) = @_;
344   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
345   ***      0                                  0      return %short_opts;
346                                                   }
347                                                   
348                                                   sub set_defaults {
349   ***      0                    0             0      my ( $self, %defaults ) = @_;
350   ***      0                                  0      $self->{defaults} = {};
351   ***      0                                  0      foreach my $long ( keys %defaults ) {
352   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
353                                                            unless exists $self->{opts}->{$long};
354   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
355   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
356                                                      }
357   ***      0                                  0      return;
358                                                   }
359                                                   
360                                                   sub get_defaults {
361   ***      0                    0             0      my ( $self ) = @_;
362   ***      0                                  0      return $self->{defaults};
363                                                   }
364                                                   
365                                                   sub get_groups {
366   ***      0                    0             0      my ( $self ) = @_;
367   ***      0                                  0      return $self->{groups};
368                                                   }
369                                                   
370                                                   sub _set_option {
371   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
372   ***      0      0                           0      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***             0                               
373                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
374                                                               : die "Getopt::Long gave a nonexistent option: $opt";
375                                                   
376   ***      0                                  0      $opt = $self->{opts}->{$long};
377   ***      0      0                           0      if ( $opt->{is_cumulative} ) {
378   ***      0                                  0         $opt->{value}++;
379                                                      }
380                                                      else {
381   ***      0                                  0         $opt->{value} = $val;
382                                                      }
383   ***      0                                  0      $opt->{got} = 1;
384   ***      0                                  0      MKDEBUG && _d('Got option', $long, '=', $val);
385                                                   }
386                                                   
387                                                   sub get_opts {
388   ***      0                    0             0      my ( $self ) = @_; 
389                                                   
390   ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
391   ***      0                                  0         $self->{opts}->{$long}->{got} = 0;
392   ***      0      0                           0         $self->{opts}->{$long}->{value}
      ***             0                               
393                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
394                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
395                                                            : undef;
396                                                      }
397   ***      0                                  0      $self->{got_opts} = 0;
398                                                   
399   ***      0                                  0      $self->{errors} = [];
400                                                   
401   ***      0      0      0                    0      if ( @ARGV && $ARGV[0] eq "--config" ) {
402   ***      0                                  0         shift @ARGV;
403   ***      0                                  0         $self->_set_option('config', shift @ARGV);
404                                                      }
405   ***      0      0                           0      if ( $self->has('config') ) {
406   ***      0                                  0         my @extra_args;
407   ***      0                                  0         foreach my $filename ( split(',', $self->get('config')) ) {
408   ***      0                                  0            eval {
409   ***      0                                  0               push @extra_args, $self->_read_config_file($filename);
410                                                            };
411   ***      0      0                           0            if ( $EVAL_ERROR ) {
412   ***      0      0                           0               if ( $self->got('config') ) {
413   ***      0                                  0                  die $EVAL_ERROR;
414                                                               }
415                                                               elsif ( MKDEBUG ) {
416                                                                  _d($EVAL_ERROR);
417                                                               }
418                                                            }
419                                                         }
420   ***      0                                  0         unshift @ARGV, @extra_args;
421                                                      }
422                                                   
423   ***      0                                  0      Getopt::Long::Configure('no_ignore_case', 'bundling');
424                                                      GetOptions(
425   ***      0                    0             0         map    { $_->{spec} => sub { $self->_set_option(@_); } }
      ***      0                                  0   
      ***      0                                  0   
426   ***      0                                  0         grep   { $_->{long} ne 'config' } # --config is handled specially above.
427   ***      0      0                           0         values %{$self->{opts}}
428                                                      ) or $self->save_error('Error parsing options');
429                                                   
430   ***      0      0      0                    0      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
431   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
432                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
433                                                               or die "Cannot print: $OS_ERROR";
434   ***      0                                  0         exit 0;
435                                                      }
436                                                   
437   ***      0      0      0                    0      if ( @ARGV && $self->{strict} ) {
438   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
439                                                      }
440                                                   
441   ***      0                                  0      foreach my $mutex ( @{$self->{mutex}} ) {
      ***      0                                  0   
442   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
443   ***      0      0                           0         if ( @set > 1 ) {
444   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
445   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
446                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
447                                                                    . ' are mutually exclusive.';
448   ***      0                                  0            $self->save_error($err);
449                                                         }
450                                                      }
451                                                   
452   ***      0                                  0      foreach my $required ( @{$self->{atleast1}} ) {
      ***      0                                  0   
453   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
454   ***      0      0                           0         if ( @set == 0 ) {
455   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
456   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
457                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
458   ***      0                                  0            $self->save_error("Specify at least one of $err");
459                                                         }
460                                                      }
461                                                   
462   ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
463   ***      0                                  0         my $opt = $self->{opts}->{$long};
464   ***      0      0                           0         if ( $opt->{got} ) {
      ***             0                               
465   ***      0      0                           0            if ( exists $self->{disables}->{$long} ) {
466   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
467   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
468   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
469                                                                  'because', $long,'disables them');
470                                                            }
471                                                   
472   ***      0      0                           0            if ( exists $self->{allowed_groups}->{$long} ) {
473                                                   
474   ***      0                                  0               my @restricted_groups = grep {
475   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
476   ***      0                                  0               } keys %{$self->{groups}};
477                                                   
478   ***      0                                  0               my @restricted_opts;
479   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
480   ***      0                                  0                  RESTRICTED_OPT:
481   ***      0                                  0                  foreach my $restricted_opt (
482                                                                     keys %{$self->{groups}->{$restricted_group}} )
483                                                                  {
484   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
485   ***      0      0                           0                     push @restricted_opts, $restricted_opt
486                                                                        if $self->{opts}->{$restricted_opt}->{got};
487                                                                  }
488                                                               }
489                                                   
490   ***      0      0                           0               if ( @restricted_opts ) {
491   ***      0                                  0                  my $err;
492   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
493   ***      0                                  0                     $err = "--$restricted_opts[0]";
494                                                                  }
495                                                                  else {
496   ***      0                                  0                     $err = join(', ',
497   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
498   ***      0                                  0                               grep { $_ } 
499                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
500                                                                            )
501                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
502                                                                  }
503   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
504                                                               }
505                                                            }
506                                                   
507                                                         }
508                                                         elsif ( $opt->{is_required} ) { 
509   ***      0                                  0            $self->save_error("Required option --$long must be specified");
510                                                         }
511                                                   
512   ***      0                                  0         $self->_validate_type($opt);
513                                                      }
514                                                   
515   ***      0                                  0      $self->{got_opts} = 1;
516   ***      0                                  0      return;
517                                                   }
518                                                   
519                                                   sub _validate_type {
520   ***      0                    0             0      my ( $self, $opt ) = @_;
521   ***      0      0      0                    0      return unless $opt && $opt->{type};
522   ***      0                                  0      my $val = $opt->{value};
523                                                   
524   ***      0      0      0                    0      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
      ***                    0                        
525   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
526   ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
527   ***      0      0                           0         if ( !$suffix ) {
528   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
529   ***      0             0                    0            $suffix = $s || 's';
530   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
531                                                               $opt->{long}, '(value:', $val, ')');
532                                                         }
533   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
534   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
535                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
536                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
537                                                                 :                  $num * 86400;   # Days
538   ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
539   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
540                                                         }
541                                                         else {
542   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
543                                                         }
544                                                      }
545                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
546   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
547   ***      0                                  0         my $prev = {};
548   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
549   ***      0      0                           0         if ( $from_key ) {
550   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
551   ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
552                                                         }
553   ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
554   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
555                                                      }
556                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
557   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
558   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
559   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
560   ***      0      0                           0         if ( defined $num ) {
561   ***      0      0                           0            if ( $factor ) {
562   ***      0                                  0               $num *= $factor_for{$factor};
563   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
564                                                                  'to num', $num, '* factor', $factor);
565                                                            }
566   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
567                                                         }
568                                                         else {
569   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
570                                                         }
571                                                      }
572                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
573   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
574                                                      }
575                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
576   ***      0             0                    0         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
577                                                      }
578                                                      else {
579   ***      0                                  0         MKDEBUG && _d('Nothing to validate for option',
580                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
581                                                      }
582                                                   
583   ***      0                                  0      return;
584                                                   }
585                                                   
586                                                   sub get {
587   ***      0                    0             0      my ( $self, $opt ) = @_;
588   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
589   ***      0      0      0                    0      die "Option $opt does not exist"
590                                                         unless $long && exists $self->{opts}->{$long};
591   ***      0                                  0      return $self->{opts}->{$long}->{value};
592                                                   }
593                                                   
594                                                   sub got {
595   ***      0                    0             0      my ( $self, $opt ) = @_;
596   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
597   ***      0      0      0                    0      die "Option $opt does not exist"
598                                                         unless $long && exists $self->{opts}->{$long};
599   ***      0                                  0      return $self->{opts}->{$long}->{got};
600                                                   }
601                                                   
602                                                   sub has {
603   ***      0                    0             0      my ( $self, $opt ) = @_;
604   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
605   ***      0      0                           0      return defined $long ? exists $self->{opts}->{$long} : 0;
606                                                   }
607                                                   
608                                                   sub set {
609   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
610   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
611   ***      0      0      0                    0      die "Option $opt does not exist"
612                                                         unless $long && exists $self->{opts}->{$long};
613   ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
614   ***      0                                  0      return;
615                                                   }
616                                                   
617                                                   sub save_error {
618   ***      0                    0             0      my ( $self, $error ) = @_;
619   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
620                                                   }
621                                                   
622                                                   sub errors {
623   ***      0                    0             0      my ( $self ) = @_;
624   ***      0                                  0      return $self->{errors};
625                                                   }
626                                                   
627                                                   sub prompt {
628   ***      0                    0             0      my ( $self ) = @_;
629   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
630                                                   }
631                                                   
632                                                   sub descr {
633   ***      0                    0             0      my ( $self ) = @_;
634   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
635                                                                 . "  For more details, please use the --help option, "
636                                                                 . "or try 'perldoc $PROGRAM_NAME' "
637                                                                 . "for complete documentation.";
638   ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
639   ***      0                                  0      $descr =~ s/ +$//mg;
640   ***      0                                  0      return $descr;
641                                                   }
642                                                   
643                                                   sub usage_or_errors {
644   ***      0                    0             0      my ( $self ) = @_;
645   ***      0      0                           0      if ( $self->{opts}->{help}->{got} ) {
      ***      0      0                           0   
646   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
647   ***      0                                  0         exit 0;
648                                                      }
649                                                      elsif ( scalar @{$self->{errors}} ) {
650   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
651   ***      0                                  0         exit 0;
652                                                      }
653   ***      0                                  0      return;
654                                                   }
655                                                   
656                                                   sub print_errors {
657   ***      0                    0             0      my ( $self ) = @_;
658   ***      0                                  0      my $usage = $self->prompt() . "\n";
659   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
660   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
661                                                                 . "\n";
662                                                      }
663   ***      0                                  0      return $usage . "\n" . $self->descr();
664                                                   }
665                                                   
666                                                   sub print_usage {
667   ***      0                    0             0      my ( $self ) = @_;
668   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
669   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
670                                                   
671   ***      0      0                           0      my $maxl = max(
672   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
673                                                         @opts);
674                                                   
675   ***      0      0                           0      my $maxs = max(0,
676   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
677   ***      0                                  0         values %{$self->{short_opts}});
678                                                   
679   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
680   ***      0                                  0      my $rcol = 80 - $lcol - 6;
681   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
682                                                   
683   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
684                                                   
685   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
686                                                   
687   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
688   ***      0                                  0      push @groups, 'default';
689                                                   
690   ***      0                                  0      foreach my $group ( reverse @groups ) {
691   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
692   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
693   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
694                                                            grep { $_->{group} eq $group }
695                                                            @opts )
696                                                         {
697   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
698   ***      0                                  0            my $short = $opt->{short};
699   ***      0                                  0            my $desc  = $opt->{desc};
700   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
701   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
702   ***      0             0                    0               $s    ||= 's';
703   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
704   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
705                                                                      . "d=days; if no suffix, $s is used.";
706                                                            }
707   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
708   ***      0                                  0            $desc =~ s/ +$//mg;
709   ***      0      0                           0            if ( $short ) {
710   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
711                                                            }
712                                                            else {
713   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
714                                                            }
715                                                         }
716                                                      }
717                                                   
718   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
719   ***      0                                  0         $usage .= "\nRules:\n\n";
720   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
721                                                      }
722   ***      0      0                           0      if ( $self->{dp} ) {
723   ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
724                                                      }
725   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
726   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
727   ***      0                                  0         my $val   = $opt->{value};
728   ***      0             0                    0         my $type  = $opt->{type} || '';
729   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
730   ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
731                                                                   : !defined $val             ? '(No value)'
732                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
733                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
734                                                                   : $type =~ m/A|a/           ? join(',', @$val)
735                                                                   :                             $val;
736   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
737                                                      }
738   ***      0                                  0      return $usage;
739                                                   }
740                                                   
741                                                   sub prompt_noecho {
742   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
743   ***      0                                  0      my ( $prompt ) = @_;
744   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
745   ***      0      0                           0      print $prompt
746                                                         or die "Cannot print: $OS_ERROR";
747   ***      0                                  0      my $response;
748   ***      0                                  0      eval {
749   ***      0                                  0         require Term::ReadKey;
750   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
751   ***      0                                  0         chomp($response = <STDIN>);
752   ***      0                                  0         Term::ReadKey::ReadMode('normal');
753   ***      0      0                           0         print "\n"
754                                                            or die "Cannot print: $OS_ERROR";
755                                                      };
756   ***      0      0                           0      if ( $EVAL_ERROR ) {
757   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
758                                                      }
759   ***      0                                  0      return $response;
760                                                   }
761                                                   
762                                                   if ( MKDEBUG ) {
763                                                      print '# ', $^X, ' ', $], "\n";
764                                                      my $uname = `uname -a`;
765                                                      if ( $uname ) {
766                                                         $uname =~ s/\s+/ /g;
767                                                         print "# $uname\n";
768                                                      }
769                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
770                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
771                                                         ($main::SVN_REV || ''), __LINE__);
772                                                      print('# Arguments: ',
773                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
774                                                   }
775                                                   
776                                                   sub _read_config_file {
777   ***      0                    0             0      my ( $self, $filename ) = @_;
778   ***      0      0                           0      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
779   ***      0                                  0      my @args;
780   ***      0                                  0      my $prefix = '--';
781   ***      0                                  0      my $parse  = 1;
782                                                   
783                                                      LINE:
784   ***      0                                  0      while ( my $line = <$fh> ) {
785   ***      0                                  0         chomp $line;
786   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
787   ***      0                                  0         $line =~ s/\s+#.*$//g;
788   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
789   ***      0      0                           0         if ( $line eq '--' ) {
790   ***      0                                  0            $prefix = '';
791   ***      0                                  0            $parse  = 0;
792   ***      0                                  0            next LINE;
793                                                         }
794   ***      0      0      0                    0         if ( $parse
      ***             0                               
795                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
796                                                         ) {
797   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
798                                                         }
799                                                         elsif ( $line =~ m/./ ) {
800   ***      0                                  0            push @args, $line;
801                                                         }
802                                                         else {
803   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
804                                                         }
805                                                      }
806   ***      0                                  0      close $fh;
807   ***      0                                  0      return @args;
808                                                   }
809                                                   
810                                                   sub read_para_after {
811   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
812   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
813   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
814   ***      0                                  0      my $para;
815   ***      0                                  0      while ( $para = <$fh> ) {
816   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
817   ***      0                                  0         last;
818                                                      }
819   ***      0                                  0      while ( $para = <$fh> ) {
820   ***      0      0                           0         next unless $para =~ m/$regex/;
821   ***      0                                  0         last;
822                                                      }
823   ***      0                                  0      $para = <$fh>;
824   ***      0                                  0      chomp($para);
825   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
826   ***      0                                  0      return $para;
827                                                   }
828                                                   
829                                                   sub clone {
830   ***      0                    0             0      my ( $self ) = @_;
831                                                   
832   ***      0                                  0      my %clone = map {
833   ***      0                                  0         my $hashref  = $self->{$_};
834   ***      0                                  0         my $val_copy = {};
835   ***      0                                  0         foreach my $key ( keys %$hashref ) {
836   ***      0                                  0            my $ref = ref $hashref->{$key};
837   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
838   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
839   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
840                                                                              : $hashref->{$key};
841                                                         }
842   ***      0                                  0         $_ => $val_copy;
843                                                      } qw(opts short_opts defaults);
844                                                   
845   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
846   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
847                                                      }
848                                                   
849   ***      0                                  0      return bless \%clone;     
850                                                   }
851                                                   
852                                                   sub _d {
853   ***      0                    0             0      my ($package, undef, $line) = caller 0;
854   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
855   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
856                                                           @_;
857   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
858                                                   }
859                                                   
860                                                   1;
861                                                   
862                                                   # ###########################################################################
863                                                   # End OptionParser package
864                                                   # ###########################################################################
865                                                   
866                                                   # ###########################################################################
867                                                   # DSNParser package 5266
868                                                   # ###########################################################################
869                                                   package DSNParser;
870                                                   
871            1                    1           112   use strict;
               1                                  3   
               1                                 13   
872            1                    1             7   use warnings FATAL => 'all';
               1                                  3   
               1                                  8   
873            1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  8   
874            1                    1            12   use Data::Dumper;
               1                                  3   
               1                                 17   
875                                                   $Data::Dumper::Indent    = 0;
876                                                   $Data::Dumper::Quotekeys = 0;
877                                                   
878                                                   eval {
879                                                      require DBI;
880                                                   };
881                                                   my $have_dbi = $EVAL_ERROR ? 0 : 1;
882                                                   
883   ***      1            50      1             7   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 18   
884                                                   
885                                                   sub new {
886            1                    1             5      my ( $class, @opts ) = @_;
887            1                                 28      my $self = {
888                                                         opts => {
889                                                            A => {
890                                                               desc => 'Default character set',
891                                                               dsn  => 'charset',
892                                                               copy => 1,
893                                                            },
894                                                            D => {
895                                                               desc => 'Database to use',
896                                                               dsn  => 'database',
897                                                               copy => 1,
898                                                            },
899                                                            F => {
900                                                               desc => 'Only read default options from the given file',
901                                                               dsn  => 'mysql_read_default_file',
902                                                               copy => 1,
903                                                            },
904                                                            h => {
905                                                               desc => 'Connect to host',
906                                                               dsn  => 'host',
907                                                               copy => 1,
908                                                            },
909                                                            p => {
910                                                               desc => 'Password to use when connecting',
911                                                               dsn  => 'password',
912                                                               copy => 1,
913                                                            },
914                                                            P => {
915                                                               desc => 'Port number to use for connection',
916                                                               dsn  => 'port',
917                                                               copy => 1,
918                                                            },
919                                                            S => {
920                                                               desc => 'Socket file to use for connection',
921                                                               dsn  => 'mysql_socket',
922                                                               copy => 1,
923                                                            },
924                                                            u => {
925                                                               desc => 'User for login if not current user',
926                                                               dsn  => 'user',
927                                                               copy => 1,
928                                                            },
929                                                         },
930                                                      };
931            1                                  5      foreach my $opt ( @opts ) {
932   ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
933   ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
934                                                      }
935            1                                 16      return bless $self, $class;
936                                                   }
937                                                   
938                                                   sub prop {
939            9                    9            49      my ( $self, $prop, $value ) = @_;
940   ***      9     50                          46      if ( @_ > 2 ) {
941   ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
942   ***      0                                  0         $self->{$prop} = $value;
943                                                      }
944            9                                 85      return $self->{$prop};
945                                                   }
946                                                   
947                                                   sub parse {
948            3                    3           173      my ( $self, $dsn, $prev, $defaults ) = @_;
949   ***      3     50                          19      if ( !$dsn ) {
950   ***      0                                  0         MKDEBUG && _d('No DSN to parse');
951   ***      0                                  0         return;
952                                                      }
953            3                                  8      MKDEBUG && _d('Parsing', $dsn);
954   ***      3            50                   16      $prev     ||= {};
955   ***      3            50                   18      $defaults ||= {};
956            3                                  8      my %given_props;
957            3                                  9      my %final_props;
958            3                                 11      my %opts = %{$self->{opts}};
               3                                 67   
959                                                   
960            3                                 36      foreach my $dsn_part ( split(/,/, $dsn) ) {
961   ***     12     50                         122         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
962           12                                 62            $given_props{$prop_key} = $prop_val;
963                                                         }
964                                                         else {
965   ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
966   ***      0                                  0            $given_props{h} = $dsn_part;
967                                                         }
968                                                      }
969                                                   
970            3                                 19      foreach my $key ( keys %opts ) {
971           24                                110         MKDEBUG && _d('Finding value for', $key);
972           24                                 92         $final_props{$key} = $given_props{$key};
973   ***     24     50     66                  195         if (   !defined $final_props{$key}
      ***                   33                        
974                                                              && defined $prev->{$key} && $opts{$key}->{copy} )
975                                                         {
976   ***      0                                  0            $final_props{$key} = $prev->{$key};
977   ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
978                                                         }
979           24    100                         102         if ( !defined $final_props{$key} ) {
980           12                                 39            $final_props{$key} = $defaults->{$key};
981           12                                 35            MKDEBUG && _d('Copying value for', $key, 'from defaults');
982                                                         }
983                                                      }
984                                                   
985            3                                 18      foreach my $key ( keys %given_props ) {
986   ***     12     50                          82         die "Unrecognized DSN part '$key' in '$dsn'\n"
987                                                            unless exists $opts{$key};
988                                                      }
989   ***      3     50                          21      if ( (my $required = $self->prop('required')) ) {
990   ***      0                                  0         foreach my $key ( keys %$required ) {
991   ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
992                                                         }
993                                                      }
994                                                   
995            3                                 27      return \%final_props;
996                                                   }
997                                                   
998                                                   sub parse_options {
999   ***      0                    0             0      my ( $self, $o ) = @_;
1000  ***      0      0                           0      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1001  ***      0                                  0      my $dsn_string
1002                                                        = join(',',
1003  ***      0      0                           0             map  { "$_=".$o->get($_); }
1004  ***      0                                  0             grep { $o->has($_) && $o->get($_) }
1005  ***      0                                  0             keys %{$self->{opts}}
1006                                                          );
1007  ***      0                                  0      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1008  ***      0                                  0      return $self->parse($dsn_string);
1009                                                  }
1010                                                  
1011                                                  sub as_string {
1012  ***      0                    0             0      my ( $self, $dsn ) = @_;
1013  ***      0      0                           0      return $dsn unless ref $dsn;
1014  ***      0      0                           0      return join(',',
1015  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1016  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1017                                                        sort keys %$dsn );
1018                                                  }
1019                                                  
1020                                                  sub usage {
1021  ***      0                    0             0      my ( $self ) = @_;
1022  ***      0                                  0      my $usage
1023                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1024                                                        . "  KEY  COPY  MEANING\n"
1025                                                        . "  ===  ====  =============================================\n";
1026  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1027  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1028  ***      0      0      0                    0         $usage .= "  $key    "
1029                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1030                                                               .  ($opts{$key}->{desc} || '[No description]')
1031                                                               . "\n";
1032                                                     }
1033  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1034  ***      0                                  0      return $usage;
1035                                                  }
1036                                                  
1037                                                  sub get_cxn_params {
1038           3                    3            57      my ( $self, $info ) = @_;
1039           3                                  9      my $dsn;
1040           3                                  9      my %opts = %{$self->{opts}};
               3                                 25   
1041  ***      3            50                   16      my $driver = $self->prop('dbidriver') || '';
1042  ***      3     50                          16      if ( $driver eq 'Pg' ) {
1043  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1044  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1045  ***      0             0                    0                        grep { defined $info->{$_} }
1046                                                                       qw(h P));
1047                                                     }
1048                                                     else {
1049           6                                 49         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1050          15                                 58            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1051  ***      3            50                   41                        grep { defined $info->{$_} }
1052                                                                       qw(F h P S A))
1053                                                           . ';mysql_read_default_group=client';
1054                                                     }
1055           3                                  9      MKDEBUG && _d($dsn);
1056           3                                 32      return ($dsn, $info->{u}, $info->{p});
1057                                                  }
1058                                                  
1059                                                  sub fill_in_dsn {
1060  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1061  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1062  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1063  ***      0                                  0      $user =~ s/@.*//;
1064  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1065  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1066  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1067  ***      0             0                    0      $dsn->{u} ||= $user;
1068  ***      0             0                    0      $dsn->{D} ||= $db;
1069                                                  }
1070                                                  
1071                                                  sub get_dbh {
1072           3                    3            22      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1073  ***      3            50                   14      $opts ||= {};
1074  ***      3     50                          41      my $defaults = {
1075                                                        AutoCommit         => 0,
1076                                                        RaiseError         => 1,
1077                                                        PrintError         => 0,
1078                                                        ShowErrorStatement => 1,
1079                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1080                                                     };
1081           3                                 19      @{$defaults}{ keys %$opts } = values %$opts;
               3                                 13   
1082                                                  
1083  ***      3     50                          17      if ( !$have_dbi ) {
1084  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1085                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1086                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1087                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1088                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1089                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1090                                                  
1091                                                     }
1092                                                  
1093           3                                  8      my $dbh;
1094           3                                 12      my $tries = 2;
1095  ***      3            66                   34      while ( !$dbh && $tries-- ) {
1096                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1097           3                                  9            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1098                                                  
1099           3                                  8         eval {
1100           3                                 32            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1101                                                  
1102  ***      3     50                          45            if ( $cxn_string =~ m/mysql/i ) {
1103           3                                  9               my $sql;
1104                                                  
1105           3                                 13               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1106                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1107           3                                  7               MKDEBUG && _d($dbh, ':', $sql);
1108           3                                399               $dbh->do($sql);
1109                                                  
1110  ***      3     50                          30               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1111  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1112  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1113  ***      0                                  0                  $dbh->do($sql);
1114  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1115  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1116  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1117                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1118                                                                 }
1119                                                                 else {
1120  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1121                                                                 }
1122                                                              }
1123                                                  
1124  ***      3     50                          23               if ( $self->prop('set-vars') ) {
1125  ***      0                                  0                  $sql = "SET " . $self->prop('set-vars');
1126  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1127  ***      0                                  0                  $dbh->do($sql);
1128                                                              }
1129                                                           }
1130                                                        };
1131  ***      3     50     33                   36         if ( !$dbh && $EVAL_ERROR ) {
1132  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1133  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1134  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1135  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1136                                                           }
1137                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1138  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1139                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1140                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1141                                                                 . "DBD::mysql is not installed, try:\n"
1142                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1143                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1144                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1145                                                           }
1146  ***      0      0                           0            if ( !$tries ) {
1147  ***      0                                  0               die $EVAL_ERROR;
1148                                                           }
1149                                                        }
1150                                                     }
1151                                                  
1152           3                                  6      MKDEBUG && _d('DBH info: ',
1153                                                        $dbh,
1154                                                        Dumper($dbh->selectrow_hashref(
1155                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1156                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1157                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1158                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1159                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1160                                                        '$DBI::VERSION:',        $DBI::VERSION,
1161                                                     );
1162                                                  
1163           3                                 23      return $dbh;
1164                                                  }
1165                                                  
1166                                                  sub get_hostname {
1167  ***      0                    0                    my ( $self, $dbh ) = @_;
1168  ***      0      0      0                           if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1169  ***      0                                            return $host;
1170                                                     }
1171  ***      0                                         my ( $hostname, $one ) = $dbh->selectrow_array(
1172                                                        'SELECT /*!50038 @@hostname, */ 1');
1173  ***      0                                         return $hostname;
1174                                                  }
1175                                                  
1176                                                  sub disconnect {
1177  ***      0                    0                    my ( $self, $dbh ) = @_;
1178  ***      0                                         MKDEBUG && $self->print_active_handles($dbh);
1179  ***      0                                         $dbh->disconnect;
1180                                                  }
1181                                                  
1182                                                  sub print_active_handles {
1183  ***      0                    0                    my ( $self, $thing, $level ) = @_;
1184  ***      0             0                           $level ||= 0;
1185  ***      0      0      0                           printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1186                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1187                                                        or die "Cannot print: $OS_ERROR";
1188  ***      0                                         foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                      
      ***      0                                      
1189  ***      0                                            $self->print_active_handles( $handle, $level + 1 );
1190                                                     }
1191                                                  }
1192                                                  
1193                                                  sub copy {
1194  ***      0                    0                    my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1195  ***      0      0                                  die 'I need a dsn_1 argument' unless $dsn_1;
1196  ***      0      0                                  die 'I need a dsn_2 argument' unless $dsn_2;
1197  ***      0                                         my %new_dsn = map {
1198  ***      0                                            my $key = $_;
1199  ***      0                                            my $val;
1200  ***      0      0                                     if ( $args{overwrite} ) {
1201  ***      0      0                                        $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1202                                                        }
1203                                                        else {
1204  ***      0      0                                        $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1205                                                        }
1206  ***      0                                            $key => $val;
1207  ***      0                                         } keys %{$self->{opts}};
1208  ***      0                                         return \%new_dsn;
1209                                                  }
1210                                                  
1211                                                  sub _d {
1212  ***      0                    0                    my ($package, undef, $line) = caller 0;
1213  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1214  ***      0                                              map { defined $_ ? $_ : 'undef' }
1215                                                          @_;
1216  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1217                                                  }
1218                                                  
1219                                                  1;
1220                                                  
1221                                                  # ###########################################################################
1222                                                  # End DSNParser package
1223                                                  # ###########################################################################
1224                                                  
1225                                                  # ###########################################################################
1226                                                  # MasterSlave package 5362
1227                                                  # ###########################################################################
1228           1                    1            12   use strict;
               1                                  4   
               1                                  8   
1229           1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  8   
1230                                                  
1231                                                  package MasterSlave;
1232                                                  
1233           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  7   
1234           1                    1             9   use List::Util qw(min max);
               1                                  3   
               1                                  7   
1235           1                    1             7   use Data::Dumper;
               1                                  3   
               1                                  7   
1236                                                  $Data::Dumper::Quotekeys = 0;
1237                                                  $Data::Dumper::Indent    = 0;
1238                                                  
1239  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 18   
1240                                                  
1241                                                  sub new {
1242  ***      0                    0                    bless {}, shift;
1243                                                  }
1244                                                  
1245                                                  sub recurse_to_slaves {
1246  ***      0                    0                    my ( $self, $args, $level ) = @_;
1247  ***      0             0                           $level ||= 0;
1248  ***      0                                         my $dp   = $args->{dsn_parser};
1249  ***      0                                         my $dsn  = $args->{dsn};
1250                                                  
1251  ***      0                                         my $dbh;
1252  ***      0                                         eval {
1253  ***      0             0                              $dbh = $args->{dbh} || $dp->get_dbh(
1254                                                           $dp->get_cxn_params($dsn), { AutoCommit => 1 });
1255  ***      0                                            MKDEBUG && _d('Connected to', $dp->as_string($dsn));
1256                                                     };
1257  ***      0      0                                  if ( $EVAL_ERROR ) {
1258  ***      0      0                                     print STDERR "Cannot connect to ", $dp->as_string($dsn), "\n"
1259                                                           or die "Cannot print: $OS_ERROR";
1260  ***      0                                            return;
1261                                                     }
1262                                                  
1263  ***      0                                         my $sql  = 'SELECT @@SERVER_ID';
1264  ***      0                                         MKDEBUG && _d($sql);
1265  ***      0                                         my ($id) = $dbh->selectrow_array($sql);
1266  ***      0                                         MKDEBUG && _d('Working on server ID', $id);
1267  ***      0                                         my $master_thinks_i_am = $dsn->{server_id};
1268  ***      0      0      0                           if ( !defined $id
      ***                    0                        
      ***                    0                        
1269                                                         || ( defined $master_thinks_i_am && $master_thinks_i_am != $id )
1270                                                         || $args->{server_ids_seen}->{$id}++
1271                                                     ) {
1272  ***      0                                            MKDEBUG && _d('Server ID seen, or not what master said');
1273  ***      0      0                                     if ( $args->{skip_callback} ) {
1274  ***      0                                               $args->{skip_callback}->($dsn, $dbh, $level, $args->{parent});
1275                                                        }
1276  ***      0                                            return;
1277                                                     }
1278                                                  
1279  ***      0                                         $args->{callback}->($dsn, $dbh, $level, $args->{parent});
1280                                                  
1281  ***      0      0      0                           if ( !defined $args->{recurse} || $level < $args->{recurse} ) {
1282                                                  
1283  ***      0      0                                     my @slaves =
1284  ***      0                                               grep { !$_->{master_id} || $_->{master_id} == $id } # Only my slaves.
1285                                                           $self->find_slave_hosts($dp, $dbh, $dsn, $args->{method});
1286                                                  
1287  ***      0                                            foreach my $slave ( @slaves ) {
1288  ***      0                                               MKDEBUG && _d('Recursing from',
1289                                                              $dp->as_string($dsn), 'to', $dp->as_string($slave));
1290  ***      0                                               $self->recurse_to_slaves(
1291                                                              { %$args, dsn => $slave, dbh => undef, parent => $dsn }, $level + 1 );
1292                                                        }
1293                                                     }
1294                                                  }
1295                                                  
1296                                                  sub find_slave_hosts {
1297  ***      0                    0                    my ( $self, $dsn_parser, $dbh, $dsn, $method ) = @_;
1298                                                  
1299  ***      0                                         my @methods = qw(processlist hosts);
1300  ***      0      0                                  if ( $method ) {
1301  ***      0                                            @methods = grep { $_ ne $method } @methods;
      ***      0                                      
1302  ***      0                                            unshift @methods, $method;
1303                                                     }
1304                                                     else {
1305  ***      0      0      0                              if ( ($dsn->{P} || 3306) != 3306 ) {
1306  ***      0                                               MKDEBUG && _d('Port number is non-standard; using only hosts method');
1307  ***      0                                               @methods = qw(hosts);
1308                                                        }
1309                                                     }
1310  ***      0                                         MKDEBUG && _d('Looking for slaves on', $dsn_parser->as_string($dsn),
1311                                                        'using methods', @methods);
1312                                                  
1313  ***      0                                         my @slaves;
1314                                                     METHOD:
1315  ***      0                                         foreach my $method ( @methods ) {
1316  ***      0                                            my $find_slaves = "_find_slaves_by_$method";
1317  ***      0                                            MKDEBUG && _d('Finding slaves with', $find_slaves);
1318  ***      0                                            @slaves = $self->$find_slaves($dsn_parser, $dbh, $dsn);
1319  ***      0      0                                     last METHOD if @slaves;
1320                                                     }
1321                                                  
1322  ***      0                                         MKDEBUG && _d('Found', scalar(@slaves), 'slaves');
1323  ***      0                                         return @slaves;
1324                                                  }
1325                                                  
1326                                                  sub _find_slaves_by_processlist {
1327  ***      0                    0                    my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
1328                                                  
1329  ***      0                                         my @slaves = map  {
1330  ***      0                                            my $slave        = $dsn_parser->parse("h=$_", $dsn);
1331  ***      0                                            $slave->{source} = 'processlist';
1332  ***      0                                            $slave;
1333                                                     }
1334  ***      0                                         grep { $_ }
1335                                                     map  {
1336  ***      0                                            my ( $host ) = $_->{host} =~ m/^([^:]+):/;
1337  ***      0      0                                     if ( $host eq 'localhost' ) {
1338  ***      0                                               $host = '127.0.0.1'; # Replication never uses sockets.
1339                                                        }
1340  ***      0                                            $host;
1341                                                     } $self->get_connected_slaves($dbh);
1342                                                  
1343  ***      0                                         return @slaves;
1344                                                  }
1345                                                  
1346                                                  sub _find_slaves_by_hosts {
1347  ***      0                    0                    my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
1348                                                  
1349  ***      0                                         my @slaves;
1350  ***      0                                         my $sql = 'SHOW SLAVE HOSTS';
1351  ***      0                                         MKDEBUG && _d($dbh, $sql);
1352  ***      0                                         @slaves = @{$dbh->selectall_arrayref($sql, { Slice => {} })};
      ***      0                                      
1353                                                  
1354  ***      0      0                                  if ( @slaves ) {
1355  ***      0                                            MKDEBUG && _d('Found some SHOW SLAVE HOSTS info');
1356  ***      0                                            @slaves = map {
1357  ***      0                                               my %hash;
1358  ***      0                                               @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                      
1359  ***      0      0                                        my $spec = "h=$hash{host},P=$hash{port}"
      ***             0                               
1360                                                              . ( $hash{user} ? ",u=$hash{user}" : '')
1361                                                              . ( $hash{password} ? ",p=$hash{password}" : '');
1362  ***      0                                               my $dsn           = $dsn_parser->parse($spec, $dsn);
1363  ***      0                                               $dsn->{server_id} = $hash{server_id};
1364  ***      0                                               $dsn->{master_id} = $hash{master_id};
1365  ***      0                                               $dsn->{source}    = 'hosts';
1366  ***      0                                               $dsn;
1367                                                        } @slaves;
1368                                                     }
1369                                                  
1370  ***      0                                         return @slaves;
1371                                                  }
1372                                                  
1373                                                  sub get_connected_slaves {
1374  ***      0                    0                    my ( $self, $dbh ) = @_;
1375                                                  
1376  ***      0                                         my $proc =
1377  ***      0                                            grep { m/ALL PRIVILEGES.*?\*\.\*|PROCESS/ }
1378  ***      0                                            @{$dbh->selectcol_arrayref('SHOW GRANTS')};
1379  ***      0      0                                  if ( !$proc ) {
1380  ***      0                                            die "You do not have the PROCESS privilege";
1381                                                     }
1382                                                  
1383  ***      0                                         my $sql = 'SHOW PROCESSLIST';
1384  ***      0                                         MKDEBUG && _d($dbh, $sql);
1385  ***      0                                         grep { $_->{command} =~ m/Binlog Dump/i }
      ***      0                                      
1386                                                     map  { # Lowercase the column names
1387  ***      0                                            my %hash;
1388  ***      0                                            @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                      
1389  ***      0                                            \%hash;
1390                                                     }
1391  ***      0                                         @{$dbh->selectall_arrayref($sql, { Slice => {} })};
1392                                                  }
1393                                                  
1394                                                  sub is_master_of {
1395  ***      0                    0                    my ( $self, $master, $slave ) = @_;
1396  ***      0      0                                  my $master_status = $self->get_master_status($master)
1397                                                        or die "The server specified as a master is not a master";
1398  ***      0      0                                  my $slave_status  = $self->get_slave_status($slave)
1399                                                        or die "The server specified as a slave is not a slave";
1400  ***      0      0                                  my @connected     = $self->get_connected_slaves($master)
1401                                                        or die "The server specified as a master has no connected slaves";
1402  ***      0                                         my (undef, $port) = $master->selectrow_array('SHOW VARIABLES LIKE "port"');
1403                                                  
1404  ***      0      0                                  if ( $port != $slave_status->{master_port} ) {
1405  ***      0                                            die "The slave is connected to $slave_status->{master_port} "
1406                                                           . "but the master's port is $port";
1407                                                     }
1408                                                  
1409  ***      0      0                                  if ( !grep { $slave_status->{master_user} eq $_->{user} } @connected ) {
      ***      0                                      
1410  ***      0                                            die "I don't see any slave I/O thread connected with user "
1411                                                           . $slave_status->{master_user};
1412                                                     }
1413                                                  
1414  ***      0      0      0                           if ( ($slave_status->{slave_io_state} || '')
1415                                                        eq 'Waiting for master to send event' )
1416                                                     {
1417  ***      0                                            my ( $master_log_name, $master_log_num )
1418                                                           = $master_status->{file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
1419  ***      0                                            my ( $slave_log_name, $slave_log_num )
1420                                                           = $slave_status->{master_log_file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
1421  ***      0      0      0                              if ( $master_log_name ne $slave_log_name
1422                                                           || abs($master_log_num - $slave_log_num) > 1 )
1423                                                        {
1424  ***      0                                               die "The slave thinks it is reading from "
1425                                                              . "$slave_status->{master_log_file},  but the "
1426                                                              . "master is writing to $master_status->{file}";
1427                                                        }
1428                                                     }
1429  ***      0                                         return 1;
1430                                                  }
1431                                                  
1432                                                  sub get_master_dsn {
1433  ***      0                    0                    my ( $self, $dbh, $dsn, $dsn_parser ) = @_;
1434  ***      0      0                                  my $master = $self->get_slave_status($dbh) or return undef;
1435  ***      0                                         my $spec   = "h=$master->{master_host},P=$master->{master_port}";
1436  ***      0                                         return       $dsn_parser->parse($spec, $dsn);
1437                                                  }
1438                                                  
1439                                                  sub get_slave_status {
1440  ***      0                    0                    my ( $self, $dbh ) = @_;
1441  ***      0      0                                  if ( !$self->{not_a_slave}->{$dbh} ) {
1442  ***      0             0                              my $sth = $self->{sths}->{$dbh}->{SLAVE_STATUS}
1443                                                              ||= $dbh->prepare('SHOW SLAVE STATUS');
1444  ***      0                                            MKDEBUG && _d($dbh, 'SHOW SLAVE STATUS');
1445  ***      0                                            $sth->execute();
1446  ***      0                                            my ($ss) = @{$sth->fetchall_arrayref({})};
      ***      0                                      
1447                                                  
1448  ***      0      0      0                              if ( $ss && %$ss ) {
1449  ***      0                                               $ss = { map { lc($_) => $ss->{$_} } keys %$ss }; # lowercase the keys
      ***      0                                      
1450  ***      0                                               return $ss;
1451                                                        }
1452                                                  
1453  ***      0                                            MKDEBUG && _d('This server returns nothing for SHOW SLAVE STATUS');
1454  ***      0                                            $self->{not_a_slave}->{$dbh}++;
1455                                                     }
1456                                                  }
1457                                                  
1458                                                  sub get_master_status {
1459  ***      0                    0                    my ( $self, $dbh ) = @_;
1460  ***      0      0                                  if ( !$self->{not_a_master}->{$dbh} ) {
1461  ***      0             0                              my $sth = $self->{sths}->{$dbh}->{MASTER_STATUS}
1462                                                              ||= $dbh->prepare('SHOW MASTER STATUS');
1463  ***      0                                            MKDEBUG && _d($dbh, 'SHOW MASTER STATUS');
1464  ***      0                                            $sth->execute();
1465  ***      0                                            my ($ms) = @{$sth->fetchall_arrayref({})};
      ***      0                                      
1466                                                  
1467  ***      0      0      0                              if ( $ms && %$ms ) {
1468  ***      0                                               $ms = { map { lc($_) => $ms->{$_} } keys %$ms }; # lowercase the keys
      ***      0                                      
1469  ***      0      0      0                                 if ( $ms->{file} && $ms->{position} ) {
1470  ***      0                                                  return $ms;
1471                                                           }
1472                                                        }
1473                                                  
1474  ***      0                                            MKDEBUG && _d('This server returns nothing for SHOW MASTER STATUS');
1475  ***      0                                            $self->{not_a_master}->{$dbh}++;
1476                                                     }
1477                                                  }
1478                                                  
1479                                                  sub wait_for_master {
1480  ***      0                    0                    my ( $self, $master, $slave, $time, $timeoutok, $ms ) = @_;
1481  ***      0                                         my $result;
1482  ***      0      0                                  $time = 60 unless defined $time;
1483  ***      0                                         MKDEBUG && _d('Waiting for slave to catch up to master timeout ok:',
1484                                                        $timeoutok);
1485  ***      0             0                           $ms ||= $self->get_master_status($master);
1486  ***      0      0                                  if ( $ms ) {
1487  ***      0                                            my $query = "SELECT MASTER_POS_WAIT('$ms->{file}', $ms->{position}, $time)";
1488  ***      0                                            MKDEBUG && _d($slave, $query);
1489  ***      0                                            ($result) = $slave->selectrow_array($query);
1490  ***      0      0                                     my $stat = defined $result ? $result : 'NULL';
1491  ***      0                                            MKDEBUG && _d('Result of waiting:', $stat);
1492  ***      0      0      0                              if ( $stat eq 'NULL' || $stat < 0 && !$timeoutok ) {
      ***                    0                        
1493  ***      0                                               die "MASTER_POS_WAIT returned $stat";
1494                                                        }
1495                                                     }
1496                                                     else {
1497  ***      0                                            MKDEBUG && _d('Not waiting: this server is not a master');
1498                                                     }
1499  ***      0                                         return $result;
1500                                                  }
1501                                                  
1502                                                  sub stop_slave {
1503  ***      0                    0                    my ( $self, $dbh ) = @_;
1504  ***      0             0                           my $sth = $self->{sths}->{$dbh}->{STOP_SLAVE}
1505                                                           ||= $dbh->prepare('STOP SLAVE');
1506  ***      0                                         MKDEBUG && _d($dbh, $sth->{Statement});
1507  ***      0                                         $sth->execute();
1508                                                  }
1509                                                  
1510                                                  sub start_slave {
1511  ***      0                    0                    my ( $self, $dbh, $pos ) = @_;
1512  ***      0      0                                  if ( $pos ) {
1513  ***      0                                            my $sql = "START SLAVE UNTIL MASTER_LOG_FILE='$pos->{file}', "
1514                                                                . "MASTER_LOG_POS=$pos->{position}";
1515  ***      0                                            MKDEBUG && _d($dbh, $sql);
1516  ***      0                                            $dbh->do($sql);
1517                                                     }
1518                                                     else {
1519  ***      0             0                              my $sth = $self->{sths}->{$dbh}->{START_SLAVE}
1520                                                              ||= $dbh->prepare('START SLAVE');
1521  ***      0                                            MKDEBUG && _d($dbh, $sth->{Statement});
1522  ***      0                                            $sth->execute();
1523                                                     }
1524                                                  }
1525                                                  
1526                                                  sub catchup_to_master {
1527  ***      0                    0                    my ( $self, $slave, $master, $time ) = @_;
1528  ***      0                                         $self->stop_slave($master);
1529  ***      0                                         $self->stop_slave($slave);
1530  ***      0                                         my $slave_status  = $self->get_slave_status($slave);
1531  ***      0                                         my $slave_pos     = $self->repl_posn($slave_status);
1532  ***      0                                         my $master_status = $self->get_master_status($master);
1533  ***      0                                         my $master_pos    = $self->repl_posn($master_status);
1534  ***      0                                         MKDEBUG && _d('Master position:', $self->pos_to_string($master_pos),
1535                                                        'Slave position:', $self->pos_to_string($slave_pos));
1536  ***      0      0                                  if ( $self->pos_cmp($slave_pos, $master_pos) < 0 ) {
1537  ***      0                                            MKDEBUG && _d('Waiting for slave to catch up to master');
1538  ***      0                                            $self->start_slave($slave, $master_pos);
1539  ***      0                                            eval {
1540  ***      0                                               $self->wait_for_master($master, $slave, $time, 0, $master_status);
1541                                                        };
1542  ***      0      0                                     if ( $EVAL_ERROR ) {
1543  ***      0                                               MKDEBUG && _d($EVAL_ERROR);
1544  ***      0      0                                        if ( $EVAL_ERROR =~ m/MASTER_POS_WAIT returned NULL/ ) {
1545  ***      0                                                  $slave_status = $self->get_slave_status($slave);
1546  ***      0      0                                           if ( !$self->slave_is_running($slave_status) ) {
1547  ***      0                                                     MKDEBUG && _d('Master position:',
1548                                                                    $self->pos_to_string($master_pos),
1549                                                                    'Slave position:', $self->pos_to_string($slave_pos));
1550  ***      0                                                     $slave_pos = $self->repl_posn($slave_status);
1551  ***      0      0                                              if ( $self->pos_cmp($slave_pos, $master_pos) != 0 ) {
1552  ***      0                                                        die "$EVAL_ERROR but slave has not caught up to master";
1553                                                                 }
1554  ***      0                                                     MKDEBUG && _d('Slave is caught up to master and stopped');
1555                                                              }
1556                                                              else {
1557  ***      0                                                     die "$EVAL_ERROR but slave was still running";
1558                                                              }
1559                                                           }
1560                                                           else {
1561  ***      0                                                  die $EVAL_ERROR;
1562                                                           }
1563                                                        }
1564                                                     }
1565                                                  }
1566                                                  
1567                                                  sub catchup_to_same_pos {
1568  ***      0                    0                    my ( $self, $s1_dbh, $s2_dbh ) = @_;
1569  ***      0                                         $self->stop_slave($s1_dbh);
1570  ***      0                                         $self->stop_slave($s2_dbh);
1571  ***      0                                         my $s1_status = $self->get_slave_status($s1_dbh);
1572  ***      0                                         my $s2_status = $self->get_slave_status($s2_dbh);
1573  ***      0                                         my $s1_pos    = $self->repl_posn($s1_status);
1574  ***      0                                         my $s2_pos    = $self->repl_posn($s2_status);
1575  ***      0      0                                  if ( $self->pos_cmp($s1_pos, $s2_pos) < 0 ) {
      ***             0                               
1576  ***      0                                            $self->start_slave($s1_dbh, $s2_pos);
1577                                                     }
1578                                                     elsif ( $self->pos_cmp($s2_pos, $s1_pos) < 0 ) {
1579  ***      0                                            $self->start_slave($s2_dbh, $s1_pos);
1580                                                     }
1581                                                  
1582  ***      0                                         $s1_status = $self->get_slave_status($s1_dbh);
1583  ***      0                                         $s2_status = $self->get_slave_status($s2_dbh);
1584  ***      0                                         $s1_pos    = $self->repl_posn($s1_status);
1585  ***      0                                         $s2_pos    = $self->repl_posn($s2_status);
1586                                                  
1587  ***      0      0      0                           if ( $self->slave_is_running($s1_status)
      ***                    0                        
1588                                                       || $self->slave_is_running($s2_status)
1589                                                       || $self->pos_cmp($s1_pos, $s2_pos) != 0)
1590                                                     {
1591  ***      0                                            die "The servers aren't both stopped at the same position";
1592                                                     }
1593                                                  
1594                                                  }
1595                                                  
1596                                                  sub change_master_to {
1597  ***      0                    0                    my ( $self, $dbh, $master_dsn, $master_pos ) = @_;
1598  ***      0                                         $self->stop_slave($dbh);
1599  ***      0                                         MKDEBUG && _d(Dumper($master_dsn), Dumper($master_pos));
1600  ***      0                                         my $sql = "CHANGE MASTER TO MASTER_HOST='$master_dsn->{h}', "
1601                                                        . "MASTER_PORT= $master_dsn->{P}, MASTER_LOG_FILE='$master_pos->{file}', "
1602                                                        . "MASTER_LOG_POS=$master_pos->{position}";
1603  ***      0                                         MKDEBUG && _d($dbh, $sql);
1604  ***      0                                         $dbh->do($sql);
1605                                                  }
1606                                                  
1607                                                  sub make_sibling_of_master {
1608  ***      0                    0                    my ( $self, $slave_dbh, $slave_dsn, $dsn_parser, $timeout) = @_;
1609                                                  
1610  ***      0      0                                  my $master_dsn  = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
1611                                                        or die "This server is not a slave";
1612  ***      0                                         my $master_dbh  = $dsn_parser->get_dbh(
1613                                                        $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
1614  ***      0      0                                  my $gmaster_dsn
1615                                                        = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
1616                                                        or die "This server's master is not a slave";
1617  ***      0                                         my $gmaster_dbh = $dsn_parser->get_dbh(
1618                                                        $dsn_parser->get_cxn_params($gmaster_dsn), { AutoCommit => 1 });
1619  ***      0      0                                  if ( $self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn) ) {
1620  ***      0                                            die "The slave's master's master is the slave: master-master replication";
1621                                                     }
1622                                                  
1623  ***      0                                         $self->stop_slave($master_dbh);
1624  ***      0                                         $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
1625  ***      0                                         $self->stop_slave($slave_dbh);
1626                                                  
1627  ***      0                                         my $master_status = $self->get_master_status($master_dbh);
1628  ***      0                                         my $mslave_status = $self->get_slave_status($master_dbh);
1629  ***      0                                         my $slave_status  = $self->get_slave_status($slave_dbh);
1630  ***      0                                         my $master_pos    = $self->repl_posn($master_status);
1631  ***      0                                         my $slave_pos     = $self->repl_posn($slave_status);
1632                                                  
1633  ***      0      0      0                           if ( !$self->slave_is_running($mslave_status)
      ***                    0                        
1634                                                       && !$self->slave_is_running($slave_status)
1635                                                       && $self->pos_cmp($master_pos, $slave_pos) == 0)
1636                                                     {
1637  ***      0                                            $self->change_master_to($slave_dbh, $gmaster_dsn,
1638                                                           $self->repl_posn($mslave_status)); # Note it's not $master_pos!
1639                                                     }
1640                                                     else {
1641  ***      0                                            die "The servers aren't both stopped at the same position";
1642                                                     }
1643                                                  
1644  ***      0                                         $mslave_status = $self->get_slave_status($master_dbh);
1645  ***      0                                         $slave_status  = $self->get_slave_status($slave_dbh);
1646  ***      0                                         my $mslave_pos = $self->repl_posn($mslave_status);
1647  ***      0                                         $slave_pos     = $self->repl_posn($slave_status);
1648  ***      0      0      0                           if ( $self->short_host($mslave_status) ne $self->short_host($slave_status)
1649                                                       || $self->pos_cmp($mslave_pos, $slave_pos) != 0)
1650                                                     {
1651  ***      0                                            die "The servers don't have the same master/position after the change";
1652                                                     }
1653                                                  }
1654                                                  
1655                                                  sub make_slave_of_sibling {
1656  ***      0                    0                    my ( $self, $slave_dbh, $slave_dsn, $sib_dbh, $sib_dsn,
1657                                                          $dsn_parser, $timeout) = @_;
1658                                                  
1659  ***      0      0                                  if ( $self->short_host($slave_dsn) eq $self->short_host($sib_dsn) ) {
1660  ***      0                                            die "You are trying to make the slave a slave of itself";
1661                                                     }
1662                                                  
1663  ***      0      0                                  my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
1664                                                        or die "This server is not a slave";
1665  ***      0                                         my $master_dbh1 = $dsn_parser->get_dbh(
1666                                                        $dsn_parser->get_cxn_params($master_dsn1), { AutoCommit => 1 });
1667  ***      0      0                                  my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
1668                                                        or die "The sibling is not a slave";
1669  ***      0      0                                  if ( $self->short_host($master_dsn1) ne $self->short_host($master_dsn2) ) {
1670  ***      0                                            die "This server isn't a sibling of the slave";
1671                                                     }
1672  ***      0      0                                  my $sib_master_stat = $self->get_master_status($sib_dbh)
1673                                                        or die "Binary logging is not enabled on the sibling";
1674  ***      0      0                                  die "The log_slave_updates option is not enabled on the sibling"
1675                                                        unless $self->has_slave_updates($sib_dbh);
1676                                                  
1677  ***      0                                         $self->catchup_to_same_pos($slave_dbh, $sib_dbh);
1678                                                  
1679  ***      0                                         $sib_master_stat = $self->get_master_status($sib_dbh);
1680  ***      0                                         $self->change_master_to($slave_dbh, $sib_dsn,
1681                                                           $self->repl_posn($sib_master_stat));
1682                                                  
1683  ***      0                                         my $slave_status = $self->get_slave_status($slave_dbh);
1684  ***      0                                         my $slave_pos    = $self->repl_posn($slave_status);
1685  ***      0                                         $sib_master_stat = $self->get_master_status($sib_dbh);
1686  ***      0      0      0                           if ( $self->short_host($slave_status) ne $self->short_host($sib_dsn)
1687                                                       || $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
1688                                                     {
1689  ***      0                                            die "After changing the slave's master, it isn't a slave of the sibling, "
1690                                                           . "or it has a different replication position than the sibling";
1691                                                     }
1692                                                  }
1693                                                  
1694                                                  sub make_slave_of_uncle {
1695  ***      0                    0                    my ( $self, $slave_dbh, $slave_dsn, $unc_dbh, $unc_dsn,
1696                                                          $dsn_parser, $timeout) = @_;
1697                                                  
1698  ***      0      0                                  if ( $self->short_host($slave_dsn) eq $self->short_host($unc_dsn) ) {
1699  ***      0                                            die "You are trying to make the slave a slave of itself";
1700                                                     }
1701                                                  
1702  ***      0      0                                  my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
1703                                                        or die "This server is not a slave";
1704  ***      0                                         my $master_dbh = $dsn_parser->get_dbh(
1705                                                        $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
1706  ***      0      0                                  my $gmaster_dsn
1707                                                        = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
1708                                                        or die "The master is not a slave";
1709  ***      0      0                                  my $unc_master_dsn
1710                                                        = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
1711                                                        or die "The uncle is not a slave";
1712  ***      0      0                                  if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn)) {
1713  ***      0                                            die "The uncle isn't really the slave's uncle";
1714                                                     }
1715                                                  
1716  ***      0      0                                  my $unc_master_stat = $self->get_master_status($unc_dbh)
1717                                                        or die "Binary logging is not enabled on the uncle";
1718  ***      0      0                                  die "The log_slave_updates option is not enabled on the uncle"
1719                                                        unless $self->has_slave_updates($unc_dbh);
1720                                                  
1721  ***      0                                         $self->catchup_to_same_pos($master_dbh, $unc_dbh);
1722  ***      0                                         $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
1723                                                  
1724  ***      0                                         my $slave_status  = $self->get_slave_status($slave_dbh);
1725  ***      0                                         my $master_status = $self->get_master_status($master_dbh);
1726  ***      0      0                                  if ( $self->pos_cmp(
1727                                                           $self->repl_posn($slave_status),
1728                                                           $self->repl_posn($master_status)) != 0 )
1729                                                     {
1730  ***      0                                            die "The slave is not caught up to its master";
1731                                                     }
1732                                                  
1733  ***      0                                         $unc_master_stat = $self->get_master_status($unc_dbh);
1734  ***      0                                         $self->change_master_to($slave_dbh, $unc_dsn,
1735                                                        $self->repl_posn($unc_master_stat));
1736                                                  
1737                                                  
1738  ***      0                                         $slave_status    = $self->get_slave_status($slave_dbh);
1739  ***      0                                         my $slave_pos    = $self->repl_posn($slave_status);
1740  ***      0      0      0                           if ( $self->short_host($slave_status) ne $self->short_host($unc_dsn)
1741                                                       || $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
1742                                                     {
1743  ***      0                                            die "After changing the slave's master, it isn't a slave of the uncle, "
1744                                                           . "or it has a different replication position than the uncle";
1745                                                     }
1746                                                  }
1747                                                  
1748                                                  sub detach_slave {
1749  ***      0                    0                    my ( $self, $dbh ) = @_;
1750  ***      0                                         $self->stop_slave($dbh);
1751  ***      0      0                                  my $stat = $self->get_slave_status($dbh)
1752                                                        or die "This server is not a slave";
1753  ***      0                                         $dbh->do('CHANGE MASTER TO MASTER_HOST=""');
1754  ***      0                                         $dbh->do('RESET SLAVE'); # Wipes out master.info, etc etc
1755  ***      0                                         return $stat;
1756                                                  }
1757                                                  
1758                                                  sub slave_is_running {
1759  ***      0                    0                    my ( $self, $slave_status ) = @_;
1760  ***      0             0                           return ($slave_status->{slave_sql_running} || 'No') eq 'Yes';
1761                                                  }
1762                                                  
1763                                                  sub has_slave_updates {
1764  ***      0                    0                    my ( $self, $dbh ) = @_;
1765  ***      0                                         my $sql = q{SHOW VARIABLES LIKE 'log_slave_updates'};
1766  ***      0                                         MKDEBUG && _d($dbh, $sql);
1767  ***      0                                         my ($name, $value) = $dbh->selectrow_array($sql);
1768  ***      0             0                           return $value && $value =~ m/^(1|ON)$/;
1769                                                  }
1770                                                  
1771                                                  sub repl_posn {
1772  ***      0                    0                    my ( $self, $status ) = @_;
1773  ***      0      0      0                           if ( exists $status->{file} && exists $status->{position} ) {
1774                                                        return {
1775  ***      0                                               file     => $status->{file},
1776                                                           position => $status->{position},
1777                                                        };
1778                                                     }
1779                                                     else {
1780                                                        return {
1781  ***      0                                               file     => $status->{relay_master_log_file},
1782                                                           position => $status->{exec_master_log_pos},
1783                                                        };
1784                                                     }
1785                                                  }
1786                                                  
1787                                                  sub get_slave_lag {
1788  ***      0                    0                    my ( $self, $dbh ) = @_;
1789  ***      0                                         my $stat = $self->get_slave_status($dbh);
1790  ***      0                                         return $stat->{seconds_behind_master};
1791                                                  }
1792                                                  
1793                                                  sub pos_cmp {
1794  ***      0                    0                    my ( $self, $a, $b ) = @_;
1795  ***      0                                         return $self->pos_to_string($a) cmp $self->pos_to_string($b);
1796                                                  }
1797                                                  
1798                                                  sub short_host {
1799  ***      0                    0                    my ( $self, $dsn ) = @_;
1800  ***      0                                         my ($host, $port);
1801  ***      0      0                                  if ( $dsn->{master_host} ) {
1802  ***      0                                            $host = $dsn->{master_host};
1803  ***      0                                            $port = $dsn->{master_port};
1804                                                     }
1805                                                     else {
1806  ***      0                                            $host = $dsn->{h};
1807  ***      0                                            $port = $dsn->{P};
1808                                                     }
1809  ***      0      0      0                           return ($host || '[default]') . ( ($port || 3306) == 3306 ? '' : ":$port" );
      ***                    0                        
1810                                                  }
1811                                                  
1812                                                  sub pos_to_string {
1813  ***      0                    0                    my ( $self, $pos ) = @_;
1814  ***      0                                         my $fmt  = '%s/%020d';
1815  ***      0                                         return sprintf($fmt, @{$pos}{qw(file position)});
      ***      0                                      
1816                                                  }
1817                                                  
1818                                                  sub _d {
1819  ***      0                    0                    my ($package, undef, $line) = caller 0;
1820  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1821  ***      0                                              map { defined $_ ? $_ : 'undef' }
1822                                                          @_;
1823  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1824                                                  }
1825                                                  
1826                                                  1;
1827                                                  
1828                                                  # ###########################################################################
1829                                                  # End MasterSlave package
1830                                                  # ###########################################################################
1831                                                  
1832                                                  # ###########################################################################
1833                                                  # Daemon package 5266
1834                                                  # ###########################################################################
1835                                                  
1836                                                  package Daemon;
1837                                                  
1838           1                    1            14   use strict;
               1                                  3   
               1                                 13   
1839           1                    1             7   use warnings FATAL => 'all';
               1                                  3   
               1                                  8   
1840                                                  
1841           1                    1             6   use POSIX qw(setsid);
               1                                  2   
               1                                  7   
1842           1                    1             6   use English qw(-no_match_vars);
               1                                  4   
               1                                  7   
1843                                                  
1844  ***      1            50      1            12   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 18   
1845                                                  
1846                                                  sub new {
1847  ***      0                    0                    my ( $class, %args ) = @_;
1848  ***      0                                         foreach my $arg ( qw(o) ) {
1849  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
1850                                                     }
1851  ***      0                                         my $o = $args{o};
1852  ***      0      0                                  my $self = {
      ***             0                               
1853                                                        o        => $o,
1854                                                        log_file => $o->has('log') ? $o->get('log') : undef,
1855                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
1856                                                     };
1857                                                  
1858  ***      0                                         check_PID_file(undef, $self->{PID_file});
1859                                                  
1860  ***      0                                         MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
1861  ***      0                                         return bless $self, $class;
1862                                                  }
1863                                                  
1864                                                  sub daemonize {
1865  ***      0                    0                    my ( $self ) = @_;
1866                                                  
1867  ***      0                                         MKDEBUG && _d('About to fork and daemonize');
1868  ***      0      0                                  defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
1869  ***      0      0                                  if ( $pid ) {
1870  ***      0                                            MKDEBUG && _d('I am the parent and now I die');
1871  ***      0                                            exit;
1872                                                     }
1873                                                  
1874  ***      0                                         $self->{child} = 1;
1875                                                  
1876  ***      0      0                                  POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
1877  ***      0      0                                  chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
1878                                                  
1879  ***      0                                         $self->_make_PID_file();
1880                                                  
1881  ***      0                                         $OUTPUT_AUTOFLUSH = 1;
1882                                                  
1883  ***      0      0                                  if ( -t STDIN ) {
1884  ***      0                                            close STDIN;
1885  ***      0      0                                     open  STDIN, '/dev/null'
1886                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
1887                                                     }
1888                                                  
1889  ***      0      0                                  if ( $self->{log_file} ) {
1890  ***      0                                            close STDOUT;
1891  ***      0      0                                     open  STDOUT, '>>', $self->{log_file}
1892                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
1893                                                  
1894  ***      0                                            close STDERR;
1895  ***      0      0                                     open  STDERR, ">&STDOUT"
1896                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
1897                                                     }
1898                                                     else {
1899  ***      0      0                                     if ( -t STDOUT ) {
1900  ***      0                                               close STDOUT;
1901  ***      0      0                                        open  STDOUT, '>', '/dev/null'
1902                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
1903                                                        }
1904  ***      0      0                                     if ( -t STDERR ) {
1905  ***      0                                               close STDERR;
1906  ***      0      0                                        open  STDERR, '>', '/dev/null'
1907                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
1908                                                        }
1909                                                     }
1910                                                  
1911  ***      0                                         MKDEBUG && _d('I am the child and now I live daemonized');
1912  ***      0                                         return;
1913                                                  }
1914                                                  
1915                                                  sub check_PID_file {
1916  ***      0                    0                    my ( $self, $file ) = @_;
1917  ***      0      0                                  my $PID_file = $self ? $self->{PID_file} : $file;
1918  ***      0                                         MKDEBUG && _d('Checking PID file', $PID_file);
1919  ***      0      0      0                           if ( $PID_file && -f $PID_file ) {
1920  ***      0                                            my $pid;
1921  ***      0                                            eval { chomp($pid = `cat $PID_file`); };
      ***      0                                      
1922  ***      0      0                                     die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
1923  ***      0                                            MKDEBUG && _d('PID file exists; it contains PID', $pid);
1924  ***      0      0                                     if ( $pid ) {
1925  ***      0                                               my $pid_is_alive = kill 0, $pid;
1926  ***      0      0                                        if ( $pid_is_alive ) {
1927  ***      0                                                  die "The PID file $PID_file already exists "
1928                                                                 . " and the PID that it contains, $pid, is running";
1929                                                           }
1930                                                           else {
1931  ***      0                                                  warn "Overwriting PID file $PID_file because the PID that it "
1932                                                                 . "contains, $pid, is not running";
1933                                                           }
1934                                                        }
1935                                                        else {
1936  ***      0                                               die "The PID file $PID_file already exists but it does not "
1937                                                              . "contain a PID";
1938                                                        }
1939                                                     }
1940                                                     else {
1941  ***      0                                            MKDEBUG && _d('No PID file');
1942                                                     }
1943  ***      0                                         return;
1944                                                  }
1945                                                  
1946                                                  sub make_PID_file {
1947  ***      0                    0                    my ( $self ) = @_;
1948  ***      0      0                                  if ( exists $self->{child} ) {
1949  ***      0                                            die "Do not call Daemon::make_PID_file() for daemonized scripts";
1950                                                     }
1951  ***      0                                         $self->_make_PID_file();
1952  ***      0                                         $self->{rm_PID_file} = 1;
1953  ***      0                                         return;
1954                                                  }
1955                                                  
1956                                                  sub _make_PID_file {
1957  ***      0                    0                    my ( $self ) = @_;
1958                                                  
1959  ***      0                                         my $PID_file = $self->{PID_file};
1960  ***      0      0                                  if ( !$PID_file ) {
1961  ***      0                                            MKDEBUG && _d('No PID file to create');
1962  ***      0                                            return;
1963                                                     }
1964                                                  
1965  ***      0                                         $self->check_PID_file();
1966                                                  
1967  ***      0      0                                  open my $PID_FH, '>', $PID_file
1968                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
1969  ***      0      0                                  print $PID_FH $PID
1970                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
1971  ***      0      0                                  close $PID_FH
1972                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
1973                                                  
1974  ***      0                                         MKDEBUG && _d('Created PID file:', $self->{PID_file});
1975  ***      0                                         return;
1976                                                  }
1977                                                  
1978                                                  sub _remove_PID_file {
1979  ***      0                    0                    my ( $self ) = @_;
1980  ***      0      0      0                           if ( $self->{PID_file} && -f $self->{PID_file} ) {
1981  ***      0      0                                     unlink $self->{PID_file}
1982                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
1983  ***      0                                            MKDEBUG && _d('Removed PID file');
1984                                                     }
1985                                                     else {
1986  ***      0                                            MKDEBUG && _d('No PID to remove');
1987                                                     }
1988  ***      0                                         return;
1989                                                  }
1990                                                  
1991                                                  sub DESTROY {
1992  ***      0                    0                    my ( $self ) = @_;
1993  ***      0      0      0                           $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
1994  ***      0                                         return;
1995                                                  }
1996                                                  
1997                                                  sub _d {
1998  ***      0                    0                    my ($package, undef, $line) = caller 0;
1999  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2000  ***      0                                              map { defined $_ ? $_ : 'undef' }
2001                                                          @_;
2002  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2003                                                  }
2004                                                  
2005                                                  1;
2006                                                  
2007                                                  # ###########################################################################
2008                                                  # End Daemon package
2009                                                  # ###########################################################################
2010                                                  
2011                                                  # ###########################################################################
2012                                                  # This is a combination of modules and programs in one -- a runnable module.
2013                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
2014                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
2015                                                  #
2016                                                  # Check at the end of this package for the call to main() which actually runs
2017                                                  # the program.
2018                                                  # ###########################################################################
2019                                                  package mk_slave_find;
2020                                                  
2021           1                    1            12   use English qw(-no_match_vars);
               1                                  3   
               1                                  7   
2022                                                  
2023  ***      1            50      1            17   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 21   
2024                                                  
2025                                                  sub main {
2026  ***      0                    0                    @ARGV = @_;  # set global ARGV for this package
2027                                                  
2028                                                     # ########################################################################
2029                                                     # Get configuration information.
2030                                                     # ########################################################################
2031  ***      0                                         my $dp = new DSNParser();
2032  ***      0                                         my $o  = new OptionParser(
2033                                                        strict      => 0,
2034                                                        description => 'finds and prints a hierarchy tree of MySQL slaves.',
2035                                                        prompt      => '[OPTIONS] MASTER-HOST',
2036                                                        dp          => $dp,
2037                                                     );
2038  ***      0                                         $o->get_specs();
2039  ***      0                                         $o->get_opts();
2040                                                  
2041  ***      0                                         $dp->prop('set-vars', $o->get('set-vars'));
2042                                                  
2043  ***      0      0                                  if ( $o->get('ask-pass') ) {
2044  ***      0                                            $o->set('password', OptionParser::prompt_noecho("Enter password: "));
2045                                                     }
2046                                                  
2047  ***      0                                         my $dsn_defaults = $dp->parse_options($o);
2048  ***      0      0                                  my $master_dsn   = @ARGV ? $dp->parse(shift @ARGV, $dsn_defaults)
2049                                                                              : $dsn_defaults;
2050  ***      0      0                                  if ( !$master_dsn ) { 
2051  ***      0                                            $o->save_error("Missing or invalid master host");
2052                                                     }
2053                                                  
2054  ***      0                                         $o->usage_or_errors();
2055                                                  
2056                                                     # ########################################################################
2057                                                     # If --pid, check it first since we'll die if it already exits.
2058                                                     # ########################################################################
2059  ***      0                                         my $daemon;
2060  ***      0      0                                  if ( $o->get('pid') ) {
2061                                                        # We're not daemoninzing, it just handles PID stuff.  Keep $daemon
2062                                                        # in the the scope of main() because when it's destroyed it automatically
2063                                                        # removes the PID file.
2064  ***      0                                            $daemon = new Daemon(o=>$o);
2065  ***      0                                            $daemon->make_PID_file();
2066                                                     }
2067                                                  
2068                                                     # ########################################################################
2069                                                     # Connect and go to work.
2070                                                     # ########################################################################
2071  ***      0                                         my $dbh = $dp->get_dbh($dp->get_cxn_params($master_dsn), {AutoCommit => 1});
2072                                                  
2073  ***      0                                         my $exit_status = 0;
2074  ***      0                                         my %slaves_found;
2075  ***      0                                         my $root;
2076                                                  
2077                                                     # Despite the name, recursing to slaves actually begins at the specified
2078                                                     # server, so the named server may also be included.
2079  ***      0                                         my $ms = new MasterSlave();
2080                                                     $ms->recurse_to_slaves(
2081                                                        {  dbh        => $dbh,
2082                                                           dsn        => $master_dsn,
2083                                                           dsn_parser => $dp,
2084                                                           recurse    => $o->get('recurse'),
2085                                                           callback   => sub {
2086  ***      0                    0                             my ( $dsn, $dbh, $level, $parent ) = @_;
2087  ***      0      0                                           if ( !$parent ) {
2088  ***      0                                                     $root = $dsn;
2089                                                              }
2090                                                              else {
2091  ***      0                                                     my $p = $slaves_found{$dp->as_string($parent)};
2092  ***      0                                                     push @{$p->{children}}, $dsn;
      ***      0                                      
2093                                                              }
2094  ***      0                                                  $slaves_found{$dp->as_string($dsn)} = $dsn;
2095                                                           },
2096  ***      0                                               method => $o->get('recursion-method'),
2097                                                        }
2098                                                     );
2099                                                  
2100                                                     # If the user relied on values from the defaults file, the $root hostname
2101                                                     # might not be defined.  Try to fill it in.
2102  ***      0             0                           $root->{h} ||= $dp->get_hostname($dbh);
2103                                                  
2104                                                     # Now that we've found them all, recurse through them and do stuff!
2105  ***      0                                         print_slaves($ms, $root);
2106                                                  
2107  ***      0                                         return 0;
2108                                                  }
2109                                                  
2110                                                  # ############################################################################
2111                                                  # Subroutines
2112                                                  # ############################################################################
2113                                                  
2114                                                  # Print master and slaves in a tree like:
2115                                                  #    master:port
2116                                                  #    +- slave1:port
2117                                                  #       +- slave1-1:port
2118                                                  #    +- slave2:port
2119                                                  # The levels are thus:
2120                                                  #    0
2121                                                  #    +- 1
2122                                                  #       +- 2
2123                                                  #    +- 1
2124                                                  sub print_slaves {
2125  ***      0                    0                    my ( $ms, $node, $level ) = @_;
2126  ***      0      0                                  die "I need a node" unless $node;
2127  ***      0             0                           $level ||= 0;
2128                                                  
2129                                                     # Strip out the noise.  We really only need to see the host and port, and if
2130                                                     # the port is default, we don't even need to see that.
2131  ***      0                                         my $host   = $ms->short_host($node);
2132  ***      0      0                                  my $prefix = $level ? (' ' x (($level-1)*3) . '+- ') : '';
2133                                                  
2134  ***      0                                         MKDEBUG && _d('level', $level, 'host', $host);
2135  ***      0                                         print "$prefix$host\n";
2136                                                  
2137  ***      0      0                                  if ( $node->{children} ) {
2138  ***      0                                            my @slaves = reverse @{$node->{children}};
      ***      0                                      
2139  ***      0                                            foreach my $slave ( @slaves ) {
2140  ***      0                                               print_slaves($ms, $slave, $level + 1);
2141                                                        }
2142                                                     }
2143                                                  
2144  ***      0                                         return;
2145                                                  }
2146                                                  
2147                                                  sub _d {
2148  ***      0                    0                    my ($package, undef, $line) = caller 0;
2149  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2150  ***      0                                              map { defined $_ ? $_ : 'undef' }
2151                                                          @_;
2152  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2153                                                  }
2154                                                  
2155                                                  # ############################################################################
2156                                                  # Run the program.
2157                                                  # ############################################################################
2158                                                  if ( !caller ) { exit main(@ARGV); }
2159                                                  
2160                                                  1; # Because this is a module as well as a script.
2161                                                  
2162                                                  # ############################################################################
2163                                                  # Documentation.
2164                                                  # ############################################################################
2165                                                  
2166                                                  =pod
2167                                                  
2168                                                  =head1 NAME
2169                                                  
2170                                                  mk-slave-find - Find and print replication hierarchy tree of MySQL slaves.
2171                                                  
2172                                                  =head1 SYNOPSIS
2173                                                  
2174                                                     mk-slave-find --host master-host
2175                                                  
2176                                                  =head1 RISKS
2177                                                  
2178                                                  The following section is included to inform users about the potential risks,
2179                                                  whether known or unknown, of using this tool.  The two main categories of risks
2180                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
2181                                                  tools) and those created by bugs.
2182                                                  
2183                                                  mk-slave-find is read-only and very low-risk.
2184                                                  
2185                                                  At the time of this release, we know of no bugs that could cause serious harm to
2186                                                  users.
2187                                                  
2188                                                  The authoritative source for updated information is always the online issue
2189                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
2190                                                  see a list of such issues at the following URL:
2191                                                  L<http://www.maatkit.org/bugs/mk-slave-find>.
2192                                                  
2193                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
2194                                                  
2195                                                  =head1 DESCRIPTION
2196                                                  
2197                                                  mk-slave-find connects to a MySQL replication master and finds its slaves.
2198                                                  Currently the only thing it can do is print a tree-like view of the replication
2199                                                  hierarchy.
2200                                                  
2201                                                  The master host can be specified using one of two methods.  The first method is
2202                                                  to use the standard connection-related command line options:
2203                                                  L<"--defaults-file">, L<"--password">, L<"--host">, L<"--port">, L<"--socket">
2204                                                  or L<"--user">.
2205                                                  
2206                                                  The second method to specifiy the master host is a DSN.  A DSN is a special
2207                                                  syntax that can be either just a hostname (like C<server.domain.com> or
2208                                                  C<1.2.3.4>), or a C<key=value,key=value> string. Keys are a single letter:
2209                                                  
2210                                                     KEY MEANING
2211                                                     === =======
2212                                                     h   Connect to host
2213                                                     P   Port number to use for connection
2214                                                     S   Socket file to use for connection
2215                                                     u   User for login if not current user
2216                                                     p   Password to use when connecting
2217                                                     F   Only read default options from the given file
2218                                                  
2219                                                  C<mk-slave-find> reads all normal MySQL option files, such as ~/.my.cnf, so
2220                                                  you may not need to specify username, password and other common options at all.
2221                                                  
2222                                                  =head1 EXIT STATUS
2223                                                  
2224                                                  Successful exit status is 0.  Any other value represents the exit status of
2225                                                  the Perl process itself.
2226                                                  
2227                                                  =head1 OPTIONS
2228                                                  
2229                                                  =over
2230                                                  
2231                                                  =item --ask-pass
2232                                                  
2233                                                  Prompt for a password when connecting to MySQL.
2234                                                  
2235                                                  =item --charset
2236                                                  
2237                                                  short form: -A; type: string
2238                                                  
2239                                                  Default character set.  If the value is utf8, sets Perl's binmode on
2240                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
2241                                                  runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
2242                                                  binmode on STDOUT without the utf8 layer, and runs SET NAMES after
2243                                                  connecting to MySQL.
2244                                                  
2245                                                  =item --config
2246                                                  
2247                                                  type: Array
2248                                                  
2249                                                  Read this comma-separated list of config files; if specified, this must be the
2250                                                  first option on the command line.
2251                                                  
2252                                                  =item --database
2253                                                  
2254                                                  short form: -D
2255                                                  
2256                                                  Database to use.
2257                                                  
2258                                                  =item --defaults-file
2259                                                  
2260                                                  short form: -F; type: string
2261                                                  
2262                                                  Only read mysql options from the given file.  You must give an absolute
2263                                                  pathname.
2264                                                  
2265                                                  =item --help
2266                                                  
2267                                                  Show help and exit.
2268                                                  
2269                                                  =item --host
2270                                                  
2271                                                  short form: -h; type: string
2272                                                  
2273                                                  Connect to host.
2274                                                  
2275                                                  =item --password
2276                                                  
2277                                                  short form: -p; type: string
2278                                                  
2279                                                  Password to use when connecting.
2280                                                  
2281                                                  =item --pid
2282                                                  
2283                                                  type: string
2284                                                  
2285                                                  Create the given PID file.  The file contains the process ID of the script.
2286                                                  The PID file is removed when the script exits.  Before starting, the script
2287                                                  checks if the PID file already exists.  If it does not, then the script creates
2288                                                  and writes its own PID to it.  If it does, then the script checks the following:
2289                                                  if the file contains a PID and a process is running with that PID, then
2290                                                  the script dies; or, if there is no process running with that PID, then the
2291                                                  script overwrites the file with its own PID and starts; else, if the file
2292                                                  contains no PID, then the script dies.
2293                                                  
2294                                                  =item --port
2295                                                  
2296                                                  short form: -P; type: int
2297                                                  
2298                                                  Port number to use for connection.
2299                                                  
2300                                                  =item --recurse
2301                                                  
2302                                                  Number of levels to recurse in the hierarchy.  Default is infinite.
2303                                                  
2304                                                  See L<"--recursion-method">.
2305                                                  
2306                                                  =item --recursion-method
2307                                                  
2308                                                  type: string
2309                                                  
2310                                                  Preferred recursion method used to find slaves.
2311                                                  
2312                                                  Possible methods are:
2313                                                  
2314                                                    METHOD       USES
2315                                                    ===========  ================
2316                                                    processlist  SHOW PROCESSLIST
2317                                                    hosts        SHOW SLAVE HOSTS
2318                                                  
2319                                                  The processlist method is preferred because SHOW SLAVE HOSTS is not reliable.
2320                                                  However, the hosts method is required if the server uses a non-standard
2321                                                  port (not 3306).  Usually mk-slave-find does the right thing and finds
2322                                                  the slaves, but you may give a preferred method and it will be used first.
2323                                                  If it doesn't find any slaves, the other methods will be tried.
2324                                                  
2325                                                  =item --set-vars
2326                                                  
2327                                                  type: string; default: wait_timeout=10000
2328                                                  
2329                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this
2330                                                  string will be appended to SET and executed.
2331                                                  
2332                                                  =item --socket
2333                                                  
2334                                                  short form: -S; type: string
2335                                                  
2336                                                  Socket file to use for connection.
2337                                                  
2338                                                  =item --user
2339                                                  
2340                                                  short form: -u; type: string
2341                                                  
2342                                                  User for login if not current user.
2343                                                  
2344                                                  =item --version
2345                                                  
2346                                                  Show version and exit.
2347                                                  
2348                                                  =back
2349                                                  
2350                                                  =head1 DOWNLOADING
2351                                                  
2352                                                  You can download Maatkit from Google Code at
2353                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
2354                                                  easily with a command like the following:
2355                                                  
2356                                                     wget http://www.maatkit.org/get/toolname
2357                                                     or
2358                                                     wget http://www.maatkit.org/trunk/toolname
2359                                                  
2360                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
2361                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
2362                                                  needed.  The first URL gets the latest released version of the tool, and the
2363                                                  second gets the latest trunk code from Subversion.
2364                                                  
2365                                                  =head1 ENVIRONMENT
2366                                                  
2367                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
2368                                                  the Maatkit tools:
2369                                                  
2370                                                     MKDEBUG=1 mk-....
2371                                                  
2372                                                  =head1 SYSTEM REQUIREMENTS
2373                                                  
2374                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
2375                                                  installed in any reasonably new version of Perl.
2376                                                  
2377                                                  =head1 BUGS
2378                                                  
2379                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-slave-find>.
2380                                                  
2381                                                  Please use Google Code Issues and Groups to report bugs or request support:
2382                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
2383                                                  discuss Maatkit.
2384                                                  
2385                                                  Please include the complete command-line used to reproduce the problem you are
2386                                                  seeing, the version of all MySQL servers involved, the complete output of the
2387                                                  tool when run with L<"--version">, and if possible, debugging output produced by
2388                                                  running with the C<MKDEBUG=1> environment variable.
2389                                                  
2390                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
2391                                                  
2392                                                  This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
2393                                                  Feedback and improvements are welcome.
2394                                                  
2395                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
2396                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
2397                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
2398                                                  
2399                                                  This program is free software; you can redistribute it and/or modify it under
2400                                                  the terms of the GNU General Public License as published by the Free Software
2401                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
2402                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
2403                                                  licenses.
2404                                                  
2405                                                  You should have received a copy of the GNU General Public License along with
2406                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
2407                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
2408                                                  
2409                                                  =head1 AUTHOR
2410                                                  
2411                                                  Baron Schwartz
2412                                                  
2413                                                  =head1 ABOUT MAATKIT
2414                                                  
2415                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
2416                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
2417                                                  code contributors.  Both are employed by Percona.  Financial support for
2418                                                  Maatkit development is primarily provided by Percona and its clients. 
2419                                                  
2420                                                  =head1 VERSION
2421                                                  
2422                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5425 $.
2423                                                  
2424                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
58    ***      0      0      0   unless $args{$arg}
64    ***      0      0      0   exists $args{'strict'} ? :
107   ***      0      0      0   unless open my $fh, '<', $file
127   ***      0      0      0   unless $para =~ /^=head1 OPTIONS/
132   ***      0      0      0   if $para =~ /^=over/
140   ***      0      0      0   unless $para
143   ***      0      0      0   if (my($option) = $para =~ /^=item --(.*)/)
150   ***      0      0      0   if ($para =~ /: /) { }
154   ***      0      0      0   unless $attributes{$attrib}
158   ***      0      0      0   if ($attribs{'short form'})
174   ***      0      0      0   if $para =~ /^=item/
176   ***      0      0      0   if (my($base_option) = $option =~ /^\[no\](.*)/)
181   ***      0      0      0   $attribs{'short form'} ? :
      ***      0      0      0   $attribs{'negatable'} ? :
      ***      0      0      0   $attribs{'cumulative'} ? :
      ***      0      0      0   $attribs{'type'} ? :
      ***      0      0      0   $attribs{'default'} ? :
      ***      0      0      0   $attribs{'group'} ? :
193   ***      0      0      0   unless $para
196   ***      0      0      0   if ($para =~ /^=head1/)
200   ***      0      0      0   if $para =~ /^=item --/
204   ***      0      0      0   unless @specs
215   ***      0      0      0   if (ref $opt) { }
220   ***      0      0      0   if (not $long)
225   ***      0      0      0   if exists $$self{'opts'}{$long}
228   ***      0      0      0   if (length $long == 1)
233   ***      0      0      0   if ($short) { }
234   ***      0      0      0   if exists $$self{'short_opts'}{$short}
243   ***      0      0      0   $$opt{'spec'} =~ /!/ ? :
244   ***      0      0      0   $$opt{'spec'} =~ /\+/ ? :
245   ***      0      0      0   $$opt{'desc'} =~ /required/ ? :
257   ***      0      0      0   if ($type and $type eq 'd' and not $$self{'dp'})
262   ***      0      0      0   if $type and $type =~ /[HhAadzm]/
264   ***      0      0      0   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
265   ***      0      0      0   defined $def ? :
269   ***      0      0      0   if ($long eq 'config')
273   ***      0      0      0   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
286   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
291   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
296   ***      0      0      0   if ($opt =~ /default to/)
301   ***      0      0      0   if ($opt =~ /restricted to option groups/)
311   ***      0      0      0   unless $rule_ok
328   ***      0      0      0   unless exists $$self{'opts'}{$long}
352   ***      0      0      0   unless exists $$self{'opts'}{$long}
372   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***      0      0      0   exists $$self{'opts'}{$opt} ? :
377   ***      0      0      0   if ($$opt{'is_cumulative'}) { }
392   ***      0      0      0   $$self{'opts'}{$long}{'is_cumulative'} ? :
      ***      0      0      0   exists $$self{'defaults'}{$long} ? :
401   ***      0      0      0   if (@ARGV and $ARGV[0] eq '--config')
405   ***      0      0      0   if ($self->has('config'))
411   ***      0      0      0   if ($EVAL_ERROR)
412   ***      0      0      0   $self->got('config') ? :
427   ***      0      0      0   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
430   ***      0      0      0   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
431   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
437   ***      0      0      0   if (@ARGV and $$self{'strict'})
443   ***      0      0      0   if (@set > 1)
454   ***      0      0      0   if (@set == 0)
464   ***      0      0      0   if ($$opt{'got'}) { }
      ***      0      0      0   elsif ($$opt{'is_required'}) { }
465   ***      0      0      0   if (exists $$self{'disables'}{$long})
472   ***      0      0      0   if (exists $$self{'allowed_groups'}{$long})
484   ***      0      0      0   if $restricted_opt eq $long
485   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
490   ***      0      0      0   if (@restricted_opts)
492   ***      0      0      0   if (@restricted_opts == 1) { }
521   ***      0      0      0   unless $opt and $$opt{'type'}
524   ***      0      0      0   if ($val and $$opt{'type'} eq 'm') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'd') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'z') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
527   ***      0      0      0   if (not $suffix)
533   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
534   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
549   ***      0      0      0   if ($from_key)
560   ***      0      0      0   if (defined $num) { }
561   ***      0      0      0   if ($factor)
588   ***      0      0      0   length $opt == 1 ? :
589   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
596   ***      0      0      0   length $opt == 1 ? :
597   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
604   ***      0      0      0   length $opt == 1 ? :
605   ***      0      0      0   defined $long ? :
610   ***      0      0      0   length $opt == 1 ? :
611   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
645   ***      0      0      0   if ($$self{'opts'}{'help'}{'got'}) { }
      ***      0      0      0   elsif (scalar @{$$self{'errors'};}) { }
646   ***      0      0      0   unless print $self->print_usage
650   ***      0      0      0   unless print $self->print_errors
659   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
668   ***      0      0      0   unless $$self{'got_opts'}
671   ***      0      0      0   $$_{'is_negatable'} ? :
675   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
691   ***      0      0      0   $group eq 'default' ? :
697   ***      0      0      0   $$opt{'is_negatable'} ? :
700   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
709   ***      0      0      0   if ($short) { }
718   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
722   ***      0      0      0   if ($$self{'dp'})
730   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
742   ***      0      0      0   if ref $_[0] eq 'OptionParser'
745   ***      0      0      0   unless print $prompt
753   ***      0      0      0   unless print "\n"
756   ***      0      0      0   if ($EVAL_ERROR)
778   ***      0      0      0   unless open my $fh, '<', $filename
786   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
789   ***      0      0      0   if ($line eq '--')
794   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
812   ***      0      0      0   unless open my $fh, '<', $file
816   ***      0      0      0   unless $para =~ /^=pod$/m
820   ***      0      0      0   unless $para =~ /$regex/
825   ***      0      0      0   unless close $fh
839   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
854   ***      0      0      0   defined $_ ? :
940   ***     50      0      9   if (@_ > 2)
949   ***     50      0      3   if (not $dsn)
961   ***     50     12      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
973   ***     50      0     24   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
979          100     12     12   if (not defined $final_props{$key})
986   ***     50      0     12   unless exists $opts{$key}
989   ***     50      0      3   if (my $required = $self->prop('required'))
991   ***      0      0      0   unless $final_props{$key}
1000  ***      0      0      0   unless ref $o eq 'OptionParser'
1003  ***      0      0      0   if $o->has($_)
1013  ***      0      0      0   unless ref $dsn
1014  ***      0      0      0   $_ eq 'p' ? :
1015  ***      0      0      0   if defined $$dsn{$_}
1028  ***      0      0      0   $opts{$key}{'copy'} ? :
1042  ***     50      0      3   if ($driver eq 'Pg') { }
1074  ***     50      0      3   $cxn_string =~ /charset=utf8/ ? :
1083  ***     50      0      3   if (not $have_dbi)
1102  ***     50      3      0   if ($cxn_string =~ /mysql/i)
1110  ***     50      0      3   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1115  ***      0      0      0   if ($charset eq 'utf8') { }
1116  ***      0      0      0   unless binmode STDOUT, ':utf8'
1120  ***      0      0      0   unless binmode STDOUT
1124  ***     50      0      3   if ($self->prop('set-vars'))
1131  ***     50      0      3   if (not $dbh and $EVAL_ERROR)
1133  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1146  ***      0      0      0   if (not $tries)
1168  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1185  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1195  ***      0      0      0   unless $dsn_1
1196  ***      0      0      0   unless $dsn_2
1200  ***      0      0      0   if ($args{'overwrite'}) { }
1201  ***      0      0      0   defined $$dsn_1{$key} ? :
1204  ***      0      0      0   defined $$dsn_2{$key} ? :
1213  ***      0      0      0   defined $_ ? :
1257  ***      0      0      0   if ($EVAL_ERROR)
1258  ***      0      0      0   unless print STDERR 'Cannot connect to ', $dp->as_string($dsn), "\n"
1268  ***      0      0      0   if (not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++)
1273  ***      0      0      0   if ($$args{'skip_callback'})
1281  ***      0      0      0   if (not defined $$args{'recurse'} or $level < $$args{'recurse'})
1283  ***      0      0      0   unless not $$_{'master_id'}
1300  ***      0      0      0   if ($method) { }
1305  ***      0      0      0   if (($$dsn{'P'} || 3306) != 3306)
1319  ***      0      0      0   if @slaves
1337  ***      0      0      0   if ($host eq 'localhost')
1354  ***      0      0      0   if (@slaves)
1359  ***      0      0      0   $hash{'user'} ? :
      ***      0      0      0   $hash{'password'} ? :
1379  ***      0      0      0   if (not $proc)
1396  ***      0      0      0   unless my $master_status = $self->get_master_status($master)
1398  ***      0      0      0   unless my $slave_status = $self->get_slave_status($slave)
1400  ***      0      0      0   unless my(@connected) = $self->get_connected_slaves($master)
1404  ***      0      0      0   if ($port != $$slave_status{'master_port'})
1409  ***      0      0      0   if (not grep {$$slave_status{'master_user'} eq $$_{'user'};} @connected)
1414  ***      0      0      0   if (($$slave_status{'slave_io_state'} || '') eq 'Waiting for master to send event')
1421  ***      0      0      0   if ($master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1)
1434  ***      0      0      0   unless my $master = $self->get_slave_status($dbh)
1441  ***      0      0      0   if (not $$self{'not_a_slave'}{$dbh})
1448  ***      0      0      0   if ($ss and %$ss)
1460  ***      0      0      0   if (not $$self{'not_a_master'}{$dbh})
1467  ***      0      0      0   if ($ms and %$ms)
1469  ***      0      0      0   if ($$ms{'file'} and $$ms{'position'})
1482  ***      0      0      0   unless defined $time
1486  ***      0      0      0   if ($ms) { }
1490  ***      0      0      0   defined $result ? :
1492  ***      0      0      0   if ($stat eq 'NULL' or $stat < 0 and not $timeoutok)
1512  ***      0      0      0   if ($pos) { }
1536  ***      0      0      0   if ($self->pos_cmp($slave_pos, $master_pos) < 0)
1542  ***      0      0      0   if ($EVAL_ERROR)
1544  ***      0      0      0   if ($EVAL_ERROR =~ /MASTER_POS_WAIT returned NULL/) { }
1546  ***      0      0      0   if (not $self->slave_is_running($slave_status)) { }
1551  ***      0      0      0   if ($self->pos_cmp($slave_pos, $master_pos) != 0)
1575  ***      0      0      0   if ($self->pos_cmp($s1_pos, $s2_pos) < 0) { }
      ***      0      0      0   elsif ($self->pos_cmp($s2_pos, $s1_pos) < 0) { }
1587  ***      0      0      0   if ($self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0)
1610  ***      0      0      0   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
1614  ***      0      0      0   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
1619  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn))
1633  ***      0      0      0   if (not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0) { }
1648  ***      0      0      0   if ($self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0)
1659  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($sib_dsn))
1663  ***      0      0      0   unless my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
1667  ***      0      0      0   unless my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
1669  ***      0      0      0   if ($self->short_host($master_dsn1) ne $self->short_host($master_dsn2))
1672  ***      0      0      0   unless my $sib_master_stat = $self->get_master_status($sib_dbh)
1674  ***      0      0      0   unless $self->has_slave_updates($sib_dbh)
1686  ***      0      0      0   if ($self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
1698  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($unc_dsn))
1702  ***      0      0      0   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
1706  ***      0      0      0   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
1709  ***      0      0      0   unless my $unc_master_dsn = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
1712  ***      0      0      0   if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn))
1716  ***      0      0      0   unless my $unc_master_stat = $self->get_master_status($unc_dbh)
1718  ***      0      0      0   unless $self->has_slave_updates($unc_dbh)
1726  ***      0      0      0   if ($self->pos_cmp($self->repl_posn($slave_status), $self->repl_posn($master_status)) != 0)
1740  ***      0      0      0   if ($self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
1751  ***      0      0      0   unless my $stat = $self->get_slave_status($dbh)
1773  ***      0      0      0   if (exists $$status{'file'} and exists $$status{'position'}) { }
1801  ***      0      0      0   if ($$dsn{'master_host'}) { }
1809  ***      0      0      0   ($port || 3306) == 3306 ? :
1820  ***      0      0      0   defined $_ ? :
1849  ***      0      0      0   unless $args{$arg}
1852  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
1868  ***      0      0      0   unless defined(my $pid = fork)
1869  ***      0      0      0   if ($pid)
1876  ***      0      0      0   unless POSIX::setsid()
1877  ***      0      0      0   unless chdir '/'
1883  ***      0      0      0   if (-t STDIN)
1885  ***      0      0      0   unless open STDIN, '/dev/null'
1889  ***      0      0      0   if ($$self{'log_file'}) { }
1891  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
1895  ***      0      0      0   unless open STDERR, '>&STDOUT'
1899  ***      0      0      0   if (-t STDOUT)
1901  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
1904  ***      0      0      0   if (-t STDERR)
1906  ***      0      0      0   unless open STDERR, '>', '/dev/null'
1917  ***      0      0      0   $self ? :
1919  ***      0      0      0   if ($PID_file and -f $PID_file) { }
1922  ***      0      0      0   if $EVAL_ERROR
1924  ***      0      0      0   if ($pid) { }
1926  ***      0      0      0   if ($pid_is_alive) { }
1948  ***      0      0      0   if (exists $$self{'child'})
1960  ***      0      0      0   if (not $PID_file)
1967  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
1969  ***      0      0      0   unless print $PID_FH $PID
1971  ***      0      0      0   unless close $PID_FH
1980  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
1981  ***      0      0      0   unless unlink $$self{'PID_file'}
1993  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
1999  ***      0      0      0   defined $_ ? :
2043  ***      0      0      0   if ($o->get('ask-pass'))
2048  ***      0      0      0   @ARGV ? :
2050  ***      0      0      0   if (not $master_dsn)
2060  ***      0      0      0   if ($o->get('pid'))
2087  ***      0      0      0   if (not $parent) { }
2126  ***      0      0      0   unless $node
2132  ***      0      0      0   $level ? :
2137  ***      0      0      0   if ($$node{'children'})
2149  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
257   ***      0      0      0      0   $type and $type eq 'd'
      ***      0      0      0      0   $type and $type eq 'd' and not $$self{'dp'}
262   ***      0      0      0      0   $type and $type =~ /[HhAadzm]/
401   ***      0      0      0      0   @ARGV and $ARGV[0] eq '--config'
430   ***      0      0      0      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
437   ***      0      0      0      0   @ARGV and $$self{'strict'}
521   ***      0      0      0      0   $opt and $$opt{'type'}
524   ***      0      0      0      0   $val and $$opt{'type'} eq 'm'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'd'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'z'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'a'
589   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
597   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
611   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
700   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
794   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
973   ***     66     12     12      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33     24      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1095  ***     66      3      0      3   not $dbh and $tries--
1131  ***     33      3      0      0   not $dbh and $EVAL_ERROR
1268  ***      0      0      0      0   defined $master_thinks_i_am and $master_thinks_i_am != $id
1448  ***      0      0      0      0   $ss and %$ss
1467  ***      0      0      0      0   $ms and %$ms
1469  ***      0      0      0      0   $$ms{'file'} and $$ms{'position'}
1492  ***      0      0      0      0   $stat < 0 and not $timeoutok
1633  ***      0      0      0      0   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status)
      ***      0      0      0      0   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0
1768  ***      0      0      0      0   $value && $value =~ /^(1|ON)$/
1773  ***      0      0      0      0   exists $$status{'file'} and exists $$status{'position'}
1919  ***      0      0      0      0   $PID_file and -f $PID_file
1980  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
42    ***     50      0      1   $ENV{'MKDEBUG'} || 0
62    ***      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
64    ***      0      0      0   $args{'prompt'} || '<options>'
      ***      0      0      0   $args{'dp'} || undef
106   ***      0      0      0   $file ||= '/home/daniel/dev/maatkit/mk-slave-find/mk-slave-find'
247   ***      0      0      0   $$opt{'group'} ||= 'default'
529   ***      0      0      0   $s || 's'
538   ***      0      0      0   $prefix || ''
566   ***      0      0      0   $pre || ''
573   ***      0      0      0   $val || ''
576   ***      0      0      0   $val || ''
634   ***      0      0      0   $$self{'description'} || ''
702   ***      0      0      0   $s ||= 's'
728   ***      0      0      0   $$opt{'type'} || ''
883   ***     50      0      1   $ENV{'MKDEBUG'} || 0
954   ***     50      0      3   $prev ||= {}
955   ***     50      0      3   $defaults ||= {}
1028  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1041  ***     50      0      3   $self->prop('dbidriver') || ''
1045  ***      0      0      0   $$info{'D'} || ''
1051  ***     50      0      3   $$info{'D'} || ''
1073  ***     50      3      0   $opts ||= {}
1168  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1184  ***      0      0      0   $level ||= 0
1185  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1239  ***     50      0      1   $ENV{'MKDEBUG'} || 0
1247  ***      0      0      0   $level ||= 0
1305  ***      0      0      0   $$dsn{'P'} || 3306
1414  ***      0      0      0   $$slave_status{'slave_io_state'} || ''
1760  ***      0      0      0   $$slave_status{'slave_sql_running'} || 'No'
1809  ***      0      0      0   $host || '[default]'
      ***      0      0      0   $port || 3306
1844  ***     50      0      1   $ENV{'MKDEBUG'} || 0
2023  ***     50      0      1   $ENV{'MKDEBUG'} || 0
2127  ***      0      0      0   $level ||= 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
61    ***      0      0      0      0   $program_name ||= $PROGRAM_NAME
62    ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
524   ***      0      0      0      0   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1064  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1065  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1066  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1067  ***      0      0      0      0   $$dsn{'u'} ||= $user
1068  ***      0      0      0      0   $$dsn{'D'} ||= $db
1253  ***      0      0      0      0   $$args{'dbh'} || $dp->get_dbh($dp->get_cxn_params($dsn), {'AutoCommit', 1})
1268  ***      0      0      0      0   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id
      ***      0      0      0      0   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++
1281  ***      0      0      0      0   not defined $$args{'recurse'} or $level < $$args{'recurse'}
1421  ***      0      0      0      0   $master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1
1442  ***      0      0      0      0   $$self{'sths'}{$dbh}{'SLAVE_STATUS'} ||= $dbh->prepare('SHOW SLAVE STATUS')
1461  ***      0      0      0      0   $$self{'sths'}{$dbh}{'MASTER_STATUS'} ||= $dbh->prepare('SHOW MASTER STATUS')
1485  ***      0      0      0      0   $ms ||= $self->get_master_status($master)
1492  ***      0      0      0      0   $stat eq 'NULL' or $stat < 0 and not $timeoutok
1504  ***      0      0      0      0   $$self{'sths'}{$dbh}{'STOP_SLAVE'} ||= $dbh->prepare('STOP SLAVE')
1519  ***      0      0      0      0   $$self{'sths'}{$dbh}{'START_SLAVE'} ||= $dbh->prepare('START SLAVE')
1587  ***      0      0      0      0   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status)
      ***      0      0      0      0   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0
1648  ***      0      0      0      0   $self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0
1686  ***      0      0      0      0   $self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0
1740  ***      0      0      0      0   $self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0
1993  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
2102  ***      0      0      0      0   $$root{'h'} ||= $dp->get_hostname($dbh)


Covered Subroutines
-------------------

Subroutine                  Count Location                                                 
--------------------------- ----- ---------------------------------------------------------
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1228
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1229
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1233
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1234
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1235
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1239
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1838
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1839
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1841
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1842
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1844
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:2021
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:2023
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:23  
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:24  
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:35  
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:36  
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:38  
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:39  
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:40  
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:42  
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:871 
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:872 
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:873 
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:874 
BEGIN                           1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:883 
get_cxn_params                  3 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1038
get_dbh                         3 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1072
new                             1 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:886 
parse                           3 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:948 
prop                            9 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:939 

Uncovered Subroutines
---------------------

Subroutine                  Count Location                                                 
--------------------------- ----- ---------------------------------------------------------
DESTROY                         0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1992
__ANON__                        0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:2086
__ANON__                        0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:425 
_d                              0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1212
_d                              0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1819
_d                              0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1998
_d                              0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:2148
_d                              0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:853 
_find_slaves_by_hosts           0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1347
_find_slaves_by_processlist     0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1327
_get_participants               0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:325 
_make_PID_file                  0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1957
_parse_specs                    0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:211 
_pod_to_specs                   0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:105 
_read_config_file               0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:777 
_remove_PID_file                0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1979
_set_option                     0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:371 
_validate_type                  0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:520 
as_string                       0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1012
catchup_to_master               0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1527
catchup_to_same_pos             0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1568
change_master_to                0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1597
check_PID_file                  0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1916
clone                           0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:830 
copy                            0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1194
daemonize                       0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1865
descr                           0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:633 
detach_slave                    0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1749
disconnect                      0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1177
errors                          0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:623 
fill_in_dsn                     0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1060
find_slave_hosts                0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1297
get                             0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:587 
get_connected_slaves            0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1374
get_defaults                    0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:361 
get_defaults_files              0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:100 
get_groups                      0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:366 
get_hostname                    0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1167
get_master_dsn                  0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1433
get_master_status               0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1459
get_opts                        0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:388 
get_slave_lag                   0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1788
get_slave_status                0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1440
get_specs                       0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:93  
got                             0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:595 
has                             0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:603 
has_slave_updates               0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1764
is_master_of                    0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1395
main                            0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:2026
make_PID_file                   0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1947
make_sibling_of_master          0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1608
make_slave_of_sibling           0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1656
make_slave_of_uncle             0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1695
new                             0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1242
new                             0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1847
new                             0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:56  
opts                            0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:337 
parse_options                   0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:999 
pos_cmp                         0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1794
pos_to_string                   0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1813
print_active_handles            0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1183
print_errors                    0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:657 
print_slaves                    0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:2125
print_usage                     0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:667 
prompt                          0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:628 
prompt_noecho                   0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:742 
read_para_after                 0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:811 
recurse_to_slaves               0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1246
repl_posn                       0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1772
save_error                      0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:618 
set                             0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:609 
set_defaults                    0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:349 
short_host                      0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1799
short_opts                      0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:343 
slave_is_running                0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1759
start_slave                     0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1511
stop_slave                      0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1503
usage                           0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1021
usage_or_errors                 0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:644 
wait_for_master                 0 /home/daniel/dev/maatkit/mk-slave-find/mk-slave-find:1480


mk-slave-find.t

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     BEGIN {
4     ***      1     50     33      1            36      die "The MAATKIT_TRUNK environment variable is not set.  See http://code.google.com/p/maatkit/wiki/Testing"
5                                                           unless $ENV{MAATKIT_TRUNK} && -d $ENV{MAATKIT_TRUNK};
6              1                                  8      unshift @INC, "$ENV{MAATKIT_TRUNK}/common";
7                                                     };
8                                                     
9              1                    1            12   use strict;
               1                                  3   
               1                                  6   
10             1                    1             7   use warnings FATAL => 'all';
               1                                  2   
               1                                  6   
11             1                    1            13   use English qw(-no_match_vars);
               1                                  3   
               1                                  8   
12             1                    1            12   use Test::More;
               1                                  4   
               1                                 13   
13                                                    
14             1                    1            16   use MaatkitTest;
               1                                  4   
               1                                 12   
15             1                    1            15   use Sandbox;
               1                                  3   
               1                                 13   
16             1                                 24   require "$trunk/mk-slave-find/mk-slave-find";
17                                                    
18             1                                 12   my $dp = new DSNParser();
19             1                                 11   my $sb = new Sandbox(basedir => '/tmp', DSNParser => $dp);
20             1                                 63   my $master_dbh = $sb->get_dbh_for('master');
21             1                                 23   my $slave_dbh  = $sb->get_dbh_for('slave1');
22                                                    
23                                                    # Create slave2 as slave of slave1.
24             1                              37412   diag(`/tmp/12347/stop >/dev/null 2>&1`);
25             1                              34235   diag(`rm -rf /tmp/12347 >/dev/null 2>&1`);
26             1                             3372569   diag(`$trunk/sandbox/start-sandbox slave 12347 12346 >/dev/null`);
27             1                                147   my $slave_2_dbh = $sb->get_dbh_for('slave2');
28                                                    
29    ***      1     50                          29   if ( !$master_dbh ) {
      ***            50                               
      ***            50                               
30    ***      0                                  0      plan skip_all => 'Cannot connect to sandbox master';
31                                                    }
32                                                    elsif ( !$slave_dbh ) {
33    ***      0                                  0      plan skip_all => 'Cannot connect to sandbox slave';
34                                                    }
35                                                    elsif ( !$slave_2_dbh ) {
36    ***      0                                  0      plan skip_all => 'Cannot connect to second sandbox slave';
37                                                    }
38                                                    else {
39             1                                 13      plan tests => 4;
40                                                    }
41                                                    
42             1                              93142   my $output = `$trunk/mk-slave-find/mk-slave-find --help`;
43             1                                 64   like($output, qr/Prompt for a password/, 'It compiles');
44                                                    
45                                                    # Double check that we're setup correctly.
46             1                                 50   my $row = $slave_2_dbh->selectall_arrayref('SHOW SLAVE STATUS', {Slice => {}});
47             1                                 18   is(
48                                                       $row->[0]->{Master_Port},
49                                                       '12346',
50                                                       'slave2 is slave of slave1'
51                                                    );
52                                                    
53             1                             199914   $output = `$trunk/mk-slave-find/mk-slave-find -h 127.0.0.1 -P 12345 -u msandbox -p msandbox`;
54             1                                 18   my $expected = <<EOF;
55                                                    127.0.0.1:12345
56                                                    +- 127.0.0.1:12346
57                                                       +- 127.0.0.1:12347
58                                                    EOF
59             1                                 31   is($output, $expected, 'Master with slave and slave of slave');
60                                                    
61                                                    # #############################################################################
62                                                    # Until MasterSlave::find_slave_hosts() is improved to overcome the problems
63                                                    # with SHOW SLAVE HOSTS, this test won't work.
64                                                    # #############################################################################
65                                                    # Make slave2 slave of master.
66                                                    #diag(`../../mk-slave-move/mk-slave-move --sibling-of-master h=127.1,P=12347`);
67                                                    #$output = `perl ../mk-slave-find -h 127.0.0.1 -P 12345 -u msandbox -p msandbox`;
68                                                    #$expected = <<EOF;
69                                                    #127.0.0.1:12345
70                                                    #+- 127.0.0.1:12346
71                                                    #+- 127.0.0.1:12347
72                                                    #EOF
73                                                    #is($output, $expected, 'Master with two slaves');
74                                                    
75                                                    # #########################################################################
76                                                    # Issue 391: Add --pid option to all scripts
77                                                    # #########################################################################
78             1                              21808   `touch /tmp/mk-script.pid`;
79             1                             148689   $output = `$trunk/mk-slave-find/mk-slave-find -h 127.0.0.1 -P 12345 -u msandbox -p msandbox --pid /tmp/mk-script.pid 2>&1`;
80             1                                 65   like(
81                                                       $output,
82                                                       qr{PID file /tmp/mk-script.pid already exists},
83                                                       'Dies if PID file already exists (issue 391)'
84                                                    );
85             1                              13476   `rm -rf /tmp/mk-script.pid`;
86                                                    
87                                                    # Stop and remove slave2.
88             1                             3266490   diag(`/tmp/12347/stop >/dev/null`);
89             1                              39950   diag(`rm -rf /tmp/12347 >/dev/null`);
90             1                                  7   exit;


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
4     ***     50      0      1   unless $ENV{'MAATKIT_TRUNK'} and -d $ENV{'MAATKIT_TRUNK'}
29    ***     50      0      1   if (not $master_dbh) { }
      ***     50      0      1   elsif (not $slave_dbh) { }
      ***     50      0      1   elsif (not $slave_2_dbh) { }


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
4     ***     33      0      0      1   $ENV{'MAATKIT_TRUNK'} and -d $ENV{'MAATKIT_TRUNK'}


Covered Subroutines
-------------------

Subroutine Count Location          
---------- ----- ------------------
BEGIN          1 mk-slave-find.t:10
BEGIN          1 mk-slave-find.t:11
BEGIN          1 mk-slave-find.t:12
BEGIN          1 mk-slave-find.t:14
BEGIN          1 mk-slave-find.t:15
BEGIN          1 mk-slave-find.t:4 
BEGIN          1 mk-slave-find.t:9 


