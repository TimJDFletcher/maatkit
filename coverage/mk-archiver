---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...t/mk-archiver/mk-archiver   46.9   32.9   29.0   51.9    n/a  100.0   41.2
Total                          46.9   32.9   29.0   51.9    n/a  100.0   41.2
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 17:57:36 2010
Finish:       Fri Feb 19 17:57:36 2010

Run:          ./101_basics.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 17:57:38 2010
Finish:       Fri Feb 19 17:57:54 2010

Run:          ./102_dest.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 17:57:57 2010
Finish:       Fri Feb 19 17:58:11 2010

Run:          ./103_file.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 17:58:14 2010
Finish:       Fri Feb 19 17:58:17 2010

Run:          ./104_purge.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 17:58:20 2010
Finish:       Fri Feb 19 17:58:24 2010

Run:          ./105_plugin.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 17:58:27 2010
Finish:       Fri Feb 19 17:58:55 2010

Run:          ./106_gt_n.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 17:58:58 2010
Finish:       Fri Feb 19 17:58:58 2010

Run:          ./107_res_fk.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 17:59:02 2010
Finish:       Fri Feb 19 17:59:06 2010

Run:          ./108_check_slave_lag.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 17:59:09 2010
Finish:       Fri Feb 19 17:59:14 2010

Run:          ./109_standard_options.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 17:59:18 2010
Finish:       Fri Feb 19 17:59:22 2010

Run:          ./110_bulk_delete.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 17:59:25 2010
Finish:       Fri Feb 19 17:59:48 2010

Run:          ./111_bulk_insert.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 17:59:52 2010
Finish:       Fri Feb 19 17:59:54 2010

Run:          ./112_indexes.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 17:59:57 2010
Finish:       Fri Feb 19 18:00:50 2010

Run:          ./113_safe_auto_increment.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 18:00:54 2010
Finish:       Fri Feb 19 18:00:54 2010

Run:          ./114_delete_more.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 18:00:58 2010
Finish:       Fri Feb 19 18:01:02 2010

Run:          ./201_issue_655.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 18:01:05 2010
Finish:       Fri Feb 19 18:01:05 2010

Run:          ./202_issue_131.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 18:01:08 2010
Finish:       Fri Feb 19 18:01:09 2010

Run:          ./203_issue_524.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 18:01:12 2010
Finish:       Fri Feb 19 18:01:12 2010

/home/daniel/dev/maatkit/mk-archiver/mk-archiver

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This is mk-archiver, a program to archive records from one MySQL table to
4                                                     # a file and/or another table.
5                                                     #
6                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
7                                                     # Feedback and improvements are welcome.
8                                                     #
9                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
10                                                    # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
11                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
12                                                    #
13                                                    # This program is free software; you can redistribute it and/or modify it under
14                                                    # the terms of the GNU General Public License as published by the Free Software
15                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
16                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
17                                                    # licenses.
18                                                    #
19                                                    # You should have received a copy of the GNU General Public License along with
20                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
21                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
22                                                    
23            17                   17           101   use strict;
              17                                 41   
              17                                126   
24            17                   17           109   use warnings FATAL => 'all';
              17                                 69   
              17                                121   
25                                                    
26                                                    our $VERSION = '@VERSION@';
27                                                    our $DISTRIB = '@DISTRIB@';
28                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5805 $ =~ m/(\d+)/g, 0));
29                                                    
30                                                    # ###########################################################################
31                                                    # OptionParser package 5568
32                                                    # ###########################################################################
33                                                    package OptionParser;
34                                                    
35            17                   17           119   use strict;
              17                                 50   
              17                                 84   
36            17                   17           105   use warnings FATAL => 'all';
              17                                 45   
              17                                 85   
37                                                    
38            17                   17           178   use Getopt::Long;
              17                                 61   
              17                                121   
39            17                   17           122   use List::Util qw(max);
              17                                 51   
              17                                188   
40            17                   17           112   use English qw(-no_match_vars);
              17                                 42   
              17                                117   
41                                                    
42    ***     17            50     17           122   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              17                                 44   
              17                                285   
43                                                    
44                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
45                                                    
46                                                    my %attributes = (
47                                                       'type'       => 1,
48                                                       'short form' => 1,
49                                                       'group'      => 1,
50                                                       'default'    => 1,
51                                                       'cumulative' => 1,
52                                                       'negatable'  => 1,
53                                                    );
54                                                    
55                                                    sub new {
56            18                   18           309      my ( $class, %args ) = @_;
57            18                                167      foreach my $arg ( qw(description) ) {
58    ***     18     50                         191         die "I need a $arg argument" unless $args{$arg};
59                                                       }
60            18                                376      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
61    ***     18            33                  121      $program_name ||= $PROGRAM_NAME;
62    ***     18            33                  247      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                   33                        
      ***                   50                        
63                                                    
64    ***     18     50     50                  964      my $self = {
      ***                   50                        
65                                                          description    => $args{description},
66                                                          prompt         => $args{prompt} || '<options>',
67                                                          strict         => (exists $args{strict} ? $args{strict} : 1),
68                                                          dp             => $args{dp}     || undef,
69                                                          program_name   => $program_name,
70                                                          opts           => {},
71                                                          got_opts       => 0,
72                                                          short_opts     => {},
73                                                          defaults       => {},
74                                                          groups         => {},
75                                                          allowed_groups => {},
76                                                          errors         => [],
77                                                          rules          => [],  # desc of rules for --help
78                                                          mutex          => [],  # rule: opts are mutually exclusive
79                                                          atleast1       => [],  # rule: at least one opt is required
80                                                          disables       => {},  # rule: opt disables other opts 
81                                                          defaults_to    => {},  # rule: opt defaults to value of other opt
82                                                          default_files  => [
83                                                             "/etc/maatkit/maatkit.conf",
84                                                             "/etc/maatkit/$program_name.conf",
85                                                             "$home/.maatkit.conf",
86                                                             "$home/.$program_name.conf",
87                                                          ],
88                                                       };
89            18                                236      return bless $self, $class;
90                                                    }
91                                                    
92                                                    sub get_specs {
93            18                   18           117      my ( $self, $file ) = @_;
94            18                                162      my @specs = $self->_pod_to_specs($file);
95            18                               1029      $self->_parse_specs(@specs);
96            18                                210      return;
97                                                    }
98                                                    
99                                                    sub get_defaults_files {
100           18                   18           100      my ( $self ) = @_;
101           18                                 73      return @{$self->{default_files}};
              18                                286   
102                                                   }
103                                                   
104                                                   sub _pod_to_specs {
105           18                   18           117      my ( $self, $file ) = @_;
106   ***     18            50                  142      $file ||= __FILE__;
107   ***     18     50                        1162      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
108                                                   
109           18                                435      my %types = (
110                                                         string => 's', # standard Getopt type
111                                                         'int'  => 'i', # standard Getopt type
112                                                         float  => 'f', # standard Getopt type
113                                                         Hash   => 'H', # hash, formed from a comma-separated list
114                                                         hash   => 'h', # hash as above, but only if a value is given
115                                                         Array  => 'A', # array, similar to Hash
116                                                         array  => 'a', # array, similar to hash
117                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
118                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
119                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
120                                                      );
121           18                                 95      my @specs = ();
122           18                                 70      my @rules = ();
123           18                                 72      my $para;
124                                                   
125           18                                166      local $INPUT_RECORD_SEPARATOR = '';
126           18                                672      while ( $para = <$fh> ) {
127         9144    100                       94613         next unless $para =~ m/^=head1 OPTIONS/;
128           18                                 87         last;
129                                                      }
130                                                   
131           18                                156      while ( $para = <$fh> ) {
132          162    100                        1046         last if $para =~ m/^=over/;
133          144                                570         chomp $para;
134          144                               1270         $para =~ s/\s+/ /g;
135          144                               2996         $para =~ s/$POD_link_re/$1/go;
136          144                                463         MKDEBUG && _d('Option rule:', $para);
137          144                               1653         push @rules, $para;
138                                                      }
139                                                   
140   ***     18     50                         115      die 'POD has no OPTIONS section' unless $para;
141                                                   
142           18                                 84      do {
143         1080    100                       11213         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
144         1062                               4094            chomp $para;
145         1062                               3009            MKDEBUG && _d($para);
146         1062                               3327            my %attribs;
147                                                   
148         1062                               6406            $para = <$fh>; # read next paragraph, possibly attributes
149                                                   
150         1062    100                        6182            if ( $para =~ m/: / ) { # attributes
151          540                               3723               $para =~ s/\s+\Z//g;
152          792                               5955               %attribs = map {
153          540                               3696                     my ( $attrib, $val) = split(/: /, $_);
154   ***    792     50                        5154                     die "Unrecognized attribute for --$option: $attrib"
155                                                                        unless $attributes{$attrib};
156          792                               6135                     ($attrib, $val);
157                                                                  } split(/; /, $para);
158          540    100                        3554               if ( $attribs{'short form'} ) {
159          126                                901                  $attribs{'short form'} =~ s/-//;
160                                                               }
161          540                               3323               $para = <$fh>; # read next paragraph, probably short help desc
162                                                            }
163                                                            else {
164          522                               1725               MKDEBUG && _d('Option has no attributes');
165                                                            }
166                                                   
167         1062                               9050            $para =~ s/\s+\Z//g;
168         1062                               8556            $para =~ s/\s+/ /g;
169         1062                               8013            $para =~ s/$POD_link_re/$1/go;
170                                                   
171         1062                               5841            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
172         1062                               3214            MKDEBUG && _d('Short help:', $para);
173                                                   
174   ***   1062     50                        6078            die "No description after option spec $option" if $para =~ m/^=item/;
175                                                   
176         1062    100                        7277            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
177           36                                137               $option = $base_option;
178           36                                371               $attribs{'negatable'} = 1;
179                                                            }
180                                                   
181         1062    100                       26654            push @specs, {
                    100                               
      ***            50                               
                    100                               
                    100                               
      ***            50                               
182                                                               spec  => $option
183                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
184                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
185                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
186                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
187                                                               desc  => $para
188                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
189                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
190                                                            };
191                                                         }
192         1080                              11386         while ( $para = <$fh> ) {
193   ***   2952     50                       14374            last unless $para;
194                                                   
195                                                   
196         2952    100                       15842            if ( $para =~ m/^=head1/ ) {
197           18                                 85               $para = undef; # Can't 'last' out of a do {} block.
198           18                                165               last;
199                                                            }
200         2934    100                       28713            last if $para =~ m/^=item --/;
201                                                         }
202                                                      } while ( $para );
203                                                   
204   ***     18     50                         104      die 'No valid specs in POD OPTIONS' unless @specs;
205                                                   
206           18                                382      close $fh;
207           18                                 93      return @specs, @rules;
208                                                   }
209                                                   
210                                                   sub _parse_specs {
211           18                   18           418      my ( $self, @specs ) = @_;
212           18                                160      my %disables; # special rule that requires deferred checking
213                                                   
214           18                                155      foreach my $opt ( @specs ) {
215         1206    100                        6342         if ( ref $opt ) { # It's an option spec, not a rule.
216                                                            MKDEBUG && _d('Parsing opt spec:',
217         1062                               3282               map { ($_, '=>', $opt->{$_}) } keys %$opt);
218                                                   
219         1062                              11084            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
220   ***   1062     50                        6580            if ( !$long ) {
221   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
222                                                            }
223         1062                               5315            $opt->{long} = $long;
224                                                   
225   ***   1062     50                        7068            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
226         1062                               6604            $self->{opts}->{$long} = $opt;
227                                                   
228   ***   1062     50                        6107            if ( length $long == 1 ) {
229   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
230   ***      0                                  0               $self->{short_opts}->{$long} = $long;
231                                                            }
232                                                   
233         1062    100                        5274            if ( $short ) {
234   ***    126     50                         865               die "Duplicate short option -$short"
235                                                                  if exists $self->{short_opts}->{$short};
236          126                                810               $self->{short_opts}->{$short} = $long;
237          126                                630               $opt->{short} = $short;
238                                                            }
239                                                            else {
240          936                               4561               $opt->{short} = undef;
241                                                            }
242                                                   
243         1062    100                        8201            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
244   ***   1062     50                        7554            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
245         1062    100                        9219            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
246                                                   
247   ***   1062            50                 6343            $opt->{group} ||= 'default';
248         1062                               7694            $self->{groups}->{ $opt->{group} }->{$long} = 1;
249                                                   
250         1062                               4925            $opt->{value} = undef;
251         1062                               4793            $opt->{got}   = 0;
252                                                   
253         1062                               7569            my ( $type ) = $opt->{spec} =~ m/=(.)/;
254         1062                               5195            $opt->{type} = $type;
255         1062                               3061            MKDEBUG && _d($long, 'type:', $type);
256                                                   
257   ***   1062     50    100                12554            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                   66                        
258   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
259                                                                  . "was given when this OptionParser object was created";
260                                                            }
261                                                   
262         1062    100    100                10566            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
263                                                   
264         1062    100                        9140            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
265   ***    162     50                        1338               $self->{defaults}->{$long} = defined $def ? $def : 1;
266          162                                524               MKDEBUG && _d($long, 'default:', $def);
267                                                            }
268                                                   
269         1062    100                        5841            if ( $long eq 'config' ) {
270           18                                177               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
271                                                            }
272                                                   
273         1062    100                        7802            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
274           18                                103               $disables{$long} = $dis;
275           18                                 63               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
276                                                            }
277                                                   
278         1062                               7287            $self->{opts}->{$long} = $opt;
279                                                         }
280                                                         else { # It's an option rule, not a spec.
281          144                                411            MKDEBUG && _d('Parsing rule:', $opt); 
282          144                                497            push @{$self->{rules}}, $opt;
             144                                977   
283          144                                906            my @participants = $self->_get_participants($opt);
284          144                                595            my $rule_ok = 0;
285                                                   
286          144    100                        1538            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
287          108                                407               $rule_ok = 1;
288          108                                358               push @{$self->{mutex}}, \@participants;
             108                                706   
289          108                                364               MKDEBUG && _d(@participants, 'are mutually exclusive');
290                                                            }
291          144    100                        1210            if ( $opt =~ m/at least one|one and only one/ ) {
292           18                                 73               $rule_ok = 1;
293           18                                 66               push @{$self->{atleast1}}, \@participants;
              18                                144   
294           18                                 72               MKDEBUG && _d(@participants, 'require at least one');
295                                                            }
296          144    100                         856            if ( $opt =~ m/default to/ ) {
297           18                                 80               $rule_ok = 1;
298           18                                137               $self->{defaults_to}->{$participants[0]} = $participants[1];
299           18                                 68               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
300                                                            }
301   ***    144     50                         808            if ( $opt =~ m/restricted to option groups/ ) {
302   ***      0                                  0               $rule_ok = 1;
303   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
304   ***      0                                  0               my @groups = split(',', $groups);
305   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
306   ***      0                                  0                  s/\s+//;
307   ***      0                                  0                  $_ => 1;
308                                                               } @groups;
309                                                            }
310                                                   
311   ***    144     50                         964            die "Unrecognized option rule: $opt" unless $rule_ok;
312                                                         }
313                                                      }
314                                                   
315           18                                171      foreach my $long ( keys %disables ) {
316           18                                121         my @participants = $self->_get_participants($disables{$long});
317           18                                145         $self->{disables}->{$long} = \@participants;
318           18                                 97         MKDEBUG && _d('Option', $long, 'disables', @participants);
319                                                      }
320                                                   
321           18                                225      return; 
322                                                   }
323                                                   
324                                                   sub _get_participants {
325          162                  162           979      my ( $self, $str ) = @_;
326          162                                570      my @participants;
327          162                               1786      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
328   ***    324     50                        2267         die "Option --$long does not exist while processing rule $str"
329                                                            unless exists $self->{opts}->{$long};
330          324                               1881         push @participants, $long;
331                                                      }
332          162                                623      MKDEBUG && _d('Participants for', $str, ':', @participants);
333          162                               1301      return @participants;
334                                                   }
335                                                   
336                                                   sub opts {
337   ***      0                    0             0      my ( $self ) = @_;
338   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
339   ***      0                                  0      return %opts;
340                                                   }
341                                                   
342                                                   sub short_opts {
343   ***      0                    0             0      my ( $self ) = @_;
344   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
345   ***      0                                  0      return %short_opts;
346                                                   }
347                                                   
348                                                   sub set_defaults {
349   ***      0                    0             0      my ( $self, %defaults ) = @_;
350   ***      0                                  0      $self->{defaults} = {};
351   ***      0                                  0      foreach my $long ( keys %defaults ) {
352   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
353                                                            unless exists $self->{opts}->{$long};
354   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
355   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
356                                                      }
357   ***      0                                  0      return;
358                                                   }
359                                                   
360                                                   sub get_defaults {
361   ***      0                    0             0      my ( $self ) = @_;
362   ***      0                                  0      return $self->{defaults};
363                                                   }
364                                                   
365                                                   sub get_groups {
366   ***      0                    0             0      my ( $self ) = @_;
367   ***      0                                  0      return $self->{groups};
368                                                   }
369                                                   
370                                                   sub _set_option {
371           87                   87           514      my ( $self, $opt, $val ) = @_;
372   ***     87      0                         572      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
373                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
374                                                               : die "Getopt::Long gave a nonexistent option: $opt";
375                                                   
376           87                                224      $opt = $self->{opts}->{$long};
377   ***     87     50                         691      if ( $opt->{is_cumulative} ) {
378   ***      0                                  0         $opt->{value}++;
379                                                      }
380                                                      else {
381           87                                474         $opt->{value} = $val;
382                                                      }
383           87                                388      $opt->{got} = 1;
384           87                                592      MKDEBUG && _d('Got option', $long, '=', $val);
385                                                   }
386                                                   
387                                                   sub get_opts {
388           18                   18           118      my ( $self ) = @_; 
389                                                   
390           18                                 76      foreach my $long ( keys %{$self->{opts}} ) {
              18                                412   
391         1062                               6171         $self->{opts}->{$long}->{got} = 0;
392   ***   1062     50                       12984         $self->{opts}->{$long}->{value}
                    100                               
393                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
394                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
395                                                            : undef;
396                                                      }
397           18                                205      $self->{got_opts} = 0;
398                                                   
399           18                                115      $self->{errors} = [];
400                                                   
401   ***     18     50     33                  328      if ( @ARGV && $ARGV[0] eq "--config" ) {
402   ***      0                                  0         shift @ARGV;
403   ***      0                                  0         $self->_set_option('config', shift @ARGV);
404                                                      }
405   ***     18     50                         163      if ( $self->has('config') ) {
406           18                                 68         my @extra_args;
407           18                                150         foreach my $filename ( split(',', $self->get('config')) ) {
408           72                                272            eval {
409           72                                504               push @extra_args, $self->_read_config_file($filename);
410                                                            };
411   ***     72     50                         552            if ( $EVAL_ERROR ) {
412   ***     72     50                         437               if ( $self->got('config') ) {
413   ***      0                                  0                  die $EVAL_ERROR;
414                                                               }
415                                                               elsif ( MKDEBUG ) {
416                                                                  _d($EVAL_ERROR);
417                                                               }
418                                                            }
419                                                         }
420           18                                133         unshift @ARGV, @extra_args;
421                                                      }
422                                                   
423           18                                231      Getopt::Long::Configure('no_ignore_case', 'bundling');
424                                                      GetOptions(
425         1044                   87         10068         map    { $_->{spec} => sub { $self->_set_option(@_); } }
              87                                598   
            1062                               6043   
426           18                                277         grep   { $_->{long} ne 'config' } # --config is handled specially above.
427   ***     18     50                          86         values %{$self->{opts}}
428                                                      ) or $self->save_error('Error parsing options');
429                                                   
430   ***     18     50     33                 2570      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
431   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
432                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
433                                                               or die "Cannot print: $OS_ERROR";
434   ***      0                                  0         exit 0;
435                                                      }
436                                                   
437   ***     18     50     33                  195      if ( @ARGV && $self->{strict} ) {
438   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
439                                                      }
440                                                   
441           18                                 72      foreach my $mutex ( @{$self->{mutex}} ) {
              18                                170   
442          108                                493         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
             216                               1509   
443   ***    108     50                         710         if ( @set > 1 ) {
444   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
445   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
446                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
447                                                                    . ' are mutually exclusive.';
448   ***      0                                  0            $self->save_error($err);
449                                                         }
450                                                      }
451                                                   
452           18                                 81      foreach my $required ( @{$self->{atleast1}} ) {
              18                                135   
453           18                                138         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
              54                                397   
454   ***     18     50                         153         if ( @set == 0 ) {
455   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
456   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
457                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
458   ***      0                                  0            $self->save_error("Specify at least one of $err");
459                                                         }
460                                                      }
461                                                   
462           18                                 72      foreach my $long ( keys %{$self->{opts}} ) {
              18                                328   
463         1062                               5813         my $opt = $self->{opts}->{$long};
464         1062    100                       11428         if ( $opt->{got} ) {
      ***            50                               
465   ***     87     50                         600            if ( exists $self->{disables}->{$long} ) {
466   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
467   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
468   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
469                                                                  'because', $long,'disables them');
470                                                            }
471                                                   
472   ***     87     50                         589            if ( exists $self->{allowed_groups}->{$long} ) {
473                                                   
474   ***      0                                  0               my @restricted_groups = grep {
475   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
476   ***      0                                  0               } keys %{$self->{groups}};
477                                                   
478   ***      0                                  0               my @restricted_opts;
479   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
480   ***      0                                  0                  RESTRICTED_OPT:
481   ***      0                                  0                  foreach my $restricted_opt (
482                                                                     keys %{$self->{groups}->{$restricted_group}} )
483                                                                  {
484   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
485   ***      0      0                           0                     push @restricted_opts, $restricted_opt
486                                                                        if $self->{opts}->{$restricted_opt}->{got};
487                                                                  }
488                                                               }
489                                                   
490   ***      0      0                           0               if ( @restricted_opts ) {
491   ***      0                                  0                  my $err;
492   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
493   ***      0                                  0                     $err = "--$restricted_opts[0]";
494                                                                  }
495                                                                  else {
496   ***      0                                  0                     $err = join(', ',
497   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
498   ***      0                                  0                               grep { $_ } 
499                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
500                                                                            )
501                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
502                                                                  }
503   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
504                                                               }
505                                                            }
506                                                   
507                                                         }
508                                                         elsif ( $opt->{is_required} ) { 
509   ***      0                                  0            $self->save_error("Required option --$long must be specified");
510                                                         }
511                                                   
512         1062                               6663         $self->_validate_type($opt);
513                                                      }
514                                                   
515           18                                264      $self->{got_opts} = 1;
516           18                                 76      return;
517                                                   }
518                                                   
519                                                   sub _validate_type {
520         1062                 1062          5315      my ( $self, $opt ) = @_;
521   ***   1062    100     66                14055      return unless $opt && $opt->{type};
522          504                               2270      my $val = $opt->{value};
523                                                   
524          504    100    100                18651      if ( $val && $opt->{type} eq 'm' ) {  # type time
                    100    100                        
      ***            50     66                        
      ***            50     66                        
      ***           100     33                        
                           100                        
                           100                        
525           36                                102         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
526           36                                538         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
527   ***     36     50                         230         if ( !$suffix ) {
528   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
529   ***      0             0                    0            $suffix = $s || 's';
530   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
531                                                               $opt->{long}, '(value:', $val, ')');
532                                                         }
533   ***     36     50                         249         if ( $suffix =~ m/[smhd]/ ) {
534   ***     36      0                         198            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***            50                               
535                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
536                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
537                                                                 :                  $num * 86400;   # Days
538   ***     36            50                  469            $opt->{value} = ($prefix || '') . $val;
539           36                                138            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
540                                                         }
541                                                         else {
542   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
543                                                         }
544                                                      }
545                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
546           25                                 78         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
547           25                                120         my $prev = {};
548           25                                189         my $from_key = $self->{defaults_to}->{ $opt->{long} };
549           25    100                         142         if ( $from_key ) {
550            7                                 26            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
551            7                                 44            $prev = $self->{opts}->{$from_key}->{value};
552                                                         }
553           25                                270         my $defaults = $self->{dp}->parse_options($self);
554           25                                171         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
555                                                      }
556                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
557   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
558   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
559   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
560   ***      0      0                           0         if ( defined $num ) {
561   ***      0      0                           0            if ( $factor ) {
562   ***      0                                  0               $num *= $factor_for{$factor};
563   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
564                                                                  'to num', $num, '* factor', $factor);
565                                                            }
566   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
567                                                         }
568                                                         else {
569   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
570                                                         }
571                                                      }
572                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
573   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
574                                                      }
575                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
576   ***     19            50                  484         $opt->{value} = [ split(/(?<!\\),\s*/, ($val || '')) ];
577                                                      }
578                                                      else {
579          424                               1345         MKDEBUG && _d('Nothing to validate for option',
580                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
581                                                      }
582                                                   
583          504                               2431      return;
584                                                   }
585                                                   
586                                                   sub get {
587         1057                 1057          6234      my ( $self, $opt ) = @_;
588         1057    100                        6621      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
589   ***   1057     50     33                14362      die "Option $opt does not exist"
590                                                         unless $long && exists $self->{opts}->{$long};
591         1057                              12616      return $self->{opts}->{$long}->{value};
592                                                   }
593                                                   
594                                                   sub got {
595           90                   90           599      my ( $self, $opt ) = @_;
596   ***     90     50                         611      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
597   ***     90     50     33                 1388      die "Option $opt does not exist"
598                                                         unless $long && exists $self->{opts}->{$long};
599           90                                900      return $self->{opts}->{$long}->{got};
600                                                   }
601                                                   
602                                                   sub has {
603          343                  343          1899      my ( $self, $opt ) = @_;
604          343    100                        2445      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
605          343    100                        3618      return defined $long ? exists $self->{opts}->{$long} : 0;
606                                                   }
607                                                   
608                                                   sub set {
609   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
610   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
611   ***      0      0      0                    0      die "Option $opt does not exist"
612                                                         unless $long && exists $self->{opts}->{$long};
613   ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
614   ***      0                                  0      return;
615                                                   }
616                                                   
617                                                   sub save_error {
618   ***      0                    0             0      my ( $self, $error ) = @_;
619   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
620                                                   }
621                                                   
622                                                   sub errors {
623   ***      0                    0             0      my ( $self ) = @_;
624   ***      0                                  0      return $self->{errors};
625                                                   }
626                                                   
627                                                   sub prompt {
628   ***      0                    0             0      my ( $self ) = @_;
629   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
630                                                   }
631                                                   
632                                                   sub descr {
633   ***      0                    0             0      my ( $self ) = @_;
634   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
635                                                                 . "  For more details, please use the --help option, "
636                                                                 . "or try 'perldoc $PROGRAM_NAME' "
637                                                                 . "for complete documentation.";
638   ***      0      0                           0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g)
639                                                         unless $ENV{DONT_BREAK_LINES};
640   ***      0                                  0      $descr =~ s/ +$//mg;
641   ***      0                                  0      return $descr;
642                                                   }
643                                                   
644                                                   sub usage_or_errors {
645           18                   18            91      my ( $self ) = @_;
646   ***     18     50                         147      if ( $self->{opts}->{help}->{got} ) {
      ***     18     50                         140   
647   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
648   ***      0                                  0         exit 0;
649                                                      }
650                                                      elsif ( scalar @{$self->{errors}} ) {
651   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
652   ***      0                                  0         exit 0;
653                                                      }
654           18                                 68      return;
655                                                   }
656                                                   
657                                                   sub print_errors {
658   ***      0                    0             0      my ( $self ) = @_;
659   ***      0                                  0      my $usage = $self->prompt() . "\n";
660   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
661   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
662                                                                 . "\n";
663                                                      }
664   ***      0                                  0      return $usage . "\n" . $self->descr();
665                                                   }
666                                                   
667                                                   sub print_usage {
668   ***      0                    0             0      my ( $self ) = @_;
669   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
670   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
671                                                   
672   ***      0      0                           0      my $maxl = max(
673   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
674                                                         @opts);
675                                                   
676   ***      0      0                           0      my $maxs = max(0,
677   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
678   ***      0                                  0         values %{$self->{short_opts}});
679                                                   
680   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
681   ***      0                                  0      my $rcol = 80 - $lcol - 6;
682   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
683                                                   
684   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
685                                                   
686   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
687                                                   
688   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
689   ***      0                                  0      push @groups, 'default';
690                                                   
691   ***      0                                  0      foreach my $group ( reverse @groups ) {
692   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
693   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
694   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
695                                                            grep { $_->{group} eq $group }
696                                                            @opts )
697                                                         {
698   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
699   ***      0                                  0            my $short = $opt->{short};
700   ***      0                                  0            my $desc  = $opt->{desc};
701   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
702   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
703   ***      0             0                    0               $s    ||= 's';
704   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
705   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
706                                                                      . "d=days; if no suffix, $s is used.";
707                                                            }
708   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
709   ***      0                                  0            $desc =~ s/ +$//mg;
710   ***      0      0                           0            if ( $short ) {
711   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
712                                                            }
713                                                            else {
714   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
715                                                            }
716                                                         }
717                                                      }
718                                                   
719   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
720   ***      0                                  0         $usage .= "\nRules:\n\n";
721   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
722                                                      }
723   ***      0      0                           0      if ( $self->{dp} ) {
724   ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
725                                                      }
726   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
727   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
728   ***      0                                  0         my $val   = $opt->{value};
729   ***      0             0                    0         my $type  = $opt->{type} || '';
730   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
731   ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
732                                                                   : !defined $val             ? '(No value)'
733                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
734                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
735                                                                   : $type =~ m/A|a/           ? join(',', @$val)
736                                                                   :                             $val;
737   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
738                                                      }
739   ***      0                                  0      return $usage;
740                                                   }
741                                                   
742                                                   sub prompt_noecho {
743   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
744   ***      0                                  0      my ( $prompt ) = @_;
745   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
746   ***      0      0                           0      print $prompt
747                                                         or die "Cannot print: $OS_ERROR";
748   ***      0                                  0      my $response;
749   ***      0                                  0      eval {
750   ***      0                                  0         require Term::ReadKey;
751   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
752   ***      0                                  0         chomp($response = <STDIN>);
753   ***      0                                  0         Term::ReadKey::ReadMode('normal');
754   ***      0      0                           0         print "\n"
755                                                            or die "Cannot print: $OS_ERROR";
756                                                      };
757   ***      0      0                           0      if ( $EVAL_ERROR ) {
758   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
759                                                      }
760   ***      0                                  0      return $response;
761                                                   }
762                                                   
763                                                   if ( MKDEBUG ) {
764                                                      print '# ', $^X, ' ', $], "\n";
765                                                      my $uname = `uname -a`;
766                                                      if ( $uname ) {
767                                                         $uname =~ s/\s+/ /g;
768                                                         print "# $uname\n";
769                                                      }
770                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
771                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
772                                                         ($main::SVN_REV || ''), __LINE__);
773                                                      print('# Arguments: ',
774                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
775                                                   }
776                                                   
777                                                   sub _read_config_file {
778           72                   72           453      my ( $self, $filename ) = @_;
779   ***     72     50                         269      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
780   ***      0                                  0      my @args;
781   ***      0                                  0      my $prefix = '--';
782   ***      0                                  0      my $parse  = 1;
783                                                   
784                                                      LINE:
785   ***      0                                  0      while ( my $line = <$fh> ) {
786   ***      0                                  0         chomp $line;
787   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
788   ***      0                                  0         $line =~ s/\s+#.*$//g;
789   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
790   ***      0      0                           0         if ( $line eq '--' ) {
791   ***      0                                  0            $prefix = '';
792   ***      0                                  0            $parse  = 0;
793   ***      0                                  0            next LINE;
794                                                         }
795   ***      0      0      0                    0         if ( $parse
      ***             0                               
796                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
797                                                         ) {
798   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
799                                                         }
800                                                         elsif ( $line =~ m/./ ) {
801   ***      0                                  0            push @args, $line;
802                                                         }
803                                                         else {
804   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
805                                                         }
806                                                      }
807   ***      0                                  0      close $fh;
808   ***      0                                  0      return @args;
809                                                   }
810                                                   
811                                                   sub read_para_after {
812   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
813   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
814   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
815   ***      0                                  0      my $para;
816   ***      0                                  0      while ( $para = <$fh> ) {
817   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
818   ***      0                                  0         last;
819                                                      }
820   ***      0                                  0      while ( $para = <$fh> ) {
821   ***      0      0                           0         next unless $para =~ m/$regex/;
822   ***      0                                  0         last;
823                                                      }
824   ***      0                                  0      $para = <$fh>;
825   ***      0                                  0      chomp($para);
826   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
827   ***      0                                  0      return $para;
828                                                   }
829                                                   
830                                                   sub clone {
831   ***      0                    0             0      my ( $self ) = @_;
832                                                   
833   ***      0                                  0      my %clone = map {
834   ***      0                                  0         my $hashref  = $self->{$_};
835   ***      0                                  0         my $val_copy = {};
836   ***      0                                  0         foreach my $key ( keys %$hashref ) {
837   ***      0                                  0            my $ref = ref $hashref->{$key};
838   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
839   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
840   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
841                                                                              : $hashref->{$key};
842                                                         }
843   ***      0                                  0         $_ => $val_copy;
844                                                      } qw(opts short_opts defaults);
845                                                   
846   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
847   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
848                                                      }
849                                                   
850   ***      0                                  0      return bless \%clone;     
851                                                   }
852                                                   
853                                                   sub _d {
854   ***      0                    0             0      my ($package, undef, $line) = caller 0;
855   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
856   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
857                                                           @_;
858   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
859                                                   }
860                                                   
861                                                   1;
862                                                   
863                                                   # ###########################################################################
864                                                   # End OptionParser package
865                                                   # ###########################################################################
866                                                   
867                                                   # ###########################################################################
868                                                   # TableParser package 5266
869                                                   # ###########################################################################
870                                                   package TableParser;
871                                                   
872           17                   17           199   use strict;
              17                                 57   
              17                                139   
873           17                   17           106   use warnings FATAL => 'all';
              17                                 42   
              17                                133   
874           17                   17           106   use English qw(-no_match_vars);
              17                                 42   
              17                                124   
875           17                   17           128   use Data::Dumper;
              17                                 46   
              17                                273   
876                                                   $Data::Dumper::Indent    = 1;
877                                                   $Data::Dumper::Sortkeys  = 1;
878                                                   $Data::Dumper::Quotekeys = 0;
879                                                   
880   ***     17            50     17           115   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              17                                 44   
              17                                274   
881                                                   
882                                                   
883                                                   sub new {
884           18                   18           188      my ( $class, %args ) = @_;
885           18                                114      my @required_args = qw(Quoter);
886           18                                109      foreach my $arg ( @required_args ) {
887   ***     18     50                         160         die "I need a $arg argument" unless $args{$arg};
888                                                      }
889           18                                137      my $self = { %args };
890           18                                202      return bless $self, $class;
891                                                   }
892                                                   
893                                                   
894                                                   sub parse {
895           25                   25           175      my ( $self, $ddl, $opts ) = @_;
896   ***     25     50                         153      return unless $ddl;
897   ***     25     50                         193      if ( ref $ddl eq 'ARRAY' ) {
898   ***     25     50                         174         if ( lc $ddl->[0] eq 'table' ) {
899           25                                145            $ddl = $ddl->[1];
900                                                         }
901                                                         else {
902                                                            return {
903   ***      0                                  0               engine => 'VIEW',
904                                                            };
905                                                         }
906                                                      }
907                                                   
908   ***     25     50                         323      if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
909   ***      0                                  0         die "Cannot parse table definition; is ANSI quoting "
910                                                            . "enabled or SQL_QUOTE_SHOW_CREATE disabled?";
911                                                      }
912                                                   
913           25                                350      my ($name)     = $ddl =~ m/CREATE (?:TEMPORARY )?TABLE\s+(`.+?`)/;
914   ***     25     50                         277      (undef, $name) = $self->{Quoter}->split_unquote($name) if $name;
915                                                   
916           25                                901      $ddl =~ s/(`[^`]+`)/\L$1/g;
917                                                   
918           25                                230      my $engine = $self->get_engine($ddl);
919                                                   
920           25                                907      my @defs   = $ddl =~ m/^(\s+`.*?),?$/gm;
921           25                                142      my @cols   = map { $_ =~ m/`([^`]+)`/ } @defs;
              94                                712   
922           25                                 99      MKDEBUG && _d('Columns:', join(', ', @cols));
923                                                   
924           25                                 93      my %def_for;
925           25                                221      @def_for{@cols} = @defs;
926                                                   
927           25                                104      my (@nums, @null);
928           25                                114      my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
929           25                                173      foreach my $col ( @cols ) {
930           94                                407         my $def = $def_for{$col};
931           94                                802         my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
932   ***     94     50                         519         die "Can't determine column type for $def" unless $type;
933           94                                422         $type_for{$col} = $type;
934           94    100                         727         if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
935           71                                300            push @nums, $col;
936           71                                343            $is_numeric{$col} = 1;
937                                                         }
938           94    100                         590         if ( $def !~ m/NOT NULL/ ) {
939           48                                205            push @null, $col;
940           48                                212            $is_nullable{$col} = 1;
941                                                         }
942           94    100                         715         $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
943                                                      }
944                                                   
945           25                                243      my ($keys, $clustered_key) = $self->get_keys($ddl, $opts, \%is_nullable);
946                                                   
947                                                      return {
948           94                                591         name           => $name,
949                                                         cols           => \@cols,
950           94                               1262         col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
951           25                                331         is_col         => { map { $_ => 1 } @cols },
952                                                         null_cols      => \@null,
953                                                         is_nullable    => \%is_nullable,
954                                                         is_autoinc     => \%is_autoinc,
955                                                         clustered_key  => $clustered_key,
956                                                         keys           => $keys,
957                                                         defs           => \%def_for,
958                                                         numeric_cols   => \@nums,
959                                                         is_numeric     => \%is_numeric,
960                                                         engine         => $engine,
961                                                         type_for       => \%type_for,
962                                                      };
963                                                   }
964                                                   
965                                                   sub sort_indexes {
966           17                   17            86      my ( $self, $tbl ) = @_;
967                                                   
968                                                      my @indexes
969   ***      0                                  0         = sort {
970           34                                183            (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
971                                                            || ( !$tbl->{keys}->{$a}->{is_unique} <=> !$tbl->{keys}->{$b}->{is_unique} )
972                                                            || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
973   ***     17     50     33                  206            || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      ***      0            33                    0   
974                                                         }
975                                                         grep {
976           17                                233            $tbl->{keys}->{$_}->{type} eq 'BTREE'
977                                                         }
978           17                                 83         sort keys %{$tbl->{keys}};
979                                                   
980           17                                160      MKDEBUG && _d('Indexes sorted best-first:', join(', ', @indexes));
981           17                                137      return @indexes;
982                                                   }
983                                                   
984                                                   sub find_best_index {
985           17                   17           102      my ( $self, $tbl, $index ) = @_;
986           17                                 61      my $best;
987   ***     17     50                          98      if ( $index ) {
988   ***      0                                  0         ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
      ***      0                                  0   
      ***      0                                  0   
989                                                      }
990   ***     17     50                          97      if ( !$best ) {
991   ***     17     50                          81         if ( $index ) {
992   ***      0                                  0            die "Index '$index' does not exist in table";
993                                                         }
994                                                         else {
995           17                                138            ($best) = $self->sort_indexes($tbl);
996                                                         }
997                                                      }
998           17                                 54      MKDEBUG && _d('Best index found is', $best);
999           17                                 92      return $best;
1000                                                  }
1001                                                  
1002                                                  sub find_possible_keys {
1003  ***      0                    0             0      my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
1004  ***      0      0                           0      return () unless $where;
1005  ***      0                                  0      my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
1006                                                        . ' WHERE ' . $where;
1007  ***      0                                  0      MKDEBUG && _d($sql);
1008  ***      0                                  0      my $expl = $dbh->selectrow_hashref($sql);
1009  ***      0                                  0      $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
      ***      0                                  0   
1010  ***      0      0                           0      if ( $expl->{possible_keys} ) {
1011  ***      0                                  0         MKDEBUG && _d('possible_keys =', $expl->{possible_keys});
1012  ***      0                                  0         my @candidates = split(',', $expl->{possible_keys});
1013  ***      0                                  0         my %possible   = map { $_ => 1 } @candidates;
      ***      0                                  0   
1014  ***      0      0                           0         if ( $expl->{key} ) {
1015  ***      0                                  0            MKDEBUG && _d('MySQL chose', $expl->{key});
1016  ***      0                                  0            unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
      ***      0                                  0   
1017  ***      0                                  0            MKDEBUG && _d('Before deduping:', join(', ', @candidates));
1018  ***      0                                  0            my %seen;
1019  ***      0                                  0            @candidates = grep { !$seen{$_}++ } @candidates;
      ***      0                                  0   
1020                                                        }
1021  ***      0                                  0         MKDEBUG && _d('Final list:', join(', ', @candidates));
1022  ***      0                                  0         return @candidates;
1023                                                     }
1024                                                     else {
1025  ***      0                                  0         MKDEBUG && _d('No keys in possible_keys');
1026  ***      0                                  0         return ();
1027                                                     }
1028                                                  }
1029                                                  
1030                                                  sub check_table {
1031  ***      0                    0             0      my ( $self, %args ) = @_;
1032  ***      0                                  0      my @required_args = qw(dbh db tbl);
1033  ***      0                                  0      foreach my $arg ( @required_args ) {
1034  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1035                                                     }
1036  ***      0                                  0      my ($dbh, $db, $tbl) = @args{@required_args};
1037  ***      0                                  0      my $q      = $self->{Quoter};
1038  ***      0                                  0      my $db_tbl = $q->quote($db, $tbl);
1039  ***      0                                  0      MKDEBUG && _d('Checking', $db_tbl);
1040                                                  
1041  ***      0                                  0      my $sql = "SHOW TABLES FROM " . $q->quote($db)
1042                                                             . ' LIKE ' . $q->literal_like($tbl);
1043  ***      0                                  0      MKDEBUG && _d($sql);
1044  ***      0                                  0      my $row;
1045  ***      0                                  0      eval {
1046  ***      0                                  0         $row = $dbh->selectrow_arrayref($sql);
1047                                                     };
1048  ***      0      0                           0      if ( $EVAL_ERROR ) {
1049  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
1050  ***      0                                  0         return 0;
1051                                                     }
1052  ***      0      0      0                    0      if ( !$row->[0] || $row->[0] ne $tbl ) {
1053  ***      0                                  0         MKDEBUG && _d('Table does not exist');
1054  ***      0                                  0         return 0;
1055                                                     }
1056                                                  
1057  ***      0                                  0      MKDEBUG && _d('Table exists; no privs to check');
1058  ***      0      0                           0      return 1 unless $args{all_privs};
1059                                                  
1060  ***      0                                  0      $sql = "SHOW FULL COLUMNS FROM $db_tbl";
1061  ***      0                                  0      MKDEBUG && _d($sql);
1062  ***      0                                  0      eval {
1063  ***      0                                  0         $row = $dbh->selectrow_hashref($sql);
1064                                                     };
1065  ***      0      0                           0      if ( $EVAL_ERROR ) {
1066  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
1067  ***      0                                  0         return 0;
1068                                                     }
1069  ***      0      0                           0      if ( !scalar keys %$row ) {
1070  ***      0                                  0         MKDEBUG && _d('Table has no columns:', Dumper($row));
1071  ***      0                                  0         return 0;
1072                                                     }
1073  ***      0             0                    0      my $privs = $row->{privileges} || $row->{Privileges};
1074                                                  
1075  ***      0                                  0      $sql = "DELETE FROM $db_tbl LIMIT 0";
1076  ***      0                                  0      MKDEBUG && _d($sql);
1077  ***      0                                  0      eval {
1078  ***      0                                  0         $dbh->do($sql);
1079                                                     };
1080  ***      0      0                           0      my $can_delete = $EVAL_ERROR ? 0 : 1;
1081                                                  
1082  ***      0                                  0      MKDEBUG && _d('User privs on', $db_tbl, ':', $privs,
1083                                                        ($can_delete ? 'delete' : ''));
1084                                                  
1085  ***      0      0      0                    0      if ( !($privs =~ m/select/ && $privs =~ m/insert/ && $privs =~ m/update/
      ***                    0                        
      ***                    0                        
1086                                                            && $can_delete) ) {
1087  ***      0                                  0         MKDEBUG && _d('User does not have all privs');
1088  ***      0                                  0         return 0;
1089                                                     }
1090                                                  
1091  ***      0                                  0      MKDEBUG && _d('User has all privs');
1092  ***      0                                  0      return 1;
1093                                                  }
1094                                                  
1095                                                  sub get_engine {
1096          50                   50           349      my ( $self, $ddl, $opts ) = @_;
1097          50                                979      my ( $engine ) = $ddl =~ m/\).*?(?:ENGINE|TYPE)=(\w+)/;
1098          50                                196      MKDEBUG && _d('Storage engine:', $engine);
1099  ***     50            50                  409      return $engine || undef;
1100                                                  }
1101                                                  
1102                                                  sub get_keys {
1103          25                   25           204      my ( $self, $ddl, $opts, $is_nullable ) = @_;
1104          25                                141      my $engine        = $self->get_engine($ddl);
1105          25                                109      my $keys          = {};
1106          25                                 90      my $clustered_key = undef;
1107                                                  
1108                                                     KEY:
1109          25                                479      foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {
1110                                                  
1111  ***     41     50                         240         next KEY if $key =~ m/FOREIGN/;
1112                                                  
1113          41                                152         my $key_ddl = $key;
1114          41                                121         MKDEBUG && _d('Parsed key:', $key_ddl);
1115                                                  
1116  ***     41     50                         330         if ( $engine !~ m/MEMORY|HEAP/ ) {
1117          41                                180            $key =~ s/USING HASH/USING BTREE/;
1118                                                        }
1119                                                  
1120          41                                449         my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
1121          41                                256         my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
1122  ***     41            33                  747         $type = $type || $special || 'BTREE';
      ***                   50                        
1123  ***     41     50     33                  390         if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
      ***                   33                        
1124                                                           && $engine =~ m/HEAP|MEMORY/i )
1125                                                        {
1126  ***      0                                  0            $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
1127                                                        }
1128                                                  
1129          41                                451         my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
1130          41    100                         346         my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
1131          41                                129         my @cols;
1132          41                                123         my @col_prefixes;
1133          41                                263         foreach my $col_def ( split(',', $cols) ) {
1134          41                                420            my ($name, $prefix) = $col_def =~ m/`([^`]+)`(?:\((\d+)\))?/;
1135          41                                217            push @cols, $name;
1136          41                                235            push @col_prefixes, $prefix;
1137                                                        }
1138          41                                244         $name =~ s/`//g;
1139                                                  
1140          41                                117         MKDEBUG && _d('Key', $name, 'cols:', join(', ', @cols));
1141                                                  
1142          41                                270         $keys->{$name} = {
1143                                                           name         => $name,
1144                                                           type         => $type,
1145                                                           colnames     => $cols,
1146                                                           cols         => \@cols,
1147                                                           col_prefixes => \@col_prefixes,
1148                                                           is_unique    => $unique,
1149          41                                696            is_nullable  => scalar(grep { $is_nullable->{$_} } @cols),
1150          41                                331            is_col       => { map { $_ => 1 } @cols },
1151                                                           ddl          => $key_ddl,
1152                                                        };
1153                                                  
1154  ***     41    100     66                  686         if ( $engine =~ m/InnoDB/i && !$clustered_key ) {
1155          23                                116            my $this_key = $keys->{$name};
1156  ***     23     50      0                  137            if ( $this_key->{name} eq 'PRIMARY' ) {
      ***             0                               
1157          23                                 87               $clustered_key = 'PRIMARY';
1158                                                           }
1159                                                           elsif ( $this_key->{is_unique} && !$this_key->{is_nullable} ) {
1160  ***      0                                  0               $clustered_key = $this_key->{name};
1161                                                           }
1162          23                                118            MKDEBUG && $clustered_key && _d('This key is the clustered key');
1163                                                        }
1164                                                     }
1165                                                  
1166          25                                214      return $keys, $clustered_key;
1167                                                  }
1168                                                  
1169                                                  sub get_fks {
1170  ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
1171  ***      0                                  0      my $fks = {};
1172                                                  
1173  ***      0                                  0      foreach my $fk (
1174                                                        $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg )
1175                                                     {
1176  ***      0                                  0         my ( $name ) = $fk =~ m/CONSTRAINT `(.*?)`/;
1177  ***      0                                  0         my ( $cols ) = $fk =~ m/FOREIGN KEY \(([^\)]+)\)/;
1178  ***      0                                  0         my ( $parent, $parent_cols ) = $fk =~ m/REFERENCES (\S+) \(([^\)]+)\)/;
1179                                                  
1180  ***      0      0      0                    0         if ( $parent !~ m/\./ && $opts->{database} ) {
1181  ***      0                                  0            $parent = "`$opts->{database}`.$parent";
1182                                                        }
1183                                                  
1184  ***      0                                  0         $fks->{$name} = {
1185                                                           name           => $name,
1186                                                           colnames       => $cols,
1187  ***      0                                  0            cols           => [ map { s/[ `]+//g; $_; } split(',', $cols) ],
      ***      0                                  0   
1188                                                           parent_tbl     => $parent,
1189                                                           parent_colnames=> $parent_cols,
1190  ***      0                                  0            parent_cols    => [ map { s/[ `]+//g; $_; } split(',', $parent_cols) ],
      ***      0                                  0   
1191                                                           ddl            => $fk,
1192                                                        };
1193                                                     }
1194                                                  
1195  ***      0                                  0      return $fks;
1196                                                  }
1197                                                  
1198                                                  sub remove_auto_increment {
1199  ***      0                    0             0      my ( $self, $ddl ) = @_;
1200  ***      0                                  0      $ddl =~ s/(^\).*?) AUTO_INCREMENT=\d+\b/$1/m;
1201  ***      0                                  0      return $ddl;
1202                                                  }
1203                                                  
1204                                                  sub remove_secondary_indexes {
1205  ***      0                    0             0      my ( $self, $ddl ) = @_;
1206  ***      0                                  0      my $sec_indexes_ddl;
1207  ***      0                                  0      my $tbl_struct = $self->parse($ddl);
1208                                                  
1209  ***      0      0      0                    0      if ( ($tbl_struct->{engine} || '') =~ m/InnoDB/i ) {
1210  ***      0                                  0         my $clustered_key = $tbl_struct->{clustered_key};
1211  ***      0             0                    0         $clustered_key  ||= '';
1212                                                  
1213  ***      0                                  0         my @sec_indexes   = map {
1214  ***      0                                  0            my $key_def = $_->{ddl};
1215  ***      0                                  0            $key_def =~ s/([\(\)])/\\$1/g;
1216  ***      0                                  0            $ddl =~ s/\s+$key_def//;
1217  ***      0                                  0            "ADD $_->{ddl}";
1218                                                        }
1219  ***      0                                  0         grep { $_->{name} ne $clustered_key }
1220  ***      0                                  0         values %{$tbl_struct->{keys}};
1221  ***      0                                  0         MKDEBUG && _d('Secondary indexes:', Dumper(\@sec_indexes));
1222                                                  
1223  ***      0      0                           0         if ( @sec_indexes ) {
1224  ***      0                                  0            $sec_indexes_ddl = join(' ', @sec_indexes);
1225  ***      0                                  0            $sec_indexes_ddl =~ s/,$//;
1226                                                        }
1227                                                  
1228  ***      0                                  0         $ddl =~ s/,(\n\) )/$1/s;
1229                                                     }
1230                                                     else {
1231  ***      0                                  0         MKDEBUG && _d('Not removing secondary indexes from',
1232                                                           $tbl_struct->{engine}, 'table');
1233                                                     }
1234                                                  
1235  ***      0                                  0      return $ddl, $sec_indexes_ddl, $tbl_struct;
1236                                                  }
1237                                                  
1238                                                  sub _d {
1239  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1240  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1241  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1242                                                          @_;
1243  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1244                                                  }
1245                                                  
1246                                                  1;
1247                                                  
1248                                                  # ###########################################################################
1249                                                  # End TableParser package
1250                                                  # ###########################################################################
1251                                                  
1252                                                  # ###########################################################################
1253                                                  # DSNParser package 5266
1254                                                  # ###########################################################################
1255                                                  package DSNParser;
1256                                                  
1257          17                   17           169   use strict;
              17                                 54   
              17                                121   
1258          17                   17           107   use warnings FATAL => 'all';
              17                                 53   
              17                                122   
1259          17                   17           101   use English qw(-no_match_vars);
              17                                 48   
              17                                100   
1260          17                   17           125   use Data::Dumper;
              17                                 44   
              17                                 98   
1261                                                  $Data::Dumper::Indent    = 0;
1262                                                  $Data::Dumper::Quotekeys = 0;
1263                                                  
1264                                                  eval {
1265                                                     require DBI;
1266                                                  };
1267                                                  my $have_dbi = $EVAL_ERROR ? 0 : 1;
1268                                                  
1269  ***     17            50     17           114   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              17                                 51   
              17                                252   
1270                                                  
1271                                                  sub new {
1272          34                   34           176      my ( $class, @opts ) = @_;
1273          34                                769      my $self = {
1274                                                        opts => {
1275                                                           A => {
1276                                                              desc => 'Default character set',
1277                                                              dsn  => 'charset',
1278                                                              copy => 1,
1279                                                           },
1280                                                           D => {
1281                                                              desc => 'Database to use',
1282                                                              dsn  => 'database',
1283                                                              copy => 1,
1284                                                           },
1285                                                           F => {
1286                                                              desc => 'Only read default options from the given file',
1287                                                              dsn  => 'mysql_read_default_file',
1288                                                              copy => 1,
1289                                                           },
1290                                                           h => {
1291                                                              desc => 'Connect to host',
1292                                                              dsn  => 'host',
1293                                                              copy => 1,
1294                                                           },
1295                                                           p => {
1296                                                              desc => 'Password to use when connecting',
1297                                                              dsn  => 'password',
1298                                                              copy => 1,
1299                                                           },
1300                                                           P => {
1301                                                              desc => 'Port number to use for connection',
1302                                                              dsn  => 'port',
1303                                                              copy => 1,
1304                                                           },
1305                                                           S => {
1306                                                              desc => 'Socket file to use for connection',
1307                                                              dsn  => 'mysql_socket',
1308                                                              copy => 1,
1309                                                           },
1310                                                           u => {
1311                                                              desc => 'User for login if not current user',
1312                                                              dsn  => 'user',
1313                                                              copy => 1,
1314                                                           },
1315                                                        },
1316                                                     };
1317          34                                149      foreach my $opt ( @opts ) {
1318         102                                520         MKDEBUG && _d('Adding extra property', $opt->{key});
1319         102                                733         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
1320                                                     }
1321          34                                362      return bless $self, $class;
1322                                                  }
1323                                                  
1324                                                  sub prop {
1325         175                  175          1026      my ( $self, $prop, $value ) = @_;
1326         175    100                        1043      if ( @_ > 2 ) {
1327          18                                 57         MKDEBUG && _d('Setting', $prop, 'property');
1328          18                                 99         $self->{$prop} = $value;
1329                                                     }
1330         175                               1613      return $self->{$prop};
1331                                                  }
1332                                                  
1333                                                  sub parse {
1334          69                   69          1203      my ( $self, $dsn, $prev, $defaults ) = @_;
1335          69    100                         444      if ( !$dsn ) {
1336          25                                 89         MKDEBUG && _d('No DSN to parse');
1337          25                                149         return;
1338                                                     }
1339          44                                159      MKDEBUG && _d('Parsing', $dsn);
1340          44           100                  264      $prev     ||= {};
1341  ***     44            50                  286      $defaults ||= {};
1342          44                                142      my %given_props;
1343          44                                143      my %final_props;
1344          44                                143      my %opts = %{$self->{opts}};
              44                                677   
1345                                                  
1346          44                                541      foreach my $dsn_part ( split(/,/, $dsn) ) {
1347  ***    137     50                        1412         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1348         137                                801            $given_props{$prop_key} = $prop_val;
1349                                                        }
1350                                                        else {
1351  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1352  ***      0                                  0            $given_props{h} = $dsn_part;
1353                                                        }
1354                                                     }
1355                                                  
1356          44                                381      foreach my $key ( keys %opts ) {
1357         477                               1351         MKDEBUG && _d('Finding value for', $key);
1358         477                               2069         $final_props{$key} = $given_props{$key};
1359         477    100    100                 5431         if (   !defined $final_props{$key}
      ***                   66                        
1360                                                             && defined $prev->{$key} && $opts{$key}->{copy} )
1361                                                        {
1362          14                                 64            $final_props{$key} = $prev->{$key};
1363          14                                 43            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1364                                                        }
1365         477    100                        2536         if ( !defined $final_props{$key} ) {
1366         326                               1382            $final_props{$key} = $defaults->{$key};
1367         326                               1155            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1368                                                        }
1369                                                     }
1370                                                  
1371          44                                294      foreach my $key ( keys %given_props ) {
1372  ***    137     50                         760         die "Unrecognized DSN part '$key' in '$dsn'\n"
1373                                                           unless exists $opts{$key};
1374                                                     }
1375  ***     44     50                         358      if ( (my $required = $self->prop('required')) ) {
1376  ***      0                                  0         foreach my $key ( keys %$required ) {
1377  ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1378                                                        }
1379                                                     }
1380                                                  
1381          44                                662      return \%final_props;
1382                                                  }
1383                                                  
1384                                                  sub parse_options {
1385          25                   25           262      my ( $self, $o ) = @_;
1386  ***     25     50                         203      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1387  ***      0                                  0      my $dsn_string
1388                                                        = join(',',
1389         325    100                        1610             map  { "$_=".$o->get($_); }
1390          25                                279             grep { $o->has($_) && $o->get($_) }
1391          25                                108             keys %{$self->{opts}}
1392                                                          );
1393          25                                147      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1394          25                                161      return $self->parse($dsn_string);
1395                                                  }
1396                                                  
1397                                                  sub as_string {
1398           3                    3            21      my ( $self, $dsn ) = @_;
1399  ***      3     50                          26      return $dsn unless ref $dsn;
1400  ***      9     50                         107      return join(',',
1401          51    100                         554         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1402           3                                 91         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1403                                                        sort keys %$dsn );
1404                                                  }
1405                                                  
1406                                                  sub usage {
1407  ***      0                    0             0      my ( $self ) = @_;
1408  ***      0                                  0      my $usage
1409                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1410                                                        . "  KEY  COPY  MEANING\n"
1411                                                        . "  ===  ====  =============================================\n";
1412  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1413  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1414  ***      0      0      0                    0         $usage .= "  $key    "
1415                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1416                                                               .  ($opts{$key}->{desc} || '[No description]')
1417                                                               . "\n";
1418                                                     }
1419  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1420  ***      0                                  0      return $usage;
1421                                                  }
1422                                                  
1423                                                  sub get_cxn_params {
1424          44                   44           410      my ( $self, $info ) = @_;
1425          44                                147      my $dsn;
1426          44                                145      my %opts = %{$self->{opts}};
              44                                655   
1427  ***     44            50                  357      my $driver = $self->prop('dbidriver') || '';
1428  ***     44     50                         256      if ( $driver eq 'Pg' ) {
1429  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1430  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1431  ***      0             0                    0                        grep { defined $info->{$_} }
1432                                                                       qw(h P));
1433                                                     }
1434                                                     else {
1435          63                                616         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1436         220                               1038            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1437          44           100                  552                        grep { defined $info->{$_} }
1438                                                                       qw(F h P S A))
1439                                                           . ';mysql_read_default_group=client';
1440                                                     }
1441          44                                165      MKDEBUG && _d($dsn);
1442          44                                643      return ($dsn, $info->{u}, $info->{p});
1443                                                  }
1444                                                  
1445                                                  sub fill_in_dsn {
1446  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1447  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1448  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1449  ***      0                                  0      $user =~ s/@.*//;
1450  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1451  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1452  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1453  ***      0             0                    0      $dsn->{u} ||= $user;
1454  ***      0             0                    0      $dsn->{D} ||= $db;
1455                                                  }
1456                                                  
1457                                                  sub get_dbh {
1458          44                   44           344      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1459  ***     44            50                  258      $opts ||= {};
1460  ***     44     50                         534      my $defaults = {
1461                                                        AutoCommit         => 0,
1462                                                        RaiseError         => 1,
1463                                                        PrintError         => 0,
1464                                                        ShowErrorStatement => 1,
1465                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1466                                                     };
1467          44                                298      @{$defaults}{ keys %$opts } = values %$opts;
              44                                236   
1468                                                  
1469  ***     44     50                         251      if ( !$have_dbi ) {
1470  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1471                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1472                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1473                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1474                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1475                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1476                                                  
1477                                                     }
1478                                                  
1479          44                                145      my $dbh;
1480          44                                171      my $tries = 2;
1481  ***     44            66                  534      while ( !$dbh && $tries-- ) {
1482                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1483          44                                125            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1484                                                  
1485          44                                171         eval {
1486          44                                514            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1487                                                  
1488  ***     44     50                         574            if ( $cxn_string =~ m/mysql/i ) {
1489          44                                153               my $sql;
1490                                                  
1491          44                                198               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1492                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1493          44                                145               MKDEBUG && _d($dbh, ':', $sql);
1494          44                               6907               $dbh->do($sql);
1495                                                  
1496  ***     44     50                         466               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1497  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1498  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1499  ***      0                                  0                  $dbh->do($sql);
1500  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1501  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1502  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1503                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1504                                                                 }
1505                                                                 else {
1506  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1507                                                                 }
1508                                                              }
1509                                                  
1510          44    100                         330               if ( $self->prop('set-vars') ) {
1511          25                                144                  $sql = "SET " . $self->prop('set-vars');
1512          25                                 89                  MKDEBUG && _d($dbh, ':', $sql);
1513          25                               2446                  $dbh->do($sql);
1514                                                              }
1515                                                           }
1516                                                        };
1517  ***     44     50     33                  590         if ( !$dbh && $EVAL_ERROR ) {
1518  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1519  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1520  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1521  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1522                                                           }
1523                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1524  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1525                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1526                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1527                                                                 . "DBD::mysql is not installed, try:\n"
1528                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1529                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1530                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1531                                                           }
1532  ***      0      0                           0            if ( !$tries ) {
1533  ***      0                                  0               die $EVAL_ERROR;
1534                                                           }
1535                                                        }
1536                                                     }
1537                                                  
1538          44                                124      MKDEBUG && _d('DBH info: ',
1539                                                        $dbh,
1540                                                        Dumper($dbh->selectrow_hashref(
1541                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1542                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1543                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1544                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1545                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1546                                                        '$DBI::VERSION:',        $DBI::VERSION,
1547                                                     );
1548                                                  
1549          44                                303      return $dbh;
1550                                                  }
1551                                                  
1552                                                  sub get_hostname {
1553  ***      0                    0             0      my ( $self, $dbh ) = @_;
1554  ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1555  ***      0                                  0         return $host;
1556                                                     }
1557  ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
1558                                                        'SELECT /*!50038 @@hostname, */ 1');
1559  ***      0                                  0      return $hostname;
1560                                                  }
1561                                                  
1562                                                  sub disconnect {
1563  ***      0                    0             0      my ( $self, $dbh ) = @_;
1564  ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
1565  ***      0                                  0      $dbh->disconnect;
1566                                                  }
1567                                                  
1568                                                  sub print_active_handles {
1569  ***      0                    0             0      my ( $self, $thing, $level ) = @_;
1570  ***      0             0                    0      $level ||= 0;
1571  ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1572                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1573                                                        or die "Cannot print: $OS_ERROR";
1574  ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
1575  ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
1576                                                     }
1577                                                  }
1578                                                  
1579                                                  sub copy {
1580  ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1581  ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
1582  ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
1583  ***      0                                  0      my %new_dsn = map {
1584  ***      0                                  0         my $key = $_;
1585  ***      0                                  0         my $val;
1586  ***      0      0                           0         if ( $args{overwrite} ) {
1587  ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1588                                                        }
1589                                                        else {
1590  ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1591                                                        }
1592  ***      0                                  0         $key => $val;
1593  ***      0                                  0      } keys %{$self->{opts}};
1594  ***      0                                  0      return \%new_dsn;
1595                                                  }
1596                                                  
1597                                                  sub _d {
1598  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1599  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1600  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1601                                                          @_;
1602  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1603                                                  }
1604                                                  
1605                                                  1;
1606                                                  
1607                                                  # ###########################################################################
1608                                                  # End DSNParser package
1609                                                  # ###########################################################################
1610                                                  
1611                                                  # ###########################################################################
1612                                                  # VersionParser package 5266
1613                                                  # ###########################################################################
1614                                                  package VersionParser;
1615                                                  
1616          17                   17           162   use strict;
              17                                 49   
              17                                183   
1617          17                   17           104   use warnings FATAL => 'all';
              17                                 52   
              17                                128   
1618                                                  
1619          17                   17           109   use English qw(-no_match_vars);
              17                                 44   
              17                                113   
1620                                                  
1621  ***     17            50     17           135   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              17                                 45   
              17                                281   
1622                                                  
1623                                                  sub new {
1624          17                   17            81      my ( $class ) = @_;
1625          17                                183      bless {}, $class;
1626                                                  }
1627                                                  
1628                                                  sub parse {
1629          67                   67          4340      my ( $self, $str ) = @_;
1630          67                               1091      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
1631          67                                247      MKDEBUG && _d($str, 'parses to', $result);
1632          67                                604      return $result;
1633                                                  }
1634                                                  
1635                                                  sub version_ge {
1636          42                   42           300      my ( $self, $dbh, $target ) = @_;
1637          42    100                         404      if ( !$self->{$dbh} ) {
1638          25                                 88         $self->{$dbh} = $self->parse(
1639                                                           $dbh->selectrow_array('SELECT VERSION()'));
1640                                                     }
1641  ***     42     50                         876      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
1642          42                                138      MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
1643          42                                391      return $result;
1644                                                  }
1645                                                  
1646                                                  sub _d {
1647  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1648  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1649  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1650                                                          @_;
1651  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1652                                                  }
1653                                                  
1654                                                  1;
1655                                                  
1656                                                  # ###########################################################################
1657                                                  # End VersionParser package
1658                                                  # ###########################################################################
1659                                                  
1660                                                  # ###########################################################################
1661                                                  # Quoter package 5266
1662                                                  # ###########################################################################
1663          17                   17           132   use strict;
              17                                 57   
              17                                100   
1664          17                   17           104   use warnings FATAL => 'all';
              17                                 50   
              17                                105   
1665                                                  
1666                                                  package Quoter;
1667                                                  
1668          17                   17           106   use English qw(-no_match_vars);
              17                                 48   
              17                                 93   
1669                                                  
1670  ***     17            50     17           128   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              17                                 45   
              17                                353   
1671                                                  
1672                                                  sub new {
1673          17                   17            71      my ( $class ) = @_;
1674          17                                175      bless {}, $class;
1675                                                  }
1676                                                  
1677                                                  sub quote {
1678         219                  219          1355      my ( $self, @vals ) = @_;
1679         219                               1065      foreach my $val ( @vals ) {
1680         269                               1461         $val =~ s/`/``/g;
1681                                                     }
1682         219                               1060      return join('.', map { '`' . $_ . '`' } @vals);
             269                               2349   
1683                                                  }
1684                                                  
1685                                                  sub quote_val {
1686  ***      0                    0             0      my ( $self, $val, $is_numeric ) = @_;
1687                                                  
1688  ***      0      0                           0      return 'NULL' unless defined $val;  # undef = NULL
1689  ***      0      0                           0      return "''" if $val eq '';          # blank string = ''
1690                                                  
1691  ***      0      0                           0      if ( !defined $is_numeric ) {
1692  ***      0      0                           0         $is_numeric = $val =~ m/^0|\D/ ? 0 : 1;
1693                                                     }
1694                                                  
1695  ***      0      0                           0      return $val if $is_numeric;
1696                                                  
1697  ***      0                                  0      $val =~ s/(['\\])/\\$1/g;
1698  ***      0                                  0      return "'$val'";
1699                                                  }
1700                                                  
1701                                                  sub split_unquote {
1702          25                   25           155      my ( $self, $db_tbl, $default_db ) = @_;
1703          25                                227      $db_tbl =~ s/`//g;
1704          25                                215      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
1705  ***     25     50                         169      if ( !$tbl ) {
1706          25                                102         $tbl = $db;
1707          25                                 91         $db  = $default_db;
1708                                                     }
1709          25                                191      return ($db, $tbl);
1710                                                  }
1711                                                  
1712                                                  sub literal_like {
1713  ***      0                    0             0      my ( $self, $like ) = @_;
1714  ***      0      0                           0      return unless $like;
1715  ***      0                                  0      $like =~ s/([%_])/\\$1/g;
1716  ***      0                                  0      return "'$like'";
1717                                                  }
1718                                                  
1719                                                  1;
1720                                                  
1721                                                  # ###########################################################################
1722                                                  # End Quoter package
1723                                                  # ###########################################################################
1724                                                  
1725                                                  # ###########################################################################
1726                                                  # TableNibbler package 5266
1727                                                  # ###########################################################################
1728                                                  package TableNibbler;
1729                                                  
1730          17                   17           134   use strict;
              17                                 47   
              17                                 91   
1731          17                   17           106   use warnings FATAL => 'all';
              17                                 44   
              17                                101   
1732                                                  
1733          17                   17           106   use English qw(-no_match_vars);
              17                                 47   
              17                                101   
1734                                                  
1735  ***     17            50     17           118   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              17                                 46   
              17                                241   
1736                                                  
1737                                                  sub new {
1738          17                   17           173      my ( $class, %args ) = @_;
1739          17                                125      my @required_args = qw(TableParser Quoter);
1740          17                                104      foreach my $arg ( @required_args ) {
1741  ***     34     50                         244         die "I need a $arg argument" unless $args{$arg};
1742                                                     }
1743          17                                140      my $self = { %args };
1744          17                                167      return bless $self, $class;
1745                                                  }
1746                                                  
1747                                                  sub generate_asc_stmt {
1748          17                   17           208      my ( $self, %args ) = @_;
1749          17                                125      my @required_args = qw(tbl_struct index);
1750          17                                 95      foreach my $arg ( @required_args ) {
1751  ***     34     50                         250         die "I need a $arg argument" unless defined $args{$arg};
1752                                                     }
1753          17                                112      my ($tbl_struct, $index) = @args{@required_args};
1754  ***     17     50                         108      my @cols = $args{cols}  ? @{$args{cols}} : @{$tbl_struct->{cols}};
              17                                137   
      ***      0                                  0   
1755          17                                108      my $q    = $self->{Quoter};
1756                                                  
1757  ***     17     50                         117      die "Index '$index' does not exist in table"
1758                                                        unless exists $tbl_struct->{keys}->{$index};
1759                                                  
1760          17                                 64      my @asc_cols = @{$tbl_struct->{keys}->{$index}->{cols}};
              17                                133   
1761          17                                 60      my @asc_slice;
1762                                                  
1763          17                                 88      @asc_cols = @{$tbl_struct->{keys}->{$index}->{cols}};
              17                                133   
1764          17                                 50      MKDEBUG && _d('Will ascend index', $index);
1765          17                                 56      MKDEBUG && _d('Will ascend columns', join(', ', @asc_cols));
1766  ***     17     50                         106      if ( $args{asc_first} ) {
1767  ***      0                                  0         @asc_cols = $asc_cols[0];
1768  ***      0                                  0         MKDEBUG && _d('Ascending only first column');
1769                                                     }
1770                                                  
1771          17                                 68      my %col_posn = do { my $i = 0; map { $_ => $i++ } @cols };
              17                                 72   
              17                                 76   
              63                                410   
1772          17                                132      foreach my $col ( @asc_cols ) {
1773  ***     17     50                         104         if ( !exists $col_posn{$col} ) {
1774  ***      0                                  0            push @cols, $col;
1775  ***      0                                  0            $col_posn{$col} = $#cols;
1776                                                        }
1777          17                                112         push @asc_slice, $col_posn{$col};
1778                                                     }
1779          17                                 55      MKDEBUG && _d('Will ascend, in ordinal position:', join(', ', @asc_slice));
1780                                                  
1781          17                                187      my $asc_stmt = {
1782                                                        cols  => \@cols,
1783                                                        index => $index,
1784                                                        where => '',
1785                                                        slice => [],
1786                                                        scols => [],
1787                                                     };
1788                                                  
1789  ***     17     50                         103      if ( @asc_slice ) {
1790          17                                 56         my $cmp_where;
1791          17                                 90         foreach my $cmp ( qw(< <= >= >) ) {
1792          68                                649            $cmp_where = $self->generate_cmp_where(
1793                                                              type        => $cmp,
1794                                                              slice       => \@asc_slice,
1795                                                              cols        => \@cols,
1796                                                              quoter      => $q,
1797                                                              is_nullable => $tbl_struct->{is_nullable},
1798                                                           );
1799          68                                694            $asc_stmt->{boundaries}->{$cmp} = $cmp_where->{where};
1800                                                        }
1801          17    100                         120         my $cmp = $args{asc_only} ? '>' : '>=';
1802          17                                113         $asc_stmt->{where} = $asc_stmt->{boundaries}->{$cmp};
1803          17                                 97         $asc_stmt->{slice} = $cmp_where->{slice};
1804          17                                117         $asc_stmt->{scols} = $cmp_where->{scols};
1805                                                     }
1806                                                  
1807          17                                147      return $asc_stmt;
1808                                                  }
1809                                                  
1810                                                  sub generate_cmp_where {
1811          68                   68           676      my ( $self, %args ) = @_;
1812          68                                437      foreach my $arg ( qw(type slice cols is_nullable) ) {
1813  ***    272     50                        1723         die "I need a $arg arg" unless defined $args{$arg};
1814                                                     }
1815          68                                244      my @slice       = @{$args{slice}};
              68                                405   
1816          68                                242      my @cols        = @{$args{cols}};
              68                                488   
1817          68                                320      my $is_nullable = $args{is_nullable};
1818          68                                274      my $type        = $args{type};
1819          68                                300      my $q           = $self->{Quoter};
1820                                                  
1821          68                                414      (my $cmp = $type) =~ s/=//;
1822                                                  
1823          68                                203      my @r_slice;    # Resulting slice columns, by ordinal
1824          68                                203      my @r_scols;    # Ditto, by name
1825                                                  
1826          68                                213      my @clauses;
1827          68                                485      foreach my $i ( 0 .. $#slice ) {
1828          68                                216         my @clause;
1829                                                  
1830          68                                408         foreach my $j ( 0 .. $i - 1 ) {
1831  ***      0                                  0            my $ord = $slice[$j];
1832  ***      0                                  0            my $col = $cols[$ord];
1833  ***      0                                  0            my $quo = $q->quote($col);
1834  ***      0      0                           0            if ( $is_nullable->{$col} ) {
1835  ***      0                                  0               push @clause, "((? IS NULL AND $quo IS NULL) OR ($quo = ?))";
1836  ***      0                                  0               push @r_slice, $ord, $ord;
1837  ***      0                                  0               push @r_scols, $col, $col;
1838                                                           }
1839                                                           else {
1840  ***      0                                  0               push @clause, "$quo = ?";
1841  ***      0                                  0               push @r_slice, $ord;
1842  ***      0                                  0               push @r_scols, $col;
1843                                                           }
1844                                                        }
1845                                                  
1846          68                                297         my $ord = $slice[$i];
1847          68                                290         my $col = $cols[$ord];
1848          68                                338         my $quo = $q->quote($col);
1849          68                                383         my $end = $i == $#slice; # Last clause of the whole group.
1850  ***     68     50                         417         if ( $is_nullable->{$col} ) {
1851  ***      0      0      0                    0            if ( $type =~ m/=/ && $end ) {
      ***             0                               
1852  ***      0                                  0               push @clause, "(? IS NULL OR $quo $type ?)";
1853                                                           }
1854                                                           elsif ( $type =~ m/>/ ) {
1855  ***      0                                  0               push @clause, "((? IS NULL AND $quo IS NOT NULL) OR ($quo $cmp ?))";
1856                                                           }
1857                                                           else { # If $type =~ m/</ ) {
1858  ***      0                                  0               push @clause, "((? IS NOT NULL AND $quo IS NULL) OR ($quo $cmp ?))";
1859                                                           }
1860  ***      0                                  0            push @r_slice, $ord, $ord;
1861  ***      0                                  0            push @r_scols, $col, $col;
1862                                                        }
1863                                                        else {
1864          68                                298            push @r_slice, $ord;
1865          68                                280            push @r_scols, $col;
1866  ***     68    100     66                  931            push @clause, ($type =~ m/=/ && $end ? "$quo $type ?" : "$quo $cmp ?");
1867                                                        }
1868                                                  
1869          68                                574         push @clauses, '(' . join(' AND ', @clause) . ')';
1870                                                     }
1871          68                                416      my $result = '(' . join(' OR ', @clauses) . ')';
1872          68                                581      my $where = {
1873                                                        slice => \@r_slice,
1874                                                        scols => \@r_scols,
1875                                                        where => $result,
1876                                                     };
1877          68                                577      return $where;
1878                                                  }
1879                                                  
1880                                                  sub generate_del_stmt {
1881          17                   17           211      my ( $self, %args ) = @_;
1882                                                  
1883          17                                140      my $tbl  = $args{tbl_struct};
1884  ***     17     50                          96      my @cols = $args{cols} ? @{$args{cols}} : ();
              17                                149   
1885          17                                 86      my $tp   = $self->{TableParser};
1886          17                                 77      my $q    = $self->{Quoter};
1887                                                  
1888          17                                 56      my @del_cols;
1889          17                                 55      my @del_slice;
1890                                                  
1891          17                                153      my $index = $tp->find_best_index($tbl, $args{index});
1892  ***     17     50                          90      die "Cannot find an ascendable index in table" unless $index;
1893                                                  
1894  ***     17     50                          82      if ( $index ) {
1895          17                                 67         @del_cols = @{$tbl->{keys}->{$index}->{cols}};
              17                                150   
1896                                                     }
1897                                                     else {
1898  ***      0                                  0         @del_cols = @{$tbl->{cols}};
      ***      0                                  0   
1899                                                     }
1900          17                                 57      MKDEBUG && _d('Columns needed for DELETE:', join(', ', @del_cols));
1901                                                  
1902          17                                 61      my %col_posn = do { my $i = 0; map { $_ => $i++ } @cols };
              17                                 69   
              17                                 72   
              63                                411   
1903          17                                121      foreach my $col ( @del_cols ) {
1904  ***     17     50                         107         if ( !exists $col_posn{$col} ) {
1905  ***      0                                  0            push @cols, $col;
1906  ***      0                                  0            $col_posn{$col} = $#cols;
1907                                                        }
1908          17                                130         push @del_slice, $col_posn{$col};
1909                                                     }
1910          17                                 54      MKDEBUG && _d('Ordinals needed for DELETE:', join(', ', @del_slice));
1911                                                  
1912          17                                221      my $del_stmt = {
1913                                                        cols  => \@cols,
1914                                                        index => $index,
1915                                                        where => '',
1916                                                        slice => [],
1917                                                        scols => [],
1918                                                     };
1919                                                  
1920          17                                 66      my @clauses;
1921          17                                136      foreach my $i ( 0 .. $#del_slice ) {
1922          17                                 78         my $ord = $del_slice[$i];
1923          17                                 78         my $col = $cols[$ord];
1924          17                                109         my $quo = $q->quote($col);
1925  ***     17     50                         123         if ( $tbl->{is_nullable}->{$col} ) {
1926  ***      0                                  0            push @clauses, "((? IS NULL AND $quo IS NULL) OR ($quo = ?))";
1927  ***      0                                  0            push @{$del_stmt->{slice}}, $ord, $ord;
      ***      0                                  0   
1928  ***      0                                  0            push @{$del_stmt->{scols}}, $col, $col;
      ***      0                                  0   
1929                                                        }
1930                                                        else {
1931          17                                103            push @clauses, "$quo = ?";
1932          17                                 60            push @{$del_stmt->{slice}}, $ord;
              17                                118   
1933          17                                 62            push @{$del_stmt->{scols}}, $col;
              17                                129   
1934                                                        }
1935                                                     }
1936                                                  
1937          17                                137      $del_stmt->{where} = '(' . join(' AND ', @clauses) . ')';
1938                                                  
1939          17                                149      return $del_stmt;
1940                                                  }
1941                                                  
1942                                                  sub generate_ins_stmt {
1943           6                    6            48      my ( $self, %args ) = @_;
1944           6                                 35      foreach my $arg ( qw(ins_tbl sel_cols) ) {
1945  ***     12     50                          76         die "I need a $arg argument" unless $args{$arg};
1946                                                     }
1947           6                                 26      my $ins_tbl  = $args{ins_tbl};
1948           6                                 20      my @sel_cols = @{$args{sel_cols}};
               6                                 46   
1949                                                  
1950  ***      6     50                          34      die "You didn't specify any SELECT columns" unless @sel_cols;
1951                                                  
1952           6                                 19      my @ins_cols;
1953           6                                 17      my @ins_slice;
1954           6                                 43      for my $i ( 0..$#sel_cols ) {
1955          24    100                         167         next unless $ins_tbl->{is_col}->{$sel_cols[$i]};
1956          21                                 84         push @ins_cols, $sel_cols[$i];
1957          21                                 87         push @ins_slice, $i;
1958                                                     }
1959                                                  
1960                                                     return {
1961           6                                 73         cols  => \@ins_cols,
1962                                                        slice => \@ins_slice,
1963                                                     };
1964                                                  }
1965                                                  
1966                                                  sub _d {
1967  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1968  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1969  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1970                                                          @_;
1971  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1972                                                  }
1973                                                  
1974                                                  1;
1975                                                  
1976                                                  # ###########################################################################
1977                                                  # End TableNibbler package
1978                                                  # ###########################################################################
1979                                                  
1980                                                  # ###########################################################################
1981                                                  # MySQLDump package 5266
1982                                                  # ###########################################################################
1983                                                  package MySQLDump;
1984                                                  
1985          17                   17           144   use strict;
              17                                 56   
              17                               3558   
1986          17                   17           370   use warnings FATAL => 'all';
              17                                 42   
              17                                592   
1987                                                  
1988          17                   17            99   use English qw(-no_match_vars);
              17                                 40   
              17                                 86   
1989                                                  
1990  ***     17            50     17           118   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              17                                 56   
              17                                241   
1991                                                  
1992                                                  ( our $before = <<'EOF') =~ s/^   //gm;
1993                                                     /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
1994                                                     /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
1995                                                     /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
1996                                                     /*!40101 SET NAMES utf8 */;
1997                                                     /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
1998                                                     /*!40103 SET TIME_ZONE='+00:00' */;
1999                                                     /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
2000                                                     /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
2001                                                     /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
2002                                                     /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
2003                                                  EOF
2004                                                  
2005                                                  ( our $after = <<'EOF') =~ s/^   //gm;
2006                                                     /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
2007                                                     /*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
2008                                                     /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
2009                                                     /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
2010                                                     /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
2011                                                     /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
2012                                                     /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
2013                                                     /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
2014                                                  EOF
2015                                                  
2016                                                  sub new {
2017          18                   18           133      my ( $class, %args ) = @_;
2018  ***     18     50                         196      $args{cache} = 1 unless defined $args{cache};
2019          18                                118      my $self = bless \%args, $class;
2020          18                                366      return $self;
2021                                                  }
2022                                                  
2023                                                  sub dump {
2024  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl, $what ) = @_;
2025                                                  
2026  ***      0      0                           0      if ( $what eq 'table' ) {
      ***             0                               
      ***             0                               
2027  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
2028  ***      0      0                           0         return unless $ddl;
2029  ***      0      0                           0         if ( $ddl->[0] eq 'table' ) {
2030  ***      0                                  0            return $before
2031                                                              . 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
2032                                                              . $ddl->[1] . ";\n";
2033                                                        }
2034                                                        else {
2035  ***      0                                  0            return 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
2036                                                              . '/*!50001 DROP VIEW IF EXISTS '
2037                                                              . $quoter->quote($tbl) . "*/;\n/*!50001 "
2038                                                              . $self->get_tmp_table($dbh, $quoter, $db, $tbl) . "*/;\n";
2039                                                        }
2040                                                     }
2041                                                     elsif ( $what eq 'triggers' ) {
2042  ***      0                                  0         my $trgs = $self->get_triggers($dbh, $quoter, $db, $tbl);
2043  ***      0      0      0                    0         if ( $trgs && @$trgs ) {
2044  ***      0                                  0            my $result = $before . "\nDELIMITER ;;\n";
2045  ***      0                                  0            foreach my $trg ( @$trgs ) {
2046  ***      0      0                           0               if ( $trg->{sql_mode} ) {
2047  ***      0                                  0                  $result .= qq{/*!50003 SET SESSION SQL_MODE='$trg->{sql_mode}' */;;\n};
2048                                                              }
2049  ***      0                                  0               $result .= "/*!50003 CREATE */ ";
2050  ***      0      0                           0               if ( $trg->{definer} ) {
2051  ***      0                                  0                  my ( $user, $host )
2052  ***      0                                  0                     = map { s/'/''/g; "'$_'"; }
      ***      0                                  0   
2053                                                                      split('@', $trg->{definer}, 2);
2054  ***      0                                  0                  $result .= "/*!50017 DEFINER=$user\@$host */ ";
2055                                                              }
2056  ***      0                                  0               $result .= sprintf("/*!50003 TRIGGER %s %s %s ON %s\nFOR EACH ROW %s */;;\n\n",
2057                                                                 $quoter->quote($trg->{trigger}),
2058  ***      0                                  0                  @{$trg}{qw(timing event)},
2059                                                                 $quoter->quote($trg->{table}),
2060                                                                 $trg->{statement});
2061                                                           }
2062  ***      0                                  0            $result .= "DELIMITER ;\n\n/*!50003 SET SESSION SQL_MODE=\@OLD_SQL_MODE */;\n\n";
2063  ***      0                                  0            return $result;
2064                                                        }
2065                                                        else {
2066  ***      0                                  0            return undef;
2067                                                        }
2068                                                     }
2069                                                     elsif ( $what eq 'view' ) {
2070  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
2071  ***      0                                  0         return '/*!50001 DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
2072                                                           . '/*!50001 DROP VIEW IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
2073                                                           . '/*!50001 ' . $ddl->[1] . "*/;\n";
2074                                                     }
2075                                                     else {
2076  ***      0                                  0         die "You didn't say what to dump.";
2077                                                     }
2078                                                  }
2079                                                  
2080                                                  sub _use_db {
2081          50                   50           363      my ( $self, $dbh, $quoter, $new ) = @_;
2082  ***     50     50                         288      if ( !$new ) {
2083  ***      0                                  0         MKDEBUG && _d('No new DB to use');
2084  ***      0                                  0         return;
2085                                                     }
2086          50                                191      my $sql = 'SELECT DATABASE()';
2087          50                                140      MKDEBUG && _d($sql);
2088          50                                150      my $curr = $dbh->selectrow_array($sql);
2089  ***     50     50     33                 7154      if ( $curr && $new && $curr eq $new ) {
      ***                   33                        
2090          50                                146         MKDEBUG && _d('Current and new DB are the same');
2091          50                                302         return $curr;
2092                                                     }
2093  ***      0                                  0      $sql = 'USE ' . $quoter->quote($new);
2094  ***      0                                  0      MKDEBUG && _d($sql);
2095  ***      0                                  0      $dbh->do($sql);
2096  ***      0                                  0      return $curr;
2097                                                  }
2098                                                  
2099                                                  sub get_create_table {
2100          25                   25           197      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2101  ***     25     50     33                  513      if ( !$self->{cache} || !$self->{tables}->{$db}->{$tbl} ) {
2102          25                                114         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
2103                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
2104                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
2105                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
2106          25                                 75         MKDEBUG && _d($sql);
2107          25                                 85         eval { $dbh->do($sql); };
              25                               3962   
2108          25                                105         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2109          25                                219         my $curr_db = $self->_use_db($dbh, $quoter, $db);
2110          25                                165         $sql = "SHOW CREATE TABLE " . $quoter->quote($db, $tbl);
2111          25                                 83         MKDEBUG && _d($sql);
2112          25                                 87         my $href;
2113          25                                 90         eval { $href = $dbh->selectrow_hashref($sql); };
              25                                 74   
2114  ***     25     50                         240         if ( $EVAL_ERROR ) {
2115  ***      0                                  0            warn "Failed to $sql.  The table may be damaged.\nError: $EVAL_ERROR";
2116  ***      0                                  0            return;
2117                                                        }
2118          25                                149         $self->_use_db($dbh, $quoter, $curr_db);
2119          25                                102         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
2120                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
2121          25                                 77         MKDEBUG && _d($sql);
2122          25                               2574         $dbh->do($sql);
2123          25                                235         my ($key) = grep { m/create table/i } keys %$href;
              50                                426   
2124  ***     25     50                         149         if ( $key ) {
2125          25                                 77            MKDEBUG && _d('This table is a base table');
2126          25                                367            $self->{tables}->{$db}->{$tbl} = [ 'table', $href->{$key} ];
2127                                                        }
2128                                                        else {
2129  ***      0                                  0            MKDEBUG && _d('This table is a view');
2130  ***      0                                  0            ($key) = grep { m/create view/i } keys %$href;
      ***      0                                  0   
2131  ***      0                                  0            $self->{tables}->{$db}->{$tbl} = [ 'view', $href->{$key} ];
2132                                                        }
2133                                                     }
2134          25                                327      return $self->{tables}->{$db}->{$tbl};
2135                                                  }
2136                                                  
2137                                                  sub get_columns {
2138  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2139  ***      0                                  0      MKDEBUG && _d('Get columns for', $db, $tbl);
2140  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{columns}->{$db}->{$tbl} ) {
2141  ***      0                                  0         my $curr_db = $self->_use_db($dbh, $quoter, $db);
2142  ***      0                                  0         my $sql = "SHOW COLUMNS FROM " . $quoter->quote($db, $tbl);
2143  ***      0                                  0         MKDEBUG && _d($sql);
2144  ***      0                                  0         my $cols = $dbh->selectall_arrayref($sql, { Slice => {} });
2145  ***      0                                  0         $self->_use_db($dbh, $quoter, $curr_db);
2146  ***      0                                  0         $self->{columns}->{$db}->{$tbl} = [
2147                                                           map {
2148  ***      0                                  0               my %row;
2149  ***      0                                  0               @row{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
2150  ***      0                                  0               \%row;
2151                                                           } @$cols
2152                                                        ];
2153                                                     }
2154  ***      0                                  0      return $self->{columns}->{$db}->{$tbl};
2155                                                  }
2156                                                  
2157                                                  sub get_tmp_table {
2158  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2159  ***      0                                  0      my $result = 'CREATE TABLE ' . $quoter->quote($tbl) . " (\n";
2160  ***      0                                  0      $result .= join(",\n",
2161  ***      0                                  0         map { '  ' . $quoter->quote($_->{field}) . ' ' . $_->{type} }
2162  ***      0                                  0         @{$self->get_columns($dbh, $quoter, $db, $tbl)});
2163  ***      0                                  0      $result .= "\n)";
2164  ***      0                                  0      MKDEBUG && _d($result);
2165  ***      0                                  0      return $result;
2166                                                  }
2167                                                  
2168                                                  sub get_triggers {
2169  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2170  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{triggers}->{$db} ) {
2171  ***      0                                  0         $self->{triggers}->{$db} = {};
2172  ***      0                                  0         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
2173                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
2174                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
2175                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
2176  ***      0                                  0         MKDEBUG && _d($sql);
2177  ***      0                                  0         eval { $dbh->do($sql); };
      ***      0                                  0   
2178  ***      0                                  0         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2179  ***      0                                  0         $sql = "SHOW TRIGGERS FROM " . $quoter->quote($db);
2180  ***      0                                  0         MKDEBUG && _d($sql);
2181  ***      0                                  0         my $sth = $dbh->prepare($sql);
2182  ***      0                                  0         $sth->execute();
2183  ***      0      0                           0         if ( $sth->rows ) {
2184  ***      0                                  0            my $trgs = $sth->fetchall_arrayref({});
2185  ***      0                                  0            foreach my $trg (@$trgs) {
2186  ***      0                                  0               my %trg;
2187  ***      0                                  0               @trg{ map { lc $_ } keys %$trg } = values %$trg;
      ***      0                                  0   
2188  ***      0                                  0               push @{ $self->{triggers}->{$db}->{ $trg{table} } }, \%trg;
      ***      0                                  0   
2189                                                           }
2190                                                        }
2191  ***      0                                  0         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
2192                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
2193  ***      0                                  0         MKDEBUG && _d($sql);
2194  ***      0                                  0         $dbh->do($sql);
2195                                                     }
2196  ***      0      0                           0      if ( $tbl ) {
2197  ***      0                                  0         return $self->{triggers}->{$db}->{$tbl};
2198                                                     }
2199  ***      0                                  0      return values %{$self->{triggers}->{$db}};
      ***      0                                  0   
2200                                                  }
2201                                                  
2202                                                  sub get_databases {
2203  ***      0                    0             0      my ( $self, $dbh, $quoter, $like ) = @_;
2204  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{databases} || $like ) {
      ***                    0                        
2205  ***      0                                  0         my $sql = 'SHOW DATABASES';
2206  ***      0                                  0         my @params;
2207  ***      0      0                           0         if ( $like ) {
2208  ***      0                                  0            $sql .= ' LIKE ?';
2209  ***      0                                  0            push @params, $like;
2210                                                        }
2211  ***      0                                  0         my $sth = $dbh->prepare($sql);
2212  ***      0                                  0         MKDEBUG && _d($sql, @params);
2213  ***      0                                  0         $sth->execute( @params );
2214  ***      0                                  0         my @dbs = map { $_->[0] } @{$sth->fetchall_arrayref()};
      ***      0                                  0   
      ***      0                                  0   
2215  ***      0      0                           0         $self->{databases} = \@dbs unless $like;
2216  ***      0                                  0         return @dbs;
2217                                                     }
2218  ***      0                                  0      return @{$self->{databases}};
      ***      0                                  0   
2219                                                  }
2220                                                  
2221                                                  sub get_table_status {
2222  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
2223  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_status}->{$db} || $like ) {
      ***                    0                        
2224  ***      0                                  0         my $sql = "SHOW TABLE STATUS FROM " . $quoter->quote($db);
2225  ***      0                                  0         my @params;
2226  ***      0      0                           0         if ( $like ) {
2227  ***      0                                  0            $sql .= ' LIKE ?';
2228  ***      0                                  0            push @params, $like;
2229                                                        }
2230  ***      0                                  0         MKDEBUG && _d($sql, @params);
2231  ***      0                                  0         my $sth = $dbh->prepare($sql);
2232  ***      0                                  0         $sth->execute(@params);
2233  ***      0                                  0         my @tables = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
2234  ***      0                                  0         @tables = map {
2235  ***      0                                  0            my %tbl; # Make a copy with lowercased keys
2236  ***      0                                  0            @tbl{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
2237  ***      0             0                    0            $tbl{engine} ||= $tbl{type} || $tbl{comment};
      ***                    0                        
2238  ***      0                                  0            delete $tbl{type};
2239  ***      0                                  0            \%tbl;
2240                                                        } @tables;
2241  ***      0      0                           0         $self->{table_status}->{$db} = \@tables unless $like;
2242  ***      0                                  0         return @tables;
2243                                                     }
2244  ***      0                                  0      return @{$self->{table_status}->{$db}};
      ***      0                                  0   
2245                                                  }
2246                                                  
2247                                                  sub get_table_list {
2248  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
2249  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_list}->{$db} || $like ) {
      ***                    0                        
2250  ***      0                                  0         my $sql = "SHOW /*!50002 FULL*/ TABLES FROM " . $quoter->quote($db);
2251  ***      0                                  0         my @params;
2252  ***      0      0                           0         if ( $like ) {
2253  ***      0                                  0            $sql .= ' LIKE ?';
2254  ***      0                                  0            push @params, $like;
2255                                                        }
2256  ***      0                                  0         MKDEBUG && _d($sql, @params);
2257  ***      0                                  0         my $sth = $dbh->prepare($sql);
2258  ***      0                                  0         $sth->execute(@params);
2259  ***      0                                  0         my @tables = @{$sth->fetchall_arrayref()};
      ***      0                                  0   
2260  ***      0      0      0                    0         @tables = map {
2261  ***      0                                  0            my %tbl = (
2262                                                              name   => $_->[0],
2263                                                              engine => ($_->[1] || '') eq 'VIEW' ? 'VIEW' : '',
2264                                                           );
2265  ***      0                                  0            \%tbl;
2266                                                        } @tables;
2267  ***      0      0                           0         $self->{table_list}->{$db} = \@tables unless $like;
2268  ***      0                                  0         return @tables;
2269                                                     }
2270  ***      0                                  0      return @{$self->{table_list}->{$db}};
      ***      0                                  0   
2271                                                  }
2272                                                  
2273                                                  sub _d {
2274  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2275  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2276  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2277                                                          @_;
2278  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2279                                                  }
2280                                                  
2281                                                  1;
2282                                                  
2283                                                  # ###########################################################################
2284                                                  # End MySQLDump package
2285                                                  # ###########################################################################
2286                                                  
2287                                                  # ###########################################################################
2288                                                  # Daemon package 5266
2289                                                  # ###########################################################################
2290                                                  
2291                                                  package Daemon;
2292                                                  
2293          17                   17           144   use strict;
              17                                 53   
              17                                102   
2294          17                   17           104   use warnings FATAL => 'all';
              17                                 45   
              17                                 99   
2295                                                  
2296          17                   17           106   use POSIX qw(setsid);
              17                                 37   
              17                                136   
2297          17                   17           103   use English qw(-no_match_vars);
              17                                 43   
              17                                100   
2298                                                  
2299  ***     17            50     17           124   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              17                                 44   
              17                                244   
2300                                                  
2301                                                  sub new {
2302  ***      0                    0             0      my ( $class, %args ) = @_;
2303  ***      0                                  0      foreach my $arg ( qw(o) ) {
2304  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
2305                                                     }
2306  ***      0                                  0      my $o = $args{o};
2307  ***      0      0                           0      my $self = {
      ***             0                               
2308                                                        o        => $o,
2309                                                        log_file => $o->has('log') ? $o->get('log') : undef,
2310                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
2311                                                     };
2312                                                  
2313  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
2314                                                  
2315  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
2316  ***      0                                  0      return bless $self, $class;
2317                                                  }
2318                                                  
2319                                                  sub daemonize {
2320  ***      0                    0             0      my ( $self ) = @_;
2321                                                  
2322  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
2323  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
2324  ***      0      0                           0      if ( $pid ) {
2325  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
2326  ***      0                                  0         exit;
2327                                                     }
2328                                                  
2329  ***      0                                  0      $self->{child} = 1;
2330                                                  
2331  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
2332  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
2333                                                  
2334  ***      0                                  0      $self->_make_PID_file();
2335                                                  
2336  ***      0                                  0      $OUTPUT_AUTOFLUSH = 1;
2337                                                  
2338  ***      0      0                           0      if ( -t STDIN ) {
2339  ***      0                                  0         close STDIN;
2340  ***      0      0                           0         open  STDIN, '/dev/null'
2341                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
2342                                                     }
2343                                                  
2344  ***      0      0                           0      if ( $self->{log_file} ) {
2345  ***      0                                  0         close STDOUT;
2346  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
2347                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
2348                                                  
2349  ***      0                                  0         close STDERR;
2350  ***      0      0                           0         open  STDERR, ">&STDOUT"
2351                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
2352                                                     }
2353                                                     else {
2354  ***      0      0                           0         if ( -t STDOUT ) {
2355  ***      0                                  0            close STDOUT;
2356  ***      0      0                           0            open  STDOUT, '>', '/dev/null'
2357                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
2358                                                        }
2359  ***      0      0                           0         if ( -t STDERR ) {
2360  ***      0                                  0            close STDERR;
2361  ***      0      0                           0            open  STDERR, '>', '/dev/null'
2362                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
2363                                                        }
2364                                                     }
2365                                                  
2366  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
2367  ***      0                                  0      return;
2368                                                  }
2369                                                  
2370                                                  sub check_PID_file {
2371  ***      0                    0             0      my ( $self, $file ) = @_;
2372  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
2373  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
2374  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
2375  ***      0                                  0         my $pid;
2376  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
2377  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
2378  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
2379  ***      0      0                           0         if ( $pid ) {
2380  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
2381  ***      0      0                           0            if ( $pid_is_alive ) {
2382  ***      0                                  0               die "The PID file $PID_file already exists "
2383                                                                 . " and the PID that it contains, $pid, is running";
2384                                                           }
2385                                                           else {
2386  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
2387                                                                 . "contains, $pid, is not running";
2388                                                           }
2389                                                        }
2390                                                        else {
2391  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
2392                                                              . "contain a PID";
2393                                                        }
2394                                                     }
2395                                                     else {
2396  ***      0                                  0         MKDEBUG && _d('No PID file');
2397                                                     }
2398  ***      0                                  0      return;
2399                                                  }
2400                                                  
2401                                                  sub make_PID_file {
2402  ***      0                    0             0      my ( $self ) = @_;
2403  ***      0      0                           0      if ( exists $self->{child} ) {
2404  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
2405                                                     }
2406  ***      0                                  0      $self->_make_PID_file();
2407  ***      0                                  0      $self->{rm_PID_file} = 1;
2408  ***      0                                  0      return;
2409                                                  }
2410                                                  
2411                                                  sub _make_PID_file {
2412  ***      0                    0             0      my ( $self ) = @_;
2413                                                  
2414  ***      0                                  0      my $PID_file = $self->{PID_file};
2415  ***      0      0                           0      if ( !$PID_file ) {
2416  ***      0                                  0         MKDEBUG && _d('No PID file to create');
2417  ***      0                                  0         return;
2418                                                     }
2419                                                  
2420  ***      0                                  0      $self->check_PID_file();
2421                                                  
2422  ***      0      0                           0      open my $PID_FH, '>', $PID_file
2423                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
2424  ***      0      0                           0      print $PID_FH $PID
2425                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
2426  ***      0      0                           0      close $PID_FH
2427                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
2428                                                  
2429  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
2430  ***      0                                  0      return;
2431                                                  }
2432                                                  
2433                                                  sub _remove_PID_file {
2434  ***      0                    0             0      my ( $self ) = @_;
2435  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
2436  ***      0      0                           0         unlink $self->{PID_file}
2437                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
2438  ***      0                                  0         MKDEBUG && _d('Removed PID file');
2439                                                     }
2440                                                     else {
2441  ***      0                                  0         MKDEBUG && _d('No PID to remove');
2442                                                     }
2443  ***      0                                  0      return;
2444                                                  }
2445                                                  
2446                                                  sub DESTROY {
2447  ***      0                    0             0      my ( $self ) = @_;
2448  ***      0      0      0                    0      $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
2449  ***      0                                  0      return;
2450                                                  }
2451                                                  
2452                                                  sub _d {
2453  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2454  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2455  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2456                                                          @_;
2457  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2458                                                  }
2459                                                  
2460                                                  1;
2461                                                  
2462                                                  # ###########################################################################
2463                                                  # End Daemon package
2464                                                  # ###########################################################################
2465                                                  
2466                                                  # ###########################################################################
2467                                                  # MasterSlave package 5362
2468                                                  # ###########################################################################
2469          17                   17           178   use strict;
              17                                 50   
              17                                102   
2470          17                   17           114   use warnings FATAL => 'all';
              17                                 41   
              17                                 95   
2471                                                  
2472                                                  package MasterSlave;
2473                                                  
2474          17                   17           108   use English qw(-no_match_vars);
              17                                 53   
              17                                122   
2475          17                   17           124   use List::Util qw(min max);
              17                                 55   
              17                                106   
2476          17                   17           109   use Data::Dumper;
              17                                 41   
              17                                 95   
2477                                                  $Data::Dumper::Quotekeys = 0;
2478                                                  $Data::Dumper::Indent    = 0;
2479                                                  
2480  ***     17            50     17           109   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              17                                 45   
              17                                246   
2481                                                  
2482                                                  sub new {
2483  ***      0                    0             0      bless {}, shift;
2484                                                  }
2485                                                  
2486                                                  sub recurse_to_slaves {
2487  ***      0                    0             0      my ( $self, $args, $level ) = @_;
2488  ***      0             0                    0      $level ||= 0;
2489  ***      0                                  0      my $dp   = $args->{dsn_parser};
2490  ***      0                                  0      my $dsn  = $args->{dsn};
2491                                                  
2492  ***      0                                  0      my $dbh;
2493  ***      0                                  0      eval {
2494  ***      0             0                    0         $dbh = $args->{dbh} || $dp->get_dbh(
2495                                                           $dp->get_cxn_params($dsn), { AutoCommit => 1 });
2496  ***      0                                  0         MKDEBUG && _d('Connected to', $dp->as_string($dsn));
2497                                                     };
2498  ***      0      0                           0      if ( $EVAL_ERROR ) {
2499  ***      0      0                           0         print STDERR "Cannot connect to ", $dp->as_string($dsn), "\n"
2500                                                           or die "Cannot print: $OS_ERROR";
2501  ***      0                                  0         return;
2502                                                     }
2503                                                  
2504  ***      0                                  0      my $sql  = 'SELECT @@SERVER_ID';
2505  ***      0                                  0      MKDEBUG && _d($sql);
2506  ***      0                                  0      my ($id) = $dbh->selectrow_array($sql);
2507  ***      0                                  0      MKDEBUG && _d('Working on server ID', $id);
2508  ***      0                                  0      my $master_thinks_i_am = $dsn->{server_id};
2509  ***      0      0      0                    0      if ( !defined $id
      ***                    0                        
      ***                    0                        
2510                                                         || ( defined $master_thinks_i_am && $master_thinks_i_am != $id )
2511                                                         || $args->{server_ids_seen}->{$id}++
2512                                                     ) {
2513  ***      0                                  0         MKDEBUG && _d('Server ID seen, or not what master said');
2514  ***      0      0                           0         if ( $args->{skip_callback} ) {
2515  ***      0                                  0            $args->{skip_callback}->($dsn, $dbh, $level, $args->{parent});
2516                                                        }
2517  ***      0                                  0         return;
2518                                                     }
2519                                                  
2520  ***      0                                  0      $args->{callback}->($dsn, $dbh, $level, $args->{parent});
2521                                                  
2522  ***      0      0      0                    0      if ( !defined $args->{recurse} || $level < $args->{recurse} ) {
2523                                                  
2524  ***      0      0                           0         my @slaves =
2525  ***      0                                  0            grep { !$_->{master_id} || $_->{master_id} == $id } # Only my slaves.
2526                                                           $self->find_slave_hosts($dp, $dbh, $dsn, $args->{method});
2527                                                  
2528  ***      0                                  0         foreach my $slave ( @slaves ) {
2529  ***      0                                  0            MKDEBUG && _d('Recursing from',
2530                                                              $dp->as_string($dsn), 'to', $dp->as_string($slave));
2531  ***      0                                  0            $self->recurse_to_slaves(
2532                                                              { %$args, dsn => $slave, dbh => undef, parent => $dsn }, $level + 1 );
2533                                                        }
2534                                                     }
2535                                                  }
2536                                                  
2537                                                  sub find_slave_hosts {
2538  ***      0                    0             0      my ( $self, $dsn_parser, $dbh, $dsn, $method ) = @_;
2539                                                  
2540  ***      0                                  0      my @methods = qw(processlist hosts);
2541  ***      0      0                           0      if ( $method ) {
2542  ***      0                                  0         @methods = grep { $_ ne $method } @methods;
      ***      0                                  0   
2543  ***      0                                  0         unshift @methods, $method;
2544                                                     }
2545                                                     else {
2546  ***      0      0      0                    0         if ( ($dsn->{P} || 3306) != 3306 ) {
2547  ***      0                                  0            MKDEBUG && _d('Port number is non-standard; using only hosts method');
2548  ***      0                                  0            @methods = qw(hosts);
2549                                                        }
2550                                                     }
2551  ***      0                                  0      MKDEBUG && _d('Looking for slaves on', $dsn_parser->as_string($dsn),
2552                                                        'using methods', @methods);
2553                                                  
2554  ***      0                                  0      my @slaves;
2555                                                     METHOD:
2556  ***      0                                  0      foreach my $method ( @methods ) {
2557  ***      0                                  0         my $find_slaves = "_find_slaves_by_$method";
2558  ***      0                                  0         MKDEBUG && _d('Finding slaves with', $find_slaves);
2559  ***      0                                  0         @slaves = $self->$find_slaves($dsn_parser, $dbh, $dsn);
2560  ***      0      0                           0         last METHOD if @slaves;
2561                                                     }
2562                                                  
2563  ***      0                                  0      MKDEBUG && _d('Found', scalar(@slaves), 'slaves');
2564  ***      0                                  0      return @slaves;
2565                                                  }
2566                                                  
2567                                                  sub _find_slaves_by_processlist {
2568  ***      0                    0             0      my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
2569                                                  
2570  ***      0                                  0      my @slaves = map  {
2571  ***      0                                  0         my $slave        = $dsn_parser->parse("h=$_", $dsn);
2572  ***      0                                  0         $slave->{source} = 'processlist';
2573  ***      0                                  0         $slave;
2574                                                     }
2575  ***      0                                  0      grep { $_ }
2576                                                     map  {
2577  ***      0                                  0         my ( $host ) = $_->{host} =~ m/^([^:]+):/;
2578  ***      0      0                           0         if ( $host eq 'localhost' ) {
2579  ***      0                                  0            $host = '127.0.0.1'; # Replication never uses sockets.
2580                                                        }
2581  ***      0                                  0         $host;
2582                                                     } $self->get_connected_slaves($dbh);
2583                                                  
2584  ***      0                                  0      return @slaves;
2585                                                  }
2586                                                  
2587                                                  sub _find_slaves_by_hosts {
2588  ***      0                    0             0      my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
2589                                                  
2590  ***      0                                  0      my @slaves;
2591  ***      0                                  0      my $sql = 'SHOW SLAVE HOSTS';
2592  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
2593  ***      0                                  0      @slaves = @{$dbh->selectall_arrayref($sql, { Slice => {} })};
      ***      0                                  0   
2594                                                  
2595  ***      0      0                           0      if ( @slaves ) {
2596  ***      0                                  0         MKDEBUG && _d('Found some SHOW SLAVE HOSTS info');
2597  ***      0                                  0         @slaves = map {
2598  ***      0                                  0            my %hash;
2599  ***      0                                  0            @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
2600  ***      0      0                           0            my $spec = "h=$hash{host},P=$hash{port}"
      ***             0                               
2601                                                              . ( $hash{user} ? ",u=$hash{user}" : '')
2602                                                              . ( $hash{password} ? ",p=$hash{password}" : '');
2603  ***      0                                  0            my $dsn           = $dsn_parser->parse($spec, $dsn);
2604  ***      0                                  0            $dsn->{server_id} = $hash{server_id};
2605  ***      0                                  0            $dsn->{master_id} = $hash{master_id};
2606  ***      0                                  0            $dsn->{source}    = 'hosts';
2607  ***      0                                  0            $dsn;
2608                                                        } @slaves;
2609                                                     }
2610                                                  
2611  ***      0                                  0      return @slaves;
2612                                                  }
2613                                                  
2614                                                  sub get_connected_slaves {
2615  ***      0                    0             0      my ( $self, $dbh ) = @_;
2616                                                  
2617  ***      0                                  0      my $proc =
2618  ***      0                                  0         grep { m/ALL PRIVILEGES.*?\*\.\*|PROCESS/ }
2619  ***      0                                  0         @{$dbh->selectcol_arrayref('SHOW GRANTS')};
2620  ***      0      0                           0      if ( !$proc ) {
2621  ***      0                                  0         die "You do not have the PROCESS privilege";
2622                                                     }
2623                                                  
2624  ***      0                                  0      my $sql = 'SHOW PROCESSLIST';
2625  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
2626  ***      0                                  0      grep { $_->{command} =~ m/Binlog Dump/i }
      ***      0                                  0   
2627                                                     map  { # Lowercase the column names
2628  ***      0                                  0         my %hash;
2629  ***      0                                  0         @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
2630  ***      0                                  0         \%hash;
2631                                                     }
2632  ***      0                                  0      @{$dbh->selectall_arrayref($sql, { Slice => {} })};
2633                                                  }
2634                                                  
2635                                                  sub is_master_of {
2636  ***      0                    0             0      my ( $self, $master, $slave ) = @_;
2637  ***      0      0                           0      my $master_status = $self->get_master_status($master)
2638                                                        or die "The server specified as a master is not a master";
2639  ***      0      0                           0      my $slave_status  = $self->get_slave_status($slave)
2640                                                        or die "The server specified as a slave is not a slave";
2641  ***      0      0                           0      my @connected     = $self->get_connected_slaves($master)
2642                                                        or die "The server specified as a master has no connected slaves";
2643  ***      0                                  0      my (undef, $port) = $master->selectrow_array('SHOW VARIABLES LIKE "port"');
2644                                                  
2645  ***      0      0                           0      if ( $port != $slave_status->{master_port} ) {
2646  ***      0                                  0         die "The slave is connected to $slave_status->{master_port} "
2647                                                           . "but the master's port is $port";
2648                                                     }
2649                                                  
2650  ***      0      0                           0      if ( !grep { $slave_status->{master_user} eq $_->{user} } @connected ) {
      ***      0                                  0   
2651  ***      0                                  0         die "I don't see any slave I/O thread connected with user "
2652                                                           . $slave_status->{master_user};
2653                                                     }
2654                                                  
2655  ***      0      0      0                    0      if ( ($slave_status->{slave_io_state} || '')
2656                                                        eq 'Waiting for master to send event' )
2657                                                     {
2658  ***      0                                  0         my ( $master_log_name, $master_log_num )
2659                                                           = $master_status->{file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
2660  ***      0                                  0         my ( $slave_log_name, $slave_log_num )
2661                                                           = $slave_status->{master_log_file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
2662  ***      0      0      0                    0         if ( $master_log_name ne $slave_log_name
2663                                                           || abs($master_log_num - $slave_log_num) > 1 )
2664                                                        {
2665  ***      0                                  0            die "The slave thinks it is reading from "
2666                                                              . "$slave_status->{master_log_file},  but the "
2667                                                              . "master is writing to $master_status->{file}";
2668                                                        }
2669                                                     }
2670  ***      0                                  0      return 1;
2671                                                  }
2672                                                  
2673                                                  sub get_master_dsn {
2674  ***      0                    0             0      my ( $self, $dbh, $dsn, $dsn_parser ) = @_;
2675  ***      0      0                           0      my $master = $self->get_slave_status($dbh) or return undef;
2676  ***      0                                  0      my $spec   = "h=$master->{master_host},P=$master->{master_port}";
2677  ***      0                                  0      return       $dsn_parser->parse($spec, $dsn);
2678                                                  }
2679                                                  
2680                                                  sub get_slave_status {
2681  ***      0                    0             0      my ( $self, $dbh ) = @_;
2682  ***      0      0                           0      if ( !$self->{not_a_slave}->{$dbh} ) {
2683  ***      0             0                    0         my $sth = $self->{sths}->{$dbh}->{SLAVE_STATUS}
2684                                                              ||= $dbh->prepare('SHOW SLAVE STATUS');
2685  ***      0                                  0         MKDEBUG && _d($dbh, 'SHOW SLAVE STATUS');
2686  ***      0                                  0         $sth->execute();
2687  ***      0                                  0         my ($ss) = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
2688                                                  
2689  ***      0      0      0                    0         if ( $ss && %$ss ) {
2690  ***      0                                  0            $ss = { map { lc($_) => $ss->{$_} } keys %$ss }; # lowercase the keys
      ***      0                                  0   
2691  ***      0                                  0            return $ss;
2692                                                        }
2693                                                  
2694  ***      0                                  0         MKDEBUG && _d('This server returns nothing for SHOW SLAVE STATUS');
2695  ***      0                                  0         $self->{not_a_slave}->{$dbh}++;
2696                                                     }
2697                                                  }
2698                                                  
2699                                                  sub get_master_status {
2700  ***      0                    0             0      my ( $self, $dbh ) = @_;
2701  ***      0      0                           0      if ( !$self->{not_a_master}->{$dbh} ) {
2702  ***      0             0                    0         my $sth = $self->{sths}->{$dbh}->{MASTER_STATUS}
2703                                                              ||= $dbh->prepare('SHOW MASTER STATUS');
2704  ***      0                                  0         MKDEBUG && _d($dbh, 'SHOW MASTER STATUS');
2705  ***      0                                  0         $sth->execute();
2706  ***      0                                  0         my ($ms) = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
2707                                                  
2708  ***      0      0      0                    0         if ( $ms && %$ms ) {
2709  ***      0                                  0            $ms = { map { lc($_) => $ms->{$_} } keys %$ms }; # lowercase the keys
      ***      0                                  0   
2710  ***      0      0      0                    0            if ( $ms->{file} && $ms->{position} ) {
2711  ***      0                                  0               return $ms;
2712                                                           }
2713                                                        }
2714                                                  
2715  ***      0                                  0         MKDEBUG && _d('This server returns nothing for SHOW MASTER STATUS');
2716  ***      0                                  0         $self->{not_a_master}->{$dbh}++;
2717                                                     }
2718                                                  }
2719                                                  
2720                                                  sub wait_for_master {
2721  ***      0                    0             0      my ( $self, $master, $slave, $time, $timeoutok, $ms ) = @_;
2722  ***      0                                  0      my $result;
2723  ***      0      0                           0      $time = 60 unless defined $time;
2724  ***      0                                  0      MKDEBUG && _d('Waiting for slave to catch up to master timeout ok:',
2725                                                        $timeoutok);
2726  ***      0             0                    0      $ms ||= $self->get_master_status($master);
2727  ***      0      0                           0      if ( $ms ) {
2728  ***      0                                  0         my $query = "SELECT MASTER_POS_WAIT('$ms->{file}', $ms->{position}, $time)";
2729  ***      0                                  0         MKDEBUG && _d($slave, $query);
2730  ***      0                                  0         ($result) = $slave->selectrow_array($query);
2731  ***      0      0                           0         my $stat = defined $result ? $result : 'NULL';
2732  ***      0                                  0         MKDEBUG && _d('Result of waiting:', $stat);
2733  ***      0      0      0                    0         if ( $stat eq 'NULL' || $stat < 0 && !$timeoutok ) {
      ***                    0                        
2734  ***      0                                  0            die "MASTER_POS_WAIT returned $stat";
2735                                                        }
2736                                                     }
2737                                                     else {
2738  ***      0                                  0         MKDEBUG && _d('Not waiting: this server is not a master');
2739                                                     }
2740  ***      0                                  0      return $result;
2741                                                  }
2742                                                  
2743                                                  sub stop_slave {
2744  ***      0                    0             0      my ( $self, $dbh ) = @_;
2745  ***      0             0                    0      my $sth = $self->{sths}->{$dbh}->{STOP_SLAVE}
2746                                                           ||= $dbh->prepare('STOP SLAVE');
2747  ***      0                                  0      MKDEBUG && _d($dbh, $sth->{Statement});
2748  ***      0                                  0      $sth->execute();
2749                                                  }
2750                                                  
2751                                                  sub start_slave {
2752  ***      0                    0             0      my ( $self, $dbh, $pos ) = @_;
2753  ***      0      0                           0      if ( $pos ) {
2754  ***      0                                  0         my $sql = "START SLAVE UNTIL MASTER_LOG_FILE='$pos->{file}', "
2755                                                                . "MASTER_LOG_POS=$pos->{position}";
2756  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
2757  ***      0                                  0         $dbh->do($sql);
2758                                                     }
2759                                                     else {
2760  ***      0             0                    0         my $sth = $self->{sths}->{$dbh}->{START_SLAVE}
2761                                                              ||= $dbh->prepare('START SLAVE');
2762  ***      0                                  0         MKDEBUG && _d($dbh, $sth->{Statement});
2763  ***      0                                  0         $sth->execute();
2764                                                     }
2765                                                  }
2766                                                  
2767                                                  sub catchup_to_master {
2768  ***      0                    0             0      my ( $self, $slave, $master, $time ) = @_;
2769  ***      0                                  0      $self->stop_slave($master);
2770  ***      0                                  0      $self->stop_slave($slave);
2771  ***      0                                  0      my $slave_status  = $self->get_slave_status($slave);
2772  ***      0                                  0      my $slave_pos     = $self->repl_posn($slave_status);
2773  ***      0                                  0      my $master_status = $self->get_master_status($master);
2774  ***      0                                  0      my $master_pos    = $self->repl_posn($master_status);
2775  ***      0                                  0      MKDEBUG && _d('Master position:', $self->pos_to_string($master_pos),
2776                                                        'Slave position:', $self->pos_to_string($slave_pos));
2777  ***      0      0                           0      if ( $self->pos_cmp($slave_pos, $master_pos) < 0 ) {
2778  ***      0                                  0         MKDEBUG && _d('Waiting for slave to catch up to master');
2779  ***      0                                  0         $self->start_slave($slave, $master_pos);
2780  ***      0                                  0         eval {
2781  ***      0                                  0            $self->wait_for_master($master, $slave, $time, 0, $master_status);
2782                                                        };
2783  ***      0      0                           0         if ( $EVAL_ERROR ) {
2784  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
2785  ***      0      0                           0            if ( $EVAL_ERROR =~ m/MASTER_POS_WAIT returned NULL/ ) {
2786  ***      0                                  0               $slave_status = $self->get_slave_status($slave);
2787  ***      0      0                           0               if ( !$self->slave_is_running($slave_status) ) {
2788  ***      0                                  0                  MKDEBUG && _d('Master position:',
2789                                                                    $self->pos_to_string($master_pos),
2790                                                                    'Slave position:', $self->pos_to_string($slave_pos));
2791  ***      0                                  0                  $slave_pos = $self->repl_posn($slave_status);
2792  ***      0      0                           0                  if ( $self->pos_cmp($slave_pos, $master_pos) != 0 ) {
2793  ***      0                                  0                     die "$EVAL_ERROR but slave has not caught up to master";
2794                                                                 }
2795  ***      0                                  0                  MKDEBUG && _d('Slave is caught up to master and stopped');
2796                                                              }
2797                                                              else {
2798  ***      0                                  0                  die "$EVAL_ERROR but slave was still running";
2799                                                              }
2800                                                           }
2801                                                           else {
2802  ***      0                                  0               die $EVAL_ERROR;
2803                                                           }
2804                                                        }
2805                                                     }
2806                                                  }
2807                                                  
2808                                                  sub catchup_to_same_pos {
2809  ***      0                    0             0      my ( $self, $s1_dbh, $s2_dbh ) = @_;
2810  ***      0                                  0      $self->stop_slave($s1_dbh);
2811  ***      0                                  0      $self->stop_slave($s2_dbh);
2812  ***      0                                  0      my $s1_status = $self->get_slave_status($s1_dbh);
2813  ***      0                                  0      my $s2_status = $self->get_slave_status($s2_dbh);
2814  ***      0                                  0      my $s1_pos    = $self->repl_posn($s1_status);
2815  ***      0                                  0      my $s2_pos    = $self->repl_posn($s2_status);
2816  ***      0      0                           0      if ( $self->pos_cmp($s1_pos, $s2_pos) < 0 ) {
      ***             0                               
2817  ***      0                                  0         $self->start_slave($s1_dbh, $s2_pos);
2818                                                     }
2819                                                     elsif ( $self->pos_cmp($s2_pos, $s1_pos) < 0 ) {
2820  ***      0                                  0         $self->start_slave($s2_dbh, $s1_pos);
2821                                                     }
2822                                                  
2823  ***      0                                  0      $s1_status = $self->get_slave_status($s1_dbh);
2824  ***      0                                  0      $s2_status = $self->get_slave_status($s2_dbh);
2825  ***      0                                  0      $s1_pos    = $self->repl_posn($s1_status);
2826  ***      0                                  0      $s2_pos    = $self->repl_posn($s2_status);
2827                                                  
2828  ***      0      0      0                    0      if ( $self->slave_is_running($s1_status)
      ***                    0                        
2829                                                       || $self->slave_is_running($s2_status)
2830                                                       || $self->pos_cmp($s1_pos, $s2_pos) != 0)
2831                                                     {
2832  ***      0                                  0         die "The servers aren't both stopped at the same position";
2833                                                     }
2834                                                  
2835                                                  }
2836                                                  
2837                                                  sub change_master_to {
2838  ***      0                    0             0      my ( $self, $dbh, $master_dsn, $master_pos ) = @_;
2839  ***      0                                  0      $self->stop_slave($dbh);
2840  ***      0                                  0      MKDEBUG && _d(Dumper($master_dsn), Dumper($master_pos));
2841  ***      0                                  0      my $sql = "CHANGE MASTER TO MASTER_HOST='$master_dsn->{h}', "
2842                                                        . "MASTER_PORT= $master_dsn->{P}, MASTER_LOG_FILE='$master_pos->{file}', "
2843                                                        . "MASTER_LOG_POS=$master_pos->{position}";
2844  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
2845  ***      0                                  0      $dbh->do($sql);
2846                                                  }
2847                                                  
2848                                                  sub make_sibling_of_master {
2849  ***      0                    0             0      my ( $self, $slave_dbh, $slave_dsn, $dsn_parser, $timeout) = @_;
2850                                                  
2851  ***      0      0                           0      my $master_dsn  = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
2852                                                        or die "This server is not a slave";
2853  ***      0                                  0      my $master_dbh  = $dsn_parser->get_dbh(
2854                                                        $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
2855  ***      0      0                           0      my $gmaster_dsn
2856                                                        = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
2857                                                        or die "This server's master is not a slave";
2858  ***      0                                  0      my $gmaster_dbh = $dsn_parser->get_dbh(
2859                                                        $dsn_parser->get_cxn_params($gmaster_dsn), { AutoCommit => 1 });
2860  ***      0      0                           0      if ( $self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn) ) {
2861  ***      0                                  0         die "The slave's master's master is the slave: master-master replication";
2862                                                     }
2863                                                  
2864  ***      0                                  0      $self->stop_slave($master_dbh);
2865  ***      0                                  0      $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
2866  ***      0                                  0      $self->stop_slave($slave_dbh);
2867                                                  
2868  ***      0                                  0      my $master_status = $self->get_master_status($master_dbh);
2869  ***      0                                  0      my $mslave_status = $self->get_slave_status($master_dbh);
2870  ***      0                                  0      my $slave_status  = $self->get_slave_status($slave_dbh);
2871  ***      0                                  0      my $master_pos    = $self->repl_posn($master_status);
2872  ***      0                                  0      my $slave_pos     = $self->repl_posn($slave_status);
2873                                                  
2874  ***      0      0      0                    0      if ( !$self->slave_is_running($mslave_status)
      ***                    0                        
2875                                                       && !$self->slave_is_running($slave_status)
2876                                                       && $self->pos_cmp($master_pos, $slave_pos) == 0)
2877                                                     {
2878  ***      0                                  0         $self->change_master_to($slave_dbh, $gmaster_dsn,
2879                                                           $self->repl_posn($mslave_status)); # Note it's not $master_pos!
2880                                                     }
2881                                                     else {
2882  ***      0                                  0         die "The servers aren't both stopped at the same position";
2883                                                     }
2884                                                  
2885  ***      0                                  0      $mslave_status = $self->get_slave_status($master_dbh);
2886  ***      0                                  0      $slave_status  = $self->get_slave_status($slave_dbh);
2887  ***      0                                  0      my $mslave_pos = $self->repl_posn($mslave_status);
2888  ***      0                                  0      $slave_pos     = $self->repl_posn($slave_status);
2889  ***      0      0      0                    0      if ( $self->short_host($mslave_status) ne $self->short_host($slave_status)
2890                                                       || $self->pos_cmp($mslave_pos, $slave_pos) != 0)
2891                                                     {
2892  ***      0                                  0         die "The servers don't have the same master/position after the change";
2893                                                     }
2894                                                  }
2895                                                  
2896                                                  sub make_slave_of_sibling {
2897  ***      0                    0             0      my ( $self, $slave_dbh, $slave_dsn, $sib_dbh, $sib_dsn,
2898                                                          $dsn_parser, $timeout) = @_;
2899                                                  
2900  ***      0      0                           0      if ( $self->short_host($slave_dsn) eq $self->short_host($sib_dsn) ) {
2901  ***      0                                  0         die "You are trying to make the slave a slave of itself";
2902                                                     }
2903                                                  
2904  ***      0      0                           0      my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
2905                                                        or die "This server is not a slave";
2906  ***      0                                  0      my $master_dbh1 = $dsn_parser->get_dbh(
2907                                                        $dsn_parser->get_cxn_params($master_dsn1), { AutoCommit => 1 });
2908  ***      0      0                           0      my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
2909                                                        or die "The sibling is not a slave";
2910  ***      0      0                           0      if ( $self->short_host($master_dsn1) ne $self->short_host($master_dsn2) ) {
2911  ***      0                                  0         die "This server isn't a sibling of the slave";
2912                                                     }
2913  ***      0      0                           0      my $sib_master_stat = $self->get_master_status($sib_dbh)
2914                                                        or die "Binary logging is not enabled on the sibling";
2915  ***      0      0                           0      die "The log_slave_updates option is not enabled on the sibling"
2916                                                        unless $self->has_slave_updates($sib_dbh);
2917                                                  
2918  ***      0                                  0      $self->catchup_to_same_pos($slave_dbh, $sib_dbh);
2919                                                  
2920  ***      0                                  0      $sib_master_stat = $self->get_master_status($sib_dbh);
2921  ***      0                                  0      $self->change_master_to($slave_dbh, $sib_dsn,
2922                                                           $self->repl_posn($sib_master_stat));
2923                                                  
2924  ***      0                                  0      my $slave_status = $self->get_slave_status($slave_dbh);
2925  ***      0                                  0      my $slave_pos    = $self->repl_posn($slave_status);
2926  ***      0                                  0      $sib_master_stat = $self->get_master_status($sib_dbh);
2927  ***      0      0      0                    0      if ( $self->short_host($slave_status) ne $self->short_host($sib_dsn)
2928                                                       || $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
2929                                                     {
2930  ***      0                                  0         die "After changing the slave's master, it isn't a slave of the sibling, "
2931                                                           . "or it has a different replication position than the sibling";
2932                                                     }
2933                                                  }
2934                                                  
2935                                                  sub make_slave_of_uncle {
2936  ***      0                    0             0      my ( $self, $slave_dbh, $slave_dsn, $unc_dbh, $unc_dsn,
2937                                                          $dsn_parser, $timeout) = @_;
2938                                                  
2939  ***      0      0                           0      if ( $self->short_host($slave_dsn) eq $self->short_host($unc_dsn) ) {
2940  ***      0                                  0         die "You are trying to make the slave a slave of itself";
2941                                                     }
2942                                                  
2943  ***      0      0                           0      my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
2944                                                        or die "This server is not a slave";
2945  ***      0                                  0      my $master_dbh = $dsn_parser->get_dbh(
2946                                                        $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
2947  ***      0      0                           0      my $gmaster_dsn
2948                                                        = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
2949                                                        or die "The master is not a slave";
2950  ***      0      0                           0      my $unc_master_dsn
2951                                                        = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
2952                                                        or die "The uncle is not a slave";
2953  ***      0      0                           0      if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn)) {
2954  ***      0                                  0         die "The uncle isn't really the slave's uncle";
2955                                                     }
2956                                                  
2957  ***      0      0                           0      my $unc_master_stat = $self->get_master_status($unc_dbh)
2958                                                        or die "Binary logging is not enabled on the uncle";
2959  ***      0      0                           0      die "The log_slave_updates option is not enabled on the uncle"
2960                                                        unless $self->has_slave_updates($unc_dbh);
2961                                                  
2962  ***      0                                  0      $self->catchup_to_same_pos($master_dbh, $unc_dbh);
2963  ***      0                                  0      $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
2964                                                  
2965  ***      0                                  0      my $slave_status  = $self->get_slave_status($slave_dbh);
2966  ***      0                                  0      my $master_status = $self->get_master_status($master_dbh);
2967  ***      0      0                           0      if ( $self->pos_cmp(
2968                                                           $self->repl_posn($slave_status),
2969                                                           $self->repl_posn($master_status)) != 0 )
2970                                                     {
2971  ***      0                                  0         die "The slave is not caught up to its master";
2972                                                     }
2973                                                  
2974  ***      0                                  0      $unc_master_stat = $self->get_master_status($unc_dbh);
2975  ***      0                                  0      $self->change_master_to($slave_dbh, $unc_dsn,
2976                                                        $self->repl_posn($unc_master_stat));
2977                                                  
2978                                                  
2979  ***      0                                  0      $slave_status    = $self->get_slave_status($slave_dbh);
2980  ***      0                                  0      my $slave_pos    = $self->repl_posn($slave_status);
2981  ***      0      0      0                    0      if ( $self->short_host($slave_status) ne $self->short_host($unc_dsn)
2982                                                       || $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
2983                                                     {
2984  ***      0                                  0         die "After changing the slave's master, it isn't a slave of the uncle, "
2985                                                           . "or it has a different replication position than the uncle";
2986                                                     }
2987                                                  }
2988                                                  
2989                                                  sub detach_slave {
2990  ***      0                    0             0      my ( $self, $dbh ) = @_;
2991  ***      0                                  0      $self->stop_slave($dbh);
2992  ***      0      0                           0      my $stat = $self->get_slave_status($dbh)
2993                                                        or die "This server is not a slave";
2994  ***      0                                  0      $dbh->do('CHANGE MASTER TO MASTER_HOST=""');
2995  ***      0                                  0      $dbh->do('RESET SLAVE'); # Wipes out master.info, etc etc
2996  ***      0                                  0      return $stat;
2997                                                  }
2998                                                  
2999                                                  sub slave_is_running {
3000  ***      0                    0             0      my ( $self, $slave_status ) = @_;
3001  ***      0             0                    0      return ($slave_status->{slave_sql_running} || 'No') eq 'Yes';
3002                                                  }
3003                                                  
3004                                                  sub has_slave_updates {
3005  ***      0                    0             0      my ( $self, $dbh ) = @_;
3006  ***      0                                  0      my $sql = q{SHOW VARIABLES LIKE 'log_slave_updates'};
3007  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
3008  ***      0                                  0      my ($name, $value) = $dbh->selectrow_array($sql);
3009  ***      0             0                    0      return $value && $value =~ m/^(1|ON)$/;
3010                                                  }
3011                                                  
3012                                                  sub repl_posn {
3013  ***      0                    0             0      my ( $self, $status ) = @_;
3014  ***      0      0      0                    0      if ( exists $status->{file} && exists $status->{position} ) {
3015                                                        return {
3016  ***      0                                  0            file     => $status->{file},
3017                                                           position => $status->{position},
3018                                                        };
3019                                                     }
3020                                                     else {
3021                                                        return {
3022  ***      0                                  0            file     => $status->{relay_master_log_file},
3023                                                           position => $status->{exec_master_log_pos},
3024                                                        };
3025                                                     }
3026                                                  }
3027                                                  
3028                                                  sub get_slave_lag {
3029  ***      0                    0             0      my ( $self, $dbh ) = @_;
3030  ***      0                                  0      my $stat = $self->get_slave_status($dbh);
3031  ***      0                                  0      return $stat->{seconds_behind_master};
3032                                                  }
3033                                                  
3034                                                  sub pos_cmp {
3035  ***      0                    0             0      my ( $self, $a, $b ) = @_;
3036  ***      0                                  0      return $self->pos_to_string($a) cmp $self->pos_to_string($b);
3037                                                  }
3038                                                  
3039                                                  sub short_host {
3040  ***      0                    0             0      my ( $self, $dsn ) = @_;
3041  ***      0                                  0      my ($host, $port);
3042  ***      0      0                           0      if ( $dsn->{master_host} ) {
3043  ***      0                                  0         $host = $dsn->{master_host};
3044  ***      0                                  0         $port = $dsn->{master_port};
3045                                                     }
3046                                                     else {
3047  ***      0                                  0         $host = $dsn->{h};
3048  ***      0                                  0         $port = $dsn->{P};
3049                                                     }
3050  ***      0      0      0                    0      return ($host || '[default]') . ( ($port || 3306) == 3306 ? '' : ":$port" );
      ***                    0                        
3051                                                  }
3052                                                  
3053                                                  sub pos_to_string {
3054  ***      0                    0             0      my ( $self, $pos ) = @_;
3055  ***      0                                  0      my $fmt  = '%s/%020d';
3056  ***      0                                  0      return sprintf($fmt, @{$pos}{qw(file position)});
      ***      0                                  0   
3057                                                  }
3058                                                  
3059                                                  sub _d {
3060  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3061  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3062  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3063                                                          @_;
3064  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3065                                                  }
3066                                                  
3067                                                  1;
3068                                                  
3069                                                  # ###########################################################################
3070                                                  # End MasterSlave package
3071                                                  # ###########################################################################
3072                                                  
3073                                                  # ###########################################################################
3074                                                  # This is a combination of modules and programs in one -- a runnable module.
3075                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
3076                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
3077                                                  #
3078                                                  # Check at the end of this package for the call to main() which actually runs
3079                                                  # the program.
3080                                                  # ###########################################################################
3081                                                  package mk_archiver;
3082                                                  
3083          17                   17           156   use English qw(-no_match_vars);
              17                                 46   
              17                                125   
3084          17                   17           130   use List::Util qw(max);
              17                                 44   
              17                                103   
3085          17                   17           111   use IO::File;
              17                                 43   
              17                                250   
3086          17                   17           232   use sigtrap qw(handler finish untrapped normal-signals);
              17                                 49   
              17                                154   
3087          17                   17           111   use Time::HiRes qw(gettimeofday sleep time);
              17                                 44   
              17                                138   
3088          17                   17           214   use Data::Dumper;
              17                                 44   
              17                                104   
3089                                                  $Data::Dumper::Indent    = 1;
3090                                                  $Data::Dumper::Quotekeys = 0;
3091                                                  
3092  ***     17            50     17           108   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              17                                 45   
              17                                255   
3093                                                  
3094                                                  # Global variables; as few as possible.
3095                                                  my $oktorun   = 1;
3096                                                  my $txn_cnt   = 0;
3097                                                  my $cnt       = 0;
3098                                                  my $can_retry = 1;
3099                                                  my $archive_fh;
3100                                                  my $get_sth;
3101                                                  my ( $OUT_OF_RETRIES, $ROLLED_BACK, $ALL_IS_WELL ) = ( 0, -1, 1 );
3102                                                  my ( $src, $dst );
3103                                                  
3104                                                  # Holds the arguments for the $sth's bind variables, so it can be re-tried
3105                                                  # easily.
3106                                                  my @beginning_of_txn;
3107                                                  my $dp = new DSNParser(
3108                                                     { key => 'D', copy => 1, desc => 'Database that contains the table' },
3109                                                     { key => 't', copy => 1, desc => 'Table to archive from/to' },
3110                                                     { key => 'a', copy => 0, desc => 'Database to USE when executing queries' },
3111                                                     { key => 'i', copy => 1, desc => 'Index to use' },
3112                                                     { key => 'm', copy => 0, desc => 'Plugin module name' },
3113                                                     { key => 'b', copy => 0, desc => 'Disable binlog with SET SQL_LOG_BIN=0' },
3114                                                  );
3115                                                  my $vp = new VersionParser;
3116                                                  my $q  = new Quoter;
3117                                                  
3118                                                  sub main {
3119          18                   18        10359702      @ARGV = @_;  # set global ARGV for this package
3120                                                  
3121                                                     # Reset global vars else tests, which run this tool as a module,
3122                                                     # may encounter weird results.
3123          18                                144      $oktorun          = 1;
3124          18                                 78      $txn_cnt          = 0;
3125          18                                 69      $cnt              = 0;
3126          18                                 92      $can_retry        = 1;
3127          18                                 73      $archive_fh       = undef;
3128          18                                 76      $get_sth          = undef;
3129          18                                665      ($src, $dst)      = (undef, undef);
3130          18                               4083      @beginning_of_txn = ();
3131          18                                585      undef *trace;
3132          18                                105      ($OUT_OF_RETRIES, $ROLLED_BACK, $ALL_IS_WELL ) = (0, -1, 1);
3133                                                  
3134                                                     # ########################################################################
3135                                                     # Get configuration information.
3136                                                     # ########################################################################
3137          18                                421      my $o = new OptionParser(
3138                                                        prompt      => '--source DSN --where WHERE <options>',
3139                                                        dp          => $dp,
3140                                                        description => q{nibbles records from a MySQL table.  The --source }
3141                                                                     . q{and --dest arguments use DSN syntax; if COPY is }
3142                                                                     . q{yes, --dest defaults to the key's value from --source.},
3143                                                     );
3144          18                                136      $o->get_specs();
3145          18                                208      $o->get_opts();
3146                                                  
3147          18                                130      $dp->prop('set-vars', $o->get('set-vars'));
3148                                                  
3149                                                     # Frequently used options.
3150          18                                106      $src             = $o->get('source');
3151          18                                106      $dst             = $o->get('dest');
3152          18                                103      my $sentinel     = $o->get('sentinel');
3153          18                                 97      my $bulk_del     = $o->get('bulk-delete');
3154          18                                206      my $commit_each  = $o->get('commit-each');
3155          18                                 99      my $limit        = $o->get('limit');
3156          18                                 97      my $archive_file = $o->get('file');
3157          18                                100      my $txnsize      = $o->get('txn-size');
3158          18                                125      my $quiet        = $o->get('quiet');
3159                                                  
3160                                                     # First things first: if --stop was given, create the sentinel file.
3161  ***     18     50                         105      if ( $o->get('stop') ) {
3162  ***      0      0                           0         my $sentinel_fh = IO::File->new($sentinel, ">>")
3163                                                           or die "Cannot open $sentinel: $OS_ERROR\n";
3164  ***      0      0                           0         print $sentinel_fh "Remove this file to permit mk-archiver to run\n"
3165                                                           or die "Cannot write to $sentinel: $OS_ERROR\n";
3166  ***      0      0                           0         close $sentinel_fh
3167                                                           or die "Cannot close $sentinel: $OS_ERROR\n";
3168  ***      0      0                           0         print STDOUT "Successfully created file $sentinel\n"
3169                                                           unless $quiet;
3170  ***      0                                  0         return 0;
3171                                                     }
3172                                                  
3173                                                     # Generate a filename with sprintf-like formatting codes.
3174  ***     18     50                         108      if ( $archive_file ) {
3175  ***      0                                  0         my @time = localtime();
3176  ***      0      0      0                    0         my %fmt = (
      ***             0      0                        
3177                                                           d => sprintf('%02d', $time[3]),
3178                                                           H => sprintf('%02d', $time[2]),
3179                                                           i => sprintf('%02d', $time[1]),
3180                                                           m => sprintf('%02d', $time[4] + 1),
3181                                                           s => sprintf('%02d', $time[0]),
3182                                                           Y => $time[5] + 1900,
3183                                                           D => $src && $src->{D} ? $src->{D} : '',
3184                                                           t => $src && $src->{t} ? $src->{t} : '',
3185                                                        );
3186  ***      0                                  0         $archive_file =~ s/%([dHimsYDt])/$fmt{$1}/g;
3187                                                     }
3188                                                  
3189  ***     18     50                         136      if ( !$o->got('help') ) {
3190  ***     18     50                         128         $o->save_error("--source DSN requires a 't' (table) part")
3191                                                           unless $src->{t};
3192                                                  
3193          18    100                         117         if ( $dst ) {
3194                                                           # Ensure --source and --dest don't point to the same place
3195           7                                 29            my $same = 1;
3196           7                                 42            foreach my $arg ( qw(h P D t S) ) {
3197  ***     28    100     66                  421               if ( defined $src->{$arg} && defined $dst->{$arg}
                           100                        
3198                                                                   && $src->{$arg} ne $dst->{$arg} ) {
3199           7                                 27                  $same = 0;
3200           7                                 34                  last;
3201                                                              }
3202                                                           }
3203  ***      7     50                          42            if ( $same ) {
3204  ***      0                                  0               $o->save_error("--source and --dest refer to the same table");
3205                                                           }
3206                                                        }
3207  ***     18     50                         106         if ( $o->get('bulk-insert') ) {
3208  ***      0      0                           0            $o->save_error("--bulk-insert is meaningless without a destination")
3209                                                              unless $dst;
3210  ***      0                                  0            $bulk_del = 1; # VERY IMPORTANT for safety.
3211                                                        }
3212  ***     18     50     33                  142         if ( $bulk_del && $limit < 2 ) {
3213  ***      0                                  0            $o->save_error("--bulk-delete is meaningless with --limit 1");
3214                                                        }
3215                                                  
3216                                                     }
3217                                                  
3218  ***     18     50     33                  208      if ( $bulk_del || $o->get('bulk-insert') ) {
3219  ***      0                                  0         $o->set('commit-each', 1);
3220                                                     }
3221                                                  
3222          18                                154      $o->usage_or_errors();
3223                                                  
3224                                                     # ########################################################################
3225                                                     # If --pid, check it first since we'll die if it already exits.
3226                                                     # ########################################################################
3227          18                                 65      my $daemon;
3228  ***     18     50                         104      if ( $o->get('pid') ) {
3229                                                        # We're not daemoninzing, it just handles PID stuff.  Keep $daemon
3230                                                        # in the the scope of main() because when it's destroyed it automatically
3231                                                        # removes the PID file.
3232  ***      0                                  0         $daemon = new Daemon(o=>$o);
3233  ***      0                                  0         $daemon->make_PID_file();
3234                                                     }
3235                                                        
3236                                                     # ########################################################################
3237                                                     # Set up statistics.
3238                                                     # ########################################################################
3239          18                                 91      my %statistics = ();
3240          18                                 66      my $stat_start;
3241                                                  
3242          18    100                         105      if ( $o->get('statistics') ) {
3243           2                                 68         my $start    = gettimeofday();
3244           2                                 25         my $obs_cost = gettimeofday() - $start; # cost of observation
3245                                                  
3246                                                        *trace = sub {
3247  ***     37            66     37           297            my ( $thing, $sub ) = @_;
3248          37                                294            my $start = gettimeofday();
3249          37                                199            $sub->();
3250          37                                715            $statistics{$thing . '_time'}
3251                                                              += (gettimeofday() - $start - $obs_cost);
3252          37                                239            ++$statistics{$thing . '_count'};
3253  ***     37            66                  341            $stat_start ||= $start;
3254                                                        }
3255           2                                 64      }
3256                                                     else { # Generate a version that doesn't do any timing
3257                                                        *trace = sub {
3258          26                   26           197            my ( $thing, $sub ) = @_;
3259          26                                170            $sub->();
3260                                                        }
3261          16                                393      }
3262                                                  
3263                                                     # ########################################################################
3264                                                     # Inspect DB servers and tables.
3265                                                     # ########################################################################
3266                                                  
3267          18                                322      my $tp = new TableParser(Quoter => $q);
3268          18                                253      my $du = new MySQLDump();
3269          18                                 94      foreach my $table ( grep { $_ } ($src, $dst) ) {
              36                                206   
3270  ***     25            33                  186         my $ac = !$txnsize && !$commit_each;
3271  ***     25     50     33                  312         if ( !defined $table->{p} && $o->get('ask-pass') ) {
3272  ***      0                                  0            $table->{p} = OptionParser::prompt_noecho("Enter password: ");
3273                                                        }
3274          25                                234         my $dbh = $dp->get_dbh(
3275                                                           $dp->get_cxn_params($table), { AutoCommit => $ac });
3276                                                  
3277                                                        # Set options that can enable removing data on the master and archiving it
3278                                                        # on the slaves.
3279  ***     25     50                         257         if ( $table->{a} ) {
3280  ***      0                                  0            $dbh->do("USE $table->{a}");
3281                                                        }
3282  ***     25     50                         151         if ( $table->{b} ) {
3283  ***      0                                  0            $dbh->do("SET SQL_LOG_BIN=0");
3284                                                        }
3285                                                  
3286          25                                153         $table->{dbh}  = $dbh;
3287          25                                215         $table->{irot} = get_irot($dbh);
3288                                                  
3289  ***     25            33                  313         $can_retry = $can_retry && !$table->{irot};
3290                                                  
3291          50                                439         $table->{db_tbl} = $q->quote(
3292          50                                409            map  { $_ =~ s/(^`|`$)//g; $_; }
              50                                257   
3293          25                                214            grep { $_ }
3294                                                           ( $table->{D}, $table->{t} )
3295                                                        );
3296                                                  
3297                                                        # Create objects for archivable and dependency handling, BEFORE getting
3298                                                        # the tbl structure (because the object might do some setup, including
3299                                                        # creating the table to be archived).
3300  ***     25     50                         195         if ( $table->{m} ) {
3301  ***      0                                  0            eval "require $table->{m}";
3302  ***      0      0                           0            die $EVAL_ERROR if $EVAL_ERROR;
3303                                                  
3304                                                           trace('plugin_start', sub {
3305  ***      0                    0             0               $table->{plugin} = $table->{m}->new(
3306                                                                 dbh          => $table->{dbh},
3307                                                                 db           => $table->{D},
3308                                                                 tbl          => $table->{t},
3309                                                                 OptionParser => $o,
3310                                                                 DSNParser    => $dp,
3311                                                                 Quoter       => $q,
3312                                                              );
3313  ***      0                                  0            });
3314                                                        }
3315                                                  
3316          25                                324         $table->{info} = $tp->parse(
3317                                                           $du->get_create_table($dbh, $q, $table->{D}, $table->{t}));
3318                                                     }
3319                                                  
3320  ***     18     50     66                  199      if ( $o->get('primary-key-only')
3321                                                          && !exists $src->{info}->{keys}->{PRIMARY} ) {
3322  ***      0                                  0         $src->{dbh}->disconnect();
3323  ***      0      0      0                    0         $dst->{dbh}->disconnect() if $dst && $dst->{dbh};
3324  ***      0                                  0         die "--primary-key-only was specified by the --source table "
3325                                                           . "$src->{db_tbl} does not have a PRIMARY KEY";
3326                                                     }
3327                                                  
3328          18    100    100                  160      if ( $dst && $o->get('check-columns') ) {
3329          21                                138         my @not_in_src = grep {
3330           6                                 40            !$src->{info}->{is_col}->{$_}
3331           6                                 22         } @{$dst->{info}->{cols}};
3332  ***      6     50                          37         if ( @not_in_src ) {
3333  ***      0                                  0            $src->{dbh}->disconnect();
3334  ***      0      0      0                    0            $dst->{dbh}->disconnect() if $dst && $dst->{dbh};
3335  ***      0                                  0            die "The following columns exist in --dest but not --source: "
3336                                                              . join(', ', @not_in_src)
3337                                                              . "\n";
3338                                                        }
3339          24                                147         my @not_in_dst = grep {
3340           6                                 55            !$dst->{info}->{is_col}->{$_}
3341           6                                 69         } @{$src->{info}->{cols}};
3342           6    100                          35         if ( @not_in_dst ) {
3343           1                                 43            $src->{dbh}->disconnect();
3344  ***      1     50     33                   40            $dst->{dbh}->disconnect() if $dst && $dst->{dbh};
3345           1                                  5            die "The following columns exist in --source but not --dest: "
3346                                                              . join(', ', @not_in_dst)
3347                                                              . "\n";
3348                                                        }
3349                                                     }
3350                                                  
3351                                                     # ########################################################################
3352                                                     # Get lag dbh.
3353                                                     # ########################################################################
3354          17                                 80      my $lag_dbh;
3355          17                                 57      my $ms;
3356  ***     17     50                          95      if ( $o->get('check-slave-lag') ) {
3357  ***      0                                  0         my $dsn_defaults = $dp->parse_options($o);
3358  ***      0                                  0         my $dsn  = $dp->parse($o->get('check-slave-lag'), $dsn_defaults);
3359  ***      0                                  0         $lag_dbh = $dp->get_dbh($dp->get_cxn_params($dsn), { AutoCommit => 1 });
3360  ***      0                                  0         $ms      = new MasterSlave();
3361                                                     }
3362                                                  
3363                                                     # ########################################################################
3364                                                     # Set up general plugin.
3365                                                     # ########################################################################
3366          17                                 64      my $plugin;
3367  ***     17     50                         106      if ( $o->get('plugin') ) {
3368  ***      0                                  0         eval "require " . $o->get('plugin');
3369  ***      0      0                           0         die $EVAL_ERROR if $EVAL_ERROR;
3370  ***      0                                  0         $plugin = $o->get('plugin')->new(
3371                                                           src  => $src,
3372                                                           dst  => $dst,
3373                                                           opts => $o,
3374                                                        );
3375                                                     }
3376                                                  
3377                                                     # ########################################################################
3378                                                     # Design SQL statements.
3379                                                     # ########################################################################
3380          17                                 92      my $dbh = $src->{dbh};
3381          17                                290      my $nibbler = new TableNibbler(
3382                                                        TableParser => $tp,
3383                                                        Quoter      => $q,
3384                                                     );
3385          17                                 80      my ($first_sql, $next_sql, $del_sql, $ins_sql);
3386          17                                 72      my ($sel_stmt, $ins_stmt, $del_stmt);
3387          17                                 86      my (@asc_slice, @sel_slice, @del_slice, @bulkdel_slice, @ins_slice);
3388           1                                  5      my @sel_cols = $o->get('columns')          ? @{$o->get('columns')}    # Explicit
               1                                  9   
3389          15                                188                   : $o->get('primary-key-only') ? @{$src->{info}->{keys}->{PRIMARY}->{cols}} 
3390          17    100                         103                   :                               @{$src->{info}->{cols}}; # All
                    100                               
3391          17                                 63      MKDEBUG && _d("sel cols: ", @sel_cols);
3392                                                  
3393          17                                182      $del_stmt = $nibbler->generate_del_stmt(
3394                                                        tbl_struct => $src->{info},
3395                                                        cols       => \@sel_cols,
3396                                                        index      => $src->{i},
3397                                                     );
3398          17                                 69      @del_slice = @{$del_stmt->{slice}};
              17                                113   
3399                                                  
3400                                                     # Generate statement for ascending index, if desired
3401  ***     17     50                          99      if ( !$o->get('no-ascend') ) {
3402  ***     17      0                         168         $sel_stmt = $nibbler->generate_asc_stmt(
      ***            50                               
                    100                               
3403                                                           tbl_struct => $src->{info},
3404                                                           cols       => $del_stmt->{cols},
3405                                                           index      => $del_stmt->{index},
3406                                                           asc_first  => $o->get('ascend-first'),
3407                                                           # A plugin might prevent rows in the source from being deleted
3408                                                           # when doing single delete, but it cannot prevent rows from
3409                                                           # being deleted when doing a bulk delete.
3410                                                           asc_only   => $o->get('no-delete') ?  1
3411                                                                      : $src->{m}             ? ($o->get('bulk-delete') ? 0 : 1)
3412                                                                      :                          0,
3413                                                        )
3414                                                     }
3415                                                     else {
3416  ***      0                                  0         $sel_stmt = {
3417                                                           cols  => $del_stmt->{cols},
3418                                                           index => undef,
3419                                                           where => '1=1',
3420                                                           slice => [], # No-ascend = no bind variables in the WHERE clause.
3421                                                           scols => [], # No-ascend = no bind variables in the WHERE clause.
3422                                                        };
3423                                                     }
3424          17                                 74      @asc_slice = @{$sel_stmt->{slice}};
              17                                110   
3425          17                                151      @sel_slice = 0..$#sel_cols;
3426                                                  
3427          63                                318      $first_sql
3428                                                        = 'SELECT' . ( $o->get('high-priority-select') ? ' HIGH_PRIORITY' : '' )
3429                                                        . ' /*!40001 SQL_NO_CACHE */ '
3430          17    100                         127         . join(',', map { $q->quote($_) } @{$sel_stmt->{cols}} )
      ***     17     50                         104   
      ***            50                               
3431                                                        . " FROM $src->{db_tbl}"
3432                                                        . ( $sel_stmt->{index}
3433                                                           ? (($vp->version_ge($dbh, '4.0.9') ? " FORCE" : " USE")
3434                                                              . " INDEX(`$sel_stmt->{index}`)")
3435                                                           : '')
3436                                                        . " WHERE (".$o->get('where').")";
3437                                                  
3438  ***     17     50     33                  119      if ( $o->get('safe-auto-increment')
      ***     17            33                  494   
      ***                   33                        
3439                                                           && $sel_stmt->{index}
3440                                                           && scalar(@{$src->{info}->{keys}->{$sel_stmt->{index}}->{cols}}) == 1
3441                                                           && $src->{info}->{is_autoinc}->{
3442                                                              $src->{info}->{keys}->{$sel_stmt->{index}}->{cols}->[0]
3443                                                           }
3444                                                     ) {
3445  ***      0                                  0         my $col = $q->quote($sel_stmt->{scols}->[0]);
3446  ***      0                                  0         my ($val) = $dbh->selectrow_array("SELECT MAX($col) FROM $src->{db_tbl}");
3447  ***      0                                  0         $first_sql .= " AND ($col < " . $q->quote_val($val) . ")";
3448                                                     }
3449                                                  
3450          17                                 77      $next_sql = $first_sql;
3451  ***     17     50                         105      if ( !$o->get('no-ascend') ) {
3452          17                                109         $next_sql .= " AND $sel_stmt->{where}";
3453                                                     }
3454                                                  
3455          17                                113      foreach my $thing ( $first_sql, $next_sql ) {
3456          34                                144         $thing .= " LIMIT $limit";
3457          34    100                         176         if ( $o->get('for-update') ) {
                    100                               
3458           2                                 23            $thing .= ' FOR UPDATE';
3459                                                        }
3460                                                        elsif ( $o->get('share-lock') ) {
3461           2                                 15            $thing .= ' LOCK IN SHARE MODE';
3462                                                        }
3463                                                     }
3464                                                  
3465  ***     17     50                          98      if ( !$bulk_del ) {
3466                                                        # The LIMIT is *always* 1 here, because even though a SELECT can return
3467                                                        # many rows, an INSERT only does one at a time.  It would not be safe to
3468                                                        # iterate over a SELECT that was LIMIT-ed to 500 rows, read and INSERT
3469                                                        # one, and then delete with a LIMIT of 500.  Only one row would be written
3470                                                        # to the file; only one would be INSERT-ed at the destination.  Every
3471                                                        # DELETE must be LIMIT 1.
3472          17    100                          92         $del_sql = 'DELETE'
                    100                               
3473                                                           . ($o->get('low-priority-delete') ? ' LOW_PRIORITY' : '')
3474                                                           . ($o->get('quick-delete')        ? ' QUICK'        : '')
3475                                                           . " FROM $src->{db_tbl} WHERE $del_stmt->{where}"
3476                                                           . " LIMIT 1";
3477                                                     }
3478                                                     else {
3479                                                        # Unless, of course, it's a bulk DELETE, in which case the 500 rows have
3480                                                        # already been INSERT-ed.
3481  ***      0                                  0         my $asc_stmt = $nibbler->generate_asc_stmt(
3482                                                           tbl_struct => $src->{info},
3483                                                           cols       => $del_stmt->{cols},
3484                                                           index      => $del_stmt->{index},
3485                                                           asc_first  => 0,
3486                                                        );
3487  ***      0      0                           0         $del_sql = 'DELETE'
      ***             0                               
3488                                                           . ($o->get('low-priority-delete') ? ' LOW_PRIORITY' : '')
3489                                                           . ($o->get('quick-delete')        ? ' QUICK'        : '')
3490                                                           . " FROM $src->{db_tbl} WHERE ("
3491                                                           . $asc_stmt->{boundaries}->{'>='}
3492                                                           . ') AND (' . $asc_stmt->{boundaries}->{'<='}
3493                                                           # Unlike the row-at-a-time DELETE, this one must include the user's
3494                                                           # specified WHERE clause and an appropriate LIMIT clause.
3495                                                           . ") AND (".$o->get('where').") LIMIT $limit";
3496  ***      0                                  0         @bulkdel_slice = @{$asc_stmt->{slice}};
      ***      0                                  0   
3497                                                     }
3498                                                  
3499          17    100                         108      if ( $dst ) {
3500           6                                 60         $ins_stmt = $nibbler->generate_ins_stmt(
3501                                                           ins_tbl  => $dst->{info},
3502                                                           sel_cols => \@sel_cols,
3503                                                        );
3504           6                                 20         MKDEBUG && _d("inst stmt: ", Dumper($ins_stmt));
3505           6                                 20         @ins_slice = @{$ins_stmt->{slice}};
               6                                 40   
3506  ***      6     50                          33         if ( $o->get('bulk-insert') ) {
3507  ***      0                                  0            $ins_sql = 'LOAD DATA'
3508                                                                    . ($o->get('low-priority-insert') ? ' LOW_PRIORITY' : '')
3509                                                                    . ' LOCAL INFILE ?'
3510                                                                    . ($o->get('replace')    ? ' REPLACE'      : '')
3511                                                                    . ($o->get('ignore')     ? ' IGNORE'       : '')
3512                                                                    . " INTO TABLE $dst->{db_tbl}("
3513  ***      0      0                           0                     . join(",", map { $q->quote($_) } @{$ins_stmt->{cols}} )
      ***      0      0                           0   
      ***             0                               
3514                                                                    . ")";
3515                                                        }
3516                                                        else {
3517          21                                 94            $ins_sql = ($o->get('replace')             ? 'REPLACE'      : 'INSERT')
3518                                                                    . ($o->get('low-priority-insert') ? ' LOW_PRIORITY' : '')
3519                                                                    . ($o->get('delayed-insert')      ? ' DELAYED'      : '')
3520                                                                    . ($o->get('ignore')              ? ' IGNORE'       : '')
3521                                                                    . " INTO $dst->{db_tbl}("
3522           6                                 32                     . join(",", map { $q->quote($_) } @{$ins_stmt->{cols}} )
              21                                116   
3523                                                                    . ") VALUES ("
3524           6    100                          43                     . join(",", map { "?" } @{$ins_stmt->{cols}} ) . ")";
               6    100                          59   
                    100                               
      ***            50                               
3525                                                        }
3526                                                     }
3527                                                     else {
3528          11                                 54         $ins_sql = '';
3529                                                     }
3530                                                  
3531          17                                 67      if ( MKDEBUG ) {
3532                                                        _d("get first sql:", $first_sql);
3533                                                        _d("get next sql:", $next_sql);
3534                                                        _d("del row sql:", $del_sql);
3535                                                        _d("ins row sql:", $ins_sql);
3536                                                     }
3537                                                     
3538          17    100                         109      if ( $o->get('dry-run') ) {
3539  ***     12     50                          72         if ( !$quiet ) {
3540  ***     12    100     50                  169            print join("\n", grep { $_ } ($archive_file || ''),
              60                                364   
3541                                                                    $first_sql, $next_sql,
3542                                                                    ($o->get('no-delete') ? '' : $del_sql), $ins_sql)
3543                                                              , "\n";
3544                                                        }
3545          12                                887         $src->{dbh}->disconnect();
3546  ***     12    100     66                  317         $dst->{dbh}->disconnect() if $dst && $dst->{dbh};
3547          12                               3071         return 0;
3548                                                     }
3549                                                  
3550           5                                 24      my $get_first = $dbh->prepare($first_sql);
3551           5                                 18      my $get_next  = $dbh->prepare($next_sql);
3552           5                                 16      my $del_row   = $dbh->prepare($del_sql);
3553           5    100                          54      my $ins_row   = $dst->{dbh}->prepare($ins_sql) if $dst; # Different $dbh!
3554                                                  
3555                                                     # ########################################################################
3556                                                     # Set MySQL options.
3557                                                     # ########################################################################
3558                                                  
3559  ***      5     50                          36      if ( $o->get('skip-foreign-key-checks') ) {
3560  ***      0                                  0         $src->{dbh}->do("/*!40014 SET FOREIGN_KEY_CHECKS=0 */");
3561  ***      0      0                           0         if ( $dst ) {
3562  ***      0                                  0            $dst->{dbh}->do("/*!40014 SET FOREIGN_KEY_CHECKS=0 */");
3563                                                        }
3564                                                     }
3565                                                  
3566                                                     # ########################################################################
3567                                                     # Set up the plugins
3568                                                     # ########################################################################
3569           5                                 30      foreach my $table ( $dst, $src ) {
3570  ***     10     50     66                  156         next unless $table && $table->{plugin};
3571                                                        trace ('before_begin', sub {
3572  ***      0                    0             0            $table->{plugin}->before_begin(
3573                                                              cols    => \@sel_cols,
3574                                                              allcols => $sel_stmt->{cols},
3575                                                           );
3576  ***      0                                  0         });
3577                                                     }
3578                                                  
3579                                                     # ########################################################################
3580                                                     # Start archiving.
3581                                                     # ########################################################################
3582           5                                 54      my $start   = time();
3583  ***      5            50                   28      my $end     = $start + ($o->get('run-time') || 0); # When to exit
3584           5                                 30      my $now     = $start;
3585           5                                 17      my $last_select_time;  # for --sleep-coef
3586           5                                 27      my $retries = $o->get('retries');
3587  ***      5     50     33                   31      printf("%-19s %7s %7s\n", 'TIME', 'ELAPSED', 'COUNT')
3588                                                        if $o->get('progress') && !$quiet;
3589  ***      5     50     33                   27      printf("%19s %7d %7d\n", ts($now), $now - $start, $cnt)
3590                                                        if $o->get('progress') && !$quiet;
3591                                                  
3592           5                                 20      $get_sth = $get_first; # Later it may be assigned $get_next
3593                                                     trace('select', sub {
3594           5                    5            34         my $select_start = time;
3595           5                               2883         $get_sth->execute;
3596           5                                 65         $last_select_time = time - $select_start;
3597           5                                177         $statistics{SELECT} += $get_sth->rows;
3598           5                                105      });
3599           5                                144      my $row = $get_sth->fetchrow_arrayref();
3600           5                                 19      MKDEBUG && _d("First row: ", Dumper($row), 'rows:', $get_sth->rows);
3601           5    100                          36      if ( !$row ) {
3602           1                                 28         $get_sth->finish;
3603           1                                198         $src->{dbh}->disconnect();
3604  ***      1     50     33                   13         $dst->{dbh}->disconnect() if $dst && $dst->{dbh};
3605           1                                445         return 0;
3606                                                     }
3607                                                  
3608                                                     # Open the file and print the header to it.
3609  ***      4     50                          22      if ( $archive_file ) {
3610  ***      0             0                    0         my $need_hdr = $o->get('header') && !-f $archive_file;
3611  ***      0      0                           0         $archive_fh = IO::File->new($archive_file, ">>")
3612                                                           or die "Cannot open $archive_file: $OS_ERROR\n";
3613  ***      0      0                           0         $archive_fh->autoflush(1) unless $o->get('buffer');
3614  ***      0      0                           0         if ( $need_hdr ) {
3615  ***      0      0                           0            print $archive_fh '', escape(\@sel_cols), "\n"
3616                                                              or die "Cannot write to $archive_file: $OS_ERROR\n";
3617                                                        }
3618                                                     }
3619                                                  
3620                                                     # Open the bulk insert file, which doesn't get any header info.
3621           4                                 28      my $bulkins_file;
3622  ***      4     50                          30      if ( $o->get('bulk-insert') ) {
3623  ***      0                                  0         require File::Temp;
3624  ***      0      0                           0         $bulkins_file = File::Temp->new( SUFFIX => 'mk-archiver' )
3625                                                           or die "Cannot open temp file: $OS_ERROR\n";
3626                                                     }
3627                                                  
3628                                                     # This row is the first row fetched from each 'chunk'.
3629           4                                 27      my $first_row = [ @$row ];
3630           4                                 14      my $csv_row;
3631                                                  
3632                                                     ROW:
3633  ***      4            66                   90      while (                                 # Quit if:
      ***                   33                        
      ***                   66                        
      ***                   66                        
      ***                   66                        
3634                                                        $row                                 # There is no data
3635                                                        && $retries >= 0                     # or retries are exceeded
3636                                                        && (!$o->get('run-time') || $now < $end) # or time is exceeded
3637                                                        && !-f $sentinel                     # or the sentinel is set
3638                                                        && $oktorun                          # or instructed to quit
3639                                                        )
3640                                                     {
3641          16                                 86         my $lastrow = $row;
3642                                                  
3643  ***     16     50     33                  177         if ( !$src->{plugin}
3644                                                           || trace('is_archivable', sub {
3645  ***      0                    0             0               $src->{plugin}->is_archivable(row => $row)
3646                                                           })
3647                                                        ) {
3648                                                  
3649                                                           # Do the archiving.  Write to the file first since, like the file,
3650                                                           # MyISAM and other tables cannot be rolled back etc.  If there is a
3651                                                           # problem, hopefully the data has at least made it to the file.
3652          16                                 60            my $escaped_row;
3653  ***     16     50     33                  234            if ( $archive_fh || $bulkins_file ) {
3654  ***      0                                  0               $escaped_row = escape([@{$row}[@sel_slice]]);
      ***      0                                  0   
3655                                                           }
3656  ***     16     50                          86            if ( $archive_fh ) {
3657                                                              trace('print_file', sub {
3658  ***      0      0             0             0                  print $archive_fh $escaped_row, "\n"
3659                                                                    or die "Cannot write to $archive_file: $OS_ERROR\n";
3660  ***      0                                  0               });
3661                                                           }
3662                                                  
3663                                                           # ###################################################################
3664                                                           # This code is for the row-at-a-time archiving functionality.
3665                                                           # ###################################################################
3666                                                           # INSERT must come first, to be as safe as possible.
3667  ***     16    100     66                  167            if ( $dst && !$bulkins_file ) {
3668           4                                 16               my $ins_sth; # Let plugin change which sth is used for the INSERT.
3669  ***      4     50                          29               if ( $dst->{plugin} ) {
3670                                                                 trace('before_insert', sub {
3671  ***      0                    0             0                     $dst->{plugin}->before_insert(row => $row);
3672  ***      0                                  0                  });
3673                                                                 trace('custom_sth', sub {
3674  ***      0                    0             0                     $ins_sth = $dst->{plugin}->custom_sth(
3675                                                                       row => $row, sql => $ins_sql);
3676  ***      0                                  0                  });
3677                                                              }
3678  ***      4            33                   24               $ins_sth ||= $ins_row; # Default to the sth decided before.
3679                                                              my $success = do_with_retries($o, 'inserting', sub {
3680           4                    4            23                  $ins_sth->execute(@{$row}[@ins_slice]);
               4                               1092   
3681           4                                 21                  MKDEBUG && _d('Inserted', $del_row->rows, 'rows');
3682           4                                 93                  $statistics{INSERT} += $ins_sth->rows;
3683           4                                 71               });
3684  ***      4     50                          67               if ( $success == $OUT_OF_RETRIES ) {
      ***            50                               
3685  ***      0                                  0                  $retries = -1;
3686  ***      0                                  0                  last ROW;
3687                                                              }
3688                                                              elsif ( $success == $ROLLED_BACK ) {
3689  ***      0                                  0                  --$retries;
3690  ***      0                                  0                  next ROW;
3691                                                              }
3692                                                           }
3693                                                  
3694  ***     16     50                         100            if ( !$bulk_del ) {
3695                                                              # DELETE comes after INSERT for safety.
3696  ***     16     50                         113               if ( $src->{plugin} ) {
3697                                                                 trace('before_delete', sub {
3698  ***      0                    0             0                     $src->{plugin}->before_delete(row => $row);
3699  ***      0                                  0                  });
3700                                                              }
3701          16    100                         115               if ( !$o->get('no-delete') ) {
3702                                                                 my $success = do_with_retries($o, 'deleting', sub {
3703          12                   12            59                     $del_row->execute(@{$row}[@del_slice]);
              12                               7501   
3704          12                                 67                     MKDEBUG && _d('Deleted', $del_row->rows, 'rows');
3705          12                                346                     $statistics{DELETE} += $del_row->rows;
3706          12                                228                  });
3707  ***     12     50                         194                  if ( $success == $OUT_OF_RETRIES ) {
      ***            50                               
3708  ***      0                                  0                     $retries = -1;
3709  ***      0                                  0                     last ROW;
3710                                                                 }
3711                                                                 elsif ( $success == $ROLLED_BACK ) {
3712  ***      0                                  0                     --$retries;
3713  ***      0                                  0                     next ROW;
3714                                                                 }
3715                                                              }
3716                                                           }
3717                                                  
3718                                                           # ###################################################################
3719                                                           # This code is for the bulk archiving functionality.
3720                                                           # ###################################################################
3721  ***     16     50                         110            if ( $bulkins_file ) {
3722                                                              trace('print_bulkfile', sub {
3723  ***      0      0             0             0                  print $bulkins_file $escaped_row, "\n"
3724                                                                    or die "Cannot write to bulk file: $OS_ERROR\n";
3725  ***      0                                  0               });
3726                                                           }
3727                                                  
3728                                                        }  # row is archivable
3729                                                  
3730          16                                150         $now = time();
3731          16                                 62         ++$cnt;
3732          16                                 62         ++$txn_cnt;
3733          16                                113         $retries = $o->get('retries');
3734                                                  
3735                                                        # Possibly flush the file and commit the insert and delete.
3736  ***     16     50                         190         commit($o) unless $commit_each;
3737                                                  
3738                                                        # Report on progress.
3739  ***     16     50     33                  413         if ( !$quiet && $o->get('progress') && $cnt % $o->get('progress') == 0 ) {
      ***                   33                        
3740  ***      0                                  0            printf("%19s %7d %7d\n", ts($now), $now - $start, $cnt);
3741                                                        }
3742                                                  
3743                                                        # Get the next row in this chunk.
3744                                                        # First time through this loop $get_sth is set to $get_first.
3745                                                        # For non-bulk operations this means that rows ($row) are archived
3746                                                        # one-by-one in in the code block above ("row is archivable").  For
3747                                                        # bulk operations, the 2nd to 2nd-to-last rows are ignored and
3748                                                        # only the first row ($first_row) and the last row ($last_row) of
3749                                                        # this chunk are used to do bulk INSERT or DELETE on the range of
3750                                                        # rows between first and last.  After the bulk ops, $first_row and
3751                                                        # $last_row are reset to the next chunk.
3752  ***     16     50                         403         if ( $get_sth->{Active} ) { # Fetch until exhausted
3753          16                                628            $row = $get_sth->fetchrow_arrayref();
3754                                                        }
3755  ***     16     50                         148         if ( !$row ) {
3756          16                                 68            MKDEBUG && _d('No more rows in this chunk; doing bulk operations');
3757                                                  
3758                                                           # ###################################################################
3759                                                           # This code is for the bulk archiving functionality.
3760                                                           # ###################################################################
3761  ***     16     50                         104            if ( $bulkins_file ) {
3762  ***      0      0                           0               $bulkins_file->close()
3763                                                                 or die "Cannot close bulk insert file: $OS_ERROR\n";
3764  ***      0                                  0               my $ins_sth; # Let plugin change which sth is used for the INSERT.
3765  ***      0      0                           0               if ( $dst->{plugin} ) {
3766                                                                 trace('before_bulk_insert', sub {
3767  ***      0                    0             0                     $dst->{plugin}->before_bulk_insert(
3768                                                                       first_row => $first_row,
3769                                                                       last_row  => $lastrow,
3770                                                                    );
3771  ***      0                                  0                  });
3772                                                                 trace('custom_sth', sub {
3773  ***      0                    0             0                     $ins_sth = $dst->{plugin}->custom_sth_bulk(
3774                                                                       first_row => $first_row,
3775                                                                       last_row  => $lastrow,
3776                                                                       sql       => $ins_sql,
3777                                                                    );
3778  ***      0                                  0                  });
3779                                                              }
3780  ***      0             0                    0               $ins_sth ||= $ins_row; # Default to the sth decided before.
3781                                                              my $success = do_with_retries($o, 'bulk_inserting', sub {
3782  ***      0                    0             0                  $ins_sth->execute($bulkins_file->filename());
3783  ***      0                                  0                  MKDEBUG && _d('Bulk inserted', $del_row->rows, 'rows');
3784  ***      0                                  0                  $statistics{INSERT} += $ins_sth->rows;
3785  ***      0                                  0               });
3786  ***      0      0                           0               if ( $success != $ALL_IS_WELL ) {
3787  ***      0                                  0                  $retries = -1;
3788  ***      0                                  0                  last ROW; # unlike other places, don't do 'next'
3789                                                              }
3790                                                           }
3791                                                  
3792  ***     16     50                          96            if ( $bulk_del ) {
3793  ***      0      0                           0               if ( $src->{plugin} ) {
3794                                                                 trace('before_bulk_delete', sub {
3795  ***      0                    0             0                     $src->{plugin}->before_bulk_delete(
3796                                                                       first_row => $first_row,
3797                                                                       last_row  => $lastrow,
3798                                                                    );
3799  ***      0                                  0                  });
3800                                                              }
3801  ***      0      0                           0               if ( !$o->get('no-delete') ) {
3802                                                                 my $success = do_with_retries($o, 'bulk_deleting', sub {
3803  ***      0                                  0                     $del_row->execute(
3804  ***      0                                  0                        @{$first_row}[@bulkdel_slice],
3805  ***      0                    0             0                        @{$lastrow}[@bulkdel_slice],
3806                                                                    );
3807  ***      0                                  0                     MKDEBUG && _d('Bulk deleted', $del_row->rows, 'rows');
3808  ***      0                                  0                     $statistics{DELETE} += $del_row->rows;
3809  ***      0                                  0                  });
3810  ***      0      0                           0                  if ( $success != $ALL_IS_WELL ) {
3811  ***      0                                  0                     $retries = -1;
3812  ***      0                                  0                     last ROW; # unlike other places, don't do 'next'
3813                                                                 }
3814                                                              }
3815                                                           }
3816                                                  
3817                                                           # ###################################################################
3818                                                           # This code is for normal operation AND bulk operation.
3819                                                           # ###################################################################
3820  ***     16     50                         120            commit($o, 1) if $commit_each;
3821          16                                 72            $get_sth = $get_next;
3822                                                  
3823          16                                 54            MKDEBUG && _d('Fetching rows in next chunk');
3824                                                           trace('select', sub {
3825          16                   16           137               my $select_start = time;
3826          16                                 88               $get_sth->execute(@{$lastrow}[@asc_slice]);
              16                               7511   
3827          16                                256               $last_select_time = time - $select_start;
3828          16                                 52               MKDEBUG && _d('Fetched', $get_sth->rows, 'rows');
3829          16                                578               $statistics{SELECT} += $get_sth->rows;
3830          16                                407            });
3831                                                  
3832                                                           # Reset $first_row to the first row of this new chunk.
3833  ***     16     50                         311            @beginning_of_txn = @{$lastrow}[@asc_slice] unless $txn_cnt;
              16                                233   
3834          16                                338            $row              = $get_sth->fetchrow_arrayref();
3835          16    100                         193            $first_row        = $row ? [ @$row ] : undef;
3836                                                  
3837  ***     16     50                         173            if ( $o->get('bulk-insert') ) {
3838  ***      0      0                           0               $bulkins_file = File::Temp->new( SUFFIX => 'mk-archiver' )
3839                                                                 or die "Cannot open temp file: $OS_ERROR\n";
3840                                                           }
3841                                                        }  # no next row (do bulk operations)
3842                                                        else {
3843  ***      0                                  0            MKDEBUG && _d('Got another row in this chunk');
3844                                                        }
3845                                                  
3846                                                        # Check slave lag and wait if slave is too far behind.
3847  ***     16     50                         112         if ( $lag_dbh ) {
3848  ***      0                                  0            my $lag = $ms->get_slave_lag($lag_dbh);
3849  ***      0             0                    0            while ( !defined $lag || $lag > $o->get('max-lag') ) {
3850  ***      0                                  0               MKDEBUG && _d('Sleeping: slave lag is', $lag);
3851  ***      0                                  0               sleep($o->get('check-interval'));
3852  ***      0                                  0               $lag = $ms->get_slave_lag($lag_dbh);
3853                                                           }
3854                                                        }
3855                                                  
3856                                                        # Sleep between rows.
3857  ***     16     50                         125         if( my $sleep_time = $o->get('sleep') ) {
3858  ***      0      0                           0            $sleep_time = $last_select_time * $o->get('sleep-coef')
3859                                                              if $o->get('sleep-coef');
3860  ***      0                                  0            MKDEBUG && _d('Sleeping', $sleep_time);
3861                                                           trace('sleep', sub {
3862  ***      0                    0             0               sleep($sleep_time);
3863  ***      0                                  0            });
3864                                                        }
3865                                                     }  # ROW 
3866           4                                 16      MKDEBUG && _d('Done fetching rows');
3867                                                  
3868                                                     # Transactions might still be open, etc
3869  ***      4            33                   46      commit($o, $txnsize || $commit_each);
3870  ***      4     50     33                   41      if ( $archive_file && $archive_fh ) {
3871  ***      0      0                           0         close $archive_fh
3872                                                           or die "Cannot close $archive_file: $OS_ERROR\n";
3873                                                     }
3874                                                  
3875  ***      4     50     33                   79      if ( !$quiet && $o->get('progress') ) {
3876  ***      0                                  0         printf("%19s %7d %7d\n", ts($now), $now - $start, $cnt);
3877                                                     }
3878                                                  
3879                                                     # Tear down the plugins.
3880           4                                 33      foreach my $table ( $dst, $src ) {
3881  ***      8     50     66                  143         next unless $table && $table->{plugin};
3882                                                        trace('after_finish', sub {
3883  ***      0                    0             0            $table->{plugin}->after_finish();
3884  ***      0                                  0         });
3885                                                     }
3886                                                  
3887                                                     # Run ANALYZE or OPTIMIZE.
3888  ***      4    100     66                   62      if ( $oktorun && ($o->get('analyze') || $o->get('optimize')) ) {
      ***                   66                        
3889  ***      1            33                   14         my $action = $o->get('analyze') || $o->get('optimize');
3890  ***      1     50                           8         my $maint  = ($o->get('analyze') ? 'ANALYZE' : 'OPTIMIZE')
      ***            50                               
3891                                                                   . ($o->get('local') ? ' /*!40101 NO_WRITE_TO_BINLOG*/' : '');
3892  ***      1     50                          27         if ( $action =~ m/s/i ) {
3893                                                           trace($maint, sub {
3894           1                    1        293892               $src->{dbh}->do("$maint TABLE $src->{db_tbl}");
3895           1                                 21            });
3896                                                        }
3897  ***      1     50     33                   62         if ( $action =~ m/d/i && $dst ) {
3898                                                           trace($maint, sub {
3899  ***      0                    0             0               $dst->{dbh}->do("$maint TABLE $dst->{db_tbl}");
3900  ***      0                                  0            });
3901                                                        }
3902                                                     } 
3903                                                  
3904                                                     # ########################################################################
3905                                                     # Print statistics
3906                                                     # ########################################################################
3907  ***      4     50                          35      if ( $plugin ) {
3908  ***      0                                  0         $plugin->statistics(\%statistics, $stat_start);
3909                                                     }
3910                                                  
3911  ***      4    100     66                   75      if ( !$quiet && $o->get('statistics') ) {
3912           2                                 17         my $stat_stop  = gettimeofday();
3913           2                                 12         my $stat_total = $stat_stop - $stat_start;
3914                                                  
3915           2                                  8         my $total2 = 0;
3916           2                                 17         my $maxlen = 0;
3917           2                                  8         my %summary;
3918                                                  
3919           2                                 16         printf("Started at %s, ended at %s\n", ts($stat_start), ts($stat_stop));
3920           2                                 20         print("Source: ", $dp->as_string($src), "\n");
3921           2    100                          34         print("Dest:   ", $dp->as_string($dst), "\n") if $dst;
3922           2           100                   18         print(join("\n", map { "$_ " . ($statistics{$_} || 0) }
               6                                 81   
3923                                                              qw(SELECT INSERT DELETE)), "\n");
3924                                                  
3925           2                                 20         foreach my $thing ( grep { m/_(count|time)/ } keys %statistics ) {
              19                                154   
3926          14                                183            my ( $action, $type ) = $thing =~ m/^(.*?)_(count|time)$/;
3927          14                                143            $summary{$action}->{$type}  = $statistics{$thing};
3928          14                                 81            $summary{$action}->{action} = $action;
3929          14                                105            $maxlen                     = max($maxlen, length($action));
3930                                                           # Just in case I get only one type of statistic for a given action (in
3931                                                           # case there was a crash or CTRL-C or something).
3932          14           100                  110            $summary{$action}->{time}  ||= 0;
3933          14           100                  116            $summary{$action}->{count} ||= 0;
3934                                                        }
3935           2                                 37         printf("%-${maxlen}s \%10s %10s %10s\n", qw(Action Count Time Pct));
3936           2                                 21         my $fmt = "%-${maxlen}s \%10d %10.4f %10.2f\n";
3937                                                  
3938           2                                  6         foreach my $stat (
               6                                 45   
3939                                                           reverse sort { $a->{time} <=> $b->{time} } values %summary )
3940                                                        {
3941           7                                 57            my $pct = $stat->{time} / $stat_total * 100;
3942           7                                 38            printf($fmt, @{$stat}{qw(action count time)}, $pct);
               7                                159   
3943           7                                 51            $total2 += $stat->{time};
3944                                                        }
3945           2                                 51         printf($fmt, 'other', 0, $stat_total - $total2,
3946                                                           ($stat_total - $total2) / $stat_total * 100);
3947                                                     }
3948                                                  
3949                                                     # Optionally print the reason for exiting.  Do this even if --quiet is
3950                                                     # specified.
3951           4    100                          33      if ( $o->get('why-quit') ) {
3952  ***      1     50     33                   12         if ( $retries < 0 ) {
      ***            50                               
      ***            50                               
      ***            50                               
3953  ***      0                                  0            print "Exiting because retries exceeded.\n";
3954                                                        }
3955                                                        elsif ( $o->get('run-time') && $now >= $end ) {
3956  ***      0                                  0            print "Exiting because time exceeded.\n";
3957                                                        }
3958                                                        elsif ( -f $sentinel ) {
3959  ***      0                                  0            print "Exiting because sentinel file $sentinel exists.\n";
3960                                                        }
3961                                                        elsif ( $o->get('statistics') ) {
3962           1                                  7            print "Exiting because there are no more rows.\n";
3963                                                        }
3964                                                     }
3965                                                  
3966           4                                429      $src->{dbh}->disconnect();
3967  ***      4    100     66                   85      $dst->{dbh}->disconnect() if $dst && $dst->{dbh};
3968                                                  
3969           4                               1634      return 0;
3970                                                  }
3971                                                  
3972                                                  # ############################################################################
3973                                                  # Subroutines.
3974                                                  # ############################################################################
3975                                                  
3976                                                  # Catches signals so mk-archiver can exit gracefully.
3977                                                  sub finish {
3978  ***      0                    0             0      my ($signal) = @_;
3979  ***      0                                  0      print STDERR "Exiting on SIG$signal.\n";
3980  ***      0                                  0      $oktorun = 0;
3981                                                  }
3982                                                  
3983                                                  # Accesses globals, but I wanted the code in one place.
3984                                                  sub commit {
3985          20                   20           142      my ( $o, $force ) = @_;
3986          20                                133      my $txnsize = $o->get('txn-size');
3987  ***     20     50     33                  669      if ( $force || ($txnsize && $txn_cnt && $cnt % $txnsize == 0) ) {
      ***                   33                        
      ***                   66                        
3988  ***     20     50     33                  121         if ( $o->get('buffer') && $archive_fh ) {
3989  ***      0                                  0            my $archive_file = $o->get('file');
3990                                                           trace('flush', sub {
3991  ***      0      0             0             0               $archive_fh->flush or die "Cannot flush $archive_file: $OS_ERROR\n";
3992  ***      0                                  0            });
3993                                                        }
3994          20    100                         126         if ( $dst ) {
3995                                                           trace('commit', sub {
3996           5                    5        647621               $dst->{dbh}->commit;
3997           5                                 76            });
3998                                                        }
3999                                                        trace('commit', sub {
4000          20                   20        1912112            $src->{dbh}->commit;
4001          20                                405         });
4002          20                                392         $txn_cnt = 0;
4003                                                     }
4004                                                  }
4005                                                  
4006                                                  # Repeatedly retries the code until retries runs out, a really bad error
4007                                                  # happens, or it succeeds.  This sub uses lots of global variables; I only wrote
4008                                                  # it to factor out some repeated code.
4009                                                  sub do_with_retries {
4010          16                   16           135      my ( $o, $doing, $code ) = @_;
4011          16                                100      my $retries = $o->get('retries');
4012          16                                 95      my $txnsize = $o->get('txn-size');
4013          16                                 67      my $success = $OUT_OF_RETRIES;
4014                                                  
4015                                                     RETRY:
4016  ***     16            66                  243      while ( !$success && $retries >= 0 ) {
4017          16                                 73         eval {
4018          16                                 99            trace($doing, $code);
4019          16                                124            $success = $ALL_IS_WELL;
4020                                                        };
4021  ***     16     50                         194         if ( $EVAL_ERROR ) {
4022  ***      0      0                           0            if ( $EVAL_ERROR =~ m/Lock wait timeout exceeded|Deadlock found/ ) {
4023  ***      0      0      0                    0               if (
      ***                    0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
4024                                                                 # More than one row per txn
4025                                                                 (
4026                                                                    ($txnsize && $txnsize > 1)
4027                                                                    || ($o->get('commit-each') && $o->get('limit') > 1)
4028                                                                 )
4029                                                                 # Not first row
4030                                                                 && $txn_cnt
4031                                                                 # And it's not retry-able
4032                                                                 && (!$can_retry || $EVAL_ERROR =~ m/Deadlock/)
4033                                                              ) {
4034                                                                 # The txn, which is more than 1 statement, was rolled back.
4035  ***      0                                  0                  last RETRY;
4036                                                              }
4037                                                              else {
4038                                                                 # Only one statement had trouble, and the rest of the txn was
4039                                                                 # not rolled back.  The statement can be retried.
4040  ***      0                                  0                  --$retries;
4041                                                              }
4042                                                           }
4043                                                           else {
4044  ***      0                                  0               die $EVAL_ERROR;
4045                                                           }
4046                                                        }
4047                                                     }
4048                                                  
4049  ***     16     50                         107      if ( $success != $ALL_IS_WELL ) {
4050                                                        # Must throw away everything and start the transaction over.
4051  ***      0      0                           0         if ( $retries >= 0 ) {
4052  ***      0                                  0            warn "Deadlock or non-retryable lock wait while $doing; "
4053                                                              . "rolling back $txn_cnt rows.\n";
4054  ***      0                                  0            $success = $ROLLED_BACK;
4055                                                        }
4056                                                        else {
4057  ***      0                                  0            warn "Exhausted retries while $doing; rolling back $txn_cnt rows.\n";
4058  ***      0                                  0            $success = $OUT_OF_RETRIES;
4059                                                        }
4060  ***      0                                  0         $get_sth->finish;
4061                                                        trace('rollback', sub {
4062  ***      0                    0             0            $dst->{dbh}->rollback;
4063  ***      0                                  0         });
4064                                                        trace('rollback', sub {
4065  ***      0                    0             0            $src->{dbh}->rollback;
4066  ***      0                                  0         });
4067                                                        # I wish: $archive_fh->rollback
4068                                                        trace('select', sub {
4069  ***      0                    0             0            $get_sth->execute(@beginning_of_txn);
4070  ***      0                                  0         });
4071  ***      0                                  0         $cnt -= $txn_cnt;
4072  ***      0                                  0         $txn_cnt = 0;
4073                                                     }
4074          16                                113      return $success;
4075                                                  }
4076                                                  
4077                                                  # Formats a row the same way SELECT INTO OUTFILE does by default.  This is
4078                                                  # described in the LOAD DATA INFILE section of the MySQL manual,
4079                                                  # http://dev.mysql.com/doc/refman/5.0/en/load-data.html
4080                                                  sub escape {
4081  ***      0                    0             0      my ($row) = @_;
4082  ***      0      0                           0      return join("\t", map {
4083  ***      0                                  0         s/([\t\n\\])/\\$1/g if defined $_;  # Escape tabs etc
4084  ***      0      0                           0         defined $_ ? $_ : '\N';             # NULL = \N
4085                                                     } @$row);
4086                                                  }
4087                                                  
4088                                                  sub ts {
4089           4                    4            25      my ( $time ) = @_;
4090           4                                225      my ( $sec, $min, $hour, $mday, $mon, $year )
4091                                                        = localtime($time);
4092           4                                 28      $mon  += 1;
4093           4                                 17      $year += 1900;
4094           4                                 85      return sprintf("%d-%02d-%02dT%02d:%02d:%02d",
4095                                                        $year, $mon, $mday, $hour, $min, $sec);
4096                                                  }
4097                                                  
4098                                                  sub get_irot {
4099          25                   25           139      my ( $dbh ) = @_;
4100  ***     25     50                         221      return 1 unless $vp->version_ge($dbh, '5.0.13');
4101          25                                355      my $rows = $dbh->selectall_arrayref(
4102                                                        "show variables like 'innodb_rollback_on_timeout'",
4103                                                        { Slice => {} });
4104  ***     25     50                         280      return 0 unless $rows;
4105  ***     25            33                  523      return @$rows && $rows->[0]->{Value} ne 'OFF';
4106                                                  }
4107                                                  
4108                                                  sub _d {
4109  ***      0                    0                    my ($package, undef, $line) = caller 0;
4110  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
4111  ***      0                                              map { defined $_ ? $_ : 'undef' }
4112                                                          @_;
4113  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4114                                                  }
4115                                                  
4116                                                  # ############################################################################
4117                                                  # Run the program.
4118                                                  # ############################################################################
4119                                                  if ( !caller ) { exit main(@ARGV); }
4120                                                  
4121                                                  1; # Because this is a module as well as a script.
4122                                                  
4123                                                  # ############################################################################
4124                                                  # Documentation.
4125                                                  # ############################################################################
4126                                                  
4127                                                  =pod
4128                                                  
4129                                                  =head1 NAME
4130                                                  
4131                                                  mk-archiver - Archive rows from a MySQL table into another table or a file.
4132                                                  
4133                                                  =head1 SYNOPSIS
4134                                                  
4135                                                   mk-archiver --source h=oltp_server,D=test,t=tbl --dest h=olap_server \
4136                                                      --file '/var/log/archive/%Y-%m-%d-%D.%t' --limit 1000 --commit-each
4137                                                  
4138                                                  =head1 RISKS
4139                                                  
4140                                                  The following section is included to inform users about the potential risks,
4141                                                  whether known or unknown, of using this tool.  The two main categories of risks
4142                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
4143                                                  tools) and those created by bugs.
4144                                                  
4145                                                  mk-achiver is a read-write tool.  It deletes data from the source by default, so
4146                                                  you should test your archiving jobs with the L<"--dry-run"> option if you're not
4147                                                  sure about them.  It is designed to have as little impact on production systems
4148                                                  as possible, but tuning with L<"--limit">, L<"--txn-size"> and similar options
4149                                                  might be a good idea too.
4150                                                  
4151                                                  If you write or use L<"--plugin"> modules, you should ensure they are good
4152                                                  quality and well-tested. 
4153                                                  
4154                                                  At the time of this release, a user has reported that DBI quoting might cause
4155                                                  the tool not to delete some rows from the source table.
4156                                                  
4157                                                  The authoritative source for updated information is always the online issue
4158                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
4159                                                  see a list of such issues at the following URL:
4160                                                  L<http://www.maatkit.org/bugs/mk-archiver>.
4161                                                  
4162                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
4163                                                  
4164                                                  =head1 DESCRIPTION
4165                                                  
4166                                                  mk-archiver is the tool I use to archive tables as described in
4167                                                  L<http://tinyurl.com/mysql-archiving>.  The goal is a low-impact, forward-only
4168                                                  job to nibble old data out of the table without impacting OLTP queries much.
4169                                                  You can insert the data into another table, which need not be on the same
4170                                                  server.  You can also write it to a file in a format suitable for LOAD DATA
4171                                                  INFILE.  Or you can do neither, in which case it's just an incremental DELETE.
4172                                                  
4173                                                  mk-archiver is extensible via a plugin mechanism.  You can inject your own
4174                                                  code to add advanced archiving logic that could be useful for archiving
4175                                                  dependent data, applying complex business rules, or building a data warehouse
4176                                                  during the archiving process.
4177                                                  
4178                                                  You need to choose values carefully for some options.  The most important are
4179                                                  L<"--limit">, L<"--retries">, and L<"--txn-size">.
4180                                                  
4181                                                  The strategy is to find the first row(s), then scan some index forward-only to
4182                                                  find more rows efficiently.  Each subsequent query should not scan the entire
4183                                                  table; it should seek into the index, then scan until it finds more archivable
4184                                                  rows.  Specifying the index with the 'i' part of the L<"--source"> argument can
4185                                                  be crucial for this; use L<"--dry-run"> to examine the generated queries and be
4186                                                  sure to EXPLAIN them to see if they are efficient (most of the time you probably
4187                                                  want to scan the PRIMARY key, which is the default).  Even better, profile
4188                                                  mk-archiver with mk-query-profiler and make sure it is not scanning the whole
4189                                                  table every query.
4190                                                  
4191                                                  You can disable the seek-then-scan optimizations partially or wholly with
4192                                                  L<"--no-ascend"> and L<"--ascend-first">.  Sometimes this may be more efficient
4193                                                  for multi-column keys.  Be aware that mk-archiver is built to start at the
4194                                                  beginning of the index it chooses and scan it forward-only.  This might result
4195                                                  in long table scans if you're trying to nibble from the end of the table by an
4196                                                  index other than the one it prefers.  See L<"--source"> and read the
4197                                                  documentation on the C<i> part if this applies to you.
4198                                                  
4199                                                  =head1 OUTPUT
4200                                                  
4201                                                  If you specify L<"--progress">, the output is a header row, plus status output
4202                                                  at intervals.  Each row in the status output lists the current date and time,
4203                                                  how many seconds mk-archiver has been running, and how many rows it has
4204                                                  archived.
4205                                                  
4206                                                  If you specify L<"--statistics">, C<mk-archiver> outputs timing and other
4207                                                  information to help you identify which part of your archiving process takes the
4208                                                  most time.
4209                                                  
4210                                                  =head1 ERROR-HANDLING
4211                                                  
4212                                                  mk-archiver tries to catch signals and exit gracefully; for example, if you
4213                                                  send it SIGTERM (Ctrl-C on UNIX-ish systems), it will catch the signal, print a
4214                                                  message about the signal, and exit fairly normally.  It will not execute
4215                                                  L<"--analyze"> or L<"--optimize">, because these may take a long time to finish.
4216                                                  It will run all other code normally, including calling after_finish() on any
4217                                                  plugins (see L<"EXTENDING">).
4218                                                  
4219                                                  In other words, a signal, if caught, will break out of the main archiving
4220                                                  loop and skip optimize/analyze.
4221                                                  
4222                                                  =head1 OPTIONS
4223                                                  
4224                                                  Specify at least one of L<"--dest">, L<"--file">, or L<"--purge">.
4225                                                  
4226                                                  L<"--ignore"> and L<"--replace"> are mutually exclusive.
4227                                                  
4228                                                  L<"--txn-size"> and L<"--commit-each"> are mutually exclusive.
4229                                                  
4230                                                  L<"--low-priority-insert"> and L<"--delayed-insert"> are mutually exclusive.
4231                                                  
4232                                                  L<"--share-lock"> and L<"--for-update"> are mutually exclusive.
4233                                                  
4234                                                  L<"--analyze"> and L<"--optimize"> are mutually exclusive.
4235                                                  
4236                                                  L<"--no-ascend"> and L<"--no-delete"> are mutually exclusive.
4237                                                  
4238                                                  DSN values in L<"--dest"> default to values from L<"--source"> if COPY is yes.
4239                                                  
4240                                                  =over
4241                                                  
4242                                                  =item --analyze
4243                                                  
4244                                                  type: string
4245                                                  
4246                                                  Run ANALYZE TABLE afterwards on L<"--source"> and/or L<"--dest">.
4247                                                  
4248                                                  Runs ANALYZE TABLE after finishing.  The argument is an arbitrary string.  If it
4249                                                  contains the letter 's', the source will be analyzed.  If it contains 'd', the
4250                                                  destination will be analyzed.  You can specify either or both.  For example, the
4251                                                  following will analyze both:
4252                                                  
4253                                                    --analyze=ds
4254                                                  
4255                                                  See L<http://dev.mysql.com/doc/en/analyze-table.html> for details on ANALYZE
4256                                                  TABLE.
4257                                                  
4258                                                  =item --ascend-first
4259                                                  
4260                                                  Ascend only first column of index.
4261                                                  
4262                                                  If you do want to use the ascending index optimization (see L<"--no-ascend">),
4263                                                  but do not want to incur the overhead of ascending a large multi-column index,
4264                                                  you can use this option to tell mk-archiver to ascend only the leftmost column
4265                                                  of the index.  This can provide a significant performance boost over not
4266                                                  ascending the index at all, while avoiding the cost of ascending the whole
4267                                                  index.
4268                                                  
4269                                                  See L<"EXTENDING"> for a discussion of how this interacts with plugins.
4270                                                  
4271                                                  =item --ask-pass
4272                                                  
4273                                                  Prompt for a password when connecting to MySQL.
4274                                                  
4275                                                  =item --buffer
4276                                                  
4277                                                  Buffer output to L<"--file"> and flush at commit.
4278                                                  
4279                                                  Disables autoflushing to L<"--file"> and flushes L<"--file"> to disk only when a
4280                                                  transaction commits.  This typically means the file is block-flushed by the
4281                                                  operating system, so there may be some implicit flushes to disk between
4282                                                  commits as well.  The default is to flush L<"--file"> to disk after every row.
4283                                                  
4284                                                  The danger is that a crash might cause lost data.
4285                                                  
4286                                                  The performance increase I have seen from using L<"--buffer"> is around 5 to 15
4287                                                  percent.  Your mileage may vary.
4288                                                  
4289                                                  =item --bulk-delete
4290                                                  
4291                                                  Delete each chunk with a single statement (implies L<"--commit-each">).
4292                                                  
4293                                                  Delete each chunk of rows in bulk with a single C<DELETE> statement.  The
4294                                                  statement deletes every row between the first and last row of the chunk,
4295                                                  inclusive.  It implies L<"--commit-each">, since it would be a bad idea to
4296                                                  C<INSERT> rows one at a time and commit them before the bulk C<DELETE>.
4297                                                  
4298                                                  The normal method is to delete every row by its primary key.  Bulk deletes might
4299                                                  be a lot faster.  B<They also might not be faster> if you have a complex
4300                                                  C<WHERE> clause.
4301                                                  
4302                                                  This option completely defers all C<DELETE> processing until the chunk of rows
4303                                                  is finished.  If you have a plugin on the source, its C<before_delete> method
4304                                                  will not be called.  Instead, its C<before_bulk_delete> method is called later.
4305                                                  
4306                                                  B<WARNING>: if you have a plugin on the source that sometimes doesn't return
4307                                                  true from C<is_archivable()>, you should use this option only if you understand
4308                                                  what it does.  If the plugin instructs C<mk-archiver> not to archive a row,
4309                                                  it will still be deleted by the bulk delete!
4310                                                  
4311                                                  =item --bulk-insert
4312                                                  
4313                                                  Insert each chunk with LOAD DATA INFILE (implies L<"--bulk-delete"> L<"--commit-each">).
4314                                                  
4315                                                  Insert each chunk of rows with C<LOAD DATA LOCAL INFILE>.  This may be much
4316                                                  faster than inserting a row at a time with C<INSERT> statements.  It is
4317                                                  implemented by creating a temporary file for each chunk of rows, and writing the
4318                                                  rows to this file instead of inserting them.  When the chunk is finished, it
4319                                                  uploads the rows.
4320                                                  
4321                                                  To protect the safety of your data, this option forces bulk deletes to be used.
4322                                                  It would be unsafe to delete each row as it is found, before inserting the rows
4323                                                  into the destination first.  Forcing bulk deletes guarantees that the deletion
4324                                                  waits until the insertion is successful.
4325                                                  
4326                                                  The L<"--low-priority-insert">, L<"--replace">, and L<"--ignore"> options work
4327                                                  with this option, but L<"--delayed-insert"> does not.
4328                                                  
4329                                                  =item --charset
4330                                                  
4331                                                  short form: -A; type: string
4332                                                  
4333                                                  Default character set.  If the value is utf8, sets Perl's binmode on
4334                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and runs SET
4335                                                  NAMES UTF8 after connecting to MySQL.  Any other value sets binmode on STDOUT
4336                                                  without the utf8 layer, and runs SET NAMES after connecting to MySQL.
4337                                                  
4338                                                  =item --[no]check-columns
4339                                                  
4340                                                  default: yes
4341                                                  
4342                                                  Ensure L<"--source"> and L<"--dest"> have same columns.
4343                                                  
4344                                                  Enabled by default; causes mk-archiver to check that the source and destination
4345                                                  tables have the same columns.  It does not check column order, data type, etc.
4346                                                  It just checks that all columns in the source exist in the destination and
4347                                                  vice versa.  If there are any differences, mk-archiver will exit with an
4348                                                  error.
4349                                                  
4350                                                  To disable this check, specify --no-check-columns.
4351                                                  
4352                                                  =item --check-interval
4353                                                  
4354                                                  type: time; default: 1s
4355                                                  
4356                                                  How often to check for slave lag if L<"--check-slave-lag"> is given.
4357                                                  
4358                                                  =item --check-slave-lag
4359                                                  
4360                                                  type: string
4361                                                  
4362                                                  Pause archiving until the specified DSN's slave lag is less than L<"--max-lag">.
4363                                                  
4364                                                  =item --columns
4365                                                  
4366                                                  short form: -c; type: array
4367                                                  
4368                                                  Comma-separated list of columns to archive.
4369                                                  
4370                                                  Specify a comma-separated list of columns to fetch, write to the file, and
4371                                                  insert into the destination table.  If specified, mk-archiver ignores other
4372                                                  columns unless it needs to add them to the C<SELECT> statement for ascending an
4373                                                  index or deleting rows.  It fetches and uses these extra columns internally, but
4374                                                  does not write them to the file or to the destination table.  It I<does> pass
4375                                                  them to plugins.
4376                                                  
4377                                                  See also L<"--primary-key-only">.
4378                                                  
4379                                                  =item --commit-each
4380                                                  
4381                                                  Commit each set of fetched and archived rows (disables L<"--txn-size">).
4382                                                  
4383                                                  Commits transactions and flushes L<"--file"> after each set of rows has been
4384                                                  archived, before fetching the next set of rows, and before sleeping if
4385                                                  L<"--sleep"> is specified.  Disables L<"--txn-size">; use L<"--limit"> to
4386                                                  control the transaction size with L<"--commit-each">.
4387                                                  
4388                                                  This option is useful as a shortcut to make L<"--limit"> and L<"--txn-size"> the
4389                                                  same value, but more importantly it avoids transactions being held open while
4390                                                  searching for more rows.  For example, imagine you are archiving old rows from
4391                                                  the beginning of a very large table, with L<"--limit"> 1000 and L<"--txn-size">
4392                                                  1000.  After some period of finding and archiving 1000 rows at a time,
4393                                                  mk-archiver finds the last 999 rows and archives them, then executes the next
4394                                                  SELECT to find more rows.  This scans the rest of the table, but never finds any
4395                                                  more rows.  It has held open a transaction for a very long time, only to
4396                                                  determine it is finished anyway.  You can use L<"--commit-each"> to avoid this.
4397                                                  
4398                                                  =item --config
4399                                                  
4400                                                  type: Array
4401                                                  
4402                                                  Read this comma-separated list of config files; if specified, this must be the
4403                                                  first option on the command line.
4404                                                  
4405                                                  =item --delayed-insert
4406                                                  
4407                                                  Add the DELAYED modifier to INSERT statements.
4408                                                  
4409                                                  Adds the DELAYED modifier to INSERT or REPLACE statements.  See
4410                                                  L<http://dev.mysql.com/doc/en/insert.html> for details.
4411                                                  
4412                                                  =item --dest
4413                                                  
4414                                                  type: DSN
4415                                                  
4416                                                  DSN specifying the table to archive to.
4417                                                  
4418                                                  This item specifies a table into which mk-archiver will insert rows
4419                                                  archived from L<"--source">.  It uses the same key=val argument format as
4420                                                  L<"--source">.  Most missing values default to the same values as
4421                                                  L<"--source">, so you don't have to repeat options that are the same in
4422                                                  L<"--source"> and L<"--dest">.  Use the L<"--help"> option to see which values
4423                                                  are copied from L<"--source">.
4424                                                  
4425                                                  =item --dry-run
4426                                                  
4427                                                  Print queries and exit without doing anything.
4428                                                  
4429                                                  Causes mk-archiver to exit after printing the filename and SQL statements
4430                                                  it will use.
4431                                                  
4432                                                  =item --file
4433                                                  
4434                                                  type: string
4435                                                  
4436                                                  File to archive to, with DATE_FORMAT()-like formatting.
4437                                                  
4438                                                  Filename to write archived rows to.  A subset of MySQL's DATE_FORMAT()
4439                                                  formatting codes are allowed in the filename, as follows:
4440                                                  
4441                                                     %d    Day of the month, numeric (01..31)
4442                                                     %H    Hour (00..23)
4443                                                     %i    Minutes, numeric (00..59)
4444                                                     %m    Month, numeric (01..12)
4445                                                     %s    Seconds (00..59)
4446                                                     %Y    Year, numeric, four digits
4447                                                  
4448                                                  You can use the following extra format codes too:
4449                                                  
4450                                                     %D    Database name
4451                                                     %t    Table name
4452                                                  
4453                                                  Example:
4454                                                  
4455                                                     --file '/var/log/archive/%Y-%m-%d-%D.%t'
4456                                                  
4457                                                  The file's contents are in the same format used by SELECT INTO OUTFILE, as
4458                                                  documented in the MySQL manual: rows terminated by newlines, columns
4459                                                  terminated by tabs, NULL characters are represented by \N, and special
4460                                                  characters are escaped by \.  This lets you reload a file with LOAD DATA
4461                                                  INFILE's default settings.
4462                                                  
4463                                                  If you want a column header at the top of the file, see L<"--header">.  The file
4464                                                  is auto-flushed by default; see L<"--buffer">.
4465                                                  
4466                                                  =item --for-update
4467                                                  
4468                                                  Adds the FOR UPDATE modifier to SELECT statements.
4469                                                  
4470                                                  For details, see L<http://dev.mysql.com/doc/en/innodb-locking-reads.html>.
4471                                                  
4472                                                  =item --header
4473                                                  
4474                                                  Print column header at top of L<"--file">.
4475                                                  
4476                                                  Writes column names as the first line in the file given by L<"--file">.  If the
4477                                                  file exists, does not write headers; this keeps the file loadable with LOAD
4478                                                  DATA INFILE in case you append more output to it.
4479                                                  
4480                                                  =item --help
4481                                                  
4482                                                  Show help and exit.
4483                                                  
4484                                                  =item --high-priority-select
4485                                                  
4486                                                  Adds the HIGH_PRIORITY modifier to SELECT statements.
4487                                                  
4488                                                  See L<http://dev.mysql.com/doc/en/select.html> for details.
4489                                                  
4490                                                  =item --host
4491                                                  
4492                                                  short form: -h; type: string
4493                                                  
4494                                                  Connect to host.
4495                                                  
4496                                                  =item --ignore
4497                                                  
4498                                                  Use IGNORE for INSERT statements.
4499                                                  
4500                                                  Causes INSERTs into L<"--dest"> to be INSERT IGNORE.
4501                                                  
4502                                                  =item --limit
4503                                                  
4504                                                  type: int; default: 1
4505                                                  
4506                                                  Number of rows to fetch and archive per statement.
4507                                                  
4508                                                  Limits the number of rows returned by the SELECT statements that retrieve rows
4509                                                  to archive.  Default is one row.  It may be more efficient to increase the
4510                                                  limit, but be careful if you are archiving sparsely, skipping over many rows;
4511                                                  this can potentially cause more contention with other queries, depending on the
4512                                                  storage engine, transaction isolation level, and options such as
4513                                                  L<"--for-update">.
4514                                                  
4515                                                  =item --local
4516                                                  
4517                                                  Do not write OPTIMIZE or ANALYZE queries to binlog.
4518                                                  
4519                                                  Adds the NO_WRITE_TO_BINLOG modifier to ANALYZE and OPTIMIZE queries.  See
4520                                                  L<"--analyze"> for details.
4521                                                  
4522                                                  =item --low-priority-delete
4523                                                  
4524                                                  Adds the LOW_PRIORITY modifier to DELETE statements.
4525                                                  
4526                                                  See L<http://dev.mysql.com/doc/en/delete.html> for details.
4527                                                  
4528                                                  =item --low-priority-insert
4529                                                  
4530                                                  Adds the LOW_PRIORITY modifier to INSERT or REPLACE statements.
4531                                                  
4532                                                  See L<http://dev.mysql.com/doc/en/insert.html> for details.
4533                                                  
4534                                                  =item --max-lag
4535                                                  
4536                                                  type: time; default: 1s
4537                                                  
4538                                                  Pause archiving if the slave given by L<"--check-slave-lag"> lags.
4539                                                  
4540                                                  This option causes mk-archiver to look at the slave every time it's about
4541                                                  to fetch another row.  If the slave's lag is greater than the option's value,
4542                                                  or if the slave isn't running (so its lag is NULL), mk-table-checksum sleeps
4543                                                  for L<"--check-interval"> seconds and then looks at the lag again.  It repeats
4544                                                  until the slave is caught up, then proceeds to fetch and archive the row.
4545                                                  
4546                                                  This option may eliminate the need for L<"--sleep"> or L<"--sleep-coef">.
4547                                                  
4548                                                  =item --no-ascend
4549                                                  
4550                                                  Do not use ascending index optimization.
4551                                                  
4552                                                  The default ascending-index optimization causes C<mk-archiver> to optimize
4553                                                  repeated C<SELECT> queries so they seek into the index where the previous query
4554                                                  ended, then scan along it, rather than scanning from the beginning of the table
4555                                                  every time.  This is enabled by default because it is generally a good strategy
4556                                                  for repeated accesses.
4557                                                  
4558                                                  Large, multiple-column indexes may cause the WHERE clause to be complex enough
4559                                                  that this could actually be less efficient.  Consider for example a four-column
4560                                                  PRIMARY KEY on (a, b, c, d).  The WHERE clause to start where the last query
4561                                                  ended is as follows:
4562                                                  
4563                                                     WHERE (a > ?)
4564                                                        OR (a = ? AND b > ?)
4565                                                        OR (a = ? AND b = ? AND c > ?)
4566                                                        OR (a = ? AND b = ? AND c = ? AND d >= ?)
4567                                                  
4568                                                  Populating the placeholders with values uses memory and CPU, adds network
4569                                                  traffic and parsing overhead, and may make the query harder for MySQL to
4570                                                  optimize.  A four-column key isn't a big deal, but a ten-column key in which
4571                                                  every column allows C<NULL> might be.
4572                                                  
4573                                                  Ascending the index might not be necessary if you know you are simply removing
4574                                                  rows from the beginning of the table in chunks, but not leaving any holes, so
4575                                                  starting at the beginning of the table is actually the most efficient thing to
4576                                                  do.
4577                                                  
4578                                                  See also L<"--ascend-first">.  See L<"EXTENDING"> for a discussion of how this
4579                                                  interacts with plugins.
4580                                                  
4581                                                  =item --no-delete
4582                                                  
4583                                                  Do not delete archived rows.
4584                                                  
4585                                                  Causes C<mk-archiver> not to delete rows after processing them.  This disallows
4586                                                  L<"--no-ascend">, because enabling them both would cause an infinite loop.
4587                                                  
4588                                                  If there is a plugin on the source DSN, its C<before_delete> method is called
4589                                                  anyway, even though C<mk-archiver> will not execute the delete.  See
4590                                                  L<"EXTENDING"> for more on plugins.
4591                                                  
4592                                                  =item --optimize
4593                                                  
4594                                                  type: string
4595                                                  
4596                                                  Run OPTIMIZE TABLE afterwards on L<"--source"> and/or L<"--dest">.
4597                                                  
4598                                                  Runs OPTIMIZE TABLE after finishing.  See L<"--analyze"> for the option syntax
4599                                                  and L<http://dev.mysql.com/doc/en/optimize-table.html> for details on OPTIMIZE
4600                                                  TABLE.
4601                                                  
4602                                                  =item --password
4603                                                  
4604                                                  short form: -p; type: string
4605                                                  
4606                                                  Password to use when connecting.
4607                                                  
4608                                                  =item --pid
4609                                                  
4610                                                  type: string
4611                                                  
4612                                                  Create the given PID file when daemonized.  The file contains the process ID of
4613                                                  the daemonized instance.  The PID file is removed when the daemonized instance
4614                                                  exits.  The program checks for the existence of the PID file when starting; if
4615                                                  it exists and the process with the matching PID exists, the program exits.
4616                                                  
4617                                                  =item --plugin
4618                                                  
4619                                                  type: string
4620                                                  
4621                                                  Perl module name to use as a generic plugin.
4622                                                  
4623                                                  Specify the Perl module name of a general-purpose plugin.  It is currently used
4624                                                  only for statistics (see L<"--statistics">) and must have C<new()> and a
4625                                                  C<statistics()> method.
4626                                                  
4627                                                  The C<new( src => $src, dst => $dst, opts => $o )> method gets the source
4628                                                  and destination DSNs, and their database connections, just like the
4629                                                  connection-specific plugins do.  It also gets an OptionParser object (C<$o>) for
4630                                                  accessing command-line options (example: C<$o->get('purge');>).
4631                                                  
4632                                                  The C<statistics(\%stats, $time)> method gets a hashref of the statistics
4633                                                  collected by the archiving job, and the time the whole job started.
4634                                                  
4635                                                  =item --port
4636                                                  
4637                                                  short form: -P; type: int
4638                                                  
4639                                                  Port number to use for connection.
4640                                                  
4641                                                  =item --primary-key-only
4642                                                  
4643                                                  Primary key columns only.
4644                                                  
4645                                                  A shortcut for specifying L<"--columns"> with the primary key columns.  This is
4646                                                  an efficiency if you just want to purge rows; it avoids fetching the entire row,
4647                                                  when only the primary key columns are needed for C<DELETE> statements.  See also
4648                                                  L<"--purge">.
4649                                                  
4650                                                  =item --progress
4651                                                  
4652                                                  type: int
4653                                                  
4654                                                  Print progress information every X rows.
4655                                                  
4656                                                  Prints current time, elapsed time, and rows archived every X rows.
4657                                                  
4658                                                  =item --purge
4659                                                  
4660                                                  Purge instead of archiving; allows omitting L<"--file"> and L<"--dest">.
4661                                                  
4662                                                  Allows archiving without a L<"--file"> or L<"--dest"> argument, which is
4663                                                  effectively a purge since the rows are just deleted.
4664                                                  
4665                                                  If you just want to purge rows, consider specifying the table's primary key
4666                                                  columns with L<"--primary-key-only">.  This will prevent fetching all columns
4667                                                  from the server for no reason.
4668                                                  
4669                                                  =item --quick-delete
4670                                                  
4671                                                  Adds the QUICK modifier to DELETE statements.
4672                                                  
4673                                                  See L<http://dev.mysql.com/doc/en/delete.html> for details.  As stated in the
4674                                                  documentation, in some cases it may be faster to use DELETE QUICK followed by
4675                                                  OPTIMIZE TABLE.  You can use L<"--optimize"> for this.
4676                                                  
4677                                                  =item --quiet
4678                                                  
4679                                                  Do not print any output, such as for L<"--statistics">.
4680                                                  
4681                                                  Suppresses normal output, including the output of L<"--statistics">, but doesn't
4682                                                  suppress the output from L<"--why-quit">.
4683                                                  
4684                                                  =item --replace
4685                                                  
4686                                                  Causes INSERTs into L<"--dest"> to be written as REPLACE.
4687                                                  
4688                                                  =item --retries
4689                                                  
4690                                                  type: int; default: 1
4691                                                  
4692                                                  Number of retries per timeout or deadlock.
4693                                                  
4694                                                  Specifies the number of times mk-archiver should retry when there is an
4695                                                  InnoDB lock wait timeout or deadlock.  When retries are exhausted,
4696                                                  mk-archiver will exit with an error.
4697                                                  
4698                                                  Consider carefully what you want to happen when you are archiving between a
4699                                                  mixture of transactional and non-transactional storage engines.  The INSERT to
4700                                                  L<"--dest"> and DELETE from L<"--source"> are on separate connections, so they
4701                                                  do not actually participate in the same transaction even if they're on the same
4702                                                  server.  However, mk-archiver implements simple distributed transactions in
4703                                                  code, so commits and rollbacks should happen as desired across the two
4704                                                  connections.
4705                                                  
4706                                                  At this time I have not written any code to handle errors with transactional
4707                                                  storage engines other than InnoDB.  Request that feature if you need it.
4708                                                  
4709                                                  =item --run-time
4710                                                  
4711                                                  type: time
4712                                                  
4713                                                  Time to run before exiting.
4714                                                  
4715                                                  Optional suffix s=seconds, m=minutes, h=hours, d=days; if no suffix, s is used.
4716                                                  
4717                                                  =item --[no]safe-auto-increment
4718                                                  
4719                                                  default: yes
4720                                                  
4721                                                  Do not archive row with max AUTO_INCREMENT.
4722                                                  
4723                                                  Adds an extra WHERE clause to prevent mk-archiver from removing the newest
4724                                                  row when ascending a single-column AUTO_INCREMENT key.  This guards against
4725                                                  re-using AUTO_INCREMENT values if the server restarts, and is enabled by
4726                                                  default.
4727                                                  
4728                                                  The extra WHERE clause contains the maximum value of the auto-increment column
4729                                                  as of the beginning of the archive or purge job.  If new rows are inserted while
4730                                                  mk-archiver is running, it will not see them.
4731                                                  
4732                                                  =item --sentinel
4733                                                  
4734                                                  type: string; default: /tmp/mk-archiver-sentinel
4735                                                  
4736                                                  Exit if this file exists.
4737                                                  
4738                                                  The presence of the file specified by L<"--sentinel"> will cause mk-archiver to
4739                                                  stop archiving and exit.  The default is /tmp/mk-archiver-sentinel.  You
4740                                                  might find this handy to stop cron jobs gracefully if necessary.  See also
4741                                                  L<"--stop">.
4742                                                  
4743                                                  =item --set-vars
4744                                                  
4745                                                  type: string; default: wait_timeout=10000
4746                                                  
4747                                                  Set these MySQL variables.
4748                                                  
4749                                                  Specify any variables you want to be set immediately after connecting to MySQL.
4750                                                  These will be included in a C<SET> command.
4751                                                  
4752                                                  =item --share-lock
4753                                                  
4754                                                  Adds the LOCK IN SHARE MODE modifier to SELECT statements.
4755                                                  
4756                                                  See L<http://dev.mysql.com/doc/en/innodb-locking-reads.html>.
4757                                                  
4758                                                  =item --skip-foreign-key-checks
4759                                                  
4760                                                  Disables foreign key checks with SET FOREIGN_KEY_CHECKS=0.
4761                                                  
4762                                                  =item --sleep
4763                                                  
4764                                                  type: int
4765                                                  
4766                                                  Sleep time between fetches.
4767                                                  
4768                                                  Specifies how long to sleep between SELECT statements.  Default is not to
4769                                                  sleep at all.  Transactions are NOT committed, and the L<"--file"> file is NOT
4770                                                  flushed, before sleeping.  See L<"--txn-size"> to control that.
4771                                                  
4772                                                  If L<"--commit-each"> is specified, committing and flushing happens before
4773                                                  sleeping.
4774                                                  
4775                                                  =item --sleep-coef
4776                                                  
4777                                                  type: float
4778                                                  
4779                                                  Calculate L<"--sleep"> as a multiple of the last SELECT time.
4780                                                  
4781                                                  If this option is specified, mk-archiver will sleep for the query time of the
4782                                                  last SELECT multiplied by the specified coefficient.  This option is ignored
4783                                                  if L<"--sleep"> is specified.
4784                                                  
4785                                                  This is a slightly more sophisticated way to throttle the SELECTs: sleep a
4786                                                  varying amount of time between each SELECT, depending on how long the SELECTs
4787                                                  are taking.
4788                                                  
4789                                                  =item --socket
4790                                                  
4791                                                  short form: -S; type: string
4792                                                  
4793                                                  Socket file to use for connection.
4794                                                  
4795                                                  =item --source
4796                                                  
4797                                                  type: DSN
4798                                                  
4799                                                  DSN specifying the table to archive from (required).
4800                                                  
4801                                                  This argument is specially formatted as a key=value,key=value string.  Keys are
4802                                                  a single letter.  Most options control how mk-archiver connects to MySQL:
4803                                                  
4804                                                     KEY MEANING
4805                                                     === =======
4806                                                     h   Connect to host
4807                                                     P   Port number to use for connection
4808                                                     S   Socket file to use for connection
4809                                                     u   User for login if not current user
4810                                                     p   Password to use when connecting
4811                                                     F   Only read default options from the given file
4812                                                  
4813                                                  The following options select a table to archive:
4814                                                  
4815                                                     KEY MEANING
4816                                                     === =======
4817                                                     D   Database to archive
4818                                                     t   Table to archive
4819                                                     i   Index to use
4820                                                  
4821                                                  The following options specify pluggable actions, which an external Perl module
4822                                                  can provide:
4823                                                  
4824                                                     KEY MEANING
4825                                                     === =======
4826                                                     m   Package name of an external Perl module (see EXTENDING).
4827                                                  
4828                                                  The following actions set other options:
4829                                                  
4830                                                     KEY MEANING
4831                                                     === =======
4832                                                     a   Database to set as the connection's default with USE
4833                                                     b   Disable binary logging with SET SQL_LOG_BIN=0
4834                                                  
4835                                                  The only required part is the table; other parts may be read from various
4836                                                  places in the environment (such as options files).  Here is an example:
4837                                                  
4838                                                     --source h=my_server,D=my_database,t=my_tbl
4839                                                  
4840                                                  The 'i' part deserves special mention.  This tells mk-archiver which index
4841                                                  it should scan to archive.  This appears in a FORCE INDEX or USE INDEX hint in
4842                                                  the SELECT statements used to fetch archivable rows.  If you don't specify
4843                                                  anything, mk-archiver will auto-discover a good index, preferring a C<PRIMARY
4844                                                  KEY> if one exists.  In my experience this usually works well, so most of the
4845                                                  time you can probably just omit the 'i' part.
4846                                                  
4847                                                  The index is used to optimize repeated accesses to the table; mk-archiver
4848                                                  remembers the last row it retrieves from each SELECT statement, and uses it to
4849                                                  construct a WHERE clause, using the columns in the specified index, that should
4850                                                  allow MySQL to start the next SELECT where the last one ended, rather than
4851                                                  potentially scanning from the beginning of the table with each successive
4852                                                  SELECT.  If you are using external plugins, please see L<"EXTENDING"> for a
4853                                                  discussion of how they interact with ascending indexes.
4854                                                  
4855                                                  The 'a' and 'b' options allow you to control how statements flow through the
4856                                                  binary log.  If you specify the 'b' option, binary logging will be disabled on
4857                                                  the specified connection.  If you specify the 'a' option, the connection will
4858                                                  C<USE> the specified database, which you can use to prevent slaves from
4859                                                  executing the binary log events with C<--replicate-ignore-db> options.  These
4860                                                  two options can be used as different methods to achieve the same goal: archive
4861                                                  data off the master, but leave it on the slave.  For example, you can run a
4862                                                  purge job on the master and prevent it from happening on the slave using your
4863                                                  method of choice.
4864                                                  
4865                                                  =item --statistics
4866                                                  
4867                                                  Collect and print timing statistics.
4868                                                  
4869                                                  Causes mk-archiver to collect timing statistics about what it does.  These
4870                                                  statistics are available to the plugin specified by L<"--plugin">
4871                                                  
4872                                                  Unless you specify L<"--quiet">, C<mk-archiver> prints the statistics when it
4873                                                  exits.  The statistics look like this:
4874                                                  
4875                                                   Started at 2008-07-18T07:18:53, ended at 2008-07-18T07:18:53
4876                                                   Source: D=db,t=table
4877                                                   SELECT 4
4878                                                   INSERT 4
4879                                                   DELETE 4
4880                                                   Action         Count       Time        Pct
4881                                                   commit            10     0.1079      88.27
4882                                                   select             5     0.0047       3.87
4883                                                   deleting           4     0.0028       2.29
4884                                                   inserting          4     0.0028       2.28
4885                                                   other              0     0.0040       3.29
4886                                                  
4887                                                  The first two (or three) lines show times and the source and destination tables.
4888                                                  The next three lines show how many rows were fetched, inserted, and deleted.
4889                                                  
4890                                                  The remaining lines show counts and timing.  The columns are the action, the
4891                                                  total number of times that action was timed, the total time it took, and the
4892                                                  percent of the program's total runtime.  The rows are sorted in order of
4893                                                  descending total time.  The last row is the rest of the time not explicitly
4894                                                  attributed to anything.  Actions will vary depending on command-line options.
4895                                                  
4896                                                  If L<"--why-quit"> is given, its behavior is changed slightly.  This option
4897                                                  causes it to print the reason for exiting even when it's just because there are
4898                                                  no more rows.
4899                                                  
4900                                                  This option requires the standard Time::HiRes module, which is part of core Perl
4901                                                  on reasonably new Perl releases.
4902                                                  
4903                                                  =item --stop
4904                                                  
4905                                                  Stop running instances by creating the sentinel file.
4906                                                  
4907                                                  Causes mk-archiver to create the sentinel file specified by L<"--sentinel"> and
4908                                                  exit.  This should have the effect of stopping all running instances which are
4909                                                  watching the same sentinel file.
4910                                                  
4911                                                  =item --txn-size
4912                                                  
4913                                                  type: int; default: 1
4914                                                  
4915                                                  Number of rows per transaction.
4916                                                  
4917                                                  Specifies the size, in number of rows, of each transaction. Zero disables
4918                                                  transactions altogether.  After mk-archiver processes this many rows, it
4919                                                  commits both the L<"--source"> and the L<"--dest"> if given, and flushes the
4920                                                  file given by L<"--file">.
4921                                                  
4922                                                  This parameter is critical to performance.  If you are archiving from a live
4923                                                  server, which for example is doing heavy OLTP work, you need to choose a good
4924                                                  balance between transaction size and commit overhead.  Larger transactions
4925                                                  create the possibility of more lock contention and deadlocks, but smaller
4926                                                  transactions cause more frequent commit overhead, which can be significant.  To
4927                                                  give an idea, on a small test set I worked with while writing mk-archiver, a
4928                                                  value of 500 caused archiving to take about 2 seconds per 1000 rows on an
4929                                                  otherwise quiet MySQL instance on my desktop machine, archiving to disk and to
4930                                                  another table.  Disabling transactions with a value of zero, which turns on
4931                                                  autocommit, dropped performance to 38 seconds per thousand rows.
4932                                                  
4933                                                  If you are not archiving from or to a transactional storage engine, you may
4934                                                  want to disable transactions so mk-archiver doesn't try to commit.
4935                                                  
4936                                                  =item --user
4937                                                  
4938                                                  short form: -u; type: string
4939                                                  
4940                                                  User for login if not current user.
4941                                                  
4942                                                  =item --version
4943                                                  
4944                                                  Show version and exit.
4945                                                  
4946                                                  =item --where
4947                                                  
4948                                                  type: string
4949                                                  
4950                                                  WHERE clause to limit which rows to archive (required).
4951                                                  
4952                                                  Specifies a WHERE clause to limit which rows are archived.  Do not include the
4953                                                  word WHERE.  You may need to quote the argument to prevent your shell from
4954                                                  interpreting it.  For example:
4955                                                  
4956                                                     --where 'ts < current_date - interval 90 day'
4957                                                  
4958                                                  For safety, L<"--where"> is required.  If you do not require a WHERE clause, use
4959                                                  L<"--where"> 1=1.
4960                                                  
4961                                                  =item --why-quit
4962                                                  
4963                                                  Print reason for exiting unless rows exhausted.
4964                                                  
4965                                                  Causes mk-archiver to print a message if it exits for any reason other than
4966                                                  running out of rows to archive.  This can be useful if you have a cron job with
4967                                                  L<"--run-time"> specified, for example, and you want to be sure mk-archiver is
4968                                                  finishing before running out of time.
4969                                                  
4970                                                  If L<"--statistics"> is given, the behavior is changed slightly.  It will print
4971                                                  the reason for exiting even when it's just because there are no more rows.
4972                                                  
4973                                                  This output prints even if L<"--quiet"> is given.  That's so you can put
4974                                                  C<mk-archiver> in a C<cron> job and get an email if there's an abnormal exit.
4975                                                  
4976                                                  =back
4977                                                  
4978                                                  =head1 EXTENDING
4979                                                  
4980                                                  mk-archiver is extensible by plugging in external Perl modules to handle some
4981                                                  logic and/or actions.  You can specify a module for both the L<"--source"> and
4982                                                  the L<"--dest">, with the 'm' part of the specification.  For example:
4983                                                  
4984                                                     --source D=test,t=test1,m=My::Module1 --dest m=My::Module2,t=test2
4985                                                  
4986                                                  This will cause mk-archiver to load the My::Module1 and My::Module2 packages,
4987                                                  create instances of them, and then make calls to them during the archiving
4988                                                  process.
4989                                                  
4990                                                  You can also specify a plugin with L<"--plugin">.
4991                                                  
4992                                                  The module must provide this interface:
4993                                                  
4994                                                  =over
4995                                                  
4996                                                  =item new(dbh => $dbh, db => $db_name, tbl => $tbl_name)
4997                                                  
4998                                                  The plugin's constructor is passed a reference to the database handle, the
4999                                                  database name, and table name.  The plugin is created just after mk-archiver
5000                                                  opens the connection, and before it examines the table given in the arguments.
5001                                                  This gives the plugin a chance to create and populate temporary tables, or do
5002                                                  other setup work.
5003                                                  
5004                                                  =item before_begin(cols => \@cols, allcols => \@allcols)
5005                                                  
5006                                                  This method is called just before mk-archiver begins iterating through rows
5007                                                  and archiving them, but after it does all other setup work (examining table
5008                                                  structures, designing SQL queries, and so on).  This is the only time
5009                                                  mk-archiver tells the plugin column names for the rows it will pass the
5010                                                  plugin while archiving.
5011                                                  
5012                                                  The C<cols> argument is the column names the user requested to be archived,
5013                                                  either by default or by the L<"--columns"> option.  The C<allcols> argument is
5014                                                  the list of column names for every row mk-archiver will fetch from the source
5015                                                  table.  It may fetch more columns than the user requested, because it needs some
5016                                                  columns for its own use.  When subsequent plugin functions receive a row, it is
5017                                                  the full row containing all the extra columns, if any, added to the end.
5018                                                  
5019                                                  =item is_archivable(row => \@row)
5020                                                  
5021                                                  This method is called for each row to determine whether it is archivable.  This
5022                                                  applies only to L<"--source">.  The argument is the row itself, as an arrayref.
5023                                                  If the method returns true, the row will be archived; otherwise it will be
5024                                                  skipped.
5025                                                  
5026                                                  Skipping a row adds complications for non-unique indexes.  Normally
5027                                                  mk-archiver uses a WHERE clause designed to target the last processed row as
5028                                                  the place to start the scan for the next SELECT statement.  If you have skipped
5029                                                  the row by returning false from is_archivable(), mk-archiver could get into
5030                                                  an infinite loop because the row still exists.  Therefore, when you specify a
5031                                                  plugin for the L<"--source"> argument, mk-archiver will change its WHERE clause
5032                                                  slightly.  Instead of starting at "greater than or equal to" the last processed
5033                                                  row, it will start "strictly greater than."  This will work fine on unique
5034                                                  indexes such as primary keys, but it may skip rows (leave holes) on non-unique
5035                                                  indexes or when ascending only the first column of an index.
5036                                                  
5037                                                  C<mk-archiver> will change the clause in the same way if you specify
5038                                                  L<"--no-delete">, because again an infinite loop is possible.
5039                                                  
5040                                                  If you specify the L<"--bulk-delete"> option and return false from this method,
5041                                                  C<mk-archiver> may not do what you want.  The row won't be archived, but it will
5042                                                  be deleted, since bulk deletes operate on ranges of rows and don't know which
5043                                                  rows the plugin selected to keep.
5044                                                  
5045                                                  If you specify the L<"--bulk-insert"> option, this method's return value will
5046                                                  influence whether the row is written to the temporary file for the bulk insert,
5047                                                  so bulk inserts will work as expected.  However, bulk inserts require bulk
5048                                                  deletes.
5049                                                  
5050                                                  =item before_delete(row => \@row)
5051                                                  
5052                                                  This method is called for each row just before it is deleted.  This applies only
5053                                                  to L<"--source">.  This is a good place for you to handle dependencies, such as
5054                                                  deleting things that are foreign-keyed to the row you are about to delete.  You
5055                                                  could also use this to recursively archive all dependent tables.
5056                                                  
5057                                                  This plugin method is called even if L<"--no-delete"> is given, but not if
5058                                                  L<"--bulk-delete"> is given.
5059                                                  
5060                                                  =item before_bulk_delete(first_row => \@row, last_row => \@row)
5061                                                  
5062                                                  This method is called just before a bulk delete is executed.  It is similar to
5063                                                  the C<before_delete> method, except its arguments are the first and last row of
5064                                                  the range to be deleted.  It is called even if L<"--no-delete"> is given.
5065                                                  
5066                                                  =item before_insert(row => \@row)
5067                                                  
5068                                                  This method is called for each row just before it is inserted.  This applies
5069                                                  only to L<"--dest">.  You could use this to insert the row into multiple tables,
5070                                                  perhaps with an ON DUPLICATE KEY UPDATE clause to build summary tables in a data
5071                                                  warehouse.
5072                                                  
5073                                                  This method is not called if L<"--bulk-insert"> is given.
5074                                                  
5075                                                  =item before_bulk_insert(first_row => \@row, last_row => \@row)
5076                                                  
5077                                                  This method is called just before a bulk insert is executed.  It is similar to
5078                                                  the C<before_insert> method, except its arguments are the first and last row of
5079                                                  the range to be deleted.
5080                                                  
5081                                                  =item custom_sth(row => \@row, sql => $sql)
5082                                                  
5083                                                  This method is called just before inserting the row, but after
5084                                                  L<"before_insert()">.  It allows the plugin to specify different C<INSERT>
5085                                                  statement if desired.  The return value (if any) should be a DBI statement
5086                                                  handle.  The C<sql> parameter is the SQL text used to prepare the default
5087                                                  C<INSERT> statement.  This method is not called if you specify
5088                                                  L<"--bulk-insert">.
5089                                                  
5090                                                  If no value is returned, the default C<INSERT> statement handle is used.
5091                                                  
5092                                                  This method applies only to the plugin specified for L<"--dest">, so if your
5093                                                  plugin isn't doing what you expect, check that you've specified it for the
5094                                                  destination and not the source.
5095                                                  
5096                                                  =item custom_sth_bulk(first_row => \@row, last_row => \@row, sql => $sql)
5097                                                  
5098                                                  If you've specified L<"--bulk-insert">, this method is called just before the
5099                                                  bulk insert, but after L<"before_bulk_insert()">, and the arguments are
5100                                                  different.
5101                                                  
5102                                                  This method's return value etc is similar to the L<"custom_sth()"> method.
5103                                                  
5104                                                  =item after_finish()
5105                                                  
5106                                                  This method is called after mk-archiver exits the archiving loop, commits all
5107                                                  database handles, closes L<"--file">, and prints the final statistics, but
5108                                                  before mk-archiver runs ANALYZE or OPTIMIZE (see L<"--analyze"> and
5109                                                  L<"--optimize">).
5110                                                  
5111                                                  =back
5112                                                  
5113                                                  If you specify a plugin for both L<"--source"> and L<"--dest">, mk-archiver
5114                                                  constructs, calls before_begin(), and calls after_finish() on the two plugins in
5115                                                  the order L<"--source">, L<"--dest">.
5116                                                  
5117                                                  mk-archiver assumes it controls transactions, and that the plugin will NOT
5118                                                  commit or roll back the database handle.  The database handle passed to the
5119                                                  plugin's constructor is the same handle mk-archiver uses itself.  Remember
5120                                                  that L<"--source"> and L<"--dest"> are separate handles.
5121                                                  
5122                                                  A sample module might look like this:
5123                                                  
5124                                                     package My::Module;
5125                                                  
5126                                                     sub new {
5127                                                        my ( $class, %args ) = @_;
5128                                                        return bless(\%args, $class);
5129                                                     }
5130                                                  
5131                                                     sub before_begin {
5132                                                        my ( $self, %args ) = @_;
5133                                                        # Save column names for later
5134                                                        $self->{cols} = $args{cols};
5135                                                     }
5136                                                  
5137                                                     sub is_archivable {
5138                                                        my ( $self, %args ) = @_;
5139                                                        # Do some advanced logic with $args{row}
5140                                                        return 1;
5141                                                     }
5142                                                  
5143                                                     sub before_delete {} # Take no action
5144                                                     sub before_insert {} # Take no action
5145                                                     sub custom_sth    {} # Take no action
5146                                                     sub after_finish  {} # Take no action
5147                                                  
5148                                                     1;
5149                                                  
5150                                                  =head1 DOWNLOADING
5151                                                  
5152                                                  You can download Maatkit from Google Code at
5153                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
5154                                                  easily with a command like the following:
5155                                                  
5156                                                     wget http://www.maatkit.org/get/toolname
5157                                                     or
5158                                                     wget http://www.maatkit.org/trunk/toolname
5159                                                  
5160                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
5161                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
5162                                                  needed.  The first URL gets the latest released version of the tool, and the
5163                                                  second gets the latest trunk code from Subversion.
5164                                                  
5165                                                  =head1 ENVIRONMENT
5166                                                  
5167                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
5168                                                  the Maatkit tools:
5169                                                  
5170                                                     MKDEBUG=1 mk-....
5171                                                  
5172                                                  =head1 SYSTEM REQUIREMENTS
5173                                                  
5174                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
5175                                                  installed in any reasonably new version of Perl.
5176                                                  
5177                                                  =head1 BUGS
5178                                                  
5179                                                  For a list of known bugs see L<http://www.maatkit.org/bugs/mk-archiver>.
5180                                                  
5181                                                  Please use Google Code Issues and Groups to report bugs or request support:
5182                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
5183                                                  discuss Maatkit.
5184                                                  
5185                                                  Please include the complete command-line used to reproduce the problem you are
5186                                                  seeing, the version of all MySQL servers involved, the complete output of the
5187                                                  tool when run with L<"--version">, and if possible, debugging output produced by
5188                                                  running with the C<MKDEBUG=1> environment variable.
5189                                                  
5190                                                  =head1 ACKNOWLEDGEMENTS
5191                                                  
5192                                                  Thanks to the following people, and apologies to anyone I've omitted:
5193                                                  
5194                                                  Andrew O'Brien,
5195                                                  
5196                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
5197                                                  
5198                                                  This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
5199                                                  Feedback and improvements are welcome.
5200                                                  
5201                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
5202                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
5203                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
5204                                                  
5205                                                  This program is free software; you can redistribute it and/or modify it under
5206                                                  the terms of the GNU General Public License as published by the Free Software
5207                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
5208                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
5209                                                  licenses.
5210                                                  
5211                                                  You should have received a copy of the GNU General Public License along with
5212                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
5213                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
5214                                                  
5215                                                  =head1 AUTHOR
5216                                                  
5217                                                  Baron Schwartz
5218                                                  
5219                                                  =head1 ABOUT MAATKIT
5220                                                  
5221                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
5222                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
5223                                                  code contributors.  Both are employed by Percona.  Financial support for
5224                                                  Maatkit development is primarily provided by Percona and its clients. 
5225                                                  
5226                                                  =head1 VERSION
5227                                                  
5228                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5805 $.
5229                                                  
5230                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
58    ***     50      0     18   unless $args{$arg}
64    ***     50      0     18   exists $args{'strict'} ? :
107   ***     50      0     18   unless open my $fh, '<', $file
127          100   9126     18   unless $para =~ /^=head1 OPTIONS/
132          100     18    144   if $para =~ /^=over/
140   ***     50      0     18   unless $para
143          100   1062     18   if (my($option) = $para =~ /^=item --(.*)/)
150          100    540    522   if ($para =~ /: /) { }
154   ***     50      0    792   unless $attributes{$attrib}
158          100    126    414   if ($attribs{'short form'})
174   ***     50      0   1062   if $para =~ /^=item/
176          100     36   1026   if (my($base_option) = $option =~ /^\[no\](.*)/)
181          100    126    936   $attribs{'short form'} ? :
             100     36   1026   $attribs{'negatable'} ? :
      ***     50      0   1062   $attribs{'cumulative'} ? :
             100    504    558   $attribs{'type'} ? :
             100    162    900   $attribs{'default'} ? :
      ***     50      0   1062   $attribs{'group'} ? :
193   ***     50      0   2952   unless $para
196          100     18   2934   if ($para =~ /^=head1/)
200          100   1062   1872   if $para =~ /^=item --/
204   ***     50      0     18   unless @specs
215          100   1062    144   if (ref $opt) { }
220   ***     50      0   1062   if (not $long)
225   ***     50      0   1062   if exists $$self{'opts'}{$long}
228   ***     50      0   1062   if (length $long == 1)
233          100    126    936   if ($short) { }
234   ***     50      0    126   if exists $$self{'short_opts'}{$short}
243          100     36   1026   $$opt{'spec'} =~ /!/ ? :
244   ***     50      0   1062   $$opt{'spec'} =~ /\+/ ? :
245          100     36   1026   $$opt{'desc'} =~ /required/ ? :
257   ***     50      0   1062   if ($type and $type eq 'd' and not $$self{'dp'})
262          100    126    936   if $type and $type =~ /[HhAadzm]/
264          100    162    900   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
265   ***     50    162      0   defined $def ? :
269          100     18   1044   if ($long eq 'config')
273          100     18   1044   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
286          100    108     36   if ($opt =~ /mutually exclusive|one and only one/)
291          100     18    126   if ($opt =~ /at least one|one and only one/)
296          100     18    126   if ($opt =~ /default to/)
301   ***     50      0    144   if ($opt =~ /restricted to option groups/)
311   ***     50      0    144   unless $rule_ok
328   ***     50      0    324   unless exists $$self{'opts'}{$long}
352   ***      0      0      0   unless exists $$self{'opts'}{$long}
372   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50     87      0   exists $$self{'opts'}{$opt} ? :
377   ***     50      0     87   if ($$opt{'is_cumulative'}) { }
392   ***     50      0    882   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100    180    882   exists $$self{'defaults'}{$long} ? :
401   ***     50      0     18   if (@ARGV and $ARGV[0] eq '--config')
405   ***     50     18      0   if ($self->has('config'))
411   ***     50     72      0   if ($EVAL_ERROR)
412   ***     50      0     72   $self->got('config') ? :
427   ***     50      0     18   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
430   ***     50      0     18   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
431   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
437   ***     50      0     18   if (@ARGV and $$self{'strict'})
443   ***     50      0    108   if (@set > 1)
454   ***     50      0     18   if (@set == 0)
464          100     87    975   if ($$opt{'got'}) { }
      ***     50      0    975   elsif ($$opt{'is_required'}) { }
465   ***     50      0     87   if (exists $$self{'disables'}{$long})
472   ***     50      0     87   if (exists $$self{'allowed_groups'}{$long})
484   ***      0      0      0   if $restricted_opt eq $long
485   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
490   ***      0      0      0   if (@restricted_opts)
492   ***      0      0      0   if (@restricted_opts == 1) { }
521          100    558    504   unless $opt and $$opt{'type'}
524          100     36    468   if ($val and $$opt{'type'} eq 'm') { }
             100     25    443   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0    443   elsif ($val and $$opt{'type'} eq 'z') { }
      ***     50      0    443   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100     19    424   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
527   ***     50      0     36   if (not $suffix)
533   ***     50     36      0   if ($suffix =~ /[smhd]/) { }
534   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***     50     36      0   $suffix eq 's' ? :
549          100      7     18   if ($from_key)
560   ***      0      0      0   if (defined $num) { }
561   ***      0      0      0   if ($factor)
588          100    150    907   length $opt == 1 ? :
589   ***     50      0   1057   unless $long and exists $$self{'opts'}{$long}
596   ***     50      0     90   length $opt == 1 ? :
597   ***     50      0     90   unless $long and exists $$self{'opts'}{$long}
604          100    325     18   length $opt == 1 ? :
605          100    168    175   defined $long ? :
610   ***      0      0      0   length $opt == 1 ? :
611   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
638   ***      0      0      0   unless $ENV{'DONT_BREAK_LINES'}
646   ***     50      0     18   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0     18   elsif (scalar @{$$self{'errors'};}) { }
647   ***      0      0      0   unless print $self->print_usage
651   ***      0      0      0   unless print $self->print_errors
660   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
669   ***      0      0      0   unless $$self{'got_opts'}
672   ***      0      0      0   $$_{'is_negatable'} ? :
676   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
692   ***      0      0      0   $group eq 'default' ? :
698   ***      0      0      0   $$opt{'is_negatable'} ? :
701   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
710   ***      0      0      0   if ($short) { }
719   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
723   ***      0      0      0   if ($$self{'dp'})
731   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
743   ***      0      0      0   if ref $_[0] eq 'OptionParser'
746   ***      0      0      0   unless print $prompt
754   ***      0      0      0   unless print "\n"
757   ***      0      0      0   if ($EVAL_ERROR)
779   ***     50     72      0   unless open my $fh, '<', $filename
787   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
790   ***      0      0      0   if ($line eq '--')
795   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
813   ***      0      0      0   unless open my $fh, '<', $file
817   ***      0      0      0   unless $para =~ /^=pod$/m
821   ***      0      0      0   unless $para =~ /$regex/
826   ***      0      0      0   unless close $fh
840   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
855   ***      0      0      0   defined $_ ? :
887   ***     50      0     18   unless $args{$arg}
896   ***     50      0     25   unless $ddl
897   ***     50     25      0   if (ref $ddl eq 'ARRAY')
898   ***     50     25      0   if (lc $$ddl[0] eq 'table') { }
908   ***     50      0     25   if (not $ddl =~ /CREATE (?:TEMPORARY )?TABLE `/)
914   ***     50     25      0   if $name
932   ***     50      0     94   unless $type
934          100     71     23   if ($type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/)
938          100     48     46   if (not $def =~ /NOT NULL/)
942          100      5     89   $def =~ /AUTO_INCREMENT/i ? :
973   ***     50      0     17   unless ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
987   ***     50      0     17   if ($index)
990   ***     50     17      0   if (not $best)
991   ***     50      0     17   if ($index) { }
1004  ***      0      0      0   unless $where
1010  ***      0      0      0   if ($$expl{'possible_keys'}) { }
1014  ***      0      0      0   if ($$expl{'key'})
1034  ***      0      0      0   unless $args{$arg}
1048  ***      0      0      0   if ($EVAL_ERROR)
1052  ***      0      0      0   if (not $$row[0] or $$row[0] ne $tbl)
1058  ***      0      0      0   unless $args{'all_privs'}
1065  ***      0      0      0   if ($EVAL_ERROR)
1069  ***      0      0      0   if (not scalar keys %$row)
1080  ***      0      0      0   $EVAL_ERROR ? :
1085  ***      0      0      0   if (not $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete)
1111  ***     50      0     41   if $key =~ /FOREIGN/
1116  ***     50     41      0   if (not $engine =~ /MEMORY|HEAP/)
1123  ***     50      0     41   if ($$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i)
1130         100     23     18   $key =~ /PRIMARY|UNIQUE/ ? :
1154         100     23     18   if ($engine =~ /InnoDB/i and not $clustered_key)
1156  ***     50     23      0   if ($$this_key{'name'} eq 'PRIMARY') { }
      ***      0      0      0   elsif ($$this_key{'is_unique'} and not $$this_key{'is_nullable'}) { }
1180  ***      0      0      0   if (not $parent =~ /\./ and $$opts{'database'})
1209  ***      0      0      0   if (($$tbl_struct{'engine'} || '') =~ /InnoDB/i) { }
1223  ***      0      0      0   if (@sec_indexes)
1240  ***      0      0      0   defined $_ ? :
1326         100     18    157   if (@_ > 2)
1335         100     25     44   if (not $dsn)
1347  ***     50    137      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1359         100     14    463   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1365         100    326    151   if (not defined $final_props{$key})
1372  ***     50      0    137   unless exists $opts{$key}
1375  ***     50      0     44   if (my $required = $self->prop('required'))
1377  ***      0      0      0   unless $final_props{$key}
1386  ***     50      0     25   unless ref $o eq 'OptionParser'
1389         100    150    175   if $o->has($_)
1399  ***     50      0      3   unless ref $dsn
1400  ***     50      0      9   $_ eq 'p' ? :
1401         100     21     30   if defined $$dsn{$_}
1414  ***      0      0      0   $opts{$key}{'copy'} ? :
1428  ***     50      0     44   if ($driver eq 'Pg') { }
1460  ***     50      0     44   $cxn_string =~ /charset=utf8/ ? :
1469  ***     50      0     44   if (not $have_dbi)
1488  ***     50     44      0   if ($cxn_string =~ /mysql/i)
1496  ***     50      0     44   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1501  ***      0      0      0   if ($charset eq 'utf8') { }
1502  ***      0      0      0   unless binmode STDOUT, ':utf8'
1506  ***      0      0      0   unless binmode STDOUT
1510         100     25     19   if ($self->prop('set-vars'))
1517  ***     50      0     44   if (not $dbh and $EVAL_ERROR)
1519  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1532  ***      0      0      0   if (not $tries)
1554  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1571  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1581  ***      0      0      0   unless $dsn_1
1582  ***      0      0      0   unless $dsn_2
1586  ***      0      0      0   if ($args{'overwrite'}) { }
1587  ***      0      0      0   defined $$dsn_1{$key} ? :
1590  ***      0      0      0   defined $$dsn_2{$key} ? :
1599  ***      0      0      0   defined $_ ? :
1637         100     25     17   if (not $$self{$dbh})
1641  ***     50     42      0   $$self{$dbh} ge $self->parse($target) ? :
1648  ***      0      0      0   defined $_ ? :
1688  ***      0      0      0   unless defined $val
1689  ***      0      0      0   if $val eq ''
1691  ***      0      0      0   if (not defined $is_numeric)
1692  ***      0      0      0   $val =~ /^0|\D/ ? :
1695  ***      0      0      0   if $is_numeric
1705  ***     50     25      0   if (not $tbl)
1714  ***      0      0      0   unless $like
1741  ***     50      0     34   unless $args{$arg}
1751  ***     50      0     34   unless defined $args{$arg}
1754  ***     50     17      0   $args{'cols'} ? :
1757  ***     50      0     17   unless exists $$tbl_struct{'keys'}{$index}
1766  ***     50      0     17   if ($args{'asc_first'})
1773  ***     50      0     17   if (not exists $col_posn{$col})
1789  ***     50     17      0   if (@asc_slice)
1801         100      2     15   $args{'asc_only'} ? :
1813  ***     50      0    272   unless defined $args{$arg}
1834  ***      0      0      0   if ($$is_nullable{$col}) { }
1850  ***     50      0     68   if ($$is_nullable{$col}) { }
1851  ***      0      0      0   if ($type =~ /=/ and $end) { }
      ***      0      0      0   elsif ($type =~ />/) { }
1866         100     34     34   $type =~ /=/ && $end ? :
1884  ***     50     17      0   $args{'cols'} ? :
1892  ***     50      0     17   unless $index
1894  ***     50     17      0   if ($index) { }
1904  ***     50      0     17   if (not exists $col_posn{$col})
1925  ***     50      0     17   if ($$tbl{'is_nullable'}{$col}) { }
1945  ***     50      0     12   unless $args{$arg}
1950  ***     50      0      6   unless @sel_cols
1955         100      3     21   unless $$ins_tbl{'is_col'}{$sel_cols[$i]}
1968  ***      0      0      0   defined $_ ? :
2018  ***     50     18      0   unless defined $args{'cache'}
2026  ***      0      0      0   if ($what eq 'table') { }
      ***      0      0      0   elsif ($what eq 'triggers') { }
      ***      0      0      0   elsif ($what eq 'view') { }
2028  ***      0      0      0   unless $ddl
2029  ***      0      0      0   if ($$ddl[0] eq 'table') { }
2043  ***      0      0      0   if ($trgs and @$trgs) { }
2046  ***      0      0      0   if ($$trg{'sql_mode'})
2050  ***      0      0      0   if ($$trg{'definer'})
2082  ***     50      0     50   if (not $new)
2089  ***     50     50      0   if ($curr and $new and $curr eq $new)
2101  ***     50     25      0   if (not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl})
2114  ***     50      0     25   if ($EVAL_ERROR)
2124  ***     50     25      0   if ($key) { }
2140  ***      0      0      0   if (not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl})
2170  ***      0      0      0   if (not $$self{'cache'} or not $$self{'triggers'}{$db})
2183  ***      0      0      0   if ($sth->rows)
2196  ***      0      0      0   if ($tbl)
2204  ***      0      0      0   if (not $$self{'cache'} or not $$self{'databases'} or $like)
2207  ***      0      0      0   if ($like)
2215  ***      0      0      0   unless $like
2223  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_status'}{$db} or $like)
2226  ***      0      0      0   if ($like)
2241  ***      0      0      0   unless $like
2249  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_list'}{$db} or $like)
2252  ***      0      0      0   if ($like)
2260  ***      0      0      0   ($$_[1] || '') eq 'VIEW' ? :
2267  ***      0      0      0   unless $like
2275  ***      0      0      0   defined $_ ? :
2304  ***      0      0      0   unless $args{$arg}
2307  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
2323  ***      0      0      0   unless defined(my $pid = fork)
2324  ***      0      0      0   if ($pid)
2331  ***      0      0      0   unless POSIX::setsid()
2332  ***      0      0      0   unless chdir '/'
2338  ***      0      0      0   if (-t STDIN)
2340  ***      0      0      0   unless open STDIN, '/dev/null'
2344  ***      0      0      0   if ($$self{'log_file'}) { }
2346  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
2350  ***      0      0      0   unless open STDERR, '>&STDOUT'
2354  ***      0      0      0   if (-t STDOUT)
2356  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
2359  ***      0      0      0   if (-t STDERR)
2361  ***      0      0      0   unless open STDERR, '>', '/dev/null'
2372  ***      0      0      0   $self ? :
2374  ***      0      0      0   if ($PID_file and -f $PID_file) { }
2377  ***      0      0      0   if $EVAL_ERROR
2379  ***      0      0      0   if ($pid) { }
2381  ***      0      0      0   if ($pid_is_alive) { }
2403  ***      0      0      0   if (exists $$self{'child'})
2415  ***      0      0      0   if (not $PID_file)
2422  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
2424  ***      0      0      0   unless print $PID_FH $PID
2426  ***      0      0      0   unless close $PID_FH
2435  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
2436  ***      0      0      0   unless unlink $$self{'PID_file'}
2448  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
2454  ***      0      0      0   defined $_ ? :
2498  ***      0      0      0   if ($EVAL_ERROR)
2499  ***      0      0      0   unless print STDERR 'Cannot connect to ', $dp->as_string($dsn), "\n"
2509  ***      0      0      0   if (not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++)
2514  ***      0      0      0   if ($$args{'skip_callback'})
2522  ***      0      0      0   if (not defined $$args{'recurse'} or $level < $$args{'recurse'})
2524  ***      0      0      0   unless not $$_{'master_id'}
2541  ***      0      0      0   if ($method) { }
2546  ***      0      0      0   if (($$dsn{'P'} || 3306) != 3306)
2560  ***      0      0      0   if @slaves
2578  ***      0      0      0   if ($host eq 'localhost')
2595  ***      0      0      0   if (@slaves)
2600  ***      0      0      0   $hash{'user'} ? :
      ***      0      0      0   $hash{'password'} ? :
2620  ***      0      0      0   if (not $proc)
2637  ***      0      0      0   unless my $master_status = $self->get_master_status($master)
2639  ***      0      0      0   unless my $slave_status = $self->get_slave_status($slave)
2641  ***      0      0      0   unless my(@connected) = $self->get_connected_slaves($master)
2645  ***      0      0      0   if ($port != $$slave_status{'master_port'})
2650  ***      0      0      0   if (not grep {$$slave_status{'master_user'} eq $$_{'user'};} @connected)
2655  ***      0      0      0   if (($$slave_status{'slave_io_state'} || '') eq 'Waiting for master to send event')
2662  ***      0      0      0   if ($master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1)
2675  ***      0      0      0   unless my $master = $self->get_slave_status($dbh)
2682  ***      0      0      0   if (not $$self{'not_a_slave'}{$dbh})
2689  ***      0      0      0   if ($ss and %$ss)
2701  ***      0      0      0   if (not $$self{'not_a_master'}{$dbh})
2708  ***      0      0      0   if ($ms and %$ms)
2710  ***      0      0      0   if ($$ms{'file'} and $$ms{'position'})
2723  ***      0      0      0   unless defined $time
2727  ***      0      0      0   if ($ms) { }
2731  ***      0      0      0   defined $result ? :
2733  ***      0      0      0   if ($stat eq 'NULL' or $stat < 0 and not $timeoutok)
2753  ***      0      0      0   if ($pos) { }
2777  ***      0      0      0   if ($self->pos_cmp($slave_pos, $master_pos) < 0)
2783  ***      0      0      0   if ($EVAL_ERROR)
2785  ***      0      0      0   if ($EVAL_ERROR =~ /MASTER_POS_WAIT returned NULL/) { }
2787  ***      0      0      0   if (not $self->slave_is_running($slave_status)) { }
2792  ***      0      0      0   if ($self->pos_cmp($slave_pos, $master_pos) != 0)
2816  ***      0      0      0   if ($self->pos_cmp($s1_pos, $s2_pos) < 0) { }
      ***      0      0      0   elsif ($self->pos_cmp($s2_pos, $s1_pos) < 0) { }
2828  ***      0      0      0   if ($self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0)
2851  ***      0      0      0   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
2855  ***      0      0      0   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
2860  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn))
2874  ***      0      0      0   if (not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0) { }
2889  ***      0      0      0   if ($self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0)
2900  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($sib_dsn))
2904  ***      0      0      0   unless my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
2908  ***      0      0      0   unless my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
2910  ***      0      0      0   if ($self->short_host($master_dsn1) ne $self->short_host($master_dsn2))
2913  ***      0      0      0   unless my $sib_master_stat = $self->get_master_status($sib_dbh)
2915  ***      0      0      0   unless $self->has_slave_updates($sib_dbh)
2927  ***      0      0      0   if ($self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
2939  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($unc_dsn))
2943  ***      0      0      0   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
2947  ***      0      0      0   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
2950  ***      0      0      0   unless my $unc_master_dsn = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
2953  ***      0      0      0   if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn))
2957  ***      0      0      0   unless my $unc_master_stat = $self->get_master_status($unc_dbh)
2959  ***      0      0      0   unless $self->has_slave_updates($unc_dbh)
2967  ***      0      0      0   if ($self->pos_cmp($self->repl_posn($slave_status), $self->repl_posn($master_status)) != 0)
2981  ***      0      0      0   if ($self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
2992  ***      0      0      0   unless my $stat = $self->get_slave_status($dbh)
3014  ***      0      0      0   if (exists $$status{'file'} and exists $$status{'position'}) { }
3042  ***      0      0      0   if ($$dsn{'master_host'}) { }
3050  ***      0      0      0   ($port || 3306) == 3306 ? :
3061  ***      0      0      0   defined $_ ? :
3161  ***     50      0     18   if ($o->get('stop'))
3162  ***      0      0      0   unless my $sentinel_fh = 'IO::File'->new($sentinel, '>>')
3164  ***      0      0      0   unless print $sentinel_fh "Remove this file to permit mk-archiver to run\n"
3166  ***      0      0      0   unless close $sentinel_fh
3168  ***      0      0      0   unless $quiet
3174  ***     50      0     18   if ($archive_file)
3176  ***      0      0      0   $src && $$src{'D'} ? :
      ***      0      0      0   $src && $$src{'t'} ? :
3189  ***     50     18      0   if (not $o->got('help'))
3190  ***     50      0     18   unless $$src{'t'}
3193         100      7     11   if ($dst)
3197         100      7     21   if (defined $$src{$arg} and defined $$dst{$arg} and $$src{$arg} ne $$dst{$arg})
3203  ***     50      0      7   if ($same)
3207  ***     50      0     18   if ($o->get('bulk-insert'))
3208  ***      0      0      0   unless $dst
3212  ***     50      0     18   if ($bulk_del and $limit < 2)
3218  ***     50      0     18   if ($bulk_del or $o->get('bulk-insert'))
3228  ***     50      0     18   if ($o->get('pid'))
3242         100      2     16   if ($o->get('statistics')) { }
3271  ***     50      0     25   if (not defined $$table{'p'} and $o->get('ask-pass'))
3279  ***     50      0     25   if ($$table{'a'})
3282  ***     50      0     25   if ($$table{'b'})
3300  ***     50      0     25   if ($$table{'m'})
3302  ***      0      0      0   if $EVAL_ERROR
3320  ***     50      0     18   if ($o->get('primary-key-only') and not exists $$src{'info'}{'keys'}{'PRIMARY'})
3323  ***      0      0      0   if $dst and $$dst{'dbh'}
3328         100      6     12   if ($dst and $o->get('check-columns'))
3332  ***     50      0      6   if (@not_in_src)
3334  ***      0      0      0   if $dst and $$dst{'dbh'}
3342         100      1      5   if (@not_in_dst)
3344  ***     50      1      0   if $dst and $$dst{'dbh'}
3356  ***     50      0     17   if ($o->get('check-slave-lag'))
3367  ***     50      0     17   if ($o->get('plugin'))
3369  ***      0      0      0   if $EVAL_ERROR
3390         100      1     15   $o->get('primary-key-only') ? :
             100      1     16   $o->get('columns') ? :
3401  ***     50     17      0   if (not $o->get('no-ascend')) { }
3402  ***      0      0      0   $o->get('bulk-delete') ? :
      ***     50      0     15   $$src{'m'} ? :
             100      2     15   $o->get('no-delete') ? :
3430         100      1     16   $o->get('high-priority-select') ? :
      ***     50     17      0   $vp->version_ge($dbh, '4.0.9') ? :
      ***     50     17      0   $$sel_stmt{'index'} ? :
3438  ***     50      0     17   if ($o->get('safe-auto-increment') and $$sel_stmt{'index'} and scalar @{$$src{'info'}{'keys'}{$$sel_stmt{'index'}}{'cols'};} == 1 and $$src{'info'}{'is_autoinc'}{$$src{'info'}{'keys'}{$$sel_stmt{'index'}}{'cols'}[0]})
3451  ***     50     17      0   if (not $o->get('no-ascend'))
3457         100      2     32   if ($o->get('for-update')) { }
             100      2     30   elsif ($o->get('share-lock')) { }
3465  ***     50     17      0   if (not $bulk_del) { }
3472         100      1     16   $o->get('low-priority-delete') ? :
             100      1     16   $o->get('quick-delete') ? :
3487  ***      0      0      0   $o->get('low-priority-delete') ? :
      ***      0      0      0   $o->get('quick-delete') ? :
3499         100      6     11   if ($dst) { }
3506  ***     50      0      6   if ($o->get('bulk-insert')) { }
3513  ***      0      0      0   $o->get('low-priority-insert') ? :
      ***      0      0      0   $o->get('replace') ? :
      ***      0      0      0   $o->get('ignore') ? :
3524         100      2      4   $o->get('replace') ? :
             100      1      5   $o->get('low-priority-insert') ? :
             100      1      5   $o->get('delayed-insert') ? :
      ***     50      0      6   $o->get('ignore') ? :
3538         100     12      5   if ($o->get('dry-run'))
3539  ***     50     12      0   if (not $quiet)
3540         100      1     11   $o->get('no-delete') ? :
3546         100      5      7   if $dst and $$dst{'dbh'}
3553         100      1      4   if $dst
3559  ***     50      0      5   if ($o->get('skip-foreign-key-checks'))
3561  ***      0      0      0   if ($dst)
3570  ***     50     10      0   unless $table and $$table{'plugin'}
3587  ***     50      0      5   if $o->get('progress') and not $quiet
3589  ***     50      0      5   if $o->get('progress') and not $quiet
3601         100      1      4   if (not $row)
3604  ***     50      0      1   if $dst and $$dst{'dbh'}
3609  ***     50      0      4   if ($archive_file)
3611  ***      0      0      0   unless $archive_fh = 'IO::File'->new($archive_file, '>>')
3613  ***      0      0      0   unless $o->get('buffer')
3614  ***      0      0      0   if ($need_hdr)
3615  ***      0      0      0   unless print $archive_fh '', escape(\@sel_cols), "\n"
3622  ***     50      0      4   if ($o->get('bulk-insert'))
3624  ***      0      0      0   unless $bulkins_file = 'File::Temp'->new('SUFFIX', 'mk-archiver')
3643  ***     50     16      0   if (not $$src{'plugin'} or trace('is_archivable', sub {
	$$src{'plugin'}->is_archivable('row', $row);
}
))
3653  ***     50      0     16   if ($archive_fh or $bulkins_file)
3656  ***     50      0     16   if ($archive_fh)
3658  ***      0      0      0   unless print $archive_fh $escaped_row, "\n"
3667         100      4     12   if ($dst and not $bulkins_file)
3669  ***     50      0      4   if ($$dst{'plugin'})
3684  ***     50      0      4   if ($success == $OUT_OF_RETRIES) { }
      ***     50      0      4   elsif ($success == $ROLLED_BACK) { }
3694  ***     50     16      0   if (not $bulk_del)
3696  ***     50      0     16   if ($$src{'plugin'})
3701         100     12      4   if (not $o->get('no-delete'))
3707  ***     50      0     12   if ($success == $OUT_OF_RETRIES) { }
      ***     50      0     12   elsif ($success == $ROLLED_BACK) { }
3721  ***     50      0     16   if ($bulkins_file)
3723  ***      0      0      0   unless print $bulkins_file $escaped_row, "\n"
3736  ***     50     16      0   unless $commit_each
3739  ***     50      0     16   if (not $quiet and $o->get('progress') and $cnt % $o->get('progress') == 0)
3752  ***     50     16      0   if ($$get_sth{'Active'})
3755  ***     50     16      0   if (not $row) { }
3761  ***     50      0     16   if ($bulkins_file)
3762  ***      0      0      0   unless $bulkins_file->close
3765  ***      0      0      0   if ($$dst{'plugin'})
3786  ***      0      0      0   if ($success != $ALL_IS_WELL)
3792  ***     50      0     16   if ($bulk_del)
3793  ***      0      0      0   if ($$src{'plugin'})
3801  ***      0      0      0   if (not $o->get('no-delete'))
3810  ***      0      0      0   if ($success != $ALL_IS_WELL)
3820  ***     50      0     16   if $commit_each
3833  ***     50     16      0   unless $txn_cnt
3835         100     12      4   $row ? :
3837  ***     50      0     16   if ($o->get('bulk-insert'))
3838  ***      0      0      0   unless $bulkins_file = 'File::Temp'->new('SUFFIX', 'mk-archiver')
3847  ***     50      0     16   if ($lag_dbh)
3857  ***     50      0     16   if (my $sleep_time = $o->get('sleep'))
3858  ***      0      0      0   if $o->get('sleep-coef')
3870  ***     50      0      4   if ($archive_file and $archive_fh)
3871  ***      0      0      0   unless close $archive_fh
3875  ***     50      0      4   if (not $quiet and $o->get('progress'))
3881  ***     50      8      0   unless $table and $$table{'plugin'}
3888         100      1      3   if ($oktorun and $o->get('analyze') || $o->get('optimize'))
3890  ***     50      0      1   $o->get('analyze') ? :
      ***     50      0      1   $o->get('local') ? :
3892  ***     50      1      0   if ($action =~ /s/i)
3897  ***     50      0      1   if ($action =~ /d/i and $dst)
3907  ***     50      0      4   if ($plugin)
3911         100      2      2   if (not $quiet and $o->get('statistics'))
3921         100      1      1   if $dst
3951         100      1      3   if ($o->get('why-quit'))
3952  ***     50      0      1   if ($retries < 0) { }
      ***     50      0      1   elsif ($o->get('run-time') and $now >= $end) { }
      ***     50      0      1   elsif (-f $sentinel) { }
      ***     50      1      0   elsif ($o->get('statistics')) { }
3967         100      1      3   if $dst and $$dst{'dbh'}
3987  ***     50     20      0   if ($force or $txnsize and $txn_cnt and $cnt % $txnsize == 0)
3988  ***     50      0     20   if ($o->get('buffer') and $archive_fh)
3991  ***      0      0      0   unless $archive_fh->flush
3994         100      5     15   if ($dst)
4021  ***     50      0     16   if ($EVAL_ERROR)
4022  ***      0      0      0   if ($EVAL_ERROR =~ /Lock wait timeout exceeded|Deadlock found/) { }
4023  ***      0      0      0   if ($txnsize && $txnsize > 1 || $o->get('commit-each') && $o->get('limit') > 1 and $txn_cnt and !$can_retry || $EVAL_ERROR =~ /Deadlock/) { }
4049  ***     50      0     16   if ($success != $ALL_IS_WELL)
4051  ***      0      0      0   if ($retries >= 0) { }
4082  ***      0      0      0   if defined $_
4084  ***      0      0      0   defined $_ ? :
4100  ***     50      0     25   unless $vp->version_ge($dbh, '5.0.13')
4104  ***     50      0     25   unless $rows
4110  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
257          100    558    468     36   $type and $type eq 'd'
      ***     66   1026     36      0   $type and $type eq 'd' and not $$self{'dp'}
262          100    558    378    126   $type and $type =~ /[HhAadzm]/
401   ***     33      0     18      0   @ARGV and $ARGV[0] eq '--config'
430   ***     33      0     18      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
437   ***     33     18      0      0   @ARGV and $$self{'strict'}
521   ***     66      0    558    504   $opt and $$opt{'type'}
524          100    315    153     36   $val and $$opt{'type'} eq 'm'
             100    315    128     25   $val and $$opt{'type'} eq 'd'
      ***     66    315    128      0   $val and $$opt{'type'} eq 'z'
      ***     66    315    128      0   defined $val and $$opt{'type'} eq 'h'
             100    315    109      1   defined $val and $$opt{'type'} eq 'a'
589   ***     33      0      0   1057   $long and exists $$self{'opts'}{$long}
597   ***     33      0      0     90   $long and exists $$self{'opts'}{$long}
611   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
701   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
795   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1085  ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete
1123  ***     33     41      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000'
      ***     33     41      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i
1154  ***     66      0     18     23   $engine =~ /InnoDB/i and not $clustered_key
1156  ***      0      0      0      0   $$this_key{'is_unique'} and not $$this_key{'is_nullable'}
1180  ***      0      0      0      0   not $parent =~ /\./ and $$opts{'database'}
1359         100    137    326     14   not defined $final_props{$key} and defined $$prev{$key}
      ***     66    463      0     14   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1481  ***     66     44      0     44   not $dbh and $tries--
1517  ***     33     44      0      0   not $dbh and $EVAL_ERROR
1851  ***      0      0      0      0   $type =~ /=/ and $end
1866  ***     66     34      0     34   $type =~ /=/ && $end
2043  ***      0      0      0      0   $trgs and @$trgs
2089  ***     33      0      0     50   $curr and $new
      ***     33      0      0     50   $curr and $new and $curr eq $new
2374  ***      0      0      0      0   $PID_file and -f $PID_file
2435  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
2509  ***      0      0      0      0   defined $master_thinks_i_am and $master_thinks_i_am != $id
2689  ***      0      0      0      0   $ss and %$ss
2708  ***      0      0      0      0   $ms and %$ms
2710  ***      0      0      0      0   $$ms{'file'} and $$ms{'position'}
2733  ***      0      0      0      0   $stat < 0 and not $timeoutok
2874  ***      0      0      0      0   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status)
      ***      0      0      0      0   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0
3009  ***      0      0      0      0   $value && $value =~ /^(1|ON)$/
3014  ***      0      0      0      0   exists $$status{'file'} and exists $$status{'position'}
3176  ***      0      0      0      0   $src && $$src{'D'}
      ***      0      0      0      0   $src && $$src{'t'}
3197  ***     66     14      0     14   defined $$src{$arg} and defined $$dst{$arg}
             100     14      7      7   defined $$src{$arg} and defined $$dst{$arg} and $$src{$arg} ne $$dst{$arg}
3212  ***     33     18      0      0   $bulk_del and $limit < 2
3270  ***     33     25      0      0   !$txnsize && !$commit_each
3271  ***     33      0     25      0   not defined $$table{'p'} and $o->get('ask-pass')
3289  ***     33      0      0     25   $can_retry && !$$table{'irot'}
3320  ***     66     17      1      0   $o->get('primary-key-only') and not exists $$src{'info'}{'keys'}{'PRIMARY'}
3323  ***      0      0      0      0   $dst and $$dst{'dbh'}
3328         100     11      1      6   $dst and $o->get('check-columns')
3334  ***      0      0      0      0   $dst and $$dst{'dbh'}
3344  ***     33      0      0      1   $dst and $$dst{'dbh'}
3438  ***     33      0      0     17   $o->get('safe-auto-increment') and $$sel_stmt{'index'}
      ***     33      0      0     17   $o->get('safe-auto-increment') and $$sel_stmt{'index'} and scalar @{$$src{'info'}{'keys'}{$$sel_stmt{'index'}}{'cols'};} == 1
      ***     33      0     17      0   $o->get('safe-auto-increment') and $$sel_stmt{'index'} and scalar @{$$src{'info'}{'keys'}{$$sel_stmt{'index'}}{'cols'};} == 1 and $$src{'info'}{'is_autoinc'}{$$src{'info'}{'keys'}{$$sel_stmt{'index'}}{'cols'}[0]}
3546  ***     66      7      0      5   $dst and $$dst{'dbh'}
3570  ***     66      4      6      0   $table and $$table{'plugin'}
3587  ***     33      5      0      0   $o->get('progress') and not $quiet
3589  ***     33      5      0      0   $o->get('progress') and not $quiet
3604  ***     33      1      0      0   $dst and $$dst{'dbh'}
3610  ***      0      0      0      0   $o->get('header') && !-f($archive_file)
3633  ***     66      4      0     16   $row and $retries >= 0
      ***     66      4      0     16   $row and $retries >= 0 and !$o->get('run-time') || $now < $end
      ***     66      4      0     16   $row and $retries >= 0 and !$o->get('run-time') || $now < $end and not -f $sentinel
      ***     66      4      0     16   $row and $retries >= 0 and !$o->get('run-time') || $now < $end and not -f $sentinel and $oktorun
3667  ***     66     12      0      4   $dst and not $bulkins_file
3739  ***     33      0     16      0   not $quiet and $o->get('progress')
      ***     33     16      0      0   not $quiet and $o->get('progress') and $cnt % $o->get('progress') == 0
3870  ***     33      4      0      0   $archive_file and $archive_fh
3875  ***     33      0      4      0   not $quiet and $o->get('progress')
3881  ***     66      3      5      0   $table and $$table{'plugin'}
3888  ***     66      0      3      1   $oktorun and $o->get('analyze') || $o->get('optimize')
3897  ***     33      0      1      0   $action =~ /d/i and $dst
3911  ***     66      0      2      2   not $quiet and $o->get('statistics')
3952  ***     33      1      0      0   $o->get('run-time') and $now >= $end
3967  ***     66      3      0      1   $dst and $$dst{'dbh'}
3987  ***     33      0      0     16   $txnsize and $txn_cnt
      ***     33      0      0     16   $txnsize and $txn_cnt and $cnt % $txnsize == 0
3988  ***     33     20      0      0   $o->get('buffer') and $archive_fh
4016  ***     66     16      0     16   not $success and $retries >= 0
4023  ***      0      0      0      0   $txnsize && $txnsize > 1
      ***      0      0      0      0   $o->get('commit-each') && $o->get('limit') > 1
      ***      0      0      0      0   $txnsize && $txnsize > 1 || $o->get('commit-each') && $o->get('limit') > 1 and $txn_cnt
      ***      0      0      0      0   $txnsize && $txnsize > 1 || $o->get('commit-each') && $o->get('limit') > 1 and $txn_cnt and !$can_retry || $EVAL_ERROR =~ /Deadlock/
4105  ***     33      0     25      0   @$rows && $$rows[0]{'Value'} ne 'OFF'

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
42    ***     50      0     17   $ENV{'MKDEBUG'} || 0
61    ***     33     18      0   0
62    ***     50     18      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
64    ***     50     18      0   $args{'prompt'} || '<options>'
      ***     50     18      0   $args{'dp'} || undef
106   ***     50      0     18   $file ||= '/home/daniel/dev/maatkit/mk-archiver/mk-archiver'
247   ***     50   1062      0   $$opt{'group'} ||= 'default'
529   ***      0      0      0   $s || 's'
538   ***     50      0     36   $prefix || ''
566   ***      0      0      0   $pre || ''
573   ***      0      0      0   $val || ''
576   ***     50     19      0   $val || ''
634   ***      0      0      0   $$self{'description'} || ''
703   ***      0      0      0   $s ||= 's'
729   ***      0      0      0   $$opt{'type'} || ''
880   ***     50      0     17   $ENV{'MKDEBUG'} || 0
1099  ***     50     50      0   $engine || undef
1122  ***     50      0     41   $type || $special || 'BTREE'
1209  ***      0      0      0   $$tbl_struct{'engine'} || ''
1211  ***      0      0      0   $clustered_key ||= ''
1269  ***     50      0     17   $ENV{'MKDEBUG'} || 0
1340         100     25     19   $prev ||= {}
1341  ***     50      0     44   $defaults ||= {}
1414  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1427  ***     50      0     44   $self->prop('dbidriver') || ''
1431  ***      0      0      0   $$info{'D'} || ''
1437         100     25     19   $$info{'D'} || ''
1459  ***     50     44      0   $opts ||= {}
1554  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1570  ***      0      0      0   $level ||= 0
1571  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1621  ***     50      0     17   $ENV{'MKDEBUG'} || 0
1670  ***     50      0     17   $ENV{'MKDEBUG'} || 0
1735  ***     50      0     17   $ENV{'MKDEBUG'} || 0
1990  ***     50      0     17   $ENV{'MKDEBUG'} || 0
2260  ***      0      0      0   $$_[1] || ''
2299  ***     50      0     17   $ENV{'MKDEBUG'} || 0
2480  ***     50      0     17   $ENV{'MKDEBUG'} || 0
2488  ***      0      0      0   $level ||= 0
2546  ***      0      0      0   $$dsn{'P'} || 3306
2655  ***      0      0      0   $$slave_status{'slave_io_state'} || ''
3001  ***      0      0      0   $$slave_status{'slave_sql_running'} || 'No'
3050  ***      0      0      0   $host || '[default]'
      ***      0      0      0   $port || 3306
3092  ***     50      0     17   $ENV{'MKDEBUG'} || 0
3247  ***     66     35      2   0
3253  ***     66     35      2   0
3540  ***     50      0     12   $archive_file || ''
3583  ***     50      0      5   $o->get('run-time') || 0
3678  ***     33      0      4   0
3922         100      5      1   $statistics{$_} || 0
3932         100      9      5   $summary{$action}{'time'} ||= 0
3933         100     12      2   $summary{$action}{'count'} ||= 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
62    ***     33     18      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***     33     18      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
524   ***     33      0      0    443   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
             100     18      1    424   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
973   ***     33     17      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'}
      ***     33     17      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
1052  ***      0      0      0      0   not $$row[0] or $$row[0] ne $tbl
1073  ***      0      0      0      0   $$row{'privileges'} || $$row{'Privileges'}
1122  ***     33      0      0     41   $type || $special
1450  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1451  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1452  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1453  ***      0      0      0      0   $$dsn{'u'} ||= $user
1454  ***      0      0      0      0   $$dsn{'D'} ||= $db
2101  ***     33      0     25      0   not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl}
2140  ***      0      0      0      0   not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl}
2170  ***      0      0      0      0   not $$self{'cache'} or not $$self{'triggers'}{$db}
2204  ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'} or $like
2223  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db} or $like
2237  ***      0      0      0      0   $tbl{'type'} || $tbl{'comment'}
      ***      0      0      0      0   $tbl{'engine'} ||= $tbl{'type'} || $tbl{'comment'}
2249  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db} or $like
2448  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
2494  ***      0      0      0      0   $$args{'dbh'} || $dp->get_dbh($dp->get_cxn_params($dsn), {'AutoCommit', 1})
2509  ***      0      0      0      0   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id
      ***      0      0      0      0   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++
2522  ***      0      0      0      0   not defined $$args{'recurse'} or $level < $$args{'recurse'}
2662  ***      0      0      0      0   $master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1
2683  ***      0      0      0      0   $$self{'sths'}{$dbh}{'SLAVE_STATUS'} ||= $dbh->prepare('SHOW SLAVE STATUS')
2702  ***      0      0      0      0   $$self{'sths'}{$dbh}{'MASTER_STATUS'} ||= $dbh->prepare('SHOW MASTER STATUS')
2726  ***      0      0      0      0   $ms ||= $self->get_master_status($master)
2733  ***      0      0      0      0   $stat eq 'NULL' or $stat < 0 and not $timeoutok
2745  ***      0      0      0      0   $$self{'sths'}{$dbh}{'STOP_SLAVE'} ||= $dbh->prepare('STOP SLAVE')
2760  ***      0      0      0      0   $$self{'sths'}{$dbh}{'START_SLAVE'} ||= $dbh->prepare('START SLAVE')
2828  ***      0      0      0      0   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status)
      ***      0      0      0      0   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0
2889  ***      0      0      0      0   $self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0
2927  ***      0      0      0      0   $self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0
2981  ***      0      0      0      0   $self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0
3218  ***     33      0      0     18   $bulk_del or $o->get('bulk-insert')
3633  ***     33     16      0      0   !$o->get('run-time') || $now < $end
3643  ***     33     16      0      0   not $$src{'plugin'} or trace('is_archivable', sub {
	$$src{'plugin'}->is_archivable('row', $row);
}
)
3653  ***     33      0      0     16   $archive_fh or $bulkins_file
3780  ***      0      0      0      0   $ins_sth ||= $ins_row
3849  ***      0      0      0      0   not defined $lag or $lag > $o->get('max-lag')
3869  ***     33      4      0      0   $txnsize || $commit_each
3888  ***     66      0      1      3   $o->get('analyze') || $o->get('optimize')
3889  ***     33      0      1      0   $o->get('analyze') || $o->get('optimize')
3987  ***     66      4     16      0   $force or $txnsize and $txn_cnt and $cnt % $txnsize == 0
4023  ***      0      0      0      0   $txnsize && $txnsize > 1 || $o->get('commit-each') && $o->get('limit') > 1
      ***      0      0      0      0   !$can_retry || $EVAL_ERROR =~ /Deadlock/


Covered Subroutines
-------------------

Subroutine                  Count Location                                             
--------------------------- ----- -----------------------------------------------------
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1257
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1258
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1259
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1260
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1269
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1616
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1617
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1619
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1621
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1663
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1664
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1668
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1670
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1730
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1731
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1733
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1735
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1985
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1986
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1988
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1990
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2293
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2294
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2296
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2297
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2299
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:23  
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:24  
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2469
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2470
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2474
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2475
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2476
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2480
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3083
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3084
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3085
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3086
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3087
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3088
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3092
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:35  
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:36  
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:38  
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:39  
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:40  
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:42  
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:872 
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:873 
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:874 
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:875 
BEGIN                          17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:880 
__ANON__                       37 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3247
__ANON__                       26 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3258
__ANON__                        5 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3594
__ANON__                        4 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3680
__ANON__                       12 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3703
__ANON__                       16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3825
__ANON__                        1 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3894
__ANON__                        5 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3996
__ANON__                       20 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:4000
__ANON__                       87 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:425 
_get_participants             162 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:325 
_parse_specs                   18 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:211 
_pod_to_specs                  18 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:105 
_read_config_file              72 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:778 
_set_option                    87 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:371 
_use_db                        50 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2081
_validate_type               1062 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:520 
as_string                       3 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1398
commit                         20 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3985
do_with_retries                16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:4010
find_best_index                17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:985 
generate_asc_stmt              17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1748
generate_cmp_where             68 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1811
generate_del_stmt              17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1881
generate_ins_stmt               6 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1943
get                          1057 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:587 
get_create_table               25 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2100
get_cxn_params                 44 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1424
get_dbh                        44 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1458
get_defaults_files             18 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:100 
get_engine                     50 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1096
get_irot                       25 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:4099
get_keys                       25 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1103
get_opts                       18 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:388 
get_specs                      18 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:93  
got                            90 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:595 
has                           343 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:603 
main                           18 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3119
new                            34 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1272
new                            17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1624
new                            17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1673
new                            17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1738
new                            18 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2017
new                            18 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:56  
new                            18 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:884 
parse                          69 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1334
parse                          67 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1629
parse                          25 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:895 
parse_options                  25 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1385
prop                          175 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1325
quote                         219 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1678
sort_indexes                   17 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:966 
split_unquote                  25 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1702
ts                              4 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:4089
usage_or_errors                18 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:645 
version_ge                     42 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1636

Uncovered Subroutines
---------------------

Subroutine                  Count Location                                             
--------------------------- ----- -----------------------------------------------------
DESTROY                         0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2447
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3305
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3572
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3645
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3658
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3671
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3674
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3698
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3723
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3767
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3773
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3782
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3795
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3805
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3862
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3883
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3899
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3991
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:4062
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:4065
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:4069
_d                              0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1239
_d                              0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1598
_d                              0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1647
_d                              0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1967
_d                              0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2274
_d                              0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2453
_d                              0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3060
_d                              0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:4109
_d                              0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:854 
_find_slaves_by_hosts           0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2588
_find_slaves_by_processlist     0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2568
_make_PID_file                  0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2412
_remove_PID_file                0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2434
catchup_to_master               0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2768
catchup_to_same_pos             0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2809
change_master_to                0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2838
check_PID_file                  0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2371
check_table                     0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1031
clone                           0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:831 
copy                            0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1580
daemonize                       0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2320
descr                           0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:633 
detach_slave                    0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2990
disconnect                      0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1563
dump                            0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2024
errors                          0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:623 
escape                          0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:4081
fill_in_dsn                     0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1446
find_possible_keys              0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1003
find_slave_hosts                0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2538
finish                          0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3978
get_columns                     0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2138
get_connected_slaves            0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2615
get_databases                   0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2203
get_defaults                    0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:361 
get_fks                         0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1170
get_groups                      0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:366 
get_hostname                    0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1553
get_master_dsn                  0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2674
get_master_status               0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2700
get_slave_lag                   0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3029
get_slave_status                0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2681
get_table_list                  0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2248
get_table_status                0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2222
get_tmp_table                   0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2158
get_triggers                    0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2169
has_slave_updates               0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3005
is_master_of                    0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2636
literal_like                    0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1713
make_PID_file                   0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2402
make_sibling_of_master          0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2849
make_slave_of_sibling           0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2897
make_slave_of_uncle             0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2936
new                             0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2302
new                             0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2483
opts                            0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:337 
pos_cmp                         0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3035
pos_to_string                   0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3054
print_active_handles            0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1569
print_errors                    0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:658 
print_usage                     0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:668 
prompt                          0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:628 
prompt_noecho                   0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:743 
quote_val                       0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1686
read_para_after                 0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:812 
recurse_to_slaves               0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2487
remove_auto_increment           0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1199
remove_secondary_indexes        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1205
repl_posn                       0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3013
save_error                      0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:618 
set                             0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:609 
set_defaults                    0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:349 
short_host                      0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3040
short_opts                      0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:343 
slave_is_running                0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3000
start_slave                     0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2752
stop_slave                      0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2744
usage                           0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1407
wait_for_master                 0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2721


