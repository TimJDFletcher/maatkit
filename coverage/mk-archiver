---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...t/mk-archiver/mk-archiver   10.1    1.5    3.9   28.4    n/a  100.0    8.1
Total                          10.1    1.5    3.9   28.4    n/a  100.0    8.1
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:17:28 2010
Finish:       Thu Jan 28 22:17:28 2010

Run:          ./101_basics.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:17:30 2010
Finish:       Thu Jan 28 22:17:47 2010

Run:          ./102_dest.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:17:51 2010
Finish:       Thu Jan 28 22:18:07 2010

Run:          ./103_file.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:18:10 2010
Finish:       Thu Jan 28 22:18:12 2010

Run:          ./104_purge.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:18:16 2010
Finish:       Thu Jan 28 22:18:19 2010

Run:          ./105_plugin.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:18:22 2010
Finish:       Thu Jan 28 22:18:57 2010

Run:          ./106_gt_n.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:19:00 2010
Finish:       Thu Jan 28 22:19:01 2010

Run:          ./107_res_fk.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:19:04 2010
Finish:       Thu Jan 28 22:19:09 2010

Run:          ./108_check_slave_lag.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:19:12 2010
Finish:       Thu Jan 28 22:19:17 2010

Run:          ./109_standard_options.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:19:20 2010
Finish:       Thu Jan 28 22:19:24 2010

Run:          ./110_bulk_delete.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:19:28 2010
Finish:       Thu Jan 28 22:19:52 2010

Run:          ./111_bulk_insert.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:19:56 2010
Finish:       Thu Jan 28 22:19:58 2010

Run:          ./112_indexes.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:20:02 2010
Finish:       Thu Jan 28 22:20:57 2010

Run:          ./113_safe_auto_increment.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:21:00 2010
Finish:       Thu Jan 28 22:21:01 2010

Run:          ./201_issue_655.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:21:04 2010
Finish:       Thu Jan 28 22:21:04 2010

Run:          ./202_issue_131.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:21:07 2010
Finish:       Thu Jan 28 22:21:08 2010

Run:          ./203_issue_524.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:21:11 2010
Finish:       Thu Jan 28 22:21:11 2010

/home/daniel/dev/maatkit/mk-archiver/mk-archiver

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This is mk-archiver, a program to archive records from one MySQL table to
4                                                     # a file and/or another table.
5                                                     #
6                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
7                                                     # Feedback and improvements are welcome.
8                                                     #
9                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
10                                                    # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
11                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
12                                                    #
13                                                    # This program is free software; you can redistribute it and/or modify it under
14                                                    # the terms of the GNU General Public License as published by the Free Software
15                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
16                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
17                                                    # licenses.
18                                                    #
19                                                    # You should have received a copy of the GNU General Public License along with
20                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
21                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
22                                                    
23            16                   16            91   use strict;
              16                                 42   
              16                                117   
24            16                   16           189   use warnings FATAL => 'all';
              16                                 37   
              16                                112   
25                                                    
26                                                    our $VERSION = '@VERSION@';
27                                                    our $DISTRIB = '@DISTRIB@';
28                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5425 $ =~ m/(\d+)/g, 0));
29                                                    
30                                                    # ###########################################################################
31                                                    # OptionParser package 5266
32                                                    # ###########################################################################
33                                                    package OptionParser;
34                                                    
35            16                   16           108   use strict;
              16                                 42   
              16                                 77   
36            16                   16            97   use warnings FATAL => 'all';
              16                                 38   
              16                                 79   
37                                                    
38            16                   16           155   use Getopt::Long;
              16                                 58   
              16                                111   
39            16                   16           115   use List::Util qw(max);
              16                                 44   
              16                                182   
40            16                   16           106   use English qw(-no_match_vars);
              16                                 41   
              16                                110   
41                                                    
42    ***     16            50     16           128   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              16                                 40   
              16                                267   
43                                                    
44                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
45                                                    
46                                                    my %attributes = (
47                                                       'type'       => 1,
48                                                       'short form' => 1,
49                                                       'group'      => 1,
50                                                       'default'    => 1,
51                                                       'cumulative' => 1,
52                                                       'negatable'  => 1,
53                                                    );
54                                                    
55                                                    sub new {
56    ***      0                    0             0      my ( $class, %args ) = @_;
57    ***      0                                  0      foreach my $arg ( qw(description) ) {
58    ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
59                                                       }
60    ***      0                                  0      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
61    ***      0             0                    0      $program_name ||= $PROGRAM_NAME;
62    ***      0             0                    0      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                    0                        
      ***                    0                        
63                                                    
64    ***      0      0      0                    0      my $self = {
      ***                    0                        
65                                                          description    => $args{description},
66                                                          prompt         => $args{prompt} || '<options>',
67                                                          strict         => (exists $args{strict} ? $args{strict} : 1),
68                                                          dp             => $args{dp}     || undef,
69                                                          program_name   => $program_name,
70                                                          opts           => {},
71                                                          got_opts       => 0,
72                                                          short_opts     => {},
73                                                          defaults       => {},
74                                                          groups         => {},
75                                                          allowed_groups => {},
76                                                          errors         => [],
77                                                          rules          => [],  # desc of rules for --help
78                                                          mutex          => [],  # rule: opts are mutually exclusive
79                                                          atleast1       => [],  # rule: at least one opt is required
80                                                          disables       => {},  # rule: opt disables other opts 
81                                                          defaults_to    => {},  # rule: opt defaults to value of other opt
82                                                          default_files  => [
83                                                             "/etc/maatkit/maatkit.conf",
84                                                             "/etc/maatkit/$program_name.conf",
85                                                             "$home/.maatkit.conf",
86                                                             "$home/.$program_name.conf",
87                                                          ],
88                                                       };
89    ***      0                                  0      return bless $self, $class;
90                                                    }
91                                                    
92                                                    sub get_specs {
93    ***      0                    0             0      my ( $self, $file ) = @_;
94    ***      0                                  0      my @specs = $self->_pod_to_specs($file);
95    ***      0                                  0      $self->_parse_specs(@specs);
96    ***      0                                  0      return;
97                                                    }
98                                                    
99                                                    sub get_defaults_files {
100   ***      0                    0             0      my ( $self ) = @_;
101   ***      0                                  0      return @{$self->{default_files}};
      ***      0                                  0   
102                                                   }
103                                                   
104                                                   sub _pod_to_specs {
105   ***      0                    0             0      my ( $self, $file ) = @_;
106   ***      0             0                    0      $file ||= __FILE__;
107   ***      0      0                           0      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
108                                                   
109   ***      0                                  0      my %types = (
110                                                         string => 's', # standard Getopt type
111                                                         'int'  => 'i', # standard Getopt type
112                                                         float  => 'f', # standard Getopt type
113                                                         Hash   => 'H', # hash, formed from a comma-separated list
114                                                         hash   => 'h', # hash as above, but only if a value is given
115                                                         Array  => 'A', # array, similar to Hash
116                                                         array  => 'a', # array, similar to hash
117                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
118                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
119                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
120                                                      );
121   ***      0                                  0      my @specs = ();
122   ***      0                                  0      my @rules = ();
123   ***      0                                  0      my $para;
124                                                   
125   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
126   ***      0                                  0      while ( $para = <$fh> ) {
127   ***      0      0                           0         next unless $para =~ m/^=head1 OPTIONS/;
128   ***      0                                  0         last;
129                                                      }
130                                                   
131   ***      0                                  0      while ( $para = <$fh> ) {
132   ***      0      0                           0         last if $para =~ m/^=over/;
133   ***      0                                  0         chomp $para;
134   ***      0                                  0         $para =~ s/\s+/ /g;
135   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
136   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
137   ***      0                                  0         push @rules, $para;
138                                                      }
139                                                   
140   ***      0      0                           0      die 'POD has no OPTIONS section' unless $para;
141                                                   
142   ***      0                                  0      do {
143   ***      0      0                           0         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
144   ***      0                                  0            chomp $para;
145   ***      0                                  0            MKDEBUG && _d($para);
146   ***      0                                  0            my %attribs;
147                                                   
148   ***      0                                  0            $para = <$fh>; # read next paragraph, possibly attributes
149                                                   
150   ***      0      0                           0            if ( $para =~ m/: / ) { # attributes
151   ***      0                                  0               $para =~ s/\s+\Z//g;
152   ***      0                                  0               %attribs = map {
153   ***      0                                  0                     my ( $attrib, $val) = split(/: /, $_);
154   ***      0      0                           0                     die "Unrecognized attribute for --$option: $attrib"
155                                                                        unless $attributes{$attrib};
156   ***      0                                  0                     ($attrib, $val);
157                                                                  } split(/; /, $para);
158   ***      0      0                           0               if ( $attribs{'short form'} ) {
159   ***      0                                  0                  $attribs{'short form'} =~ s/-//;
160                                                               }
161   ***      0                                  0               $para = <$fh>; # read next paragraph, probably short help desc
162                                                            }
163                                                            else {
164   ***      0                                  0               MKDEBUG && _d('Option has no attributes');
165                                                            }
166                                                   
167   ***      0                                  0            $para =~ s/\s+\Z//g;
168   ***      0                                  0            $para =~ s/\s+/ /g;
169   ***      0                                  0            $para =~ s/$POD_link_re/$1/go;
170                                                   
171   ***      0                                  0            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
172   ***      0                                  0            MKDEBUG && _d('Short help:', $para);
173                                                   
174   ***      0      0                           0            die "No description after option spec $option" if $para =~ m/^=item/;
175                                                   
176   ***      0      0                           0            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
177   ***      0                                  0               $option = $base_option;
178   ***      0                                  0               $attribs{'negatable'} = 1;
179                                                            }
180                                                   
181   ***      0      0                           0            push @specs, {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
182                                                               spec  => $option
183                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
184                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
185                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
186                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
187                                                               desc  => $para
188                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
189                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
190                                                            };
191                                                         }
192   ***      0                                  0         while ( $para = <$fh> ) {
193   ***      0      0                           0            last unless $para;
194                                                   
195                                                   
196   ***      0      0                           0            if ( $para =~ m/^=head1/ ) {
197   ***      0                                  0               $para = undef; # Can't 'last' out of a do {} block.
198   ***      0                                  0               last;
199                                                            }
200   ***      0      0                           0            last if $para =~ m/^=item --/;
201                                                         }
202                                                      } while ( $para );
203                                                   
204   ***      0      0                           0      die 'No valid specs in POD OPTIONS' unless @specs;
205                                                   
206   ***      0                                  0      close $fh;
207   ***      0                                  0      return @specs, @rules;
208                                                   }
209                                                   
210                                                   sub _parse_specs {
211   ***      0                    0             0      my ( $self, @specs ) = @_;
212   ***      0                                  0      my %disables; # special rule that requires deferred checking
213                                                   
214   ***      0                                  0      foreach my $opt ( @specs ) {
215   ***      0      0                           0         if ( ref $opt ) { # It's an option spec, not a rule.
216                                                            MKDEBUG && _d('Parsing opt spec:',
217   ***      0                                  0               map { ($_, '=>', $opt->{$_}) } keys %$opt);
218                                                   
219   ***      0                                  0            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
220   ***      0      0                           0            if ( !$long ) {
221   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
222                                                            }
223   ***      0                                  0            $opt->{long} = $long;
224                                                   
225   ***      0      0                           0            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
226   ***      0                                  0            $self->{opts}->{$long} = $opt;
227                                                   
228   ***      0      0                           0            if ( length $long == 1 ) {
229   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
230   ***      0                                  0               $self->{short_opts}->{$long} = $long;
231                                                            }
232                                                   
233   ***      0      0                           0            if ( $short ) {
234   ***      0      0                           0               die "Duplicate short option -$short"
235                                                                  if exists $self->{short_opts}->{$short};
236   ***      0                                  0               $self->{short_opts}->{$short} = $long;
237   ***      0                                  0               $opt->{short} = $short;
238                                                            }
239                                                            else {
240   ***      0                                  0               $opt->{short} = undef;
241                                                            }
242                                                   
243   ***      0      0                           0            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
244   ***      0      0                           0            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
245   ***      0      0                           0            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
246                                                   
247   ***      0             0                    0            $opt->{group} ||= 'default';
248   ***      0                                  0            $self->{groups}->{ $opt->{group} }->{$long} = 1;
249                                                   
250   ***      0                                  0            $opt->{value} = undef;
251   ***      0                                  0            $opt->{got}   = 0;
252                                                   
253   ***      0                                  0            my ( $type ) = $opt->{spec} =~ m/=(.)/;
254   ***      0                                  0            $opt->{type} = $type;
255   ***      0                                  0            MKDEBUG && _d($long, 'type:', $type);
256                                                   
257   ***      0      0      0                    0            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                    0                        
258   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
259                                                                  . "was given when this OptionParser object was created";
260                                                            }
261                                                   
262   ***      0      0      0                    0            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
263                                                   
264   ***      0      0                           0            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
265   ***      0      0                           0               $self->{defaults}->{$long} = defined $def ? $def : 1;
266   ***      0                                  0               MKDEBUG && _d($long, 'default:', $def);
267                                                            }
268                                                   
269   ***      0      0                           0            if ( $long eq 'config' ) {
270   ***      0                                  0               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
271                                                            }
272                                                   
273   ***      0      0                           0            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
274   ***      0                                  0               $disables{$long} = $dis;
275   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
276                                                            }
277                                                   
278   ***      0                                  0            $self->{opts}->{$long} = $opt;
279                                                         }
280                                                         else { # It's an option rule, not a spec.
281   ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
282   ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
283   ***      0                                  0            my @participants = $self->_get_participants($opt);
284   ***      0                                  0            my $rule_ok = 0;
285                                                   
286   ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
287   ***      0                                  0               $rule_ok = 1;
288   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
289   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
290                                                            }
291   ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
292   ***      0                                  0               $rule_ok = 1;
293   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
294   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
295                                                            }
296   ***      0      0                           0            if ( $opt =~ m/default to/ ) {
297   ***      0                                  0               $rule_ok = 1;
298   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
299   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
300                                                            }
301   ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
302   ***      0                                  0               $rule_ok = 1;
303   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
304   ***      0                                  0               my @groups = split(',', $groups);
305   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
306   ***      0                                  0                  s/\s+//;
307   ***      0                                  0                  $_ => 1;
308                                                               } @groups;
309                                                            }
310                                                   
311   ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
312                                                         }
313                                                      }
314                                                   
315   ***      0                                  0      foreach my $long ( keys %disables ) {
316   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
317   ***      0                                  0         $self->{disables}->{$long} = \@participants;
318   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
319                                                      }
320                                                   
321   ***      0                                  0      return; 
322                                                   }
323                                                   
324                                                   sub _get_participants {
325   ***      0                    0             0      my ( $self, $str ) = @_;
326   ***      0                                  0      my @participants;
327   ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
328   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
329                                                            unless exists $self->{opts}->{$long};
330   ***      0                                  0         push @participants, $long;
331                                                      }
332   ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
333   ***      0                                  0      return @participants;
334                                                   }
335                                                   
336                                                   sub opts {
337   ***      0                    0             0      my ( $self ) = @_;
338   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
339   ***      0                                  0      return %opts;
340                                                   }
341                                                   
342                                                   sub short_opts {
343   ***      0                    0             0      my ( $self ) = @_;
344   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
345   ***      0                                  0      return %short_opts;
346                                                   }
347                                                   
348                                                   sub set_defaults {
349   ***      0                    0             0      my ( $self, %defaults ) = @_;
350   ***      0                                  0      $self->{defaults} = {};
351   ***      0                                  0      foreach my $long ( keys %defaults ) {
352   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
353                                                            unless exists $self->{opts}->{$long};
354   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
355   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
356                                                      }
357   ***      0                                  0      return;
358                                                   }
359                                                   
360                                                   sub get_defaults {
361   ***      0                    0             0      my ( $self ) = @_;
362   ***      0                                  0      return $self->{defaults};
363                                                   }
364                                                   
365                                                   sub get_groups {
366   ***      0                    0             0      my ( $self ) = @_;
367   ***      0                                  0      return $self->{groups};
368                                                   }
369                                                   
370                                                   sub _set_option {
371   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
372   ***      0      0                           0      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***             0                               
373                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
374                                                               : die "Getopt::Long gave a nonexistent option: $opt";
375                                                   
376   ***      0                                  0      $opt = $self->{opts}->{$long};
377   ***      0      0                           0      if ( $opt->{is_cumulative} ) {
378   ***      0                                  0         $opt->{value}++;
379                                                      }
380                                                      else {
381   ***      0                                  0         $opt->{value} = $val;
382                                                      }
383   ***      0                                  0      $opt->{got} = 1;
384   ***      0                                  0      MKDEBUG && _d('Got option', $long, '=', $val);
385                                                   }
386                                                   
387                                                   sub get_opts {
388   ***      0                    0             0      my ( $self ) = @_; 
389                                                   
390   ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
391   ***      0                                  0         $self->{opts}->{$long}->{got} = 0;
392   ***      0      0                           0         $self->{opts}->{$long}->{value}
      ***             0                               
393                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
394                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
395                                                            : undef;
396                                                      }
397   ***      0                                  0      $self->{got_opts} = 0;
398                                                   
399   ***      0                                  0      $self->{errors} = [];
400                                                   
401   ***      0      0      0                    0      if ( @ARGV && $ARGV[0] eq "--config" ) {
402   ***      0                                  0         shift @ARGV;
403   ***      0                                  0         $self->_set_option('config', shift @ARGV);
404                                                      }
405   ***      0      0                           0      if ( $self->has('config') ) {
406   ***      0                                  0         my @extra_args;
407   ***      0                                  0         foreach my $filename ( split(',', $self->get('config')) ) {
408   ***      0                                  0            eval {
409   ***      0                                  0               push @extra_args, $self->_read_config_file($filename);
410                                                            };
411   ***      0      0                           0            if ( $EVAL_ERROR ) {
412   ***      0      0                           0               if ( $self->got('config') ) {
413   ***      0                                  0                  die $EVAL_ERROR;
414                                                               }
415                                                               elsif ( MKDEBUG ) {
416                                                                  _d($EVAL_ERROR);
417                                                               }
418                                                            }
419                                                         }
420   ***      0                                  0         unshift @ARGV, @extra_args;
421                                                      }
422                                                   
423   ***      0                                  0      Getopt::Long::Configure('no_ignore_case', 'bundling');
424                                                      GetOptions(
425   ***      0                    0             0         map    { $_->{spec} => sub { $self->_set_option(@_); } }
      ***      0                                  0   
      ***      0                                  0   
426   ***      0                                  0         grep   { $_->{long} ne 'config' } # --config is handled specially above.
427   ***      0      0                           0         values %{$self->{opts}}
428                                                      ) or $self->save_error('Error parsing options');
429                                                   
430   ***      0      0      0                    0      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
431   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
432                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
433                                                               or die "Cannot print: $OS_ERROR";
434   ***      0                                  0         exit 0;
435                                                      }
436                                                   
437   ***      0      0      0                    0      if ( @ARGV && $self->{strict} ) {
438   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
439                                                      }
440                                                   
441   ***      0                                  0      foreach my $mutex ( @{$self->{mutex}} ) {
      ***      0                                  0   
442   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
443   ***      0      0                           0         if ( @set > 1 ) {
444   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
445   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
446                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
447                                                                    . ' are mutually exclusive.';
448   ***      0                                  0            $self->save_error($err);
449                                                         }
450                                                      }
451                                                   
452   ***      0                                  0      foreach my $required ( @{$self->{atleast1}} ) {
      ***      0                                  0   
453   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
454   ***      0      0                           0         if ( @set == 0 ) {
455   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
456   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
457                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
458   ***      0                                  0            $self->save_error("Specify at least one of $err");
459                                                         }
460                                                      }
461                                                   
462   ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
463   ***      0                                  0         my $opt = $self->{opts}->{$long};
464   ***      0      0                           0         if ( $opt->{got} ) {
      ***             0                               
465   ***      0      0                           0            if ( exists $self->{disables}->{$long} ) {
466   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
467   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
468   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
469                                                                  'because', $long,'disables them');
470                                                            }
471                                                   
472   ***      0      0                           0            if ( exists $self->{allowed_groups}->{$long} ) {
473                                                   
474   ***      0                                  0               my @restricted_groups = grep {
475   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
476   ***      0                                  0               } keys %{$self->{groups}};
477                                                   
478   ***      0                                  0               my @restricted_opts;
479   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
480   ***      0                                  0                  RESTRICTED_OPT:
481   ***      0                                  0                  foreach my $restricted_opt (
482                                                                     keys %{$self->{groups}->{$restricted_group}} )
483                                                                  {
484   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
485   ***      0      0                           0                     push @restricted_opts, $restricted_opt
486                                                                        if $self->{opts}->{$restricted_opt}->{got};
487                                                                  }
488                                                               }
489                                                   
490   ***      0      0                           0               if ( @restricted_opts ) {
491   ***      0                                  0                  my $err;
492   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
493   ***      0                                  0                     $err = "--$restricted_opts[0]";
494                                                                  }
495                                                                  else {
496   ***      0                                  0                     $err = join(', ',
497   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
498   ***      0                                  0                               grep { $_ } 
499                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
500                                                                            )
501                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
502                                                                  }
503   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
504                                                               }
505                                                            }
506                                                   
507                                                         }
508                                                         elsif ( $opt->{is_required} ) { 
509   ***      0                                  0            $self->save_error("Required option --$long must be specified");
510                                                         }
511                                                   
512   ***      0                                  0         $self->_validate_type($opt);
513                                                      }
514                                                   
515   ***      0                                  0      $self->{got_opts} = 1;
516   ***      0                                  0      return;
517                                                   }
518                                                   
519                                                   sub _validate_type {
520   ***      0                    0             0      my ( $self, $opt ) = @_;
521   ***      0      0      0                    0      return unless $opt && $opt->{type};
522   ***      0                                  0      my $val = $opt->{value};
523                                                   
524   ***      0      0      0                    0      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
      ***                    0                        
525   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
526   ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
527   ***      0      0                           0         if ( !$suffix ) {
528   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
529   ***      0             0                    0            $suffix = $s || 's';
530   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
531                                                               $opt->{long}, '(value:', $val, ')');
532                                                         }
533   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
534   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
535                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
536                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
537                                                                 :                  $num * 86400;   # Days
538   ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
539   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
540                                                         }
541                                                         else {
542   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
543                                                         }
544                                                      }
545                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
546   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
547   ***      0                                  0         my $prev = {};
548   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
549   ***      0      0                           0         if ( $from_key ) {
550   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
551   ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
552                                                         }
553   ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
554   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
555                                                      }
556                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
557   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
558   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
559   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
560   ***      0      0                           0         if ( defined $num ) {
561   ***      0      0                           0            if ( $factor ) {
562   ***      0                                  0               $num *= $factor_for{$factor};
563   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
564                                                                  'to num', $num, '* factor', $factor);
565                                                            }
566   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
567                                                         }
568                                                         else {
569   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
570                                                         }
571                                                      }
572                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
573   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
574                                                      }
575                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
576   ***      0             0                    0         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
577                                                      }
578                                                      else {
579   ***      0                                  0         MKDEBUG && _d('Nothing to validate for option',
580                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
581                                                      }
582                                                   
583   ***      0                                  0      return;
584                                                   }
585                                                   
586                                                   sub get {
587   ***      0                    0             0      my ( $self, $opt ) = @_;
588   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
589   ***      0      0      0                    0      die "Option $opt does not exist"
590                                                         unless $long && exists $self->{opts}->{$long};
591   ***      0                                  0      return $self->{opts}->{$long}->{value};
592                                                   }
593                                                   
594                                                   sub got {
595   ***      0                    0             0      my ( $self, $opt ) = @_;
596   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
597   ***      0      0      0                    0      die "Option $opt does not exist"
598                                                         unless $long && exists $self->{opts}->{$long};
599   ***      0                                  0      return $self->{opts}->{$long}->{got};
600                                                   }
601                                                   
602                                                   sub has {
603   ***      0                    0             0      my ( $self, $opt ) = @_;
604   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
605   ***      0      0                           0      return defined $long ? exists $self->{opts}->{$long} : 0;
606                                                   }
607                                                   
608                                                   sub set {
609   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
610   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
611   ***      0      0      0                    0      die "Option $opt does not exist"
612                                                         unless $long && exists $self->{opts}->{$long};
613   ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
614   ***      0                                  0      return;
615                                                   }
616                                                   
617                                                   sub save_error {
618   ***      0                    0             0      my ( $self, $error ) = @_;
619   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
620                                                   }
621                                                   
622                                                   sub errors {
623   ***      0                    0             0      my ( $self ) = @_;
624   ***      0                                  0      return $self->{errors};
625                                                   }
626                                                   
627                                                   sub prompt {
628   ***      0                    0             0      my ( $self ) = @_;
629   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
630                                                   }
631                                                   
632                                                   sub descr {
633   ***      0                    0             0      my ( $self ) = @_;
634   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
635                                                                 . "  For more details, please use the --help option, "
636                                                                 . "or try 'perldoc $PROGRAM_NAME' "
637                                                                 . "for complete documentation.";
638   ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
639   ***      0                                  0      $descr =~ s/ +$//mg;
640   ***      0                                  0      return $descr;
641                                                   }
642                                                   
643                                                   sub usage_or_errors {
644   ***      0                    0             0      my ( $self ) = @_;
645   ***      0      0                           0      if ( $self->{opts}->{help}->{got} ) {
      ***      0      0                           0   
646   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
647   ***      0                                  0         exit 0;
648                                                      }
649                                                      elsif ( scalar @{$self->{errors}} ) {
650   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
651   ***      0                                  0         exit 0;
652                                                      }
653   ***      0                                  0      return;
654                                                   }
655                                                   
656                                                   sub print_errors {
657   ***      0                    0             0      my ( $self ) = @_;
658   ***      0                                  0      my $usage = $self->prompt() . "\n";
659   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
660   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
661                                                                 . "\n";
662                                                      }
663   ***      0                                  0      return $usage . "\n" . $self->descr();
664                                                   }
665                                                   
666                                                   sub print_usage {
667   ***      0                    0             0      my ( $self ) = @_;
668   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
669   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
670                                                   
671   ***      0      0                           0      my $maxl = max(
672   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
673                                                         @opts);
674                                                   
675   ***      0      0                           0      my $maxs = max(0,
676   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
677   ***      0                                  0         values %{$self->{short_opts}});
678                                                   
679   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
680   ***      0                                  0      my $rcol = 80 - $lcol - 6;
681   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
682                                                   
683   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
684                                                   
685   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
686                                                   
687   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
688   ***      0                                  0      push @groups, 'default';
689                                                   
690   ***      0                                  0      foreach my $group ( reverse @groups ) {
691   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
692   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
693   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
694                                                            grep { $_->{group} eq $group }
695                                                            @opts )
696                                                         {
697   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
698   ***      0                                  0            my $short = $opt->{short};
699   ***      0                                  0            my $desc  = $opt->{desc};
700   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
701   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
702   ***      0             0                    0               $s    ||= 's';
703   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
704   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
705                                                                      . "d=days; if no suffix, $s is used.";
706                                                            }
707   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
708   ***      0                                  0            $desc =~ s/ +$//mg;
709   ***      0      0                           0            if ( $short ) {
710   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
711                                                            }
712                                                            else {
713   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
714                                                            }
715                                                         }
716                                                      }
717                                                   
718   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
719   ***      0                                  0         $usage .= "\nRules:\n\n";
720   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
721                                                      }
722   ***      0      0                           0      if ( $self->{dp} ) {
723   ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
724                                                      }
725   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
726   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
727   ***      0                                  0         my $val   = $opt->{value};
728   ***      0             0                    0         my $type  = $opt->{type} || '';
729   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
730   ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
731                                                                   : !defined $val             ? '(No value)'
732                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
733                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
734                                                                   : $type =~ m/A|a/           ? join(',', @$val)
735                                                                   :                             $val;
736   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
737                                                      }
738   ***      0                                  0      return $usage;
739                                                   }
740                                                   
741                                                   sub prompt_noecho {
742   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
743   ***      0                                  0      my ( $prompt ) = @_;
744   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
745   ***      0      0                           0      print $prompt
746                                                         or die "Cannot print: $OS_ERROR";
747   ***      0                                  0      my $response;
748   ***      0                                  0      eval {
749   ***      0                                  0         require Term::ReadKey;
750   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
751   ***      0                                  0         chomp($response = <STDIN>);
752   ***      0                                  0         Term::ReadKey::ReadMode('normal');
753   ***      0      0                           0         print "\n"
754                                                            or die "Cannot print: $OS_ERROR";
755                                                      };
756   ***      0      0                           0      if ( $EVAL_ERROR ) {
757   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
758                                                      }
759   ***      0                                  0      return $response;
760                                                   }
761                                                   
762                                                   if ( MKDEBUG ) {
763                                                      print '# ', $^X, ' ', $], "\n";
764                                                      my $uname = `uname -a`;
765                                                      if ( $uname ) {
766                                                         $uname =~ s/\s+/ /g;
767                                                         print "# $uname\n";
768                                                      }
769                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
770                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
771                                                         ($main::SVN_REV || ''), __LINE__);
772                                                      print('# Arguments: ',
773                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
774                                                   }
775                                                   
776                                                   sub _read_config_file {
777   ***      0                    0             0      my ( $self, $filename ) = @_;
778   ***      0      0                           0      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
779   ***      0                                  0      my @args;
780   ***      0                                  0      my $prefix = '--';
781   ***      0                                  0      my $parse  = 1;
782                                                   
783                                                      LINE:
784   ***      0                                  0      while ( my $line = <$fh> ) {
785   ***      0                                  0         chomp $line;
786   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
787   ***      0                                  0         $line =~ s/\s+#.*$//g;
788   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
789   ***      0      0                           0         if ( $line eq '--' ) {
790   ***      0                                  0            $prefix = '';
791   ***      0                                  0            $parse  = 0;
792   ***      0                                  0            next LINE;
793                                                         }
794   ***      0      0      0                    0         if ( $parse
      ***             0                               
795                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
796                                                         ) {
797   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
798                                                         }
799                                                         elsif ( $line =~ m/./ ) {
800   ***      0                                  0            push @args, $line;
801                                                         }
802                                                         else {
803   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
804                                                         }
805                                                      }
806   ***      0                                  0      close $fh;
807   ***      0                                  0      return @args;
808                                                   }
809                                                   
810                                                   sub read_para_after {
811   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
812   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
813   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
814   ***      0                                  0      my $para;
815   ***      0                                  0      while ( $para = <$fh> ) {
816   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
817   ***      0                                  0         last;
818                                                      }
819   ***      0                                  0      while ( $para = <$fh> ) {
820   ***      0      0                           0         next unless $para =~ m/$regex/;
821   ***      0                                  0         last;
822                                                      }
823   ***      0                                  0      $para = <$fh>;
824   ***      0                                  0      chomp($para);
825   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
826   ***      0                                  0      return $para;
827                                                   }
828                                                   
829                                                   sub clone {
830   ***      0                    0             0      my ( $self ) = @_;
831                                                   
832   ***      0                                  0      my %clone = map {
833   ***      0                                  0         my $hashref  = $self->{$_};
834   ***      0                                  0         my $val_copy = {};
835   ***      0                                  0         foreach my $key ( keys %$hashref ) {
836   ***      0                                  0            my $ref = ref $hashref->{$key};
837   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
838   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
839   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
840                                                                              : $hashref->{$key};
841                                                         }
842   ***      0                                  0         $_ => $val_copy;
843                                                      } qw(opts short_opts defaults);
844                                                   
845   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
846   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
847                                                      }
848                                                   
849   ***      0                                  0      return bless \%clone;     
850                                                   }
851                                                   
852                                                   sub _d {
853   ***      0                    0             0      my ($package, undef, $line) = caller 0;
854   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
855   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
856                                                           @_;
857   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
858                                                   }
859                                                   
860                                                   1;
861                                                   
862                                                   # ###########################################################################
863                                                   # End OptionParser package
864                                                   # ###########################################################################
865                                                   
866                                                   # ###########################################################################
867                                                   # TableParser package 5266
868                                                   # ###########################################################################
869                                                   package TableParser;
870                                                   
871           16                   16           168   use strict;
              16                                 60   
              16                                133   
872           16                   16           105   use warnings FATAL => 'all';
              16                                 39   
              16                                121   
873           16                   16           104   use English qw(-no_match_vars);
              16                                 41   
              16                                105   
874           16                   16           114   use Data::Dumper;
              16                                 42   
              16                                585   
875                                                   $Data::Dumper::Indent    = 1;
876                                                   $Data::Dumper::Sortkeys  = 1;
877                                                   $Data::Dumper::Quotekeys = 0;
878                                                   
879   ***     16            50     16           104   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              16                                 51   
              16                                251   
880                                                   
881                                                   
882                                                   sub new {
883   ***      0                    0             0      my ( $class, %args ) = @_;
884   ***      0                                  0      my @required_args = qw(Quoter);
885   ***      0                                  0      foreach my $arg ( @required_args ) {
886   ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
887                                                      }
888   ***      0                                  0      my $self = { %args };
889   ***      0                                  0      return bless $self, $class;
890                                                   }
891                                                   
892                                                   
893                                                   sub parse {
894   ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
895   ***      0      0                           0      return unless $ddl;
896   ***      0      0                           0      if ( ref $ddl eq 'ARRAY' ) {
897   ***      0      0                           0         if ( lc $ddl->[0] eq 'table' ) {
898   ***      0                                  0            $ddl = $ddl->[1];
899                                                         }
900                                                         else {
901                                                            return {
902   ***      0                                  0               engine => 'VIEW',
903                                                            };
904                                                         }
905                                                      }
906                                                   
907   ***      0      0                           0      if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
908   ***      0                                  0         die "Cannot parse table definition; is ANSI quoting "
909                                                            . "enabled or SQL_QUOTE_SHOW_CREATE disabled?";
910                                                      }
911                                                   
912   ***      0                                  0      my ($name)     = $ddl =~ m/CREATE (?:TEMPORARY )?TABLE\s+(`.+?`)/;
913   ***      0      0                           0      (undef, $name) = $self->{Quoter}->split_unquote($name) if $name;
914                                                   
915   ***      0                                  0      $ddl =~ s/(`[^`]+`)/\L$1/g;
916                                                   
917   ***      0                                  0      my $engine = $self->get_engine($ddl);
918                                                   
919   ***      0                                  0      my @defs   = $ddl =~ m/^(\s+`.*?),?$/gm;
920   ***      0                                  0      my @cols   = map { $_ =~ m/`([^`]+)`/ } @defs;
      ***      0                                  0   
921   ***      0                                  0      MKDEBUG && _d('Columns:', join(', ', @cols));
922                                                   
923   ***      0                                  0      my %def_for;
924   ***      0                                  0      @def_for{@cols} = @defs;
925                                                   
926   ***      0                                  0      my (@nums, @null);
927   ***      0                                  0      my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
928   ***      0                                  0      foreach my $col ( @cols ) {
929   ***      0                                  0         my $def = $def_for{$col};
930   ***      0                                  0         my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
931   ***      0      0                           0         die "Can't determine column type for $def" unless $type;
932   ***      0                                  0         $type_for{$col} = $type;
933   ***      0      0                           0         if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
934   ***      0                                  0            push @nums, $col;
935   ***      0                                  0            $is_numeric{$col} = 1;
936                                                         }
937   ***      0      0                           0         if ( $def !~ m/NOT NULL/ ) {
938   ***      0                                  0            push @null, $col;
939   ***      0                                  0            $is_nullable{$col} = 1;
940                                                         }
941   ***      0      0                           0         $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
942                                                      }
943                                                   
944   ***      0                                  0      my ($keys, $clustered_key) = $self->get_keys($ddl, $opts, \%is_nullable);
945                                                   
946                                                      return {
947   ***      0                                  0         name           => $name,
948                                                         cols           => \@cols,
949   ***      0                                  0         col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
950   ***      0                                  0         is_col         => { map { $_ => 1 } @cols },
951                                                         null_cols      => \@null,
952                                                         is_nullable    => \%is_nullable,
953                                                         is_autoinc     => \%is_autoinc,
954                                                         clustered_key  => $clustered_key,
955                                                         keys           => $keys,
956                                                         defs           => \%def_for,
957                                                         numeric_cols   => \@nums,
958                                                         is_numeric     => \%is_numeric,
959                                                         engine         => $engine,
960                                                         type_for       => \%type_for,
961                                                      };
962                                                   }
963                                                   
964                                                   sub sort_indexes {
965   ***      0                    0             0      my ( $self, $tbl ) = @_;
966                                                   
967                                                      my @indexes
968   ***      0                                  0         = sort {
969   ***      0                                  0            (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
970                                                            || ( !$tbl->{keys}->{$a}->{is_unique} <=> !$tbl->{keys}->{$b}->{is_unique} )
971                                                            || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
972   ***      0      0      0                    0            || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      ***      0             0                    0   
973                                                         }
974                                                         grep {
975   ***      0                                  0            $tbl->{keys}->{$_}->{type} eq 'BTREE'
976                                                         }
977   ***      0                                  0         sort keys %{$tbl->{keys}};
978                                                   
979   ***      0                                  0      MKDEBUG && _d('Indexes sorted best-first:', join(', ', @indexes));
980   ***      0                                  0      return @indexes;
981                                                   }
982                                                   
983                                                   sub find_best_index {
984   ***      0                    0             0      my ( $self, $tbl, $index ) = @_;
985   ***      0                                  0      my $best;
986   ***      0      0                           0      if ( $index ) {
987   ***      0                                  0         ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
      ***      0                                  0   
      ***      0                                  0   
988                                                      }
989   ***      0      0                           0      if ( !$best ) {
990   ***      0      0                           0         if ( $index ) {
991   ***      0                                  0            die "Index '$index' does not exist in table";
992                                                         }
993                                                         else {
994   ***      0                                  0            ($best) = $self->sort_indexes($tbl);
995                                                         }
996                                                      }
997   ***      0                                  0      MKDEBUG && _d('Best index found is', $best);
998   ***      0                                  0      return $best;
999                                                   }
1000                                                  
1001                                                  sub find_possible_keys {
1002  ***      0                    0             0      my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
1003  ***      0      0                           0      return () unless $where;
1004  ***      0                                  0      my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
1005                                                        . ' WHERE ' . $where;
1006  ***      0                                  0      MKDEBUG && _d($sql);
1007  ***      0                                  0      my $expl = $dbh->selectrow_hashref($sql);
1008  ***      0                                  0      $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
      ***      0                                  0   
1009  ***      0      0                           0      if ( $expl->{possible_keys} ) {
1010  ***      0                                  0         MKDEBUG && _d('possible_keys =', $expl->{possible_keys});
1011  ***      0                                  0         my @candidates = split(',', $expl->{possible_keys});
1012  ***      0                                  0         my %possible   = map { $_ => 1 } @candidates;
      ***      0                                  0   
1013  ***      0      0                           0         if ( $expl->{key} ) {
1014  ***      0                                  0            MKDEBUG && _d('MySQL chose', $expl->{key});
1015  ***      0                                  0            unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
      ***      0                                  0   
1016  ***      0                                  0            MKDEBUG && _d('Before deduping:', join(', ', @candidates));
1017  ***      0                                  0            my %seen;
1018  ***      0                                  0            @candidates = grep { !$seen{$_}++ } @candidates;
      ***      0                                  0   
1019                                                        }
1020  ***      0                                  0         MKDEBUG && _d('Final list:', join(', ', @candidates));
1021  ***      0                                  0         return @candidates;
1022                                                     }
1023                                                     else {
1024  ***      0                                  0         MKDEBUG && _d('No keys in possible_keys');
1025  ***      0                                  0         return ();
1026                                                     }
1027                                                  }
1028                                                  
1029                                                  sub check_table {
1030  ***      0                    0             0      my ( $self, %args ) = @_;
1031  ***      0                                  0      my @required_args = qw(dbh db tbl);
1032  ***      0                                  0      foreach my $arg ( @required_args ) {
1033  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1034                                                     }
1035  ***      0                                  0      my ($dbh, $db, $tbl) = @args{@required_args};
1036  ***      0                                  0      my $q      = $self->{Quoter};
1037  ***      0                                  0      my $db_tbl = $q->quote($db, $tbl);
1038  ***      0                                  0      MKDEBUG && _d('Checking', $db_tbl);
1039                                                  
1040  ***      0                                  0      my $sql = "SHOW TABLES FROM " . $q->quote($db)
1041                                                             . ' LIKE ' . $q->literal_like($tbl);
1042  ***      0                                  0      MKDEBUG && _d($sql);
1043  ***      0                                  0      my $row;
1044  ***      0                                  0      eval {
1045  ***      0                                  0         $row = $dbh->selectrow_arrayref($sql);
1046                                                     };
1047  ***      0      0                           0      if ( $EVAL_ERROR ) {
1048  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
1049  ***      0                                  0         return 0;
1050                                                     }
1051  ***      0      0      0                    0      if ( !$row->[0] || $row->[0] ne $tbl ) {
1052  ***      0                                  0         MKDEBUG && _d('Table does not exist');
1053  ***      0                                  0         return 0;
1054                                                     }
1055                                                  
1056  ***      0                                  0      MKDEBUG && _d('Table exists; no privs to check');
1057  ***      0      0                           0      return 1 unless $args{all_privs};
1058                                                  
1059  ***      0                                  0      $sql = "SHOW FULL COLUMNS FROM $db_tbl";
1060  ***      0                                  0      MKDEBUG && _d($sql);
1061  ***      0                                  0      eval {
1062  ***      0                                  0         $row = $dbh->selectrow_hashref($sql);
1063                                                     };
1064  ***      0      0                           0      if ( $EVAL_ERROR ) {
1065  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
1066  ***      0                                  0         return 0;
1067                                                     }
1068  ***      0      0                           0      if ( !scalar keys %$row ) {
1069  ***      0                                  0         MKDEBUG && _d('Table has no columns:', Dumper($row));
1070  ***      0                                  0         return 0;
1071                                                     }
1072  ***      0             0                    0      my $privs = $row->{privileges} || $row->{Privileges};
1073                                                  
1074  ***      0                                  0      $sql = "DELETE FROM $db_tbl LIMIT 0";
1075  ***      0                                  0      MKDEBUG && _d($sql);
1076  ***      0                                  0      eval {
1077  ***      0                                  0         $dbh->do($sql);
1078                                                     };
1079  ***      0      0                           0      my $can_delete = $EVAL_ERROR ? 0 : 1;
1080                                                  
1081  ***      0                                  0      MKDEBUG && _d('User privs on', $db_tbl, ':', $privs,
1082                                                        ($can_delete ? 'delete' : ''));
1083                                                  
1084  ***      0      0      0                    0      if ( !($privs =~ m/select/ && $privs =~ m/insert/ && $privs =~ m/update/
      ***                    0                        
      ***                    0                        
1085                                                            && $can_delete) ) {
1086  ***      0                                  0         MKDEBUG && _d('User does not have all privs');
1087  ***      0                                  0         return 0;
1088                                                     }
1089                                                  
1090  ***      0                                  0      MKDEBUG && _d('User has all privs');
1091  ***      0                                  0      return 1;
1092                                                  }
1093                                                  
1094                                                  sub get_engine {
1095  ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
1096  ***      0                                  0      my ( $engine ) = $ddl =~ m/\).*?(?:ENGINE|TYPE)=(\w+)/;
1097  ***      0                                  0      MKDEBUG && _d('Storage engine:', $engine);
1098  ***      0             0                    0      return $engine || undef;
1099                                                  }
1100                                                  
1101                                                  sub get_keys {
1102  ***      0                    0             0      my ( $self, $ddl, $opts, $is_nullable ) = @_;
1103  ***      0                                  0      my $engine        = $self->get_engine($ddl);
1104  ***      0                                  0      my $keys          = {};
1105  ***      0                                  0      my $clustered_key = undef;
1106                                                  
1107                                                     KEY:
1108  ***      0                                  0      foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {
1109                                                  
1110  ***      0      0                           0         next KEY if $key =~ m/FOREIGN/;
1111                                                  
1112  ***      0                                  0         my $key_ddl = $key;
1113  ***      0                                  0         MKDEBUG && _d('Parsed key:', $key_ddl);
1114                                                  
1115  ***      0      0                           0         if ( $engine !~ m/MEMORY|HEAP/ ) {
1116  ***      0                                  0            $key =~ s/USING HASH/USING BTREE/;
1117                                                        }
1118                                                  
1119  ***      0                                  0         my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
1120  ***      0                                  0         my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
1121  ***      0             0                    0         $type = $type || $special || 'BTREE';
      ***                    0                        
1122  ***      0      0      0                    0         if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
      ***                    0                        
1123                                                           && $engine =~ m/HEAP|MEMORY/i )
1124                                                        {
1125  ***      0                                  0            $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
1126                                                        }
1127                                                  
1128  ***      0                                  0         my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
1129  ***      0      0                           0         my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
1130  ***      0                                  0         my @cols;
1131  ***      0                                  0         my @col_prefixes;
1132  ***      0                                  0         foreach my $col_def ( split(',', $cols) ) {
1133  ***      0                                  0            my ($name, $prefix) = $col_def =~ m/`([^`]+)`(?:\((\d+)\))?/;
1134  ***      0                                  0            push @cols, $name;
1135  ***      0                                  0            push @col_prefixes, $prefix;
1136                                                        }
1137  ***      0                                  0         $name =~ s/`//g;
1138                                                  
1139  ***      0                                  0         MKDEBUG && _d('Key', $name, 'cols:', join(', ', @cols));
1140                                                  
1141  ***      0                                  0         $keys->{$name} = {
1142                                                           name         => $name,
1143                                                           type         => $type,
1144                                                           colnames     => $cols,
1145                                                           cols         => \@cols,
1146                                                           col_prefixes => \@col_prefixes,
1147                                                           is_unique    => $unique,
1148  ***      0                                  0            is_nullable  => scalar(grep { $is_nullable->{$_} } @cols),
1149  ***      0                                  0            is_col       => { map { $_ => 1 } @cols },
1150                                                           ddl          => $key_ddl,
1151                                                        };
1152                                                  
1153  ***      0      0      0                    0         if ( $engine =~ m/InnoDB/i && !$clustered_key ) {
1154  ***      0                                  0            my $this_key = $keys->{$name};
1155  ***      0      0      0                    0            if ( $this_key->{name} eq 'PRIMARY' ) {
      ***             0                               
1156  ***      0                                  0               $clustered_key = 'PRIMARY';
1157                                                           }
1158                                                           elsif ( $this_key->{is_unique} && !$this_key->{is_nullable} ) {
1159  ***      0                                  0               $clustered_key = $this_key->{name};
1160                                                           }
1161  ***      0                                  0            MKDEBUG && $clustered_key && _d('This key is the clustered key');
1162                                                        }
1163                                                     }
1164                                                  
1165  ***      0                                  0      return $keys, $clustered_key;
1166                                                  }
1167                                                  
1168                                                  sub get_fks {
1169  ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
1170  ***      0                                  0      my $fks = {};
1171                                                  
1172  ***      0                                  0      foreach my $fk (
1173                                                        $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg )
1174                                                     {
1175  ***      0                                  0         my ( $name ) = $fk =~ m/CONSTRAINT `(.*?)`/;
1176  ***      0                                  0         my ( $cols ) = $fk =~ m/FOREIGN KEY \(([^\)]+)\)/;
1177  ***      0                                  0         my ( $parent, $parent_cols ) = $fk =~ m/REFERENCES (\S+) \(([^\)]+)\)/;
1178                                                  
1179  ***      0      0      0                    0         if ( $parent !~ m/\./ && $opts->{database} ) {
1180  ***      0                                  0            $parent = "`$opts->{database}`.$parent";
1181                                                        }
1182                                                  
1183  ***      0                                  0         $fks->{$name} = {
1184                                                           name           => $name,
1185                                                           colnames       => $cols,
1186  ***      0                                  0            cols           => [ map { s/[ `]+//g; $_; } split(',', $cols) ],
      ***      0                                  0   
1187                                                           parent_tbl     => $parent,
1188                                                           parent_colnames=> $parent_cols,
1189  ***      0                                  0            parent_cols    => [ map { s/[ `]+//g; $_; } split(',', $parent_cols) ],
      ***      0                                  0   
1190                                                           ddl            => $fk,
1191                                                        };
1192                                                     }
1193                                                  
1194  ***      0                                  0      return $fks;
1195                                                  }
1196                                                  
1197                                                  sub remove_auto_increment {
1198  ***      0                    0             0      my ( $self, $ddl ) = @_;
1199  ***      0                                  0      $ddl =~ s/(^\).*?) AUTO_INCREMENT=\d+\b/$1/m;
1200  ***      0                                  0      return $ddl;
1201                                                  }
1202                                                  
1203                                                  sub remove_secondary_indexes {
1204  ***      0                    0             0      my ( $self, $ddl ) = @_;
1205  ***      0                                  0      my $sec_indexes_ddl;
1206  ***      0                                  0      my $tbl_struct = $self->parse($ddl);
1207                                                  
1208  ***      0      0      0                    0      if ( ($tbl_struct->{engine} || '') =~ m/InnoDB/i ) {
1209  ***      0                                  0         my $clustered_key = $tbl_struct->{clustered_key};
1210  ***      0             0                    0         $clustered_key  ||= '';
1211                                                  
1212  ***      0                                  0         my @sec_indexes   = map {
1213  ***      0                                  0            my $key_def = $_->{ddl};
1214  ***      0                                  0            $key_def =~ s/([\(\)])/\\$1/g;
1215  ***      0                                  0            $ddl =~ s/\s+$key_def//;
1216  ***      0                                  0            "ADD $_->{ddl}";
1217                                                        }
1218  ***      0                                  0         grep { $_->{name} ne $clustered_key }
1219  ***      0                                  0         values %{$tbl_struct->{keys}};
1220  ***      0                                  0         MKDEBUG && _d('Secondary indexes:', Dumper(\@sec_indexes));
1221                                                  
1222  ***      0      0                           0         if ( @sec_indexes ) {
1223  ***      0                                  0            $sec_indexes_ddl = join(' ', @sec_indexes);
1224  ***      0                                  0            $sec_indexes_ddl =~ s/,$//;
1225                                                        }
1226                                                  
1227  ***      0                                  0         $ddl =~ s/,(\n\) )/$1/s;
1228                                                     }
1229                                                     else {
1230  ***      0                                  0         MKDEBUG && _d('Not removing secondary indexes from',
1231                                                           $tbl_struct->{engine}, 'table');
1232                                                     }
1233                                                  
1234  ***      0                                  0      return $ddl, $sec_indexes_ddl, $tbl_struct;
1235                                                  }
1236                                                  
1237                                                  sub _d {
1238  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1239  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1240  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1241                                                          @_;
1242  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1243                                                  }
1244                                                  
1245                                                  1;
1246                                                  
1247                                                  # ###########################################################################
1248                                                  # End TableParser package
1249                                                  # ###########################################################################
1250                                                  
1251                                                  # ###########################################################################
1252                                                  # DSNParser package 5266
1253                                                  # ###########################################################################
1254                                                  package DSNParser;
1255                                                  
1256          16                   16           142   use strict;
              16                                 52   
              16                                110   
1257          16                   16           101   use warnings FATAL => 'all';
              16                                 40   
              16                                101   
1258          16                   16           104   use English qw(-no_match_vars);
              16                                 39   
              16                                 98   
1259          16                   16           119   use Data::Dumper;
              16                                 48   
              16                                161   
1260                                                  $Data::Dumper::Indent    = 0;
1261                                                  $Data::Dumper::Quotekeys = 0;
1262                                                  
1263                                                  eval {
1264                                                     require DBI;
1265                                                  };
1266                                                  my $have_dbi = $EVAL_ERROR ? 0 : 1;
1267                                                  
1268  ***     16            50     16           107   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              16                                 49   
              16                                249   
1269                                                  
1270                                                  sub new {
1271          32                   32           161      my ( $class, @opts ) = @_;
1272          32                                706      my $self = {
1273                                                        opts => {
1274                                                           A => {
1275                                                              desc => 'Default character set',
1276                                                              dsn  => 'charset',
1277                                                              copy => 1,
1278                                                           },
1279                                                           D => {
1280                                                              desc => 'Database to use',
1281                                                              dsn  => 'database',
1282                                                              copy => 1,
1283                                                           },
1284                                                           F => {
1285                                                              desc => 'Only read default options from the given file',
1286                                                              dsn  => 'mysql_read_default_file',
1287                                                              copy => 1,
1288                                                           },
1289                                                           h => {
1290                                                              desc => 'Connect to host',
1291                                                              dsn  => 'host',
1292                                                              copy => 1,
1293                                                           },
1294                                                           p => {
1295                                                              desc => 'Password to use when connecting',
1296                                                              dsn  => 'password',
1297                                                              copy => 1,
1298                                                           },
1299                                                           P => {
1300                                                              desc => 'Port number to use for connection',
1301                                                              dsn  => 'port',
1302                                                              copy => 1,
1303                                                           },
1304                                                           S => {
1305                                                              desc => 'Socket file to use for connection',
1306                                                              dsn  => 'mysql_socket',
1307                                                              copy => 1,
1308                                                           },
1309                                                           u => {
1310                                                              desc => 'User for login if not current user',
1311                                                              dsn  => 'user',
1312                                                              copy => 1,
1313                                                           },
1314                                                        },
1315                                                     };
1316          32                                139      foreach my $opt ( @opts ) {
1317          96                                547         MKDEBUG && _d('Adding extra property', $opt->{key});
1318          96                                666         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
1319                                                     }
1320          32                                320      return bless $self, $class;
1321                                                  }
1322                                                  
1323                                                  sub prop {
1324          54                   54           262      my ( $self, $prop, $value ) = @_;
1325  ***     54     50                         273      if ( @_ > 2 ) {
1326  ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
1327  ***      0                                  0         $self->{$prop} = $value;
1328                                                     }
1329          54                                616      return $self->{$prop};
1330                                                  }
1331                                                  
1332                                                  sub parse {
1333          18                   18           728      my ( $self, $dsn, $prev, $defaults ) = @_;
1334  ***     18     50                          93      if ( !$dsn ) {
1335  ***      0                                  0         MKDEBUG && _d('No DSN to parse');
1336  ***      0                                  0         return;
1337                                                     }
1338          18                                 43      MKDEBUG && _d('Parsing', $dsn);
1339  ***     18            50                   85      $prev     ||= {};
1340  ***     18            50                   84      $defaults ||= {};
1341          18                                 53      my %given_props;
1342          18                                 48      my %final_props;
1343          18                                 52      my %opts = %{$self->{opts}};
              18                                163   
1344                                                  
1345          18                                164      foreach my $dsn_part ( split(/,/, $dsn) ) {
1346  ***     72     50                         596         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1347          72                                354            $given_props{$prop_key} = $prop_val;
1348                                                        }
1349                                                        else {
1350  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1351  ***      0                                  0            $given_props{h} = $dsn_part;
1352                                                        }
1353                                                     }
1354                                                  
1355          18                                107      foreach my $key ( keys %opts ) {
1356         144                                313         MKDEBUG && _d('Finding value for', $key);
1357         144                                482         $final_props{$key} = $given_props{$key};
1358  ***    144     50     66                 1227         if (   !defined $final_props{$key}
      ***                   33                        
1359                                                             && defined $prev->{$key} && $opts{$key}->{copy} )
1360                                                        {
1361  ***      0                                  0            $final_props{$key} = $prev->{$key};
1362  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1363                                                        }
1364         144    100                         629         if ( !defined $final_props{$key} ) {
1365          72                                259            $final_props{$key} = $defaults->{$key};
1366          72                                186            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1367                                                        }
1368                                                     }
1369                                                  
1370          18                                 95      foreach my $key ( keys %given_props ) {
1371  ***     72     50                         314         die "Unrecognized DSN part '$key' in '$dsn'\n"
1372                                                           unless exists $opts{$key};
1373                                                     }
1374  ***     18     50                          93      if ( (my $required = $self->prop('required')) ) {
1375  ***      0                                  0         foreach my $key ( keys %$required ) {
1376  ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1377                                                        }
1378                                                     }
1379                                                  
1380          18                                121      return \%final_props;
1381                                                  }
1382                                                  
1383                                                  sub parse_options {
1384  ***      0                    0             0      my ( $self, $o ) = @_;
1385  ***      0      0                           0      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1386  ***      0                                  0      my $dsn_string
1387                                                        = join(',',
1388  ***      0      0                           0             map  { "$_=".$o->get($_); }
1389  ***      0                                  0             grep { $o->has($_) && $o->get($_) }
1390  ***      0                                  0             keys %{$self->{opts}}
1391                                                          );
1392  ***      0                                  0      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1393  ***      0                                  0      return $self->parse($dsn_string);
1394                                                  }
1395                                                  
1396                                                  sub as_string {
1397  ***      0                    0             0      my ( $self, $dsn ) = @_;
1398  ***      0      0                           0      return $dsn unless ref $dsn;
1399  ***      0      0                           0      return join(',',
1400  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1401  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1402                                                        sort keys %$dsn );
1403                                                  }
1404                                                  
1405                                                  sub usage {
1406  ***      0                    0             0      my ( $self ) = @_;
1407  ***      0                                  0      my $usage
1408                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1409                                                        . "  KEY  COPY  MEANING\n"
1410                                                        . "  ===  ====  =============================================\n";
1411  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1412  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1413  ***      0      0      0                    0         $usage .= "  $key    "
1414                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1415                                                               .  ($opts{$key}->{desc} || '[No description]')
1416                                                               . "\n";
1417                                                     }
1418  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1419  ***      0                                  0      return $usage;
1420                                                  }
1421                                                  
1422                                                  sub get_cxn_params {
1423          18                   18           223      my ( $self, $info ) = @_;
1424          18                                 50      my $dsn;
1425          18                                 53      my %opts = %{$self->{opts}};
              18                                151   
1426  ***     18            50                   96      my $driver = $self->prop('dbidriver') || '';
1427  ***     18     50                          95      if ( $driver eq 'Pg' ) {
1428  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1429  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1430  ***      0             0                    0                        grep { defined $info->{$_} }
1431                                                                       qw(h P));
1432                                                     }
1433                                                     else {
1434          36                                264         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1435          90                                334            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1436  ***     18            50                  226                        grep { defined $info->{$_} }
1437                                                                       qw(F h P S A))
1438                                                           . ';mysql_read_default_group=client';
1439                                                     }
1440          18                                 56      MKDEBUG && _d($dsn);
1441          18                                153      return ($dsn, $info->{u}, $info->{p});
1442                                                  }
1443                                                  
1444                                                  sub fill_in_dsn {
1445  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1446  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1447  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1448  ***      0                                  0      $user =~ s/@.*//;
1449  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1450  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1451  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1452  ***      0             0                    0      $dsn->{u} ||= $user;
1453  ***      0             0                    0      $dsn->{D} ||= $db;
1454                                                  }
1455                                                  
1456                                                  sub get_dbh {
1457          18                   18           111      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1458  ***     18            50                  109      $opts ||= {};
1459  ***     18     50                         190      my $defaults = {
1460                                                        AutoCommit         => 0,
1461                                                        RaiseError         => 1,
1462                                                        PrintError         => 0,
1463                                                        ShowErrorStatement => 1,
1464                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1465                                                     };
1466          18                                 94      @{$defaults}{ keys %$opts } = values %$opts;
              18                                 84   
1467                                                  
1468  ***     18     50                          82      if ( !$have_dbi ) {
1469  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1470                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1471                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1472                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1473                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1474                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1475                                                  
1476                                                     }
1477                                                  
1478          18                                 52      my $dbh;
1479          18                                 53      my $tries = 2;
1480  ***     18            66                  192      while ( !$dbh && $tries-- ) {
1481                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1482          18                                 47            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1483                                                  
1484          18                                 45         eval {
1485          18                                128            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1486                                                  
1487  ***     18     50                         411            if ( $cxn_string =~ m/mysql/i ) {
1488          18                                 62               my $sql;
1489                                                  
1490          18                                 68               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1491                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1492          18                                 46               MKDEBUG && _d($dbh, ':', $sql);
1493          18                               2390               $dbh->do($sql);
1494                                                  
1495  ***     18     50                         179               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1496  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1497  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1498  ***      0                                  0                  $dbh->do($sql);
1499  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1500  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1501  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1502                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1503                                                                 }
1504                                                                 else {
1505  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1506                                                                 }
1507                                                              }
1508                                                  
1509  ***     18     50                         116               if ( $self->prop('set-vars') ) {
1510  ***      0                                  0                  $sql = "SET " . $self->prop('set-vars');
1511  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1512  ***      0                                  0                  $dbh->do($sql);
1513                                                              }
1514                                                           }
1515                                                        };
1516  ***     18     50     33                  206         if ( !$dbh && $EVAL_ERROR ) {
1517  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1518  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1519  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1520  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1521                                                           }
1522                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1523  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1524                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1525                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1526                                                                 . "DBD::mysql is not installed, try:\n"
1527                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1528                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1529                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1530                                                           }
1531  ***      0      0                           0            if ( !$tries ) {
1532  ***      0                                  0               die $EVAL_ERROR;
1533                                                           }
1534                                                        }
1535                                                     }
1536                                                  
1537          18                                 45      MKDEBUG && _d('DBH info: ',
1538                                                        $dbh,
1539                                                        Dumper($dbh->selectrow_hashref(
1540                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1541                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1542                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1543                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1544                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1545                                                        '$DBI::VERSION:',        $DBI::VERSION,
1546                                                     );
1547                                                  
1548          18                                128      return $dbh;
1549                                                  }
1550                                                  
1551                                                  sub get_hostname {
1552  ***      0                    0             0      my ( $self, $dbh ) = @_;
1553  ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1554  ***      0                                  0         return $host;
1555                                                     }
1556  ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
1557                                                        'SELECT /*!50038 @@hostname, */ 1');
1558  ***      0                                  0      return $hostname;
1559                                                  }
1560                                                  
1561                                                  sub disconnect {
1562  ***      0                    0             0      my ( $self, $dbh ) = @_;
1563  ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
1564  ***      0                                  0      $dbh->disconnect;
1565                                                  }
1566                                                  
1567                                                  sub print_active_handles {
1568  ***      0                    0             0      my ( $self, $thing, $level ) = @_;
1569  ***      0             0                    0      $level ||= 0;
1570  ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1571                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1572                                                        or die "Cannot print: $OS_ERROR";
1573  ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
1574  ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
1575                                                     }
1576                                                  }
1577                                                  
1578                                                  sub copy {
1579  ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1580  ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
1581  ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
1582  ***      0                                  0      my %new_dsn = map {
1583  ***      0                                  0         my $key = $_;
1584  ***      0                                  0         my $val;
1585  ***      0      0                           0         if ( $args{overwrite} ) {
1586  ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1587                                                        }
1588                                                        else {
1589  ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1590                                                        }
1591  ***      0                                  0         $key => $val;
1592  ***      0                                  0      } keys %{$self->{opts}};
1593  ***      0                                  0      return \%new_dsn;
1594                                                  }
1595                                                  
1596                                                  sub _d {
1597  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1598  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1599  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1600                                                          @_;
1601  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1602                                                  }
1603                                                  
1604                                                  1;
1605                                                  
1606                                                  # ###########################################################################
1607                                                  # End DSNParser package
1608                                                  # ###########################################################################
1609                                                  
1610                                                  # ###########################################################################
1611                                                  # VersionParser package 5266
1612                                                  # ###########################################################################
1613                                                  package VersionParser;
1614                                                  
1615          16                   16           135   use strict;
              16                                 44   
              16                                180   
1616          16                   16            98   use warnings FATAL => 'all';
              16                                 40   
              16                                103   
1617                                                  
1618          16                   16            97   use English qw(-no_match_vars);
              16                                 43   
              16                                 97   
1619                                                  
1620  ***     16            50     16           105   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              16                                 46   
              16                                236   
1621                                                  
1622                                                  sub new {
1623          16                   16            75      my ( $class ) = @_;
1624          16                                170      bless {}, $class;
1625                                                  }
1626                                                  
1627                                                  sub parse {
1628  ***      0                    0             0      my ( $self, $str ) = @_;
1629  ***      0                                  0      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
1630  ***      0                                  0      MKDEBUG && _d($str, 'parses to', $result);
1631  ***      0                                  0      return $result;
1632                                                  }
1633                                                  
1634                                                  sub version_ge {
1635  ***      0                    0             0      my ( $self, $dbh, $target ) = @_;
1636  ***      0      0                           0      if ( !$self->{$dbh} ) {
1637  ***      0                                  0         $self->{$dbh} = $self->parse(
1638                                                           $dbh->selectrow_array('SELECT VERSION()'));
1639                                                     }
1640  ***      0      0                           0      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
1641  ***      0                                  0      MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
1642  ***      0                                  0      return $result;
1643                                                  }
1644                                                  
1645                                                  sub _d {
1646  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1647  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1648  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1649                                                          @_;
1650  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1651                                                  }
1652                                                  
1653                                                  1;
1654                                                  
1655                                                  # ###########################################################################
1656                                                  # End VersionParser package
1657                                                  # ###########################################################################
1658                                                  
1659                                                  # ###########################################################################
1660                                                  # Quoter package 5266
1661                                                  # ###########################################################################
1662          16                   16           115   use strict;
              16                                 45   
              16                                 79   
1663          16                   16            96   use warnings FATAL => 'all';
              16                                 42   
              16                                 83   
1664                                                  
1665                                                  package Quoter;
1666                                                  
1667          16                   16            96   use English qw(-no_match_vars);
              16                                 38   
              16                                 81   
1668                                                  
1669  ***     16            50     16           113   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              16                                 43   
              16                                331   
1670                                                  
1671                                                  sub new {
1672          16                   16            70      my ( $class ) = @_;
1673          16                                161      bless {}, $class;
1674                                                  }
1675                                                  
1676                                                  sub quote {
1677  ***      0                    0                    my ( $self, @vals ) = @_;
1678  ***      0                                         foreach my $val ( @vals ) {
1679  ***      0                                            $val =~ s/`/``/g;
1680                                                     }
1681  ***      0                                         return join('.', map { '`' . $_ . '`' } @vals);
      ***      0                                      
1682                                                  }
1683                                                  
1684                                                  sub quote_val {
1685  ***      0                    0                    my ( $self, $val, $is_numeric ) = @_;
1686                                                  
1687  ***      0      0                                  return 'NULL' unless defined $val;  # undef = NULL
1688  ***      0      0                                  return "''" if $val eq '';          # blank string = ''
1689                                                  
1690  ***      0      0                                  if ( !defined $is_numeric ) {
1691  ***      0      0                                     $is_numeric = $val =~ m/^0|\D/ ? 0 : 1;
1692                                                     }
1693                                                  
1694  ***      0      0                                  return $val if $is_numeric;
1695                                                  
1696  ***      0                                         $val =~ s/(['\\])/\\$1/g;
1697  ***      0                                         return "'$val'";
1698                                                  }
1699                                                  
1700                                                  sub split_unquote {
1701  ***      0                    0                    my ( $self, $db_tbl, $default_db ) = @_;
1702  ***      0                                         $db_tbl =~ s/`//g;
1703  ***      0                                         my ( $db, $tbl ) = split(/[.]/, $db_tbl);
1704  ***      0      0                                  if ( !$tbl ) {
1705  ***      0                                            $tbl = $db;
1706  ***      0                                            $db  = $default_db;
1707                                                     }
1708  ***      0                                         return ($db, $tbl);
1709                                                  }
1710                                                  
1711                                                  sub literal_like {
1712  ***      0                    0                    my ( $self, $like ) = @_;
1713  ***      0      0                                  return unless $like;
1714  ***      0                                         $like =~ s/([%_])/\\$1/g;
1715  ***      0                                         return "'$like'";
1716                                                  }
1717                                                  
1718                                                  1;
1719                                                  
1720                                                  # ###########################################################################
1721                                                  # End Quoter package
1722                                                  # ###########################################################################
1723                                                  
1724                                                  # ###########################################################################
1725                                                  # TableNibbler package 5266
1726                                                  # ###########################################################################
1727                                                  package TableNibbler;
1728                                                  
1729          16                   16           118   use strict;
              16                                 42   
              16                                 83   
1730          16                   16            96   use warnings FATAL => 'all';
              16                                 40   
              16                                117   
1731                                                  
1732          16                   16            98   use English qw(-no_match_vars);
              16                                 42   
              16                                 83   
1733                                                  
1734  ***     16            50     16           110   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              16                                 44   
              16                                219   
1735                                                  
1736                                                  sub new {
1737  ***      0                    0                    my ( $class, %args ) = @_;
1738  ***      0                                         my @required_args = qw(TableParser Quoter);
1739  ***      0                                         foreach my $arg ( @required_args ) {
1740  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
1741                                                     }
1742  ***      0                                         my $self = { %args };
1743  ***      0                                         return bless $self, $class;
1744                                                  }
1745                                                  
1746                                                  sub generate_asc_stmt {
1747  ***      0                    0                    my ( $self, %args ) = @_;
1748  ***      0                                         my @required_args = qw(tbl_struct index);
1749  ***      0                                         foreach my $arg ( @required_args ) {
1750  ***      0      0                                     die "I need a $arg argument" unless defined $args{$arg};
1751                                                     }
1752  ***      0                                         my ($tbl_struct, $index) = @args{@required_args};
1753  ***      0      0                                  my @cols = $args{cols}  ? @{$args{cols}} : @{$tbl_struct->{cols}};
      ***      0                                      
      ***      0                                      
1754  ***      0                                         my $q    = $self->{Quoter};
1755                                                  
1756  ***      0      0                                  die "Index '$index' does not exist in table"
1757                                                        unless exists $tbl_struct->{keys}->{$index};
1758                                                  
1759  ***      0                                         my @asc_cols = @{$tbl_struct->{keys}->{$index}->{cols}};
      ***      0                                      
1760  ***      0                                         my @asc_slice;
1761                                                  
1762  ***      0                                         @asc_cols = @{$tbl_struct->{keys}->{$index}->{cols}};
      ***      0                                      
1763  ***      0                                         MKDEBUG && _d('Will ascend index', $index);
1764  ***      0                                         MKDEBUG && _d('Will ascend columns', join(', ', @asc_cols));
1765  ***      0      0                                  if ( $args{asc_first} ) {
1766  ***      0                                            @asc_cols = $asc_cols[0];
1767  ***      0                                            MKDEBUG && _d('Ascending only first column');
1768                                                     }
1769                                                  
1770  ***      0                                         my %col_posn = do { my $i = 0; map { $_ => $i++ } @cols };
      ***      0                                      
      ***      0                                      
      ***      0                                      
1771  ***      0                                         foreach my $col ( @asc_cols ) {
1772  ***      0      0                                     if ( !exists $col_posn{$col} ) {
1773  ***      0                                               push @cols, $col;
1774  ***      0                                               $col_posn{$col} = $#cols;
1775                                                        }
1776  ***      0                                            push @asc_slice, $col_posn{$col};
1777                                                     }
1778  ***      0                                         MKDEBUG && _d('Will ascend, in ordinal position:', join(', ', @asc_slice));
1779                                                  
1780  ***      0                                         my $asc_stmt = {
1781                                                        cols  => \@cols,
1782                                                        index => $index,
1783                                                        where => '',
1784                                                        slice => [],
1785                                                        scols => [],
1786                                                     };
1787                                                  
1788  ***      0      0                                  if ( @asc_slice ) {
1789  ***      0                                            my $cmp_where;
1790  ***      0                                            foreach my $cmp ( qw(< <= >= >) ) {
1791  ***      0                                               $cmp_where = $self->generate_cmp_where(
1792                                                              type        => $cmp,
1793                                                              slice       => \@asc_slice,
1794                                                              cols        => \@cols,
1795                                                              quoter      => $q,
1796                                                              is_nullable => $tbl_struct->{is_nullable},
1797                                                           );
1798  ***      0                                               $asc_stmt->{boundaries}->{$cmp} = $cmp_where->{where};
1799                                                        }
1800  ***      0      0                                     my $cmp = $args{asc_only} ? '>' : '>=';
1801  ***      0                                            $asc_stmt->{where} = $asc_stmt->{boundaries}->{$cmp};
1802  ***      0                                            $asc_stmt->{slice} = $cmp_where->{slice};
1803  ***      0                                            $asc_stmt->{scols} = $cmp_where->{scols};
1804                                                     }
1805                                                  
1806  ***      0                                         return $asc_stmt;
1807                                                  }
1808                                                  
1809                                                  sub generate_cmp_where {
1810  ***      0                    0                    my ( $self, %args ) = @_;
1811  ***      0                                         foreach my $arg ( qw(type slice cols is_nullable) ) {
1812  ***      0      0                                     die "I need a $arg arg" unless defined $args{$arg};
1813                                                     }
1814  ***      0                                         my @slice       = @{$args{slice}};
      ***      0                                      
1815  ***      0                                         my @cols        = @{$args{cols}};
      ***      0                                      
1816  ***      0                                         my $is_nullable = $args{is_nullable};
1817  ***      0                                         my $type        = $args{type};
1818  ***      0                                         my $q           = $self->{Quoter};
1819                                                  
1820  ***      0                                         (my $cmp = $type) =~ s/=//;
1821                                                  
1822  ***      0                                         my @r_slice;    # Resulting slice columns, by ordinal
1823  ***      0                                         my @r_scols;    # Ditto, by name
1824                                                  
1825  ***      0                                         my @clauses;
1826  ***      0                                         foreach my $i ( 0 .. $#slice ) {
1827  ***      0                                            my @clause;
1828                                                  
1829  ***      0                                            foreach my $j ( 0 .. $i - 1 ) {
1830  ***      0                                               my $ord = $slice[$j];
1831  ***      0                                               my $col = $cols[$ord];
1832  ***      0                                               my $quo = $q->quote($col);
1833  ***      0      0                                        if ( $is_nullable->{$col} ) {
1834  ***      0                                                  push @clause, "((? IS NULL AND $quo IS NULL) OR ($quo = ?))";
1835  ***      0                                                  push @r_slice, $ord, $ord;
1836  ***      0                                                  push @r_scols, $col, $col;
1837                                                           }
1838                                                           else {
1839  ***      0                                                  push @clause, "$quo = ?";
1840  ***      0                                                  push @r_slice, $ord;
1841  ***      0                                                  push @r_scols, $col;
1842                                                           }
1843                                                        }
1844                                                  
1845  ***      0                                            my $ord = $slice[$i];
1846  ***      0                                            my $col = $cols[$ord];
1847  ***      0                                            my $quo = $q->quote($col);
1848  ***      0                                            my $end = $i == $#slice; # Last clause of the whole group.
1849  ***      0      0                                     if ( $is_nullable->{$col} ) {
1850  ***      0      0      0                                 if ( $type =~ m/=/ && $end ) {
      ***             0                               
1851  ***      0                                                  push @clause, "(? IS NULL OR $quo $type ?)";
1852                                                           }
1853                                                           elsif ( $type =~ m/>/ ) {
1854  ***      0                                                  push @clause, "((? IS NULL AND $quo IS NOT NULL) OR ($quo $cmp ?))";
1855                                                           }
1856                                                           else { # If $type =~ m/</ ) {
1857  ***      0                                                  push @clause, "((? IS NOT NULL AND $quo IS NULL) OR ($quo $cmp ?))";
1858                                                           }
1859  ***      0                                               push @r_slice, $ord, $ord;
1860  ***      0                                               push @r_scols, $col, $col;
1861                                                        }
1862                                                        else {
1863  ***      0                                               push @r_slice, $ord;
1864  ***      0                                               push @r_scols, $col;
1865  ***      0      0      0                                 push @clause, ($type =~ m/=/ && $end ? "$quo $type ?" : "$quo $cmp ?");
1866                                                        }
1867                                                  
1868  ***      0                                            push @clauses, '(' . join(' AND ', @clause) . ')';
1869                                                     }
1870  ***      0                                         my $result = '(' . join(' OR ', @clauses) . ')';
1871  ***      0                                         my $where = {
1872                                                        slice => \@r_slice,
1873                                                        scols => \@r_scols,
1874                                                        where => $result,
1875                                                     };
1876  ***      0                                         return $where;
1877                                                  }
1878                                                  
1879                                                  sub generate_del_stmt {
1880  ***      0                    0                    my ( $self, %args ) = @_;
1881                                                  
1882  ***      0                                         my $tbl  = $args{tbl_struct};
1883  ***      0      0                                  my @cols = $args{cols} ? @{$args{cols}} : ();
      ***      0                                      
1884  ***      0                                         my $tp   = $self->{TableParser};
1885  ***      0                                         my $q    = $self->{Quoter};
1886                                                  
1887  ***      0                                         my @del_cols;
1888  ***      0                                         my @del_slice;
1889                                                  
1890  ***      0                                         my $index = $tp->find_best_index($tbl, $args{index});
1891  ***      0      0                                  die "Cannot find an ascendable index in table" unless $index;
1892                                                  
1893  ***      0      0                                  if ( $index ) {
1894  ***      0                                            @del_cols = @{$tbl->{keys}->{$index}->{cols}};
      ***      0                                      
1895                                                     }
1896                                                     else {
1897  ***      0                                            @del_cols = @{$tbl->{cols}};
      ***      0                                      
1898                                                     }
1899  ***      0                                         MKDEBUG && _d('Columns needed for DELETE:', join(', ', @del_cols));
1900                                                  
1901  ***      0                                         my %col_posn = do { my $i = 0; map { $_ => $i++ } @cols };
      ***      0                                      
      ***      0                                      
      ***      0                                      
1902  ***      0                                         foreach my $col ( @del_cols ) {
1903  ***      0      0                                     if ( !exists $col_posn{$col} ) {
1904  ***      0                                               push @cols, $col;
1905  ***      0                                               $col_posn{$col} = $#cols;
1906                                                        }
1907  ***      0                                            push @del_slice, $col_posn{$col};
1908                                                     }
1909  ***      0                                         MKDEBUG && _d('Ordinals needed for DELETE:', join(', ', @del_slice));
1910                                                  
1911  ***      0                                         my $del_stmt = {
1912                                                        cols  => \@cols,
1913                                                        index => $index,
1914                                                        where => '',
1915                                                        slice => [],
1916                                                        scols => [],
1917                                                     };
1918                                                  
1919  ***      0                                         my @clauses;
1920  ***      0                                         foreach my $i ( 0 .. $#del_slice ) {
1921  ***      0                                            my $ord = $del_slice[$i];
1922  ***      0                                            my $col = $cols[$ord];
1923  ***      0                                            my $quo = $q->quote($col);
1924  ***      0      0                                     if ( $tbl->{is_nullable}->{$col} ) {
1925  ***      0                                               push @clauses, "((? IS NULL AND $quo IS NULL) OR ($quo = ?))";
1926  ***      0                                               push @{$del_stmt->{slice}}, $ord, $ord;
      ***      0                                      
1927  ***      0                                               push @{$del_stmt->{scols}}, $col, $col;
      ***      0                                      
1928                                                        }
1929                                                        else {
1930  ***      0                                               push @clauses, "$quo = ?";
1931  ***      0                                               push @{$del_stmt->{slice}}, $ord;
      ***      0                                      
1932  ***      0                                               push @{$del_stmt->{scols}}, $col;
      ***      0                                      
1933                                                        }
1934                                                     }
1935                                                  
1936  ***      0                                         $del_stmt->{where} = '(' . join(' AND ', @clauses) . ')';
1937                                                  
1938  ***      0                                         return $del_stmt;
1939                                                  }
1940                                                  
1941                                                  sub generate_ins_stmt {
1942  ***      0                    0                    my ( $self, %args ) = @_;
1943  ***      0                                         foreach my $arg ( qw(ins_tbl sel_cols) ) {
1944  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
1945                                                     }
1946  ***      0                                         my $ins_tbl  = $args{ins_tbl};
1947  ***      0                                         my @sel_cols = @{$args{sel_cols}};
      ***      0                                      
1948                                                  
1949  ***      0      0                                  die "You didn't specify any SELECT columns" unless @sel_cols;
1950                                                  
1951  ***      0                                         my @ins_cols;
1952  ***      0                                         my @ins_slice;
1953  ***      0                                         for my $i ( 0..$#sel_cols ) {
1954  ***      0      0                                     next unless $ins_tbl->{is_col}->{$sel_cols[$i]};
1955  ***      0                                            push @ins_cols, $sel_cols[$i];
1956  ***      0                                            push @ins_slice, $i;
1957                                                     }
1958                                                  
1959                                                     return {
1960  ***      0                                            cols  => \@ins_cols,
1961                                                        slice => \@ins_slice,
1962                                                     };
1963                                                  }
1964                                                  
1965                                                  sub _d {
1966  ***      0                    0                    my ($package, undef, $line) = caller 0;
1967  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1968  ***      0                                              map { defined $_ ? $_ : 'undef' }
1969                                                          @_;
1970  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1971                                                  }
1972                                                  
1973                                                  1;
1974                                                  
1975                                                  # ###########################################################################
1976                                                  # End TableNibbler package
1977                                                  # ###########################################################################
1978                                                  
1979                                                  # ###########################################################################
1980                                                  # MySQLDump package 5266
1981                                                  # ###########################################################################
1982                                                  package MySQLDump;
1983                                                  
1984          16                   16           119   use strict;
              16                                 39   
              16                               3241   
1985          16                   16           587   use warnings FATAL => 'all';
              16                                278   
              16                                 85   
1986                                                  
1987          16                   16            88   use English qw(-no_match_vars);
              16                                 38   
              16                                 77   
1988                                                  
1989  ***     16            50     16           104   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              16                                 34   
              16                                222   
1990                                                  
1991                                                  ( our $before = <<'EOF') =~ s/^   //gm;
1992                                                     /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
1993                                                     /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
1994                                                     /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
1995                                                     /*!40101 SET NAMES utf8 */;
1996                                                     /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
1997                                                     /*!40103 SET TIME_ZONE='+00:00' */;
1998                                                     /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
1999                                                     /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
2000                                                     /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
2001                                                     /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
2002                                                  EOF
2003                                                  
2004                                                  ( our $after = <<'EOF') =~ s/^   //gm;
2005                                                     /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
2006                                                     /*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
2007                                                     /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
2008                                                     /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
2009                                                     /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
2010                                                     /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
2011                                                     /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
2012                                                     /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
2013                                                  EOF
2014                                                  
2015                                                  sub new {
2016  ***      0                    0                    my ( $class, %args ) = @_;
2017  ***      0      0                                  $args{cache} = 1 unless defined $args{cache};
2018  ***      0                                         my $self = bless \%args, $class;
2019  ***      0                                         return $self;
2020                                                  }
2021                                                  
2022                                                  sub dump {
2023  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $tbl, $what ) = @_;
2024                                                  
2025  ***      0      0                                  if ( $what eq 'table' ) {
      ***             0                               
      ***             0                               
2026  ***      0                                            my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
2027  ***      0      0                                     return unless $ddl;
2028  ***      0      0                                     if ( $ddl->[0] eq 'table' ) {
2029  ***      0                                               return $before
2030                                                              . 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
2031                                                              . $ddl->[1] . ";\n";
2032                                                        }
2033                                                        else {
2034  ***      0                                               return 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
2035                                                              . '/*!50001 DROP VIEW IF EXISTS '
2036                                                              . $quoter->quote($tbl) . "*/;\n/*!50001 "
2037                                                              . $self->get_tmp_table($dbh, $quoter, $db, $tbl) . "*/;\n";
2038                                                        }
2039                                                     }
2040                                                     elsif ( $what eq 'triggers' ) {
2041  ***      0                                            my $trgs = $self->get_triggers($dbh, $quoter, $db, $tbl);
2042  ***      0      0      0                              if ( $trgs && @$trgs ) {
2043  ***      0                                               my $result = $before . "\nDELIMITER ;;\n";
2044  ***      0                                               foreach my $trg ( @$trgs ) {
2045  ***      0      0                                           if ( $trg->{sql_mode} ) {
2046  ***      0                                                     $result .= qq{/*!50003 SET SESSION SQL_MODE='$trg->{sql_mode}' */;;\n};
2047                                                              }
2048  ***      0                                                  $result .= "/*!50003 CREATE */ ";
2049  ***      0      0                                           if ( $trg->{definer} ) {
2050  ***      0                                                     my ( $user, $host )
2051  ***      0                                                        = map { s/'/''/g; "'$_'"; }
      ***      0                                      
2052                                                                      split('@', $trg->{definer}, 2);
2053  ***      0                                                     $result .= "/*!50017 DEFINER=$user\@$host */ ";
2054                                                              }
2055  ***      0                                                  $result .= sprintf("/*!50003 TRIGGER %s %s %s ON %s\nFOR EACH ROW %s */;;\n\n",
2056                                                                 $quoter->quote($trg->{trigger}),
2057  ***      0                                                     @{$trg}{qw(timing event)},
2058                                                                 $quoter->quote($trg->{table}),
2059                                                                 $trg->{statement});
2060                                                           }
2061  ***      0                                               $result .= "DELIMITER ;\n\n/*!50003 SET SESSION SQL_MODE=\@OLD_SQL_MODE */;\n\n";
2062  ***      0                                               return $result;
2063                                                        }
2064                                                        else {
2065  ***      0                                               return undef;
2066                                                        }
2067                                                     }
2068                                                     elsif ( $what eq 'view' ) {
2069  ***      0                                            my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
2070  ***      0                                            return '/*!50001 DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
2071                                                           . '/*!50001 DROP VIEW IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
2072                                                           . '/*!50001 ' . $ddl->[1] . "*/;\n";
2073                                                     }
2074                                                     else {
2075  ***      0                                            die "You didn't say what to dump.";
2076                                                     }
2077                                                  }
2078                                                  
2079                                                  sub _use_db {
2080  ***      0                    0                    my ( $self, $dbh, $quoter, $new ) = @_;
2081  ***      0      0                                  if ( !$new ) {
2082  ***      0                                            MKDEBUG && _d('No new DB to use');
2083  ***      0                                            return;
2084                                                     }
2085  ***      0                                         my $sql = 'SELECT DATABASE()';
2086  ***      0                                         MKDEBUG && _d($sql);
2087  ***      0                                         my $curr = $dbh->selectrow_array($sql);
2088  ***      0      0      0                           if ( $curr && $new && $curr eq $new ) {
      ***                    0                        
2089  ***      0                                            MKDEBUG && _d('Current and new DB are the same');
2090  ***      0                                            return $curr;
2091                                                     }
2092  ***      0                                         $sql = 'USE ' . $quoter->quote($new);
2093  ***      0                                         MKDEBUG && _d($sql);
2094  ***      0                                         $dbh->do($sql);
2095  ***      0                                         return $curr;
2096                                                  }
2097                                                  
2098                                                  sub get_create_table {
2099  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2100  ***      0      0      0                           if ( !$self->{cache} || !$self->{tables}->{$db}->{$tbl} ) {
2101  ***      0                                            my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
2102                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
2103                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
2104                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
2105  ***      0                                            MKDEBUG && _d($sql);
2106  ***      0                                            eval { $dbh->do($sql); };
      ***      0                                      
2107  ***      0                                            MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2108  ***      0                                            my $curr_db = $self->_use_db($dbh, $quoter, $db);
2109  ***      0                                            $sql = "SHOW CREATE TABLE " . $quoter->quote($db, $tbl);
2110  ***      0                                            MKDEBUG && _d($sql);
2111  ***      0                                            my $href;
2112  ***      0                                            eval { $href = $dbh->selectrow_hashref($sql); };
      ***      0                                      
2113  ***      0      0                                     if ( $EVAL_ERROR ) {
2114  ***      0                                               warn "Failed to $sql.  The table may be damaged.\nError: $EVAL_ERROR";
2115  ***      0                                               return;
2116                                                        }
2117  ***      0                                            $self->_use_db($dbh, $quoter, $curr_db);
2118  ***      0                                            $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
2119                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
2120  ***      0                                            MKDEBUG && _d($sql);
2121  ***      0                                            $dbh->do($sql);
2122  ***      0                                            my ($key) = grep { m/create table/i } keys %$href;
      ***      0                                      
2123  ***      0      0                                     if ( $key ) {
2124  ***      0                                               MKDEBUG && _d('This table is a base table');
2125  ***      0                                               $self->{tables}->{$db}->{$tbl} = [ 'table', $href->{$key} ];
2126                                                        }
2127                                                        else {
2128  ***      0                                               MKDEBUG && _d('This table is a view');
2129  ***      0                                               ($key) = grep { m/create view/i } keys %$href;
      ***      0                                      
2130  ***      0                                               $self->{tables}->{$db}->{$tbl} = [ 'view', $href->{$key} ];
2131                                                        }
2132                                                     }
2133  ***      0                                         return $self->{tables}->{$db}->{$tbl};
2134                                                  }
2135                                                  
2136                                                  sub get_columns {
2137  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2138  ***      0                                         MKDEBUG && _d('Get columns for', $db, $tbl);
2139  ***      0      0      0                           if ( !$self->{cache} || !$self->{columns}->{$db}->{$tbl} ) {
2140  ***      0                                            my $curr_db = $self->_use_db($dbh, $quoter, $db);
2141  ***      0                                            my $sql = "SHOW COLUMNS FROM " . $quoter->quote($db, $tbl);
2142  ***      0                                            MKDEBUG && _d($sql);
2143  ***      0                                            my $cols = $dbh->selectall_arrayref($sql, { Slice => {} });
2144  ***      0                                            $self->_use_db($dbh, $quoter, $curr_db);
2145  ***      0                                            $self->{columns}->{$db}->{$tbl} = [
2146                                                           map {
2147  ***      0                                                  my %row;
2148  ***      0                                                  @row{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                      
2149  ***      0                                                  \%row;
2150                                                           } @$cols
2151                                                        ];
2152                                                     }
2153  ***      0                                         return $self->{columns}->{$db}->{$tbl};
2154                                                  }
2155                                                  
2156                                                  sub get_tmp_table {
2157  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2158  ***      0                                         my $result = 'CREATE TABLE ' . $quoter->quote($tbl) . " (\n";
2159  ***      0                                         $result .= join(",\n",
2160  ***      0                                            map { '  ' . $quoter->quote($_->{field}) . ' ' . $_->{type} }
2161  ***      0                                            @{$self->get_columns($dbh, $quoter, $db, $tbl)});
2162  ***      0                                         $result .= "\n)";
2163  ***      0                                         MKDEBUG && _d($result);
2164  ***      0                                         return $result;
2165                                                  }
2166                                                  
2167                                                  sub get_triggers {
2168  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2169  ***      0      0      0                           if ( !$self->{cache} || !$self->{triggers}->{$db} ) {
2170  ***      0                                            $self->{triggers}->{$db} = {};
2171  ***      0                                            my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
2172                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
2173                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
2174                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
2175  ***      0                                            MKDEBUG && _d($sql);
2176  ***      0                                            eval { $dbh->do($sql); };
      ***      0                                      
2177  ***      0                                            MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2178  ***      0                                            $sql = "SHOW TRIGGERS FROM " . $quoter->quote($db);
2179  ***      0                                            MKDEBUG && _d($sql);
2180  ***      0                                            my $sth = $dbh->prepare($sql);
2181  ***      0                                            $sth->execute();
2182  ***      0      0                                     if ( $sth->rows ) {
2183  ***      0                                               my $trgs = $sth->fetchall_arrayref({});
2184  ***      0                                               foreach my $trg (@$trgs) {
2185  ***      0                                                  my %trg;
2186  ***      0                                                  @trg{ map { lc $_ } keys %$trg } = values %$trg;
      ***      0                                      
2187  ***      0                                                  push @{ $self->{triggers}->{$db}->{ $trg{table} } }, \%trg;
      ***      0                                      
2188                                                           }
2189                                                        }
2190  ***      0                                            $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
2191                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
2192  ***      0                                            MKDEBUG && _d($sql);
2193  ***      0                                            $dbh->do($sql);
2194                                                     }
2195  ***      0      0                                  if ( $tbl ) {
2196  ***      0                                            return $self->{triggers}->{$db}->{$tbl};
2197                                                     }
2198  ***      0                                         return values %{$self->{triggers}->{$db}};
      ***      0                                      
2199                                                  }
2200                                                  
2201                                                  sub get_databases {
2202  ***      0                    0                    my ( $self, $dbh, $quoter, $like ) = @_;
2203  ***      0      0      0                           if ( !$self->{cache} || !$self->{databases} || $like ) {
      ***                    0                        
2204  ***      0                                            my $sql = 'SHOW DATABASES';
2205  ***      0                                            my @params;
2206  ***      0      0                                     if ( $like ) {
2207  ***      0                                               $sql .= ' LIKE ?';
2208  ***      0                                               push @params, $like;
2209                                                        }
2210  ***      0                                            my $sth = $dbh->prepare($sql);
2211  ***      0                                            MKDEBUG && _d($sql, @params);
2212  ***      0                                            $sth->execute( @params );
2213  ***      0                                            my @dbs = map { $_->[0] } @{$sth->fetchall_arrayref()};
      ***      0                                      
      ***      0                                      
2214  ***      0      0                                     $self->{databases} = \@dbs unless $like;
2215  ***      0                                            return @dbs;
2216                                                     }
2217  ***      0                                         return @{$self->{databases}};
      ***      0                                      
2218                                                  }
2219                                                  
2220                                                  sub get_table_status {
2221  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $like ) = @_;
2222  ***      0      0      0                           if ( !$self->{cache} || !$self->{table_status}->{$db} || $like ) {
      ***                    0                        
2223  ***      0                                            my $sql = "SHOW TABLE STATUS FROM " . $quoter->quote($db);
2224  ***      0                                            my @params;
2225  ***      0      0                                     if ( $like ) {
2226  ***      0                                               $sql .= ' LIKE ?';
2227  ***      0                                               push @params, $like;
2228                                                        }
2229  ***      0                                            MKDEBUG && _d($sql, @params);
2230  ***      0                                            my $sth = $dbh->prepare($sql);
2231  ***      0                                            $sth->execute(@params);
2232  ***      0                                            my @tables = @{$sth->fetchall_arrayref({})};
      ***      0                                      
2233  ***      0                                            @tables = map {
2234  ***      0                                               my %tbl; # Make a copy with lowercased keys
2235  ***      0                                               @tbl{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                      
2236  ***      0             0                                 $tbl{engine} ||= $tbl{type} || $tbl{comment};
      ***                    0                        
2237  ***      0                                               delete $tbl{type};
2238  ***      0                                               \%tbl;
2239                                                        } @tables;
2240  ***      0      0                                     $self->{table_status}->{$db} = \@tables unless $like;
2241  ***      0                                            return @tables;
2242                                                     }
2243  ***      0                                         return @{$self->{table_status}->{$db}};
      ***      0                                      
2244                                                  }
2245                                                  
2246                                                  sub get_table_list {
2247  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $like ) = @_;
2248  ***      0      0      0                           if ( !$self->{cache} || !$self->{table_list}->{$db} || $like ) {
      ***                    0                        
2249  ***      0                                            my $sql = "SHOW /*!50002 FULL*/ TABLES FROM " . $quoter->quote($db);
2250  ***      0                                            my @params;
2251  ***      0      0                                     if ( $like ) {
2252  ***      0                                               $sql .= ' LIKE ?';
2253  ***      0                                               push @params, $like;
2254                                                        }
2255  ***      0                                            MKDEBUG && _d($sql, @params);
2256  ***      0                                            my $sth = $dbh->prepare($sql);
2257  ***      0                                            $sth->execute(@params);
2258  ***      0                                            my @tables = @{$sth->fetchall_arrayref()};
      ***      0                                      
2259  ***      0      0      0                              @tables = map {
2260  ***      0                                               my %tbl = (
2261                                                              name   => $_->[0],
2262                                                              engine => ($_->[1] || '') eq 'VIEW' ? 'VIEW' : '',
2263                                                           );
2264  ***      0                                               \%tbl;
2265                                                        } @tables;
2266  ***      0      0                                     $self->{table_list}->{$db} = \@tables unless $like;
2267  ***      0                                            return @tables;
2268                                                     }
2269  ***      0                                         return @{$self->{table_list}->{$db}};
      ***      0                                      
2270                                                  }
2271                                                  
2272                                                  sub _d {
2273  ***      0                    0                    my ($package, undef, $line) = caller 0;
2274  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2275  ***      0                                              map { defined $_ ? $_ : 'undef' }
2276                                                          @_;
2277  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2278                                                  }
2279                                                  
2280                                                  1;
2281                                                  
2282                                                  # ###########################################################################
2283                                                  # End MySQLDump package
2284                                                  # ###########################################################################
2285                                                  
2286                                                  # ###########################################################################
2287                                                  # Daemon package 5266
2288                                                  # ###########################################################################
2289                                                  
2290                                                  package Daemon;
2291                                                  
2292          16                   16           122   use strict;
              16                                109   
              16                                 89   
2293          16                   16           109   use warnings FATAL => 'all';
              16                                 37   
              16                                 93   
2294                                                  
2295          16                   16            99   use POSIX qw(setsid);
              16                                 35   
              16                                107   
2296          16                   16            97   use English qw(-no_match_vars);
              16                                 41   
              16                                 89   
2297                                                  
2298  ***     16            50     16           103   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              16                                 39   
              16                                232   
2299                                                  
2300                                                  sub new {
2301  ***      0                    0                    my ( $class, %args ) = @_;
2302  ***      0                                         foreach my $arg ( qw(o) ) {
2303  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
2304                                                     }
2305  ***      0                                         my $o = $args{o};
2306  ***      0      0                                  my $self = {
      ***             0                               
2307                                                        o        => $o,
2308                                                        log_file => $o->has('log') ? $o->get('log') : undef,
2309                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
2310                                                     };
2311                                                  
2312  ***      0                                         check_PID_file(undef, $self->{PID_file});
2313                                                  
2314  ***      0                                         MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
2315  ***      0                                         return bless $self, $class;
2316                                                  }
2317                                                  
2318                                                  sub daemonize {
2319  ***      0                    0                    my ( $self ) = @_;
2320                                                  
2321  ***      0                                         MKDEBUG && _d('About to fork and daemonize');
2322  ***      0      0                                  defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
2323  ***      0      0                                  if ( $pid ) {
2324  ***      0                                            MKDEBUG && _d('I am the parent and now I die');
2325  ***      0                                            exit;
2326                                                     }
2327                                                  
2328  ***      0                                         $self->{child} = 1;
2329                                                  
2330  ***      0      0                                  POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
2331  ***      0      0                                  chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
2332                                                  
2333  ***      0                                         $self->_make_PID_file();
2334                                                  
2335  ***      0                                         $OUTPUT_AUTOFLUSH = 1;
2336                                                  
2337  ***      0      0                                  if ( -t STDIN ) {
2338  ***      0                                            close STDIN;
2339  ***      0      0                                     open  STDIN, '/dev/null'
2340                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
2341                                                     }
2342                                                  
2343  ***      0      0                                  if ( $self->{log_file} ) {
2344  ***      0                                            close STDOUT;
2345  ***      0      0                                     open  STDOUT, '>>', $self->{log_file}
2346                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
2347                                                  
2348  ***      0                                            close STDERR;
2349  ***      0      0                                     open  STDERR, ">&STDOUT"
2350                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
2351                                                     }
2352                                                     else {
2353  ***      0      0                                     if ( -t STDOUT ) {
2354  ***      0                                               close STDOUT;
2355  ***      0      0                                        open  STDOUT, '>', '/dev/null'
2356                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
2357                                                        }
2358  ***      0      0                                     if ( -t STDERR ) {
2359  ***      0                                               close STDERR;
2360  ***      0      0                                        open  STDERR, '>', '/dev/null'
2361                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
2362                                                        }
2363                                                     }
2364                                                  
2365  ***      0                                         MKDEBUG && _d('I am the child and now I live daemonized');
2366  ***      0                                         return;
2367                                                  }
2368                                                  
2369                                                  sub check_PID_file {
2370  ***      0                    0                    my ( $self, $file ) = @_;
2371  ***      0      0                                  my $PID_file = $self ? $self->{PID_file} : $file;
2372  ***      0                                         MKDEBUG && _d('Checking PID file', $PID_file);
2373  ***      0      0      0                           if ( $PID_file && -f $PID_file ) {
2374  ***      0                                            my $pid;
2375  ***      0                                            eval { chomp($pid = `cat $PID_file`); };
      ***      0                                      
2376  ***      0      0                                     die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
2377  ***      0                                            MKDEBUG && _d('PID file exists; it contains PID', $pid);
2378  ***      0      0                                     if ( $pid ) {
2379  ***      0                                               my $pid_is_alive = kill 0, $pid;
2380  ***      0      0                                        if ( $pid_is_alive ) {
2381  ***      0                                                  die "The PID file $PID_file already exists "
2382                                                                 . " and the PID that it contains, $pid, is running";
2383                                                           }
2384                                                           else {
2385  ***      0                                                  warn "Overwriting PID file $PID_file because the PID that it "
2386                                                                 . "contains, $pid, is not running";
2387                                                           }
2388                                                        }
2389                                                        else {
2390  ***      0                                               die "The PID file $PID_file already exists but it does not "
2391                                                              . "contain a PID";
2392                                                        }
2393                                                     }
2394                                                     else {
2395  ***      0                                            MKDEBUG && _d('No PID file');
2396                                                     }
2397  ***      0                                         return;
2398                                                  }
2399                                                  
2400                                                  sub make_PID_file {
2401  ***      0                    0                    my ( $self ) = @_;
2402  ***      0      0                                  if ( exists $self->{child} ) {
2403  ***      0                                            die "Do not call Daemon::make_PID_file() for daemonized scripts";
2404                                                     }
2405  ***      0                                         $self->_make_PID_file();
2406  ***      0                                         $self->{rm_PID_file} = 1;
2407  ***      0                                         return;
2408                                                  }
2409                                                  
2410                                                  sub _make_PID_file {
2411  ***      0                    0                    my ( $self ) = @_;
2412                                                  
2413  ***      0                                         my $PID_file = $self->{PID_file};
2414  ***      0      0                                  if ( !$PID_file ) {
2415  ***      0                                            MKDEBUG && _d('No PID file to create');
2416  ***      0                                            return;
2417                                                     }
2418                                                  
2419  ***      0                                         $self->check_PID_file();
2420                                                  
2421  ***      0      0                                  open my $PID_FH, '>', $PID_file
2422                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
2423  ***      0      0                                  print $PID_FH $PID
2424                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
2425  ***      0      0                                  close $PID_FH
2426                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
2427                                                  
2428  ***      0                                         MKDEBUG && _d('Created PID file:', $self->{PID_file});
2429  ***      0                                         return;
2430                                                  }
2431                                                  
2432                                                  sub _remove_PID_file {
2433  ***      0                    0                    my ( $self ) = @_;
2434  ***      0      0      0                           if ( $self->{PID_file} && -f $self->{PID_file} ) {
2435  ***      0      0                                     unlink $self->{PID_file}
2436                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
2437  ***      0                                            MKDEBUG && _d('Removed PID file');
2438                                                     }
2439                                                     else {
2440  ***      0                                            MKDEBUG && _d('No PID to remove');
2441                                                     }
2442  ***      0                                         return;
2443                                                  }
2444                                                  
2445                                                  sub DESTROY {
2446  ***      0                    0                    my ( $self ) = @_;
2447  ***      0      0      0                           $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
2448  ***      0                                         return;
2449                                                  }
2450                                                  
2451                                                  sub _d {
2452  ***      0                    0                    my ($package, undef, $line) = caller 0;
2453  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2454  ***      0                                              map { defined $_ ? $_ : 'undef' }
2455                                                          @_;
2456  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2457                                                  }
2458                                                  
2459                                                  1;
2460                                                  
2461                                                  # ###########################################################################
2462                                                  # End Daemon package
2463                                                  # ###########################################################################
2464                                                  
2465                                                  # ###########################################################################
2466                                                  # MasterSlave package 5362
2467                                                  # ###########################################################################
2468          16                   16           116   use strict;
              16                                 43   
              16                                 88   
2469          16                   16            92   use warnings FATAL => 'all';
              16                                 42   
              16                                 80   
2470                                                  
2471                                                  package MasterSlave;
2472                                                  
2473          16                   16            97   use English qw(-no_match_vars);
              16                                 38   
              16                                 99   
2474          16                   16           113   use List::Util qw(min max);
              16                                 40   
              16                                 95   
2475          16                   16            96   use Data::Dumper;
              16                                 41   
              16                                 92   
2476                                                  $Data::Dumper::Quotekeys = 0;
2477                                                  $Data::Dumper::Indent    = 0;
2478                                                  
2479  ***     16            50     16           101   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              16                                 41   
              16                                228   
2480                                                  
2481                                                  sub new {
2482  ***      0                    0                    bless {}, shift;
2483                                                  }
2484                                                  
2485                                                  sub recurse_to_slaves {
2486  ***      0                    0                    my ( $self, $args, $level ) = @_;
2487  ***      0             0                           $level ||= 0;
2488  ***      0                                         my $dp   = $args->{dsn_parser};
2489  ***      0                                         my $dsn  = $args->{dsn};
2490                                                  
2491  ***      0                                         my $dbh;
2492  ***      0                                         eval {
2493  ***      0             0                              $dbh = $args->{dbh} || $dp->get_dbh(
2494                                                           $dp->get_cxn_params($dsn), { AutoCommit => 1 });
2495  ***      0                                            MKDEBUG && _d('Connected to', $dp->as_string($dsn));
2496                                                     };
2497  ***      0      0                                  if ( $EVAL_ERROR ) {
2498  ***      0      0                                     print STDERR "Cannot connect to ", $dp->as_string($dsn), "\n"
2499                                                           or die "Cannot print: $OS_ERROR";
2500  ***      0                                            return;
2501                                                     }
2502                                                  
2503  ***      0                                         my $sql  = 'SELECT @@SERVER_ID';
2504  ***      0                                         MKDEBUG && _d($sql);
2505  ***      0                                         my ($id) = $dbh->selectrow_array($sql);
2506  ***      0                                         MKDEBUG && _d('Working on server ID', $id);
2507  ***      0                                         my $master_thinks_i_am = $dsn->{server_id};
2508  ***      0      0      0                           if ( !defined $id
      ***                    0                        
      ***                    0                        
2509                                                         || ( defined $master_thinks_i_am && $master_thinks_i_am != $id )
2510                                                         || $args->{server_ids_seen}->{$id}++
2511                                                     ) {
2512  ***      0                                            MKDEBUG && _d('Server ID seen, or not what master said');
2513  ***      0      0                                     if ( $args->{skip_callback} ) {
2514  ***      0                                               $args->{skip_callback}->($dsn, $dbh, $level, $args->{parent});
2515                                                        }
2516  ***      0                                            return;
2517                                                     }
2518                                                  
2519  ***      0                                         $args->{callback}->($dsn, $dbh, $level, $args->{parent});
2520                                                  
2521  ***      0      0      0                           if ( !defined $args->{recurse} || $level < $args->{recurse} ) {
2522                                                  
2523  ***      0      0                                     my @slaves =
2524  ***      0                                               grep { !$_->{master_id} || $_->{master_id} == $id } # Only my slaves.
2525                                                           $self->find_slave_hosts($dp, $dbh, $dsn, $args->{method});
2526                                                  
2527  ***      0                                            foreach my $slave ( @slaves ) {
2528  ***      0                                               MKDEBUG && _d('Recursing from',
2529                                                              $dp->as_string($dsn), 'to', $dp->as_string($slave));
2530  ***      0                                               $self->recurse_to_slaves(
2531                                                              { %$args, dsn => $slave, dbh => undef, parent => $dsn }, $level + 1 );
2532                                                        }
2533                                                     }
2534                                                  }
2535                                                  
2536                                                  sub find_slave_hosts {
2537  ***      0                    0                    my ( $self, $dsn_parser, $dbh, $dsn, $method ) = @_;
2538                                                  
2539  ***      0                                         my @methods = qw(processlist hosts);
2540  ***      0      0                                  if ( $method ) {
2541  ***      0                                            @methods = grep { $_ ne $method } @methods;
      ***      0                                      
2542  ***      0                                            unshift @methods, $method;
2543                                                     }
2544                                                     else {
2545  ***      0      0      0                              if ( ($dsn->{P} || 3306) != 3306 ) {
2546  ***      0                                               MKDEBUG && _d('Port number is non-standard; using only hosts method');
2547  ***      0                                               @methods = qw(hosts);
2548                                                        }
2549                                                     }
2550  ***      0                                         MKDEBUG && _d('Looking for slaves on', $dsn_parser->as_string($dsn),
2551                                                        'using methods', @methods);
2552                                                  
2553  ***      0                                         my @slaves;
2554                                                     METHOD:
2555  ***      0                                         foreach my $method ( @methods ) {
2556  ***      0                                            my $find_slaves = "_find_slaves_by_$method";
2557  ***      0                                            MKDEBUG && _d('Finding slaves with', $find_slaves);
2558  ***      0                                            @slaves = $self->$find_slaves($dsn_parser, $dbh, $dsn);
2559  ***      0      0                                     last METHOD if @slaves;
2560                                                     }
2561                                                  
2562  ***      0                                         MKDEBUG && _d('Found', scalar(@slaves), 'slaves');
2563  ***      0                                         return @slaves;
2564                                                  }
2565                                                  
2566                                                  sub _find_slaves_by_processlist {
2567  ***      0                    0                    my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
2568                                                  
2569  ***      0                                         my @slaves = map  {
2570  ***      0                                            my $slave        = $dsn_parser->parse("h=$_", $dsn);
2571  ***      0                                            $slave->{source} = 'processlist';
2572  ***      0                                            $slave;
2573                                                     }
2574  ***      0                                         grep { $_ }
2575                                                     map  {
2576  ***      0                                            my ( $host ) = $_->{host} =~ m/^([^:]+):/;
2577  ***      0      0                                     if ( $host eq 'localhost' ) {
2578  ***      0                                               $host = '127.0.0.1'; # Replication never uses sockets.
2579                                                        }
2580  ***      0                                            $host;
2581                                                     } $self->get_connected_slaves($dbh);
2582                                                  
2583  ***      0                                         return @slaves;
2584                                                  }
2585                                                  
2586                                                  sub _find_slaves_by_hosts {
2587  ***      0                    0                    my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
2588                                                  
2589  ***      0                                         my @slaves;
2590  ***      0                                         my $sql = 'SHOW SLAVE HOSTS';
2591  ***      0                                         MKDEBUG && _d($dbh, $sql);
2592  ***      0                                         @slaves = @{$dbh->selectall_arrayref($sql, { Slice => {} })};
      ***      0                                      
2593                                                  
2594  ***      0      0                                  if ( @slaves ) {
2595  ***      0                                            MKDEBUG && _d('Found some SHOW SLAVE HOSTS info');
2596  ***      0                                            @slaves = map {
2597  ***      0                                               my %hash;
2598  ***      0                                               @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                      
2599  ***      0      0                                        my $spec = "h=$hash{host},P=$hash{port}"
      ***             0                               
2600                                                              . ( $hash{user} ? ",u=$hash{user}" : '')
2601                                                              . ( $hash{password} ? ",p=$hash{password}" : '');
2602  ***      0                                               my $dsn           = $dsn_parser->parse($spec, $dsn);
2603  ***      0                                               $dsn->{server_id} = $hash{server_id};
2604  ***      0                                               $dsn->{master_id} = $hash{master_id};
2605  ***      0                                               $dsn->{source}    = 'hosts';
2606  ***      0                                               $dsn;
2607                                                        } @slaves;
2608                                                     }
2609                                                  
2610  ***      0                                         return @slaves;
2611                                                  }
2612                                                  
2613                                                  sub get_connected_slaves {
2614  ***      0                    0                    my ( $self, $dbh ) = @_;
2615                                                  
2616  ***      0                                         my $proc =
2617  ***      0                                            grep { m/ALL PRIVILEGES.*?\*\.\*|PROCESS/ }
2618  ***      0                                            @{$dbh->selectcol_arrayref('SHOW GRANTS')};
2619  ***      0      0                                  if ( !$proc ) {
2620  ***      0                                            die "You do not have the PROCESS privilege";
2621                                                     }
2622                                                  
2623  ***      0                                         my $sql = 'SHOW PROCESSLIST';
2624  ***      0                                         MKDEBUG && _d($dbh, $sql);
2625  ***      0                                         grep { $_->{command} =~ m/Binlog Dump/i }
      ***      0                                      
2626                                                     map  { # Lowercase the column names
2627  ***      0                                            my %hash;
2628  ***      0                                            @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                      
2629  ***      0                                            \%hash;
2630                                                     }
2631  ***      0                                         @{$dbh->selectall_arrayref($sql, { Slice => {} })};
2632                                                  }
2633                                                  
2634                                                  sub is_master_of {
2635  ***      0                    0                    my ( $self, $master, $slave ) = @_;
2636  ***      0      0                                  my $master_status = $self->get_master_status($master)
2637                                                        or die "The server specified as a master is not a master";
2638  ***      0      0                                  my $slave_status  = $self->get_slave_status($slave)
2639                                                        or die "The server specified as a slave is not a slave";
2640  ***      0      0                                  my @connected     = $self->get_connected_slaves($master)
2641                                                        or die "The server specified as a master has no connected slaves";
2642  ***      0                                         my (undef, $port) = $master->selectrow_array('SHOW VARIABLES LIKE "port"');
2643                                                  
2644  ***      0      0                                  if ( $port != $slave_status->{master_port} ) {
2645  ***      0                                            die "The slave is connected to $slave_status->{master_port} "
2646                                                           . "but the master's port is $port";
2647                                                     }
2648                                                  
2649  ***      0      0                                  if ( !grep { $slave_status->{master_user} eq $_->{user} } @connected ) {
      ***      0                                      
2650  ***      0                                            die "I don't see any slave I/O thread connected with user "
2651                                                           . $slave_status->{master_user};
2652                                                     }
2653                                                  
2654  ***      0      0      0                           if ( ($slave_status->{slave_io_state} || '')
2655                                                        eq 'Waiting for master to send event' )
2656                                                     {
2657  ***      0                                            my ( $master_log_name, $master_log_num )
2658                                                           = $master_status->{file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
2659  ***      0                                            my ( $slave_log_name, $slave_log_num )
2660                                                           = $slave_status->{master_log_file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
2661  ***      0      0      0                              if ( $master_log_name ne $slave_log_name
2662                                                           || abs($master_log_num - $slave_log_num) > 1 )
2663                                                        {
2664  ***      0                                               die "The slave thinks it is reading from "
2665                                                              . "$slave_status->{master_log_file},  but the "
2666                                                              . "master is writing to $master_status->{file}";
2667                                                        }
2668                                                     }
2669  ***      0                                         return 1;
2670                                                  }
2671                                                  
2672                                                  sub get_master_dsn {
2673  ***      0                    0                    my ( $self, $dbh, $dsn, $dsn_parser ) = @_;
2674  ***      0      0                                  my $master = $self->get_slave_status($dbh) or return undef;
2675  ***      0                                         my $spec   = "h=$master->{master_host},P=$master->{master_port}";
2676  ***      0                                         return       $dsn_parser->parse($spec, $dsn);
2677                                                  }
2678                                                  
2679                                                  sub get_slave_status {
2680  ***      0                    0                    my ( $self, $dbh ) = @_;
2681  ***      0      0                                  if ( !$self->{not_a_slave}->{$dbh} ) {
2682  ***      0             0                              my $sth = $self->{sths}->{$dbh}->{SLAVE_STATUS}
2683                                                              ||= $dbh->prepare('SHOW SLAVE STATUS');
2684  ***      0                                            MKDEBUG && _d($dbh, 'SHOW SLAVE STATUS');
2685  ***      0                                            $sth->execute();
2686  ***      0                                            my ($ss) = @{$sth->fetchall_arrayref({})};
      ***      0                                      
2687                                                  
2688  ***      0      0      0                              if ( $ss && %$ss ) {
2689  ***      0                                               $ss = { map { lc($_) => $ss->{$_} } keys %$ss }; # lowercase the keys
      ***      0                                      
2690  ***      0                                               return $ss;
2691                                                        }
2692                                                  
2693  ***      0                                            MKDEBUG && _d('This server returns nothing for SHOW SLAVE STATUS');
2694  ***      0                                            $self->{not_a_slave}->{$dbh}++;
2695                                                     }
2696                                                  }
2697                                                  
2698                                                  sub get_master_status {
2699  ***      0                    0                    my ( $self, $dbh ) = @_;
2700  ***      0      0                                  if ( !$self->{not_a_master}->{$dbh} ) {
2701  ***      0             0                              my $sth = $self->{sths}->{$dbh}->{MASTER_STATUS}
2702                                                              ||= $dbh->prepare('SHOW MASTER STATUS');
2703  ***      0                                            MKDEBUG && _d($dbh, 'SHOW MASTER STATUS');
2704  ***      0                                            $sth->execute();
2705  ***      0                                            my ($ms) = @{$sth->fetchall_arrayref({})};
      ***      0                                      
2706                                                  
2707  ***      0      0      0                              if ( $ms && %$ms ) {
2708  ***      0                                               $ms = { map { lc($_) => $ms->{$_} } keys %$ms }; # lowercase the keys
      ***      0                                      
2709  ***      0      0      0                                 if ( $ms->{file} && $ms->{position} ) {
2710  ***      0                                                  return $ms;
2711                                                           }
2712                                                        }
2713                                                  
2714  ***      0                                            MKDEBUG && _d('This server returns nothing for SHOW MASTER STATUS');
2715  ***      0                                            $self->{not_a_master}->{$dbh}++;
2716                                                     }
2717                                                  }
2718                                                  
2719                                                  sub wait_for_master {
2720  ***      0                    0                    my ( $self, $master, $slave, $time, $timeoutok, $ms ) = @_;
2721  ***      0                                         my $result;
2722  ***      0      0                                  $time = 60 unless defined $time;
2723  ***      0                                         MKDEBUG && _d('Waiting for slave to catch up to master timeout ok:',
2724                                                        $timeoutok);
2725  ***      0             0                           $ms ||= $self->get_master_status($master);
2726  ***      0      0                                  if ( $ms ) {
2727  ***      0                                            my $query = "SELECT MASTER_POS_WAIT('$ms->{file}', $ms->{position}, $time)";
2728  ***      0                                            MKDEBUG && _d($slave, $query);
2729  ***      0                                            ($result) = $slave->selectrow_array($query);
2730  ***      0      0                                     my $stat = defined $result ? $result : 'NULL';
2731  ***      0                                            MKDEBUG && _d('Result of waiting:', $stat);
2732  ***      0      0      0                              if ( $stat eq 'NULL' || $stat < 0 && !$timeoutok ) {
      ***                    0                        
2733  ***      0                                               die "MASTER_POS_WAIT returned $stat";
2734                                                        }
2735                                                     }
2736                                                     else {
2737  ***      0                                            MKDEBUG && _d('Not waiting: this server is not a master');
2738                                                     }
2739  ***      0                                         return $result;
2740                                                  }
2741                                                  
2742                                                  sub stop_slave {
2743  ***      0                    0                    my ( $self, $dbh ) = @_;
2744  ***      0             0                           my $sth = $self->{sths}->{$dbh}->{STOP_SLAVE}
2745                                                           ||= $dbh->prepare('STOP SLAVE');
2746  ***      0                                         MKDEBUG && _d($dbh, $sth->{Statement});
2747  ***      0                                         $sth->execute();
2748                                                  }
2749                                                  
2750                                                  sub start_slave {
2751  ***      0                    0                    my ( $self, $dbh, $pos ) = @_;
2752  ***      0      0                                  if ( $pos ) {
2753  ***      0                                            my $sql = "START SLAVE UNTIL MASTER_LOG_FILE='$pos->{file}', "
2754                                                                . "MASTER_LOG_POS=$pos->{position}";
2755  ***      0                                            MKDEBUG && _d($dbh, $sql);
2756  ***      0                                            $dbh->do($sql);
2757                                                     }
2758                                                     else {
2759  ***      0             0                              my $sth = $self->{sths}->{$dbh}->{START_SLAVE}
2760                                                              ||= $dbh->prepare('START SLAVE');
2761  ***      0                                            MKDEBUG && _d($dbh, $sth->{Statement});
2762  ***      0                                            $sth->execute();
2763                                                     }
2764                                                  }
2765                                                  
2766                                                  sub catchup_to_master {
2767  ***      0                    0                    my ( $self, $slave, $master, $time ) = @_;
2768  ***      0                                         $self->stop_slave($master);
2769  ***      0                                         $self->stop_slave($slave);
2770  ***      0                                         my $slave_status  = $self->get_slave_status($slave);
2771  ***      0                                         my $slave_pos     = $self->repl_posn($slave_status);
2772  ***      0                                         my $master_status = $self->get_master_status($master);
2773  ***      0                                         my $master_pos    = $self->repl_posn($master_status);
2774  ***      0                                         MKDEBUG && _d('Master position:', $self->pos_to_string($master_pos),
2775                                                        'Slave position:', $self->pos_to_string($slave_pos));
2776  ***      0      0                                  if ( $self->pos_cmp($slave_pos, $master_pos) < 0 ) {
2777  ***      0                                            MKDEBUG && _d('Waiting for slave to catch up to master');
2778  ***      0                                            $self->start_slave($slave, $master_pos);
2779  ***      0                                            eval {
2780  ***      0                                               $self->wait_for_master($master, $slave, $time, 0, $master_status);
2781                                                        };
2782  ***      0      0                                     if ( $EVAL_ERROR ) {
2783  ***      0                                               MKDEBUG && _d($EVAL_ERROR);
2784  ***      0      0                                        if ( $EVAL_ERROR =~ m/MASTER_POS_WAIT returned NULL/ ) {
2785  ***      0                                                  $slave_status = $self->get_slave_status($slave);
2786  ***      0      0                                           if ( !$self->slave_is_running($slave_status) ) {
2787  ***      0                                                     MKDEBUG && _d('Master position:',
2788                                                                    $self->pos_to_string($master_pos),
2789                                                                    'Slave position:', $self->pos_to_string($slave_pos));
2790  ***      0                                                     $slave_pos = $self->repl_posn($slave_status);
2791  ***      0      0                                              if ( $self->pos_cmp($slave_pos, $master_pos) != 0 ) {
2792  ***      0                                                        die "$EVAL_ERROR but slave has not caught up to master";
2793                                                                 }
2794  ***      0                                                     MKDEBUG && _d('Slave is caught up to master and stopped');
2795                                                              }
2796                                                              else {
2797  ***      0                                                     die "$EVAL_ERROR but slave was still running";
2798                                                              }
2799                                                           }
2800                                                           else {
2801  ***      0                                                  die $EVAL_ERROR;
2802                                                           }
2803                                                        }
2804                                                     }
2805                                                  }
2806                                                  
2807                                                  sub catchup_to_same_pos {
2808  ***      0                    0                    my ( $self, $s1_dbh, $s2_dbh ) = @_;
2809  ***      0                                         $self->stop_slave($s1_dbh);
2810  ***      0                                         $self->stop_slave($s2_dbh);
2811  ***      0                                         my $s1_status = $self->get_slave_status($s1_dbh);
2812  ***      0                                         my $s2_status = $self->get_slave_status($s2_dbh);
2813  ***      0                                         my $s1_pos    = $self->repl_posn($s1_status);
2814  ***      0                                         my $s2_pos    = $self->repl_posn($s2_status);
2815  ***      0      0                                  if ( $self->pos_cmp($s1_pos, $s2_pos) < 0 ) {
      ***             0                               
2816  ***      0                                            $self->start_slave($s1_dbh, $s2_pos);
2817                                                     }
2818                                                     elsif ( $self->pos_cmp($s2_pos, $s1_pos) < 0 ) {
2819  ***      0                                            $self->start_slave($s2_dbh, $s1_pos);
2820                                                     }
2821                                                  
2822  ***      0                                         $s1_status = $self->get_slave_status($s1_dbh);
2823  ***      0                                         $s2_status = $self->get_slave_status($s2_dbh);
2824  ***      0                                         $s1_pos    = $self->repl_posn($s1_status);
2825  ***      0                                         $s2_pos    = $self->repl_posn($s2_status);
2826                                                  
2827  ***      0      0      0                           if ( $self->slave_is_running($s1_status)
      ***                    0                        
2828                                                       || $self->slave_is_running($s2_status)
2829                                                       || $self->pos_cmp($s1_pos, $s2_pos) != 0)
2830                                                     {
2831  ***      0                                            die "The servers aren't both stopped at the same position";
2832                                                     }
2833                                                  
2834                                                  }
2835                                                  
2836                                                  sub change_master_to {
2837  ***      0                    0                    my ( $self, $dbh, $master_dsn, $master_pos ) = @_;
2838  ***      0                                         $self->stop_slave($dbh);
2839  ***      0                                         MKDEBUG && _d(Dumper($master_dsn), Dumper($master_pos));
2840  ***      0                                         my $sql = "CHANGE MASTER TO MASTER_HOST='$master_dsn->{h}', "
2841                                                        . "MASTER_PORT= $master_dsn->{P}, MASTER_LOG_FILE='$master_pos->{file}', "
2842                                                        . "MASTER_LOG_POS=$master_pos->{position}";
2843  ***      0                                         MKDEBUG && _d($dbh, $sql);
2844  ***      0                                         $dbh->do($sql);
2845                                                  }
2846                                                  
2847                                                  sub make_sibling_of_master {
2848  ***      0                    0                    my ( $self, $slave_dbh, $slave_dsn, $dsn_parser, $timeout) = @_;
2849                                                  
2850  ***      0      0                                  my $master_dsn  = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
2851                                                        or die "This server is not a slave";
2852  ***      0                                         my $master_dbh  = $dsn_parser->get_dbh(
2853                                                        $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
2854  ***      0      0                                  my $gmaster_dsn
2855                                                        = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
2856                                                        or die "This server's master is not a slave";
2857  ***      0                                         my $gmaster_dbh = $dsn_parser->get_dbh(
2858                                                        $dsn_parser->get_cxn_params($gmaster_dsn), { AutoCommit => 1 });
2859  ***      0      0                                  if ( $self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn) ) {
2860  ***      0                                            die "The slave's master's master is the slave: master-master replication";
2861                                                     }
2862                                                  
2863  ***      0                                         $self->stop_slave($master_dbh);
2864  ***      0                                         $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
2865  ***      0                                         $self->stop_slave($slave_dbh);
2866                                                  
2867  ***      0                                         my $master_status = $self->get_master_status($master_dbh);
2868  ***      0                                         my $mslave_status = $self->get_slave_status($master_dbh);
2869  ***      0                                         my $slave_status  = $self->get_slave_status($slave_dbh);
2870  ***      0                                         my $master_pos    = $self->repl_posn($master_status);
2871  ***      0                                         my $slave_pos     = $self->repl_posn($slave_status);
2872                                                  
2873  ***      0      0      0                           if ( !$self->slave_is_running($mslave_status)
      ***                    0                        
2874                                                       && !$self->slave_is_running($slave_status)
2875                                                       && $self->pos_cmp($master_pos, $slave_pos) == 0)
2876                                                     {
2877  ***      0                                            $self->change_master_to($slave_dbh, $gmaster_dsn,
2878                                                           $self->repl_posn($mslave_status)); # Note it's not $master_pos!
2879                                                     }
2880                                                     else {
2881  ***      0                                            die "The servers aren't both stopped at the same position";
2882                                                     }
2883                                                  
2884  ***      0                                         $mslave_status = $self->get_slave_status($master_dbh);
2885  ***      0                                         $slave_status  = $self->get_slave_status($slave_dbh);
2886  ***      0                                         my $mslave_pos = $self->repl_posn($mslave_status);
2887  ***      0                                         $slave_pos     = $self->repl_posn($slave_status);
2888  ***      0      0      0                           if ( $self->short_host($mslave_status) ne $self->short_host($slave_status)
2889                                                       || $self->pos_cmp($mslave_pos, $slave_pos) != 0)
2890                                                     {
2891  ***      0                                            die "The servers don't have the same master/position after the change";
2892                                                     }
2893                                                  }
2894                                                  
2895                                                  sub make_slave_of_sibling {
2896  ***      0                    0                    my ( $self, $slave_dbh, $slave_dsn, $sib_dbh, $sib_dsn,
2897                                                          $dsn_parser, $timeout) = @_;
2898                                                  
2899  ***      0      0                                  if ( $self->short_host($slave_dsn) eq $self->short_host($sib_dsn) ) {
2900  ***      0                                            die "You are trying to make the slave a slave of itself";
2901                                                     }
2902                                                  
2903  ***      0      0                                  my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
2904                                                        or die "This server is not a slave";
2905  ***      0                                         my $master_dbh1 = $dsn_parser->get_dbh(
2906                                                        $dsn_parser->get_cxn_params($master_dsn1), { AutoCommit => 1 });
2907  ***      0      0                                  my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
2908                                                        or die "The sibling is not a slave";
2909  ***      0      0                                  if ( $self->short_host($master_dsn1) ne $self->short_host($master_dsn2) ) {
2910  ***      0                                            die "This server isn't a sibling of the slave";
2911                                                     }
2912  ***      0      0                                  my $sib_master_stat = $self->get_master_status($sib_dbh)
2913                                                        or die "Binary logging is not enabled on the sibling";
2914  ***      0      0                                  die "The log_slave_updates option is not enabled on the sibling"
2915                                                        unless $self->has_slave_updates($sib_dbh);
2916                                                  
2917  ***      0                                         $self->catchup_to_same_pos($slave_dbh, $sib_dbh);
2918                                                  
2919  ***      0                                         $sib_master_stat = $self->get_master_status($sib_dbh);
2920  ***      0                                         $self->change_master_to($slave_dbh, $sib_dsn,
2921                                                           $self->repl_posn($sib_master_stat));
2922                                                  
2923  ***      0                                         my $slave_status = $self->get_slave_status($slave_dbh);
2924  ***      0                                         my $slave_pos    = $self->repl_posn($slave_status);
2925  ***      0                                         $sib_master_stat = $self->get_master_status($sib_dbh);
2926  ***      0      0      0                           if ( $self->short_host($slave_status) ne $self->short_host($sib_dsn)
2927                                                       || $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
2928                                                     {
2929  ***      0                                            die "After changing the slave's master, it isn't a slave of the sibling, "
2930                                                           . "or it has a different replication position than the sibling";
2931                                                     }
2932                                                  }
2933                                                  
2934                                                  sub make_slave_of_uncle {
2935  ***      0                    0                    my ( $self, $slave_dbh, $slave_dsn, $unc_dbh, $unc_dsn,
2936                                                          $dsn_parser, $timeout) = @_;
2937                                                  
2938  ***      0      0                                  if ( $self->short_host($slave_dsn) eq $self->short_host($unc_dsn) ) {
2939  ***      0                                            die "You are trying to make the slave a slave of itself";
2940                                                     }
2941                                                  
2942  ***      0      0                                  my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
2943                                                        or die "This server is not a slave";
2944  ***      0                                         my $master_dbh = $dsn_parser->get_dbh(
2945                                                        $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
2946  ***      0      0                                  my $gmaster_dsn
2947                                                        = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
2948                                                        or die "The master is not a slave";
2949  ***      0      0                                  my $unc_master_dsn
2950                                                        = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
2951                                                        or die "The uncle is not a slave";
2952  ***      0      0                                  if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn)) {
2953  ***      0                                            die "The uncle isn't really the slave's uncle";
2954                                                     }
2955                                                  
2956  ***      0      0                                  my $unc_master_stat = $self->get_master_status($unc_dbh)
2957                                                        or die "Binary logging is not enabled on the uncle";
2958  ***      0      0                                  die "The log_slave_updates option is not enabled on the uncle"
2959                                                        unless $self->has_slave_updates($unc_dbh);
2960                                                  
2961  ***      0                                         $self->catchup_to_same_pos($master_dbh, $unc_dbh);
2962  ***      0                                         $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
2963                                                  
2964  ***      0                                         my $slave_status  = $self->get_slave_status($slave_dbh);
2965  ***      0                                         my $master_status = $self->get_master_status($master_dbh);
2966  ***      0      0                                  if ( $self->pos_cmp(
2967                                                           $self->repl_posn($slave_status),
2968                                                           $self->repl_posn($master_status)) != 0 )
2969                                                     {
2970  ***      0                                            die "The slave is not caught up to its master";
2971                                                     }
2972                                                  
2973  ***      0                                         $unc_master_stat = $self->get_master_status($unc_dbh);
2974  ***      0                                         $self->change_master_to($slave_dbh, $unc_dsn,
2975                                                        $self->repl_posn($unc_master_stat));
2976                                                  
2977                                                  
2978  ***      0                                         $slave_status    = $self->get_slave_status($slave_dbh);
2979  ***      0                                         my $slave_pos    = $self->repl_posn($slave_status);
2980  ***      0      0      0                           if ( $self->short_host($slave_status) ne $self->short_host($unc_dsn)
2981                                                       || $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
2982                                                     {
2983  ***      0                                            die "After changing the slave's master, it isn't a slave of the uncle, "
2984                                                           . "or it has a different replication position than the uncle";
2985                                                     }
2986                                                  }
2987                                                  
2988                                                  sub detach_slave {
2989  ***      0                    0                    my ( $self, $dbh ) = @_;
2990  ***      0                                         $self->stop_slave($dbh);
2991  ***      0      0                                  my $stat = $self->get_slave_status($dbh)
2992                                                        or die "This server is not a slave";
2993  ***      0                                         $dbh->do('CHANGE MASTER TO MASTER_HOST=""');
2994  ***      0                                         $dbh->do('RESET SLAVE'); # Wipes out master.info, etc etc
2995  ***      0                                         return $stat;
2996                                                  }
2997                                                  
2998                                                  sub slave_is_running {
2999  ***      0                    0                    my ( $self, $slave_status ) = @_;
3000  ***      0             0                           return ($slave_status->{slave_sql_running} || 'No') eq 'Yes';
3001                                                  }
3002                                                  
3003                                                  sub has_slave_updates {
3004  ***      0                    0                    my ( $self, $dbh ) = @_;
3005  ***      0                                         my $sql = q{SHOW VARIABLES LIKE 'log_slave_updates'};
3006  ***      0                                         MKDEBUG && _d($dbh, $sql);
3007  ***      0                                         my ($name, $value) = $dbh->selectrow_array($sql);
3008  ***      0             0                           return $value && $value =~ m/^(1|ON)$/;
3009                                                  }
3010                                                  
3011                                                  sub repl_posn {
3012  ***      0                    0                    my ( $self, $status ) = @_;
3013  ***      0      0      0                           if ( exists $status->{file} && exists $status->{position} ) {
3014                                                        return {
3015  ***      0                                               file     => $status->{file},
3016                                                           position => $status->{position},
3017                                                        };
3018                                                     }
3019                                                     else {
3020                                                        return {
3021  ***      0                                               file     => $status->{relay_master_log_file},
3022                                                           position => $status->{exec_master_log_pos},
3023                                                        };
3024                                                     }
3025                                                  }
3026                                                  
3027                                                  sub get_slave_lag {
3028  ***      0                    0                    my ( $self, $dbh ) = @_;
3029  ***      0                                         my $stat = $self->get_slave_status($dbh);
3030  ***      0                                         return $stat->{seconds_behind_master};
3031                                                  }
3032                                                  
3033                                                  sub pos_cmp {
3034  ***      0                    0                    my ( $self, $a, $b ) = @_;
3035  ***      0                                         return $self->pos_to_string($a) cmp $self->pos_to_string($b);
3036                                                  }
3037                                                  
3038                                                  sub short_host {
3039  ***      0                    0                    my ( $self, $dsn ) = @_;
3040  ***      0                                         my ($host, $port);
3041  ***      0      0                                  if ( $dsn->{master_host} ) {
3042  ***      0                                            $host = $dsn->{master_host};
3043  ***      0                                            $port = $dsn->{master_port};
3044                                                     }
3045                                                     else {
3046  ***      0                                            $host = $dsn->{h};
3047  ***      0                                            $port = $dsn->{P};
3048                                                     }
3049  ***      0      0      0                           return ($host || '[default]') . ( ($port || 3306) == 3306 ? '' : ":$port" );
      ***                    0                        
3050                                                  }
3051                                                  
3052                                                  sub pos_to_string {
3053  ***      0                    0                    my ( $self, $pos ) = @_;
3054  ***      0                                         my $fmt  = '%s/%020d';
3055  ***      0                                         return sprintf($fmt, @{$pos}{qw(file position)});
      ***      0                                      
3056                                                  }
3057                                                  
3058                                                  sub _d {
3059  ***      0                    0                    my ($package, undef, $line) = caller 0;
3060  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
3061  ***      0                                              map { defined $_ ? $_ : 'undef' }
3062                                                          @_;
3063  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3064                                                  }
3065                                                  
3066                                                  1;
3067                                                  
3068                                                  # ###########################################################################
3069                                                  # End MasterSlave package
3070                                                  # ###########################################################################
3071                                                  
3072                                                  # ###########################################################################
3073                                                  # This is a combination of modules and programs in one -- a runnable module.
3074                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
3075                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
3076                                                  #
3077                                                  # Check at the end of this package for the call to main() which actually runs
3078                                                  # the program.
3079                                                  # ###########################################################################
3080                                                  package mk_archiver;
3081                                                  
3082          16                   16           131   use English qw(-no_match_vars);
              16                                 49   
              16                                122   
3083          16                   16           122   use List::Util qw(max);
              16                                 39   
              16                                 97   
3084          16                   16           333   use IO::File;
              16                                 47   
              16                                234   
3085          16                   16           214   use sigtrap qw(handler finish untrapped normal-signals);
              16                                149   
              16                                136   
3086          16                   16           106   use Time::HiRes qw(gettimeofday sleep time);
              16                                 37   
              16                                120   
3087          16                   16           177   use Data::Dumper;
              16                                 46   
              16                                109   
3088                                                  $Data::Dumper::Indent    = 1;
3089                                                  $Data::Dumper::Quotekeys = 0;
3090                                                  
3091  ***     16            50     16           103   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
              16                                 41   
              16                                245   
3092                                                  
3093                                                  # Global variables; as few as possible.
3094                                                  my $oktorun   = 1;
3095                                                  my $txn_cnt   = 0;
3096                                                  my $cnt       = 0;
3097                                                  my $can_retry = 1;
3098                                                  my $archive_fh;
3099                                                  my $get_sth;
3100                                                  my ( $OUT_OF_RETRIES, $ROLLED_BACK, $ALL_IS_WELL ) = ( 0, -1, 1 );
3101                                                  my ( $src, $dst );
3102                                                  
3103                                                  # Holds the arguments for the $sth's bind variables, so it can be re-tried
3104                                                  # easily.
3105                                                  my @beginning_of_txn;
3106                                                  my $dp = new DSNParser(
3107                                                     { key => 'D', copy => 1, desc => 'Database that contains the table' },
3108                                                     { key => 't', copy => 1, desc => 'Table to archive from/to' },
3109                                                     { key => 'a', copy => 0, desc => 'Database to USE when executing queries' },
3110                                                     { key => 'i', copy => 1, desc => 'Index to use' },
3111                                                     { key => 'm', copy => 0, desc => 'Plugin module name' },
3112                                                     { key => 'b', copy => 0, desc => 'Disable binlog with SET SQL_LOG_BIN=0' },
3113                                                  );
3114                                                  my $vp = new VersionParser;
3115                                                  my $q  = new Quoter;
3116                                                  
3117                                                  sub main {
3118  ***      0                    0                    @ARGV = @_;  # set global ARGV for this package
3119                                                  
3120                                                     # ########################################################################
3121                                                     # Get configuration information.
3122                                                     # ########################################################################
3123  ***      0                                         my $o = new OptionParser(
3124                                                        prompt      => '--source DSN --where WHERE <options>',
3125                                                        dp          => $dp,
3126                                                        description => q{nibbles records from a MySQL table.  The --source }
3127                                                                     . q{and --dest arguments use DSN syntax; if COPY is }
3128                                                                     . q{yes, --dest defaults to the key's value from --source.},
3129                                                     );
3130  ***      0                                         $o->get_specs();
3131  ***      0                                         $o->get_opts();
3132                                                  
3133  ***      0                                         $dp->prop('set-vars', $o->get('set-vars'));
3134                                                  
3135                                                     # Frequently used options.
3136  ***      0                                         $src             = $o->get('source');
3137  ***      0                                         $dst             = $o->get('dest');
3138  ***      0                                         my $sentinel     = $o->get('sentinel');
3139  ***      0                                         my $bulk_del     = $o->get('bulk-delete');
3140  ***      0                                         my $commit_each  = $o->get('commit-each');
3141  ***      0                                         my $limit        = $o->get('limit');
3142  ***      0                                         my $archive_file = $o->get('file');
3143  ***      0                                         my $txnsize      = $o->get('txn-size');
3144  ***      0                                         my $quiet        = $o->get('quiet');
3145                                                  
3146                                                     # First things first: if --stop was given, create the sentinel file.
3147  ***      0      0                                  if ( $o->get('stop') ) {
3148  ***      0      0                                     my $sentinel_fh = IO::File->new($sentinel, ">>")
3149                                                           or die "Cannot open $sentinel: $OS_ERROR\n";
3150  ***      0      0                                     print $sentinel_fh "Remove this file to permit mk-archiver to run\n"
3151                                                           or die "Cannot write to $sentinel: $OS_ERROR\n";
3152  ***      0      0                                     close $sentinel_fh
3153                                                           or die "Cannot close $sentinel: $OS_ERROR\n";
3154  ***      0      0                                     print STDOUT "Successfully created file $sentinel\n"
3155                                                           unless $quiet;
3156  ***      0                                            return 0;
3157                                                     }
3158                                                  
3159                                                     # Generate a filename with sprintf-like formatting codes.
3160  ***      0      0                                  if ( $archive_file ) {
3161  ***      0                                            my @time = localtime();
3162  ***      0      0      0                              my %fmt = (
      ***             0      0                        
3163                                                           d => sprintf('%02d', $time[3]),
3164                                                           H => sprintf('%02d', $time[2]),
3165                                                           i => sprintf('%02d', $time[1]),
3166                                                           m => sprintf('%02d', $time[4] + 1),
3167                                                           s => sprintf('%02d', $time[0]),
3168                                                           Y => $time[5] + 1900,
3169                                                           D => $src && $src->{D} ? $src->{D} : '',
3170                                                           t => $src && $src->{t} ? $src->{t} : '',
3171                                                        );
3172  ***      0                                            $archive_file =~ s/%([dHimsYDt])/$fmt{$1}/g;
3173                                                     }
3174                                                  
3175  ***      0      0                                  if ( !$o->got('help') ) {
3176  ***      0      0                                     $o->save_error("--source DSN requires a 't' (table) part")
3177                                                           unless $src->{t};
3178                                                  
3179  ***      0      0                                     if ( $dst ) {
3180                                                           # Ensure --source and --dest don't point to the same place
3181  ***      0                                               my $same = 1;
3182  ***      0                                               foreach my $arg ( qw(h P D t S) ) {
3183  ***      0      0      0                                    if ( defined $src->{$arg} && defined $dst->{$arg}
      ***                    0                        
3184                                                                   && $src->{$arg} ne $dst->{$arg} ) {
3185  ***      0                                                     $same = 0;
3186  ***      0                                                     last;
3187                                                              }
3188                                                           }
3189  ***      0      0                                        if ( $same ) {
3190  ***      0                                                  $o->save_error("--source and --dest refer to the same table");
3191                                                           }
3192                                                        }
3193  ***      0      0                                     if ( $o->get('bulk-insert') ) {
3194  ***      0      0                                        $o->save_error("--bulk-insert is meaningless without a destination")
3195                                                              unless $dst;
3196  ***      0                                               $bulk_del = 1; # VERY IMPORTANT for safety.
3197                                                        }
3198  ***      0      0      0                              if ( $bulk_del && $limit < 2 ) {
3199  ***      0                                               $o->save_error("--bulk-delete is meaningless with --limit 1");
3200                                                        }
3201                                                  
3202                                                     }
3203                                                  
3204  ***      0      0      0                           if ( $bulk_del || $o->get('bulk-insert') ) {
3205  ***      0                                            $o->set('commit-each', 1);
3206                                                     }
3207                                                  
3208  ***      0                                         $o->usage_or_errors();
3209                                                  
3210                                                     # ########################################################################
3211                                                     # If --pid, check it first since we'll die if it already exits.
3212                                                     # ########################################################################
3213  ***      0                                         my $daemon;
3214  ***      0      0                                  if ( $o->get('pid') ) {
3215                                                        # We're not daemoninzing, it just handles PID stuff.  Keep $daemon
3216                                                        # in the the scope of main() because when it's destroyed it automatically
3217                                                        # removes the PID file.
3218  ***      0                                            $daemon = new Daemon(o=>$o);
3219  ***      0                                            $daemon->make_PID_file();
3220                                                     }
3221                                                        
3222                                                     # ########################################################################
3223                                                     # Set up statistics.
3224                                                     # ########################################################################
3225  ***      0                                         my %statistics = ();
3226  ***      0                                         my $stat_start;
3227                                                  
3228  ***      0      0                                  if ( $o->get('statistics') ) {
3229  ***      0                                            my $start    = gettimeofday();
3230  ***      0                                            my $obs_cost = gettimeofday() - $start; # cost of observation
3231                                                  
3232                                                        *trace = sub {
3233  ***      0             0      0                          my ( $thing, $sub ) = @_;
3234  ***      0                                               my $start = gettimeofday();
3235  ***      0                                               $sub->();
3236  ***      0                                               $statistics{$thing . '_time'}
3237                                                              += (gettimeofday() - $start - $obs_cost);
3238  ***      0                                               ++$statistics{$thing . '_count'};
3239  ***      0             0                                 $stat_start ||= $start;
3240                                                        }
3241  ***      0                                         }
3242                                                     else { # Generate a version that doesn't do any timing
3243                                                        *trace = sub {
3244  ***      0                    0                          my ( $thing, $sub ) = @_;
3245  ***      0                                               $sub->();
3246                                                        }
3247  ***      0                                         }
3248                                                  
3249                                                     # ########################################################################
3250                                                     # Inspect DB servers and tables.
3251                                                     # ########################################################################
3252                                                  
3253  ***      0                                         my $tp = new TableParser(Quoter => $q);
3254  ***      0                                         my $du = new MySQLDump();
3255  ***      0                                         foreach my $table ( grep { $_ } ($src, $dst) ) {
      ***      0                                      
3256  ***      0             0                              my $ac = !$txnsize && !$commit_each;
3257  ***      0      0      0                              if ( !defined $table->{p} && $o->get('ask-pass') ) {
3258  ***      0                                               $table->{p} = OptionParser::prompt_noecho("Enter password: ");
3259                                                        }
3260  ***      0                                            my $dbh = $dp->get_dbh(
3261                                                           $dp->get_cxn_params($table), { AutoCommit => $ac });
3262                                                  
3263                                                        # Set options that can enable removing data on the master and archiving it
3264                                                        # on the slaves.
3265  ***      0      0                                     if ( $table->{a} ) {
3266  ***      0                                               $dbh->do("USE $table->{a}");
3267                                                        }
3268  ***      0      0                                     if ( $table->{b} ) {
3269  ***      0                                               $dbh->do("SET SQL_LOG_BIN=0");
3270                                                        }
3271                                                  
3272  ***      0                                            $table->{dbh}  = $dbh;
3273  ***      0                                            $table->{irot} = get_irot($dbh);
3274                                                  
3275  ***      0             0                              $can_retry = $can_retry && !$table->{irot};
3276                                                  
3277  ***      0                                            $table->{db_tbl} = $q->quote(
3278  ***      0                                               map  { $_ =~ s/(^`|`$)//g; $_; }
      ***      0                                      
3279  ***      0                                               grep { $_ }
3280                                                           ( $table->{D}, $table->{t} )
3281                                                        );
3282                                                  
3283                                                        # Create objects for archivable and dependency handling, BEFORE getting
3284                                                        # the tbl structure (because the object might do some setup, including
3285                                                        # creating the table to be archived).
3286  ***      0      0                                     if ( $table->{m} ) {
3287  ***      0                                               eval "require $table->{m}";
3288  ***      0      0                                        die $EVAL_ERROR if $EVAL_ERROR;
3289                                                  
3290                                                           trace('plugin_start', sub {
3291  ***      0                    0                             $table->{plugin} = $table->{m}->new(
3292                                                                 dbh => $table->{dbh},
3293                                                                 db  => $table->{D},
3294                                                                 tbl => $table->{t},
3295                                                              );
3296  ***      0                                               });
3297                                                        }
3298                                                  
3299  ***      0                                            $table->{info} = $tp->parse(
3300                                                           $du->get_create_table($dbh, $q, $table->{D}, $table->{t}));
3301                                                     }
3302                                                  
3303  ***      0      0      0                           if ( $o->get('primary-key-only')
3304                                                          && !exists $src->{info}->{keys}->{PRIMARY} ) {
3305  ***      0                                            die "--primary-key-only was specified by the --source table "
3306                                                           . "$src->{db_tbl} does not have a PRIMARY KEY";
3307                                                     }
3308                                                  
3309  ***      0      0      0                           if ( $dst && $o->get('check-columns') ) {
3310  ***      0                                            my @not_in_src = grep {
3311  ***      0                                               !$src->{info}->{is_col}->{$_}
3312  ***      0                                            } @{$dst->{info}->{cols}};
3313  ***      0      0                                     if ( @not_in_src ) {
3314  ***      0                                               die "The following columns exist in --dest but not --source: "
3315                                                              . join(', ', @not_in_src)
3316                                                              . "\n";
3317                                                        }
3318  ***      0                                            my @not_in_dst = grep {
3319  ***      0                                               !$dst->{info}->{is_col}->{$_}
3320  ***      0                                            } @{$src->{info}->{cols}};
3321  ***      0      0                                     if ( @not_in_dst ) {
3322  ***      0                                               die "The following columns exist in --source but not --dest: "
3323                                                              . join(', ', @not_in_dst)
3324                                                              . "\n";
3325                                                        }
3326                                                     }
3327                                                  
3328                                                     # ########################################################################
3329                                                     # Get lag dbh.
3330                                                     # ########################################################################
3331  ***      0                                         my $lag_dbh;
3332  ***      0                                         my $ms;
3333  ***      0      0                                  if ( $o->get('check-slave-lag') ) {
3334  ***      0                                            my $dsn_defaults = $dp->parse_options($o);
3335  ***      0                                            my $dsn  = $dp->parse($o->get('check-slave-lag'), $dsn_defaults);
3336  ***      0                                            $lag_dbh = $dp->get_dbh($dp->get_cxn_params($dsn), { AutoCommit => 1 });
3337  ***      0                                            $ms      = new MasterSlave();
3338                                                     }
3339                                                  
3340                                                     # ########################################################################
3341                                                     # Set up general plugin.
3342                                                     # ########################################################################
3343  ***      0                                         my $plugin;
3344  ***      0      0                                  if ( $o->get('plugin') ) {
3345  ***      0                                            eval "require " . $o->get('plugin');
3346  ***      0      0                                     die $EVAL_ERROR if $EVAL_ERROR;
3347  ***      0                                            $plugin = $o->get('plugin')->new(
3348                                                           src  => $src,
3349                                                           dst  => $dst,
3350                                                           opts => $o,
3351                                                        );
3352                                                     }
3353                                                  
3354                                                     # ########################################################################
3355                                                     # Design SQL statements.
3356                                                     # ########################################################################
3357  ***      0                                         my $dbh = $src->{dbh};
3358  ***      0                                         my $nibbler = new TableNibbler(
3359                                                        TableParser => $tp,
3360                                                        Quoter      => $q,
3361                                                     );
3362  ***      0                                         my ($first_sql, $next_sql, $del_sql, $ins_sql);
3363  ***      0                                         my ($sel_stmt, $ins_stmt, $del_stmt);
3364  ***      0                                         my (@asc_slice, @sel_slice, @del_slice, @bulkdel_slice, @ins_slice);
3365  ***      0                                         my @sel_cols = $o->get('columns')          ? @{$o->get('columns')}    # Explicit
      ***      0                                      
3366  ***      0                                                      : $o->get('primary-key-only') ? @{$src->{info}->{keys}->{PRIMARY}->{cols}} 
3367  ***      0      0                                               :                               @{$src->{info}->{cols}}; # All
      ***             0                               
3368  ***      0                                         MKDEBUG && _d("sel cols: " . @sel_cols);
3369                                                  
3370  ***      0                                         $del_stmt = $nibbler->generate_del_stmt(
3371                                                        tbl_struct => $src->{info},
3372                                                        cols       => \@sel_cols,
3373                                                        index      => $src->{i},
3374                                                     );
3375  ***      0                                         @del_slice = @{$del_stmt->{slice}};
      ***      0                                      
3376                                                  
3377                                                     # Generate statement for ascending index, if desired
3378  ***      0      0                                  if ( !$o->get('no-ascend') ) {
3379  ***      0             0                              $sel_stmt = $nibbler->generate_asc_stmt(
3380                                                           tbl_struct => $src->{info},
3381                                                           cols       => $del_stmt->{cols},
3382                                                           index      => $del_stmt->{index},
3383                                                           asc_first  => $o->get('ascend-first'),
3384                                                           # Might prevent rows in the source from being deleted.
3385                                                           asc_only   => $src->{m} || $o->get('no-delete'),
3386                                                        );
3387                                                     }
3388                                                     else {
3389  ***      0                                            $sel_stmt = {
3390                                                           cols  => $del_stmt->{cols},
3391                                                           index => undef,
3392                                                           where => '1=1',
3393                                                           slice => [], # No-ascend = no bind variables in the WHERE clause.
3394                                                           scols => [], # No-ascend = no bind variables in the WHERE clause.
3395                                                        };
3396                                                     }
3397  ***      0                                         @asc_slice = @{$sel_stmt->{slice}};
      ***      0                                      
3398  ***      0                                         @sel_slice = 0..$#sel_cols;
3399                                                  
3400  ***      0                                         $first_sql
3401                                                        = 'SELECT' . ( $o->get('high-priority-select') ? ' HIGH_PRIORITY' : '' )
3402                                                        . ' /*!40001 SQL_NO_CACHE */ '
3403  ***      0      0                                     . join(',', map { $q->quote($_) } @{$sel_stmt->{cols}} )
      ***      0      0                               
      ***             0                               
3404                                                        . " FROM $src->{db_tbl}"
3405                                                        . ( $sel_stmt->{index}
3406                                                           ? (($vp->version_ge($dbh, '4.0.9') ? " FORCE" : " USE")
3407                                                              . " INDEX(`$sel_stmt->{index}`)")
3408                                                           : '')
3409                                                        . " WHERE (".$o->get('where').")";
3410                                                  
3411  ***      0      0      0                           if ( $o->get('safe-auto-increment')
      ***      0             0                        
      ***                    0                        
3412                                                           && $sel_stmt->{index}
3413                                                           && scalar(@{$src->{info}->{keys}->{$sel_stmt->{index}}->{cols}}) == 1
3414                                                           && $src->{info}->{is_autoinc}->{
3415                                                              $src->{info}->{keys}->{$sel_stmt->{index}}->{cols}->[0]
3416                                                           }
3417                                                     ) {
3418  ***      0                                            my $col = $q->quote($sel_stmt->{scols}->[0]);
3419  ***      0                                            my ($val) = $dbh->selectrow_array("SELECT MAX($col) FROM $src->{db_tbl}");
3420  ***      0                                            $first_sql .= " AND ($col < " . $q->quote_val($val) . ")";
3421                                                     }
3422                                                  
3423  ***      0                                         $next_sql = $first_sql;
3424  ***      0      0                                  if ( !$o->get('no-ascend') ) {
3425  ***      0                                            $next_sql .= " AND $sel_stmt->{where}";
3426                                                     }
3427                                                  
3428  ***      0                                         foreach my $thing ( $first_sql, $next_sql ) {
3429  ***      0                                            $thing .= " LIMIT $limit";
3430  ***      0      0                                     if ( $o->get('for-update') ) {
      ***             0                               
3431  ***      0                                               $thing .= ' FOR UPDATE';
3432                                                        }
3433                                                        elsif ( $o->get('share-lock') ) {
3434  ***      0                                               $thing .= ' LOCK IN SHARE MODE';
3435                                                        }
3436                                                     }
3437                                                  
3438  ***      0      0                                  if ( !$bulk_del ) {
3439                                                        # The LIMIT is *always* 1 here, because even though a SELECT can return
3440                                                        # many rows, an INSERT only does one at a time.  It would not be safe to
3441                                                        # iterate over a SELECT that was LIMIT-ed to 500 rows, read and INSERT
3442                                                        # one, and then delete with a LIMIT of 500.  Only one row would be written
3443                                                        # to the file; only one would be INSERT-ed at the destination.  Every
3444                                                        # DELETE must be LIMIT 1.
3445  ***      0      0                                     $del_sql = 'DELETE'
      ***             0                               
3446                                                           . ($o->get('low-priority-delete') ? ' LOW_PRIORITY' : '')
3447                                                           . ($o->get('quick-delete')        ? ' QUICK'        : '')
3448                                                           . " FROM $src->{db_tbl} WHERE $del_stmt->{where}"
3449                                                           . " LIMIT 1";
3450                                                     }
3451                                                     else {
3452                                                        # Unless, of course, it's a bulk DELETE, in which case the 500 rows have
3453                                                        # already been INSERT-ed.
3454  ***      0                                            my $asc_stmt = $nibbler->generate_asc_stmt(
3455                                                           tbl_struct => $src->{info},
3456                                                           cols       => $del_stmt->{cols},
3457                                                           index      => $del_stmt->{index},
3458                                                           asc_first  => 0,
3459                                                        );
3460  ***      0      0                                     $del_sql = 'DELETE'
      ***             0                               
3461                                                           . ($o->get('low-priority-delete') ? ' LOW_PRIORITY' : '')
3462                                                           . ($o->get('quick-delete')        ? ' QUICK'        : '')
3463                                                           . " FROM $src->{db_tbl} WHERE ("
3464                                                           . $asc_stmt->{boundaries}->{'>='}
3465                                                           . ') AND (' . $asc_stmt->{boundaries}->{'<='}
3466                                                           # Unlike the row-at-a-time DELETE, this one must include the user's
3467                                                           # specified WHERE clause and an appropriate LIMIT clause.
3468                                                           . ") AND (".$o->get('where').") LIMIT $limit";
3469  ***      0                                            @bulkdel_slice = @{$asc_stmt->{slice}};
      ***      0                                      
3470                                                     }
3471                                                  
3472  ***      0      0                                  if ( $dst ) {
3473  ***      0                                            $ins_stmt = $nibbler->generate_ins_stmt(
3474                                                           ins_tbl  => $dst->{info},
3475                                                           sel_cols => \@sel_cols,
3476                                                        );
3477  ***      0                                            MKDEBUG && _d("inst stmt: ", Dumper($ins_stmt));
3478  ***      0                                            @ins_slice = @{$ins_stmt->{slice}};
      ***      0                                      
3479  ***      0      0                                     if ( $o->get('bulk-insert') ) {
3480  ***      0                                               $ins_sql = 'LOAD DATA'
3481                                                                    . ($o->get('low-priority-insert') ? ' LOW_PRIORITY' : '')
3482                                                                    . ' LOCAL INFILE ?'
3483                                                                    . ($o->get('replace')    ? ' REPLACE'      : '')
3484                                                                    . ($o->get('ignore')     ? ' IGNORE'       : '')
3485                                                                    . " INTO TABLE $dst->{db_tbl}("
3486  ***      0      0                                                 . join(",", map { $q->quote($_) } @{$ins_stmt->{cols}} )
      ***      0      0                               
      ***             0                               
3487                                                                    . ")";
3488                                                        }
3489                                                        else {
3490  ***      0                                               $ins_sql = ($o->get('replace')             ? 'REPLACE'      : 'INSERT')
3491                                                                    . ($o->get('low-priority-insert') ? ' LOW_PRIORITY' : '')
3492                                                                    . ($o->get('delayed-insert')      ? ' DELAYED'      : '')
3493                                                                    . ($o->get('ignore')              ? ' IGNORE'       : '')
3494                                                                    . " INTO $dst->{db_tbl}("
3495  ***      0                                                        . join(",", map { $q->quote($_) } @{$ins_stmt->{cols}} )
      ***      0                                      
3496                                                                    . ") VALUES ("
3497  ***      0      0                                                 . join(",", map { "?" } @{$ins_stmt->{cols}} ) . ")";
      ***      0      0                               
      ***             0                               
      ***             0                               
3498                                                        }
3499                                                     }
3500                                                     else {
3501  ***      0                                            $ins_sql = '';
3502                                                     }
3503                                                  
3504  ***      0      0                                  if ( $o->get('dry-run') ) {
3505  ***      0      0                                     if ( !$quiet ) {
3506  ***      0      0      0                                 print join("\n", grep { $_ } ($archive_file || ''),
      ***      0                                      
3507                                                                    $first_sql, $next_sql,
3508                                                                    ($o->get('no-delete') ? '' : $del_sql), $ins_sql)
3509                                                              , "\n";
3510                                                        }
3511  ***      0                                            return 0;
3512                                                     }
3513                                                  
3514  ***      0                                         if ( MKDEBUG ) {
3515                                                        _d("get first sql:", $first_sql);
3516                                                        _d("get next sql:", $next_sql);
3517                                                        _d("del row sql:", $del_sql);
3518                                                        _d("ins row sql:", $ins_sql);
3519                                                     }
3520                                                  
3521  ***      0                                         my $get_first = $dbh->prepare($first_sql);
3522  ***      0                                         my $get_next  = $dbh->prepare($next_sql);
3523  ***      0                                         my $del_row   = $dbh->prepare($del_sql);
3524  ***      0      0                                  my $ins_row   = $dst->{dbh}->prepare($ins_sql) if $dst; # Different $dbh!
3525                                                  
3526                                                     # ########################################################################
3527                                                     # Set MySQL options.
3528                                                     # ########################################################################
3529                                                  
3530  ***      0      0                                  if ( $o->get('skip-foreign-key-checks') ) {
3531  ***      0                                            $src->{dbh}->do("/*!40014 SET FOREIGN_KEY_CHECKS=0 */");
3532  ***      0      0                                     if ( $dst ) {
3533  ***      0                                               $dst->{dbh}->do("/*!40014 SET FOREIGN_KEY_CHECKS=0 */");
3534                                                        }
3535                                                     }
3536                                                  
3537                                                     # ########################################################################
3538                                                     # Set up the plugins
3539                                                     # ########################################################################
3540  ***      0                                         foreach my $table ( $dst, $src ) {
3541  ***      0      0      0                              next unless $table && $table->{plugin};
3542                                                        trace ('before_begin', sub {
3543  ***      0                    0                          $table->{plugin}->before_begin(
3544                                                              cols    => \@sel_cols,
3545                                                              allcols => $sel_stmt->{cols},
3546                                                           );
3547  ***      0                                            });
3548                                                     }
3549                                                  
3550                                                     # ########################################################################
3551                                                     # Start archiving.
3552                                                     # ########################################################################
3553  ***      0                                         my $start   = time();
3554  ***      0             0                           my $end     = $start + ($o->get('run-time') || 0); # When to exit
3555  ***      0                                         my $now     = $start;
3556  ***      0                                         my $last_select_time;  # for --sleep-coef
3557  ***      0                                         my $retries = $o->get('retries');
3558  ***      0      0      0                           printf("%-19s %7s %7s\n", 'TIME', 'ELAPSED', 'COUNT')
3559                                                        if $o->get('progress') && !$quiet;
3560  ***      0      0      0                           printf("%19s %7d %7d\n", ts($now), $now - $start, $cnt)
3561                                                        if $o->get('progress') && !$quiet;
3562                                                  
3563  ***      0                                         $get_sth = $get_first; # Later it may be assigned $get_next
3564                                                     trace('select', sub {
3565  ***      0                    0                       my $select_start = time;
3566  ***      0                                            $get_sth->execute;
3567  ***      0                                            $last_select_time = time - $select_start;
3568  ***      0                                            $statistics{SELECT} += $get_sth->rows;
3569  ***      0                                         });
3570  ***      0                                         my $row = $get_sth->fetchrow_arrayref();
3571  ***      0                                         MKDEBUG && _d("First row: ", Dumper($row));
3572  ***      0      0                                  if ( !$row ) {
3573  ***      0                                            $get_sth->finish;
3574  ***      0                                            $src->{dbh}->disconnect();
3575  ***      0      0                                     $dst->{dbh}->disconnect() if $dst;
3576  ***      0                                            return 0;
3577                                                     }
3578                                                  
3579                                                     # Open the file and print the header to it.
3580  ***      0      0                                  if ( $archive_file ) {
3581  ***      0             0                              my $need_hdr = $o->get('header') && !-f $archive_file;
3582  ***      0      0                                     $archive_fh = IO::File->new($archive_file, ">>")
3583                                                           or die "Cannot open $archive_file: $OS_ERROR\n";
3584  ***      0      0                                     $archive_fh->autoflush(1) unless $o->get('buffer');
3585  ***      0      0                                     if ( $need_hdr ) {
3586  ***      0      0                                        print $archive_fh '', escape(\@sel_cols), "\n"
3587                                                              or die "Cannot write to $archive_file: $OS_ERROR\n";
3588                                                        }
3589                                                     }
3590                                                  
3591                                                     # Open the bulk insert file, which doesn't get any header info.
3592  ***      0                                         my $bulkins_file;
3593  ***      0      0                                  if ( $o->get('bulk-insert') ) {
3594  ***      0                                            require File::Temp;
3595  ***      0      0                                     $bulkins_file = File::Temp->new( SUFFIX => 'mk-archiver' )
3596                                                           or die "Cannot open temp file: $OS_ERROR\n";
3597                                                     }
3598                                                  
3599                                                     # This row is the first row fetched from each 'chunk'.
3600  ***      0                                         my $first_row = [ @$row ];
3601  ***      0                                         my $csv_row;
3602                                                  
3603                                                     ROW:
3604  ***      0             0                           while (                                 # Quit if:
      ***                    0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
3605                                                        $row                                 # There is no data
3606                                                        && $retries >= 0                     # or retries are exceeded
3607                                                        && (!$o->get('run-time') || $now < $end) # or time is exceeded
3608                                                        && !-f $sentinel                     # or the sentinel is set
3609                                                        && $oktorun                          # or instructed to quit
3610                                                        )
3611                                                     {
3612  ***      0                                            my $lastrow = $row;
3613                                                  
3614  ***      0      0      0                              if ( !$src->{plugin}
3615                                                           || trace('is_archivable', sub {
3616  ***      0                    0                             $src->{plugin}->is_archivable(row => $row)
3617                                                           })
3618                                                        ) {
3619                                                  
3620                                                           # Do the archiving.  Write to the file first, since like the file, MyISAM
3621                                                           # and other tables cannot be rolled back etc.  If there is a problem,
3622                                                           # hopefully the data has at least made it to the file.
3623  ***      0                                               my $escaped_row;
3624  ***      0      0      0                                 if ( $archive_fh || $bulkins_file ) {
3625  ***      0                                                  $escaped_row = escape([@{$row}[@sel_slice]]);
      ***      0                                      
3626                                                           }
3627  ***      0      0                                        if ( $archive_fh ) {
3628                                                              trace('print_file', sub {
3629  ***      0      0             0                                print $archive_fh $escaped_row, "\n"
3630                                                                    or die "Cannot write to $archive_file: $OS_ERROR\n";
3631  ***      0                                                  });
3632                                                           }
3633                                                  
3634                                                           # ###################################################################
3635                                                           # This code is for the row-at-a-time archiving functionality.
3636                                                           # ###################################################################
3637                                                           # INSERT must come first, to be as safe as possible.
3638  ***      0      0      0                                 if ( $dst && !$bulkins_file ) {
3639  ***      0                                                  my $ins_sth; # Let the plugin change which sth is used for the INSERT.
3640  ***      0      0                                           if ( $dst->{plugin} ) {
3641                                                                 trace('before_insert', sub {
3642  ***      0                    0                                   $dst->{plugin}->before_insert(row => $row);
3643  ***      0                                                     });
3644                                                                 trace('custom_sth', sub {
3645  ***      0                    0                                   $ins_sth = $dst->{plugin}->custom_sth(
3646                                                                       row => $row, sql => $ins_sql);
3647  ***      0                                                     });
3648                                                              }
3649  ***      0             0                                    $ins_sth ||= $ins_row; # Default to the sth decided before.
3650                                                              my $success = do_with_retries($o, 'inserting', sub {
3651  ***      0                    0                                $ins_sth->execute(@{$row}[@ins_slice]);
      ***      0                                      
3652  ***      0                                                     $statistics{INSERT} += $ins_sth->rows;
3653  ***      0                                                  });
3654  ***      0      0                                           if ( $success == $OUT_OF_RETRIES ) {
      ***             0                               
3655  ***      0                                                     $retries = -1;
3656  ***      0                                                     last ROW;
3657                                                              }
3658                                                              elsif ( $success == $ROLLED_BACK ) {
3659  ***      0                                                     --$retries;
3660  ***      0                                                     next ROW;
3661                                                              }
3662                                                           }
3663                                                  
3664  ***      0      0                                        if ( !$bulk_del ) {
3665                                                              # DELETE comes after INSERT for safety.
3666  ***      0      0                                           if ( $src->{plugin} ) {
3667                                                                 trace('before_delete', sub {
3668  ***      0                    0                                   $src->{plugin}->before_delete(row => $row);
3669  ***      0                                                     });
3670                                                              }
3671  ***      0      0                                           if ( !$o->get('no-delete') ) {
3672                                                                 my $success = do_with_retries($o, 'deleting', sub {
3673  ***      0                    0                                   $del_row->execute(@{$row}[@del_slice]);
      ***      0                                      
3674  ***      0                                                        $statistics{DELETE} += $del_row->rows;
3675  ***      0                                                     });
3676  ***      0      0                                              if ( $success == $OUT_OF_RETRIES ) {
      ***             0                               
3677  ***      0                                                        $retries = -1;
3678  ***      0                                                        last ROW;
3679                                                                 }
3680                                                                 elsif ( $success == $ROLLED_BACK ) {
3681  ***      0                                                        --$retries;
3682  ***      0                                                        next ROW;
3683                                                                 }
3684                                                              }
3685                                                           }
3686                                                  
3687                                                           # ###################################################################
3688                                                           # This code is for the bulk archiving functionality.
3689                                                           # ###################################################################
3690  ***      0      0                                        if ( $bulkins_file ) {
3691                                                              trace('print_bulkfile', sub {
3692  ***      0      0             0                                print $bulkins_file $escaped_row, "\n"
3693                                                                    or die "Cannot write to bulk file: $OS_ERROR\n";
3694  ***      0                                                  });
3695                                                           }
3696                                                  
3697                                                        }
3698                                                  
3699  ***      0                                            $now = time();
3700  ***      0                                            ++$cnt;
3701  ***      0                                            ++$txn_cnt;
3702  ***      0                                            $retries = $o->get('retries');
3703                                                  
3704                                                        # Possibly flush the file and commit the insert and delete.
3705  ***      0      0                                     commit($o) unless $commit_each;
3706                                                  
3707                                                        # Report on progress.
3708  ***      0      0      0                              if ( !$quiet && $o->get('progress') && $cnt % $o->get('progress') == 0 ) {
      ***                    0                        
3709  ***      0                                               printf("%19s %7d %7d\n", ts($now), $now - $start, $cnt);
3710                                                        }
3711                                                  
3712                                                        # Get the next row.
3713  ***      0      0                                     if ( $get_sth->{Active} ) { # Fetch until exhausted
3714  ***      0                                               $row = $get_sth->fetchrow_arrayref();
3715                                                        }
3716  ***      0      0                                     if ( !$row ) {
3717                                                  
3718                                                           # ###################################################################
3719                                                           # This code is for the bulk archiving functionality.
3720                                                           # ###################################################################
3721  ***      0      0                                        if ( $bulkins_file ) {
3722  ***      0      0                                           $bulkins_file->close()
3723                                                                 or die "Cannot close bulk insert file: $OS_ERROR\n";
3724  ***      0                                                  my $ins_sth; # Let the plugin change which sth is used for the INSERT.
3725  ***      0      0                                           if ( $dst->{plugin} ) {
3726                                                                 trace('before_bulk_insert', sub {
3727  ***      0                    0                                   $dst->{plugin}->before_bulk_insert(
3728                                                                       first_row => $first_row,
3729                                                                       last_row  => $lastrow,
3730                                                                    );
3731  ***      0                                                     });
3732                                                                 trace('custom_sth', sub {
3733  ***      0                    0                                   $ins_sth = $dst->{plugin}->custom_sth_bulk(
3734                                                                       first_row => $first_row,
3735                                                                       last_row  => $lastrow,
3736                                                                       sql       => $ins_sql,
3737                                                                    );
3738  ***      0                                                     });
3739                                                              }
3740  ***      0             0                                    $ins_sth ||= $ins_row; # Default to the sth decided before.
3741                                                              my $success = do_with_retries($o, 'bulk_inserting', sub {
3742  ***      0                    0                                $ins_sth->execute($bulkins_file->filename());
3743  ***      0                                                     $statistics{INSERT} += $ins_sth->rows;
3744  ***      0                                                  });
3745  ***      0      0                                           if ( $success != $ALL_IS_WELL ) {
3746  ***      0                                                     $retries = -1;
3747  ***      0                                                     last ROW; # unlike other places, don't do 'next'
3748                                                              }
3749                                                           }
3750                                                  
3751  ***      0      0                                        if ( $bulk_del ) {
3752  ***      0      0                                           if ( $src->{plugin} ) {
3753                                                                 trace('before_bulk_delete', sub {
3754  ***      0                    0                                   $src->{plugin}->before_bulk_delete(
3755                                                                       first_row => $first_row,
3756                                                                       last_row  => $lastrow,
3757                                                                    );
3758  ***      0                                                     });
3759                                                              }
3760  ***      0      0                                           if ( !$o->get('no-delete') ) {
3761                                                                 my $success = do_with_retries($o, 'bulk_deleting', sub {
3762  ***      0                                                        $del_row->execute(
3763  ***      0                                                           @{$first_row}[@bulkdel_slice],
3764  ***      0                    0                                      @{$lastrow}[@bulkdel_slice],
3765                                                                    );
3766  ***      0                                                        $statistics{DELETE} += $del_row->rows;
3767  ***      0                                                     });
3768  ***      0      0                                              if ( $success != $ALL_IS_WELL ) {
3769  ***      0                                                        $retries = -1;
3770  ***      0                                                        last ROW; # unlike other places, don't do 'next'
3771                                                                 }
3772                                                              }
3773                                                           }
3774                                                  
3775                                                           # ###################################################################
3776                                                           # This code is for normal operation AND bulk operation.
3777                                                           # ###################################################################
3778  ***      0      0                                        commit($o, 1) if $commit_each;
3779  ***      0                                               $get_sth = $get_next;
3780                                                  
3781                                                           trace('select', sub {
3782  ***      0                    0                             my $select_start = time;
3783  ***      0                                                  $get_next->execute(@{$lastrow}[@asc_slice]);
      ***      0                                      
3784  ***      0                                                  $last_select_time = time - $select_start;
3785  ***      0                                                  $statistics{SELECT} += $get_next->rows;
3786  ***      0                                               });
3787                                                  
3788  ***      0      0                                        @beginning_of_txn = @{$lastrow}[@asc_slice] unless $txn_cnt;
      ***      0                                      
3789  ***      0                                               $row              = $get_sth->fetchrow_arrayref();
3790  ***      0      0                                        $first_row        = $row ? [ @$row ] : undef;
3791                                                  
3792  ***      0      0                                        if ( $o->get('bulk-insert') ) {
3793  ***      0      0                                           $bulkins_file = File::Temp->new( SUFFIX => 'mk-archiver' )
3794                                                                 or die "Cannot open temp file: $OS_ERROR\n";
3795                                                           }
3796                                                        }
3797                                                        # Check slave lag and wait if slave is too far behind.
3798  ***      0      0                                     if ( $lag_dbh ) {
3799  ***      0                                               my $lag = $ms->get_slave_lag($lag_dbh);
3800  ***      0             0                                 while ( !defined $lag || $lag > $o->get('max-lag') ) {
3801  ***      0                                                  MKDEBUG && _d('Sleeping: slave lag is', $lag);
3802  ***      0                                                  sleep($o->get('check-interval'));
3803  ***      0                                                  $lag = $ms->get_slave_lag($lag_dbh);
3804                                                           }
3805                                                        }
3806                                                  
3807                                                        # Sleep between rows.
3808  ***      0      0                                     if( my $sleep_time = $o->get('sleep') ) {
3809  ***      0      0                                        $sleep_time = $last_select_time * $o->get('sleep-coef')
3810                                                              if $o->get('sleep-coef');
3811  ***      0                                               MKDEBUG && _d('Sleeping', $sleep_time);
3812                                                           trace('sleep', sub {
3813  ***      0                    0                             sleep($sleep_time);
3814  ***      0                                               });
3815                                                        }
3816                                                     }  # ROW
3817                                                  
3818                                                     # Transactions might still be open, etc
3819  ***      0             0                           commit($o, $txnsize || $commit_each);
3820  ***      0      0      0                           if ( $archive_file && $archive_fh ) {
3821  ***      0      0                                     close $archive_fh
3822                                                           or die "Cannot close $archive_file: $OS_ERROR\n";
3823                                                     }
3824                                                  
3825  ***      0      0      0                           if ( !$quiet && $o->get('progress') ) {
3826  ***      0                                            printf("%19s %7d %7d\n", ts($now), $now - $start, $cnt);
3827                                                     }
3828                                                  
3829                                                     # Tear down the plugins.
3830  ***      0                                         foreach my $table ( $dst, $src ) {
3831  ***      0      0      0                              next unless $table && $table->{plugin};
3832                                                        trace('after_finish', sub {
3833  ***      0                    0                          $table->{plugin}->after_finish();
3834  ***      0                                            });
3835                                                     }
3836                                                  
3837                                                     # Run ANALYZE or OPTIMIZE.
3838  ***      0      0      0                           if ( $oktorun && ($o->get('analyze') || $o->get('optimize')) ) {
      ***                    0                        
3839  ***      0             0                              my $action = $o->get('analyze') || $o->get('optimize');
3840  ***      0      0                                     my $maint  = ($o->get('analyze') ? 'ANALYZE' : 'OPTIMIZE')
      ***             0                               
3841                                                                   . ($o->get('local') ? ' /*!40101 NO_WRITE_TO_BINLOG*/' : '');
3842  ***      0      0                                     if ( $action =~ m/s/i ) {
3843                                                           trace($maint, sub {
3844  ***      0                    0                             $src->{dbh}->do("$maint TABLE $src->{db_tbl}");
3845  ***      0                                               });
3846                                                        }
3847  ***      0      0      0                              if ( $action =~ m/d/i && $dst ) {
3848                                                           trace($maint, sub {
3849  ***      0                    0                             $dst->{dbh}->do("$maint TABLE $dst->{db_tbl}");
3850  ***      0                                               });
3851                                                        }
3852                                                     }
3853                                                  
3854                                                     # ########################################################################
3855                                                     # Print statistics
3856                                                     # ########################################################################
3857  ***      0      0                                  if ( $plugin ) {
3858  ***      0                                            $plugin->statistics(\%statistics, $stat_start);
3859                                                     }
3860                                                  
3861  ***      0      0      0                           if ( !$quiet && $o->get('statistics') ) {
3862  ***      0                                            my $stat_stop  = gettimeofday();
3863  ***      0                                            my $stat_total = $stat_stop - $stat_start;
3864                                                  
3865  ***      0                                            my $total2 = 0;
3866  ***      0                                            my $maxlen = 0;
3867  ***      0                                            my %summary;
3868                                                  
3869  ***      0                                            printf("Started at %s, ended at %s\n", ts($stat_start), ts($stat_stop));
3870  ***      0                                            print("Source: ", $dp->as_string($src), "\n");
3871  ***      0      0                                     print("Dest:   ", $dp->as_string($dst), "\n") if $dst;
3872  ***      0             0                              print(join("\n", map { "$_ " . ($statistics{$_} || 0) }
      ***      0                                      
3873                                                              qw(SELECT INSERT DELETE)), "\n");
3874                                                  
3875  ***      0                                            foreach my $thing ( grep { m/_(count|time)/ } keys %statistics ) {
      ***      0                                      
3876  ***      0                                               my ( $action, $type ) = $thing =~ m/^(.*?)_(count|time)$/;
3877  ***      0                                               $summary{$action}->{$type}  = $statistics{$thing};
3878  ***      0                                               $summary{$action}->{action} = $action;
3879  ***      0                                               $maxlen                     = max($maxlen, length($action));
3880                                                           # Just in case I get only one type of statistic for a given action (in
3881                                                           # case there was a crash or CTRL-C or something).
3882  ***      0             0                                 $summary{$action}->{time}  ||= 0;
3883  ***      0             0                                 $summary{$action}->{count} ||= 0;
3884                                                        }
3885  ***      0                                            printf("%-${maxlen}s \%10s %10s %10s\n", qw(Action Count Time Pct));
3886  ***      0                                            my $fmt = "%-${maxlen}s \%10d %10.4f %10.2f\n";
3887                                                  
3888  ***      0                                            foreach my $stat (
      ***      0                                      
3889                                                           reverse sort { $a->{time} <=> $b->{time} } values %summary )
3890                                                        {
3891  ***      0                                               my $pct = $stat->{time} / $stat_total * 100;
3892  ***      0                                               printf($fmt, @{$stat}{qw(action count time)}, $pct);
      ***      0                                      
3893  ***      0                                               $total2 += $stat->{time};
3894                                                        }
3895  ***      0                                            printf($fmt, 'other', 0, $stat_total - $total2,
3896                                                           ($stat_total - $total2) / $stat_total * 100);
3897                                                     }
3898                                                  
3899                                                     # Optionally print the reason for exiting.  Do this even if --quiet is
3900                                                     # specified.
3901  ***      0      0                                  if ( $o->get('why-quit') ) {
3902  ***      0      0      0                              if ( $retries < 0 ) {
      ***             0                               
      ***             0                               
      ***             0                               
3903  ***      0                                               print "Exiting because retries exceeded.\n";
3904                                                        }
3905                                                        elsif ( $o->get('run-time') && $now >= $end ) {
3906  ***      0                                               print "Exiting because time exceeded.\n";
3907                                                        }
3908                                                        elsif ( -f $sentinel ) {
3909  ***      0                                               print "Exiting because sentinel file $sentinel exists.\n";
3910                                                        }
3911                                                        elsif ( $o->get('statistics') ) {
3912  ***      0                                               print "Exiting because there are no more rows.\n";
3913                                                        }
3914                                                     }
3915                                                  
3916  ***      0                                         return 0;
3917                                                  }
3918                                                  
3919                                                  # ############################################################################
3920                                                  # Subroutines.
3921                                                  # ############################################################################
3922                                                  
3923                                                  # Catches signals so mk-archiver can exit gracefully.
3924                                                  sub finish {
3925  ***      0                    0                    my ($signal) = @_;
3926  ***      0                                         print STDERR "Exiting on SIG$signal.\n";
3927  ***      0                                         $oktorun = 0;
3928                                                  }
3929                                                  
3930                                                  # Accesses globals, but I wanted the code in one place.
3931                                                  sub commit {
3932  ***      0                    0                    my ( $o, $force ) = @_;
3933  ***      0                                         my $txnsize = $o->get('txn-size');
3934  ***      0      0      0                           if ( $force || ($txnsize && $txn_cnt && $cnt % $txnsize == 0) ) {
      ***                    0                        
      ***                    0                        
3935  ***      0      0      0                              if ( $o->get('buffer') && $archive_fh ) {
3936  ***      0                                               my $archive_file = $o->get('file');
3937                                                           trace('flush', sub {
3938  ***      0      0             0                             $archive_fh->flush or die "Cannot flush $archive_file: $OS_ERROR\n";
3939  ***      0                                               });
3940                                                        }
3941  ***      0      0                                     if ( $dst ) {
3942                                                           trace('commit', sub {
3943  ***      0                    0                             $dst->{dbh}->commit;
3944  ***      0                                               });
3945                                                        }
3946                                                        trace('commit', sub {
3947  ***      0                    0                          $src->{dbh}->commit;
3948  ***      0                                            });
3949  ***      0                                            $txn_cnt = 0;
3950                                                     }
3951                                                  }
3952                                                  
3953                                                  # Repeatedly retries the code until retries runs out, a really bad error
3954                                                  # happens, or it succeeds.  This sub uses lots of global variables; I only wrote
3955                                                  # it to factor out some repeated code.
3956                                                  sub do_with_retries {
3957  ***      0                    0                    my ( $o, $doing, $code ) = @_;
3958  ***      0                                         my $retries = $o->get('retries');
3959  ***      0                                         my $txnsize = $o->get('txn-size');
3960  ***      0                                         my $success = $OUT_OF_RETRIES;
3961                                                  
3962                                                     RETRY:
3963  ***      0             0                           while ( !$success && $retries >= 0 ) {
3964  ***      0                                            eval {
3965  ***      0                                               trace($doing, $code);
3966  ***      0                                               $success = $ALL_IS_WELL;
3967                                                        };
3968  ***      0      0                                     if ( $EVAL_ERROR ) {
3969  ***      0      0                                        if ( $EVAL_ERROR =~ m/Lock wait timeout exceeded|Deadlock found/ ) {
3970  ***      0      0      0                                    if (
      ***                    0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
3971                                                                 # More than one row per txn
3972                                                                 (
3973                                                                    ($txnsize && $txnsize > 1)
3974                                                                    || ($o->get('commit-each') && $o->get('limit') > 1)
3975                                                                 )
3976                                                                 # Not first row
3977                                                                 && $txn_cnt
3978                                                                 # And it's not retry-able
3979                                                                 && (!$can_retry || $EVAL_ERROR =~ m/Deadlock/)
3980                                                              ) {
3981                                                                 # The txn, which is more than 1 statement, was rolled back.
3982  ***      0                                                     last RETRY;
3983                                                              }
3984                                                              else {
3985                                                                 # Only one statement had trouble, and the rest of the txn was
3986                                                                 # not rolled back.  The statement can be retried.
3987  ***      0                                                     --$retries;
3988                                                              }
3989                                                           }
3990                                                           else {
3991  ***      0                                                  die;
3992                                                           }
3993                                                        }
3994                                                     }
3995                                                  
3996  ***      0      0                                  if ( $success != $ALL_IS_WELL ) {
3997                                                        # Must throw away everything and start the transaction over.
3998  ***      0      0                                     if ( $retries >= 0 ) {
3999  ***      0                                               warn "Deadlock or non-retryable lock wait while $doing; "
4000                                                              . "rolling back $txn_cnt rows.\n";
4001  ***      0                                               $success = $ROLLED_BACK;
4002                                                        }
4003                                                        else {
4004  ***      0                                               warn "Exhausted retries while $doing; rolling back $txn_cnt rows.\n";
4005  ***      0                                               $success = $OUT_OF_RETRIES;
4006                                                        }
4007  ***      0                                            $get_sth->finish;
4008                                                        trace('rollback', sub {
4009  ***      0                    0                          $dst->{dbh}->rollback;
4010  ***      0                                            });
4011                                                        trace('rollback', sub {
4012  ***      0                    0                          $src->{dbh}->rollback;
4013  ***      0                                            });
4014                                                        # I wish: $archive_fh->rollback
4015                                                        trace('select', sub {
4016  ***      0                    0                          $get_sth->execute(@beginning_of_txn);
4017  ***      0                                            });
4018  ***      0                                            $cnt -= $txn_cnt;
4019  ***      0                                            $txn_cnt = 0;
4020                                                     }
4021  ***      0                                         return $success;
4022                                                  }
4023                                                  
4024                                                  # Formats a row the same way SELECT INTO OUTFILE does by default.  This is
4025                                                  # described in the LOAD DATA INFILE section of the MySQL manual,
4026                                                  # http://dev.mysql.com/doc/refman/5.0/en/load-data.html
4027                                                  sub escape {
4028  ***      0                    0                    my ($row) = @_;
4029  ***      0      0                                  return join("\t", map {
4030  ***      0                                            s/([\t\n\\])/\\$1/g if defined $_;  # Escape tabs etc
4031  ***      0      0                                     defined $_ ? $_ : '\N';             # NULL = \N
4032                                                     } @$row);
4033                                                  }
4034                                                  
4035                                                  sub ts {
4036  ***      0                    0                    my ( $time ) = @_;
4037  ***      0                                         my ( $sec, $min, $hour, $mday, $mon, $year )
4038                                                        = localtime($time);
4039  ***      0                                         $mon  += 1;
4040  ***      0                                         $year += 1900;
4041  ***      0                                         return sprintf("%d-%02d-%02dT%02d:%02d:%02d",
4042                                                        $year, $mon, $mday, $hour, $min, $sec);
4043                                                  }
4044                                                  
4045                                                  sub get_irot {
4046  ***      0                    0                    my ( $dbh ) = @_;
4047  ***      0      0                                  return 1 unless $vp->version_ge($dbh, '5.0.13');
4048  ***      0                                         my $rows = $dbh->selectall_arrayref(
4049                                                        "show variables like 'innodb_rollback_on_timeout'",
4050                                                        { Slice => {} });
4051  ***      0      0                                  return 0 unless $rows;
4052  ***      0             0                           return @$rows && $rows->[0]->{Value} ne 'OFF';
4053                                                  }
4054                                                  
4055                                                  sub _d {
4056  ***      0                    0                    my ($package, undef, $line) = caller 0;
4057  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
4058  ***      0                                              map { defined $_ ? $_ : 'undef' }
4059                                                          @_;
4060  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4061                                                  }
4062                                                  
4063                                                  # ############################################################################
4064                                                  # Run the program.
4065                                                  # ############################################################################
4066                                                  if ( !caller ) { exit main(@ARGV); }
4067                                                  
4068                                                  1; # Because this is a module as well as a script.
4069                                                  
4070                                                  # ############################################################################
4071                                                  # Documentation.
4072                                                  # ############################################################################
4073                                                  
4074                                                  =pod
4075                                                  
4076                                                  =head1 NAME
4077                                                  
4078                                                  mk-archiver - Archive rows from a MySQL table into another table or a file.
4079                                                  
4080                                                  =head1 SYNOPSIS
4081                                                  
4082                                                   mk-archiver --source h=oltp_server,D=test,t=tbl --dest h=olap_server \
4083                                                      --file '/var/log/archive/%Y-%m-%d-%D.%t' --limit 1000 --commit-each
4084                                                  
4085                                                  =head1 RISKS
4086                                                  
4087                                                  The following section is included to inform users about the potential risks,
4088                                                  whether known or unknown, of using this tool.  The two main categories of risks
4089                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
4090                                                  tools) and those created by bugs.
4091                                                  
4092                                                  mk-achiver is a read-write tool.  It deletes data from the source by default, so
4093                                                  you should test your archiving jobs with the L<"--dry-run"> option if you're not
4094                                                  sure about them.  It is designed to have as little impact on production systems
4095                                                  as possible, but tuning with L<"--limit">, L<"--txn-size"> and similar options
4096                                                  might be a good idea too.
4097                                                  
4098                                                  If you write or use L<"--plugin"> modules, you should ensure they are good
4099                                                  quality and well-tested. 
4100                                                  
4101                                                  At the time of this release, a user has reported that DBI quoting might cause
4102                                                  the tool not to delete some rows from the source table.
4103                                                  
4104                                                  The authoritative source for updated information is always the online issue
4105                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
4106                                                  see a list of such issues at the following URL:
4107                                                  L<http://www.maatkit.org/bugs/mk-archiver>.
4108                                                  
4109                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
4110                                                  
4111                                                  =head1 DESCRIPTION
4112                                                  
4113                                                  mk-archiver is the tool I use to archive tables as described in
4114                                                  L<http://tinyurl.com/mysql-archiving>.  The goal is a low-impact, forward-only
4115                                                  job to nibble old data out of the table without impacting OLTP queries much.
4116                                                  You can insert the data into another table, which need not be on the same
4117                                                  server.  You can also write it to a file in a format suitable for LOAD DATA
4118                                                  INFILE.  Or you can do neither, in which case it's just an incremental DELETE.
4119                                                  
4120                                                  mk-archiver is extensible via a plugin mechanism.  You can inject your own
4121                                                  code to add advanced archiving logic that could be useful for archiving
4122                                                  dependent data, applying complex business rules, or building a data warehouse
4123                                                  during the archiving process.
4124                                                  
4125                                                  You need to choose values carefully for some options.  The most important are
4126                                                  L<"--limit">, L<"--retries">, and L<"--txn-size">.
4127                                                  
4128                                                  The strategy is to find the first row(s), then scan some index forward-only to
4129                                                  find more rows efficiently.  Each subsequent query should not scan the entire
4130                                                  table; it should seek into the index, then scan until it finds more archivable
4131                                                  rows.  Specifying the index with the 'i' part of the L<"--source"> argument can
4132                                                  be crucial for this; use L<"--dry-run"> to examine the generated queries and be
4133                                                  sure to EXPLAIN them to see if they are efficient (most of the time you probably
4134                                                  want to scan the PRIMARY key, which is the default).  Even better, profile
4135                                                  mk-archiver with mk-query-profiler and make sure it is not scanning the whole
4136                                                  table every query.
4137                                                  
4138                                                  You can disable the seek-then-scan optimizations partially or wholly with
4139                                                  L<"--no-ascend"> and L<"--ascend-first">.  Sometimes this may be more efficient
4140                                                  for multi-column keys.
4141                                                  
4142                                                  =head1 OUTPUT
4143                                                  
4144                                                  If you specify L<"--progress">, the output is a header row, plus status output
4145                                                  at intervals.  Each row in the status output lists the current date and time,
4146                                                  how many seconds mk-archiver has been running, and how many rows it has
4147                                                  archived.
4148                                                  
4149                                                  If you specify L<"--statistics">, C<mk-archiver> outputs timing and other
4150                                                  information to help you identify which part of your archiving process takes the
4151                                                  most time.
4152                                                  
4153                                                  =head1 ERROR-HANDLING
4154                                                  
4155                                                  mk-archiver tries to catch signals and exit gracefully; for example, if you
4156                                                  send it SIGTERM (Ctrl-C on UNIX-ish systems), it will catch the signal, print a
4157                                                  message about the signal, and exit fairly normally.  It will not execute
4158                                                  L<"--analyze"> or L<"--optimize">, because these may take a long time to finish.
4159                                                  It will run all other code normally, including calling after_finish() on any
4160                                                  plugins (see L<"EXTENDING">).
4161                                                  
4162                                                  In other words, a signal, if caught, will break out of the main archiving
4163                                                  loop and skip optimize/analyze.
4164                                                  
4165                                                  =head1 OPTIONS
4166                                                  
4167                                                  Specify at least one of L<"--dest">, L<"--file">, or L<"--purge">.
4168                                                  
4169                                                  L<"--ignore"> and L<"--replace"> are mutually exclusive.
4170                                                  
4171                                                  L<"--txn-size"> and L<"--commit-each"> are mutually exclusive.
4172                                                  
4173                                                  L<"--low-priority-insert"> and L<"--delayed-insert"> are mutually exclusive.
4174                                                  
4175                                                  L<"--share-lock"> and L<"--for-update"> are mutually exclusive.
4176                                                  
4177                                                  L<"--analyze"> and L<"--optimize"> are mutually exclusive.
4178                                                  
4179                                                  L<"--no-ascend"> and L<"--no-delete"> are mutually exclusive.
4180                                                  
4181                                                  DSN values in L<"--dest"> default to values from L<"--source"> if COPY is yes.
4182                                                  
4183                                                  =over
4184                                                  
4185                                                  =item --analyze
4186                                                  
4187                                                  type: string
4188                                                  
4189                                                  Run ANALYZE TABLE afterwards on L<"--source"> and/or L<"--dest">.
4190                                                  
4191                                                  Runs ANALYZE TABLE after finishing.  The argument is an arbitrary string.  If it
4192                                                  contains the letter 's', the source will be analyzed.  If it contains 'd', the
4193                                                  destination will be analyzed.  You can specify either or both.  For example, the
4194                                                  following will analyze both:
4195                                                  
4196                                                    --analyze=ds
4197                                                  
4198                                                  See L<http://dev.mysql.com/doc/en/analyze-table.html> for details on ANALYZE
4199                                                  TABLE.
4200                                                  
4201                                                  =item --ascend-first
4202                                                  
4203                                                  Ascend only first column of index.
4204                                                  
4205                                                  If you do want to use the ascending index optimization (see L<"--no-ascend">),
4206                                                  but do not want to incur the overhead of ascending a large multi-column index,
4207                                                  you can use this option to tell mk-archiver to ascend only the leftmost column
4208                                                  of the index.  This can provide a significant performance boost over not
4209                                                  ascending the index at all, while avoiding the cost of ascending the whole
4210                                                  index.
4211                                                  
4212                                                  See L<"EXTENDING"> for a discussion of how this interacts with plugins.
4213                                                  
4214                                                  =item --ask-pass
4215                                                  
4216                                                  Prompt for a password when connecting to MySQL.
4217                                                  
4218                                                  =item --buffer
4219                                                  
4220                                                  Buffer output to L<"--file"> and flush at commit.
4221                                                  
4222                                                  Disables autoflushing to L<"--file"> and flushes L<"--file"> to disk only when a
4223                                                  transaction commits.  This typically means the file is block-flushed by the
4224                                                  operating system, so there may be some implicit flushes to disk between
4225                                                  commits as well.  The default is to flush L<"--file"> to disk after every row.
4226                                                  
4227                                                  The danger is that a crash might cause lost data.
4228                                                  
4229                                                  The performance increase I have seen from using L<"--buffer"> is around 5 to 15
4230                                                  percent.  Your mileage may vary.
4231                                                  
4232                                                  =item --bulk-delete
4233                                                  
4234                                                  Delete each chunk with a single statement (implies L<"--commit-each">).
4235                                                  
4236                                                  Delete each chunk of rows in bulk with a single C<DELETE> statement.  The
4237                                                  statement deletes every row between the first and last row of the chunk,
4238                                                  inclusive.  It implies L<"--commit-each">, since it would be a bad idea to
4239                                                  C<INSERT> rows one at a time and commit them before the bulk C<DELETE>.
4240                                                  
4241                                                  The normal method is to delete every row by its primary key.  Bulk deletes might
4242                                                  be a lot faster.  B<They also might not be faster> if you have a complex
4243                                                  C<WHERE> clause.
4244                                                  
4245                                                  This option completely defers all C<DELETE> processing until the chunk of rows
4246                                                  is finished.  If you have a plugin on the source, its C<before_delete> method
4247                                                  will not be called.  Instead, its C<before_bulk_delete> method is called later.
4248                                                  
4249                                                  B<WARNING>: if you have a plugin on the source that sometimes doesn't return
4250                                                  true from C<is_archivable()>, you should use this option only if you understand
4251                                                  what it does.  If the plugin instructs C<mk-archiver> not to archive a row,
4252                                                  it'll still be deleted by the bulk delete!
4253                                                  
4254                                                  =item --bulk-insert
4255                                                  
4256                                                  Insert each chunk with LOAD DATA INFILE (implies L<"--bulk-delete"> L<"--commit-each">).
4257                                                  
4258                                                  Insert each chunk of rows with C<LOAD DATA LOCAL INFILE>.  This may be much
4259                                                  faster than inserting a row at a time with C<INSERT> statements.  It is
4260                                                  implemented by creating a temporary file for each chunk of rows, and writing the
4261                                                  rows to this file instead of inserting them.  When the chunk is finished, it
4262                                                  uploads the rows.
4263                                                  
4264                                                  To protect the safety of your data, this option forces bulk deletes to be used.
4265                                                  It would be unsafe to delete each row as it is found, before inserting the rows
4266                                                  into the destination first.  Forcing bulk deletes guarantees that the deletion
4267                                                  waits until the insertion is successful.
4268                                                  
4269                                                  The L<"--low-priority-insert">, L<"--replace">, and L<"--ignore"> options work
4270                                                  with this option, but L<"--delayed-insert"> does not.
4271                                                  
4272                                                  =item --charset
4273                                                  
4274                                                  short form: -A; type: string
4275                                                  
4276                                                  Default character set.  If the value is utf8, sets Perl's binmode on
4277                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and runs SET
4278                                                  NAMES UTF8 after connecting to MySQL.  Any other value sets binmode on STDOUT
4279                                                  without the utf8 layer, and runs SET NAMES after connecting to MySQL.
4280                                                  
4281                                                  =item --[no]check-columns
4282                                                  
4283                                                  default: yes
4284                                                  
4285                                                  Ensure L<"--source"> and L<"--dest"> have same columns.
4286                                                  
4287                                                  Enabled by default; causes mk-archiver to check that the source and destination
4288                                                  tables have the same columns.  It does not check column order, data type, etc.
4289                                                  It just checks that all columns in the source exist in the destination and
4290                                                  vice versa.  If there are any differences, mk-archiver will exit with an
4291                                                  error.
4292                                                  
4293                                                  To disable this check, specify --no-check-columns.
4294                                                  
4295                                                  =item --check-interval
4296                                                  
4297                                                  type: time; default: 1s
4298                                                  
4299                                                  How often to check for slave lag if L<"--check-slave-lag"> is given.
4300                                                  
4301                                                  =item --check-slave-lag
4302                                                  
4303                                                  type: string
4304                                                  
4305                                                  Pause archiving until the specified DSN's slave lag is less than L<"--max-lag">.
4306                                                  
4307                                                  =item --columns
4308                                                  
4309                                                  short form: -c; type: array
4310                                                  
4311                                                  Comma-separated list of columns to archive.
4312                                                  
4313                                                  Specify a comma-separated list of columns to fetch, write to the file, and
4314                                                  insert into the destination table.  If specified, mk-archiver ignores other
4315                                                  columns unless it needs to add them to the C<SELECT> statement for ascending an
4316                                                  index or deleting rows.  It fetches and uses these extra columns internally, but
4317                                                  does not write them to the file or to the destination table.  It I<does> pass
4318                                                  them to plugins.
4319                                                  
4320                                                  See also L<"--primary-key-only">.
4321                                                  
4322                                                  =item --commit-each
4323                                                  
4324                                                  Commit each set of fetched and archived rows (disables L<"--txn-size">).
4325                                                  
4326                                                  Commits transactions and flushes L<"--file"> after each set of rows has been
4327                                                  archived, before fetching the next set of rows, and before sleeping if
4328                                                  L<"--sleep"> is specified.  Disables L<"--txn-size">; use L<"--limit"> to
4329                                                  control the transaction size with L<"--commit-each">.
4330                                                  
4331                                                  This option is useful as a shortcut to make L<"--limit"> and L<"--txn-size"> the
4332                                                  same value, but more importantly it avoids transactions being held open while
4333                                                  searching for more rows.  For example, imagine you are archiving old rows from
4334                                                  the beginning of a very large table, with L<"--limit"> 1000 and L<"--txn-size">
4335                                                  1000.  After some period of finding and archiving 1000 rows at a time,
4336                                                  mk-archiver finds the last 999 rows and archives them, then executes the next
4337                                                  SELECT to find more rows.  This scans the rest of the table, but never finds any
4338                                                  more rows.  It has held open a transaction for a very long time, only to
4339                                                  determine it is finished anyway.  You can use L<"--commit-each"> to avoid this.
4340                                                  
4341                                                  =item --config
4342                                                  
4343                                                  type: Array
4344                                                  
4345                                                  Read this comma-separated list of config files; if specified, this must be the
4346                                                  first option on the command line.
4347                                                  
4348                                                  =item --delayed-insert
4349                                                  
4350                                                  Add the DELAYED modifier to INSERT statements.
4351                                                  
4352                                                  Adds the DELAYED modifier to INSERT or REPLACE statements.  See
4353                                                  L<http://dev.mysql.com/doc/en/insert.html> for details.
4354                                                  
4355                                                  =item --dest
4356                                                  
4357                                                  type: DSN
4358                                                  
4359                                                  DSN specifying the table to archive to.
4360                                                  
4361                                                  This item specifies a table into which mk-archiver will insert rows
4362                                                  archived from L<"--source">.  It uses the same key=val argument format as
4363                                                  L<"--source">.  Most missing values default to the same values as
4364                                                  L<"--source">, so you don't have to repeat options that are the same in
4365                                                  L<"--source"> and L<"--dest">.  Use the L<"--help"> option to see which values
4366                                                  are copied from L<"--source">.
4367                                                  
4368                                                  =item --dry-run
4369                                                  
4370                                                  Print queries and exit without doing anything.
4371                                                  
4372                                                  Causes mk-archiver to exit after printing the filename and SQL statements
4373                                                  it will use.
4374                                                  
4375                                                  =item --file
4376                                                  
4377                                                  type: string
4378                                                  
4379                                                  File to archive to, with DATE_FORMAT()-like formatting.
4380                                                  
4381                                                  Filename to write archived rows to.  A subset of MySQL's DATE_FORMAT()
4382                                                  formatting codes are allowed in the filename, as follows:
4383                                                  
4384                                                     %d    Day of the month, numeric (01..31)
4385                                                     %H    Hour (00..23)
4386                                                     %i    Minutes, numeric (00..59)
4387                                                     %m    Month, numeric (01..12)
4388                                                     %s    Seconds (00..59)
4389                                                     %Y    Year, numeric, four digits
4390                                                  
4391                                                  You can use the following extra format codes too:
4392                                                  
4393                                                     %D    Database name
4394                                                     %t    Table name
4395                                                  
4396                                                  Example:
4397                                                  
4398                                                     --file '/var/log/archive/%Y-%m-%d-%D.%t'
4399                                                  
4400                                                  The file's contents are in the same format used by SELECT INTO OUTFILE, as
4401                                                  documented in the MySQL manual: rows terminated by newlines, columns
4402                                                  terminated by tabs, NULL characters are represented by \N, and special
4403                                                  characters are escaped by \.  This lets you reload a file with LOAD DATA
4404                                                  INFILE's default settings.
4405                                                  
4406                                                  If you want a column header at the top of the file, see L<"--header">.  The file
4407                                                  is auto-flushed by default; see L<"--buffer">.
4408                                                  
4409                                                  =item --for-update
4410                                                  
4411                                                  Adds the FOR UPDATE modifier to SELECT statements.
4412                                                  
4413                                                  For details, see L<http://dev.mysql.com/doc/en/innodb-locking-reads.html>.
4414                                                  
4415                                                  =item --header
4416                                                  
4417                                                  Print column header at top of L<"--file">.
4418                                                  
4419                                                  Writes column names as the first line in the file given by L<"--file">.  If the
4420                                                  file exists, does not write headers; this keeps the file loadable with LOAD
4421                                                  DATA INFILE in case you append more output to it.
4422                                                  
4423                                                  =item --help
4424                                                  
4425                                                  Show help and exit.
4426                                                  
4427                                                  =item --high-priority-select
4428                                                  
4429                                                  Adds the HIGH_PRIORITY modifier to SELECT statements.
4430                                                  
4431                                                  See L<http://dev.mysql.com/doc/en/select.html> for details.
4432                                                  
4433                                                  =item --host
4434                                                  
4435                                                  short form: -h; type: string
4436                                                  
4437                                                  Connect to host.
4438                                                  
4439                                                  =item --ignore
4440                                                  
4441                                                  Use IGNORE for INSERT statements.
4442                                                  
4443                                                  Causes INSERTs into L<"--dest"> to be INSERT IGNORE.
4444                                                  
4445                                                  =item --limit
4446                                                  
4447                                                  type: int; default: 1
4448                                                  
4449                                                  Number of rows to fetch and archive per statement.
4450                                                  
4451                                                  Limits the number of rows returned by the SELECT statements that retrieve rows
4452                                                  to archive.  Default is one row.  It may be more efficient to increase the
4453                                                  limit, but be careful if you are archiving sparsely, skipping over many rows;
4454                                                  this can potentially cause more contention with other queries, depending on the
4455                                                  storage engine, transaction isolation level, and options such as
4456                                                  L<"--for-update">.
4457                                                  
4458                                                  =item --local
4459                                                  
4460                                                  Do not write OPTIMIZE or ANALYZE queries to binlog.
4461                                                  
4462                                                  Adds the NO_WRITE_TO_BINLOG modifier to ANALYZE and OPTIMIZE queries.  See
4463                                                  L<"--analyze"> for details.
4464                                                  
4465                                                  =item --low-priority-delete
4466                                                  
4467                                                  Adds the LOW_PRIORITY modifier to DELETE statements.
4468                                                  
4469                                                  See L<http://dev.mysql.com/doc/en/delete.html> for details.
4470                                                  
4471                                                  =item --low-priority-insert
4472                                                  
4473                                                  Adds the LOW_PRIORITY modifier to INSERT or REPLACE statements.
4474                                                  
4475                                                  See L<http://dev.mysql.com/doc/en/insert.html> for details.
4476                                                  
4477                                                  =item --max-lag
4478                                                  
4479                                                  type: time; default: 1s
4480                                                  
4481                                                  Pause archiving if the slave given by L<"--check-slave-lag"> lags.
4482                                                  
4483                                                  This option causes mk-archiver to look at the slave every time it's about
4484                                                  to fetch another row.  If the slave's lag is greater than the option's value,
4485                                                  or if the slave isn't running (so its lag is NULL), mk-table-checksum sleeps
4486                                                  for L<"--check-interval"> seconds and then looks at the lag again.  It repeats
4487                                                  until the slave is caught up, then proceeds to fetch and archive the row.
4488                                                  
4489                                                  This option may eliminate the need for L<"--sleep"> or L<"--sleep-coef">.
4490                                                  
4491                                                  =item --no-ascend
4492                                                  
4493                                                  Do not use ascending index optimization.
4494                                                  
4495                                                  The default ascending-index optimization causes C<mk-archiver> to optimize
4496                                                  repeated C<SELECT> queries so they seek into the index where the previous query
4497                                                  ended, then scan along it, rather than scanning from the beginning of the table
4498                                                  every time.  This is enabled by default because it is generally a good strategy
4499                                                  for repeated accesses.
4500                                                  
4501                                                  Large, multiple-column indexes may cause the WHERE clause to be complex enough
4502                                                  that this could actually be less efficient.  Consider for example a four-column
4503                                                  PRIMARY KEY on (a, b, c, d).  The WHERE clause to start where the last query
4504                                                  ended is as follows:
4505                                                  
4506                                                     WHERE (a > ?)
4507                                                        OR (a = ? AND b > ?)
4508                                                        OR (a = ? AND b = ? AND c > ?)
4509                                                        OR (a = ? AND b = ? AND c = ? AND d >= ?)
4510                                                  
4511                                                  Populating the placeholders with values uses memory and CPU, adds network
4512                                                  traffic and parsing overhead, and may make the query harder for MySQL to
4513                                                  optimize.  A four-column key isn't a big deal, but a ten-column key in which
4514                                                  every column allows C<NULL> might be.
4515                                                  
4516                                                  Ascending the index might not be necessary if you know you are simply removing
4517                                                  rows from the beginning of the table in chunks, but not leaving any holes, so
4518                                                  starting at the beginning of the table is actually the most efficient thing to
4519                                                  do.
4520                                                  
4521                                                  See also L<"--ascend-first">.  See L<"EXTENDING"> for a discussion of how this
4522                                                  interacts with plugins.
4523                                                  
4524                                                  =item --no-delete
4525                                                  
4526                                                  Do not delete archived rows.
4527                                                  
4528                                                  Causes C<mk-archiver> not to delete rows after processing them.  This disallows
4529                                                  L<"--no-ascend">, because enabling them both would cause an infinite loop.
4530                                                  
4531                                                  If there is a plugin on the source DSN, its C<before_delete> method is called
4532                                                  anyway, even though C<mk-archiver> will not execute the delete.  See
4533                                                  L<"EXTENDING"> for more on plugins.
4534                                                  
4535                                                  =item --optimize
4536                                                  
4537                                                  type: string
4538                                                  
4539                                                  Run OPTIMIZE TABLE afterwards on L<"--source"> and/or L<"--dest">.
4540                                                  
4541                                                  Runs OPTIMIZE TABLE after finishing.  See L<"--analyze"> for the option syntax
4542                                                  and L<http://dev.mysql.com/doc/en/optimize-table.html> for details on OPTIMIZE
4543                                                  TABLE.
4544                                                  
4545                                                  =item --password
4546                                                  
4547                                                  short form: -p; type: string
4548                                                  
4549                                                  Password to use when connecting.
4550                                                  
4551                                                  =item --pid
4552                                                  
4553                                                  type: string
4554                                                  
4555                                                  Create the given PID file when daemonized.  The file contains the process ID of
4556                                                  the daemonized instance.  The PID file is removed when the daemonized instance
4557                                                  exits.  The program checks for the existence of the PID file when starting; if
4558                                                  it exists and the process with the matching PID exists, the program exits.
4559                                                  
4560                                                  =item --plugin
4561                                                  
4562                                                  type: string
4563                                                  
4564                                                  Perl module name to use as a generic plugin.
4565                                                  
4566                                                  Specify the Perl module name of a general-purpose plugin.  It is currently used
4567                                                  only for statistics (see L<"--statistics">) and must have C<new()> and a
4568                                                  C<statistics()> method.
4569                                                  
4570                                                  The C<new( src => $src, dst => $dst, opts => $o )> method gets the source
4571                                                  and destination DSNs, and their database connections, just like the
4572                                                  connection-specific plugins do.  It also gets an OptionParser object (C<$o>) for
4573                                                  accessing command-line options (example: C<$o->get('purge');>).
4574                                                  
4575                                                  The C<statistics(\%stats, $time)> method gets a hashref of the statistics
4576                                                  collected by the archiving job, and the time the whole job started.
4577                                                  
4578                                                  =item --port
4579                                                  
4580                                                  short form: -P; type: int
4581                                                  
4582                                                  Port number to use for connection.
4583                                                  
4584                                                  =item --primary-key-only
4585                                                  
4586                                                  Primary key columns only.
4587                                                  
4588                                                  A shortcut for specifying L<"--columns"> with the primary key columns.  This is
4589                                                  an efficiency if you just want to purge rows; it avoids fetching the entire row,
4590                                                  when only the primary key columns are needed for C<DELETE> statements.  See also
4591                                                  L<"--purge">.
4592                                                  
4593                                                  =item --progress
4594                                                  
4595                                                  type: int
4596                                                  
4597                                                  Print progress information every X rows.
4598                                                  
4599                                                  Prints current time, elapsed time, and rows archived every X rows.
4600                                                  
4601                                                  =item --purge
4602                                                  
4603                                                  Purge instead of archiving; allows omitting L<"--file"> and L<"--dest">.
4604                                                  
4605                                                  Allows archiving without a L<"--file"> or L<"--dest"> argument, which is
4606                                                  effectively a purge since the rows are just deleted.
4607                                                  
4608                                                  If you just want to purge rows, consider specifying the table's primary key
4609                                                  columns with L<"--primary-key-only">.  This will prevent fetching all columns
4610                                                  from the server for no reason.
4611                                                  
4612                                                  =item --quick-delete
4613                                                  
4614                                                  Adds the QUICK modifier to DELETE statements.
4615                                                  
4616                                                  See L<http://dev.mysql.com/doc/en/delete.html> for details.  As stated in the
4617                                                  documentation, in some cases it may be faster to use DELETE QUICK followed by
4618                                                  OPTIMIZE TABLE.  You can use L<"--optimize"> for this.
4619                                                  
4620                                                  =item --quiet
4621                                                  
4622                                                  Do not print any output, such as for L<"--statistics">.
4623                                                  
4624                                                  Suppresses normal output, including the output of L<"--statistics">, but doesn't
4625                                                  suppress the output from L<"--why-quit">.
4626                                                  
4627                                                  =item --replace
4628                                                  
4629                                                  Causes INSERTs into L<"--dest"> to be written as REPLACE.
4630                                                  
4631                                                  =item --retries
4632                                                  
4633                                                  type: int; default: 1
4634                                                  
4635                                                  Number of retries per timeout or deadlock.
4636                                                  
4637                                                  Specifies the number of times mk-archiver should retry when there is an
4638                                                  InnoDB lock wait timeout or deadlock.  When retries are exhausted,
4639                                                  mk-archiver will exit with an error.
4640                                                  
4641                                                  Consider carefully what you want to happen when you are archiving between a
4642                                                  mixture of transactional and non-transactional storage engines.  The INSERT to
4643                                                  L<"--dest"> and DELETE from L<"--source"> are on separate connections, so they
4644                                                  do not actually participate in the same transaction even if they're on the same
4645                                                  server.  However, mk-archiver implements simple distributed transactions in
4646                                                  code, so commits and rollbacks should happen as desired across the two
4647                                                  connections.
4648                                                  
4649                                                  At this time I have not written any code to handle errors with transactional
4650                                                  storage engines other than InnoDB.  Request that feature if you need it.
4651                                                  
4652                                                  =item --run-time
4653                                                  
4654                                                  type: time
4655                                                  
4656                                                  Time to run before exiting.
4657                                                  
4658                                                  Optional suffix s=seconds, m=minutes, h=hours, d=days; if no suffix, s is used.
4659                                                  
4660                                                  =item --[no]safe-auto-increment
4661                                                  
4662                                                  default: yes
4663                                                  
4664                                                  Do not archive row with max AUTO_INCREMENT.
4665                                                  
4666                                                  Adds an extra WHERE clause to prevent mk-archiver from removing the newest
4667                                                  row when ascending a single-column AUTO_INCREMENT key.  This guards against
4668                                                  re-using AUTO_INCREMENT values if the server restarts, and is enabled by
4669                                                  default.
4670                                                  
4671                                                  The extra WHERE clause contains the maximum value of the auto-increment column
4672                                                  as of the beginning of the archive or purge job.  If new rows are inserted while
4673                                                  mk-archiver is running, it will not see them.
4674                                                  
4675                                                  =item --sentinel
4676                                                  
4677                                                  type: string; default: /tmp/mk-archiver-sentinel
4678                                                  
4679                                                  Exit if this file exists.
4680                                                  
4681                                                  The presence of the file specified by L<"--sentinel"> will cause mk-archiver to
4682                                                  stop archiving and exit.  The default is /tmp/mk-archiver-sentinel.  You
4683                                                  might find this handy to stop cron jobs gracefully if necessary.  See also
4684                                                  L<"--stop">.
4685                                                  
4686                                                  =item --set-vars
4687                                                  
4688                                                  type: string; default: wait_timeout=10000
4689                                                  
4690                                                  Set these MySQL variables.
4691                                                  
4692                                                  Specify any variables you want to be set immediately after connecting to MySQL.
4693                                                  These will be included in a C<SET> command.
4694                                                  
4695                                                  =item --share-lock
4696                                                  
4697                                                  Adds the LOCK IN SHARE MODE modifier to SELECT statements.
4698                                                  
4699                                                  See L<http://dev.mysql.com/doc/en/innodb-locking-reads.html>.
4700                                                  
4701                                                  =item --skip-foreign-key-checks
4702                                                  
4703                                                  Disables foreign key checks with SET FOREIGN_KEY_CHECKS=0.
4704                                                  
4705                                                  =item --sleep
4706                                                  
4707                                                  type: int
4708                                                  
4709                                                  Sleep time between fetches.
4710                                                  
4711                                                  Specifies how long to sleep between SELECT statements.  Default is not to
4712                                                  sleep at all.  Transactions are NOT committed, and the L<"--file"> file is NOT
4713                                                  flushed, before sleeping.  See L<"--txn-size"> to control that.
4714                                                  
4715                                                  If L<"--commit-each"> is specified, committing and flushing happens before
4716                                                  sleeping.
4717                                                  
4718                                                  =item --sleep-coef
4719                                                  
4720                                                  type: float
4721                                                  
4722                                                  Calculate L<"--sleep"> as a multiple of the last SELECT time.
4723                                                  
4724                                                  If this option is specified, mk-archiver will sleep for the query time of the
4725                                                  last SELECT multiplied by the specified coefficient.  This option is ignored
4726                                                  if L<"--sleep"> is specified.
4727                                                  
4728                                                  This is a slightly more sophisticated way to throttle the SELECTs: sleep a
4729                                                  varying amount of time between each SELECT, depending on how long the SELECTs
4730                                                  are taking.
4731                                                  
4732                                                  =item --socket
4733                                                  
4734                                                  short form: -S; type: string
4735                                                  
4736                                                  Socket file to use for connection.
4737                                                  
4738                                                  =item --source
4739                                                  
4740                                                  type: DSN
4741                                                  
4742                                                  DSN specifying the table to archive from (required).
4743                                                  
4744                                                  This argument is specially formatted as a key=value,key=value string.  Keys are
4745                                                  a single letter.  Most options control how mk-archiver connects to MySQL:
4746                                                  
4747                                                     KEY MEANING
4748                                                     === =======
4749                                                     h   Connect to host
4750                                                     P   Port number to use for connection
4751                                                     S   Socket file to use for connection
4752                                                     u   User for login if not current user
4753                                                     p   Password to use when connecting
4754                                                     F   Only read default options from the given file
4755                                                  
4756                                                  The following options select a table to archive:
4757                                                  
4758                                                     KEY MEANING
4759                                                     === =======
4760                                                     D   Database to archive
4761                                                     t   Table to archive
4762                                                     i   Index to use
4763                                                  
4764                                                  The following options specify pluggable actions, which an external Perl module
4765                                                  can provide:
4766                                                  
4767                                                     KEY MEANING
4768                                                     === =======
4769                                                     m   Package name of an external Perl module (see EXTENDING).
4770                                                  
4771                                                  The following actions set other options:
4772                                                  
4773                                                     KEY MEANING
4774                                                     === =======
4775                                                     a   Database to set as the connection's default with USE
4776                                                     b   Disable binary logging with SET SQL_LOG_BIN=0
4777                                                  
4778                                                  The only required part is the table; other parts may be read from various
4779                                                  places in the environment (such as options files).  Here is an example:
4780                                                  
4781                                                     --source h=my_server,D=my_database,t=my_tbl
4782                                                  
4783                                                  The 'i' part deserves special mention.  This tells mk-archiver which index
4784                                                  it should scan to archive.  This appears in a FORCE INDEX or USE INDEX hint in
4785                                                  the SELECT statements used to fetch archivable rows.  If you don't specify
4786                                                  anything, mk-archiver will auto-discover a good index, preferring a C<PRIMARY
4787                                                  KEY> if one exists.  In my experience this usually works well, so most of the
4788                                                  time you can probably just omit the 'i' part.
4789                                                  
4790                                                  The index is used to optimize repeated accesses to the table; mk-archiver
4791                                                  remembers the last row it retrieves from each SELECT statement, and uses it to
4792                                                  construct a WHERE clause, using the columns in the specified index, that should
4793                                                  allow MySQL to start the next SELECT where the last one ended, rather than
4794                                                  potentially scanning from the beginning of the table with each successive
4795                                                  SELECT.  If you are using external plugins, please see L<"EXTENDING"> for a
4796                                                  discussion of how they interact with ascending indexes.
4797                                                  
4798                                                  The 'a' and 'b' options allow you to control how statements flow through the
4799                                                  binary log.  If you specify the 'b' option, binary logging will be disabled on
4800                                                  the specified connection.  If you specify the 'a' option, the connection will
4801                                                  C<USE> the specified database, which you can use to prevent slaves from
4802                                                  executing the binary log events with C<--replicate-ignore-db> options.  These
4803                                                  two options can be used as different methods to achieve the same goal: archive
4804                                                  data off the master, but leave it on the slave.  For example, you can run a
4805                                                  purge job on the master and prevent it from happening on the slave using your
4806                                                  method of choice.
4807                                                  
4808                                                  =item --statistics
4809                                                  
4810                                                  Collect and print timing statistics.
4811                                                  
4812                                                  Causes mk-archiver to collect timing statistics about what it does.  These
4813                                                  statistics are available to the plugin specified by L<"--plugin">
4814                                                  
4815                                                  Unless you specify L<"--quiet">, C<mk-archiver> prints the statistics when it
4816                                                  exits.  The statistics look like this:
4817                                                  
4818                                                   Started at 2008-07-18T07:18:53, ended at 2008-07-18T07:18:53
4819                                                   Source: D=db,t=table
4820                                                   SELECT 4
4821                                                   INSERT 4
4822                                                   DELETE 4
4823                                                   Action         Count       Time        Pct
4824                                                   commit            10     0.1079      88.27
4825                                                   select             5     0.0047       3.87
4826                                                   deleting           4     0.0028       2.29
4827                                                   inserting          4     0.0028       2.28
4828                                                   other              0     0.0040       3.29
4829                                                  
4830                                                  The first two (or three) lines show times and the source and destination tables.
4831                                                  The next three lines show how many rows were fetched, inserted, and deleted.
4832                                                  
4833                                                  The remaining lines show counts and timing.  The columns are the action, the
4834                                                  total number of times that action was timed, the total time it took, and the
4835                                                  percent of the program's total runtime.  The rows are sorted in order of
4836                                                  descending total time.  The last row is the rest of the time not explicitly
4837                                                  attributed to anything.  Actions will vary depending on command-line options.
4838                                                  
4839                                                  If L<"--why-quit"> is given, its behavior is changed slightly.  This option
4840                                                  causes it to print the reason for exiting even when it's just because there are
4841                                                  no more rows.
4842                                                  
4843                                                  This option requires the standard Time::HiRes module, which is part of core Perl
4844                                                  on reasonably new Perl releases.
4845                                                  
4846                                                  =item --stop
4847                                                  
4848                                                  Stop running instances by creating the sentinel file.
4849                                                  
4850                                                  Causes mk-archiver to create the sentinel file specified by L<"--sentinel"> and
4851                                                  exit.  This should have the effect of stopping all running instances which are
4852                                                  watching the same sentinel file.
4853                                                  
4854                                                  =item --txn-size
4855                                                  
4856                                                  type: int; default: 1
4857                                                  
4858                                                  Number of rows per transaction.
4859                                                  
4860                                                  Specifies the size, in number of rows, of each transaction. Zero disables
4861                                                  transactions altogether.  After mk-archiver processes this many rows, it
4862                                                  commits both the L<"--source"> and the L<"--dest"> if given, and flushes the
4863                                                  file given by L<"--file">.
4864                                                  
4865                                                  This parameter is critical to performance.  If you are archiving from a live
4866                                                  server, which for example is doing heavy OLTP work, you need to choose a good
4867                                                  balance between transaction size and commit overhead.  Larger transactions
4868                                                  create the possibility of more lock contention and deadlocks, but smaller
4869                                                  transactions cause more frequent commit overhead, which can be significant.  To
4870                                                  give an idea, on a small test set I worked with while writing mk-archiver, a
4871                                                  value of 500 caused archiving to take about 2 seconds per 1000 rows on an
4872                                                  otherwise quiet MySQL instance on my desktop machine, archiving to disk and to
4873                                                  another table.  Disabling transactions with a value of zero, which turns on
4874                                                  autocommit, dropped performance to 38 seconds per thousand rows.
4875                                                  
4876                                                  If you are not archiving from or to a transactional storage engine, you may
4877                                                  want to disable transactions so mk-archiver doesn't try to commit.
4878                                                  
4879                                                  =item --user
4880                                                  
4881                                                  short form: -u; type: string
4882                                                  
4883                                                  User for login if not current user.
4884                                                  
4885                                                  =item --version
4886                                                  
4887                                                  Show version and exit.
4888                                                  
4889                                                  =item --where
4890                                                  
4891                                                  type: string
4892                                                  
4893                                                  WHERE clause to limit which rows to archive (required).
4894                                                  
4895                                                  Specifies a WHERE clause to limit which rows are archived.  Do not include the
4896                                                  word WHERE.  You may need to quote the argument to prevent your shell from
4897                                                  interpreting it.  For example:
4898                                                  
4899                                                     --where 'ts < current_date - interval 90 day'
4900                                                  
4901                                                  For safety, L<"--where"> is required.  If you do not require a WHERE clause, use
4902                                                  L<"--where"> 1=1.
4903                                                  
4904                                                  =item --why-quit
4905                                                  
4906                                                  Print reason for exiting unless rows exhausted.
4907                                                  
4908                                                  Causes mk-archiver to print a message if it exits for any reason other than
4909                                                  running out of rows to archive.  This can be useful if you have a cron job with
4910                                                  L<"--run-time"> specified, for example, and you want to be sure mk-archiver is
4911                                                  finishing before running out of time.
4912                                                  
4913                                                  If L<"--statistics"> is given, the behavior is changed slightly.  It will print
4914                                                  the reason for exiting even when it's just because there are no more rows.
4915                                                  
4916                                                  This output prints even if L<"--quiet"> is given.  That's so you can put
4917                                                  C<mk-archiver> in a C<cron> job and get an email if there's an abnormal exit.
4918                                                  
4919                                                  =back
4920                                                  
4921                                                  =head1 EXTENDING
4922                                                  
4923                                                  mk-archiver is extensible by plugging in external Perl modules to handle some
4924                                                  logic and/or actions.  You can specify a module for both the L<"--source"> and
4925                                                  the L<"--dest">, with the 'm' part of the specification.  For example:
4926                                                  
4927                                                     --source D=test,t=test1,m=My::Module1 --dest m=My::Module2,t=test2
4928                                                  
4929                                                  This will cause mk-archiver to load the My::Module1 and My::Module2 packages,
4930                                                  create instances of them, and then make calls to them during the archiving
4931                                                  process.
4932                                                  
4933                                                  You can also specify a plugin with L<"--plugin">.
4934                                                  
4935                                                  The module must provide this interface:
4936                                                  
4937                                                  =over
4938                                                  
4939                                                  =item new(dbh => $dbh, db => $db_name, tbl => $tbl_name)
4940                                                  
4941                                                  The plugin's constructor is passed a reference to the database handle, the
4942                                                  database name, and table name.  The plugin is created just after mk-archiver
4943                                                  opens the connection, and before it examines the table given in the arguments.
4944                                                  This gives the plugin a chance to create and populate temporary tables, or do
4945                                                  other setup work.
4946                                                  
4947                                                  =item before_begin(cols => \@cols, allcols => \@allcols)
4948                                                  
4949                                                  This method is called just before mk-archiver begins iterating through rows
4950                                                  and archiving them, but after it does all other setup work (examining table
4951                                                  structures, designing SQL queries, and so on).  This is the only time
4952                                                  mk-archiver tells the plugin column names for the rows it will pass the
4953                                                  plugin while archiving.
4954                                                  
4955                                                  The C<cols> argument is the column names the user requested to be archived,
4956                                                  either by default or by the L<"--columns"> option.  The C<allcols> argument is
4957                                                  the list of column names for every row mk-archiver will fetch from the source
4958                                                  table.  It may fetch more columns than the user requested, because it needs some
4959                                                  columns for its own use.  When subsequent plugin functions receive a row, it is
4960                                                  the full row containing all the extra columns, if any, added to the end.
4961                                                  
4962                                                  =item is_archivable(row => \@row)
4963                                                  
4964                                                  This method is called for each row to determine whether it is archivable.  This
4965                                                  applies only to L<"--source">.  The argument is the row itself, as an arrayref.
4966                                                  If the method returns true, the row will be archived; otherwise it will be
4967                                                  skipped.
4968                                                  
4969                                                  Skipping a row adds complications for non-unique indexes.  Normally
4970                                                  mk-archiver uses a WHERE clause designed to target the last processed row as
4971                                                  the place to start the scan for the next SELECT statement.  If you have skipped
4972                                                  the row by returning false from is_archivable(), mk-archiver could get into
4973                                                  an infinite loop because the row still exists.  Therefore, when you specify a
4974                                                  plugin for the L<"--source"> argument, mk-archiver will change its WHERE clause
4975                                                  slightly.  Instead of starting at "greater than or equal to" the last processed
4976                                                  row, it will start "strictly greater than."  This will work fine on unique
4977                                                  indexes such as primary keys, but it may skip rows (leave holes) on non-unique
4978                                                  indexes or when ascending only the first column of an index.
4979                                                  
4980                                                  C<mk-archiver> will change the clause in the same way if you specify
4981                                                  L<"--no-delete">, because again an infinite loop is possible.
4982                                                  
4983                                                  If you specify the L<"--bulk-delete"> option and return false from this method,
4984                                                  C<mk-archiver> may not do what you want.  The row won't be archived, but it will
4985                                                  be deleted, since bulk deletes operate on ranges of rows and don't know which
4986                                                  rows the plugin selected to keep.
4987                                                  
4988                                                  If you specify the L<"--bulk-insert"> option, this method's return value will
4989                                                  influence whether the row is written to the temporary file for the bulk insert,
4990                                                  so bulk inserts will work as expected.  However, bulk inserts require bulk
4991                                                  deletes.
4992                                                  
4993                                                  =item before_delete(row => \@row)
4994                                                  
4995                                                  This method is called for each row just before it is deleted.  This applies only
4996                                                  to L<"--source">.  This is a good place for you to handle dependencies, such as
4997                                                  deleting things that are foreign-keyed to the row you are about to delete.  You
4998                                                  could also use this to recursively archive all dependent tables.
4999                                                  
5000                                                  This plugin method is called even if L<"--no-delete"> is given, but not if
5001                                                  L<"--bulk-delete"> is given.
5002                                                  
5003                                                  =item before_bulk_delete(first_row => \@row, last_row => \@row)
5004                                                  
5005                                                  This method is called just before a bulk delete is executed.  It is similar to
5006                                                  the C<before_delete> method, except its arguments are the first and last row of
5007                                                  the range to be deleted.  It is called even if L<"--no-delete"> is given.
5008                                                  
5009                                                  =item before_insert(row => \@row)
5010                                                  
5011                                                  This method is called for each row just before it is inserted.  This applies
5012                                                  only to L<"--dest">.  You could use this to insert the row into multiple tables,
5013                                                  perhaps with an ON DUPLICATE KEY UPDATE clause to build summary tables in a data
5014                                                  warehouse.
5015                                                  
5016                                                  This method is not called if L<"--bulk-insert"> is given.
5017                                                  
5018                                                  =item before_bulk_insert(first_row => \@row, last_row => \@row)
5019                                                  
5020                                                  This method is called just before a bulk insert is executed.  It is similar to
5021                                                  the C<before_insert> method, except its arguments are the first and last row of
5022                                                  the range to be deleted.
5023                                                  
5024                                                  =item custom_sth(row => \@row, sql => $sql)
5025                                                  
5026                                                  This method is called just before inserting the row, but after
5027                                                  L<"before_insert()">.  It allows the plugin to specify different C<INSERT>
5028                                                  statement if desired.  The return value (if any) should be a DBI statement
5029                                                  handle.  The C<sql> parameter is the SQL text used to prepare the default
5030                                                  C<INSERT> statement.  This method is not called if you specify
5031                                                  L<"--bulk-insert">.
5032                                                  
5033                                                  If no value is returned, the default C<INSERT> statement handle is used.
5034                                                  
5035                                                  This method applies only to the plugin specified for L<"--dest">, so if your
5036                                                  plugin isn't doing what you expect, check that you've specified it for the
5037                                                  destination and not the source.
5038                                                  
5039                                                  =item custom_sth_bulk(first_row => \@row, last_row => \@row, sql => $sql)
5040                                                  
5041                                                  If you've specified L<"--bulk-insert">, this method is called just before the
5042                                                  bulk insert, but after L<"before_bulk_insert()">, and the arguments are
5043                                                  different.
5044                                                  
5045                                                  This method's return value etc is similar to the L<"custom_sth()"> method.
5046                                                  
5047                                                  =item after_finish()
5048                                                  
5049                                                  This method is called after mk-archiver exits the archiving loop, commits all
5050                                                  database handles, closes L<"--file">, and prints the final statistics, but
5051                                                  before mk-archiver runs ANALYZE or OPTIMIZE (see L<"--analyze"> and
5052                                                  L<"--optimize">).
5053                                                  
5054                                                  =back
5055                                                  
5056                                                  If you specify a plugin for both L<"--source"> and L<"--dest">, mk-archiver
5057                                                  constructs, calls before_begin(), and calls after_finish() on the two plugins in
5058                                                  the order L<"--source">, L<"--dest">.
5059                                                  
5060                                                  mk-archiver assumes it controls transactions, and that the plugin will NOT
5061                                                  commit or roll back the database handle.  The database handle passed to the
5062                                                  plugin's constructor is the same handle mk-archiver uses itself.  Remember
5063                                                  that L<"--source"> and L<"--dest"> are separate handles.
5064                                                  
5065                                                  A sample module might look like this:
5066                                                  
5067                                                     package My::Module;
5068                                                  
5069                                                     sub new {
5070                                                        my ( $class, %args ) = @_;
5071                                                        return bless(\%args, $class);
5072                                                     }
5073                                                  
5074                                                     sub before_begin {
5075                                                        my ( $self, %args ) = @_;
5076                                                        # Save column names for later
5077                                                        $self->{cols} = $args{cols};
5078                                                     }
5079                                                  
5080                                                     sub is_archivable {
5081                                                        my ( $self, %args ) = @_;
5082                                                        # Do some advanced logic with $args{row}
5083                                                        return 1;
5084                                                     }
5085                                                  
5086                                                     sub before_delete {} # Take no action
5087                                                     sub before_insert {} # Take no action
5088                                                     sub custom_sth    {} # Take no action
5089                                                     sub after_finish  {} # Take no action
5090                                                  
5091                                                     1;
5092                                                  
5093                                                  =head1 DOWNLOADING
5094                                                  
5095                                                  You can download Maatkit from Google Code at
5096                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
5097                                                  easily with a command like the following:
5098                                                  
5099                                                     wget http://www.maatkit.org/get/toolname
5100                                                     or
5101                                                     wget http://www.maatkit.org/trunk/toolname
5102                                                  
5103                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
5104                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
5105                                                  needed.  The first URL gets the latest released version of the tool, and the
5106                                                  second gets the latest trunk code from Subversion.
5107                                                  
5108                                                  =head1 ENVIRONMENT
5109                                                  
5110                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
5111                                                  the Maatkit tools:
5112                                                  
5113                                                     MKDEBUG=1 mk-....
5114                                                  
5115                                                  =head1 SYSTEM REQUIREMENTS
5116                                                  
5117                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
5118                                                  installed in any reasonably new version of Perl.
5119                                                  
5120                                                  =head1 BUGS
5121                                                  
5122                                                  For a list of known bugs see L<http://www.maatkit.org/bugs/mk-archiver>.
5123                                                  
5124                                                  Please use Google Code Issues and Groups to report bugs or request support:
5125                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
5126                                                  discuss Maatkit.
5127                                                  
5128                                                  Please include the complete command-line used to reproduce the problem you are
5129                                                  seeing, the version of all MySQL servers involved, the complete output of the
5130                                                  tool when run with L<"--version">, and if possible, debugging output produced by
5131                                                  running with the C<MKDEBUG=1> environment variable.
5132                                                  
5133                                                  =head1 ACKNOWLEDGEMENTS
5134                                                  
5135                                                  Thanks to the following people, and apologies to anyone I've omitted:
5136                                                  
5137                                                  Andrew O'Brien,
5138                                                  
5139                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
5140                                                  
5141                                                  This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
5142                                                  Feedback and improvements are welcome.
5143                                                  
5144                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
5145                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
5146                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
5147                                                  
5148                                                  This program is free software; you can redistribute it and/or modify it under
5149                                                  the terms of the GNU General Public License as published by the Free Software
5150                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
5151                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
5152                                                  licenses.
5153                                                  
5154                                                  You should have received a copy of the GNU General Public License along with
5155                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
5156                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
5157                                                  
5158                                                  =head1 AUTHOR
5159                                                  
5160                                                  Baron Schwartz
5161                                                  
5162                                                  =head1 ABOUT MAATKIT
5163                                                  
5164                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
5165                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
5166                                                  code contributors.  Both are employed by Percona.  Financial support for
5167                                                  Maatkit development is primarily provided by Percona and its clients. 
5168                                                  
5169                                                  =head1 VERSION
5170                                                  
5171                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5425 $.
5172                                                  
5173                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
58    ***      0      0      0   unless $args{$arg}
64    ***      0      0      0   exists $args{'strict'} ? :
107   ***      0      0      0   unless open my $fh, '<', $file
127   ***      0      0      0   unless $para =~ /^=head1 OPTIONS/
132   ***      0      0      0   if $para =~ /^=over/
140   ***      0      0      0   unless $para
143   ***      0      0      0   if (my($option) = $para =~ /^=item --(.*)/)
150   ***      0      0      0   if ($para =~ /: /) { }
154   ***      0      0      0   unless $attributes{$attrib}
158   ***      0      0      0   if ($attribs{'short form'})
174   ***      0      0      0   if $para =~ /^=item/
176   ***      0      0      0   if (my($base_option) = $option =~ /^\[no\](.*)/)
181   ***      0      0      0   $attribs{'short form'} ? :
      ***      0      0      0   $attribs{'negatable'} ? :
      ***      0      0      0   $attribs{'cumulative'} ? :
      ***      0      0      0   $attribs{'type'} ? :
      ***      0      0      0   $attribs{'default'} ? :
      ***      0      0      0   $attribs{'group'} ? :
193   ***      0      0      0   unless $para
196   ***      0      0      0   if ($para =~ /^=head1/)
200   ***      0      0      0   if $para =~ /^=item --/
204   ***      0      0      0   unless @specs
215   ***      0      0      0   if (ref $opt) { }
220   ***      0      0      0   if (not $long)
225   ***      0      0      0   if exists $$self{'opts'}{$long}
228   ***      0      0      0   if (length $long == 1)
233   ***      0      0      0   if ($short) { }
234   ***      0      0      0   if exists $$self{'short_opts'}{$short}
243   ***      0      0      0   $$opt{'spec'} =~ /!/ ? :
244   ***      0      0      0   $$opt{'spec'} =~ /\+/ ? :
245   ***      0      0      0   $$opt{'desc'} =~ /required/ ? :
257   ***      0      0      0   if ($type and $type eq 'd' and not $$self{'dp'})
262   ***      0      0      0   if $type and $type =~ /[HhAadzm]/
264   ***      0      0      0   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
265   ***      0      0      0   defined $def ? :
269   ***      0      0      0   if ($long eq 'config')
273   ***      0      0      0   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
286   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
291   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
296   ***      0      0      0   if ($opt =~ /default to/)
301   ***      0      0      0   if ($opt =~ /restricted to option groups/)
311   ***      0      0      0   unless $rule_ok
328   ***      0      0      0   unless exists $$self{'opts'}{$long}
352   ***      0      0      0   unless exists $$self{'opts'}{$long}
372   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***      0      0      0   exists $$self{'opts'}{$opt} ? :
377   ***      0      0      0   if ($$opt{'is_cumulative'}) { }
392   ***      0      0      0   $$self{'opts'}{$long}{'is_cumulative'} ? :
      ***      0      0      0   exists $$self{'defaults'}{$long} ? :
401   ***      0      0      0   if (@ARGV and $ARGV[0] eq '--config')
405   ***      0      0      0   if ($self->has('config'))
411   ***      0      0      0   if ($EVAL_ERROR)
412   ***      0      0      0   $self->got('config') ? :
427   ***      0      0      0   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
430   ***      0      0      0   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
431   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
437   ***      0      0      0   if (@ARGV and $$self{'strict'})
443   ***      0      0      0   if (@set > 1)
454   ***      0      0      0   if (@set == 0)
464   ***      0      0      0   if ($$opt{'got'}) { }
      ***      0      0      0   elsif ($$opt{'is_required'}) { }
465   ***      0      0      0   if (exists $$self{'disables'}{$long})
472   ***      0      0      0   if (exists $$self{'allowed_groups'}{$long})
484   ***      0      0      0   if $restricted_opt eq $long
485   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
490   ***      0      0      0   if (@restricted_opts)
492   ***      0      0      0   if (@restricted_opts == 1) { }
521   ***      0      0      0   unless $opt and $$opt{'type'}
524   ***      0      0      0   if ($val and $$opt{'type'} eq 'm') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'd') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'z') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
527   ***      0      0      0   if (not $suffix)
533   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
534   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
549   ***      0      0      0   if ($from_key)
560   ***      0      0      0   if (defined $num) { }
561   ***      0      0      0   if ($factor)
588   ***      0      0      0   length $opt == 1 ? :
589   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
596   ***      0      0      0   length $opt == 1 ? :
597   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
604   ***      0      0      0   length $opt == 1 ? :
605   ***      0      0      0   defined $long ? :
610   ***      0      0      0   length $opt == 1 ? :
611   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
645   ***      0      0      0   if ($$self{'opts'}{'help'}{'got'}) { }
      ***      0      0      0   elsif (scalar @{$$self{'errors'};}) { }
646   ***      0      0      0   unless print $self->print_usage
650   ***      0      0      0   unless print $self->print_errors
659   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
668   ***      0      0      0   unless $$self{'got_opts'}
671   ***      0      0      0   $$_{'is_negatable'} ? :
675   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
691   ***      0      0      0   $group eq 'default' ? :
697   ***      0      0      0   $$opt{'is_negatable'} ? :
700   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
709   ***      0      0      0   if ($short) { }
718   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
722   ***      0      0      0   if ($$self{'dp'})
730   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
742   ***      0      0      0   if ref $_[0] eq 'OptionParser'
745   ***      0      0      0   unless print $prompt
753   ***      0      0      0   unless print "\n"
756   ***      0      0      0   if ($EVAL_ERROR)
778   ***      0      0      0   unless open my $fh, '<', $filename
786   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
789   ***      0      0      0   if ($line eq '--')
794   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
812   ***      0      0      0   unless open my $fh, '<', $file
816   ***      0      0      0   unless $para =~ /^=pod$/m
820   ***      0      0      0   unless $para =~ /$regex/
825   ***      0      0      0   unless close $fh
839   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
854   ***      0      0      0   defined $_ ? :
886   ***      0      0      0   unless $args{$arg}
895   ***      0      0      0   unless $ddl
896   ***      0      0      0   if (ref $ddl eq 'ARRAY')
897   ***      0      0      0   if (lc $$ddl[0] eq 'table') { }
907   ***      0      0      0   if (not $ddl =~ /CREATE (?:TEMPORARY )?TABLE `/)
913   ***      0      0      0   if $name
931   ***      0      0      0   unless $type
933   ***      0      0      0   if ($type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/)
937   ***      0      0      0   if (not $def =~ /NOT NULL/)
941   ***      0      0      0   $def =~ /AUTO_INCREMENT/i ? :
972   ***      0      0      0   unless ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
986   ***      0      0      0   if ($index)
989   ***      0      0      0   if (not $best)
990   ***      0      0      0   if ($index) { }
1003  ***      0      0      0   unless $where
1009  ***      0      0      0   if ($$expl{'possible_keys'}) { }
1013  ***      0      0      0   if ($$expl{'key'})
1033  ***      0      0      0   unless $args{$arg}
1047  ***      0      0      0   if ($EVAL_ERROR)
1051  ***      0      0      0   if (not $$row[0] or $$row[0] ne $tbl)
1057  ***      0      0      0   unless $args{'all_privs'}
1064  ***      0      0      0   if ($EVAL_ERROR)
1068  ***      0      0      0   if (not scalar keys %$row)
1079  ***      0      0      0   $EVAL_ERROR ? :
1084  ***      0      0      0   if (not $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete)
1110  ***      0      0      0   if $key =~ /FOREIGN/
1115  ***      0      0      0   if (not $engine =~ /MEMORY|HEAP/)
1122  ***      0      0      0   if ($$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i)
1129  ***      0      0      0   $key =~ /PRIMARY|UNIQUE/ ? :
1153  ***      0      0      0   if ($engine =~ /InnoDB/i and not $clustered_key)
1155  ***      0      0      0   if ($$this_key{'name'} eq 'PRIMARY') { }
      ***      0      0      0   elsif ($$this_key{'is_unique'} and not $$this_key{'is_nullable'}) { }
1179  ***      0      0      0   if (not $parent =~ /\./ and $$opts{'database'})
1208  ***      0      0      0   if (($$tbl_struct{'engine'} || '') =~ /InnoDB/i) { }
1222  ***      0      0      0   if (@sec_indexes)
1239  ***      0      0      0   defined $_ ? :
1325  ***     50      0     54   if (@_ > 2)
1334  ***     50      0     18   if (not $dsn)
1346  ***     50     72      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1358  ***     50      0    144   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1364         100     72     72   if (not defined $final_props{$key})
1371  ***     50      0     72   unless exists $opts{$key}
1374  ***     50      0     18   if (my $required = $self->prop('required'))
1376  ***      0      0      0   unless $final_props{$key}
1385  ***      0      0      0   unless ref $o eq 'OptionParser'
1388  ***      0      0      0   if $o->has($_)
1398  ***      0      0      0   unless ref $dsn
1399  ***      0      0      0   $_ eq 'p' ? :
1400  ***      0      0      0   if defined $$dsn{$_}
1413  ***      0      0      0   $opts{$key}{'copy'} ? :
1427  ***     50      0     18   if ($driver eq 'Pg') { }
1459  ***     50      0     18   $cxn_string =~ /charset=utf8/ ? :
1468  ***     50      0     18   if (not $have_dbi)
1487  ***     50     18      0   if ($cxn_string =~ /mysql/i)
1495  ***     50      0     18   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1500  ***      0      0      0   if ($charset eq 'utf8') { }
1501  ***      0      0      0   unless binmode STDOUT, ':utf8'
1505  ***      0      0      0   unless binmode STDOUT
1509  ***     50      0     18   if ($self->prop('set-vars'))
1516  ***     50      0     18   if (not $dbh and $EVAL_ERROR)
1518  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1531  ***      0      0      0   if (not $tries)
1553  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1570  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1580  ***      0      0      0   unless $dsn_1
1581  ***      0      0      0   unless $dsn_2
1585  ***      0      0      0   if ($args{'overwrite'}) { }
1586  ***      0      0      0   defined $$dsn_1{$key} ? :
1589  ***      0      0      0   defined $$dsn_2{$key} ? :
1598  ***      0      0      0   defined $_ ? :
1636  ***      0      0      0   if (not $$self{$dbh})
1640  ***      0      0      0   $$self{$dbh} ge $self->parse($target) ? :
1647  ***      0      0      0   defined $_ ? :
1687  ***      0      0      0   unless defined $val
1688  ***      0      0      0   if $val eq ''
1690  ***      0      0      0   if (not defined $is_numeric)
1691  ***      0      0      0   $val =~ /^0|\D/ ? :
1694  ***      0      0      0   if $is_numeric
1704  ***      0      0      0   if (not $tbl)
1713  ***      0      0      0   unless $like
1740  ***      0      0      0   unless $args{$arg}
1750  ***      0      0      0   unless defined $args{$arg}
1753  ***      0      0      0   $args{'cols'} ? :
1756  ***      0      0      0   unless exists $$tbl_struct{'keys'}{$index}
1765  ***      0      0      0   if ($args{'asc_first'})
1772  ***      0      0      0   if (not exists $col_posn{$col})
1788  ***      0      0      0   if (@asc_slice)
1800  ***      0      0      0   $args{'asc_only'} ? :
1812  ***      0      0      0   unless defined $args{$arg}
1833  ***      0      0      0   if ($$is_nullable{$col}) { }
1849  ***      0      0      0   if ($$is_nullable{$col}) { }
1850  ***      0      0      0   if ($type =~ /=/ and $end) { }
      ***      0      0      0   elsif ($type =~ />/) { }
1865  ***      0      0      0   $type =~ /=/ && $end ? :
1883  ***      0      0      0   $args{'cols'} ? :
1891  ***      0      0      0   unless $index
1893  ***      0      0      0   if ($index) { }
1903  ***      0      0      0   if (not exists $col_posn{$col})
1924  ***      0      0      0   if ($$tbl{'is_nullable'}{$col}) { }
1944  ***      0      0      0   unless $args{$arg}
1949  ***      0      0      0   unless @sel_cols
1954  ***      0      0      0   unless $$ins_tbl{'is_col'}{$sel_cols[$i]}
1967  ***      0      0      0   defined $_ ? :
2017  ***      0      0      0   unless defined $args{'cache'}
2025  ***      0      0      0   if ($what eq 'table') { }
      ***      0      0      0   elsif ($what eq 'triggers') { }
      ***      0      0      0   elsif ($what eq 'view') { }
2027  ***      0      0      0   unless $ddl
2028  ***      0      0      0   if ($$ddl[0] eq 'table') { }
2042  ***      0      0      0   if ($trgs and @$trgs) { }
2045  ***      0      0      0   if ($$trg{'sql_mode'})
2049  ***      0      0      0   if ($$trg{'definer'})
2081  ***      0      0      0   if (not $new)
2088  ***      0      0      0   if ($curr and $new and $curr eq $new)
2100  ***      0      0      0   if (not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl})
2113  ***      0      0      0   if ($EVAL_ERROR)
2123  ***      0      0      0   if ($key) { }
2139  ***      0      0      0   if (not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl})
2169  ***      0      0      0   if (not $$self{'cache'} or not $$self{'triggers'}{$db})
2182  ***      0      0      0   if ($sth->rows)
2195  ***      0      0      0   if ($tbl)
2203  ***      0      0      0   if (not $$self{'cache'} or not $$self{'databases'} or $like)
2206  ***      0      0      0   if ($like)
2214  ***      0      0      0   unless $like
2222  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_status'}{$db} or $like)
2225  ***      0      0      0   if ($like)
2240  ***      0      0      0   unless $like
2248  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_list'}{$db} or $like)
2251  ***      0      0      0   if ($like)
2259  ***      0      0      0   ($$_[1] || '') eq 'VIEW' ? :
2266  ***      0      0      0   unless $like
2274  ***      0      0      0   defined $_ ? :
2303  ***      0      0      0   unless $args{$arg}
2306  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
2322  ***      0      0      0   unless defined(my $pid = fork)
2323  ***      0      0      0   if ($pid)
2330  ***      0      0      0   unless POSIX::setsid()
2331  ***      0      0      0   unless chdir '/'
2337  ***      0      0      0   if (-t STDIN)
2339  ***      0      0      0   unless open STDIN, '/dev/null'
2343  ***      0      0      0   if ($$self{'log_file'}) { }
2345  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
2349  ***      0      0      0   unless open STDERR, '>&STDOUT'
2353  ***      0      0      0   if (-t STDOUT)
2355  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
2358  ***      0      0      0   if (-t STDERR)
2360  ***      0      0      0   unless open STDERR, '>', '/dev/null'
2371  ***      0      0      0   $self ? :
2373  ***      0      0      0   if ($PID_file and -f $PID_file) { }
2376  ***      0      0      0   if $EVAL_ERROR
2378  ***      0      0      0   if ($pid) { }
2380  ***      0      0      0   if ($pid_is_alive) { }
2402  ***      0      0      0   if (exists $$self{'child'})
2414  ***      0      0      0   if (not $PID_file)
2421  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
2423  ***      0      0      0   unless print $PID_FH $PID
2425  ***      0      0      0   unless close $PID_FH
2434  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
2435  ***      0      0      0   unless unlink $$self{'PID_file'}
2447  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
2453  ***      0      0      0   defined $_ ? :
2497  ***      0      0      0   if ($EVAL_ERROR)
2498  ***      0      0      0   unless print STDERR 'Cannot connect to ', $dp->as_string($dsn), "\n"
2508  ***      0      0      0   if (not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++)
2513  ***      0      0      0   if ($$args{'skip_callback'})
2521  ***      0      0      0   if (not defined $$args{'recurse'} or $level < $$args{'recurse'})
2523  ***      0      0      0   unless not $$_{'master_id'}
2540  ***      0      0      0   if ($method) { }
2545  ***      0      0      0   if (($$dsn{'P'} || 3306) != 3306)
2559  ***      0      0      0   if @slaves
2577  ***      0      0      0   if ($host eq 'localhost')
2594  ***      0      0      0   if (@slaves)
2599  ***      0      0      0   $hash{'user'} ? :
      ***      0      0      0   $hash{'password'} ? :
2619  ***      0      0      0   if (not $proc)
2636  ***      0      0      0   unless my $master_status = $self->get_master_status($master)
2638  ***      0      0      0   unless my $slave_status = $self->get_slave_status($slave)
2640  ***      0      0      0   unless my(@connected) = $self->get_connected_slaves($master)
2644  ***      0      0      0   if ($port != $$slave_status{'master_port'})
2649  ***      0      0      0   if (not grep {$$slave_status{'master_user'} eq $$_{'user'};} @connected)
2654  ***      0      0      0   if (($$slave_status{'slave_io_state'} || '') eq 'Waiting for master to send event')
2661  ***      0      0      0   if ($master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1)
2674  ***      0      0      0   unless my $master = $self->get_slave_status($dbh)
2681  ***      0      0      0   if (not $$self{'not_a_slave'}{$dbh})
2688  ***      0      0      0   if ($ss and %$ss)
2700  ***      0      0      0   if (not $$self{'not_a_master'}{$dbh})
2707  ***      0      0      0   if ($ms and %$ms)
2709  ***      0      0      0   if ($$ms{'file'} and $$ms{'position'})
2722  ***      0      0      0   unless defined $time
2726  ***      0      0      0   if ($ms) { }
2730  ***      0      0      0   defined $result ? :
2732  ***      0      0      0   if ($stat eq 'NULL' or $stat < 0 and not $timeoutok)
2752  ***      0      0      0   if ($pos) { }
2776  ***      0      0      0   if ($self->pos_cmp($slave_pos, $master_pos) < 0)
2782  ***      0      0      0   if ($EVAL_ERROR)
2784  ***      0      0      0   if ($EVAL_ERROR =~ /MASTER_POS_WAIT returned NULL/) { }
2786  ***      0      0      0   if (not $self->slave_is_running($slave_status)) { }
2791  ***      0      0      0   if ($self->pos_cmp($slave_pos, $master_pos) != 0)
2815  ***      0      0      0   if ($self->pos_cmp($s1_pos, $s2_pos) < 0) { }
      ***      0      0      0   elsif ($self->pos_cmp($s2_pos, $s1_pos) < 0) { }
2827  ***      0      0      0   if ($self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0)
2850  ***      0      0      0   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
2854  ***      0      0      0   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
2859  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn))
2873  ***      0      0      0   if (not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0) { }
2888  ***      0      0      0   if ($self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0)
2899  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($sib_dsn))
2903  ***      0      0      0   unless my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
2907  ***      0      0      0   unless my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
2909  ***      0      0      0   if ($self->short_host($master_dsn1) ne $self->short_host($master_dsn2))
2912  ***      0      0      0   unless my $sib_master_stat = $self->get_master_status($sib_dbh)
2914  ***      0      0      0   unless $self->has_slave_updates($sib_dbh)
2926  ***      0      0      0   if ($self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
2938  ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($unc_dsn))
2942  ***      0      0      0   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
2946  ***      0      0      0   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
2949  ***      0      0      0   unless my $unc_master_dsn = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
2952  ***      0      0      0   if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn))
2956  ***      0      0      0   unless my $unc_master_stat = $self->get_master_status($unc_dbh)
2958  ***      0      0      0   unless $self->has_slave_updates($unc_dbh)
2966  ***      0      0      0   if ($self->pos_cmp($self->repl_posn($slave_status), $self->repl_posn($master_status)) != 0)
2980  ***      0      0      0   if ($self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
2991  ***      0      0      0   unless my $stat = $self->get_slave_status($dbh)
3013  ***      0      0      0   if (exists $$status{'file'} and exists $$status{'position'}) { }
3041  ***      0      0      0   if ($$dsn{'master_host'}) { }
3049  ***      0      0      0   ($port || 3306) == 3306 ? :
3060  ***      0      0      0   defined $_ ? :
3147  ***      0      0      0   if ($o->get('stop'))
3148  ***      0      0      0   unless my $sentinel_fh = 'IO::File'->new($sentinel, '>>')
3150  ***      0      0      0   unless print $sentinel_fh "Remove this file to permit mk-archiver to run\n"
3152  ***      0      0      0   unless close $sentinel_fh
3154  ***      0      0      0   unless $quiet
3160  ***      0      0      0   if ($archive_file)
3162  ***      0      0      0   $src && $$src{'D'} ? :
      ***      0      0      0   $src && $$src{'t'} ? :
3175  ***      0      0      0   if (not $o->got('help'))
3176  ***      0      0      0   unless $$src{'t'}
3179  ***      0      0      0   if ($dst)
3183  ***      0      0      0   if (defined $$src{$arg} and defined $$dst{$arg} and $$src{$arg} ne $$dst{$arg})
3189  ***      0      0      0   if ($same)
3193  ***      0      0      0   if ($o->get('bulk-insert'))
3194  ***      0      0      0   unless $dst
3198  ***      0      0      0   if ($bulk_del and $limit < 2)
3204  ***      0      0      0   if ($bulk_del or $o->get('bulk-insert'))
3214  ***      0      0      0   if ($o->get('pid'))
3228  ***      0      0      0   if ($o->get('statistics')) { }
3257  ***      0      0      0   if (not defined $$table{'p'} and $o->get('ask-pass'))
3265  ***      0      0      0   if ($$table{'a'})
3268  ***      0      0      0   if ($$table{'b'})
3286  ***      0      0      0   if ($$table{'m'})
3288  ***      0      0      0   if $EVAL_ERROR
3303  ***      0      0      0   if ($o->get('primary-key-only') and not exists $$src{'info'}{'keys'}{'PRIMARY'})
3309  ***      0      0      0   if ($dst and $o->get('check-columns'))
3313  ***      0      0      0   if (@not_in_src)
3321  ***      0      0      0   if (@not_in_dst)
3333  ***      0      0      0   if ($o->get('check-slave-lag'))
3344  ***      0      0      0   if ($o->get('plugin'))
3346  ***      0      0      0   if $EVAL_ERROR
3367  ***      0      0      0   $o->get('primary-key-only') ? :
      ***      0      0      0   $o->get('columns') ? :
3378  ***      0      0      0   if (not $o->get('no-ascend')) { }
3403  ***      0      0      0   $o->get('high-priority-select') ? :
      ***      0      0      0   $vp->version_ge($dbh, '4.0.9') ? :
      ***      0      0      0   $$sel_stmt{'index'} ? :
3411  ***      0      0      0   if ($o->get('safe-auto-increment') and $$sel_stmt{'index'} and scalar @{$$src{'info'}{'keys'}{$$sel_stmt{'index'}}{'cols'};} == 1 and $$src{'info'}{'is_autoinc'}{$$src{'info'}{'keys'}{$$sel_stmt{'index'}}{'cols'}[0]})
3424  ***      0      0      0   if (not $o->get('no-ascend'))
3430  ***      0      0      0   if ($o->get('for-update')) { }
      ***      0      0      0   elsif ($o->get('share-lock')) { }
3438  ***      0      0      0   if (not $bulk_del) { }
3445  ***      0      0      0   $o->get('low-priority-delete') ? :
      ***      0      0      0   $o->get('quick-delete') ? :
3460  ***      0      0      0   $o->get('low-priority-delete') ? :
      ***      0      0      0   $o->get('quick-delete') ? :
3472  ***      0      0      0   if ($dst) { }
3479  ***      0      0      0   if ($o->get('bulk-insert')) { }
3486  ***      0      0      0   $o->get('low-priority-insert') ? :
      ***      0      0      0   $o->get('replace') ? :
      ***      0      0      0   $o->get('ignore') ? :
3497  ***      0      0      0   $o->get('replace') ? :
      ***      0      0      0   $o->get('low-priority-insert') ? :
      ***      0      0      0   $o->get('delayed-insert') ? :
      ***      0      0      0   $o->get('ignore') ? :
3504  ***      0      0      0   if ($o->get('dry-run'))
3505  ***      0      0      0   if (not $quiet)
3506  ***      0      0      0   $o->get('no-delete') ? :
3524  ***      0      0      0   if $dst
3530  ***      0      0      0   if ($o->get('skip-foreign-key-checks'))
3532  ***      0      0      0   if ($dst)
3541  ***      0      0      0   unless $table and $$table{'plugin'}
3558  ***      0      0      0   if $o->get('progress') and not $quiet
3560  ***      0      0      0   if $o->get('progress') and not $quiet
3572  ***      0      0      0   if (not $row)
3575  ***      0      0      0   if $dst
3580  ***      0      0      0   if ($archive_file)
3582  ***      0      0      0   unless $archive_fh = 'IO::File'->new($archive_file, '>>')
3584  ***      0      0      0   unless $o->get('buffer')
3585  ***      0      0      0   if ($need_hdr)
3586  ***      0      0      0   unless print $archive_fh '', escape(\@sel_cols), "\n"
3593  ***      0      0      0   if ($o->get('bulk-insert'))
3595  ***      0      0      0   unless $bulkins_file = 'File::Temp'->new('SUFFIX', 'mk-archiver')
3614  ***      0      0      0   if (not $$src{'plugin'} or trace('is_archivable', sub {
	$$src{'plugin'}->is_archivable('row', $row);
}
))
3624  ***      0      0      0   if ($archive_fh or $bulkins_file)
3627  ***      0      0      0   if ($archive_fh)
3629  ***      0      0      0   unless print $archive_fh $escaped_row, "\n"
3638  ***      0      0      0   if ($dst and not $bulkins_file)
3640  ***      0      0      0   if ($$dst{'plugin'})
3654  ***      0      0      0   if ($success == $OUT_OF_RETRIES) { }
      ***      0      0      0   elsif ($success == $ROLLED_BACK) { }
3664  ***      0      0      0   if (not $bulk_del)
3666  ***      0      0      0   if ($$src{'plugin'})
3671  ***      0      0      0   if (not $o->get('no-delete'))
3676  ***      0      0      0   if ($success == $OUT_OF_RETRIES) { }
      ***      0      0      0   elsif ($success == $ROLLED_BACK) { }
3690  ***      0      0      0   if ($bulkins_file)
3692  ***      0      0      0   unless print $bulkins_file $escaped_row, "\n"
3705  ***      0      0      0   unless $commit_each
3708  ***      0      0      0   if (not $quiet and $o->get('progress') and $cnt % $o->get('progress') == 0)
3713  ***      0      0      0   if ($$get_sth{'Active'})
3716  ***      0      0      0   if (not $row)
3721  ***      0      0      0   if ($bulkins_file)
3722  ***      0      0      0   unless $bulkins_file->close
3725  ***      0      0      0   if ($$dst{'plugin'})
3745  ***      0      0      0   if ($success != $ALL_IS_WELL)
3751  ***      0      0      0   if ($bulk_del)
3752  ***      0      0      0   if ($$src{'plugin'})
3760  ***      0      0      0   if (not $o->get('no-delete'))
3768  ***      0      0      0   if ($success != $ALL_IS_WELL)
3778  ***      0      0      0   if $commit_each
3788  ***      0      0      0   unless $txn_cnt
3790  ***      0      0      0   $row ? :
3792  ***      0      0      0   if ($o->get('bulk-insert'))
3793  ***      0      0      0   unless $bulkins_file = 'File::Temp'->new('SUFFIX', 'mk-archiver')
3798  ***      0      0      0   if ($lag_dbh)
3808  ***      0      0      0   if (my $sleep_time = $o->get('sleep'))
3809  ***      0      0      0   if $o->get('sleep-coef')
3820  ***      0      0      0   if ($archive_file and $archive_fh)
3821  ***      0      0      0   unless close $archive_fh
3825  ***      0      0      0   if (not $quiet and $o->get('progress'))
3831  ***      0      0      0   unless $table and $$table{'plugin'}
3838  ***      0      0      0   if ($oktorun and $o->get('analyze') || $o->get('optimize'))
3840  ***      0      0      0   $o->get('analyze') ? :
      ***      0      0      0   $o->get('local') ? :
3842  ***      0      0      0   if ($action =~ /s/i)
3847  ***      0      0      0   if ($action =~ /d/i and $dst)
3857  ***      0      0      0   if ($plugin)
3861  ***      0      0      0   if (not $quiet and $o->get('statistics'))
3871  ***      0      0      0   if $dst
3901  ***      0      0      0   if ($o->get('why-quit'))
3902  ***      0      0      0   if ($retries < 0) { }
      ***      0      0      0   elsif ($o->get('run-time') and $now >= $end) { }
      ***      0      0      0   elsif (-f $sentinel) { }
      ***      0      0      0   elsif ($o->get('statistics')) { }
3934  ***      0      0      0   if ($force or $txnsize and $txn_cnt and $cnt % $txnsize == 0)
3935  ***      0      0      0   if ($o->get('buffer') and $archive_fh)
3938  ***      0      0      0   unless $archive_fh->flush
3941  ***      0      0      0   if ($dst)
3968  ***      0      0      0   if ($EVAL_ERROR)
3969  ***      0      0      0   if ($EVAL_ERROR =~ /Lock wait timeout exceeded|Deadlock found/) { }
3970  ***      0      0      0   if ($txnsize && $txnsize > 1 || $o->get('commit-each') && $o->get('limit') > 1 and $txn_cnt and !$can_retry || $EVAL_ERROR =~ /Deadlock/) { }
3996  ***      0      0      0   if ($success != $ALL_IS_WELL)
3998  ***      0      0      0   if ($retries >= 0) { }
4029  ***      0      0      0   if defined $_
4031  ***      0      0      0   defined $_ ? :
4047  ***      0      0      0   unless $vp->version_ge($dbh, '5.0.13')
4051  ***      0      0      0   unless $rows
4057  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
257   ***      0      0      0      0   $type and $type eq 'd'
      ***      0      0      0      0   $type and $type eq 'd' and not $$self{'dp'}
262   ***      0      0      0      0   $type and $type =~ /[HhAadzm]/
401   ***      0      0      0      0   @ARGV and $ARGV[0] eq '--config'
430   ***      0      0      0      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
437   ***      0      0      0      0   @ARGV and $$self{'strict'}
521   ***      0      0      0      0   $opt and $$opt{'type'}
524   ***      0      0      0      0   $val and $$opt{'type'} eq 'm'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'd'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'z'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'a'
589   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
597   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
611   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
700   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
794   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1084  ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete
1122  ***      0      0      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000'
      ***      0      0      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i
1153  ***      0      0      0      0   $engine =~ /InnoDB/i and not $clustered_key
1155  ***      0      0      0      0   $$this_key{'is_unique'} and not $$this_key{'is_nullable'}
1179  ***      0      0      0      0   not $parent =~ /\./ and $$opts{'database'}
1358  ***     66     72     72      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33    144      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1480  ***     66     18      0     18   not $dbh and $tries--
1516  ***     33     18      0      0   not $dbh and $EVAL_ERROR
1850  ***      0      0      0      0   $type =~ /=/ and $end
1865  ***      0      0      0      0   $type =~ /=/ && $end
2042  ***      0      0      0      0   $trgs and @$trgs
2088  ***      0      0      0      0   $curr and $new
      ***      0      0      0      0   $curr and $new and $curr eq $new
2373  ***      0      0      0      0   $PID_file and -f $PID_file
2434  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
2508  ***      0      0      0      0   defined $master_thinks_i_am and $master_thinks_i_am != $id
2688  ***      0      0      0      0   $ss and %$ss
2707  ***      0      0      0      0   $ms and %$ms
2709  ***      0      0      0      0   $$ms{'file'} and $$ms{'position'}
2732  ***      0      0      0      0   $stat < 0 and not $timeoutok
2873  ***      0      0      0      0   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status)
      ***      0      0      0      0   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0
3008  ***      0      0      0      0   $value && $value =~ /^(1|ON)$/
3013  ***      0      0      0      0   exists $$status{'file'} and exists $$status{'position'}
3162  ***      0      0      0      0   $src && $$src{'D'}
      ***      0      0      0      0   $src && $$src{'t'}
3183  ***      0      0      0      0   defined $$src{$arg} and defined $$dst{$arg}
      ***      0      0      0      0   defined $$src{$arg} and defined $$dst{$arg} and $$src{$arg} ne $$dst{$arg}
3198  ***      0      0      0      0   $bulk_del and $limit < 2
3256  ***      0      0      0      0   !$txnsize && !$commit_each
3257  ***      0      0      0      0   not defined $$table{'p'} and $o->get('ask-pass')
3275  ***      0      0      0      0   $can_retry && !$$table{'irot'}
3303  ***      0      0      0      0   $o->get('primary-key-only') and not exists $$src{'info'}{'keys'}{'PRIMARY'}
3309  ***      0      0      0      0   $dst and $o->get('check-columns')
3411  ***      0      0      0      0   $o->get('safe-auto-increment') and $$sel_stmt{'index'}
      ***      0      0      0      0   $o->get('safe-auto-increment') and $$sel_stmt{'index'} and scalar @{$$src{'info'}{'keys'}{$$sel_stmt{'index'}}{'cols'};} == 1
      ***      0      0      0      0   $o->get('safe-auto-increment') and $$sel_stmt{'index'} and scalar @{$$src{'info'}{'keys'}{$$sel_stmt{'index'}}{'cols'};} == 1 and $$src{'info'}{'is_autoinc'}{$$src{'info'}{'keys'}{$$sel_stmt{'index'}}{'cols'}[0]}
3541  ***      0      0      0      0   $table and $$table{'plugin'}
3558  ***      0      0      0      0   $o->get('progress') and not $quiet
3560  ***      0      0      0      0   $o->get('progress') and not $quiet
3581  ***      0      0      0      0   $o->get('header') && !-f($archive_file)
3604  ***      0      0      0      0   $row and $retries >= 0
      ***      0      0      0      0   $row and $retries >= 0 and !$o->get('run-time') || $now < $end
      ***      0      0      0      0   $row and $retries >= 0 and !$o->get('run-time') || $now < $end and not -f $sentinel
      ***      0      0      0      0   $row and $retries >= 0 and !$o->get('run-time') || $now < $end and not -f $sentinel and $oktorun
3638  ***      0      0      0      0   $dst and not $bulkins_file
3708  ***      0      0      0      0   not $quiet and $o->get('progress')
      ***      0      0      0      0   not $quiet and $o->get('progress') and $cnt % $o->get('progress') == 0
3820  ***      0      0      0      0   $archive_file and $archive_fh
3825  ***      0      0      0      0   not $quiet and $o->get('progress')
3831  ***      0      0      0      0   $table and $$table{'plugin'}
3838  ***      0      0      0      0   $oktorun and $o->get('analyze') || $o->get('optimize')
3847  ***      0      0      0      0   $action =~ /d/i and $dst
3861  ***      0      0      0      0   not $quiet and $o->get('statistics')
3902  ***      0      0      0      0   $o->get('run-time') and $now >= $end
3934  ***      0      0      0      0   $txnsize and $txn_cnt
      ***      0      0      0      0   $txnsize and $txn_cnt and $cnt % $txnsize == 0
3935  ***      0      0      0      0   $o->get('buffer') and $archive_fh
3963  ***      0      0      0      0   not $success and $retries >= 0
3970  ***      0      0      0      0   $txnsize && $txnsize > 1
      ***      0      0      0      0   $o->get('commit-each') && $o->get('limit') > 1
      ***      0      0      0      0   $txnsize && $txnsize > 1 || $o->get('commit-each') && $o->get('limit') > 1 and $txn_cnt
      ***      0      0      0      0   $txnsize && $txnsize > 1 || $o->get('commit-each') && $o->get('limit') > 1 and $txn_cnt and !$can_retry || $EVAL_ERROR =~ /Deadlock/
4052  ***      0      0      0      0   @$rows && $$rows[0]{'Value'} ne 'OFF'

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
42    ***     50      0     16   $ENV{'MKDEBUG'} || 0
62    ***      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
64    ***      0      0      0   $args{'prompt'} || '<options>'
      ***      0      0      0   $args{'dp'} || undef
106   ***      0      0      0   $file ||= '/home/daniel/dev/maatkit/mk-archiver/mk-archiver'
247   ***      0      0      0   $$opt{'group'} ||= 'default'
529   ***      0      0      0   $s || 's'
538   ***      0      0      0   $prefix || ''
566   ***      0      0      0   $pre || ''
573   ***      0      0      0   $val || ''
576   ***      0      0      0   $val || ''
634   ***      0      0      0   $$self{'description'} || ''
702   ***      0      0      0   $s ||= 's'
728   ***      0      0      0   $$opt{'type'} || ''
879   ***     50      0     16   $ENV{'MKDEBUG'} || 0
1098  ***      0      0      0   $engine || undef
1121  ***      0      0      0   $type || $special || 'BTREE'
1208  ***      0      0      0   $$tbl_struct{'engine'} || ''
1210  ***      0      0      0   $clustered_key ||= ''
1268  ***     50      0     16   $ENV{'MKDEBUG'} || 0
1339  ***     50      0     18   $prev ||= {}
1340  ***     50      0     18   $defaults ||= {}
1413  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1426  ***     50      0     18   $self->prop('dbidriver') || ''
1430  ***      0      0      0   $$info{'D'} || ''
1436  ***     50      0     18   $$info{'D'} || ''
1458  ***     50     18      0   $opts ||= {}
1553  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1569  ***      0      0      0   $level ||= 0
1570  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1620  ***     50      0     16   $ENV{'MKDEBUG'} || 0
1669  ***     50      0     16   $ENV{'MKDEBUG'} || 0
1734  ***     50      0     16   $ENV{'MKDEBUG'} || 0
1989  ***     50      0     16   $ENV{'MKDEBUG'} || 0
2259  ***      0      0      0   $$_[1] || ''
2298  ***     50      0     16   $ENV{'MKDEBUG'} || 0
2479  ***     50      0     16   $ENV{'MKDEBUG'} || 0
2487  ***      0      0      0   $level ||= 0
2545  ***      0      0      0   $$dsn{'P'} || 3306
2654  ***      0      0      0   $$slave_status{'slave_io_state'} || ''
3000  ***      0      0      0   $$slave_status{'slave_sql_running'} || 'No'
3049  ***      0      0      0   $host || '[default]'
      ***      0      0      0   $port || 3306
3091  ***     50      0     16   $ENV{'MKDEBUG'} || 0
3506  ***      0      0      0   $archive_file || ''
3554  ***      0      0      0   $o->get('run-time') || 0
3872  ***      0      0      0   $statistics{$_} || 0
3882  ***      0      0      0   $summary{$action}{'time'} ||= 0
3883  ***      0      0      0   $summary{$action}{'count'} ||= 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
61    ***      0      0      0      0   $program_name ||= $PROGRAM_NAME
62    ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
524   ***      0      0      0      0   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
972   ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'}
      ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
1051  ***      0      0      0      0   not $$row[0] or $$row[0] ne $tbl
1072  ***      0      0      0      0   $$row{'privileges'} || $$row{'Privileges'}
1121  ***      0      0      0      0   $type || $special
1449  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1450  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1451  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1452  ***      0      0      0      0   $$dsn{'u'} ||= $user
1453  ***      0      0      0      0   $$dsn{'D'} ||= $db
2100  ***      0      0      0      0   not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl}
2139  ***      0      0      0      0   not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl}
2169  ***      0      0      0      0   not $$self{'cache'} or not $$self{'triggers'}{$db}
2203  ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'} or $like
2222  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db} or $like
2236  ***      0      0      0      0   $tbl{'type'} || $tbl{'comment'}
      ***      0      0      0      0   $tbl{'engine'} ||= $tbl{'type'} || $tbl{'comment'}
2248  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db} or $like
2447  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
2493  ***      0      0      0      0   $$args{'dbh'} || $dp->get_dbh($dp->get_cxn_params($dsn), {'AutoCommit', 1})
2508  ***      0      0      0      0   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id
      ***      0      0      0      0   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++
2521  ***      0      0      0      0   not defined $$args{'recurse'} or $level < $$args{'recurse'}
2661  ***      0      0      0      0   $master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1
2682  ***      0      0      0      0   $$self{'sths'}{$dbh}{'SLAVE_STATUS'} ||= $dbh->prepare('SHOW SLAVE STATUS')
2701  ***      0      0      0      0   $$self{'sths'}{$dbh}{'MASTER_STATUS'} ||= $dbh->prepare('SHOW MASTER STATUS')
2725  ***      0      0      0      0   $ms ||= $self->get_master_status($master)
2732  ***      0      0      0      0   $stat eq 'NULL' or $stat < 0 and not $timeoutok
2744  ***      0      0      0      0   $$self{'sths'}{$dbh}{'STOP_SLAVE'} ||= $dbh->prepare('STOP SLAVE')
2759  ***      0      0      0      0   $$self{'sths'}{$dbh}{'START_SLAVE'} ||= $dbh->prepare('START SLAVE')
2827  ***      0      0      0      0   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status)
      ***      0      0      0      0   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0
2888  ***      0      0      0      0   $self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0
2926  ***      0      0      0      0   $self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0
2980  ***      0      0      0      0   $self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0
3204  ***      0      0      0      0   $bulk_del or $o->get('bulk-insert')
3233  ***      0      0      0      0    ||= 
3239  ***      0      0      0      0   $stat_start ||= $start
3379  ***      0      0      0      0   $$src{'m'} || $o->get('no-delete')
3604  ***      0      0      0      0   !$o->get('run-time') || $now < $end
3614  ***      0      0      0      0   not $$src{'plugin'} or trace('is_archivable', sub {
	$$src{'plugin'}->is_archivable('row', $row);
}
)
3624  ***      0      0      0      0   $archive_fh or $bulkins_file
3649  ***      0      0      0      0   $ins_sth ||= $ins_row
3740  ***      0      0      0      0   $ins_sth ||= $ins_row
3800  ***      0      0      0      0   not defined $lag or $lag > $o->get('max-lag')
3819  ***      0      0      0      0   $txnsize || $commit_each
3838  ***      0      0      0      0   $o->get('analyze') || $o->get('optimize')
3839  ***      0      0      0      0   $o->get('analyze') || $o->get('optimize')
3934  ***      0      0      0      0   $force or $txnsize and $txn_cnt and $cnt % $txnsize == 0
3970  ***      0      0      0      0   $txnsize && $txnsize > 1 || $o->get('commit-each') && $o->get('limit') > 1
      ***      0      0      0      0   !$can_retry || $EVAL_ERROR =~ /Deadlock/


Covered Subroutines
-------------------

Subroutine                  Count Location                                             
--------------------------- ----- -----------------------------------------------------
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1256
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1257
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1258
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1259
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1268
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1615
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1616
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1618
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1620
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1662
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1663
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1667
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1669
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1729
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1730
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1732
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1734
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1984
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1985
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1987
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1989
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2292
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2293
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2295
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2296
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2298
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:23  
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:24  
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2468
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2469
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2473
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2474
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2475
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2479
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3082
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3083
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3084
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3085
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3086
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3087
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3091
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:35  
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:36  
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:38  
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:39  
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:40  
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:42  
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:871 
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:872 
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:873 
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:874 
BEGIN                          16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:879 
get_cxn_params                 18 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1423
get_dbh                        18 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1457
new                            32 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1271
new                            16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1623
new                            16 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1672
parse                          18 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1333
prop                           54 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1324

Uncovered Subroutines
---------------------

Subroutine                  Count Location                                             
--------------------------- ----- -----------------------------------------------------
DESTROY                         0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2446
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3233
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3244
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3291
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3543
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3565
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3616
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3629
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3642
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3645
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3651
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3668
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3673
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3692
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3727
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3733
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3742
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3754
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3764
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3782
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3813
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3833
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3844
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3849
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3938
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3943
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3947
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:4009
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:4012
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:4016
__ANON__                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:425 
_d                              0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1238
_d                              0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1597
_d                              0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1646
_d                              0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1966
_d                              0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2273
_d                              0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2452
_d                              0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3059
_d                              0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:4056
_d                              0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:853 
_find_slaves_by_hosts           0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2587
_find_slaves_by_processlist     0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2567
_get_participants               0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:325 
_make_PID_file                  0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2411
_parse_specs                    0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:211 
_pod_to_specs                   0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:105 
_read_config_file               0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:777 
_remove_PID_file                0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2433
_set_option                     0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:371 
_use_db                         0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2080
_validate_type                  0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:520 
as_string                       0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1397
catchup_to_master               0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2767
catchup_to_same_pos             0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2808
change_master_to                0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2837
check_PID_file                  0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2370
check_table                     0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1030
clone                           0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:830 
commit                          0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3932
copy                            0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1579
daemonize                       0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2319
descr                           0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:633 
detach_slave                    0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2989
disconnect                      0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1562
do_with_retries                 0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3957
dump                            0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2023
errors                          0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:623 
escape                          0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:4028
fill_in_dsn                     0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1445
find_best_index                 0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:984 
find_possible_keys              0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1002
find_slave_hosts                0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2537
finish                          0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3925
generate_asc_stmt               0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1747
generate_cmp_where              0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1810
generate_del_stmt               0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1880
generate_ins_stmt               0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1942
get                             0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:587 
get_columns                     0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2137
get_connected_slaves            0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2614
get_create_table                0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2099
get_databases                   0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2202
get_defaults                    0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:361 
get_defaults_files              0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:100 
get_engine                      0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1095
get_fks                         0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1169
get_groups                      0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:366 
get_hostname                    0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1552
get_irot                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:4046
get_keys                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1102
get_master_dsn                  0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2673
get_master_status               0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2699
get_opts                        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:388 
get_slave_lag                   0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3028
get_slave_status                0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2680
get_specs                       0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:93  
get_table_list                  0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2247
get_table_status                0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2221
get_tmp_table                   0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2157
get_triggers                    0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2168
got                             0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:595 
has                             0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:603 
has_slave_updates               0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3004
is_master_of                    0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2635
literal_like                    0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1712
main                            0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3118
make_PID_file                   0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2401
make_sibling_of_master          0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2848
make_slave_of_sibling           0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2896
make_slave_of_uncle             0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2935
new                             0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1737
new                             0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2016
new                             0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2301
new                             0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2482
new                             0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:56  
new                             0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:883 
opts                            0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:337 
parse                           0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1628
parse                           0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:894 
parse_options                   0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1384
pos_cmp                         0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3034
pos_to_string                   0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3053
print_active_handles            0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1568
print_errors                    0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:657 
print_usage                     0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:667 
prompt                          0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:628 
prompt_noecho                   0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:742 
quote                           0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1677
quote_val                       0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1685
read_para_after                 0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:811 
recurse_to_slaves               0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2486
remove_auto_increment           0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1198
remove_secondary_indexes        0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1204
repl_posn                       0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3012
save_error                      0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:618 
set                             0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:609 
set_defaults                    0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:349 
short_host                      0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:3039
short_opts                      0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:343 
slave_is_running                0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2999
sort_indexes                    0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:965 
split_unquote                   0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1701
start_slave                     0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2751
stop_slave                      0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2743
ts                              0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:4036
usage                           0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1406
usage_or_errors                 0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:644 
version_ge                      0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:1635
wait_for_master                 0 /home/daniel/dev/maatkit/mk-archiver/mk-archiver:2720


