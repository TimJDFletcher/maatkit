---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...ry-digest/mk-query-digest   49.0   36.9   32.7   62.3    n/a  100.0   44.8
Total                          49.0   36.9   32.7   62.3    n/a  100.0   44.8
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:25:15 2010
Finish:       Tue Feb  9 16:25:15 2010

Run:          ./101_slowlog_analyses.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:25:16 2010
Finish:       Tue Feb  9 16:25:22 2010

Run:          ./102_binlog_analyses.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:25:28 2010
Finish:       Tue Feb  9 16:25:28 2010

Run:          ./103_genlog_analyses.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:25:34 2010
Finish:       Tue Feb  9 16:25:35 2010

Run:          ./104_mysql_analyses.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:25:40 2010
Finish:       Tue Feb  9 16:25:41 2010

Run:          ./105_memcached_analyses.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:25:47 2010
Finish:       Tue Feb  9 16:25:49 2010

Run:          ./106_http_analyses.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:25:51 2010
Finish:       Tue Feb  9 16:25:51 2010

Run:          ./107_option_sanity.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:25:52 2010
Finish:       Tue Feb  9 16:25:53 2010

Run:          ./108_prepared_statements_analyses.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:25:54 2010
Finish:       Tue Feb  9 16:25:56 2010

Run:          ./109_continue_on_error.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:25:57 2010
Finish:       Tue Feb  9 16:25:58 2010

Run:          ./110_daemon.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:25:59 2010
Finish:       Tue Feb  9 16:26:01 2010

Run:          ./111_attrib_inheritance.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:26:02 2010
Finish:       Tue Feb  9 16:26:03 2010

Run:          ./112_since_until.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:26:05 2010
Finish:       Tue Feb  9 16:26:07 2010

Run:          ./113_group_by_order_by.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:26:08 2010
Finish:       Tue Feb  9 16:26:09 2010

Run:          ./114_sample.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:26:10 2010
Finish:       Tue Feb  9 16:26:11 2010

Run:          ./115_standard_options.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:26:12 2010
Finish:       Tue Feb  9 16:26:13 2010

Run:          ./116_run_time.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:26:15 2010
Finish:       Tue Feb  9 16:26:18 2010

Run:          ./117_collect_and_report_cycles.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:26:20 2010
Finish:       Tue Feb  9 16:26:26 2010

Run:          ./118_explain_partitions.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:26:27 2010
Finish:       Tue Feb  9 16:26:27 2010

Run:          ./119_review.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:26:29 2010
Finish:       Tue Feb  9 16:26:32 2010

Run:          ./120_explain.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:26:34 2010
Finish:       Tue Feb  9 16:26:34 2010

Run:          ./121_mirror.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:26:40 2010
Finish:       Tue Feb  9 16:26:51 2010

Run:          ./122_read_timeout.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:26:53 2010
Finish:       Tue Feb  9 16:26:58 2010

Run:          ./123_execute.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:27:01 2010
Finish:       Tue Feb  9 16:27:01 2010

Run:          ./201_issue_232.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:27:07 2010
Finish:       Tue Feb  9 16:27:08 2010

Run:          ./202_issue_687.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:27:09 2010
Finish:       Tue Feb  9 16:27:10 2010

Run:          ./203_issue_565.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:27:11 2010
Finish:       Tue Feb  9 16:27:12 2010

Run:          ./204_issue_360.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:27:13 2010
Finish:       Tue Feb  9 16:27:16 2010

Run:          ./205_issue_514.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Tue Feb  9 16:27:18 2010
Finish:       Tue Feb  9 16:27:18 2010

/home/daniel/dev/maatkit/mk-query-digest/mk-query-digest

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This program is copyright 2007-@CURRENTYEAR@ Percona Inc.
4                                                     # Feedback and improvements are welcome.
5                                                     #
6                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
7                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
8                                                     # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
9                                                     #
10                                                    # This program is free software; you can redistribute it and/or modify it under
11                                                    # the terms of the GNU General Public License as published by the Free Software
12                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
13                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
14                                                    # licenses.
15                                                    #
16                                                    # You should have received a copy of the GNU General Public License along with
17                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
18                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
19                                                    
20             6                    6            53   use strict;
               6                                 14   
               6                                 40   
21             6                    6            37   use warnings FATAL => 'all';
               6                                 14   
               6                                 45   
22                                                    
23                                                    our $VERSION = '@VERSION@';
24                                                    our $DISTRIB = '@DISTRIB@';
25                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5725 $ =~ m/(\d+)/g, 0));
26                                                    
27                                                    # ###########################################################################
28                                                    # DSNParser package 5266
29                                                    # ###########################################################################
30                                                    package DSNParser;
31                                                    
32             6                    6            39   use strict;
               6                                 14   
               6                                 28   
33             6                    6            35   use warnings FATAL => 'all';
               6                                 13   
               6                                 28   
34             6                    6            49   use English qw(-no_match_vars);
               6                                 19   
               6                                 39   
35             6                    6            40   use Data::Dumper;
               6                                 18   
               6                                 48   
36                                                    $Data::Dumper::Indent    = 0;
37                                                    $Data::Dumper::Quotekeys = 0;
38                                                    
39                                                    eval {
40                                                       require DBI;
41                                                    };
42                                                    my $have_dbi = $EVAL_ERROR ? 0 : 1;
43                                                    
44    ***      6            50      6            40   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 15   
               6                                 91   
45                                                    
46                                                    sub new {
47             8                    8            54      my ( $class, @opts ) = @_;
48             8                                216      my $self = {
49                                                          opts => {
50                                                             A => {
51                                                                desc => 'Default character set',
52                                                                dsn  => 'charset',
53                                                                copy => 1,
54                                                             },
55                                                             D => {
56                                                                desc => 'Database to use',
57                                                                dsn  => 'database',
58                                                                copy => 1,
59                                                             },
60                                                             F => {
61                                                                desc => 'Only read default options from the given file',
62                                                                dsn  => 'mysql_read_default_file',
63                                                                copy => 1,
64                                                             },
65                                                             h => {
66                                                                desc => 'Connect to host',
67                                                                dsn  => 'host',
68                                                                copy => 1,
69                                                             },
70                                                             p => {
71                                                                desc => 'Password to use when connecting',
72                                                                dsn  => 'password',
73                                                                copy => 1,
74                                                             },
75                                                             P => {
76                                                                desc => 'Port number to use for connection',
77                                                                dsn  => 'port',
78                                                                copy => 1,
79                                                             },
80                                                             S => {
81                                                                desc => 'Socket file to use for connection',
82                                                                dsn  => 'mysql_socket',
83                                                                copy => 1,
84                                                             },
85                                                             u => {
86                                                                desc => 'User for login if not current user',
87                                                                dsn  => 'user',
88                                                                copy => 1,
89                                                             },
90                                                          },
91                                                       };
92             8                                 33      foreach my $opt ( @opts ) {
93            12                                 34         MKDEBUG && _d('Adding extra property', $opt->{key});
94            12                                104         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
95                                                       }
96             8                                105      return bless $self, $class;
97                                                    }
98                                                    
99                                                    sub prop {
100           71                   71           442      my ( $self, $prop, $value ) = @_;
101           71    100                         403      if ( @_ > 2 ) {
102           45                                124         MKDEBUG && _d('Setting', $prop, 'property');
103           45                                174         $self->{$prop} = $value;
104                                                      }
105           71                                377      return $self->{$prop};
106                                                   }
107                                                   
108                                                   sub parse {
109           12                   12           326      my ( $self, $dsn, $prev, $defaults ) = @_;
110           12    100                          98      if ( !$dsn ) {
111            5                                 13         MKDEBUG && _d('No DSN to parse');
112            5                                 25         return;
113                                                      }
114            7                                130      MKDEBUG && _d('Parsing', $dsn);
115            7           100                   40      $prev     ||= {};
116   ***      7            50                   47      $defaults ||= {};
117            7                                 30      my %given_props;
118            7                                 24      my %final_props;
119            7                                 23      my %opts = %{$self->{opts}};
               7                                 90   
120                                                   
121            7                                 79      foreach my $dsn_part ( split(/,/, $dsn) ) {
122   ***     29     50                         301         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
123           29                                163            $given_props{$prop_key} = $prop_val;
124                                                         }
125                                                         else {
126   ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
127   ***      0                                  0            $given_props{h} = $dsn_part;
128                                                         }
129                                                      }
130                                                   
131            7                                 46      foreach my $key ( keys %opts ) {
132           61                                150         MKDEBUG && _d('Finding value for', $key);
133           61                                247         $final_props{$key} = $given_props{$key};
134   ***     61     50     66                  574         if (   !defined $final_props{$key}
      ***                   33                        
135                                                              && defined $prev->{$key} && $opts{$key}->{copy} )
136                                                         {
137   ***      0                                  0            $final_props{$key} = $prev->{$key};
138   ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
139                                                         }
140           61    100                         301         if ( !defined $final_props{$key} ) {
141           32                                122            $final_props{$key} = $defaults->{$key};
142           32                                108            MKDEBUG && _d('Copying value for', $key, 'from defaults');
143                                                         }
144                                                      }
145                                                   
146            7                                 45      foreach my $key ( keys %given_props ) {
147   ***     29     50                         147         die "Unrecognized DSN part '$key' in '$dsn'\n"
148                                                            unless exists $opts{$key};
149                                                      }
150   ***      7     50                          51      if ( (my $required = $self->prop('required')) ) {
151   ***      0                                  0         foreach my $key ( keys %$required ) {
152   ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
153                                                         }
154                                                      }
155                                                   
156            7                                321      return \%final_props;
157                                                   }
158                                                   
159                                                   sub parse_options {
160            5                    5            25      my ( $self, $o ) = @_;
161   ***      5     50                          36      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
162   ***      0                                  0      my $dsn_string
163                                                         = join(',',
164           45    100                         194             map  { "$_=".$o->get($_); }
165            5                                 63             grep { $o->has($_) && $o->get($_) }
166            5                                 20             keys %{$self->{opts}}
167                                                           );
168            5                                 23      MKDEBUG && _d('DSN string made from options:', $dsn_string);
169            5                                 38      return $self->parse($dsn_string);
170                                                   }
171                                                   
172                                                   sub as_string {
173   ***      0                    0             0      my ( $self, $dsn ) = @_;
174   ***      0      0                           0      return $dsn unless ref $dsn;
175   ***      0      0                           0      return join(',',
176   ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
177   ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
178                                                         sort keys %$dsn );
179                                                   }
180                                                   
181                                                   sub usage {
182   ***      0                    0             0      my ( $self ) = @_;
183   ***      0                                  0      my $usage
184                                                         = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
185                                                         . "  KEY  COPY  MEANING\n"
186                                                         . "  ===  ====  =============================================\n";
187   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
188   ***      0                                  0      foreach my $key ( sort keys %opts ) {
189   ***      0      0      0                    0         $usage .= "  $key    "
190                                                                .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
191                                                                .  ($opts{$key}->{desc} || '[No description]')
192                                                                . "\n";
193                                                      }
194   ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
195   ***      0                                  0      return $usage;
196                                                   }
197                                                   
198                                                   sub get_cxn_params {
199            7                    7            53      my ( $self, $info ) = @_;
200            7                                 20      my $dsn;
201            7                                 22      my %opts = %{$self->{opts}};
               7                                 81   
202   ***      7            50                   40      my $driver = $self->prop('dbidriver') || '';
203   ***      7     50                          38      if ( $driver eq 'Pg' ) {
204   ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
205   ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
206   ***      0             0                    0                        grep { defined $info->{$_} }
207                                                                        qw(h P));
208                                                      }
209                                                      else {
210           14                                122         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
211           35                                144            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
212            7           100                  100                        grep { defined $info->{$_} }
213                                                                        qw(F h P S A))
214                                                            . ';mysql_read_default_group=client';
215                                                      }
216            7                                 22      MKDEBUG && _d($dsn);
217            7                                 86      return ($dsn, $info->{u}, $info->{p});
218                                                   }
219                                                   
220                                                   sub fill_in_dsn {
221   ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
222   ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
223   ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
224   ***      0                                  0      $user =~ s/@.*//;
225   ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
226   ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
227   ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
228   ***      0             0                    0      $dsn->{u} ||= $user;
229   ***      0             0                    0      $dsn->{D} ||= $db;
230                                                   }
231                                                   
232                                                   sub get_dbh {
233            7                    7            54      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
234   ***      7            50                   37      $opts ||= {};
235   ***      7     50                          91      my $defaults = {
236                                                         AutoCommit         => 0,
237                                                         RaiseError         => 1,
238                                                         PrintError         => 0,
239                                                         ShowErrorStatement => 1,
240                                                         mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
241                                                      };
242            7                                 39      @{$defaults}{ keys %$opts } = values %$opts;
               7                                 33   
243                                                   
244   ***      7     50                          39      if ( !$have_dbi ) {
245   ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
246                                                            . "installed or not found.  Run 'perl -MDBI' to see the directories "
247                                                            . "that Perl searches for DBI.  If DBI is not installed, try:\n"
248                                                            . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
249                                                            . "  RHEL/CentOS    yum install perl-DBI\n"
250                                                            . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
251                                                   
252                                                      }
253                                                   
254            7                                 21      my $dbh;
255            7                                 23      my $tries = 2;
256   ***      7            66                   81      while ( !$dbh && $tries-- ) {
257                                                         MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
258            7                                 20            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
259                                                   
260            7                                 24         eval {
261            7                                103            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
262                                                   
263   ***      7     50                          82            if ( $cxn_string =~ m/mysql/i ) {
264            7                                 23               my $sql;
265                                                   
266            7                                 28               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
267                                                                    . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
268            7                                 17               MKDEBUG && _d($dbh, ':', $sql);
269            7                                828               $dbh->do($sql);
270                                                   
271   ***      7     50                          65               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
272   ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
273   ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
274   ***      0                                  0                  $dbh->do($sql);
275   ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
276   ***      0      0                           0                  if ( $charset eq 'utf8' ) {
277   ***      0      0                           0                     binmode(STDOUT, ':utf8')
278                                                                        or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
279                                                                  }
280                                                                  else {
281   ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
282                                                                  }
283                                                               }
284                                                   
285            7    100                          44               if ( $self->prop('set-vars') ) {
286            5                                 31                  $sql = "SET " . $self->prop('set-vars');
287            5                                 12                  MKDEBUG && _d($dbh, ':', $sql);
288            5                                457                  $dbh->do($sql);
289                                                               }
290                                                            }
291                                                         };
292   ***      7     50     33                   78         if ( !$dbh && $EVAL_ERROR ) {
293   ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
294   ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
295   ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
296   ***      0                                  0               delete $defaults->{mysql_enable_utf8};
297                                                            }
298                                                            elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
299   ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
300                                                                  . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
301                                                                  . "the directories that Perl searches for DBD::mysql.  If "
302                                                                  . "DBD::mysql is not installed, try:\n"
303                                                                  . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
304                                                                  . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
305                                                                  . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
306                                                            }
307   ***      0      0                           0            if ( !$tries ) {
308   ***      0                                  0               die $EVAL_ERROR;
309                                                            }
310                                                         }
311                                                      }
312                                                   
313            7                                 17      MKDEBUG && _d('DBH info: ',
314                                                         $dbh,
315                                                         Dumper($dbh->selectrow_hashref(
316                                                            'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
317                                                         'Connection info:',      $dbh->{mysql_hostinfo},
318                                                         'Character set info:',   Dumper($dbh->selectall_arrayref(
319                                                                        'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
320                                                         '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
321                                                         '$DBI::VERSION:',        $DBI::VERSION,
322                                                      );
323                                                   
324            7                                 41      return $dbh;
325                                                   }
326                                                   
327                                                   sub get_hostname {
328   ***      0                    0             0      my ( $self, $dbh ) = @_;
329   ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
330   ***      0                                  0         return $host;
331                                                      }
332   ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
333                                                         'SELECT /*!50038 @@hostname, */ 1');
334   ***      0                                  0      return $hostname;
335                                                   }
336                                                   
337                                                   sub disconnect {
338            5                    5            24      my ( $self, $dbh ) = @_;
339            5                                 12      MKDEBUG && $self->print_active_handles($dbh);
340            5                                578      $dbh->disconnect;
341                                                   }
342                                                   
343                                                   sub print_active_handles {
344   ***      0                    0             0      my ( $self, $thing, $level ) = @_;
345   ***      0             0                    0      $level ||= 0;
346   ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
347                                                         $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
348                                                         or die "Cannot print: $OS_ERROR";
349   ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
350   ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
351                                                      }
352                                                   }
353                                                   
354                                                   sub copy {
355   ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
356   ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
357   ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
358   ***      0                                  0      my %new_dsn = map {
359   ***      0                                  0         my $key = $_;
360   ***      0                                  0         my $val;
361   ***      0      0                           0         if ( $args{overwrite} ) {
362   ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
363                                                         }
364                                                         else {
365   ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
366                                                         }
367   ***      0                                  0         $key => $val;
368   ***      0                                  0      } keys %{$self->{opts}};
369   ***      0                                  0      return \%new_dsn;
370                                                   }
371                                                   
372                                                   sub _d {
373   ***      0                    0             0      my ($package, undef, $line) = caller 0;
374   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
375   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
376                                                           @_;
377   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
378                                                   }
379                                                   
380                                                   1;
381                                                   
382                                                   # ###########################################################################
383                                                   # End DSNParser package
384                                                   # ###########################################################################
385                                                   
386                                                   # ###########################################################################
387                                                   # Quoter package 5266
388                                                   # ###########################################################################
389            6                    6            55   use strict;
               6                                 16   
               6                                 40   
390            6                    6            44   use warnings FATAL => 'all';
               6                                 14   
               6                                 38   
391                                                   
392                                                   package Quoter;
393                                                   
394            6                    6            39   use English qw(-no_match_vars);
               6                                 13   
               6                                 39   
395                                                   
396   ***      6            50      6            39   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 17   
               6                                 96   
397                                                   
398                                                   sub new {
399            6                    6            26      my ( $class ) = @_;
400            6                                 59      bless {}, $class;
401                                                   }
402                                                   
403                                                   sub quote {
404           61                   61           341      my ( $self, @vals ) = @_;
405           61                                282      foreach my $val ( @vals ) {
406          109                                454         $val =~ s/`/``/g;
407                                                      }
408           61                                269      return join('.', map { '`' . $_ . '`' } @vals);
             109                               1236   
409                                                   }
410                                                   
411                                                   sub quote_val {
412   ***      0                    0             0      my ( $self, $val, $is_numeric ) = @_;
413                                                   
414   ***      0      0                           0      return 'NULL' unless defined $val;  # undef = NULL
415   ***      0      0                           0      return "''" if $val eq '';          # blank string = ''
416                                                   
417   ***      0      0                           0      if ( !defined $is_numeric ) {
418   ***      0      0                           0         $is_numeric = $val =~ m/^0|\D/ ? 0 : 1;
419                                                      }
420                                                   
421   ***      0      0                           0      return $val if $is_numeric;
422                                                   
423   ***      0                                  0      $val =~ s/(['\\])/\\$1/g;
424   ***      0                                  0      return "'$val'";
425                                                   }
426                                                   
427                                                   sub split_unquote {
428           79                   79           440      my ( $self, $db_tbl, $default_db ) = @_;
429           79                                340      $db_tbl =~ s/`//g;
430           79                                404      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
431           79    100                         341      if ( !$tbl ) {
432           40                                114         $tbl = $db;
433           40                                128         $db  = $default_db;
434                                                      }
435           79                                383      return ($db, $tbl);
436                                                   }
437                                                   
438                                                   sub literal_like {
439   ***      0                    0             0      my ( $self, $like ) = @_;
440   ***      0      0                           0      return unless $like;
441   ***      0                                  0      $like =~ s/([%_])/\\$1/g;
442   ***      0                                  0      return "'$like'";
443                                                   }
444                                                   
445                                                   1;
446                                                   
447                                                   # ###########################################################################
448                                                   # End Quoter package
449                                                   # ###########################################################################
450                                                   
451                                                   # ###########################################################################
452                                                   # OptionParser package 5568
453                                                   # ###########################################################################
454                                                   package OptionParser;
455                                                   
456            6                    6            46   use strict;
               6                                 16   
               6                                 29   
457            6                    6            37   use warnings FATAL => 'all';
               6                                 17   
               6                                 28   
458                                                   
459            6                    6            82   use Getopt::Long;
               6                                 20   
               6                                 40   
460            6                    6            43   use List::Util qw(max);
               6                                 16   
               6                                 67   
461            6                    6            38   use English qw(-no_match_vars);
               6                                 17   
               6                                 41   
462                                                   
463   ***      6            50      6            39   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 13   
               6                                 88   
464                                                   
465                                                   my $POD_link_re = '[LC]<"?([^">]+)"?>';
466                                                   
467                                                   my %attributes = (
468                                                      'type'       => 1,
469                                                      'short form' => 1,
470                                                      'group'      => 1,
471                                                      'default'    => 1,
472                                                      'cumulative' => 1,
473                                                      'negatable'  => 1,
474                                                   );
475                                                   
476                                                   sub new {
477           45                   45          1288      my ( $class, %args ) = @_;
478           45                                475      foreach my $arg ( qw(description) ) {
479   ***     45     50                         783         die "I need a $arg argument" unless $args{$arg};
480                                                      }
481           45                               1292      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
482   ***     45            50                  267      $program_name ||= $PROGRAM_NAME;
483   ***     45            33                  712      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                   33                        
      ***                   50                        
484                                                   
485   ***     45     50     50                 4513      my $self = {
      ***                   50                        
486                                                         description    => $args{description},
487                                                         prompt         => $args{prompt} || '<options>',
488                                                         strict         => (exists $args{strict} ? $args{strict} : 1),
489                                                         dp             => $args{dp}     || undef,
490                                                         program_name   => $program_name,
491                                                         opts           => {},
492                                                         got_opts       => 0,
493                                                         short_opts     => {},
494                                                         defaults       => {},
495                                                         groups         => {},
496                                                         allowed_groups => {},
497                                                         errors         => [],
498                                                         rules          => [],  # desc of rules for --help
499                                                         mutex          => [],  # rule: opts are mutually exclusive
500                                                         atleast1       => [],  # rule: at least one opt is required
501                                                         disables       => {},  # rule: opt disables other opts 
502                                                         defaults_to    => {},  # rule: opt defaults to value of other opt
503                                                         default_files  => [
504                                                            "/etc/maatkit/maatkit.conf",
505                                                            "/etc/maatkit/$program_name.conf",
506                                                            "$home/.maatkit.conf",
507                                                            "$home/.$program_name.conf",
508                                                         ],
509                                                      };
510           45                                625      return bless $self, $class;
511                                                   }
512                                                   
513                                                   sub get_specs {
514           45                   45           230      my ( $self, $file ) = @_;
515           45                                564      my @specs = $self->_pod_to_specs($file);
516           45                               2187      $self->_parse_specs(@specs);
517           45                                427      return;
518                                                   }
519                                                   
520                                                   sub get_defaults_files {
521           45                   45           209      my ( $self ) = @_;
522           45                                186      return @{$self->{default_files}};
              45                                575   
523                                                   }
524                                                   
525                                                   sub _pod_to_specs {
526           45                   45           231      my ( $self, $file ) = @_;
527   ***     45            50                  441      $file ||= __FILE__;
528   ***     45     50                        1815      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
529                                                   
530           45                               1386      my %types = (
531                                                         string => 's', # standard Getopt type
532                                                         'int'  => 'i', # standard Getopt type
533                                                         float  => 'f', # standard Getopt type
534                                                         Hash   => 'H', # hash, formed from a comma-separated list
535                                                         hash   => 'h', # hash as above, but only if a value is given
536                                                         Array  => 'A', # array, similar to Hash
537                                                         array  => 'a', # array, similar to hash
538                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
539                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
540                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
541                                                      );
542           45                                309      my @specs = ();
543           45                                171      my @rules = ();
544           45                                188      my $para;
545                                                   
546           45                                316      local $INPUT_RECORD_SEPARATOR = '';
547           45                               1681      while ( $para = <$fh> ) {
548        54450    100                      363555         next unless $para =~ m/^=head1 OPTIONS/;
549           45                                198         last;
550                                                      }
551                                                   
552           45                                333      while ( $para = <$fh> ) {
553           90    100                         536         last if $para =~ m/^=over/;
554           45                                319         chomp $para;
555           45                                583         $para =~ s/\s+/ /g;
556           45                               1737         $para =~ s/$POD_link_re/$1/go;
557           45                                142         MKDEBUG && _d('Option rule:', $para);
558           45                                497         push @rules, $para;
559                                                      }
560                                                   
561   ***     45     50                         213      die 'POD has no OPTIONS section' unless $para;
562                                                   
563           45                                159      do {
564         2880    100                       19178         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
565         2835                               8159            chomp $para;
566         2835                               6056            MKDEBUG && _d($para);
567         2835                               6889            my %attribs;
568                                                   
569         2835                              10584            $para = <$fh>; # read next paragraph, possibly attributes
570                                                   
571         2835    100                       11055            if ( $para =~ m/: / ) { # attributes
572         2160                              10010               $para =~ s/\s+\Z//g;
573         3195                              18593               %attribs = map {
574         2160                              10169                     my ( $attrib, $val) = split(/: /, $_);
575   ***   3195     50                       14582                     die "Unrecognized attribute for --$option: $attrib"
576                                                                        unless $attributes{$attrib};
577         3195                              19245                     ($attrib, $val);
578                                                                  } split(/; /, $para);
579         2160    100                       10307               if ( $attribs{'short form'} ) {
580          315                               1613                  $attribs{'short form'} =~ s/-//;
581                                                               }
582         2160                              10314               $para = <$fh>; # read next paragraph, probably short help desc
583                                                            }
584                                                            else {
585          675                               1670               MKDEBUG && _d('Option has no attributes');
586                                                            }
587                                                   
588         2835                              19807            $para =~ s/\s+\Z//g;
589         2835                              21098            $para =~ s/\s+/ /g;
590         2835                              14375            $para =~ s/$POD_link_re/$1/go;
591                                                   
592         2835                              11340            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
593         2835                               6834            MKDEBUG && _d('Short help:', $para);
594                                                   
595   ***   2835     50                       11300            die "No description after option spec $option" if $para =~ m/^=item/;
596                                                   
597         2835    100                       13707            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
598          180                                540               $option = $base_option;
599          180                                790               $attribs{'negatable'} = 1;
600                                                            }
601                                                   
602         2835    100                       51568            push @specs, {
                    100                               
      ***            50                               
                    100                               
                    100                               
      ***            50                               
603                                                               spec  => $option
604                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
605                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
606                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
607                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
608                                                               desc  => $para
609                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
610                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
611                                                            };
612                                                         }
613         2880                              19454         while ( $para = <$fh> ) {
614   ***  10530     50                       35618            last unless $para;
615                                                   
616                                                   
617        10530    100                       38489            if ( $para =~ m/^=head1/ ) {
618           45                                160               $para = undef; # Can't 'last' out of a do {} block.
619           45                                264               last;
620                                                            }
621        10485    100                       66169            last if $para =~ m/^=item --/;
622                                                         }
623                                                      } while ( $para );
624                                                   
625   ***     45     50                         226      die 'No valid specs in POD OPTIONS' unless @specs;
626                                                   
627           45                                688      close $fh;
628           45                                192      return @specs, @rules;
629                                                   }
630                                                   
631                                                   sub _parse_specs {
632           45                   45           628      my ( $self, @specs ) = @_;
633           45                                262      my %disables; # special rule that requires deferred checking
634                                                   
635           45                                295      foreach my $opt ( @specs ) {
636         2880    100                       10611         if ( ref $opt ) { # It's an option spec, not a rule.
637                                                            MKDEBUG && _d('Parsing opt spec:',
638         2835                               6113               map { ($_, '=>', $opt->{$_}) } keys %$opt);
639                                                   
640         2835                              21545            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
641   ***   2835     50                       12110            if ( !$long ) {
642   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
643                                                            }
644         2835                              10380            $opt->{long} = $long;
645                                                   
646   ***   2835     50                       13122            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
647         2835                              13451            $self->{opts}->{$long} = $opt;
648                                                   
649   ***   2835     50                       12983            if ( length $long == 1 ) {
650   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
651   ***      0                                  0               $self->{short_opts}->{$long} = $long;
652                                                            }
653                                                   
654         2835    100                        9218            if ( $short ) {
655   ***    315     50                        1478               die "Duplicate short option -$short"
656                                                                  if exists $self->{short_opts}->{$short};
657          315                               1511               $self->{short_opts}->{$short} = $long;
658          315                               1146               $opt->{short} = $short;
659                                                            }
660                                                            else {
661         2520                               8996               $opt->{short} = undef;
662                                                            }
663                                                   
664         2835    100                       15149            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
665   ***   2835     50                       14493            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
666   ***   2835     50                       17018            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
667                                                   
668   ***   2835            50                11785            $opt->{group} ||= 'default';
669         2835                              14951            $self->{groups}->{ $opt->{group} }->{$long} = 1;
670                                                   
671         2835                               9894            $opt->{value} = undef;
672         2835                               9961            $opt->{got}   = 0;
673                                                   
674         2835                              15865            my ( $type ) = $opt->{spec} =~ m/=(.)/;
675         2835                              10703            $opt->{type} = $type;
676         2835                               6457            MKDEBUG && _d($long, 'type:', $type);
677                                                   
678   ***   2835     50    100                26509            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                   66                        
679   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
680                                                                  . "was given when this OptionParser object was created";
681                                                            }
682                                                   
683         2835    100    100                23021            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
684                                                   
685         2835    100                       19144            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
686   ***    900     50                        5419               $self->{defaults}->{$long} = defined $def ? $def : 1;
687          900                               2210               MKDEBUG && _d($long, 'default:', $def);
688                                                            }
689                                                   
690         2835    100                       11169            if ( $long eq 'config' ) {
691           45                                309               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
692                                                            }
693                                                   
694   ***   2835     50                       14165            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
695   ***      0                                  0               $disables{$long} = $dis;
696   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
697                                                            }
698                                                   
699         2835                              14292            $self->{opts}->{$long} = $opt;
700                                                         }
701                                                         else { # It's an option rule, not a spec.
702           45                                124            MKDEBUG && _d('Parsing rule:', $opt); 
703           45                                128            push @{$self->{rules}}, $opt;
              45                                343   
704           45                                377            my @participants = $self->_get_participants($opt);
705           45                                172            my $rule_ok = 0;
706                                                   
707   ***     45     50                         453            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
708   ***      0                                  0               $rule_ok = 1;
709   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
710   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
711                                                            }
712   ***     45     50                         387            if ( $opt =~ m/at least one|one and only one/ ) {
713   ***      0                                  0               $rule_ok = 1;
714   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
715   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
716                                                            }
717   ***     45     50                         335            if ( $opt =~ m/default to/ ) {
718           45                                147               $rule_ok = 1;
719           45                                285               $self->{defaults_to}->{$participants[0]} = $participants[1];
720           45                                127               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
721                                                            }
722   ***     45     50                         293            if ( $opt =~ m/restricted to option groups/ ) {
723   ***      0                                  0               $rule_ok = 1;
724   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
725   ***      0                                  0               my @groups = split(',', $groups);
726   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
727   ***      0                                  0                  s/\s+//;
728   ***      0                                  0                  $_ => 1;
729                                                               } @groups;
730                                                            }
731                                                   
732   ***     45     50                         287            die "Unrecognized option rule: $opt" unless $rule_ok;
733                                                         }
734                                                      }
735                                                   
736           45                                350      foreach my $long ( keys %disables ) {
737   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
738   ***      0                                  0         $self->{disables}->{$long} = \@participants;
739   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
740                                                      }
741                                                   
742           45                                412      return; 
743                                                   }
744                                                   
745                                                   sub _get_participants {
746           45                   45           305      my ( $self, $str ) = @_;
747           45                                159      my @participants;
748           45                                544      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
749   ***     90     50                         488         die "Option --$long does not exist while processing rule $str"
750                                                            unless exists $self->{opts}->{$long};
751           90                                430         push @participants, $long;
752                                                      }
753           45                                137      MKDEBUG && _d('Participants for', $str, ':', @participants);
754           45                                309      return @participants;
755                                                   }
756                                                   
757                                                   sub opts {
758   ***      0                    0             0      my ( $self ) = @_;
759   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
760   ***      0                                  0      return %opts;
761                                                   }
762                                                   
763                                                   sub short_opts {
764   ***      0                    0             0      my ( $self ) = @_;
765   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
766   ***      0                                  0      return %short_opts;
767                                                   }
768                                                   
769                                                   sub set_defaults {
770   ***      0                    0             0      my ( $self, %defaults ) = @_;
771   ***      0                                  0      $self->{defaults} = {};
772   ***      0                                  0      foreach my $long ( keys %defaults ) {
773   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
774                                                            unless exists $self->{opts}->{$long};
775   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
776   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
777                                                      }
778   ***      0                                  0      return;
779                                                   }
780                                                   
781                                                   sub get_defaults {
782           46                   46           215      my ( $self ) = @_;
783           46                                274      return $self->{defaults};
784                                                   }
785                                                   
786                                                   sub get_groups {
787   ***      0                    0             0      my ( $self ) = @_;
788   ***      0                                  0      return $self->{groups};
789                                                   }
790                                                   
791                                                   sub _set_option {
792          133                  133           640      my ( $self, $opt, $val ) = @_;
793   ***    133      0                         308      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
794                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
795                                                               : die "Getopt::Long gave a nonexistent option: $opt";
796                                                   
797          133                                267      $opt = $self->{opts}->{$long};
798   ***    133     50                         872      if ( $opt->{is_cumulative} ) {
799   ***      0                                  0         $opt->{value}++;
800                                                      }
801                                                      else {
802          133                                520         $opt->{value} = $val;
803                                                      }
804          133                                468      $opt->{got} = 1;
805          133                                512      MKDEBUG && _d('Got option', $long, '=', $val);
806                                                   }
807                                                   
808                                                   sub get_opts {
809           45                   45           220      my ( $self ) = @_; 
810                                                   
811           45                                148      foreach my $long ( keys %{$self->{opts}} ) {
              45                                923   
812         2835                              11460         $self->{opts}->{$long}->{got} = 0;
813   ***   2835     50                       22838         $self->{opts}->{$long}->{value}
                    100                               
814                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
815                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
816                                                            : undef;
817                                                      }
818           45                                367      $self->{got_opts} = 0;
819                                                   
820           45                                242      $self->{errors} = [];
821                                                   
822   ***     45     50     33                  660      if ( @ARGV && $ARGV[0] eq "--config" ) {
823   ***      0                                  0         shift @ARGV;
824   ***      0                                  0         $self->_set_option('config', shift @ARGV);
825                                                      }
826   ***     45     50                         435      if ( $self->has('config') ) {
827           45                                142         my @extra_args;
828           45                                405         foreach my $filename ( split(',', $self->get('config')) ) {
829          180                                500            eval {
830          180                                982               push @extra_args, $self->_read_config_file($filename);
831                                                            };
832   ***    180     50                         945            if ( $EVAL_ERROR ) {
833   ***    180     50                         861               if ( $self->got('config') ) {
834   ***      0                                  0                  die $EVAL_ERROR;
835                                                               }
836                                                               elsif ( MKDEBUG ) {
837                                                                  _d($EVAL_ERROR);
838                                                               }
839                                                            }
840                                                         }
841           45                                347         unshift @ARGV, @extra_args;
842                                                      }
843                                                   
844           45                                538      Getopt::Long::Configure('no_ignore_case', 'bundling');
845                                                      GetOptions(
846         2790                  133         21891         map    { $_->{spec} => sub { $self->_set_option(@_); } }
             133                                766   
            2835                              11359   
847           45                                404         grep   { $_->{long} ne 'config' } # --config is handled specially above.
848   ***     45     50                         173         values %{$self->{opts}}
849                                                      ) or $self->save_error('Error parsing options');
850                                                   
851   ***     45     50     33                 5453      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
852   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
853                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
854                                                               or die "Cannot print: $OS_ERROR";
855   ***      0                                  0         exit 0;
856                                                      }
857                                                   
858   ***     45     50     33                  489      if ( @ARGV && $self->{strict} ) {
859   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
860                                                      }
861                                                   
862           45                                205      foreach my $mutex ( @{$self->{mutex}} ) {
              45                                314   
863   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
864   ***      0      0                           0         if ( @set > 1 ) {
865   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
866   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
867                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
868                                                                    . ' are mutually exclusive.';
869   ***      0                                  0            $self->save_error($err);
870                                                         }
871                                                      }
872                                                   
873           45                                146      foreach my $required ( @{$self->{atleast1}} ) {
              45                                244   
874   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
875   ***      0      0                           0         if ( @set == 0 ) {
876   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
877   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
878                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
879   ***      0                                  0            $self->save_error("Specify at least one of $err");
880                                                         }
881                                                      }
882                                                   
883           45                                153      foreach my $long ( keys %{$self->{opts}} ) {
              45                                793   
884         2835                              11028         my $opt = $self->{opts}->{$long};
885         2835    100                       16139         if ( $opt->{got} ) {
      ***            50                               
886   ***    123     50                         626            if ( exists $self->{disables}->{$long} ) {
887   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
888   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
889   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
890                                                                  'because', $long,'disables them');
891                                                            }
892                                                   
893   ***    123     50                         665            if ( exists $self->{allowed_groups}->{$long} ) {
894                                                   
895   ***      0                                  0               my @restricted_groups = grep {
896   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
897   ***      0                                  0               } keys %{$self->{groups}};
898                                                   
899   ***      0                                  0               my @restricted_opts;
900   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
901   ***      0                                  0                  RESTRICTED_OPT:
902   ***      0                                  0                  foreach my $restricted_opt (
903                                                                     keys %{$self->{groups}->{$restricted_group}} )
904                                                                  {
905   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
906   ***      0      0                           0                     push @restricted_opts, $restricted_opt
907                                                                        if $self->{opts}->{$restricted_opt}->{got};
908                                                                  }
909                                                               }
910                                                   
911   ***      0      0                           0               if ( @restricted_opts ) {
912   ***      0                                  0                  my $err;
913   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
914   ***      0                                  0                     $err = "--$restricted_opts[0]";
915                                                                  }
916                                                                  else {
917   ***      0                                  0                     $err = join(', ',
918   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
919   ***      0                                  0                               grep { $_ } 
920                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
921                                                                            )
922                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
923                                                                  }
924   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
925                                                               }
926                                                            }
927                                                   
928                                                         }
929                                                         elsif ( $opt->{is_required} ) { 
930   ***      0                                  0            $self->save_error("Required option --$long must be specified");
931                                                         }
932                                                   
933         2835                              10483         $self->_validate_type($opt);
934                                                      }
935                                                   
936           45                                491      $self->{got_opts} = 1;
937           45                                156      return;
938                                                   }
939                                                   
940                                                   sub _validate_type {
941         2835                 2835          9941      my ( $self, $opt ) = @_;
942   ***   2835    100     66                24439      return unless $opt && $opt->{type};
943         1980                               6494      my $val = $opt->{value};
944                                                   
945   ***   1980     50     66                51929      if ( $val && $opt->{type} eq 'm' ) {  # type time
                    100    100                        
      ***            50     66                        
      ***           100     66                        
      ***           100     66                        
                           100                        
                           100                        
946   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
947   ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
948   ***      0      0                           0         if ( !$suffix ) {
949   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
950   ***      0             0                    0            $suffix = $s || 's';
951   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
952                                                               $opt->{long}, '(value:', $val, ')');
953                                                         }
954   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
955   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
956                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
957                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
958                                                                 :                  $num * 86400;   # Days
959   ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
960   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
961                                                         }
962                                                         else {
963   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
964                                                         }
965                                                      }
966                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
967            5                                 20         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
968            5                                 23         my $prev = {};
969            5                                 32         my $from_key = $self->{defaults_to}->{ $opt->{long} };
970   ***      5     50                          26         if ( $from_key ) {
971   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
972   ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
973                                                         }
974            5                                 65         my $defaults = $self->{dp}->parse_options($self);
975            5                                 30         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
976                                                      }
977                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
978   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
979   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
980   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
981   ***      0      0                           0         if ( defined $num ) {
982   ***      0      0                           0            if ( $factor ) {
983   ***      0                                  0               $num *= $factor_for{$factor};
984   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
985                                                                  'to num', $num, '* factor', $factor);
986                                                            }
987   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
988                                                         }
989                                                         else {
990   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
991                                                         }
992                                                      }
993                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
994   ***     45            50                  418         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
              58                                404   
995                                                      }
996                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
997          496           100                 4714         $opt->{value} = [ split(/(?<!\\),\s*/, ($val || '')) ];
998                                                      }
999                                                      else {
1000        1434                               3395         MKDEBUG && _d('Nothing to validate for option',
1001                                                           $opt->{long}, 'type', $opt->{type}, 'value', $val);
1002                                                     }
1003                                                  
1004        1980                               6917      return;
1005                                                  }
1006                                                  
1007                                                  sub get {
1008        3615                 3615         14448      my ( $self, $opt ) = @_;
1009        3615    100                       15473      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1010  ***   3615     50     33                33018      die "Option $opt does not exist"
1011                                                        unless $long && exists $self->{opts}->{$long};
1012        3615                              33987      return $self->{opts}->{$long}->{value};
1013                                                  }
1014                                                  
1015                                                  sub got {
1016         226                  226          1092      my ( $self, $opt ) = @_;
1017  ***    226     50                        1037      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1018  ***    226     50     33                 2219      die "Option $opt does not exist"
1019                                                        unless $long && exists $self->{opts}->{$long};
1020         226                               1529      return $self->{opts}->{$long}->{got};
1021                                                  }
1022                                                  
1023                                                  sub has {
1024          90                   90           436      my ( $self, $opt ) = @_;
1025          90    100                         548      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1026          90    100                         821      return defined $long ? exists $self->{opts}->{$long} : 0;
1027                                                  }
1028                                                  
1029                                                  sub set {
1030          45                   45           230      my ( $self, $opt, $val ) = @_;
1031  ***     45     50                         262      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1032  ***     45     50     33                  724      die "Option $opt does not exist"
1033                                                        unless $long && exists $self->{opts}->{$long};
1034          45                                238      $self->{opts}->{$long}->{value} = $val;
1035          45                                184      return;
1036                                                  }
1037                                                  
1038                                                  sub save_error {
1039  ***      0                    0             0      my ( $self, $error ) = @_;
1040  ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
1041                                                  }
1042                                                  
1043                                                  sub errors {
1044  ***      0                    0             0      my ( $self ) = @_;
1045  ***      0                                  0      return $self->{errors};
1046                                                  }
1047                                                  
1048                                                  sub prompt {
1049  ***      0                    0             0      my ( $self ) = @_;
1050  ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
1051                                                  }
1052                                                  
1053                                                  sub descr {
1054  ***      0                    0             0      my ( $self ) = @_;
1055  ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
1056                                                                . "  For more details, please use the --help option, "
1057                                                                . "or try 'perldoc $PROGRAM_NAME' "
1058                                                                . "for complete documentation.";
1059  ***      0      0                           0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g)
1060                                                        unless $ENV{DONT_BREAK_LINES};
1061  ***      0                                  0      $descr =~ s/ +$//mg;
1062  ***      0                                  0      return $descr;
1063                                                  }
1064                                                  
1065                                                  sub usage_or_errors {
1066          45                   45           208      my ( $self ) = @_;
1067  ***     45     50                         295      if ( $self->{opts}->{help}->{got} ) {
      ***     45     50                         271   
1068  ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
1069  ***      0                                  0         exit 0;
1070                                                     }
1071                                                     elsif ( scalar @{$self->{errors}} ) {
1072  ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
1073  ***      0                                  0         exit 0;
1074                                                     }
1075          45                                156      return;
1076                                                  }
1077                                                  
1078                                                  sub print_errors {
1079  ***      0                    0             0      my ( $self ) = @_;
1080  ***      0                                  0      my $usage = $self->prompt() . "\n";
1081  ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
1082  ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
1083                                                                . "\n";
1084                                                     }
1085  ***      0                                  0      return $usage . "\n" . $self->descr();
1086                                                  }
1087                                                  
1088                                                  sub print_usage {
1089  ***      0                    0             0      my ( $self ) = @_;
1090  ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
1091  ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
1092                                                  
1093  ***      0      0                           0      my $maxl = max(
1094  ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
1095                                                        @opts);
1096                                                  
1097  ***      0      0                           0      my $maxs = max(0,
1098  ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
1099  ***      0                                  0         values %{$self->{short_opts}});
1100                                                  
1101  ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
1102  ***      0                                  0      my $rcol = 80 - $lcol - 6;
1103  ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
1104                                                  
1105  ***      0                                  0      $maxs = max($lcol - 3, $maxs);
1106                                                  
1107  ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
1108                                                  
1109  ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
1110  ***      0                                  0      push @groups, 'default';
1111                                                  
1112  ***      0                                  0      foreach my $group ( reverse @groups ) {
1113  ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
1114  ***      0                                  0         foreach my $opt (
      ***      0                                  0   
1115  ***      0                                  0            sort { $a->{long} cmp $b->{long} }
1116                                                           grep { $_->{group} eq $group }
1117                                                           @opts )
1118                                                        {
1119  ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
1120  ***      0                                  0            my $short = $opt->{short};
1121  ***      0                                  0            my $desc  = $opt->{desc};
1122  ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
1123  ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
1124  ***      0             0                    0               $s    ||= 's';
1125  ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
1126  ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
1127                                                                     . "d=days; if no suffix, $s is used.";
1128                                                           }
1129  ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
1130  ***      0                                  0            $desc =~ s/ +$//mg;
1131  ***      0      0                           0            if ( $short ) {
1132  ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
1133                                                           }
1134                                                           else {
1135  ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
1136                                                           }
1137                                                        }
1138                                                     }
1139                                                  
1140  ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
1141  ***      0                                  0         $usage .= "\nRules:\n\n";
1142  ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
1143                                                     }
1144  ***      0      0                           0      if ( $self->{dp} ) {
1145  ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
1146                                                     }
1147  ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
1148  ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
1149  ***      0                                  0         my $val   = $opt->{value};
1150  ***      0             0                    0         my $type  = $opt->{type} || '';
1151  ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
1152  ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
1153                                                                  : !defined $val             ? '(No value)'
1154                                                                  : $type eq 'd'              ? $self->{dp}->as_string($val)
1155                                                                  : $type =~ m/H|h/           ? join(',', sort keys %$val)
1156                                                                  : $type =~ m/A|a/           ? join(',', @$val)
1157                                                                  :                             $val;
1158  ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
1159                                                     }
1160  ***      0                                  0      return $usage;
1161                                                  }
1162                                                  
1163                                                  sub prompt_noecho {
1164  ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
1165  ***      0                                  0      my ( $prompt ) = @_;
1166  ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
1167  ***      0      0                           0      print $prompt
1168                                                        or die "Cannot print: $OS_ERROR";
1169  ***      0                                  0      my $response;
1170  ***      0                                  0      eval {
1171  ***      0                                  0         require Term::ReadKey;
1172  ***      0                                  0         Term::ReadKey::ReadMode('noecho');
1173  ***      0                                  0         chomp($response = <STDIN>);
1174  ***      0                                  0         Term::ReadKey::ReadMode('normal');
1175  ***      0      0                           0         print "\n"
1176                                                           or die "Cannot print: $OS_ERROR";
1177                                                     };
1178  ***      0      0                           0      if ( $EVAL_ERROR ) {
1179  ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
1180                                                     }
1181  ***      0                                  0      return $response;
1182                                                  }
1183                                                  
1184                                                  if ( MKDEBUG ) {
1185                                                     print '# ', $^X, ' ', $], "\n";
1186                                                     my $uname = `uname -a`;
1187                                                     if ( $uname ) {
1188                                                        $uname =~ s/\s+/ /g;
1189                                                        print "# $uname\n";
1190                                                     }
1191                                                     printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
1192                                                        $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
1193                                                        ($main::SVN_REV || ''), __LINE__);
1194                                                     print('# Arguments: ',
1195                                                        join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
1196                                                  }
1197                                                  
1198                                                  sub _read_config_file {
1199         180                  180           851      my ( $self, $filename ) = @_;
1200  ***    180     50                         493      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
1201  ***      0                                  0      my @args;
1202  ***      0                                  0      my $prefix = '--';
1203  ***      0                                  0      my $parse  = 1;
1204                                                  
1205                                                     LINE:
1206  ***      0                                  0      while ( my $line = <$fh> ) {
1207  ***      0                                  0         chomp $line;
1208  ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
1209  ***      0                                  0         $line =~ s/\s+#.*$//g;
1210  ***      0                                  0         $line =~ s/^\s+|\s+$//g;
1211  ***      0      0                           0         if ( $line eq '--' ) {
1212  ***      0                                  0            $prefix = '';
1213  ***      0                                  0            $parse  = 0;
1214  ***      0                                  0            next LINE;
1215                                                        }
1216  ***      0      0      0                    0         if ( $parse
      ***             0                               
1217                                                           && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
1218                                                        ) {
1219  ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
1220                                                        }
1221                                                        elsif ( $line =~ m/./ ) {
1222  ***      0                                  0            push @args, $line;
1223                                                        }
1224                                                        else {
1225  ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
1226                                                        }
1227                                                     }
1228  ***      0                                  0      close $fh;
1229  ***      0                                  0      return @args;
1230                                                  }
1231                                                  
1232                                                  sub read_para_after {
1233  ***      0                    0             0      my ( $self, $file, $regex ) = @_;
1234  ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
1235  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
1236  ***      0                                  0      my $para;
1237  ***      0                                  0      while ( $para = <$fh> ) {
1238  ***      0      0                           0         next unless $para =~ m/^=pod$/m;
1239  ***      0                                  0         last;
1240                                                     }
1241  ***      0                                  0      while ( $para = <$fh> ) {
1242  ***      0      0                           0         next unless $para =~ m/$regex/;
1243  ***      0                                  0         last;
1244                                                     }
1245  ***      0                                  0      $para = <$fh>;
1246  ***      0                                  0      chomp($para);
1247  ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
1248  ***      0                                  0      return $para;
1249                                                  }
1250                                                  
1251                                                  sub clone {
1252  ***      0                    0             0      my ( $self ) = @_;
1253                                                  
1254  ***      0                                  0      my %clone = map {
1255  ***      0                                  0         my $hashref  = $self->{$_};
1256  ***      0                                  0         my $val_copy = {};
1257  ***      0                                  0         foreach my $key ( keys %$hashref ) {
1258  ***      0                                  0            my $ref = ref $hashref->{$key};
1259  ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
1260  ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
1261  ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
1262                                                                             : $hashref->{$key};
1263                                                        }
1264  ***      0                                  0         $_ => $val_copy;
1265                                                     } qw(opts short_opts defaults);
1266                                                  
1267  ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
1268  ***      0                                  0         $clone{$scalar} = $self->{$scalar};
1269                                                     }
1270                                                  
1271  ***      0                                  0      return bless \%clone;     
1272                                                  }
1273                                                  
1274                                                  sub _d {
1275  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1276  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1277  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1278                                                          @_;
1279  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1280                                                  }
1281                                                  
1282                                                  1;
1283                                                  
1284                                                  # ###########################################################################
1285                                                  # End OptionParser package
1286                                                  # ###########################################################################
1287                                                  
1288                                                  # ###########################################################################
1289                                                  # Transformers package 5266
1290                                                  # ###########################################################################
1291                                                  
1292                                                  package Transformers;
1293                                                  
1294           6                    6            64   use strict;
               6                                 24   
               6                                 50   
1295           6                    6            38   use warnings FATAL => 'all';
               6                                 20   
               6                                 43   
1296           6                    6            36   use English qw(-no_match_vars);
               6                                 14   
               6                                 42   
1297           6                    6            86   use Time::Local qw(timegm timelocal);
               6                                 17   
               6                                 64   
1298           6                    6            38   use Digest::MD5 qw(md5_hex);
               6                                 30   
               6                                 43   
1299                                                  
1300  ***      6            50      6            36   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 13   
               6                                 75   
1301                                                  
1302                                                  require Exporter;
1303                                                  our @ISA         = qw(Exporter);
1304                                                  our %EXPORT_TAGS = ();
1305                                                  our @EXPORT      = ();
1306                                                  our @EXPORT_OK   = qw(
1307                                                     micro_t
1308                                                     percentage_of
1309                                                     secs_to_time
1310                                                     shorten
1311                                                     ts
1312                                                     parse_timestamp
1313                                                     unix_timestamp
1314                                                     any_unix_timestamp
1315                                                     make_checksum
1316                                                  );
1317                                                  
1318                                                  our $mysql_ts  = qr/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?/;
1319                                                  our $proper_ts = qr/(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(\.\d+)?/;
1320                                                  our $n_ts      = qr/(\d{1,5})([shmd]?)/; # Limit \d{1,5} because \d{6} looks
1321                                                  
1322                                                  sub micro_t {
1323        1169                 1169          4499      my ( $t, %args ) = @_;
1324  ***   1169     50                        4855      my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
1325  ***   1169     50                        4303      my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
1326        1169                               2677      my $f;
1327                                                  
1328        1169    100                        4432      $t = 0 if $t < 0;
1329                                                  
1330        1169    100                        6193      $t = sprintf('%.17f', $t) if $t =~ /e/;
1331                                                  
1332        1169                               6751      $t =~ s/\.(\d{1,6})\d*/\.$1/;
1333                                                  
1334        1169    100    100                11704      if ($t > 0 && $t <= 0.000999) {
                    100    100                        
                    100                               
1335         333                               1841         $f = ($t * 1000000) . 'us';
1336                                                     }
1337                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
1338         191                                921         $f = sprintf("%.${p_ms}f", $t * 1000);
1339         191                                662         $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
1340                                                     }
1341                                                     elsif ($t >= 1) {
1342         181                                753         $f = sprintf("%.${p_s}f", $t);
1343         181                                658         $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
1344                                                     }
1345                                                     else {
1346         464                               1300         $f = 0;  # $t should = 0 at this point
1347                                                     }
1348                                                  
1349        1169                               5941      return $f;
1350                                                  }
1351                                                  
1352                                                  sub percentage_of {
1353         633                  633          2524      my ( $is, $of, %args ) = @_;
1354  ***    633            50                 4507      my $p   = $args{p} || 0; # float precision
1355  ***    633     50                        2171      my $fmt = $p ? "%.${p}f" : "%d";
1356         633           100                 6154      return sprintf $fmt, ($is * 100) / ($of ||= 1);
1357                                                  }
1358                                                  
1359                                                  sub secs_to_time {
1360  ***      0                    0             0      my ( $secs, $fmt ) = @_;
1361  ***      0             0                    0      $secs ||= 0;
1362  ***      0      0                           0      return '00:00' unless $secs;
1363                                                  
1364  ***      0      0      0                    0      $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
1365                                                            : $secs >= 3_600  ? 'h'
1366                                                            :                   'm';
1367                                                  
1368                                                     return
1369  ***      0      0                           0         $fmt eq 'd' ? sprintf(
      ***             0                               
1370                                                           "%d+%02d:%02d:%02d",
1371                                                           int($secs / 86_400),
1372                                                           int(($secs % 86_400) / 3_600),
1373                                                           int(($secs % 3_600) / 60),
1374                                                           $secs % 60)
1375                                                        : $fmt eq 'h' ? sprintf(
1376                                                           "%02d:%02d:%02d",
1377                                                           int(($secs % 86_400) / 3_600),
1378                                                           int(($secs % 3_600) / 60),
1379                                                           $secs % 60)
1380                                                        : sprintf(
1381                                                           "%02d:%02d",
1382                                                           int(($secs % 3_600) / 60),
1383                                                           $secs % 60);
1384                                                  }
1385                                                  
1386                                                  sub shorten {
1387        3065                 3065         11327      my ( $num, %args ) = @_;
1388        3065    100                       11814      my $p = defined $args{p} ? $args{p} : 2;     # float precision
1389        3065    100                       11387      my $d = defined $args{d} ? $args{d} : 1_024; # divisor
1390        3065                               7739      my $n = 0;
1391        3065                              16102      my @units = ('', qw(k M G T P E Z Y));
1392  ***   3065            66                16305      while ( $num >= $d && $n < @units - 1 ) {
1393          56                                159         $num /= $d;
1394          56                                327         ++$n;
1395                                                     }
1396  ***   3065    100     66                37426      return sprintf(
1397                                                        $num =~ m/\./ || $n
1398                                                           ? "%.${p}f%s"
1399                                                           : '%d',
1400                                                        $num, $units[$n]);
1401                                                  }
1402                                                  
1403                                                  sub ts {
1404  ***      0                    0             0      my ( $time, $gmt ) = @_;
1405  ***      0      0                           0      my ( $sec, $min, $hour, $mday, $mon, $year )
1406                                                        = $gmt ? gmtime($time) : localtime($time);
1407  ***      0                                  0      $mon  += 1;
1408  ***      0                                  0      $year += 1900;
1409  ***      0                                  0      my $val = sprintf("%d-%02d-%02dT%02d:%02d:%02d",
1410                                                        $year, $mon, $mday, $hour, $min, $sec);
1411  ***      0      0                           0      if ( my ($us) = $time =~ m/(\.\d+)$/ ) {
1412  ***      0                                  0         $us = sprintf("%.6f", $us);
1413  ***      0                                  0         $us =~ s/^0\././;
1414  ***      0                                  0         $val .= $us;
1415                                                     }
1416  ***      0                                  0      return $val;
1417                                                  }
1418                                                  
1419                                                  sub parse_timestamp {
1420         206                  206           834      my ( $val ) = @_;
1421  ***    206     50                        3263      if ( my($y, $m, $d, $h, $i, $s, $f)
1422                                                           = $val =~ m/^$mysql_ts$/ )
1423                                                     {
1424         206    100                        2298         return sprintf "%d-%02d-%02d %02d:%02d:"
                    100                               
1425                                                                       . (defined $f ? '%02.6f' : '%02d'),
1426                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
1427                                                     }
1428  ***      0                                  0      return $val;
1429                                                  }
1430                                                  
1431                                                  sub unix_timestamp {
1432          30                   30           138      my ( $val, $gmt ) = @_;
1433  ***     30     50                         532      if ( my($y, $m, $d, $h, $i, $s, $us) = $val =~ m/^$proper_ts$/ ) {
1434  ***     30     50                         240         $val = $gmt
1435                                                           ? timegm($s, $i, $h, $d, $m - 1, $y)
1436                                                           : timelocal($s, $i, $h, $d, $m - 1, $y);
1437          30    100                         125         if ( defined $us ) {
1438           4                                 34            $us = sprintf('%.6f', $us);
1439           4                                 23            $us =~ s/^0\././;
1440           4                                 14            $val .= $us;
1441                                                        }
1442                                                     }
1443          30                                181      return $val;
1444                                                  }
1445                                                  
1446                                                  sub any_unix_timestamp {
1447  ***      0                    0             0      my ( $val, $callback ) = @_;
1448                                                  
1449  ***      0      0                           0      if ( my ($n, $suffix) = $val =~ m/^$n_ts$/ ) {
      ***             0                               
      ***             0                               
1450  ***      0      0                           0         $n = $suffix eq 's' ? $n            # Seconds
      ***             0                               
      ***             0                               
      ***             0                               
1451                                                           : $suffix eq 'm' ? $n * 60       # Minutes
1452                                                           : $suffix eq 'h' ? $n * 3600     # Hours
1453                                                           : $suffix eq 'd' ? $n * 86400    # Days
1454                                                           :                  $n;           # default: Seconds
1455  ***      0                                  0         MKDEBUG && _d('ts is now - N[shmd]:', $n);
1456  ***      0                                  0         return time - $n;
1457                                                     }
1458                                                     elsif ( my ($ymd, $hms) = $val =~ m/^(\d{6})(?:\s+(\d+:\d+:\d+))?/ ) {
1459  ***      0                                  0         MKDEBUG && _d('ts is MySQL slow log timestamp');
1460  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
1461  ***      0                                  0         return unix_timestamp(parse_timestamp($val));
1462                                                     }
1463                                                     elsif ( ($ymd, $hms) = $val =~ m/^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) {
1464  ***      0                                  0         MKDEBUG && _d('ts is properly formatted timestamp');
1465  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
1466  ***      0                                  0         return unix_timestamp($val);
1467                                                     }
1468                                                     else {
1469  ***      0                                  0         MKDEBUG && _d('ts is MySQL expression');
1470  ***      0      0      0                    0         return $callback->($val) if $callback && ref $callback eq 'CODE';
1471                                                     }
1472                                                  
1473  ***      0                                  0      MKDEBUG && _d('Unknown ts type:', $val);
1474  ***      0                                  0      return;
1475                                                  }
1476                                                  
1477                                                  sub make_checksum {
1478         176                  176           749      my ( $val ) = @_;
1479         176                               1480      my $checksum = uc substr(md5_hex($val), -16);
1480         176                                443      MKDEBUG && _d($checksum, 'checksum for', $val);
1481         176                               1734      return $checksum;
1482                                                  }
1483                                                  
1484                                                  sub _d {
1485  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1486  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1487  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1488                                                          @_;
1489  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1490                                                  }
1491                                                  
1492                                                  1;
1493                                                  
1494                                                  # ###########################################################################
1495                                                  # End Transformers package
1496                                                  # ###########################################################################
1497                                                  
1498                                                  # ###########################################################################
1499                                                  # QueryRewriter package 5563
1500                                                  # ###########################################################################
1501           6                    6            45   use strict;
               6                                 20   
               6                                 39   
1502           6                    6            35   use warnings FATAL => 'all';
               6                                 15   
               6                                 40   
1503                                                  
1504                                                  package QueryRewriter;
1505                                                  
1506           6                    6            36   use English qw(-no_match_vars);
               6                                 16   
               6                                 43   
1507                                                  
1508  ***      6            50      6            38   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 12   
               6                                 86   
1509                                                  
1510                                                  our $verbs   = qr{^SHOW|^FLUSH|^COMMIT|^ROLLBACK|^BEGIN|SELECT|INSERT
1511                                                                    |UPDATE|DELETE|REPLACE|^SET|UNION|^START|^LOCK}xi;
1512                                                  my $quote_re = qr/"(?:(?!(?<!\\)").)*"|'(?:(?!(?<!\\)').)*'/; # Costly!
1513                                                  my $bal;
1514                                                  $bal         = qr/
1515                                                                    \(
1516                                                                    (?:
1517                                                                       (?> [^()]+ )    # Non-parens without backtracking
1518                                                                       |
1519                                                                       (??{ $bal })    # Group with matching parens
1520                                                                    )*
1521                                                                    \)
1522                                                                   /x;
1523                                                  
1524                                                  my $olc_re = qr/(?:--|#)[^'"\r\n]*(?=[\r\n]|\Z)/;  # One-line comments
1525                                                  my $mlc_re = qr#/\*[^!].*?\*/#sm;                  # But not /*!version */
1526                                                  my $vlc_re = qr#/\*.*?[0-9+].*?\*/#sm;             # For SHOW + /*!version */
1527                                                  my $vlc_rf = qr#^(SHOW).*?/\*![0-9+].*?\*/#sm;     # Variation for SHOW
1528                                                  
1529                                                  
1530                                                  sub new {
1531           6                    6            45      my ( $class, %args ) = @_;
1532           6                                 30      my $self = { %args };
1533           6                                 68      return bless $self, $class;
1534                                                  }
1535                                                  
1536                                                  sub strip_comments {
1537          98                   98           748      my ( $self, $query ) = @_;
1538  ***     98     50                         437      return unless $query;
1539          98                               3811      $query =~ s/$olc_re//go;
1540          98                                760      $query =~ s/$mlc_re//go;
1541  ***     98     50                        1334      if ( $query =~ m/$vlc_rf/i ) { # contains show + version
1542  ***      0                                  0         $query =~ s/$vlc_re//go;
1543                                                     }
1544          98                                509      return $query;
1545                                                  }
1546                                                  
1547                                                  sub shorten {
1548          79                   79          1040      my ( $self, $query, $length ) = @_;
1549          79                              57207      $query =~ s{
1550                                                        \A(
1551                                                           (?:INSERT|REPLACE)
1552                                                           (?:\s+LOW_PRIORITY|DELAYED|HIGH_PRIORITY|IGNORE)?
1553                                                           (?:\s\w+)*\s+\S+\s+VALUES\s*\(.*?\)
1554                                                        )
1555                                                        \s*,\s*\(.*?(ON\s+DUPLICATE|\Z)}
1556                                                        {$1 /*... omitted ...*/$2}xsi;
1557                                                  
1558          79    100                         750      return $query unless $query =~ m/IN\s*\(\s*(?!select)/i;
1559                                                  
1560           2                                  7      my $last_length  = 0;
1561           2                                  7      my $query_length = length($query);
1562  ***      2            33                   29      while (
      ***                    0                        
      ***                   33                        
1563                                                        $length          > 0
1564                                                        && $query_length > $length
1565                                                        && $query_length < ( $last_length || $query_length + 1 )
1566                                                     ) {
1567  ***      0                                  0         $last_length = $query_length;
1568  ***      0                                  0         $query =~ s{
1569  ***      0                                  0            (\bIN\s*\()    # The opening of an IN list
1570                                                           ([^\)]+)       # Contents of the list, assuming no item contains paren
1571                                                           (?=\))           # Close of the list
1572                                                        }
1573                                                        {
1574                                                           $1 . __shorten($2)
1575                                                        }gexsi;
1576                                                     }
1577                                                  
1578           2                                 10      return $query;
1579                                                  }
1580                                                  
1581                                                  sub __shorten {
1582  ***      0                    0             0      my ( $snippet ) = @_;
1583  ***      0                                  0      my @vals = split(/,/, $snippet);
1584  ***      0      0                           0      return $snippet unless @vals > 20;
1585  ***      0                                  0      my @keep = splice(@vals, 0, 20);  # Remove and save the first 20 items
1586                                                     return
1587  ***      0                                  0         join(',', @keep)
1588                                                        . "/*... omitted "
1589                                                        . scalar(@vals)
1590                                                        . " items ...*/";
1591                                                  }
1592                                                  
1593                                                  sub fingerprint {
1594         317                  317          2407      my ( $self, $query ) = @_;
1595                                                  
1596  ***    317     50                        1546      $query =~ m#\ASELECT /\*!40001 SQL_NO_CACHE \*/ \* FROM `# # mysqldump query
1597                                                        && return 'mysqldump';
1598  ***    317     50                        1972      $query =~ m#/\*\w+\.\w+:[0-9]/[0-9]\*/#     # mk-table-checksum, etc query
1599                                                        && return 'maatkit';
1600         317    100                        1413      $query =~ m/\A# administrator command: /
1601                                                        && return $query;
1602  ***    306     50                        1619      $query =~ m/\A\s*(call\s+\S+)\(/i
1603                                                        && return lc($1); # Warning! $1 used, be careful.
1604         306    100                        2156      if ( my ($beginning) = $query =~ m/\A((?:INSERT|REPLACE)(?: IGNORE)?\s+INTO.+?VALUES\s*\(.*?\))\s*,\s*\(/is ) {
1605           8                                 36         $query = $beginning; # Shorten multi-value INSERT statements ASAP
1606                                                     }
1607                                                  
1608         306                               2567      $query =~ s/$olc_re//go;
1609         306                               1192      $query =~ s/$mlc_re//go;
1610  ***    306     50                        1758      $query =~ s/\Ause \S+\Z/use ?/i       # Abstract the DB in USE
1611                                                        && return $query;
1612                                                  
1613         306                               1032      $query =~ s/\\["']//g;                # quoted strings
1614         306                               1007      $query =~ s/".*?"/?/sg;               # quoted strings
1615         306                               1097      $query =~ s/'.*?'/?/sg;               # quoted strings
1616         306                               1462      $query =~ s/[0-9+-][0-9a-f.xb+-]*/?/g;# Anything vaguely resembling numbers
1617         306                               1074      $query =~ s/[xb.+-]\?/?/g;            # Clean up leftovers
1618         306                               1004      $query =~ s/\A\s+//;                  # Chop off leading whitespace
1619         306                               1036      chomp $query;                         # Kill trailing whitespace
1620         306                               1263      $query =~ tr[ \n\t\r\f][ ]s;          # Collapse whitespace
1621         306                               1415      $query = lc $query;
1622         306                               5742      $query =~ s/\bnull\b/?/g;             # Get rid of NULLs
1623         306                               1418      $query =~ s{                          # Collapse IN and VALUES lists
1624                                                                 \b(in|values?)(?:[\s,]*\([\s?,]*\))+
1625                                                                }
1626                                                                {$1(?+)}gx;
1627         306                               1104      $query =~ s{                          # Collapse UNION
1628                                                                 \b(select\s.*?)(?:(\sunion(?:\sall)?)\s\1)+
1629                                                                }
1630                                                                {$1 /*repeat$2*/}xg;
1631         306                               1032      $query =~ s/\blimit \?(?:, ?\?| offset \?)?/limit ?/; # LIMIT
1632         306                               1611      return $query;
1633                                                  }
1634                                                  
1635                                                  sub distill_verbs {
1636         103                  103           789      my ( $self, $query ) = @_;
1637                                                  
1638  ***    103     50                         624      $query =~ m/\A\s*call\s+(\S+)\(/i && return "CALL $1";
1639  ***    103     50                        1313      $query =~ m/\A\s*use\s+/          && return "USE";
1640  ***    103     50                         532      $query =~ m/\A\s*UNLOCK TABLES/i  && return "UNLOCK";
1641  ***    103     50                         440      $query =~ m/\A\s*xa\s+(\S+)/i     && return "XA_$1";
1642                                                  
1643         103    100                         488      if ( $query =~ m/\A# administrator command:/ ) {
1644           5                                 28         $query =~ s/# administrator command:/ADMIN/go;
1645           5                                 24         $query = uc $query;
1646           5                                 33         return $query;
1647                                                     }
1648                                                  
1649          98                                550      $query = $self->strip_comments($query);
1650                                                  
1651          98    100                         559      if ( $query =~ m/\A\s*SHOW\s+/i ) {
1652           4                                 13         MKDEBUG && _d($query);
1653                                                  
1654           4                                 18         $query = uc $query;
1655           4                                 23         $query =~ s/\s+(?:GLOBAL|SESSION|FULL|STORAGE|ENGINE)\b/ /g;
1656           4                                 20         $query =~ s/\s+COUNT[^)]+\)//g;
1657                                                  
1658           4                                 12         $query =~ s/\s+(?:FOR|FROM|LIKE|WHERE|LIMIT|IN)\b.+//ms;
1659                                                  
1660           4                                 57         $query =~ s/\A(SHOW(?:\s+\S+){1,2}).*\Z/$1/s;
1661           4                                 19         $query =~ s/\s+/ /g;
1662           4                                 10         MKDEBUG && _d($query);
1663           4                                 32         return $query;
1664                                                     }
1665                                                  
1666          94                                345      eval $QueryParser::data_def_stmts;
1667          94                                232      eval $QueryParser::tbl_ident;
1668          94                               1121      my ( $dds ) = $query =~ /^\s*($QueryParser::data_def_stmts)\b/i;
1669          94    100                         437      if ( $dds) {
1670           2                                 44         my ( $obj ) = $query =~ m/$dds.+(DATABASE|TABLE)\b/i;
1671  ***      2     50                          12         $obj = uc $obj if $obj;
1672           2                                  4         MKDEBUG && _d('Data def statment:', $dds, 'obj:', $obj);
1673           2                                 61         my ($db_or_tbl)
1674                                                           = $query =~ m/(?:TABLE|DATABASE)\s+($QueryParser::tbl_ident)(\s+.*)?/i;
1675           2                                  6         MKDEBUG && _d('Matches db or table:', $db_or_tbl);
1676  ***      2     50                          17         return uc($dds . ($obj ? " $obj" : '')), $db_or_tbl;
1677                                                     }
1678                                                  
1679          92                             138850      my @verbs = $query =~ m/\b($verbs)\b/gio;
1680          92                                325      @verbs    = do {
1681          92                                302         my $last = '';
1682          92                                364         grep { my $pass = $_ ne $last; $last = $_; $pass } map { uc } @verbs;
              90                                403   
              90                                250   
              90                                430   
              90                                405   
1683                                                     };
1684          92                                391      my $verbs = join(q{ }, @verbs);
1685          92                                346      $verbs =~ s/( UNION SELECT)+/ UNION/g;
1686                                                  
1687          92                                458      return $verbs;
1688                                                  }
1689                                                  
1690                                                  sub __distill_tables {
1691          94                   94          1015      my ( $self, $query, $table, %args ) = @_;
1692  ***     94            33                 1038      my $qp = $args{QueryParser} || $self->{QueryParser};
1693  ***     94     50                         394      die "I need a QueryParser argument" unless $qp;
1694                                                  
1695          77                                342      my @tables = map {
1696          77                                312         $_ =~ s/`//g;
1697          77                                592         $_ =~ s/(_?)[0-9]+/$1?/g;
1698          77                                383         $_;
1699          94                                697      } grep { defined $_ } $qp->get_tables($query);
1700                                                  
1701          94    100                         421      push @tables, $table if $table;
1702                                                  
1703          94                                298      @tables = do {
1704          94                                310         my $last = '';
1705          94                                337         grep { my $pass = $_ ne $last; $last = $_; $pass } @tables;
              79                                270   
              79                                232   
              79                                336   
1706                                                     };
1707                                                  
1708          94                                445      return @tables;
1709                                                  }
1710                                                  
1711                                                  sub distill {
1712          98                   98          1121      my ( $self, $query, %args ) = @_;
1713                                                  
1714  ***     98     50                         480      if ( $args{generic} ) {
1715  ***      0                                  0         my ($cmd, $arg) = $query =~ m/^(\S+)\s+(\S+)/;
1716  ***      0      0                           0         return '' unless $cmd;
1717  ***      0      0                           0         $query = (uc $cmd) . ($arg ? " $arg" : '');
1718                                                     }
1719                                                     else {
1720          98                                696         my ($verbs, $table)  = $self->distill_verbs($query, %args);
1721                                                  
1722          98    100    100                 1073         if ( $verbs && $verbs =~ m/^SHOW/ ) {
1723           4                                 36            my %alias_for = qw(
1724                                                              SCHEMA   DATABASE
1725                                                              KEYS     INDEX
1726                                                              INDEXES  INDEX
1727                                                           );
1728           4                                 19            map { $verbs =~ s/$_/$alias_for{$_}/ } keys %alias_for;
              12                                141   
1729           4                                 21            $query = $verbs;
1730                                                        }
1731                                                        else {
1732          94                                642            my @tables = $self->__distill_tables($query, $table, %args);
1733          94                                489            $query     = join(q{ }, $verbs, @tables); 
1734                                                        } 
1735                                                     }
1736                                                  
1737  ***     98     50                         429      if ( $args{trf} ) {
1738  ***      0                                  0         $query = $args{trf}->($query, %args);
1739                                                     }
1740                                                  
1741          98                                834      return $query;
1742                                                  }
1743                                                  
1744                                                  sub convert_to_select {
1745          41                   41           235      my ( $self, $query ) = @_;
1746  ***     41     50                         190      return unless $query;
1747          14                                115      $query =~ s{
      ***      0                                  0   
1748                                                                   \A.*?
1749                                                                   update\s+(.*?)
1750                                                                   \s+set\b(.*?)
1751                                                                   (?:\s*where\b(.*?))?
1752                                                                   (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
1753                                                                   \Z
1754                                                                }
1755                                                                {__update_to_select($1, $2, $3, $4)}exsi
1756           1                                  8         || $query =~ s{
1757                                                                      \A.*?
1758                                                                      (?:insert|replace)\s+
1759                                                                      .*?\binto\b(.*?)\(([^\)]+)\)\s*
1760                                                                      values?\s*(\(.*?\))\s*
1761                                                                      (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
1762                                                                      \Z
1763                                                                   }
1764                                                                   {__insert_to_select($1, $2, $3)}exsi
1765  ***     41    100     66                 1019         || $query =~ s{
1766                                                                      \A.*?
1767                                                                      delete\s+(.*?)
1768                                                                      \bfrom\b(.*)
1769                                                                      \Z
1770                                                                   }
1771                                                                   {__delete_to_select($1, $2)}exsi;
1772          41                                368      $query =~ s/\s*on\s+duplicate\s+key\s+update.*\Z//si;
1773          41                                280      $query =~ s/\A.*?(?=\bSELECT\s*\b)//ism;
1774          41                                177      return $query;
1775                                                  }
1776                                                  
1777                                                  sub convert_select_list {
1778  ***      0                    0             0      my ( $self, $query ) = @_;
1779  ***      0      0                           0      $query =~ s{
      ***      0                                  0   
1780                                                                 \A\s*select(.*?)\bfrom\b
1781                                                                }
1782                                                                {$1 =~ m/\*/ ? "select 1 from" : "select isnull(coalesce($1)) from"}exi;
1783  ***      0                                  0      return $query;
1784                                                  }
1785                                                  
1786                                                  sub __delete_to_select {
1787           1                    1            10      my ( $delete, $join ) = @_;
1788  ***      1     50                           9      if ( $join =~ m/\bjoin\b/ ) {
1789  ***      0                                  0         return "select 1 from $join";
1790                                                     }
1791           1                                  7      return "select * from $join";
1792                                                  }
1793                                                  
1794                                                  sub __insert_to_select {
1795  ***      0                    0             0      my ( $tbl, $cols, $vals ) = @_;
1796  ***      0                                  0      MKDEBUG && _d('Args:', @_);
1797  ***      0                                  0      my @cols = split(/,/, $cols);
1798  ***      0                                  0      MKDEBUG && _d('Cols:', @cols);
1799  ***      0                                  0      $vals =~ s/^\(|\)$//g; # Strip leading/trailing parens
1800  ***      0                                  0      my @vals = $vals =~ m/($quote_re|[^,]*${bal}[^,]*|[^,]+)/g;
1801  ***      0                                  0      MKDEBUG && _d('Vals:', @vals);
1802  ***      0      0                           0      if ( @cols == @vals ) {
1803  ***      0                                  0         return "select * from $tbl where "
1804  ***      0                                  0            . join(' and ', map { "$cols[$_]=$vals[$_]" } (0..$#cols));
1805                                                     }
1806                                                     else {
1807  ***      0                                  0         return "select * from $tbl limit 1";
1808                                                     }
1809                                                  }
1810                                                  
1811                                                  sub __update_to_select {
1812          14                   14           143      my ( $from, $set, $where, $limit ) = @_;
1813          14    100                         208      return "select $set from $from "
      ***            50                               
1814                                                        . ( $where ? "where $where" : '' )
1815                                                        . ( $limit ? " $limit "      : '' );
1816                                                  }
1817                                                  
1818                                                  sub wrap_in_derived {
1819  ***      0                    0             0      my ( $self, $query ) = @_;
1820  ***      0      0                           0      return unless $query;
1821  ***      0      0                           0      return $query =~ m/\A\s*select/i
1822                                                        ? "select 1 from ($query) as x limit 1"
1823                                                        : $query;
1824                                                  }
1825                                                  
1826                                                  sub _d {
1827  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1828  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1829  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1830                                                          @_;
1831  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1832                                                  }
1833                                                  
1834                                                  1;
1835                                                  
1836                                                  # ###########################################################################
1837                                                  # End QueryRewriter package
1838                                                  # ###########################################################################
1839                                                  
1840                                                  # ###########################################################################
1841                                                  # Processlist package 5266
1842                                                  # ###########################################################################
1843                                                  package Processlist;
1844                                                  
1845           6                    6            49   use strict;
               6                                 23   
               6                                 38   
1846           6                    6            36   use warnings FATAL => 'all';
               6                                 14   
               6                                 37   
1847           6                    6            36   use English qw(-no_match_vars);
               6                                 16   
               6                                 36   
1848                                                  
1849           6                    6            39   use Data::Dumper;
               6                                 16   
               6                                 37   
1850                                                  $Data::Dumper::Indent    = 1;
1851                                                  $Data::Dumper::Sortkeys  = 1;
1852                                                  $Data::Dumper::Quotekeys = 0;
1853                                                  
1854  ***      6            50      6            38   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 21   
               6                                 86   
1855                                                  use constant {
1856           6                                 77      ID      => 0,
1857                                                     USER    => 1,
1858                                                     HOST    => 2,
1859                                                     DB      => 3,
1860                                                     COMMAND => 4,
1861                                                     TIME    => 5,
1862                                                     STATE   => 6,
1863                                                     INFO    => 7,
1864                                                     START   => 8, # Calculated start time of statement
1865                                                     ETIME   => 9, # Exec time of SHOW PROCESSLIST (margin of error in START)
1866                                                     FSEEN   => 10, # First time ever seen
1867           6                    6            38   };
               6                                 14   
1868                                                  
1869                                                  sub new {
1870  ***      0                    0             0      my ( $class, %args ) = @_;
1871  ***      0                                  0      my $self = {
1872                                                        prev_rows => [],
1873                                                        new_rows  => [],
1874                                                        curr_row  => undef,
1875                                                        prev_row  => undef,
1876                                                     };
1877  ***      0                                  0      return bless $self, $class;
1878                                                  }
1879                                                  
1880                                                  sub parse_event {
1881  ***      0                    0             0      my ( $self, %args ) = @_;
1882  ***      0                                  0      my @required_args = qw(misc);
1883  ***      0                                  0      foreach my $arg ( @required_args ) {
1884  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1885                                                     }
1886  ***      0                                  0      my ($misc) = @args{@required_args};
1887                                                  
1888  ***      0                                  0      my $code = $misc->{code};
1889  ***      0      0                           0      die "I need a code arg to misc" unless $code;
1890                                                  
1891  ***      0                                  0      my @curr;
1892  ***      0      0                           0      if ( $self->{curr_rows} ) {
1893  ***      0                                  0         MKDEBUG && _d('Current rows from last call');
1894  ***      0                                  0         @curr = @{$self->{curr_rows}};
      ***      0                                  0   
1895                                                     }
1896                                                     else {
1897  ***      0                                  0         my $rows = $code->();
1898  ***      0      0      0                    0         if ( $rows && scalar @$rows ) {
1899  ***      0                                  0            MKDEBUG && _d('Got new current rows');
1900  ***      0                                  0            @curr = sort { $a->[ID] <=> $b->[ID] } @$rows;
      ***      0                                  0   
1901                                                        }
1902                                                        else {
1903  ***      0                                  0            MKDEBUG && _d('No current rows');
1904                                                        }
1905                                                     }
1906                                                  
1907  ***      0             0                    0      my @prev = @{$self->{prev_rows} ||= []};
      ***      0                                  0   
1908  ***      0             0                    0      my @new  = @{$self->{new_rows}  ||= []};; # Becomes next invocation's @prev
      ***      0                                  0   
1909  ***      0                                  0      my $curr = $self->{curr_row}; # Rows from each source
1910  ***      0                                  0      my $prev = $self->{prev_row};
1911  ***      0                                  0      my $event;
1912                                                  
1913  ***      0                                  0      MKDEBUG && _d('Rows:', scalar @prev, 'prev,', scalar @curr, 'current');
1914                                                  
1915  ***      0      0      0                    0      if ( !$curr && @curr ) {
1916  ***      0                                  0         MKDEBUG && _d('Fetching row from curr');
1917  ***      0                                  0         $curr = shift @curr;
1918                                                     }
1919  ***      0      0      0                    0      if ( !$prev && @prev ) {
1920  ***      0                                  0         MKDEBUG && _d('Fetching row from prev');
1921  ***      0                                  0         $prev = shift @prev;
1922                                                     }
1923  ***      0      0      0                    0      if ( $curr || $prev ) {
1924  ***      0      0      0                    0         if ( $curr && $prev && $curr->[ID] == $prev->[ID] ) {
      ***             0      0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
1925  ***      0                                  0            MKDEBUG && _d('$curr and $prev are the same cxn');
1926  ***      0      0                           0            my $fudge = $curr->[TIME] =~ m/\D/ ? 0.001 : 1; # Micro-precision?
1927  ***      0                                  0            my $is_new = 0;
1928  ***      0      0                           0            if ( $prev->[INFO] ) {
1929  ***      0      0      0                    0               if (!$curr->[INFO] || $prev->[INFO] ne $curr->[INFO]) {
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
1930  ***      0                                  0                  MKDEBUG && _d('$curr has a new query');
1931  ***      0                                  0                  $is_new = 1;
1932                                                              }
1933                                                              elsif (defined $curr->[TIME] && $curr->[TIME] < $prev->[TIME]) {
1934  ***      0                                  0                  MKDEBUG && _d('$curr time is less than $prev time');
1935  ***      0                                  0                  $is_new = 1;
1936                                                              }
1937                                                              elsif ( $curr->[INFO] && defined $curr->[TIME]
1938                                                                      && $misc->{time} - $curr->[TIME] - $prev->[START]
1939                                                                         - $prev->[ETIME] - $misc->{etime} > $fudge
1940                                                              ) {
1941  ***      0                                  0                  MKDEBUG && _d('$curr has same query that restarted');
1942  ***      0                                  0                  $is_new = 1;
1943                                                              }
1944  ***      0      0                           0               if ( $is_new ) {
1945  ***      0                                  0                  $event = $self->make_event($prev, $misc->{time});
1946                                                              }
1947                                                           }
1948  ***      0      0                           0            if ( $curr->[INFO] ) {
1949  ***      0      0      0                    0               if ( $prev->[INFO] && !$is_new ) {
1950  ***      0                                  0                  MKDEBUG && _d('Pushing old history item back onto $prev');
1951  ***      0                                  0                  push @new, [ @$prev ];
1952                                                              }
1953                                                              else {
1954  ***      0                                  0                  MKDEBUG && _d('Pushing new history item onto $prev');
1955  ***      0                                  0                  push @new,
1956                                                                    [ @$curr, int($misc->{time} - $curr->[TIME]),
1957                                                                       $misc->{etime}, $misc->{time} ];
1958                                                              }
1959                                                           }
1960  ***      0                                  0            $curr = $prev = undef; # Fetch another from each.
1961                                                        }
1962                                                        elsif ( !$curr
1963                                                                || ($curr && $prev && $curr->[ID] > $prev->[ID]) ) {
1964  ***      0                                  0            MKDEBUG && _d('$curr is not in $prev');
1965  ***      0                                  0            $event = $self->make_event($prev, $misc->{time});
1966  ***      0                                  0            $prev = undef;
1967                                                        }
1968                                                        else { # This else must be entered, to prevent infinite loops.
1969  ***      0                                  0            MKDEBUG && _d('$prev is not in $curr');
1970  ***      0      0      0                    0            if ( $curr->[INFO] && defined $curr->[TIME] ) {
1971  ***      0                                  0               MKDEBUG && _d('Pushing new history item onto $prev');
1972  ***      0                                  0               push @new,
1973                                                                 [ @$curr, int($misc->{time} - $curr->[TIME]),
1974                                                                    $misc->{etime}, $misc->{time} ];
1975                                                           }
1976  ***      0                                  0            $curr = undef; # No infinite loops.
1977                                                        }
1978                                                     }
1979                                                  
1980  ***      0                                  0      $self->{prev_rows} = \@new;
1981  ***      0                                  0      $self->{prev_row}  = $prev;
1982  ***      0      0                           0      $self->{curr_rows} = scalar @curr ? \@curr : undef;
1983  ***      0                                  0      $self->{curr_row}  = $curr;
1984                                                  
1985  ***      0                                  0      return $event;
1986                                                  }
1987                                                  
1988                                                  sub make_event {
1989  ***      0                    0             0      my ( $self, $row, $time ) = @_;
1990  ***      0                                  0      my $Query_time = $row->[TIME];
1991  ***      0      0                           0      if ( $row->[TIME] < $time - $row->[FSEEN] ) {
1992  ***      0                                  0         $Query_time = $time - $row->[FSEEN];
1993                                                     }
1994  ***      0                                  0      my $event = {
1995                                                        id         => $row->[ID],
1996                                                        db         => $row->[DB],
1997                                                        user       => $row->[USER],
1998                                                        host       => $row->[HOST],
1999                                                        arg        => $row->[INFO],
2000                                                        bytes      => length($row->[INFO]),
2001                                                        ts         => Transformers::ts($row->[START] + $row->[TIME]), # Query END time
2002                                                        Query_time => $Query_time,
2003                                                        Lock_time  => 0,               # TODO
2004                                                     };
2005  ***      0                                  0      MKDEBUG && _d('Properties of event:', Dumper($event));
2006  ***      0                                  0      return $event;
2007                                                  }
2008                                                  
2009                                                  sub _get_rows {
2010  ***      0                    0             0      my ( $self ) = @_;
2011  ***      0                                  0      my %rows = map { $_ => $self->{$_} }
      ***      0                                  0   
2012                                                        qw(prev_rows new_rows curr_row prev_row);
2013  ***      0                                  0      return \%rows;
2014                                                  }
2015                                                  
2016                                                  sub find {
2017  ***      0                    0             0      my ( $self, $proclist, %find_spec ) = @_;
2018  ***      0                                  0      MKDEBUG && _d('find specs:', Dumper(\%find_spec));
2019  ***      0                                  0      my @matches;
2020                                                     QUERY:
2021  ***      0                                  0      foreach my $query ( @$proclist ) {
2022  ***      0                                  0         MKDEBUG && _d('Checking query', Dumper($query));
2023  ***      0                                  0         my $matched = 0;
2024                                                  
2025  ***      0      0      0                    0         if ( $find_spec{busy_time} && ($query->{Command} || '') eq 'Query' ) {
      ***                    0                        
2026  ***      0      0                           0            if ( $query->{Time} < $find_spec{busy_time} ) {
2027  ***      0                                  0               MKDEBUG && _d("Query isn't running long enough");
2028  ***      0                                  0               next QUERY;
2029                                                           }
2030  ***      0                                  0            MKDEBUG && _d('Exceeds busy time');
2031  ***      0                                  0            $matched++;
2032                                                        }
2033                                                  
2034  ***      0      0      0                    0         if ( $find_spec{idle_time} && ($query->{Command} || '') eq 'Sleep' ) {
      ***                    0                        
2035  ***      0      0                           0            if ( $query->{Time} < $find_spec{idle_time} ) {
2036  ***      0                                  0               MKDEBUG && _d("Query isn't idle long enough");
2037  ***      0                                  0               next QUERY;
2038                                                           }
2039  ***      0                                  0            MKDEBUG && _d('Exceeds idle time');
2040  ***      0                                  0            $matched++;
2041                                                        }
2042                                                  
2043                                                        PROPERTY:
2044  ***      0                                  0         foreach my $property ( qw(Id User Host db State Command Info) ) {
2045  ***      0                                  0            my $filter = "_find_match_$property";
2046  ***      0      0      0                    0            if ( defined $find_spec{ignore}->{$property}
2047                                                                && $self->$filter($query, $find_spec{ignore}->{$property}) ) {
2048  ***      0                                  0               MKDEBUG && _d('Query matches ignore', $property, 'spec');
2049  ***      0                                  0               next QUERY;
2050                                                           }
2051  ***      0      0                           0            if ( defined $find_spec{match}->{$property} ) {
2052  ***      0      0                           0               if ( !$self->$filter($query, $find_spec{match}->{$property}) ) {
2053  ***      0                                  0                  MKDEBUG && _d('Query does not match', $property, 'spec');
2054  ***      0                                  0                  next QUERY;
2055                                                              }
2056  ***      0                                  0               MKDEBUG && _d('Query matches', $property, 'spec');
2057  ***      0                                  0               $matched++;
2058                                                           }
2059                                                        }
2060  ***      0      0                           0         if ( $matched ) {
2061  ***      0                                  0            MKDEBUG && _d("Query matched one or more specs, adding");
2062  ***      0                                  0            push @matches, $query;
2063  ***      0                                  0            next QUERY;
2064                                                        }
2065  ***      0                                  0         MKDEBUG && _d('Query does not match any specs, ignoring');
2066                                                     } # QUERY
2067                                                  
2068  ***      0      0      0                    0      if ( @matches && $find_spec{only_oldest} ) {
2069  ***      0                                  0         my ( $oldest ) = reverse sort { $a->{Time} <=> $b->{Time} } @matches;
      ***      0                                  0   
2070  ***      0                                  0         MKDEBUG && _d('Oldest query:', Dumper($oldest));
2071  ***      0                                  0         @matches = $oldest;
2072                                                     }
2073                                                  
2074  ***      0                                  0      return @matches;
2075                                                  }
2076                                                  
2077                                                  sub _find_match_Id {
2078  ***      0                    0             0      my ( $self, $query, $property ) = @_;
2079  ***      0             0                    0      return defined $property && defined $query->{Id} && $query->{Id} == $property;
      ***                    0                        
2080                                                  }
2081                                                  
2082                                                  sub _find_match_User {
2083  ***      0                    0             0      my ( $self, $query, $property ) = @_;
2084  ***      0             0                    0      return defined $property && defined $query->{User}
      ***                    0                        
2085                                                        && $query->{User} =~ m/$property/;
2086                                                  }
2087                                                  
2088                                                  sub _find_match_Host {
2089  ***      0                    0             0      my ( $self, $query, $property ) = @_;
2090  ***      0             0                    0      return defined $property && defined $query->{Host}
      ***                    0                        
2091                                                        && $query->{Host} =~ m/$property/;
2092                                                  }
2093                                                  
2094                                                  sub _find_match_db {
2095  ***      0                    0             0      my ( $self, $query, $property ) = @_;
2096  ***      0             0                    0      return defined $property && defined $query->{db}
      ***                    0                        
2097                                                        && $query->{db} =~ m/$property/;
2098                                                  }
2099                                                  
2100                                                  sub _find_match_State {
2101  ***      0                    0             0      my ( $self, $query, $property ) = @_;
2102  ***      0             0                    0      return defined $property && defined $query->{State}
      ***                    0                        
2103                                                        && $query->{State} =~ m/$property/;
2104                                                  }
2105                                                  
2106                                                  sub _find_match_Command {
2107  ***      0                    0             0      my ( $self, $query, $property ) = @_;
2108  ***      0             0                    0      return defined $property && defined $query->{Command}
      ***                    0                        
2109                                                        && $query->{Command} =~ m/$property/;
2110                                                  }
2111                                                  
2112                                                  sub _find_match_Info {
2113  ***      0                    0             0      my ( $self, $query, $property ) = @_;
2114  ***      0             0                    0      return defined $property && defined $query->{Info}
      ***                    0                        
2115                                                        && $query->{Info} =~ m/$property/;
2116                                                  }
2117                                                  
2118                                                  sub _d {
2119  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2120  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2121  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2122                                                          @_;
2123  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2124                                                  }
2125                                                  
2126                                                  1;
2127                                                  
2128                                                  # ###########################################################################
2129                                                  # End Processlist package
2130                                                  # ###########################################################################
2131                                                  
2132                                                  # ###########################################################################
2133                                                  # TcpdumpParser package 5436
2134                                                  # ###########################################################################
2135                                                  package TcpdumpParser;
2136                                                  
2137                                                  
2138           6                    6            43   use strict;
               6                                 16   
               6                                 37   
2139           6                    6            38   use warnings FATAL => 'all';
               6                                 18   
               6                                 36   
2140           6                    6            41   use English qw(-no_match_vars);
               6                                 14   
               6                                 33   
2141           6                    6            36   use Data::Dumper;
               6                                 20   
               6                                 30   
2142                                                  $Data::Dumper::Indent   = 1;
2143                                                  $Data::Dumper::Sortkeys = 1;
2144                                                  
2145  ***      6            50      6            38   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 14   
               6                                 80   
2146                                                  
2147                                                  sub new {
2148           3                    3            26      my ( $class, %args ) = @_;
2149           3                                 41      my $self = {};
2150           3                                 34      return bless $self, $class;
2151                                                  }
2152                                                  
2153                                                  sub parse_event {
2154          38                   38           205      my ( $self, %args ) = @_;
2155          38                                174      my @required_args = qw(next_event tell);
2156          38                                121      foreach my $arg ( @required_args ) {
2157  ***     76     50                         354         die "I need a $arg argument" unless $args{$arg};
2158                                                     }
2159          38                                172      my ($next_event, $tell) = @args{@required_args};
2160                                                  
2161          38                                232      local $INPUT_RECORD_SEPARATOR = "\n20";
2162                                                  
2163          38                                136      my $pos_in_log = $tell->();
2164          38                                138      while ( defined(my $raw_packet = $next_event->()) ) {
2165  ***     35     50                         182         next if $raw_packet =~ m/^$/;  # issue 564
2166          35    100                         142         $pos_in_log -= 1 if $pos_in_log;
2167                                                  
2168          35                                165         $raw_packet =~ s/\n20\Z//;
2169          35    100                         206         $raw_packet = "20$raw_packet" unless $raw_packet =~ m/\A20/;
2170                                                  
2171          35                                162         my $packet = $self->_parse_packet($raw_packet);
2172          35                                125         $packet->{pos_in_log} = $pos_in_log;
2173          35                                143         $packet->{raw_packet} = $raw_packet;
2174                                                  
2175          35                                252         return $packet;
2176                                                     }
2177                                                  
2178  ***      3     50                          23      $args{oktorun}->(0) if $args{oktorun};
2179           3                                 19      return;
2180                                                  }
2181                                                  
2182                                                  sub _parse_packet {
2183          35                   35           159      my ( $self, $packet ) = @_;
2184  ***     35     50                         132      die "I need a packet" unless $packet;
2185                                                  
2186          35                                339      my ( $ts, $source, $dest )  = $packet =~ m/\A(\S+ \S+) IP .*?(\S+) > (\S+):/;
2187          35                                270      my ( $src_host, $src_port ) = $source =~ m/((?:\d+\.){3}\d+)\.(\w+)/;
2188          35                                220      my ( $dst_host, $dst_port ) = $dest   =~ m/((?:\d+\.){3}\d+)\.(\w+)/;
2189                                                  
2190          35                                157      $src_port = $self->port_number($src_port);
2191          35                                119      $dst_port = $self->port_number($dst_port);
2192                                                     
2193          35                                216      my $hex = qr/[0-9a-f]/;
2194          35                               1415      (my $data = join('', $packet =~ m/\s+0x$hex+:\s((?:\s$hex{2,4})+)/go)) =~ s/\s+//g; 
2195                                                  
2196          35                                177      my $ip_hlen = hex(substr($data, 1, 1)); # Num of 32-bit words in header.
2197          35                                123      my $ip_plen = hex(substr($data, 4, 4)); # Num of BYTES in IPv4 datagram.
2198  ***     35     50                         170      my $complete = length($data) == 2 * $ip_plen ? 1 : 0;
2199                                                  
2200          35                                144      my $tcp_hlen = hex(substr($data, ($ip_hlen + 3) * 8, 1));
2201                                                  
2202          35                                145      my $seq = hex(substr($data, ($ip_hlen + 1) * 8, 8));
2203          35                                141      my $ack = hex(substr($data, ($ip_hlen + 2) * 8, 8));
2204                                                  
2205          35                                149      my $flags = hex(substr($data, (($ip_hlen + 3) * 8) + 2, 2));
2206                                                  
2207          35                                128      $data = substr($data, ($ip_hlen + $tcp_hlen) * 8);
2208                                                  
2209          35    100                         693      my $pkt = {
                    100                               
2210                                                        ts        => $ts,
2211                                                        seq       => $seq,
2212                                                        ack       => $ack,
2213                                                        fin       => $flags & 0x01,
2214                                                        syn       => $flags & 0x02,
2215                                                        rst       => $flags & 0x04,
2216                                                        src_host  => $src_host,
2217                                                        src_port  => $src_port,
2218                                                        dst_host  => $dst_host,
2219                                                        dst_port  => $dst_port,
2220                                                        complete  => $complete,
2221                                                        ip_hlen   => $ip_hlen,
2222                                                        tcp_hlen  => $tcp_hlen,
2223                                                        dgram_len => $ip_plen,
2224                                                        data_len  => $ip_plen - (($ip_hlen + $tcp_hlen) * 4),
2225                                                        data      => $data ? substr($data, 0, 10).(length $data > 10 ? '...' : '')
2226                                                                           : '',
2227                                                     };
2228          35                                 83      MKDEBUG && _d('packet:', Dumper($pkt));
2229          35                                123      $pkt->{data} = $data;
2230          35                                232      return $pkt;
2231                                                  }
2232                                                  
2233                                                  sub port_number {
2234          70                   70           257      my ( $self, $port ) = @_;
2235  ***     70     50                         277      return unless $port;
2236          70    100                         465      return $port eq 'memcached' ? 11211
      ***            50                               
      ***            50                               
2237                                                          : $port eq 'http'      ? 80
2238                                                          : $port eq 'mysql'     ? 3306
2239                                                          :                        $port; 
2240                                                  }
2241                                                  
2242                                                  sub _d {
2243  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2244  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2245  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2246                                                          @_;
2247  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2248                                                  }
2249                                                  
2250                                                  1;
2251                                                  
2252                                                  # ###########################################################################
2253                                                  # End TcpdumpParser package
2254                                                  # ###########################################################################
2255                                                  
2256                                                  # ###########################################################################
2257                                                  # MySQLProtocolParser package 5570
2258                                                  # ###########################################################################
2259                                                  package MySQLProtocolParser;
2260                                                  
2261                                                  
2262           6                    6            41   use strict;
               6                                 17   
               6                                 34   
2263           6                    6            39   use warnings FATAL => 'all';
               6                                 13   
               6                                 30   
2264           6                    6            40   use English qw(-no_match_vars);
               6                                 12   
               6                                 33   
2265                                                  
2266                                                  eval {
2267                                                     require IO::Uncompress::Inflate;
2268                                                     IO::Uncompress::Inflate->import(qw(inflate $InflateError));
2269                                                  };
2270                                                  
2271           6                    6            42   use Data::Dumper;
               6                                 15   
               6                                 34   
2272                                                  $Data::Dumper::Indent    = 1;
2273                                                  $Data::Dumper::Sortkeys  = 1;
2274                                                  $Data::Dumper::Quotekeys = 0;
2275                                                  
2276                                                  require Exporter;
2277                                                  our @ISA         = qw(Exporter);
2278                                                  our %EXPORT_TAGS = ();
2279                                                  our @EXPORT      = ();
2280                                                  our @EXPORT_OK   = qw(
2281                                                     parse_error_packet
2282                                                     parse_ok_packet
2283                                                     parse_ok_prepared_statement_packet
2284                                                     parse_server_handshake_packet
2285                                                     parse_client_handshake_packet
2286                                                     parse_com_packet
2287                                                     parse_flags
2288                                                  );
2289                                                  
2290  ***      6            50      6            47   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 13   
               6                                 98   
2291                                                  use constant {
2292           6                                219      COM_SLEEP               => '00',
2293                                                     COM_QUIT                => '01',
2294                                                     COM_INIT_DB             => '02',
2295                                                     COM_QUERY               => '03',
2296                                                     COM_FIELD_LIST          => '04',
2297                                                     COM_CREATE_DB           => '05',
2298                                                     COM_DROP_DB             => '06',
2299                                                     COM_REFRESH             => '07',
2300                                                     COM_SHUTDOWN            => '08',
2301                                                     COM_STATISTICS          => '09',
2302                                                     COM_PROCESS_INFO        => '0a',
2303                                                     COM_CONNECT             => '0b',
2304                                                     COM_PROCESS_KILL        => '0c',
2305                                                     COM_DEBUG               => '0d',
2306                                                     COM_PING                => '0e',
2307                                                     COM_TIME                => '0f',
2308                                                     COM_DELAYED_INSERT      => '10',
2309                                                     COM_CHANGE_USER         => '11',
2310                                                     COM_BINLOG_DUMP         => '12',
2311                                                     COM_TABLE_DUMP          => '13',
2312                                                     COM_CONNECT_OUT         => '14',
2313                                                     COM_REGISTER_SLAVE      => '15',
2314                                                     COM_STMT_PREPARE        => '16',
2315                                                     COM_STMT_EXECUTE        => '17',
2316                                                     COM_STMT_SEND_LONG_DATA => '18',
2317                                                     COM_STMT_CLOSE          => '19',
2318                                                     COM_STMT_RESET          => '1a',
2319                                                     COM_SET_OPTION          => '1b',
2320                                                     COM_STMT_FETCH          => '1c',
2321                                                     SERVER_QUERY_NO_GOOD_INDEX_USED => 16,
2322                                                     SERVER_QUERY_NO_INDEX_USED      => 32,
2323           6                    6            48   };
               6                                 16   
2324                                                  
2325                                                  my %com_for = (
2326                                                     '00' => 'COM_SLEEP',
2327                                                     '01' => 'COM_QUIT',
2328                                                     '02' => 'COM_INIT_DB',
2329                                                     '03' => 'COM_QUERY',
2330                                                     '04' => 'COM_FIELD_LIST',
2331                                                     '05' => 'COM_CREATE_DB',
2332                                                     '06' => 'COM_DROP_DB',
2333                                                     '07' => 'COM_REFRESH',
2334                                                     '08' => 'COM_SHUTDOWN',
2335                                                     '09' => 'COM_STATISTICS',
2336                                                     '0a' => 'COM_PROCESS_INFO',
2337                                                     '0b' => 'COM_CONNECT',
2338                                                     '0c' => 'COM_PROCESS_KILL',
2339                                                     '0d' => 'COM_DEBUG',
2340                                                     '0e' => 'COM_PING',
2341                                                     '0f' => 'COM_TIME',
2342                                                     '10' => 'COM_DELAYED_INSERT',
2343                                                     '11' => 'COM_CHANGE_USER',
2344                                                     '12' => 'COM_BINLOG_DUMP',
2345                                                     '13' => 'COM_TABLE_DUMP',
2346                                                     '14' => 'COM_CONNECT_OUT',
2347                                                     '15' => 'COM_REGISTER_SLAVE',
2348                                                     '16' => 'COM_STMT_PREPARE',
2349                                                     '17' => 'COM_STMT_EXECUTE',
2350                                                     '18' => 'COM_STMT_SEND_LONG_DATA',
2351                                                     '19' => 'COM_STMT_CLOSE',
2352                                                     '1a' => 'COM_STMT_RESET',
2353                                                     '1b' => 'COM_SET_OPTION',
2354                                                     '1c' => 'COM_STMT_FETCH',
2355                                                  );
2356                                                  
2357                                                  my %flag_for = (
2358                                                     'CLIENT_LONG_PASSWORD'     => 1,       # new more secure passwords 
2359                                                     'CLIENT_FOUND_ROWS'        => 2,       # Found instead of affected rows 
2360                                                     'CLIENT_LONG_FLAG'         => 4,       # Get all column flags 
2361                                                     'CLIENT_CONNECT_WITH_DB'   => 8,       # One can specify db on connect 
2362                                                     'CLIENT_NO_SCHEMA'         => 16,      # Don't allow database.table.column 
2363                                                     'CLIENT_COMPRESS'          => 32,      # Can use compression protocol 
2364                                                     'CLIENT_ODBC'              => 64,      # Odbc client 
2365                                                     'CLIENT_LOCAL_FILES'       => 128,     # Can use LOAD DATA LOCAL 
2366                                                     'CLIENT_IGNORE_SPACE'      => 256,     # Ignore spaces before '(' 
2367                                                     'CLIENT_PROTOCOL_41'       => 512,     # New 4.1 protocol 
2368                                                     'CLIENT_INTERACTIVE'       => 1024,    # This is an interactive client 
2369                                                     'CLIENT_SSL'               => 2048,    # Switch to SSL after handshake 
2370                                                     'CLIENT_IGNORE_SIGPIPE'    => 4096,    # IGNORE sigpipes 
2371                                                     'CLIENT_TRANSACTIONS'      => 8192,    # Client knows about transactions 
2372                                                     'CLIENT_RESERVED'          => 16384,   # Old flag for 4.1 protocol  
2373                                                     'CLIENT_SECURE_CONNECTION' => 32768,   # New 4.1 authentication 
2374                                                     'CLIENT_MULTI_STATEMENTS'  => 65536,   # Enable/disable multi-stmt support 
2375                                                     'CLIENT_MULTI_RESULTS'     => 131072,  # Enable/disable multi-results 
2376                                                  );
2377                                                  
2378                                                  use constant {
2379           6                                173      MYSQL_TYPE_DECIMAL      => 0,
2380                                                     MYSQL_TYPE_TINY         => 1,
2381                                                     MYSQL_TYPE_SHORT        => 2,
2382                                                     MYSQL_TYPE_LONG         => 3,
2383                                                     MYSQL_TYPE_FLOAT        => 4,
2384                                                     MYSQL_TYPE_DOUBLE       => 5,
2385                                                     MYSQL_TYPE_NULL         => 6,
2386                                                     MYSQL_TYPE_TIMESTAMP    => 7,
2387                                                     MYSQL_TYPE_LONGLONG     => 8,
2388                                                     MYSQL_TYPE_INT24        => 9,
2389                                                     MYSQL_TYPE_DATE         => 10,
2390                                                     MYSQL_TYPE_TIME         => 11,
2391                                                     MYSQL_TYPE_DATETIME     => 12,
2392                                                     MYSQL_TYPE_YEAR         => 13,
2393                                                     MYSQL_TYPE_NEWDATE      => 14,
2394                                                     MYSQL_TYPE_VARCHAR      => 15,
2395                                                     MYSQL_TYPE_BIT          => 16,
2396                                                     MYSQL_TYPE_NEWDECIMAL   => 246,
2397                                                     MYSQL_TYPE_ENUM         => 247,
2398                                                     MYSQL_TYPE_SET          => 248,
2399                                                     MYSQL_TYPE_TINY_BLOB    => 249,
2400                                                     MYSQL_TYPE_MEDIUM_BLOB  => 250,
2401                                                     MYSQL_TYPE_LONG_BLOB    => 251,
2402                                                     MYSQL_TYPE_BLOB         => 252,
2403                                                     MYSQL_TYPE_VAR_STRING   => 253,
2404                                                     MYSQL_TYPE_STRING       => 254,
2405                                                     MYSQL_TYPE_GEOMETRY     => 255,
2406           6                    6            43   };
               6                                 14   
2407                                                  
2408                                                  my %type_for = (
2409                                                     0   => 'MYSQL_TYPE_DECIMAL',
2410                                                     1   => 'MYSQL_TYPE_TINY',
2411                                                     2   => 'MYSQL_TYPE_SHORT',
2412                                                     3   => 'MYSQL_TYPE_LONG',
2413                                                     4   => 'MYSQL_TYPE_FLOAT',
2414                                                     5   => 'MYSQL_TYPE_DOUBLE',
2415                                                     6   => 'MYSQL_TYPE_NULL',
2416                                                     7   => 'MYSQL_TYPE_TIMESTAMP',
2417                                                     8   => 'MYSQL_TYPE_LONGLONG',
2418                                                     9   => 'MYSQL_TYPE_INT24',
2419                                                     10  => 'MYSQL_TYPE_DATE',
2420                                                     11  => 'MYSQL_TYPE_TIME',
2421                                                     12  => 'MYSQL_TYPE_DATETIME',
2422                                                     13  => 'MYSQL_TYPE_YEAR',
2423                                                     14  => 'MYSQL_TYPE_NEWDATE',
2424                                                     15  => 'MYSQL_TYPE_VARCHAR',
2425                                                     16  => 'MYSQL_TYPE_BIT',
2426                                                     246 => 'MYSQL_TYPE_NEWDECIMAL',
2427                                                     247 => 'MYSQL_TYPE_ENUM',
2428                                                     248 => 'MYSQL_TYPE_SET',
2429                                                     249 => 'MYSQL_TYPE_TINY_BLOB',
2430                                                     250 => 'MYSQL_TYPE_MEDIUM_BLOB',
2431                                                     251 => 'MYSQL_TYPE_LONG_BLOB',
2432                                                     252 => 'MYSQL_TYPE_BLOB',
2433                                                     253 => 'MYSQL_TYPE_VAR_STRING',
2434                                                     254 => 'MYSQL_TYPE_STRING',
2435                                                     255 => 'MYSQL_TYPE_GEOMETRY',
2436                                                  );
2437                                                  
2438                                                  my %unpack_type = (
2439                                                     MYSQL_TYPE_NULL       => sub { return 'NULL', 0; },
2440                                                     MYSQL_TYPE_TINY       => sub { return to_num(@_, 1), 1; },
2441                                                     MySQL_TYPE_SHORT      => sub { return to_num(@_, 2), 2; },
2442                                                     MYSQL_TYPE_LONG       => sub { return to_num(@_, 4), 4; },
2443                                                     MYSQL_TYPE_LONGLONG   => sub { return to_num(@_, 8), 8; },
2444                                                     MYSQL_TYPE_DOUBLE     => sub { return to_double(@_), 8; },
2445                                                     MYSQL_TYPE_VARCHAR    => \&unpack_string,
2446                                                     MYSQL_TYPE_VAR_STRING => \&unpack_string,
2447                                                     MYSQL_TYPE_STRING     => \&unpack_string,
2448                                                  );
2449                                                  
2450                                                  sub new {
2451           3                    3            19      my ( $class, %args ) = @_;
2452                                                  
2453  ***      3     50                          18      my ( $server_port )
2454                                                        = $args{server} ? $args{server} =~ m/:(\w+)/ : ('3306|mysql');
2455  ***      3            50                   18      $server_port ||= '3306|mysql';  # In case $args{server} doesn't have a port.
2456                                                  
2457           3                                 28      my $self = {
2458                                                        server         => $args{server},
2459                                                        server_port    => $server_port,
2460                                                        version        => '41',    # MySQL proto version; not used yet
2461                                                        sessions       => {},
2462                                                        o              => $args{o},
2463                                                        fake_thread_id => 2**32,   # see _make_event()
2464                                                     };
2465           3                                  9      MKDEBUG && $self->{server} && _d('Watching only server', $self->{server});
2466           3                                 26      return bless $self, $class;
2467                                                  }
2468                                                  
2469                                                  sub parse_event {
2470          35                   35           190      my ( $self, %args ) = @_;
2471          35                                149      my @required_args = qw(event);
2472          35                                123      foreach my $arg ( @required_args ) {
2473  ***     35     50                         181         die "I need a $arg argument" unless $args{$arg};
2474                                                     }
2475          35                                128      my $packet = @args{@required_args};
2476                                                  
2477          35                                179      my $src_host = "$packet->{src_host}:$packet->{src_port}";
2478          35                                152      my $dst_host = "$packet->{dst_host}:$packet->{dst_port}";
2479                                                  
2480  ***     35     50                         174      if ( my $server = $self->{server} ) {  # Watch only the given server.
2481  ***      0      0      0                    0         if ( $src_host ne $server && $dst_host ne $server ) {
2482  ***      0                                  0            MKDEBUG && _d('Packet is not to or from', $server);
2483  ***      0                                  0            return;
2484                                                        }
2485                                                     }
2486                                                  
2487          35                                 83      my $packet_from;
2488          35                                 83      my $client;
2489          35    100                         435      if ( $src_host =~ m/:$self->{server_port}$/ ) {
      ***            50                               
2490          18                                 62         $packet_from = 'server';
2491          18                                 62         $client      = $dst_host;
2492                                                     }
2493                                                     elsif ( $dst_host =~ m/:$self->{server_port}$/ ) {
2494          17                                 50         $packet_from = 'client';
2495          17                                 52         $client      = $src_host;
2496                                                     }
2497                                                     else {
2498  ***      0                                  0         MKDEBUG && _d('Packet is not to or from a MySQL server');
2499  ***      0                                  0         return;
2500                                                     }
2501          35                                 79      MKDEBUG && _d('Client', $client);
2502                                                  
2503          35                                 98      my $packetno = -1;
2504          35    100                         164      if ( $packet->{data_len} >= 5 ) {
2505          19                                126         $packetno = to_num(substr($packet->{data}, 6, 2));
2506                                                     }
2507          35    100                         194      if ( !exists $self->{sessions}->{$client} ) {
2508           9    100                          49         if ( $packet->{syn} ) {
                    100                               
2509           2                                  6            MKDEBUG && _d('New session (SYN)');
2510                                                        }
2511                                                        elsif ( $packetno == 0 ) {
2512           1                                  3            MKDEBUG && _d('New session (packetno 0)');
2513                                                        }
2514                                                        else {
2515           6                                 14            MKDEBUG && _d('Ignoring mid-stream', $packet_from, 'data,',
2516                                                              'packetno', $packetno);
2517           6                                 33            return;
2518                                                        }
2519                                                  
2520           3                                 57         $self->{sessions}->{$client} = {
2521                                                           client        => $client,
2522                                                           ts            => $packet->{ts},
2523                                                           state         => undef,
2524                                                           compress      => undef,
2525                                                           raw_packets   => [],
2526                                                           buff          => '',
2527                                                           sths          => {},
2528                                                           attribs       => {},
2529                                                           n_queries     => 0,
2530                                                        };
2531                                                     }
2532          29                                109      my $session = $self->{sessions}->{$client};
2533          29                                 71      MKDEBUG && _d('Client state:', $session->{state});
2534                                                  
2535          29                                 70      push @{$session->{raw_packets}}, $packet->{raw_packet};
              29                                197   
2536                                                  
2537  ***     29     50     33                  211      if ( $packet->{syn} && ($session->{n_queries} > 0 || $session->{state}) ) {
      ***                   66                        
2538  ***      0                                  0         MKDEBUG && _d('Client port reuse and last session did not quit');
2539  ***      0                                  0         $self->fail_session($session,
2540                                                              'client port reuse and last session did not quit');
2541  ***      0                                  0         return $self->parse_event(%args);
2542                                                     }
2543                                                  
2544          29    100                         135      if ( $packet->{data_len} == 0 ) {
2545                                                        MKDEBUG && _d('TCP control:',
2546          10                                 23            map { uc $_ } grep { $packet->{$_} } qw(syn ack fin rst));
2547          10                                 54         return;
2548                                                     }
2549                                                  
2550  ***     19     50                          92      if ( $session->{compress} ) {
2551  ***      0      0                           0         return unless $self->uncompress_packet($packet, $session);
2552                                                     }
2553                                                  
2554  ***     19     50     33                  106      if ( $session->{buff} && $packet_from eq 'client' ) {
2555  ***      0                                  0         $session->{buff}      .= $packet->{data};
2556  ***      0                                  0         $packet->{data}        = $session->{buff};
2557  ***      0                                  0         $session->{buff_left} -= $packet->{data_len};
2558                                                  
2559  ***      0                                  0         $packet->{mysql_data_len} = $session->{mysql_data_len};
2560  ***      0                                  0         $packet->{number}         = $session->{number};
2561                                                  
2562  ***      0                                  0         MKDEBUG && _d('Appending data to buff; expecting',
2563                                                           $session->{buff_left}, 'more bytes');
2564                                                     }
2565                                                     else { 
2566          19                                 55         eval {
2567          19                                 95            remove_mysql_header($packet);
2568                                                        };
2569  ***     19     50                          79         if ( $EVAL_ERROR ) {
2570  ***      0                                  0            MKDEBUG && _d('remove_mysql_header() failed; failing session');
2571  ***      0                                  0            $session->{EVAL_ERROR} = $EVAL_ERROR;
2572  ***      0                                  0            $self->fail_session($session, 'remove_mysql_header() failed');
2573  ***      0                                  0            return;
2574                                                        }
2575                                                     }
2576                                                  
2577          19                                 52      my $event;
2578          19    100                          99      if ( $packet_from eq 'server' ) {
      ***            50                               
2579          10                                 64         $event = $self->_packet_from_server($packet, $session, $args{misc});
2580                                                     }
2581                                                     elsif ( $packet_from eq 'client' ) {
2582  ***      9     50                         145         if ( $session->{buff} ) {
      ***            50                               
2583  ***      0      0                           0            if ( $session->{buff_left} <= 0 ) {
2584  ***      0                                  0               MKDEBUG && _d('Data is complete');
2585  ***      0                                  0               $self->_delete_buff($session);
2586                                                           }
2587                                                           else {
2588  ***      0                                  0               return;  # waiting for more data; buff_left was reported earlier
2589                                                           }
2590                                                        }
2591                                                        elsif ( $packet->{mysql_data_len} > ($packet->{data_len} - 4) ) {
2592                                                  
2593  ***      0      0      0                    0            if ( $session->{cmd} && ($session->{state} || '') eq 'awaiting_reply' ) {
      ***                    0                        
2594  ***      0                                  0               MKDEBUG && _d('No server OK to previous command (frag)');
2595  ***      0                                  0               $self->fail_session($session, 'no server OK to previous command');
2596  ***      0                                  0               $packet->{data} = $packet->{mysql_hdr} . $packet->{data};
2597  ***      0                                  0               return $self->parse_event(%args);
2598                                                           }
2599                                                  
2600  ***      0                                  0            $session->{buff}           = $packet->{data};
2601  ***      0                                  0            $session->{mysql_data_len} = $packet->{mysql_data_len};
2602  ***      0                                  0            $session->{number}         = $packet->{number};
2603                                                  
2604  ***      0             0                    0            $session->{buff_left}
2605                                                              ||= $packet->{mysql_data_len} - ($packet->{data_len} - 4);
2606                                                  
2607  ***      0                                  0            MKDEBUG && _d('Data not complete; expecting',
2608                                                              $session->{buff_left}, 'more bytes');
2609  ***      0                                  0            return;
2610                                                        }
2611                                                  
2612  ***      9     50      0                   57         if ( $session->{cmd} && ($session->{state} || '') eq 'awaiting_reply' ) {
      ***                   33                        
2613  ***      0                                  0            MKDEBUG && _d('No server OK to previous command');
2614  ***      0                                  0            $self->fail_session($session, 'no server OK to previous command');
2615  ***      0                                  0            $packet->{data} = $packet->{mysql_hdr} . $packet->{data};
2616  ***      0                                  0            return $self->parse_event(%args);
2617                                                        }
2618                                                  
2619           9                                 67         $event = $self->_packet_from_client($packet, $session, $args{misc});
2620                                                     }
2621                                                     else {
2622  ***      0                                  0         die 'Packet origin unknown';
2623                                                     }
2624                                                  
2625          19                                 59      MKDEBUG && _d('Done parsing packet; client state:', $session->{state});
2626          19    100                          88      if ( $session->{closed} ) {
2627           2                                 10         delete $self->{sessions}->{$session->{client}};
2628           2                                  6         MKDEBUG && _d('Session deleted');
2629                                                     }
2630                                                  
2631          19                                144      return $event;
2632                                                  }
2633                                                  
2634                                                  sub _packet_from_server {
2635          10                   10            82      my ( $self, $packet, $session, $misc ) = @_;
2636  ***     10     50                          53      die "I need a packet"  unless $packet;
2637  ***     10     50                          37      die "I need a session" unless $session;
2638                                                  
2639          10                                 23      MKDEBUG && _d('Packet is from server; client state:', $session->{state}); 
2640                                                  
2641  ***     10     50    100                  105      if ( ($session->{server_seq} || '') eq $packet->{seq} ) {
2642  ***      0                                  0         push @{ $session->{server_retransmissions} }, $packet->{seq};
      ***      0                                  0   
2643  ***      0                                  0         MKDEBUG && _d('TCP retransmission');
2644  ***      0                                  0         return;
2645                                                     }
2646          10                                 47      $session->{server_seq} = $packet->{seq};
2647                                                  
2648          10                                 43      my $data = $packet->{data};
2649                                                  
2650                                                  
2651          10                                 44      my ( $first_byte ) = substr($data, 0, 2, '');
2652          10                                 25      MKDEBUG && _d('First byte of packet:', $first_byte);
2653  ***     10     50                          44      if ( !$first_byte ) {
2654  ***      0                                  0         $self->fail_session($session, 'no first byte');
2655  ***      0                                  0         return;
2656                                                     }
2657                                                  
2658          10    100                          43      if ( !$session->{state} ) {
2659  ***      2     50     33                   32         if ( $first_byte eq '0a' && length $data >= 33 && $data =~ m/00{13}/ ) {
      ***             0     33                        
2660           2                                 13            my $handshake = parse_server_handshake_packet($data);
2661  ***      2     50                           9            if ( !$handshake ) {
2662  ***      0                                  0               $self->fail_session($session, 'failed to parse server handshake');
2663  ***      0                                  0               return;
2664                                                           }
2665           2                                 12            $session->{state}     = 'server_handshake';
2666           2                                  8            $session->{thread_id} = $handshake->{thread_id};
2667                                                  
2668  ***      2     50                          17            $session->{ts} = $packet->{ts} unless $session->{ts};
2669                                                        }
2670                                                        elsif ( $session->{buff} ) {
2671  ***      0                                  0            $self->fail_session($session,
2672                                                              'got server response before full buffer');
2673  ***      0                                  0            return;
2674                                                        }
2675                                                        else {
2676  ***      0                                  0            MKDEBUG && _d('Ignoring mid-stream server response');
2677  ***      0                                  0            return;
2678                                                        }
2679                                                     }
2680                                                     else {
2681  ***      8    100     33                   79         if ( $first_byte eq '00' ) { 
                    100                               
      ***            50                               
2682  ***      1     50     50                   12            if ( ($session->{state} || '') eq 'client_auth' ) {
      ***             0                               
2683                                                  
2684           1                                  4               $session->{compress} = $session->{will_compress};
2685           1                                  8               delete $session->{will_compress};
2686           1                                  2               MKDEBUG && $session->{compress} && _d('Packets will be compressed');
2687                                                  
2688           1                                  2               MKDEBUG && _d('Admin command: Connect');
2689           1                                 13               return $self->_make_event(
2690                                                                 {  cmd => 'Admin',
2691                                                                    arg => 'administrator command: Connect',
2692                                                                    ts  => $packet->{ts}, # Events are timestamped when they end
2693                                                                 },
2694                                                                 $packet, $session
2695                                                              );
2696                                                           }
2697                                                           elsif ( $session->{cmd} ) {
2698  ***      0                                  0               my $com = $session->{cmd}->{cmd};
2699  ***      0                                  0               my $ok;
2700  ***      0      0                           0               if ( $com eq COM_STMT_PREPARE ) {
2701  ***      0                                  0                  MKDEBUG && _d('OK for prepared statement');
2702  ***      0                                  0                  $ok = parse_ok_prepared_statement_packet($data);
2703  ***      0      0                           0                  if ( !$ok ) {
2704  ***      0                                  0                     $self->fail_session($session,
2705                                                                       'failed to parse OK prepared statement packet');
2706  ***      0                                  0                     return;
2707                                                                 }
2708  ***      0                                  0                  my $sth_id = $ok->{sth_id};
2709  ***      0                                  0                  $session->{attribs}->{Statement_id} = $sth_id;
2710                                                  
2711  ***      0                                  0                  $session->{sths}->{$sth_id} = $ok;
2712  ***      0                                  0                  $session->{sths}->{$sth_id}->{statement}
2713                                                                    = $session->{cmd}->{arg};
2714                                                              }
2715                                                              else {
2716  ***      0                                  0                  $ok  = parse_ok_packet($data);
2717  ***      0      0                           0                  if ( !$ok ) {
2718  ***      0                                  0                     $self->fail_session($session, 'failed to parse OK packet');
2719  ***      0                                  0                     return;
2720                                                                 }
2721                                                              }
2722                                                  
2723  ***      0                                  0               my $arg;
2724  ***      0      0      0                    0               if ( $com eq COM_QUERY
      ***             0      0                        
2725                                                                   || $com eq COM_STMT_EXECUTE || $com eq COM_STMT_RESET ) {
2726  ***      0                                  0                  $com = 'Query';
2727  ***      0                                  0                  $arg = $session->{cmd}->{arg};
2728                                                              }
2729                                                              elsif ( $com eq COM_STMT_PREPARE ) {
2730  ***      0                                  0                  $com = 'Query';
2731  ***      0                                  0                  $arg = "PREPARE $session->{cmd}->{arg}";
2732                                                              }
2733                                                              else {
2734  ***      0                                  0                  $arg = 'administrator command: '
2735                                                                      . ucfirst(lc(substr($com_for{$com}, 4)));
2736  ***      0                                  0                  $com = 'Admin';
2737                                                              }
2738                                                  
2739  ***      0                                  0               return $self->_make_event(
2740                                                                 {  cmd           => $com,
2741                                                                    arg           => $arg,
2742                                                                    ts            => $packet->{ts},
2743                                                                    Insert_id     => $ok->{insert_id},
2744                                                                    Warning_count => $ok->{warnings},
2745                                                                    Rows_affected => $ok->{affected_rows},
2746                                                                 },
2747                                                                 $packet, $session
2748                                                              );
2749                                                           } 
2750                                                           else {
2751  ***      0                                  0               MKDEBUG && _d('Looks like an OK packet but session has no cmd');
2752                                                           }
2753                                                        }
2754                                                        elsif ( $first_byte eq 'ff' ) {
2755           1                                  5            my $error = parse_error_packet($data);
2756  ***      1     50                           5            if ( !$error ) {
2757  ***      0                                  0               $self->fail_session($session, 'failed to parse error packet');
2758  ***      0                                  0               return;
2759                                                           }
2760           1                                  2            my $event;
2761                                                  
2762  ***      1     50                           5            if ( $session->{state} eq 'client_auth' ) {
      ***             0                               
2763           1                                  3               MKDEBUG && _d('Connection failed');
2764           1                                  7               $event = {
2765                                                                 cmd       => 'Admin',
2766                                                                 arg       => 'administrator command: Connect',
2767                                                                 ts        => $packet->{ts},
2768                                                                 Error_no  => $error->{errno},
2769                                                              };
2770           1                                  4               $session->{closed} = 1;  # delete session when done
2771           1                                  6               return $self->_make_event($event, $packet, $session);
2772                                                           }
2773                                                           elsif ( $session->{cmd} ) {
2774  ***      0                                  0               my $com = $session->{cmd}->{cmd};
2775  ***      0                                  0               my $arg;
2776                                                  
2777  ***      0      0      0                    0               if ( $com eq COM_QUERY || $com eq COM_STMT_EXECUTE ) {
2778  ***      0                                  0                  $com = 'Query';
2779  ***      0                                  0                  $arg = $session->{cmd}->{arg};
2780                                                              }
2781                                                              else {
2782  ***      0                                  0                  $arg = 'administrator command: '
2783                                                                      . ucfirst(lc(substr($com_for{$com}, 4)));
2784  ***      0                                  0                  $com = 'Admin';
2785                                                              }
2786                                                  
2787  ***      0      0                           0               $event = {
2788                                                                 cmd       => $com,
2789                                                                 arg       => $arg,
2790                                                                 ts        => $packet->{ts},
2791                                                                 Error_no  => $error->{errno} ? "#$error->{errno}" : 'none',
2792                                                              };
2793  ***      0                                  0               return $self->_make_event($event, $packet, $session);
2794                                                           }
2795                                                           else {
2796  ***      0                                  0               MKDEBUG && _d('Looks like an error packet but client is not '
2797                                                                 . 'authenticating and session has no cmd');
2798                                                           }
2799                                                        }
2800                                                        elsif ( $first_byte eq 'fe' && $packet->{mysql_data_len} < 9 ) {
2801  ***      0      0      0                    0            if ( $packet->{mysql_data_len} == 1
      ***                    0                        
2802                                                                && $session->{state} eq 'client_auth'
2803                                                                && $packet->{number} == 2 )
2804                                                           {
2805  ***      0                                  0               MKDEBUG && _d('Server has old password table;',
2806                                                                 'client will resend password using old algorithm');
2807  ***      0                                  0               $session->{state} = 'client_auth_resend';
2808                                                           }
2809                                                           else {
2810  ***      0                                  0               MKDEBUG && _d('Got an EOF packet');
2811  ***      0                                  0               $self->fail_session($session, 'got an unexpected EOF packet');
2812                                                           }
2813                                                        }
2814                                                        else {
2815  ***      6     50                          30            if ( $session->{cmd} ) {
2816           6                                 17               MKDEBUG && _d('Got a row/field/result packet');
2817           6                                 26               my $com = $session->{cmd}->{cmd};
2818           6                                 15               MKDEBUG && _d('Responding to client', $com_for{$com});
2819           6                                 30               my $event = { ts  => $packet->{ts} };
2820  ***      6     50     33                   36               if ( $com eq COM_QUERY || $com eq COM_STMT_EXECUTE ) {
2821           6                                 20                  $event->{cmd} = 'Query';
2822           6                                 33                  $event->{arg} = $session->{cmd}->{arg};
2823                                                              }
2824                                                              else {
2825  ***      0                                  0                  $event->{arg} = 'administrator command: '
2826                                                                      . ucfirst(lc(substr($com_for{$com}, 4)));
2827  ***      0                                  0                  $event->{cmd} = 'Admin';
2828                                                              }
2829                                                  
2830  ***      6     50                          31               if ( $packet->{complete} ) {
2831           6                                 67                  my ( $warning_count, $status_flags )
2832                                                                    = $data =~ m/fe(.{4})(.{4})\Z/;
2833  ***      6     50                          30                  if ( $warning_count ) { 
2834           6                                 24                     $event->{Warnings} = to_num($warning_count);
2835           6                                 25                     my $flags = to_num($status_flags); # TODO set all flags?
2836  ***      6     50                          45                     $event->{No_good_index_used}
2837                                                                       = $flags & SERVER_QUERY_NO_GOOD_INDEX_USED ? 1 : 0;
2838  ***      6     50                          37                     $event->{No_index_used}
2839                                                                       = $flags & SERVER_QUERY_NO_INDEX_USED ? 1 : 0;
2840                                                                 }
2841                                                              }
2842                                                  
2843           6                                 40               return $self->_make_event($event, $packet, $session);
2844                                                           }
2845                                                           else {
2846  ***      0                                  0               MKDEBUG && _d('Unknown in-stream server response');
2847                                                           }
2848                                                        }
2849                                                     }
2850                                                  
2851           2                                  9      return;
2852                                                  }
2853                                                  
2854                                                  sub _packet_from_client {
2855           9                    9            58      my ( $self, $packet, $session, $misc ) = @_;
2856  ***      9     50                          41      die "I need a packet"  unless $packet;
2857  ***      9     50                          34      die "I need a session" unless $session;
2858                                                  
2859           9                                 25      MKDEBUG && _d('Packet is from client; state:', $session->{state}); 
2860                                                  
2861  ***      9     50    100                   92      if ( ($session->{client_seq} || '') eq $packet->{seq} ) {
2862  ***      0                                  0         push @{ $session->{client_retransmissions} }, $packet->{seq};
      ***      0                                  0   
2863  ***      0                                  0         MKDEBUG && _d('TCP retransmission');
2864  ***      0                                  0         return;
2865                                                     }
2866           9                                 42      $session->{client_seq} = $packet->{seq};
2867                                                  
2868           9                                 40      my $data  = $packet->{data};
2869           9                                 31      my $ts    = $packet->{ts};
2870                                                  
2871           9    100    100                  196      if ( ($session->{state} || '') eq 'server_handshake' ) {
      ***            50     50                        
      ***            50     50                        
2872           2                                  5         MKDEBUG && _d('Expecting client authentication packet');
2873           2                                 10         my $handshake = parse_client_handshake_packet($data);
2874  ***      2     50                          14         if ( !$handshake ) {
2875  ***      0                                  0            $self->fail_session($session, 'failed to parse client handshake');
2876  ***      0                                  0            return;
2877                                                        }
2878           2                                  7         $session->{state}         = 'client_auth';
2879           2                                  9         $session->{pos_in_log}    = $packet->{pos_in_log};
2880           2                                  9         $session->{user}          = $handshake->{user};
2881           2                                  9         $session->{db}            = $handshake->{db};
2882                                                  
2883           2                                 17         $session->{will_compress} = $handshake->{flags}->{CLIENT_COMPRESS};
2884                                                     }
2885                                                     elsif ( ($session->{state} || '') eq 'client_auth_resend' ) {
2886  ***      0                                  0         MKDEBUG && _d('Client resending password using old algorithm');
2887  ***      0                                  0         $session->{state} = 'client_auth';
2888                                                     }
2889                                                     elsif ( ($session->{state} || '') eq 'awaiting_reply' ) {
2890  ***      0      0                           0         my $arg = $session->{cmd}->{arg} ? substr($session->{cmd}->{arg}, 0, 50)
2891                                                                : 'unknown';
2892  ***      0                                  0         MKDEBUG && _d('More data for previous command:', $arg, '...'); 
2893  ***      0                                  0         return;
2894                                                     }
2895                                                     else {
2896  ***      7     50                          56         if ( $packet->{number} != 0 ) {
2897  ***      0                                  0            $self->fail_session($session, 'client cmd not packet 0');
2898  ***      0                                  0            return;
2899                                                        }
2900                                                  
2901           7    100                          36         if ( !defined $session->{compress} ) {
2902  ***      1     50                          11            return unless $self->detect_compression($packet, $session);
2903           1                                  8            $data = $packet->{data};
2904                                                        }
2905                                                  
2906           7                                 41         my $com = parse_com_packet($data, $packet->{mysql_data_len});
2907  ***      7     50                          35         if ( !$com ) {
2908  ***      0                                  0            $self->fail_session($session, 'failed to parse COM packet');
2909  ***      0                                  0            return;
2910                                                        }
2911                                                  
2912  ***      7     50                          54         if ( $com->{code} eq COM_STMT_EXECUTE ) {
      ***            50                               
2913  ***      0                                  0            MKDEBUG && _d('Execute prepared statement');
2914  ***      0                                  0            my $exec = parse_execute_packet($com->{data}, $session->{sths});
2915  ***      0      0                           0            if ( !$exec ) {
2916  ***      0                                  0               MKDEBUG && _d('Failed to parse execute packet');
2917  ***      0                                  0               $session->{state} = undef;
2918  ***      0                                  0               return;
2919                                                           }
2920  ***      0                                  0            $com->{data} = $exec->{arg};
2921  ***      0                                  0            $session->{attribs}->{Statement_id} = $exec->{sth_id};
2922                                                        }
2923                                                        elsif ( $com->{code} eq COM_STMT_RESET ) {
2924  ***      0                                  0            my $sth_id = get_sth_id($com->{data});
2925  ***      0      0                           0            if ( !$sth_id ) {
2926  ***      0                                  0               $self->fail_session($session,
2927                                                                 'failed to parse prepared statement reset packet');
2928  ***      0                                  0               return;
2929                                                           }
2930  ***      0                                  0            $com->{data} = "RESET $sth_id";
2931  ***      0                                  0            $session->{attribs}->{Statement_id} = $sth_id;
2932                                                        }
2933                                                  
2934           7                                 26         $session->{state}      = 'awaiting_reply';
2935           7                                 31         $session->{pos_in_log} = $packet->{pos_in_log};
2936           7                                 27         $session->{ts}         = $ts;
2937           7                                 52         $session->{cmd}        = {
2938                                                           cmd => $com->{code},
2939                                                           arg => $com->{data},
2940                                                        };
2941                                                  
2942           7    100                          60         if ( $com->{code} eq COM_QUIT ) { # Fire right away; will cleanup later.
      ***            50                               
2943           1                                  3            MKDEBUG && _d('Got a COM_QUIT');
2944                                                  
2945           1                                  5            $session->{closed} = 1;  # delete session when done
2946                                                  
2947           1                                  9            return $self->_make_event(
2948                                                              {  cmd       => 'Admin',
2949                                                                 arg       => 'administrator command: Quit',
2950                                                                 ts        => $ts,
2951                                                              },
2952                                                              $packet, $session
2953                                                           );
2954                                                        }
2955                                                        elsif ( $com->{code} eq COM_STMT_CLOSE ) {
2956  ***      0                                  0            my $sth_id = get_sth_id($com->{data});
2957  ***      0      0                           0            if ( !$sth_id ) {
2958  ***      0                                  0               $self->fail_session($session,
2959                                                                 'failed to parse prepared statement close packet');
2960  ***      0                                  0               return;
2961                                                           }
2962  ***      0                                  0            delete $session->{sths}->{$sth_id};
2963  ***      0                                  0            return $self->_make_event(
2964                                                              {  cmd       => 'Query',
2965                                                                 arg       => "DEALLOCATE PREPARE $sth_id",
2966                                                                 ts        => $ts,
2967                                                              },
2968                                                              $packet, $session
2969                                                           );
2970                                                        }
2971                                                     }
2972                                                  
2973           8                                 58      return;
2974                                                  }
2975                                                  
2976                                                  sub _make_event {
2977           9                    9           589      my ( $self, $event, $packet, $session ) = @_;
2978           9                                 23      MKDEBUG && _d('Making event');
2979                                                  
2980           9                                 41      $session->{raw_packets}  = [];
2981           9                                 67      $self->_delete_buff($session);
2982                                                  
2983           9    100                          49      if ( !$session->{thread_id} ) {
2984           1                                  4         MKDEBUG && _d('Giving session fake thread id', $self->{fake_thread_id});
2985           1                                  7         $session->{thread_id} = $self->{fake_thread_id}++;
2986                                                     }
2987                                                  
2988           9                               3624      my ($host, $port) = $session->{client} =~ m/((?:\d+\.){3}\d+)\:(\w+)/;
2989  ***      9     50    100                   86      my $new_event = {
      ***            50     50                        
      ***                   50                        
2990                                                        cmd        => $event->{cmd},
2991                                                        arg        => $event->{arg},
2992                                                        bytes      => length( $event->{arg} ),
2993                                                        ts         => tcp_timestamp( $event->{ts} ),
2994                                                        host       => $host,
2995                                                        ip         => $host,
2996                                                        port       => $port,
2997                                                        db         => $session->{db},
2998                                                        user       => $session->{user},
2999                                                        Thread_id  => $session->{thread_id},
3000                                                        pos_in_log => $session->{pos_in_log},
3001                                                        Query_time => timestamp_diff($session->{ts}, $packet->{ts}),
3002                                                        Error_no   => $event->{Error_no} || 'none',
3003                                                        Rows_affected      => ($event->{Rows_affected} || 0),
3004                                                        Warning_count      => ($event->{Warning_count} || 0),
3005                                                        No_good_index_used => ($event->{No_good_index_used} ? 'Yes' : 'No'),
3006                                                        No_index_used      => ($event->{No_index_used}      ? 'Yes' : 'No'),
3007                                                     };
3008           9                                 33      @{$new_event}{keys %{$session->{attribs}}} = values %{$session->{attribs}};
               9                                 31   
               9                                 39   
               9                                 49   
3009           9                                 24      MKDEBUG && _d('Properties of event:', Dumper($new_event));
3010                                                  
3011           9                                 41      delete $session->{cmd};
3012                                                  
3013           9                                 35      $session->{state} = undef;
3014                                                  
3015           9                                 34      $session->{attribs} = {};
3016                                                  
3017           9                                 34      $session->{n_queries}++;
3018           9                                 38      $session->{server_retransmissions} = [];
3019           9                                 37      $session->{client_retransmissions} = [];
3020                                                  
3021           9                                 66      return $new_event;
3022                                                  }
3023                                                  
3024                                                  sub tcp_timestamp {
3025           9                    9            50      my ( $ts ) = @_;
3026           9                                156      $ts =~ s/^\d\d(\d\d)-(\d\d)-(\d\d)/$1$2$3/;
3027           9                                120      return $ts;
3028                                                  }
3029                                                  
3030                                                  sub timestamp_diff {
3031           9                    9            43      my ( $start, $end ) = @_;
3032           9                                 48      my $sd = substr($start, 0, 11, '');
3033           9                                 32      my $ed = substr($end,   0, 11, '');
3034           9                                 72      my ( $sh, $sm, $ss ) = split(/:/, $start);
3035           9                                 49      my ( $eh, $em, $es ) = split(/:/, $end);
3036           9                                 72      my $esecs = ($eh * 3600 + $em * 60 + $es);
3037           9                                 39      my $ssecs = ($sh * 3600 + $sm * 60 + $ss);
3038  ***      9     50                          50      if ( $sd eq $ed ) {
3039           9                                512         return sprintf '%.6f', $esecs - $ssecs;
3040                                                     }
3041                                                     else { # Assume only one day boundary has been crossed, no DST, etc
3042  ***      0                                  0         return sprintf '%.6f', ( 86_400 - $ssecs ) + $esecs;
3043                                                     }
3044                                                  }
3045                                                  
3046                                                  sub to_string {
3047          16                   16            78      my ( $data ) = @_;
3048          16                                130      return pack('H*', $data);
3049                                                  }
3050                                                  
3051                                                  sub unpack_string {
3052  ***      0                    0             0      my ( $data ) = @_;
3053  ***      0                                  0      my $len        = 0;
3054  ***      0                                  0      my $encode_len = 0;
3055  ***      0                                  0      ($data, $len, $encode_len) = decode_len($data);
3056  ***      0      0                           0      my $t = 'H' . ($len ? $len * 2 : '*');
3057  ***      0                                  0      $data = pack($t, $data);
3058  ***      0                                  0      return "\"$data\"", $encode_len + $len;
3059                                                  }
3060                                                  
3061                                                  sub decode_len {
3062  ***      0                    0             0      my ( $data ) = @_;
3063  ***      0      0                           0      return unless $data;
3064                                                  
3065  ***      0                                  0      my $first_byte = to_num(substr($data, 0, 2, ''));
3066                                                  
3067  ***      0                                  0      my $len;
3068  ***      0                                  0      my $encode_len;
3069  ***      0      0                           0      if ( $first_byte <= 251 ) {
      ***             0                               
      ***             0                               
      ***             0                               
3070  ***      0                                  0         $len        = $first_byte;
3071  ***      0                                  0         $encode_len = 1;
3072                                                     }
3073                                                     elsif ( $first_byte == 252 ) {
3074  ***      0                                  0         $len        = to_num(substr($data, 4, ''));
3075  ***      0                                  0         $encode_len = 2;
3076                                                     }
3077                                                     elsif ( $first_byte == 253 ) {
3078  ***      0                                  0         $len        = to_num(substr($data, 6, ''));
3079  ***      0                                  0         $encode_len = 3;
3080                                                     }
3081                                                     elsif ( $first_byte == 254 ) {
3082  ***      0                                  0         $len        = to_num(substr($data, 16, ''));
3083  ***      0                                  0         $encode_len = 8;
3084                                                     }
3085                                                     else {
3086  ***      0                                  0         MKDEBUG && _d('data:', $data, 'first byte:', $first_byte);
3087  ***      0                                  0         die "Invalid length encoded byte: $first_byte";
3088                                                     }
3089                                                  
3090  ***      0                                  0      MKDEBUG && _d('len:', $len, 'encode len', $encode_len);
3091  ***      0                                  0      return $data, $len, $encode_len;
3092                                                  }
3093                                                  
3094                                                  sub to_num {
3095          76                   76           321      my ( $str, $len ) = @_;
3096  ***     76     50                         290      if ( $len ) {
3097  ***      0                                  0         $str = substr($str, 0, $len * 2);
3098                                                     }
3099          76                                424      my @bytes = $str =~ m/(..)/g;
3100          76                                222      my $result = 0;
3101          76                                375      foreach my $i ( 0 .. $#bytes ) {
3102         141                                720         $result += hex($bytes[$i]) * (16 ** ($i * 2));
3103                                                     }
3104          76                                366      return $result;
3105                                                  }
3106                                                  
3107                                                  sub to_double {
3108  ***      0                    0             0      my ( $str ) = @_;
3109  ***      0                                  0      return unpack('d', pack('H*', $str));
3110                                                  }
3111                                                  
3112                                                  sub get_lcb {
3113  ***      0                    0             0      my ( $string ) = @_;
3114  ***      0                                  0      my $first_byte = hex(substr($$string, 0, 2, ''));
3115  ***      0      0                           0      if ( $first_byte < 251 ) {
      ***             0                               
      ***             0                               
      ***             0                               
3116  ***      0                                  0         return $first_byte;
3117                                                     }
3118                                                     elsif ( $first_byte == 252 ) {
3119  ***      0                                  0         return to_num(substr($$string, 0, 4, ''));
3120                                                     }
3121                                                     elsif ( $first_byte == 253 ) {
3122  ***      0                                  0         return to_num(substr($$string, 0, 6, ''));
3123                                                     }
3124                                                     elsif ( $first_byte == 254 ) {
3125  ***      0                                  0         return to_num(substr($$string, 0, 16, ''));
3126                                                     }
3127                                                  }
3128                                                  
3129                                                  sub parse_error_packet {
3130           1                    1             4      my ( $data ) = @_;
3131  ***      1     50                           5      return unless $data;
3132           1                                  3      MKDEBUG && _d('ERROR data:', $data);
3133  ***      1     50                          13      if ( length $data < 16 ) {
3134  ***      0                                  0         MKDEBUG && _d('Error packet is too short:', $data);
3135  ***      0                                  0         return;
3136                                                     }
3137           1                                  5      my $errno    = to_num(substr($data, 0, 4));
3138           1                                  6      my $marker   = to_string(substr($data, 4, 2));
3139  ***      1     50                           5      return unless $marker eq '#';
3140           1                                  5      my $sqlstate = to_string(substr($data, 6, 10));
3141           1                                  5      my $message  = to_string(substr($data, 16));
3142           1                                  7      my $pkt = {
3143                                                        errno    => $errno,
3144                                                        sqlstate => $marker . $sqlstate,
3145                                                        message  => $message,
3146                                                     };
3147           1                                  3      MKDEBUG && _d('Error packet:', Dumper($pkt));
3148           1                                  3      return $pkt;
3149                                                  }
3150                                                  
3151                                                  sub parse_ok_packet {
3152  ***      0                    0             0      my ( $data ) = @_;
3153  ***      0      0                           0      return unless $data;
3154  ***      0                                  0      MKDEBUG && _d('OK data:', $data);
3155  ***      0      0                           0      if ( length $data < 12 ) {
3156  ***      0                                  0         MKDEBUG && _d('OK packet is too short:', $data);
3157  ***      0                                  0         return;
3158                                                     }
3159  ***      0                                  0      my $affected_rows = get_lcb(\$data);
3160  ***      0                                  0      my $insert_id     = get_lcb(\$data);
3161  ***      0                                  0      my $status        = to_num(substr($data, 0, 4, ''));
3162  ***      0                                  0      my $warnings      = to_num(substr($data, 0, 4, ''));
3163  ***      0                                  0      my $message       = to_string($data);
3164  ***      0                                  0      my $pkt = {
3165                                                        affected_rows => $affected_rows,
3166                                                        insert_id     => $insert_id,
3167                                                        status        => $status,
3168                                                        warnings      => $warnings,
3169                                                        message       => $message,
3170                                                     };
3171  ***      0                                  0      MKDEBUG && _d('OK packet:', Dumper($pkt));
3172  ***      0                                  0      return $pkt;
3173                                                  }
3174                                                  
3175                                                  sub parse_ok_prepared_statement_packet {
3176  ***      0                    0             0      my ( $data ) = @_;
3177  ***      0      0                           0      return unless $data;
3178  ***      0                                  0      MKDEBUG && _d('OK prepared statement data:', $data);
3179  ***      0      0                           0      if ( length $data < 8 ) {
3180  ***      0                                  0         MKDEBUG && _d('OK prepared statement packet is too short:', $data);
3181  ***      0                                  0         return;
3182                                                     }
3183  ***      0                                  0      my $sth_id     = to_num(substr($data, 0, 8, ''));
3184  ***      0                                  0      my $num_cols   = to_num(substr($data, 0, 4, ''));
3185  ***      0                                  0      my $num_params = to_num(substr($data, 0, 4, ''));
3186  ***      0                                  0      my $pkt = {
3187                                                        sth_id     => $sth_id,
3188                                                        num_cols   => $num_cols,
3189                                                        num_params => $num_params,
3190                                                     };
3191  ***      0                                  0      MKDEBUG && _d('OK prepared packet:', Dumper($pkt));
3192  ***      0                                  0      return $pkt;
3193                                                  }
3194                                                  
3195                                                  sub parse_server_handshake_packet {
3196           2                    2             9      my ( $data ) = @_;
3197  ***      2     50                           8      return unless $data;
3198           2                                  9      MKDEBUG && _d('Server handshake data:', $data);
3199           2                                 15      my $handshake_pattern = qr{
3200                                                        ^                 # -----                ----
3201                                                        (.+?)00           # n Null-Term String   server_version
3202                                                        (.{8})            # 4                    thread_id
3203                                                        .{16}             # 8                    scramble_buff
3204                                                        .{2}              # 1                    filler: always 0x00
3205                                                        (.{4})            # 2                    server_capabilities
3206                                                        .{2}              # 1                    server_language
3207                                                        .{4}              # 2                    server_status
3208                                                        .{26}             # 13                   filler: always 0x00
3209                                                     }x;
3210           2                                 26      my ( $server_version, $thread_id, $flags ) = $data =~ m/$handshake_pattern/;
3211           2                                 15      my $pkt = {
3212                                                        server_version => to_string($server_version),
3213                                                        thread_id      => to_num($thread_id),
3214                                                        flags          => parse_flags($flags),
3215                                                     };
3216           2                                  5      MKDEBUG && _d('Server handshake packet:', Dumper($pkt));
3217           2                                 12      return $pkt;
3218                                                  }
3219                                                  
3220                                                  sub parse_client_handshake_packet {
3221           2                    2             9      my ( $data ) = @_;
3222  ***      2     50                           8      return unless $data;
3223           2                                  6      MKDEBUG && _d('Client handshake data:', $data);
3224           2                                 31      my ( $flags, $user, $buff_len ) = $data =~ m{
3225                                                        ^
3226                                                        (.{8})         # Client flags
3227                                                        .{10}          # Max packet size, charset
3228                                                        (?:00){23}     # Filler
3229                                                        ((?:..)+?)00   # Null-terminated user name
3230                                                        (..)           # Length-coding byte for scramble buff
3231                                                     }x;
3232                                                  
3233  ***      2     50                          10      if ( !$buff_len ) {
3234  ***      0                                  0         MKDEBUG && _d('Did not match client handshake packet');
3235  ***      0                                  0         return;
3236                                                     }
3237                                                  
3238           2                                  7      my $code_len = hex($buff_len);
3239           2                                 39      my ( $db ) = $data =~ m!
3240                                                        ^.{64}${user}00..   # Everything matched before
3241                                                        (?:..){$code_len}   # The scramble buffer
3242                                                        (.*)00\Z            # The database name
3243                                                     !x;
3244           2    100                          10      my $pkt = {
3245                                                        user  => to_string($user),
3246                                                        db    => $db ? to_string($db) : '',
3247                                                        flags => parse_flags($flags),
3248                                                     };
3249           2                                  6      MKDEBUG && _d('Client handshake packet:', Dumper($pkt));
3250           2                                  7      return $pkt;
3251                                                  }
3252                                                  
3253                                                  sub parse_com_packet {
3254           8                    8            40      my ( $data, $len ) = @_;
3255  ***      8     50     33                   68      return unless $data && $len;
3256           8                                 19      MKDEBUG && _d('COM data:',
3257                                                        (substr($data, 0, 100).(length $data > 100 ? '...' : '')),
3258                                                        'len:', $len);
3259           8                                 30      my $code = substr($data, 0, 2);
3260           8                                 37      my $com  = $com_for{$code};
3261  ***      8     50                          31      if ( !$com ) {
3262  ***      0                                  0         MKDEBUG && _d('Did not match COM packet');
3263  ***      0                                  0         return;
3264                                                     }
3265  ***      8     50     33                  137      if (    $code ne COM_STMT_EXECUTE
      ***                   33                        
3266                                                          && $code ne COM_STMT_CLOSE
3267                                                          && $code ne COM_STMT_RESET )
3268                                                     {
3269           8                                 60         $data = to_string(substr($data, 2, ($len - 1) * 2));
3270                                                     }
3271           8                                 55      my $pkt = {
3272                                                        code => $code,
3273                                                        com  => $com,
3274                                                        data => $data,
3275                                                     };
3276           8                                 17      MKDEBUG && _d('COM packet:', Dumper($pkt));
3277           8                                 31      return $pkt;
3278                                                  }
3279                                                  
3280                                                  sub parse_execute_packet {
3281  ***      0                    0             0      my ( $data, $sths ) = @_;
3282  ***      0      0      0                    0      return unless $data && $sths;
3283                                                  
3284  ***      0                                  0      my $sth_id = to_num(substr($data, 2, 8));
3285  ***      0      0                           0      return unless defined $sth_id;
3286                                                  
3287  ***      0                                  0      my $sth = $sths->{$sth_id};
3288  ***      0      0                           0      if ( !$sth ) {
3289  ***      0                                  0         MKDEBUG && _d('Skipping unknown statement handle', $sth_id);
3290  ***      0                                  0         return;
3291                                                     }
3292  ***      0             0                    0      my $null_count  = int(($sth->{num_params} + 7) / 8) || 1;
3293  ***      0                                  0      my $null_bitmap = to_num(substr($data, 20, $null_count * 2));
3294  ***      0                                  0      MKDEBUG && _d('NULL bitmap:', $null_bitmap, 'count:', $null_count);
3295                                                     
3296  ***      0                                  0      substr($data, 0, 20 + ($null_count * 2), '');
3297                                                  
3298  ***      0                                  0      my $new_params = to_num(substr($data, 0, 2, ''));
3299  ***      0                                  0      my @types; 
3300  ***      0      0                           0      if ( $new_params ) {
3301  ***      0                                  0         MKDEBUG && _d('New param types');
3302  ***      0                                  0         for my $i ( 0..($sth->{num_params}-1) ) {
3303  ***      0                                  0            my $type = to_num(substr($data, 0, 4, ''));
3304  ***      0                                  0            push @types, $type_for{$type};
3305  ***      0                                  0            MKDEBUG && _d('Param', $i, 'type:', $type, $type_for{$type});
3306                                                        }
3307  ***      0                                  0         $sth->{types} = \@types;
3308                                                     }
3309                                                     else {
3310  ***      0      0                           0         @types = @{$sth->{types}} if $data;
      ***      0                                  0   
3311                                                     }
3312                                                  
3313                                                  
3314  ***      0                                  0      my $arg  = $sth->{statement};
3315  ***      0                                  0      MKDEBUG && _d('Statement:', $arg);
3316  ***      0                                  0      for my $i ( 0..($sth->{num_params}-1) ) {
3317  ***      0                                  0         my $val;
3318  ***      0                                  0         my $len;  # in bytes
3319  ***      0      0                           0         if ( $null_bitmap & (2**$i) ) {
3320  ***      0                                  0            MKDEBUG && _d('Param', $i, 'is NULL (bitmap)');
3321  ***      0                                  0            $val = 'NULL';
3322  ***      0                                  0            $len = 0;
3323                                                        }
3324                                                        else {
3325  ***      0      0                           0            if ( $unpack_type{$types[$i]} ) {
3326  ***      0                                  0               ($val, $len) = $unpack_type{$types[$i]}->($data);
3327                                                           }
3328                                                           else {
3329  ***      0                                  0               MKDEBUG && _d('No handler for param', $i, 'type', $types[$i]);
3330  ***      0                                  0               $val = '?';
3331  ***      0                                  0               $len = 0;
3332                                                           }
3333                                                        }
3334                                                  
3335  ***      0                                  0         MKDEBUG && _d('Param', $i, 'val:', $val);
3336  ***      0                                  0         $arg =~ s/\?/$val/;
3337                                                  
3338  ***      0      0                           0         substr($data, 0, $len * 2, '') if $len;
3339                                                     }
3340                                                  
3341  ***      0                                  0      my $pkt = {
3342                                                        sth_id => $sth_id,
3343                                                        arg    => "EXECUTE $arg",
3344                                                     };
3345  ***      0                                  0      MKDEBUG && _d('Execute packet:', Dumper($pkt));
3346  ***      0                                  0      return $pkt;
3347                                                  }
3348                                                  
3349                                                  sub get_sth_id {
3350  ***      0                    0             0      my ( $data ) = @_;
3351  ***      0      0                           0      return unless $data;
3352  ***      0                                  0      my $sth_id = to_num(substr($data, 2, 8));
3353  ***      0                                  0      return $sth_id;
3354                                                  }
3355                                                  
3356                                                  sub parse_flags {
3357           4                    4            16      my ( $flags ) = @_;
3358  ***      4     50                          16      die "I need flags" unless $flags;
3359           4                                  9      MKDEBUG && _d('Flag data:', $flags);
3360           4                                 58      my %flags     = %flag_for;
3361           4                                 17      my $flags_dec = to_num($flags);
3362           4                                 24      foreach my $flag ( keys %flag_for ) {
3363          72                                195         my $flagno    = $flag_for{$flag};
3364          72    100                         299         $flags{$flag} = ($flags_dec & $flagno ? 1 : 0);
3365                                                     }
3366           4                                 37      return \%flags;
3367                                                  }
3368                                                  
3369                                                  sub uncompress_data {
3370  ***      0                    0             0      my ( $data, $len ) = @_;
3371  ***      0      0                           0      die "I need data" unless $data;
3372  ***      0      0                           0      die "I need a len argument" unless $len;
3373  ***      0      0                           0      die "I need a scalar reference to data" unless ref $data eq 'SCALAR';
3374  ***      0                                  0      MKDEBUG && _d('Uncompressing data');
3375  ***      0                                  0      our $InflateError;
3376                                                  
3377  ***      0                                  0      my $comp_bin_data = pack('H*', $$data);
3378                                                  
3379  ***      0                                  0      my $uncomp_bin_data = '';
3380  ***      0      0                           0      my $z = new IO::Uncompress::Inflate(
3381                                                        \$comp_bin_data
3382                                                     ) or die "IO::Uncompress::Inflate failed: $InflateError";
3383  ***      0      0                           0      my $status = $z->read(\$uncomp_bin_data, $len)
3384                                                        or die "IO::Uncompress::Inflate failed: $InflateError";
3385                                                  
3386  ***      0                                  0      my $uncomp_data = unpack('H*', $uncomp_bin_data);
3387                                                  
3388  ***      0                                  0      return \$uncomp_data;
3389                                                  }
3390                                                  
3391                                                  sub detect_compression {
3392           1                    1             9      my ( $self, $packet, $session ) = @_;
3393           1                                  6      MKDEBUG && _d('Checking for client compression');
3394           1                                 13      my $com = parse_com_packet($packet->{data}, $packet->{mysql_data_len});
3395  ***      1     50     33                   17      if ( $com && $com->{code} eq COM_SLEEP ) {
3396  ***      0                                  0         MKDEBUG && _d('Client is using compression');
3397  ***      0                                  0         $session->{compress} = 1;
3398                                                  
3399  ***      0                                  0         $packet->{data} = $packet->{mysql_hdr} . $packet->{data};
3400  ***      0      0                           0         return 0 unless $self->uncompress_packet($packet, $session);
3401  ***      0                                  0         remove_mysql_header($packet);
3402                                                     }
3403                                                     else {
3404           1                                  3         MKDEBUG && _d('Client is NOT using compression');
3405           1                                  7         $session->{compress} = 0;
3406                                                     }
3407           1                                  9      return 1;
3408                                                  }
3409                                                  
3410                                                  sub uncompress_packet {
3411  ***      0                    0             0      my ( $self, $packet, $session ) = @_;
3412  ***      0      0                           0      die "I need a packet"  unless $packet;
3413  ***      0      0                           0      die "I need a session" unless $session;
3414                                                  
3415                                                  
3416  ***      0                                  0      my $data;
3417  ***      0                                  0      my $comp_hdr;
3418  ***      0                                  0      my $comp_data_len;
3419  ***      0                                  0      my $pkt_num;
3420  ***      0                                  0      my $uncomp_data_len;
3421  ***      0                                  0      eval {
3422  ***      0                                  0         $data            = \$packet->{data};
3423  ***      0                                  0         $comp_hdr        = substr($$data, 0, 14, '');
3424  ***      0                                  0         $comp_data_len   = to_num(substr($comp_hdr, 0, 6));
3425  ***      0                                  0         $pkt_num         = to_num(substr($comp_hdr, 6, 2));
3426  ***      0                                  0         $uncomp_data_len = to_num(substr($comp_hdr, 8, 6));
3427  ***      0                                  0         MKDEBUG && _d('Compression header data:', $comp_hdr,
3428                                                           'compressed data len (bytes)', $comp_data_len,
3429                                                           'number', $pkt_num,
3430                                                           'uncompressed data len (bytes)', $uncomp_data_len);
3431                                                     };
3432  ***      0      0                           0      if ( $EVAL_ERROR ) {
3433  ***      0                                  0         $session->{EVAL_ERROR} = $EVAL_ERROR;
3434  ***      0                                  0         $self->fail_session($session, 'failed to parse compression header');
3435  ***      0                                  0         return 0;
3436                                                     }
3437                                                  
3438  ***      0      0                           0      if ( $uncomp_data_len ) {
3439  ***      0                                  0         eval {
3440  ***      0                                  0            $data = uncompress_data($data, $uncomp_data_len);
3441  ***      0                                  0            $packet->{data} = $$data;
3442                                                        };
3443  ***      0      0                           0         if ( $EVAL_ERROR ) {
3444  ***      0                                  0            $session->{EVAL_ERROR} = $EVAL_ERROR;
3445  ***      0                                  0            $self->fail_session($session, 'failed to uncompress data');
3446  ***      0                                  0            die "Cannot uncompress packet.  Check that IO::Uncompress::Inflate "
3447                                                              . "is installed.\nError: $EVAL_ERROR";
3448                                                        }
3449                                                     }
3450                                                     else {
3451  ***      0                                  0         MKDEBUG && _d('Packet is not really compressed');
3452  ***      0                                  0         $packet->{data} = $$data;
3453                                                     }
3454                                                  
3455  ***      0                                  0      return 1;
3456                                                  }
3457                                                  
3458                                                  sub remove_mysql_header {
3459          19                   19            72      my ( $packet ) = @_;
3460  ***     19     50                          73      die "I need a packet" unless $packet;
3461                                                  
3462          19                                102      my $mysql_hdr      = substr($packet->{data}, 0, 8, '');
3463          19                                 81      my $mysql_data_len = to_num(substr($mysql_hdr, 0, 6));
3464          19                                 92      my $pkt_num        = to_num(substr($mysql_hdr, 6, 2));
3465          19                                 48      MKDEBUG && _d('MySQL packet: header data', $mysql_hdr,
3466                                                        'data len (bytes)', $mysql_data_len, 'number', $pkt_num);
3467                                                  
3468          19                                 79      $packet->{mysql_hdr}      = $mysql_hdr;
3469          19                                 68      $packet->{mysql_data_len} = $mysql_data_len;
3470          19                                 69      $packet->{number}         = $pkt_num;
3471                                                  
3472          19                                 66      return;
3473                                                  }
3474                                                  
3475                                                  sub _get_errors_fh {
3476  ***      0                    0             0      my ( $self ) = @_;
3477  ***      0                                  0      my $errors_fh = $self->{errors_fh};
3478  ***      0      0                           0      return $errors_fh if $errors_fh;
3479                                                  
3480  ***      0                                  0      my $o = $self->{o};
3481  ***      0      0      0                    0      if ( $o && $o->has('tcpdump-errors') && $o->got('tcpdump-errors') ) {
      ***                    0                        
3482  ***      0                                  0         my $errors_file = $o->get('tcpdump-errors');
3483  ***      0                                  0         MKDEBUG && _d('tcpdump-errors file:', $errors_file);
3484  ***      0      0                           0         open $errors_fh, '>>', $errors_file
3485                                                           or die "Cannot open tcpdump-errors file $errors_file: $OS_ERROR";
3486                                                     }
3487                                                  
3488  ***      0                                  0      $self->{errors_fh} = $errors_fh;
3489  ***      0                                  0      return $errors_fh;
3490                                                  }
3491                                                  
3492                                                  sub fail_session {
3493  ***      0                    0             0      my ( $self, $session, $reason ) = @_;
3494  ***      0                                  0      MKDEBUG && _d('Client', $session->{client}, 'failed because', $reason);
3495  ***      0                                  0      my $errors_fh = $self->_get_errors_fh();
3496  ***      0      0                           0      if ( $errors_fh ) {
3497  ***      0                                  0         my $raw_packets = $session->{raw_packets};
3498  ***      0                                  0         delete $session->{raw_packets};  # Don't dump, it's printed below.
3499  ***      0                                  0         $session->{reason_for_failure} = $reason;
3500  ***      0                                  0         my $session_dump = '# ' . Dumper($session);
3501  ***      0                                  0         chomp $session_dump;
3502  ***      0                                  0         $session_dump =~ s/\n/\n# /g;
3503  ***      0                                  0         print $errors_fh "$session_dump\n";
3504                                                        {
3505  ***      0                                  0            local $LIST_SEPARATOR = "\n";
      ***      0                                  0   
3506  ***      0                                  0            print $errors_fh "@$raw_packets";
3507  ***      0                                  0            print $errors_fh "\n";
3508                                                        }
3509                                                     }
3510  ***      0                                  0      delete $self->{sessions}->{$session->{client}};
3511  ***      0                                  0      return;
3512                                                  }
3513                                                  
3514                                                  sub _delete_buff {
3515           9                    9            39      my ( $self, $session ) = @_;
3516           9                                 42      map { delete $session->{$_} } qw(buff buff_left mysql_data_len);
              27                                108   
3517           9                                 27      return;
3518                                                  }
3519                                                  
3520                                                  sub _d {
3521  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3522  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3523  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3524                                                          @_;
3525  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3526                                                  }
3527                                                  
3528                                                  1;
3529                                                  
3530                                                  # ###########################################################################
3531                                                  # End MySQLProtocolParser package
3532                                                  # ###########################################################################
3533                                                  
3534                                                  # ###########################################################################
3535                                                  # SlowLogParser package 5357
3536                                                  # ###########################################################################
3537                                                  package SlowLogParser;
3538                                                  
3539           6                    6            82   use strict;
               6                                 17   
               6                                 46   
3540           6                    6            68   use warnings FATAL => 'all';
               6                                 15   
               6                                 53   
3541           6                    6            40   use English qw(-no_match_vars);
               6                                 14   
               6                                 40   
3542           6                    6            39   use Data::Dumper;
               6                                 17   
               6                                 33   
3543                                                  
3544  ***      6            50      6            43   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 13   
               6                                 90   
3545                                                  
3546                                                  sub new {
3547          39                   39           237      my ( $class ) = @_;
3548          39                                240      my $self = {
3549                                                        pending => [],
3550                                                     };
3551          39                                343      return bless $self, $class;
3552                                                  }
3553                                                  
3554                                                  my $slow_log_ts_line = qr/^# Time: ([0-9: ]{15})/;
3555                                                  my $slow_log_uh_line = qr/# User\@Host: ([^\[]+|\[[^[]+\]).*?@ (\S*) \[(.*)\]/;
3556                                                  my $slow_log_hd_line = qr{
3557                                                        ^(?:
3558                                                        T[cC][pP]\s[pP]ort:\s+\d+ # case differs on windows/unix
3559                                                        |
3560                                                        [/A-Z].*mysqld,\sVersion.*(?:started\swith:|embedded\slibrary)
3561                                                        |
3562                                                        Time\s+Id\s+Command
3563                                                        ).*\n
3564                                                     }xm;
3565                                                  
3566                                                  sub parse_event {
3567         349                  349          2149      my ( $self, %args ) = @_;
3568         349                               1927      my @required_args = qw(next_event tell);
3569         349                               1302      foreach my $arg ( @required_args ) {
3570  ***    698     50                        3546         die "I need a $arg argument" unless $args{$arg};
3571                                                     }
3572         349                               1798      my ($next_event, $tell) = @args{@required_args};
3573                                                  
3574         349                               1287      my $pending = $self->{pending};
3575         349                               2116      local $INPUT_RECORD_SEPARATOR = ";\n#";
3576         349                               1520      my $trimlen    = length($INPUT_RECORD_SEPARATOR);
3577         349                               1441      my $pos_in_log = $tell->();
3578         349                                891      my $stmt;
3579                                                  
3580                                                     EVENT:
3581         349           100                 3028      while (
3582                                                           defined($stmt = shift @$pending)
3583                                                        or defined($stmt = $next_event->())
3584                                                     ) {
3585         310                               1919         my @properties = ('cmd', 'Query', 'pos_in_log', $pos_in_log);
3586         310                               1350         $pos_in_log = $tell->();
3587                                                  
3588         310    100                       12330         if ( $stmt =~ s/$slow_log_hd_line//go ){ # Throw away header lines in log
3589           6                                 56            my @chunks = split(/$INPUT_RECORD_SEPARATOR/o, $stmt);
3590           6    100                          40            if ( @chunks > 1 ) {
3591           1                                  8               MKDEBUG && _d("Found multiple chunks");
3592           1                                  9               $stmt = shift @chunks;
3593           1                                 10               unshift @$pending, @chunks;
3594                                                           }
3595                                                        }
3596                                                  
3597         310    100                        2776         $stmt = '#' . $stmt unless $stmt =~ m/\A#/;
3598         310                               2326         $stmt =~ s/;\n#?\Z//;
3599                                                  
3600                                                  
3601         310                               1100         my ($got_ts, $got_uh, $got_ac, $got_db, $got_set, $got_embed);
3602         310                                918         my $pos = 0;
3603         310                               1409         my $len = length($stmt);
3604         310                                899         my $found_arg = 0;
3605                                                        LINE:
3606         310                               2257         while ( $stmt =~ m/^(.*)$/mg ) { # /g is important, requires scalar match.
3607        1737                               5511            $pos     = pos($stmt);  # Be careful not to mess this up!
3608        1737                               6973            my $line = $1;          # Necessary for /g and pos() to work.
3609        1737                               3961            MKDEBUG && _d($line);
3610                                                  
3611        1737    100                        7872            if ($line =~ m/^(?:#|use |SET (?:last_insert_id|insert_id|timestamp))/o) {
3612                                                  
3613        1440    100    100                33531               if ( !$got_ts && (my ( $time ) = $line =~ m/$slow_log_ts_line/o)) {
                    100    100                        
      ***           100     66                        
                    100    100                        
      ***           100     66                        
                    100                               
3614          53                                173                  MKDEBUG && _d("Got ts", $time);
3615          53                                257                  push @properties, 'ts', $time;
3616          53                                216                  ++$got_ts;
3617  ***     53    100     66                  922                  if ( !$got_uh
3618                                                                    && ( my ( $user, $host, $ip ) = $line =~ m/$slow_log_uh_line/o )
3619                                                                 ) {
3620          16                                 53                     MKDEBUG && _d("Got user, host, ip", $user, $host, $ip);
3621          16                                112                     push @properties, 'user', $user, 'host', $host, 'ip', $ip;
3622          16                                 65                     ++$got_uh;
3623                                                                 }
3624                                                              }
3625                                                  
3626                                                              elsif ( !$got_uh
3627                                                                    && ( my ( $user, $host, $ip ) = $line =~ m/$slow_log_uh_line/o )
3628                                                              ) {
3629         103                                290                  MKDEBUG && _d("Got user, host, ip", $user, $host, $ip);
3630         103                                577                  push @properties, 'user', $user, 'host', $host, 'ip', $ip;
3631         103                                344                  ++$got_uh;
3632                                                              }
3633                                                  
3634                                                              elsif (!$got_ac && $line =~ m/^# (?:administrator command:.*)$/) {
3635          10                                 34                  MKDEBUG && _d("Got admin command");
3636          10                                 75                  push @properties, 'cmd', 'Admin', 'arg', $line;
3637          10                                 73                  push @properties, 'bytes', length($properties[-1]);
3638          10                                 40                  ++$found_arg;
3639          10                                 43                  ++$got_ac;
3640                                                              }
3641                                                  
3642                                                              elsif ( $line =~ m/^# +[A-Z][A-Za-z_]+: \S+/ ) { # Make the test cheap!
3643         988                               2321                  MKDEBUG && _d("Got some line with properties");
3644         988                              12004                  my @temp = $line =~ m/(\w+):\s+(\S+|\Z)/g;
3645         988                               6112                  push @properties, @temp;
3646                                                              }
3647                                                  
3648                                                              elsif ( !$got_db && (my ( $db ) = $line =~ m/^use ([^;]+)/ ) ) {
3649          39                                 87                  MKDEBUG && _d("Got a default database:", $db);
3650          39                                153                  push @properties, 'db', $db;
3651          39                                113                  ++$got_db;
3652                                                              }
3653                                                  
3654                                                              elsif (!$got_set && (my ($setting) = $line =~ m/^SET\s+([^;]*)/)) {
3655          20                                 58                  MKDEBUG && _d("Got some setting:", $setting);
3656          20                                255                  push @properties, split(/,|\s*=\s*/, $setting);
3657          20                                 65                  ++$got_set;
3658                                                              }
3659                                                  
3660        1440    100    100                17483               if ( !$found_arg && $pos == $len ) {
3661           3                                  9                  MKDEBUG && _d("Did not find arg, looking for special cases");
3662           3                                 23                  local $INPUT_RECORD_SEPARATOR = ";\n";
3663  ***      3     50                          24                  if ( defined(my $l = $next_event->()) ) {
3664           3                                 13                     chomp $l;
3665           3                                  8                     MKDEBUG && _d("Found admin statement", $l);
3666           3                                 17                     push @properties, 'cmd', 'Admin', 'arg', '#' . $l;
3667           3                                 12                     push @properties, 'bytes', length($properties[-1]);
3668           3                                 26                     $found_arg++;
3669                                                                 }
3670                                                                 else {
3671  ***      0                                  0                     MKDEBUG && _d("I can't figure out what to do with this line");
3672  ***      0                                  0                     next EVENT;
3673                                                                 }
3674                                                              }
3675                                                           }
3676                                                           else {
3677         297                                784               MKDEBUG && _d("Got the query/arg line");
3678         297                               2278               my $arg = substr($stmt, $pos - length($line));
3679         297                               1614               push @properties, 'arg', $arg, 'bytes', length($arg);
3680  ***    297    100     66                 3717               if ( $args{misc} && $args{misc}->{embed}
      ***                   66                        
3681                                                                 && ( my ($e) = $arg =~ m/($args{misc}->{embed})/)
3682                                                              ) {
3683           1                                 22                  push @properties, $e =~ m/$args{misc}->{capture}/g;
3684                                                              }
3685         297                               1262               last LINE;
3686                                                           }
3687                                                        }
3688                                                  
3689         310                                795         MKDEBUG && _d('Properties of event:', Dumper(\@properties));
3690         310                               4991         my $event = { @properties };
3691         310                               3441         return $event;
3692                                                     } # EVENT
3693                                                  
3694          39                                141      @$pending = ();
3695  ***     39     50                         254      $args{oktorun}->(0) if $args{oktorun};
3696          39                                278      return;
3697                                                  }
3698                                                  
3699                                                  sub _d {
3700  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3701  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3702  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3703                                                          @_;
3704  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3705                                                  }
3706                                                  
3707                                                  1;
3708                                                  
3709                                                  # ###########################################################################
3710                                                  # End SlowLogParser package
3711                                                  # ###########################################################################
3712                                                  
3713                                                  # ###########################################################################
3714                                                  # SlowLogWriter package 5266
3715                                                  # ###########################################################################
3716                                                  package SlowLogWriter;
3717                                                  
3718           6                    6            61   use strict;
               6                                 20   
               6                                 38   
3719           6                    6            34   use warnings FATAL => 'all';
               6                                 15   
               6                                 41   
3720           6                    6            37   use English qw(-no_match_vars);
               6                                 14   
               6                                 35   
3721                                                  
3722  ***      6            50      6            46   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 14   
               6                                103   
3723                                                  
3724                                                  sub new {
3725  ***      0                    0             0      my ( $class ) = @_;
3726  ***      0                                  0      bless {}, $class;
3727                                                  }
3728                                                  
3729                                                  sub write {
3730  ***      0                    0             0      my ( $self, $fh, $event ) = @_;
3731  ***      0      0                           0      if ( $event->{ts} ) {
3732  ***      0                                  0         print $fh "# Time: $event->{ts}\n";
3733                                                     }
3734  ***      0      0                           0      if ( $event->{user} ) {
3735  ***      0                                  0         printf $fh "# User\@Host: %s[%s] \@ %s []\n",
3736                                                           $event->{user}, $event->{user}, $event->{host};
3737                                                     }
3738  ***      0      0      0                    0      if ( $event->{ip} && $event->{port} ) {
3739  ***      0                                  0         printf $fh "# Client: $event->{ip}:$event->{port}\n";
3740                                                     }
3741  ***      0      0                           0      if ( $event->{Thread_id} ) {
3742  ***      0                                  0         printf $fh "# Thread_id: $event->{Thread_id}\n";
3743                                                     }
3744                                                  
3745  ***      0      0                           0      my $percona_patched = exists $event->{QC_Hit} ? 1 : 0;
3746                                                  
3747  ***      0      0                           0      printf $fh
3748                                                        "# Query_time: %.6f  Lock_time: %.6f  Rows_sent: %d  Rows_examined: %d\n",
3749  ***      0                                  0         map { $_ || 0 }
3750  ***      0                                  0            @{$event}{qw(Query_time Lock_time Rows_sent Rows_examined)};
3751                                                  
3752  ***      0      0                           0      if ( $percona_patched ) {
3753  ***      0      0                           0         printf $fh
3754                                                           "# QC_Hit: %s  Full_scan: %s  Full_join: %s  Tmp_table: %s  Disk_tmp_table: %s\n# Filesort: %s  Disk_filesort: %s  Merge_passes: %d\n",
3755  ***      0                                  0            map { $_ || 0 }
3756  ***      0                                  0               @{$event}{qw(QC_Hit Full_scan Full_join Tmp_table Disk_tmp_table Filesort Disk_filesort Merge_passes)};
3757                                                  
3758  ***      0      0                           0         if ( exists $event->{InnoDB_IO_r_ops} ) {
3759  ***      0      0                           0            printf $fh
3760                                                              "#   InnoDB_IO_r_ops: %d  InnoDB_IO_r_bytes: %d  InnoDB_IO_r_wait: %s\n#   InnoDB_rec_lock_wait: %s  InnoDB_queue_wait: %s\n#   InnoDB_pages_distinct: %d\n",
3761  ***      0                                  0               map { $_ || 0 }
3762  ***      0                                  0                  @{$event}{qw(InnoDB_IO_r_ops InnoDB_IO_r_bytes InnoDB_IO_r_wait InnoDB_rec_lock_wait InnoDB_queue_wait InnoDB_pages_distinct)};
3763                                                  
3764                                                        } 
3765                                                        else {
3766  ***      0                                  0            printf $fh "# No InnoDB statistics available for this query\n";
3767                                                        }
3768                                                     }
3769                                                  
3770  ***      0      0                           0      if ( $event->{db} ) {
3771  ***      0                                  0         printf $fh "use %s;\n", $event->{db};
3772                                                     }
3773  ***      0      0                           0      if ( $event->{arg} =~ m/^administrator command/ ) {
3774  ***      0                                  0         print $fh '# ';
3775                                                     }
3776  ***      0                                  0      print $fh $event->{arg}, ";\n";
3777                                                  
3778  ***      0                                  0      return;
3779                                                  }
3780                                                  
3781                                                  sub _d {
3782  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3783  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3784  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3785                                                          @_;
3786  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3787                                                  }
3788                                                  
3789                                                  1;
3790                                                  
3791                                                  # ###########################################################################
3792                                                  # End SlowLogWriter package
3793                                                  # ###########################################################################
3794                                                  
3795                                                  # ###########################################################################
3796                                                  # EventAggregator package 4916
3797                                                  # ###########################################################################
3798                                                  package EventAggregator;
3799                                                  
3800           6                    6            42   use strict;
               6                                 16   
               6                                 36   
3801           6                    6            44   use warnings FATAL => 'all';
               6                                 14   
               6                                 30   
3802           6                    6            36   use English qw(-no_match_vars);
               6                                 12   
               6                                 31   
3803                                                  
3804           6                    6            37   use constant MKDEBUG      => $ENV{MKDEBUG};
               6                                 15   
               6                                 42   
3805           6                    6            40   use constant BUCK_SIZE    => 1.05;
               6                                 15   
               6                                 27   
3806           6                    6            40   use constant BASE_LOG     => log(BUCK_SIZE);
               6                                 13   
               6                                 30   
3807           6                    6            37   use constant BASE_OFFSET  => abs(1 - log(0.000001) / BASE_LOG); # 284.1617969
               6                                 15   
               6                                 33   
3808           6                    6            35   use constant NUM_BUCK     => 1000;
               6                                 16   
               6                                 44   
3809           6                    6            38   use constant MIN_BUCK     => .000001;
               6                                 14   
               6                                 33   
3810                                                  
3811                                                  our @buckets  = map { 0 } (0..NUM_BUCK-1);
3812                                                  
3813                                                  my @buck_vals = map { bucket_value($_); } (0..NUM_BUCK-1);
3814                                                  
3815                                                  sub new {
3816          46                   46           752      my ( $class, %args ) = @_;
3817          46                                313      foreach my $arg ( qw(groupby worst) ) {
3818  ***     92     50                         501         die "I need a $arg argument" unless $args{$arg};
3819                                                     }
3820  ***     46            50                  244      my $attributes = $args{attributes} || {};
3821         736                               4195      my $self = {
3822                                                        groupby        => $args{groupby},
3823                                                        detect_attribs => scalar keys %$attributes == 0 ? 1 : 0,
3824                                                        all_attribs    => [ keys %$attributes ],
3825                                                        ignore_attribs => {
3826         736                               2637            map  { $_ => $args{attributes}->{$_} }
3827          46                                218            grep { $_ ne $args{groupby} }
3828           1                                  9            @{$args{ignore_attributes}}
3829                                                        },
3830                                                        attributes     => {
3831           1                                  5            map  { $_ => $args{attributes}->{$_} }
3832           1                                 19            grep { $_ ne $args{groupby} }
3833                                                           keys %$attributes
3834                                                        },
3835                                                        alt_attribs    => {
3836           1                                  6            map  { $_ => make_alt_attrib(@{$args{attributes}->{$_}}) }
               1                                 10   
3837  ***     46     50                         863            grep { $_ ne $args{groupby} }
3838                                                           keys %$attributes
3839                                                        },
3840                                                        worst        => $args{worst},
3841                                                        unroll_limit => $args{unroll_limit} || 1000,
3842                                                        attrib_limit => $args{attrib_limit},
3843                                                        result_classes => {},
3844                                                        result_globals => {},
3845                                                        result_samples => {},
3846                                                        n_events       => 0,
3847                                                        unrolled_loops => undef,
3848  ***     46    100     50                  405         type_for       => { %{$args{type_for} || { Query_time => 'num' }} },
3849                                                     };
3850          46                                620      return bless $self, $class;
3851                                                  }
3852                                                  
3853                                                  sub reset_aggregated_data {
3854          46                   46           180      my ( $self ) = @_;
3855          46                                189      foreach my $class ( values %{$self->{result_classes}} ) {
              46                                300   
3856         121                                760         foreach my $attrib ( values %$class ) {
3857        1617                               6355            delete @{$attrib}{keys %$attrib};
            1617                              26161   
3858                                                        }
3859                                                     }
3860          46                                223      foreach my $class ( values %{$self->{result_globals}} ) {
              46                                494   
3861         604                               2476         delete @{$class}{keys %$class};
             604                              10028   
3862                                                     }
3863          46                               1220      delete @{$self->{result_samples}}{keys %{$self->{result_samples}}};
              46                               1065   
              46                                319   
3864          46                                321      $self->{n_events} = 0;
3865                                                  }
3866                                                  
3867                                                  sub aggregate {
3868         339                  339          1343      my ( $self, $event ) = @_;
3869                                                  
3870         339                               1694      my $group_by = $event->{$self->{groupby}};
3871  ***    339     50                        1440      return unless defined $group_by;
3872                                                  
3873         339                               1107      $self->{n_events}++;
3874         339                                864      MKDEBUG && _d('event', $self->{n_events});
3875                                                  
3876  ***    339     50                        1626      return $self->{unrolled_loops}->($self, $event, $group_by)
3877                                                        if $self->{unrolled_loops};
3878                                                  
3879  ***    339     50                        1898      if ( $self->{n_events} <= $self->{unroll_limit} ) {
3880                                                  
3881         339    100                        2646         $self->add_new_attributes($event) if $self->{detect_attribs};
3882                                                  
3883         339                               2283         ATTRIB:
3884         339                                923         foreach my $attrib ( keys %{$self->{attributes}} ) {
3885                                                  
3886        5113    100                       22988            if ( !exists $event->{$attrib} ) {
3887         153                                338               MKDEBUG && _d("attrib doesn't exist in event:", $attrib);
3888         153                                683               my $alt_attrib = $self->{alt_attribs}->{$attrib}->($event);
3889         153                                317               MKDEBUG && _d('alt attrib:', $alt_attrib);
3890  ***    153     50                         664               next ATTRIB unless $alt_attrib;
3891                                                           }
3892                                                  
3893                                                           GROUPBY:
3894        4960    100                       20257            foreach my $val ( ref $group_by ? @$group_by : ($group_by) ) {
3895        4960           100                35351               my $class_attrib  = $self->{result_classes}->{$val}->{$attrib} ||= {};
3896        4960           100                26183               my $global_attrib = $self->{result_globals}->{$attrib} ||= {};
3897        4960                              15314               my $samples       = $self->{result_samples};
3898        4960                              18308               my $handler = $self->{handlers}->{ $attrib };
3899        4960    100                       18189               if ( !$handler ) {
3900         999                               7440                  $handler = $self->make_handler(
3901                                                                    $attrib,
3902                                                                    $event,
3903                                                                    wor => $self->{worst} eq $attrib,
3904                                                                    alt => $self->{attributes}->{$attrib},
3905                                                                 );
3906         999                               4515                  $self->{handlers}->{$attrib} = $handler;
3907                                                              }
3908        4960    100                       18471               next GROUPBY unless $handler;
3909        4545           100                18756               $samples->{$val} ||= $event; # Initialize to the first event.
3910        4545                              22438               $handler->($event, $class_attrib, $global_attrib, $samples, $group_by);
3911                                                           }
3912                                                        }
3913                                                     }
3914                                                     else {
3915  ***      0                                  0         $self->_make_unrolled_loops($event);
3916  ***      0                                  0         $self->{unrolled_loops}->($self, $event, $group_by);
3917                                                     }
3918                                                  
3919         339                               1829      return;
3920                                                  }
3921                                                  
3922                                                  sub _make_unrolled_loops {
3923  ***      0                    0             0      my ( $self, $event ) = @_;
3924                                                  
3925  ***      0                                  0      my $group_by = $event->{$self->{groupby}};
3926                                                  
3927  ***      0                                  0      my @attrs   = grep { $self->{handlers}->{$_} } keys %{$self->{attributes}};
      ***      0                                  0   
      ***      0                                  0   
3928  ***      0                                  0      my $globs   = $self->{result_globals}; # Global stats for each
3929  ***      0                                  0      my $samples = $self->{result_samples};
3930                                                  
3931  ***      0      0                           0      my @lines = (
3932                                                        'my ( $self, $event, $group_by ) = @_;',
3933                                                        'my ($val, $class, $global, $idx);',
3934                                                        (ref $group_by ? ('foreach my $group_by ( @$group_by ) {') : ()),
3935                                                        'my $temp = $self->{result_classes}->{ $group_by }
3936                                                           ||= { map { $_ => { } } @attrs };',
3937                                                        '$samples->{$group_by} ||= $event;', # Always start with the first.
3938                                                     );
3939  ***      0                                  0      foreach my $i ( 0 .. $#attrs ) {
3940  ***      0                                  0         push @lines, (
3941                                                           '$class  = $temp->{\''  . $attrs[$i] . '\'};',
3942                                                           '$global = $globs->{\'' . $attrs[$i] . '\'};',
3943                                                           $self->{unrolled_for}->{$attrs[$i]},
3944                                                        );
3945                                                     }
3946  ***      0      0                           0      if ( ref $group_by ) {
3947  ***      0                                  0         push @lines, '}'; # Close the loop opened above
3948                                                     }
3949  ***      0                                  0      @lines = map { s/^/   /gm; $_ } @lines; # Indent for debugging
      ***      0                                  0   
      ***      0                                  0   
3950  ***      0                                  0      unshift @lines, 'sub {';
3951  ***      0                                  0      push @lines, '}';
3952                                                  
3953  ***      0                                  0      my $code = join("\n", @lines);
3954  ***      0                                  0      MKDEBUG && _d('Unrolled subroutine:', @lines);
3955  ***      0                                  0      my $sub = eval $code;
3956  ***      0      0                           0      die $EVAL_ERROR if $EVAL_ERROR;
3957  ***      0                                  0      $self->{unrolled_loops} = $sub;
3958                                                  
3959  ***      0                                  0      return;
3960                                                  }
3961                                                  
3962                                                  sub results {
3963         397                  397          1376      my ( $self ) = @_;
3964                                                     return {
3965         397                               3566         classes => $self->{result_classes},
3966                                                        globals => $self->{result_globals},
3967                                                        samples => $self->{result_samples},
3968                                                     };
3969                                                  }
3970                                                  
3971                                                  sub attributes {
3972  ***      0                    0             0      my ( $self ) = @_;
3973  ***      0                                  0      return $self->{type_for};
3974                                                  }
3975                                                  
3976                                                  sub type_for {
3977        2495                 2495          9731      my ( $self, $attrib ) = @_;
3978        2495                              18968      return $self->{type_for}->{$attrib};
3979                                                  }
3980                                                  
3981                                                  sub make_handler {
3982         999                  999          7218      my ( $self, $attrib, $event, %args ) = @_;
3983  ***    999     50                        4600      die "I need an attrib" unless defined $attrib;
3984         999                               2935      my ($val) = grep { defined $_ } map { $event->{$_} } @{ $args{alt} };
             999                               3653   
             999                               4232   
             999                               4037   
3985         999                               3130      my $is_array = 0;
3986  ***    999     50                        4069      if (ref $val eq 'ARRAY') {
3987  ***      0                                  0         $is_array = 1;
3988  ***      0                                  0         $val      = $val->[0];
3989                                                     }
3990         999    100                        4668      return unless defined $val; # Can't decide type if it's undef.
3991                                                  
3992         584                               3617      my $float_re = qr{[+-]?(?:(?=\d|[.])\d+(?:[.])\d{0,})(?:E[+-]?\d+)?}i;
3993         584    100                        2382      my $type = $self->type_for($attrib)         ? $self->type_for($attrib)
                    100                               
                    100                               
3994                                                              : $val  =~ m/^(?:\d+|$float_re)$/o ? 'num'
3995                                                              : $val  =~ m/^(?:Yes|No)$/         ? 'bool'
3996                                                              :                                    'string';
3997         584                               1394      MKDEBUG && _d('Type for', $attrib, 'is', $type,
3998                                                        '(sample:', $val, '), is array:', $is_array);
3999         584                               2629      $self->{type_for}->{$attrib} = $type;
4000                                                  
4001         584    100                       12963      %args = ( # Set up defaults
                    100                               
                    100                               
                    100                               
4002                                                        min => 1,
4003                                                        max => 1,
4004                                                        sum => $type =~ m/num|bool/    ? 1 : 0,
4005                                                        cnt => 1,
4006                                                        unq => $type =~ m/bool|string/ ? 1 : 0,
4007                                                        all => $type eq 'num'          ? 1 : 0,
4008                                                        glo => 1,
4009                                                        trf => ($type eq 'bool') ? q{(($val || '') eq 'Yes') ? 1 : 0} : undef,
4010                                                        wor => 0,
4011                                                        alt => [],
4012                                                        %args,
4013                                                     );
4014                                                  
4015         584                               3593      my @lines = ("# type: $type"); # Lines of code for the subroutine
4016         584    100                        2412      if ( $args{trf} ) {
4017          97                                519         push @lines, q{$val = } . $args{trf} . ';';
4018                                                     }
4019                                                  
4020         584                               2077      foreach my $place ( qw($class $global) ) {
4021        1168                               2842         my @tmp;
4022  ***   1168     50                        4860         if ( $args{min} ) {
4023        1168    100                        4389            my $op   = $type eq 'num' ? '<' : 'lt';
4024        1168                               5082            push @tmp, (
4025                                                              'PLACE->{min} = $val if !defined PLACE->{min} || $val '
4026                                                                 . $op . ' PLACE->{min};',
4027                                                           );
4028                                                        }
4029  ***   1168     50                        4554         if ( $args{max} ) {
4030        1168    100                        4267            my $op = ($type eq 'num') ? '>' : 'gt';
4031        1168                               4543            push @tmp, (
4032                                                              'PLACE->{max} = $val if !defined PLACE->{max} || $val '
4033                                                                 . $op . ' PLACE->{max};',
4034                                                           );
4035                                                        }
4036        1168    100                        4500         if ( $args{sum} ) {
4037         870                               2649            push @tmp, 'PLACE->{sum} += $val;';
4038                                                        }
4039  ***   1168     50                        4567         if ( $args{cnt} ) {
4040        1168                               3541            push @tmp, '++PLACE->{cnt};';
4041                                                        }
4042        1168    100                        4426         if ( $args{all} ) {
4043         676                               2624            push @tmp, (
4044                                                              'exists PLACE->{all} or PLACE->{all} = [ @buckets ];',
4045                                                              '++PLACE->{all}->[ EventAggregator::bucket_idx($val) ];',
4046                                                           );
4047                                                        }
4048        1168                               3742         push @lines, map { s/PLACE/$place/g; $_ } @tmp;
            5726                              28026   
            5726                              20926   
4049                                                     }
4050                                                  
4051         584    100                        2568      if ( $args{unq} ) {
4052         246                                826         push @lines, '++$class->{unq}->{$val};';
4053                                                     }
4054         584    100                        2367      if ( $args{wor} ) {
4055  ***     44     50                         289         my $op = $type eq 'num' ? '>=' : 'ge';
4056          44                                263         push @lines, (
4057                                                           'if ( $val ' . $op . ' ($class->{max} || 0) ) {',
4058                                                           '   $samples->{$group_by} = $event;',
4059                                                           '}',
4060                                                        );
4061                                                     }
4062                                                  
4063         584                               1461      my @broken_query_time;
4064         584    100                        2319      if ( $attrib eq 'Query_time' ) {
4065          45                                224         push @broken_query_time, (
4066                                                           '$val =~ s/^(\d+(?:\.\d+)?).*/$1/;',
4067                                                           '$event->{\''.$attrib.'\'} = $val;',
4068                                                        );
4069                                                     }
4070                                                  
4071         584                               1346      my @limit;
4072  ***    584    100     66                 6108      if ( $args{all} && $type eq 'num' && $self->{attrib_limit} ) {
      ***                   66                        
4073         338                               2064         push @limit, (
4074                                                           "if ( \$val > $self->{attrib_limit} ) {",
4075                                                           '   $val = $class->{last} ||= 0;',
4076                                                           '}',
4077                                                           '$class->{last} = $val;',
4078                                                        );
4079                                                     }
4080                                                  
4081  ***      0                                  0      my @unrolled = (
4082                                                        "\$val = \$event->{'$attrib'};",
4083                                                        ($is_array ? ('foreach my $val ( @$val ) {') : ()),
4084         584                               2614         (map { "\$val = \$event->{'$_'} unless defined \$val;" }
4085         584                               2190            grep { $_ ne $attrib } @{$args{alt}}),
            8227                              29907   
4086                                                        'defined $val && do {',
4087  ***    584     50                        2758         ( map { s/^/   /gm; $_ } (@broken_query_time, @limit, @lines) ), # Indent for debugging
      ***   8227     50                       30958   
4088                                                        '};',
4089                                                        ($is_array ? ('}') : ()),
4090                                                     );
4091         584                               6708      $self->{unrolled_for}->{$attrib} = join("\n", @unrolled);
4092                                                  
4093  ***      0                                  0      unshift @lines, (
4094                                                        'sub {',
4095                                                        'my ( $event, $class, $global, $samples, $group_by ) = @_;',
4096                                                        'my ($val, $idx);', # NOTE: define all variables here
4097                                                        "\$val = \$event->{'$attrib'};",
4098         584                               4399         (map { "\$val = \$event->{'$_'} unless defined \$val;" }
4099  ***    584     50                        2650            grep { $_ ne $attrib } @{$args{alt}}),
      ***    584     50                        2204   
4100                                                        'return unless defined $val;',
4101                                                        ($is_array ? ('foreach my $val ( @$val ) {') : ()),
4102                                                        @broken_query_time,
4103                                                        @limit,
4104                                                        ($is_array ? ('}') : ()),
4105                                                     );
4106         584                               1904      push @lines, '}';
4107         584                               3641      my $code = join("\n", @lines);
4108         584                               2803      $self->{code_for}->{$attrib} = $code;
4109                                                  
4110         584                               1297      MKDEBUG && _d('Metric handler for', $attrib, ':', @lines);
4111         584                             117753      my $sub = eval join("\n", @lines);
4112  ***    584     50                        2594      die if $EVAL_ERROR;
4113         584                               6958      return $sub;
4114                                                  }
4115                                                  
4116                                                  sub bucket_idx {
4117        4796                 4796         17652      my ( $val ) = @_;
4118        4796    100                       25101      return 0 if $val < MIN_BUCK;
4119        2990                              13293      my $idx = int(BASE_OFFSET + log($val)/BASE_LOG);
4120  ***   2990     50                       18083      return $idx > (NUM_BUCK-1) ? (NUM_BUCK-1) : $idx;
4121                                                  }
4122                                                  
4123                                                  sub bucket_value {
4124        6000                 6000         18139      my ( $bucket ) = @_;
4125        6000    100                       21431      return 0 if $bucket == 0;
4126  ***   5994     50     33                44175      die "Invalid bucket: $bucket" if $bucket < 0 || $bucket > (NUM_BUCK-1);
4127        5994                              27797      return (BUCK_SIZE**($bucket-1)) * MIN_BUCK;
4128                                                  }
4129                                                  
4130                                                  {
4131                                                     my @buck_tens;
4132                                                     sub buckets_of {
4133          89    100            89         14714         return @buck_tens if @buck_tens;
4134                                                  
4135           6                                 20         my $start_bucket  = 0;
4136           6                                 24         my @base10_starts = (0);
4137           6                                 24         map { push @base10_starts, (10**$_)*MIN_BUCK } (1..7);
              42                                182   
4138                                                  
4139           6                                 48         for my $base10_bucket ( 0..($#base10_starts-1) ) {
4140          42                                196            my $next_bucket = bucket_idx( $base10_starts[$base10_bucket+1] );
4141          42                                 92            MKDEBUG && _d('Base 10 bucket', $base10_bucket, 'maps to',
4142                                                              'base 1.05 buckets', $start_bucket, '..', $next_bucket-1);
4143          42                                158            for my $base1_05_bucket ($start_bucket..($next_bucket-1)) {
4144        1986                               6381               $buck_tens[$base1_05_bucket] = $base10_bucket;
4145                                                           }
4146          42                                152            $start_bucket = $next_bucket;
4147                                                        }
4148                                                  
4149           6                                277         map { $buck_tens[$_] = 7 } ($start_bucket..(NUM_BUCK-1));
            4014                              13408   
4150                                                  
4151           6                               1256         return @buck_tens;
4152                                                     }
4153                                                  }
4154                                                  
4155                                                  sub calculate_statistical_metrics {
4156         574                  574          2268      my ( $self, $vals, $args ) = @_;
4157         574                               3248      my $statistical_metrics = {
4158                                                        pct_95    => 0,
4159                                                        stddev    => 0,
4160                                                        median    => 0,
4161                                                        cutoff    => undef,
4162                                                     };
4163                                                  
4164  ***    574     50     33                 7425      return $statistical_metrics
      ***                   33                        
4165                                                        unless defined $vals && @$vals && $args->{cnt};
4166                                                  
4167         574                               1861      my $n_vals = $args->{cnt};
4168         574    100    100                 3584      if ( $n_vals == 1 || $args->{max} == $args->{min} ) {
                    100                               
4169         526           100                 2945         my $v      = $args->{max} || 0;
4170         526    100                        3153         my $bucket = int(6 + ( log($v > 0 ? $v : MIN_BUCK) / log(10)));
4171  ***    526     50                        2366         $bucket    = $bucket > 7 ? 7 : $bucket < 0 ? 0 : $bucket;
                    100                               
4172                                                        return {
4173         526                               3713            pct_95 => $v,
4174                                                           stddev => 0,
4175                                                           median => $v,
4176                                                           cutoff => $n_vals,
4177                                                        };
4178                                                     }
4179                                                     elsif ( $n_vals == 2 ) {
4180          29                                155         foreach my $v ( $args->{min}, $args->{max} ) {
4181          58    100    100                  585            my $bucket = int(6 + ( log($v && $v > 0 ? $v : MIN_BUCK) / log(10)));
4182  ***     58     50                         328            $bucket = $bucket > 7 ? 7 : $bucket < 0 ? 0 : $bucket;
                    100                               
4183                                                        }
4184  ***     29            50                  151         my $v      = $args->{max} || 0;
4185          29           100                  185         my $mean = (($args->{min} || 0) + $v) / 2;
4186                                                        return {
4187          29                                282            pct_95 => $v,
4188                                                           stddev => sqrt((($v - $mean) ** 2) *2),
4189                                                           median => $mean,
4190                                                           cutoff => $n_vals,
4191                                                        };
4192                                                     }
4193                                                  
4194          19    100                          89      my $cutoff = $n_vals >= 10 ? int ( $n_vals * 0.95 ) : $n_vals;
4195          19                                 74      $statistical_metrics->{cutoff} = $cutoff;
4196                                                  
4197          19                                 56      my $total_left = $n_vals;
4198          19                                 59      my $top_vals   = $n_vals - $cutoff; # vals > 95th
4199          19                                 54      my $sum_excl   = 0;
4200          19                                 55      my $sum        = 0;
4201          19                                 50      my $sumsq      = 0;
4202          19                                 72      my $mid        = int($n_vals / 2);
4203          19                                 56      my $median     = 0;
4204          19                                 50      my $prev       = NUM_BUCK-1; # Used for getting median when $cutoff is odd
4205          19                                 52      my $bucket_95  = 0; # top bucket in 95th
4206                                                  
4207          19                                 41      MKDEBUG && _d('total vals:', $total_left, 'top vals:', $top_vals, 'mid:', $mid);
4208                                                  
4209                                                     BUCKET:
4210          19                                144      for my $bucket ( reverse 0..(NUM_BUCK-1) ) {
4211       19000                              54145         my $val = $vals->[$bucket];
4212       19000    100                       70686         next BUCKET unless $val; 
4213                                                  
4214          57                                168         $total_left -= $val;
4215          57                                201         $sum_excl   += $val;
4216          57    100    100                  402         $bucket_95   = $bucket if !$bucket_95 && $sum_excl > $top_vals;
4217                                                  
4218          57    100    100                  416         if ( !$median && $total_left <= $mid ) {
4219          19    100    100                  187            $median = (($cutoff % 2) || ($val > 1)) ? $buck_vals[$bucket]
4220                                                                   : ($buck_vals[$bucket] + $buck_vals[$prev]) / 2;
4221                                                        }
4222                                                  
4223          57                                248         $sum    += $val * $buck_vals[$bucket];
4224          57                                228         $sumsq  += $val * ($buck_vals[$bucket]**2);
4225          57                                184         $prev   =  $bucket;
4226                                                     }
4227                                                  
4228          19                                112      my $var      = $sumsq/$n_vals - ( ($sum/$n_vals) ** 2 );
4229          19    100                         109      my $stddev   = $var > 0 ? sqrt($var) : 0;
4230  ***     19            50                  153      my $maxstdev = (($args->{max} || 0) - ($args->{min} || 0)) / 2;
                           100                        
4231  ***     19     50                          84      $stddev      = $stddev > $maxstdev ? $maxstdev : $stddev;
4232                                                  
4233          19                                 45      MKDEBUG && _d('sum:', $sum, 'sumsq:', $sumsq, 'stddev:', $stddev,
4234                                                        'median:', $median, 'prev bucket:', $prev,
4235                                                        'total left:', $total_left, 'sum excl', $sum_excl,
4236                                                        'bucket 95:', $bucket_95, $buck_vals[$bucket_95]);
4237                                                  
4238          19                                 77      $statistical_metrics->{stddev} = $stddev;
4239          19                                 67      $statistical_metrics->{pct_95} = $buck_vals[$bucket_95];
4240          19                                 61      $statistical_metrics->{median} = $median;
4241                                                  
4242          19                                 86      return $statistical_metrics;
4243                                                  }
4244                                                  
4245                                                  sub metrics {
4246  ***      0                    0             0      my ( $self, %args ) = @_;
4247  ***      0                                  0      foreach my $arg ( qw(attrib where) ) {
4248  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
4249                                                     }
4250  ***      0                                  0      my $stats = $self->results;
4251  ***      0                                  0      my $store = $stats->{classes}->{$args{where}}->{$args{attrib}};
4252                                                  
4253  ***      0                                  0      my $global_cnt = $stats->{globals}->{$args{attrib}}->{cnt};
4254  ***      0                                  0      my $metrics    = $self->calculate_statistical_metrics($store->{all}, $store);
4255                                                  
4256                                                     return {
4257  ***      0      0      0                    0         cnt    => $store->{cnt},
      ***             0      0                        
4258                                                        pct    => $global_cnt && $store->{cnt} ? $store->{cnt} / $global_cnt : 0,
4259                                                        sum    => $store->{sum},
4260                                                        min    => $store->{min},
4261                                                        max    => $store->{max},
4262                                                        avg    => $store->{sum} && $store->{cnt} ? $store->{sum} / $store->{cnt} : 0,
4263                                                        median => $metrics->{median},
4264                                                        pct_95 => $metrics->{pct_95},
4265                                                        stddev => $metrics->{stddev},
4266                                                     };
4267                                                  }
4268                                                  
4269                                                  sub top_events {
4270          46                   46           423      my ( $self, %args ) = @_;
4271          46                                241      my $classes = $self->{result_classes};
4272         122                                856      my @sorted = reverse sort { # Sorted list of $groupby values
4273         121                                773         $classes->{$a}->{$args{attrib}}->{$args{orderby}}
4274                                                           <=> $classes->{$b}->{$args{attrib}}->{$args{orderby}}
4275                                                        } grep {
4276          46                                276            defined $classes->{$_}->{$args{attrib}}->{$args{orderby}}
4277                                                        } keys %$classes;
4278          46                                288      my @chosen;
4279          46                                170      my ($total, $count) = (0, 0);
4280          46                                191      foreach my $groupby ( @sorted ) {
4281         117    100    100                 1783         if ( 
      ***            50     66                        
                           100                        
      ***                   33                        
      ***                   66                        
4282                                                           (!$args{total} || $total < $args{total} )
4283                                                           && ( !$args{count} || $count < $args{count} )
4284                                                        ) {
4285         104                                450            push @chosen, [$groupby, 'top'];
4286                                                        }
4287                                                  
4288                                                        elsif ( $args{ol_attrib} && (!$args{ol_freq}
4289                                                           || $classes->{$groupby}->{$args{ol_attrib}}->{cnt} >= $args{ol_freq})
4290                                                        ) {
4291  ***      0                                  0            MKDEBUG && _d('Calculating statistical_metrics');
4292  ***      0                                  0            my $stats = $self->calculate_statistical_metrics(
4293                                                              $classes->{$groupby}->{$args{ol_attrib}}->{all},
4294                                                              $classes->{$groupby}->{$args{ol_attrib}}
4295                                                           );
4296  ***      0      0                           0            if ( $stats->{pct_95} >= $args{ol_limit} ) {
4297  ***      0                                  0               push @chosen, [$groupby, 'outlier'];
4298                                                           }
4299                                                        }
4300                                                  
4301         117                                649         $total += $classes->{$groupby}->{$args{attrib}}->{$args{orderby}};
4302         117                                387         $count++;
4303                                                     }
4304          46                                298      return @chosen;
4305                                                  }
4306                                                  
4307                                                  sub add_new_attributes {
4308         337                  337          1385      my ( $self, $event ) = @_;
4309  ***    337     50                        1506      return unless $event;
4310                                                  
4311         603                               1742      map {
4312        6297    100    100                62886         my $attrib = $_;
4313         603                               2697         $self->{attributes}->{$attrib}  = [$attrib];
4314         603                               2233         $self->{alt_attribs}->{$attrib} = make_alt_attrib($attrib);
4315         603                               1663         push @{$self->{all_attribs}}, $attrib;
             603                               2324   
4316         603                               1888         MKDEBUG && _d('Added new attribute:', $attrib);
4317                                                     }
4318                                                     grep {
4319         337                               2521         $_ ne $self->{groupby}
4320                                                        && !exists $self->{attributes}->{$_}
4321                                                        && !exists $self->{ignore_attribs}->{$_}
4322                                                     }
4323                                                     keys %$event;
4324                                                  
4325         337                               1577      return;
4326                                                  }
4327                                                  
4328                                                  sub get_attributes {
4329          45                   45           190      my ( $self ) = @_;
4330          45                                127      return @{$self->{all_attribs}};
              45                                675   
4331                                                  }
4332                                                  
4333                                                  sub events_processed {
4334           6                    6            29      my ( $self ) = @_;
4335           6                                 36      return $self->{n_events};
4336                                                  }
4337                                                  
4338                                                  sub make_alt_attrib {
4339         604                  604          2338      my ( @attribs ) = @_;
4340                                                  
4341         604                               1813      my $attrib = shift @attribs;  # Primary attribute.
4342  ***    604     50           153          4961      return sub {} unless @attribs;  # No alternates.
             153                                428   
4343                                                  
4344  ***      0                                  0      my @lines;
4345  ***      0                                  0      push @lines, 'sub { my ( $event ) = @_; my $alt_attrib;';
4346  ***      0                                  0      push @lines, map  {
4347  ***      0                                  0            "\$alt_attrib = '$_' if !defined \$alt_attrib "
4348                                                           . "&& exists \$event->{'$_'};"
4349                                                        } @attribs;
4350  ***      0                                  0      push @lines, 'return $alt_attrib; }';
4351  ***      0                                  0      MKDEBUG && _d('alt attrib sub for', $attrib, ':', @lines);
4352  ***      0                                  0      my $sub = eval join("\n", @lines);
4353  ***      0      0                           0      die if $EVAL_ERROR;
4354  ***      0                                  0      return $sub;
4355                                                  }
4356                                                  
4357                                                  sub _d {
4358  ***      0                    0             0      my ($package, undef, $line) = caller 0;
4359  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
4360  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
4361                                                          @_;
4362  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4363                                                  }
4364                                                  
4365                                                  1;
4366                                                  
4367                                                  # ###########################################################################
4368                                                  # End EventAggregator package
4369                                                  # ###########################################################################
4370                                                  
4371                                                  # ###########################################################################
4372                                                  # ReportFormatter package 5266
4373                                                  # ###########################################################################
4374                                                  package ReportFormatter;
4375                                                  
4376           6                    6            68   use strict;
               6                                 16   
               6                                107   
4377           6                    6            41   use warnings FATAL => 'all';
               6                                 15   
               6                                 47   
4378           6                    6            44   use English qw(-no_match_vars);
               6                                 19   
               6                                 39   
4379           6                    6            51   use List::Util qw(min max);
               6                                 14   
               6                                140   
4380                                                  
4381  ***      6            50      6            42   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 15   
               6                                118   
4382                                                  
4383           6                    6            37   use Data::Dumper;
               6                                 17   
               6                                 33   
4384                                                  $Data::Dumper::Indent    = 1;
4385                                                  $Data::Dumper::Sortkeys  = 1;
4386                                                  $Data::Dumper::Quotekeys = 0;
4387                                                  
4388                                                  sub new {
4389          10                   10            80      my ( $class, %args ) = @_;
4390          10                                 40      my @required_args = qw();
4391          10                                 48      foreach my $arg ( @required_args ) {
4392  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
4393                                                     }
4394          10                                104      my $self = {
4395                                                        underline_header  => 1,
4396                                                        line_prefix        => '# ',
4397                                                        line_width         => 78,
4398                                                        truncate_underline => 1,
4399                                                        %args,
4400                                                     };
4401          10                                142      return bless $self, $class;
4402                                                  }
4403                                                  
4404                                                  sub set_title {
4405           8                    8            37      my ( $self, $title ) = @_;
4406           8                                 34      $self->{title} = $title;
4407           8                                 22      return;
4408                                                  }
4409                                                  
4410                                                  sub set_columns {
4411          10                   10            50      my ( $self, @cols ) = @_;
4412          10                                 57      push @{$self->{cols}}, map {
              52                                136   
4413          10                                 41         my $col = $_;
4414  ***     52     50                         218         die "Column does not have a name" unless defined $col->{name};
4415  ***     52     50     33                  264         if ( $col->{fixed_wdith} && $col->{fixed_width} < length $col->{name} ) { 
4416  ***      0                                  0            die "Fixed width is less than the column name";
4417                                                        }
4418          52                                200         $col->{min_val_width} = length $col->{name};
4419          52                                188         $col->{max_val_width} = length $col->{name};
4420          52                                163         $col;
4421                                                     } @cols;
4422          10                                 37      return;
4423                                                  }
4424                                                  
4425                                                  sub add_line {
4426          30                   30           199      my ( $self, @vals ) = @_;
4427                                                  
4428          30                                102      my $n_cols = scalar @{$self->{cols}};
              30                                109   
4429          30                                 83      my $n_vals = scalar @vals;
4430  ***     30     50                         131      die "Number of columns ($n_cols) and values ($n_vals) do not match"
4431                                                        unless $n_cols == $n_vals;
4432                                                  
4433          30                                 77      my @line;
4434          30                                173      for my $i ( 0..$#vals ) {
4435         164                                583         my $col = $self->{cols}->[$i];
4436         164                                480         my $val = $vals[$i];
4437         164                                449         my $width = length $val;
4438  ***    164     50     33                  778         if ( $col->{fixed_width} && $width > $col->{fixed_width} ) {
4439  ***      0      0                           0            if ( $col->{truncate} ) {
4440  ***      0                                  0               $val  = substr($val, 0, $col->{fixed_width} - 3);
4441  ***      0                                  0               $val .= '...';
4442  ***      0                                  0               MKDEBUG && _d('Truncated', $vals[$i], 'to', $val);
4443                                                           }
4444                                                           else {
4445  ***      0                                  0               die "Value '$val' is too wide for column $col->{name}";
4446                                                           }
4447                                                        }
4448         164                                883         $col->{max_val_width} = max($width, $col->{max_val_width});
4449         164                                697         push @line, $val;
4450                                                     }
4451          30                                 90      push @{$self->{lines}}, \@line;
              30                               1248   
4452                                                  
4453          30                                151      return;
4454                                                  }
4455                                                  
4456                                                  sub get_report {
4457          10                   10            48      my ( $self ) = @_;
4458          10                                 35      my @lines;
4459  ***     10            50                   64      my $p = $self->{line_prefix} || '';
4460                                                  
4461          10    100                          30      my $n_cols = scalar @{$self->{cols}}
              10                                 72   
4462                                                                - ($self->{long_last_column} ? 2 : 1);
4463                                                  
4464          10                                 35      my $fmt = $p;
4465          10                                 30      my @col_fmts;
4466          10                                 59      for my $i ( 0..$n_cols ) {
4467          44                                161         my $col = $self->{cols}->[$i];
4468          44    100                         269         my $col_fmt = '%'
4469                                                                    . ($col->{right_justify} ? '' : '-')
4470                                                                    . "$col->{max_val_width}"
4471                                                                    . 's';
4472          44                                157         push @col_fmts, $col_fmt;
4473                                                     }
4474          10    100                          51      if ( $self->{long_last_column} ) {
4475           8                                 30         push @col_fmts, '%s';
4476                                                     }
4477          10                                 46      $fmt .= join(' ', @col_fmts);
4478          10                                 25      MKDEBUG && _d('Format:', $fmt);
4479                                                  
4480          10    100                          82      push @lines, sprintf "${p}$self->{title}" if $self->{title};
4481                                                  
4482          10                                233      (my $hdr_fmt = $fmt) =~ s/%([^-])/%-$1/g;
4483          10                                 42      push @lines, sprintf $hdr_fmt, map { $_->{name} } @{$self->{cols}};
              52                                228   
              10                                 51   
4484                                                  
4485  ***     10     50                          56      if ( $self->{underline_header} ) {
4486          10                                 36         my $underline_len = 0;
4487          52                                208         my @underlines = map {
4488          10                                 50            my $underline = '=' x $_->{max_val_width};
4489          52                                140            $underline_len += length $underline;
4490          52                                186            $underline;
4491          10                                 44         } @{$self->{cols}};
4492          10                                 44         $underline_len += (scalar @underlines) - 1;
4493  ***     10    100     66                  131         if ( $self->{truncate_underline}
4494                                                             && (2 + $underline_len) > $self->{line_width} ) {
4495           2                                  9            my $over = $self->{line_width} - (2 + $underline_len);
4496           2                                 10            $underlines[-1] = substr($underlines[-1], 0, $over);
4497                                                        }
4498                                                  
4499          10                                 64         push @lines, sprintf $fmt, @underlines;
4500                                                     }
4501                                                  
4502          10                                 33      foreach my $line ( @{$self->{lines}} ) {
              10                                 50   
4503          30                                248         push @lines, sprintf $fmt, @$line;
4504                                                     }
4505                                                  
4506          10                                216      return join("\n", @lines) . "\n";
4507                                                  }
4508                                                  
4509                                                  sub _d {
4510  ***      0                    0             0      my ($package, undef, $line) = caller 0;
4511  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
4512  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
4513                                                          @_;
4514  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4515                                                  }
4516                                                  
4517                                                  1;
4518                                                  
4519                                                  # ###########################################################################
4520                                                  # End ReportFormatter package
4521                                                  # ###########################################################################
4522                                                  
4523                                                  # ###########################################################################
4524                                                  # QueryReportFormatter package 5180
4525                                                  # ###########################################################################
4526                                                  
4527                                                  
4528                                                  package QueryReportFormatter;
4529                                                  
4530           6                    6            55   use strict;
               6                                 18   
               6                                 35   
4531           6                    6            45   use warnings FATAL => 'all';
               6                                 14   
               6                                 36   
4532           6                    6            38   use English qw(-no_match_vars);
               6                                 14   
               6                                 35   
4533                                                  Transformers->import(
4534                                                     qw(shorten micro_t parse_timestamp unix_timestamp
4535                                                        make_checksum percentage_of));
4536                                                  
4537           6                    6            48   use constant MKDEBUG           => $ENV{MKDEBUG};
               6                                 22   
               6                                 53   
4538           6                    6            38   use constant LINE_LENGTH       => 74;
               6                                 14   
               6                                 28   
4539           6                    6            36   use constant MAX_STRING_LENGTH => 10;
               6                                 18   
               6                                 28   
4540                                                  
4541                                                  my %formatting_function = (
4542                                                     ts => sub {
4543                                                        my ( $stats ) = @_;
4544                                                        my $min = parse_timestamp($stats->{min} || '');
4545                                                        my $max = parse_timestamp($stats->{max} || '');
4546                                                        return $min && $max ? "$min to $max" : '';
4547                                                     },
4548                                                  );
4549                                                  
4550                                                  my $bool_format = '# %3s%% %-6s %s';
4551                                                  
4552                                                  sub new {
4553          45                   45           229      my ( $class, %args ) = @_;
4554          45                                398      return bless { }, $class;
4555                                                  }
4556                                                  
4557                                                  sub header {
4558  ***      0                    0             0      my ($self) = @_;
4559                                                  
4560  ***      0                                  0      my ( $rss, $vsz, $user, $system ) = ( 0, 0, 0, 0 );
4561  ***      0                                  0      my $result = '';
4562  ***      0                                  0      eval {
4563  ***      0                                  0         my $mem = `ps -o rss,vsz -p $PID 2>&1`;
4564  ***      0                                  0         ( $rss, $vsz ) = $mem =~ m/(\d+)/g;
4565  ***      0                                  0         ( $user, $system ) = times();
4566  ***      0             0                    0         $result = sprintf "# %s user time, %s system time, %s rss, %s vsz\n",
      ***                    0                        
4567                                                           micro_t( $user,   p_s => 1, p_ms => 1 ),
4568                                                           micro_t( $system, p_s => 1, p_ms => 1 ),
4569                                                           shorten( ($rss || 0) * 1_024 ),
4570                                                           shorten( ($vsz || 0) * 1_024 );
4571                                                     };
4572  ***      0      0                           0      if ( $EVAL_ERROR ) {
4573  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
4574                                                     }
4575  ***      0                                  0      return $result;
4576                                                  }
4577                                                  
4578                                                  sub global_report {
4579           6                    6            60      my ( $self, $ea, %opts ) = @_;
4580           6                                 47      my $stats = $ea->results;
4581           6                                 18      my @result;
4582                                                  
4583  ***      6            50                   49      my $global_cnt = $stats->{globals}->{$opts{worst}}->{cnt} || 0;
4584                                                  
4585           6                                 22      my ($qps, $conc) = (0, 0);
4586  ***      6    100     33                  177      if ( $global_cnt && $stats->{globals}->{ts}
      ***                   50                        
      ***                   50                        
      ***                   66                        
4587                                                        && ($stats->{globals}->{ts}->{max} || '')
4588                                                           gt ($stats->{globals}->{ts}->{min} || '')
4589                                                     ) {
4590           5                                 16         eval {
4591           5                                 57            my $min  = parse_timestamp($stats->{globals}->{ts}->{min});
4592           5                                 36            my $max  = parse_timestamp($stats->{globals}->{ts}->{max});
4593           5                                 47            my $diff = unix_timestamp($max) - unix_timestamp($min);
4594           5                                 23            $qps     = $global_cnt / $diff;
4595           5                                 34            $conc    = $stats->{globals}->{$opts{worst}}->{sum} / $diff;
4596                                                        };
4597                                                     }
4598                                                  
4599                                                     MKDEBUG && _d('global_cnt:', $global_cnt, 'unique:',
4600           6                                 17         scalar keys %{$stats->{classes}}, 'qps:', $qps, 'conc:', $conc);
4601           6                                 43      my $line = sprintf(
4602                                                        '# Overall: %s total, %s unique, %s QPS, %sx concurrency ',
4603                                                        shorten($global_cnt, d=>1_000),
4604           6           100                   55         shorten(scalar keys %{$stats->{classes}}, d=>1_000),
                           100                        
4605                                                        shorten($qps  || 0, d=>1_000),
4606                                                        shorten($conc || 0, d=>1_000));
4607           6                                 39      $line .= ('_' x (LINE_LENGTH - length($line)));
4608           6                                 29      push @result, $line;
4609                                                  
4610           6                                 48      my ($format, @headers) = make_header('global');
4611           6                                 52      push @result, sprintf($format, '', @headers);
4612                                                  
4613           6                                 19      foreach my $attrib ( sort_attribs($ea, @{$opts{select}}) ) {
               6                                 53   
4614          65                                251         my $attrib_type = $ea->type_for($attrib);
4615  ***     65     50                         243         next unless $attrib_type; 
4616  ***     65     50                         307         next unless exists $stats->{globals}->{$attrib};
4617          65    100                         239         if ( $formatting_function{$attrib} ) { # Handle special cases
4618          60                                213            push @result, sprintf $format, make_label($attrib),
4619                                                              $formatting_function{$attrib}->($stats->{globals}->{$attrib}),
4620           6                                 34               (map { '' } 0..9); # just for good measure
4621                                                        }
4622                                                        else {
4623          59                                233            my $store = $stats->{globals}->{$attrib};
4624          59                                138            my @values;
4625          59    100                         233            if ( $attrib_type eq 'num' ) {
                    100                               
      ***            50                               
4626          44    100                         301               my $func = $attrib =~ m/time$/ ? \&micro_t : \&shorten;
4627          44                                 98               MKDEBUG && _d('Calculating global statistical_metrics for', $attrib);
4628          44                                227               my $metrics = $ea->calculate_statistical_metrics($store->{all}, $store);
4629          44                                261               @values = (
4630          44                                285                  @{$store}{qw(sum min max)},
4631                                                                 $store->{sum} / $store->{cnt},
4632          44                                159                  @{$metrics}{qw(pct_95 stddev median)},
4633                                                              );
4634  ***     44     50                         173               @values = map { defined $_ ? $func->($_) : '' } @values;
             308                               1313   
4635                                                           }
4636                                                           elsif ( $attrib_type eq 'string' ) {
4637           6                                 16               MKDEBUG && _d('Ignoring string attrib', $attrib);
4638           6                                 25               next;
4639                                                           }
4640                                                           elsif ( $attrib_type eq 'bool' ) {
4641  ***      9     50     33                   91               if ( $store->{sum} > 0 || !$opts{no_zero_bool} ) {
4642  ***      0                                  0                  push @result,
4643                                                                    sprintf $bool_format, format_bool_attrib($store), $attrib;
4644                                                              }
4645                                                           }
4646                                                           else {
4647  ***      0                                  0               @values = ('', $store->{min}, $store->{max}, '', '', '', '');
4648                                                           }
4649                                                  
4650          53    100                         362            push @result, sprintf $format, make_label($attrib), @values
4651                                                              unless $attrib_type eq 'bool';  # bool does its own thing.
4652                                                        }
4653                                                     }
4654                                                  
4655           6                                 40      return join("\n", map { s/\s+$//; $_ } @result) . "\n";
              62                                327   
              62                                327   
4656                                                  }
4657                                                  
4658                                                  sub event_report {
4659          89                   89          1043      my ( $self, $ea, %opts ) = @_;
4660          89                                470      my $stats = $ea->results;
4661          89                                275      my @result;
4662                                                  
4663          89                                429      my $store = $stats->{classes}->{$opts{where}};
4664  ***     89     50                         361      return "# No such event $opts{where}\n" unless $store;
4665          89                                450      my $sample = $stats->{samples}->{$opts{where}};
4666                                                  
4667          89                                545      my $global_cnt = $stats->{globals}->{$opts{worst}}->{cnt};
4668          89                                391      my $class_cnt  = $store->{$opts{worst}}->{cnt};
4669                                                  
4670          89                                333      my ($qps, $conc) = (0, 0);
4671  ***     89    100     66                 1975      if ( $global_cnt && $store->{ts}
                           100                        
                           100                        
                           100                        
4672                                                        && ($store->{ts}->{max} || '')
4673                                                           gt ($store->{ts}->{min} || '')
4674                                                     ) {
4675          10                                 40         eval {
4676          10                                 89            my $min  = parse_timestamp($store->{ts}->{min});
4677          10                                 70            my $max  = parse_timestamp($store->{ts}->{max});
4678          10                                 97            my $diff = unix_timestamp($max) - unix_timestamp($min);
4679          10                                 38            $qps     = $class_cnt / $diff;
4680          10                                 60            $conc    = $store->{$opts{worst}}->{sum} / $diff;
4681                                                        };
4682                                                     }
4683                                                  
4684  ***     89    100     50                 1429      my $line = sprintf(
                           100                        
                           100                        
                           100                        
4685                                                        '# %s %d: %s QPS, %sx concurrency, ID 0x%s at byte %d ',
4686                                                        ($ea->{groupby} eq 'fingerprint' ? 'Query' : 'Item'),
4687                                                        $opts{rank} || 0,
4688                                                        shorten($qps  || 0, d=>1_000),
4689                                                        shorten($conc || 0, d=>1_000),
4690                                                        make_checksum($opts{where}),
4691                                                        $sample->{pos_in_log} || 0);
4692          89                                485      $line .= ('_' x (LINE_LENGTH - length($line)));
4693          89                                376      push @result, $line;
4694                                                  
4695          89    100                         414      if ( $opts{reason} ) {
4696  ***     57     50                         447         push @result, "# This item is included in the report because it matches "
4697                                                           . ($opts{reason} eq 'top' ? '--limit.' : '--outliers.');
4698                                                     }
4699                                                  
4700          89                                508      my ($format, @headers) = make_header();
4701          89                                665      push @result, sprintf($format, '', @headers);
4702                                                  
4703         801                               2551      push @result, sprintf
4704                                                        $format, 'Count', percentage_of($class_cnt, $global_cnt), $class_cnt,
4705          89                                545            map { '' } (1 ..9);
4706                                                  
4707          89                                374      foreach my $attrib ( sort_attribs($ea, @{$opts{select}}) ) {
              89                                649   
4708        1176                               4560         my $attrib_type = $ea->type_for($attrib);
4709        1176    100                        4285         next unless $attrib_type; 
4710        1150    100                        4734         next unless exists $store->{$attrib};
4711        1033                               3316         my $vals = $store->{$attrib};
4712        1033    100                        4955         next unless scalar %$vals;
4713        1029    100                        3967         if ( $formatting_function{$attrib} ) { # Handle special cases
4714         780                               2491            push @result, sprintf $format, make_label($attrib),
4715                                                              $formatting_function{$attrib}->($vals),
4716          78                                411               (map { '' } 0..9); # just for good measure
4717                                                        }
4718                                                        else {
4719         951                               2223            my @values;
4720         951                               2239            my $pct;
4721         951    100                        3951            if ( $attrib_type eq 'num' ) {
                    100                               
      ***            50                               
4722         530    100                        2695               my $func = $attrib =~ m/time$/ ? \&micro_t : \&shorten;
4723         530                               2795               my $metrics = $ea->calculate_statistical_metrics($vals->{all}, $vals);
4724         530                               3248               @values = (
4725         530                               3290                  @{$vals}{qw(sum min max)},
4726                                                                 $vals->{sum} / $vals->{cnt},
4727         530                               1817                  @{$metrics}{qw(pct_95 stddev median)},
4728                                                              );
4729  ***    530     50                        1995               @values = map { defined $_ ? $func->($_) : '' } @values;
            3710                              15756   
4730         530                               3903               $pct = percentage_of($vals->{sum},
4731                                                                 $stats->{globals}->{$attrib}->{sum});
4732                                                           }
4733                                                           elsif ( $attrib_type eq 'string' ) {
4734        2060                               6019               push @values,
4735                                                                 format_string_list($vals),
4736         206                                944                  (map { '' } 0..9); # just for good measure
4737         206                                709               $pct = '';
4738                                                           }
4739                                                           elsif ( $attrib_type eq 'bool' ) {
4740  ***    215    100     66                 1973               if ( $vals->{sum} > 0 || !$opts{no_zero_bool} ) {
4741          14                                 75                  push @result,
4742                                                                    sprintf $bool_format, format_bool_attrib($vals), $attrib;
4743                                                              }
4744                                                           }
4745                                                           else {
4746  ***      0                                  0               @values = ('', $vals->{min}, $vals->{max}, '', '', '', '');
4747  ***      0                                  0               $pct = 0;
4748                                                           }
4749                                                  
4750         951    100                        5503            push @result, sprintf $format, make_label($attrib), $pct, @values
4751                                                              unless $attrib_type eq 'bool';  # bool does its own thing.
4752                                                        }
4753                                                     }
4754                                                  
4755          89                                489      return join("\n", map { s/\s+$//; $_ } @result) . "\n";
            1152                               5401   
            1152                               4885   
4756                                                  }
4757                                                  
4758                                                  sub chart_distro {
4759          89                   89           672      my ( $self, $ea, %opts ) = @_;
4760          89                                448      my $stats = $ea->results;
4761          89                                543      my $store = $stats->{classes}->{$opts{where}}->{$opts{attribute}};
4762          89                                336      my $vals  = $store->{all};
4763  ***     89     50     50                  926      return "" unless defined $vals && scalar @$vals;
4764          89                                489      my @buck_tens = $ea->buckets_of(10);
4765          89                               4635      my @distro = map { 0 } (0 .. 7);
             712                               2181   
4766          89                               4113      map { $distro[$buck_tens[$_]] += $vals->[$_] } (1 .. @$vals - 1);
           88911                             340986   
4767                                                  
4768          89                               4079      my $max_val = 0;
4769          89                                216      my $vals_per_mark; # number of vals represented by 1 #-mark
4770          89                                250      my $max_disp_width = 64;
4771          89                                310      my $bar_fmt = "# %5s%s";
4772          89                                664      my @distro_labels = qw(1us 10us 100us 1ms 10ms 100ms 1s 10s+);
4773          89                                572      my @results = "# $opts{attribute} distribution";
4774                                                  
4775          89                                464      foreach my $n_vals ( @distro ) {
4776         712    100                        2943         $max_val = $n_vals if $n_vals > $max_val;
4777                                                     }
4778          89                                359      $vals_per_mark = $max_val / $max_disp_width;
4779                                                  
4780          89                                695      foreach my $i ( 0 .. $#distro ) {
4781         712                               2148         my $n_vals = $distro[$i];
4782         712           100                 3178         my $n_marks = $n_vals / ($vals_per_mark || 1);
4783  ***    712     50     66                 5299         $n_marks = 1 if $n_marks < 1 && $n_vals > 0;
4784         712    100                        2994         my $bar = ($n_marks ? '  ' : '') . '#' x $n_marks;
4785         712                               3583         push @results, sprintf $bar_fmt, $distro_labels[$i], $bar;
4786                                                     }
4787                                                  
4788          89                               2791      return join("\n", @results) . "\n";
4789                                                  }
4790                                                  
4791                                                  sub make_header {
4792          95                   95           419      my ( $global ) = @_;
4793          95                                354      my $format = "# %-9s %6s %7s %7s %7s %7s %7s %7s %7s";
4794          95                                610      my @headers = qw(pct total min max avg 95% stddev median);
4795          95    100                         373      if ( $global ) {
4796           6                                 76         $format =~ s/%(\d+)s/' ' x $1/e;
               6                                 53   
4797           6                                 18         shift @headers;
4798                                                     }
4799          95                                949      return $format, @headers;
4800                                                  }
4801                                                  
4802                                                  sub make_label {
4803         864                  864          3164      my ( $val ) = @_;
4804                                                  
4805         864    100                        3522      if ( $val =~ m/^InnoDB/ ) {
4806          84                                664         $val =~ s/^InnoDB_(\w+)/IDB_$1/;
4807          84                                432         $val =~ s/r_(\w+)/r$1/;
4808                                                     }
4809                                                  
4810                                                     return  $val eq 'ts'         ? 'Time range'
4811                                                           : $val eq 'user'       ? 'Users'
4812                                                           : $val eq 'db'         ? 'Databases'
4813                                                           : $val eq 'Query_time' ? 'Exec time'
4814                                                           : $val eq 'host'       ? 'Hosts'
4815                                                           : $val eq 'Error_no'   ? 'Errors'
4816         864    100                        8320            : do { $val =~ s/_/ /g; $val = substr($val, 0, 9); $val };
             481    100                        2258   
             481    100                        1707   
             481    100                        3798   
                    100                               
                    100                               
4817                                                  }
4818                                                  
4819                                                  sub format_bool_attrib {
4820          14                   14            69      my ( $stats ) = @_;
4821          14                                 70      my $p_true  = percentage_of($stats->{sum},  $stats->{cnt});
4822  ***     14            50                   92      my $n_true = '(' . shorten($stats->{sum} || 0, d=>1_000, p=>0) . ')';
4823          14                                 80      return $p_true, $n_true;
4824                                                  }
4825                                                  
4826                                                  sub format_string_list {
4827         206                  206           762      my ( $stats ) = @_;
4828  ***    206     50                         897      if ( exists $stats->{unq} ) {
4829         206                                682         my $cnt_for = $stats->{unq};
4830         206    100                        1208         if ( 1 == keys %$cnt_for ) {
4831         200                                886            my ($str) = keys %$cnt_for;
4832  ***    200     50                         862            $str = substr($str, 0, LINE_LENGTH - 30) . '...'
4833                                                              if length $str > LINE_LENGTH - 30;
4834         200                                969            return (1, $str);
4835                                                        }
4836           6                                 37         my $line = '';
4837  ***      6     50                          12         my @top = sort { $cnt_for->{$b} <=> $cnt_for->{$a} || $a cmp $b }
               6                                 78   
4838                                                                       keys %$cnt_for;
4839           6                                 38         my $i = 0;
4840           6                                 34         foreach my $str ( @top ) {
4841          12                                 39            my $print_str;
4842          12    100                          49            if ( length $str > MAX_STRING_LENGTH ) {
4843           1                                  4               $print_str = substr($str, 0, MAX_STRING_LENGTH) . '...';
4844                                                           }
4845                                                           else {
4846          11                                 33               $print_str = $str;
4847                                                           }
4848  ***     12     50                          59            last if (length $line) + (length $print_str)  > LINE_LENGTH - 27;
4849          12                                 57            $line .= "$print_str ($cnt_for->{$str}), ";
4850          12                                 43            $i++;
4851                                                        }
4852           6                                 47         $line =~ s/, $//;
4853  ***      6     50                          27         if ( $i < @top ) {
4854  ***      0                                  0            $line .= "... " . (@top - $i) . " more";
4855                                                        }
4856           6                                 41         return (scalar keys %$cnt_for, $line);
4857                                                     }
4858                                                     else {
4859  ***      0                                  0         return ($stats->{cnt});
4860                                                     }
4861                                                  }
4862                                                  
4863                                                  sub sort_attribs {
4864          95                   95           915      my ( $ea, @attribs ) = @_;
4865          95                                924      my %basic_attrib = (
4866                                                        Query_time    => 0,
4867                                                        Lock_time     => 1,
4868                                                        Rows_sent     => 2,
4869                                                        Rows_examined => 3,
4870                                                        user          => 4,
4871                                                        host          => 5,
4872                                                        db            => 6,
4873                                                        ts            => 7,
4874                                                     );
4875          95                                232      my @basic_attribs;
4876          95                                253      my @non_bool_attribs;
4877          95                                246      my @bool_attribs;
4878                                                  
4879                                                     ATTRIB:
4880          95                                440      foreach my $attrib ( @attribs ) {
4881        1241    100                        4341         if ( exists $basic_attrib{$attrib} ) {
4882         626                               2215            push @basic_attribs, $attrib;
4883                                                        }
4884                                                        else {
4885  ***    615    100     50                 2222            if ( ($ea->type_for($attrib) || '') ne 'bool' ) {
4886         384                               1611               push @non_bool_attribs, $attrib;
4887                                                           }
4888                                                           else {
4889         231                                908               push @bool_attribs, $attrib;
4890                                                           }
4891                                                        }
4892                                                     }
4893                                                  
4894          95                                277      @non_bool_attribs = sort { uc $a cmp uc $b } @non_bool_attribs;
             640                               1932   
4895          95                                317      @bool_attribs     = sort { uc $a cmp uc $b } @bool_attribs;
             379                               1046   
4896        1037                               3250      @basic_attribs    = sort {
4897          95                                184            $basic_attrib{$a} <=> $basic_attrib{$b} } @basic_attribs;
4898                                                  
4899          95                               1117      return @basic_attribs, @non_bool_attribs, @bool_attribs;
4900                                                  }
4901                                                  
4902                                                  sub _d {
4903  ***      0                    0             0      my ($package, undef, $line) = caller 0;
4904  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
4905  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
4906                                                          @_;
4907  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4908                                                  }
4909                                                  
4910                                                  1;
4911                                                  
4912                                                  # ###########################################################################
4913                                                  # End QueryReportFormatter package
4914                                                  # ###########################################################################
4915                                                  
4916                                                  # ###########################################################################
4917                                                  # EventTimeline package 5266
4918                                                  # ###########################################################################
4919                                                  
4920                                                  
4921                                                  package EventTimeline;
4922                                                  
4923                                                  
4924           6                    6            61   use strict;
               6                                 28   
               6                                 50   
4925           6                    6            39   use warnings FATAL => 'all';
               6                                 15   
               6                                 42   
4926           6                    6            39   use English qw(-no_match_vars);
               6                                 15   
               6                                 35   
4927                                                  Transformers->import(qw(parse_timestamp secs_to_time unix_timestamp));
4928                                                  
4929  ***      6            50      6            48   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 14   
               6                                109   
4930           6                    6            37   use constant KEY     => 0;
               6                                 20   
               6                                 30   
4931           6                    6            38   use constant CNT     => 1;
               6                                 20   
               6                                 29   
4932           6                    6            37   use constant ATT     => 2;
               6                                 14   
               6                                 27   
4933                                                  
4934                                                  sub new {
4935           1                    1            10      my ( $class, %args ) = @_;
4936           1                                  7      foreach my $arg ( qw(groupby attributes) ) {
4937  ***      2     50                          14         die "I need a $arg argument" unless $args{$arg};
4938                                                     }
4939                                                  
4940           1                                  4      my %is_groupby = map { $_ => 1 } @{$args{groupby}};
               1                                 12   
               1                                  4   
4941                                                  
4942           2                                 37      return bless {
4943                                                        groupby    => $args{groupby},
4944           1                                  5         attributes => [ grep { !$is_groupby{$_} } @{$args{attributes}} ],
               1                                  5   
4945                                                        results    => [],
4946                                                     }, $class;
4947                                                  }
4948                                                  
4949                                                  sub reset_aggregated_data {
4950           1                    1             7      my ( $self ) = @_;
4951           1                                  7      $self->{results} = [];
4952                                                  }
4953                                                  
4954                                                  sub aggregate {
4955           8                    8            32      my ( $self, $event ) = @_;
4956           8                                 31      my $handler = $self->{handler};
4957           8    100                          33      if ( !$handler ) {
4958           1                                  7         $handler = $self->make_handler($event);
4959           1                                  5         $self->{handler} = $handler;
4960                                                     }
4961  ***      8     50                          36      return unless $handler;
4962           8                                 36      $handler->($event);
4963                                                  }
4964                                                  
4965                                                  sub results {
4966           1                    1             4      my ( $self ) = @_;
4967           1                                 15      return $self->{results};
4968                                                  }
4969                                                  
4970                                                  sub make_handler {
4971           1                    1             4      my ( $self, $event ) = @_;
4972                                                  
4973           1                                 10      my $float_re = qr{[+-]?(?:(?=\d|[.])\d*(?:[.])\d{0,})?(?:[E](?:[+-]?\d+)|)}i;
4974           1                                  3      my @lines; # lines of code for the subroutine
4975                                                  
4976           1                                  3      foreach my $attrib ( @{$self->{attributes}} ) {
               1                                  6   
4977           2                                 12         my ($val) = $event->{$attrib};
4978  ***      2     50                           9         next unless defined $val; # Can't decide type if it's undef.
4979                                                  
4980  ***      2     50                          65         my $type = $val  =~ m/^(?:\d+|$float_re)$/o ? 'num'
                    100                               
4981                                                                 : $val  =~ m/^(?:Yes|No)$/         ? 'bool'
4982                                                                 :                                    'string';
4983           2                                  5         MKDEBUG && _d('Type for', $attrib, 'is', $type, '(sample:', $val, ')');
4984           2                                 10         $self->{type_for}->{$attrib} = $type;
4985                                                  
4986           2                                 15         push @lines, (
4987                                                           "\$val = \$event->{$attrib};",
4988                                                           'defined $val && do {',
4989                                                           "# type: $type",
4990                                                           "\$store = \$last->[ATT]->{$attrib} ||= {};",
4991                                                        );
4992                                                  
4993  ***      2     50                          13         if ( $type eq 'bool' ) {
4994  ***      0                                  0            push @lines, q{$val = $val eq 'Yes' ? 1 : 0;};
4995  ***      0                                  0            $type = 'num';
4996                                                        }
4997           2    100                           7         my $op   = $type eq 'num' ? '<' : 'lt';
4998           2                                 11         push @lines, (
4999                                                           '$store->{min} = $val if !defined $store->{min} || $val '
5000                                                              . $op . ' $store->{min};',
5001                                                        );
5002           2    100                           7         $op = ($type eq 'num') ? '>' : 'gt';
5003           2                                  8         push @lines, (
5004                                                           '$store->{max} = $val if !defined $store->{max} || $val '
5005                                                              . $op . ' $store->{max};',
5006                                                        );
5007           2    100                           8         if ( $type eq 'num' ) {
5008           1                                  4            push @lines, '$store->{sum} += $val;';
5009                                                        }
5010           2                                 10         push @lines, '};';
5011                                                     }
5012                                                  
5013           1                                 10      unshift @lines, (
5014                                                        'sub {',
5015                                                        'my ( $event ) = @_;',
5016                                                        'my ($val, $last, $store);', # NOTE: define all variables here
5017                                                        '$last = $results->[-1];',
5018                                                        'if ( !$last || '
5019                                                           . join(' || ',
5020           1                                  8               map { "\$last->[KEY]->[$_] ne (\$event->{$self->{groupby}->[$_]} || 0)" }
5021           1                                 19                   (0 .. @{$self->{groupby}} -1))
5022                                                           . ' ) {',
5023                                                        '  $last = [['
5024                                                           . join(', ',
5025           1                                  5               map { "(\$event->{$self->{groupby}->[$_]} || 0)" }
5026           1                                  6                   (0 .. @{$self->{groupby}} -1))
5027                                                           . '], 0, {} ];',
5028                                                        '  push @$results, $last;',
5029                                                        '}',
5030                                                        '++$last->[CNT];',
5031                                                     );
5032           1                                  4      push @lines, '}';
5033           1                                  4      my $results = $self->{results}; # Referred to by the eval
5034           1                                  8      my $code = join("\n", @lines);
5035           1                                  3      $self->{code} = $code;
5036                                                  
5037           1                                  3      MKDEBUG && _d('Timeline handler:', $code);
5038           1                                  2      my $sub = eval $code;
5039  ***      1     50                           5      die if $EVAL_ERROR;
5040           1                                  8      return $sub;
5041                                                  }
5042                                                  
5043                                                  sub report {
5044           1                    1             5      my ( $self, $results, $callback ) = @_;
5045           1                                  8      $callback->("# " . ('#' x 72) . "\n");
5046           1                                  4      $callback->("# " . join(',', @{$self->{groupby}}) . " report\n");
               1                                  7   
5047           1                                  7      $callback->("# " . ('#' x 72) . "\n");
5048           1                                  6      foreach my $res ( @$results ) {
5049           8                                 20         my $t;
5050           8                                 21         my @vals;
5051  ***      8     50     33                   83         if ( ($t = $res->[ATT]->{ts}) && $t->{min} ) {
5052           8                                 38            my $min = parse_timestamp($t->{min});
5053           8                                 30            push @vals, $min;
5054  ***      8     50     33                   75            if ( $t->{max} && $t->{max} gt $t->{min} ) {
5055  ***      0                                  0               my $max  = parse_timestamp($t->{max});
5056  ***      0                                  0               my $diff = secs_to_time(unix_timestamp($max) - unix_timestamp($min));
5057  ***      0                                  0               push @vals, $diff;
5058                                                           }
5059                                                           else {
5060           8                                 25               push @vals, '0:00';
5061                                                           }
5062                                                        }
5063                                                        else {
5064  ***      0                                  0            push @vals, ('', '');
5065                                                        }
5066           8                                 52         $callback->(sprintf("# %19s %7s %3d %s\n", @vals, $res->[CNT], $res->[KEY]->[0]));
5067                                                     }
5068                                                  }
5069                                                  
5070                                                  sub _d {
5071  ***      0                    0             0      my ($package, undef, $line) = caller 0;
5072  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
5073  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
5074                                                          @_;
5075  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
5076                                                  }
5077                                                  
5078                                                  1;
5079                                                  
5080                                                  # ###########################################################################
5081                                                  # End EventTimeline package
5082                                                  # ###########################################################################
5083                                                  
5084                                                  # ###########################################################################
5085                                                  # QueryParser package 5444
5086                                                  # ###########################################################################
5087                                                  package QueryParser;
5088                                                  
5089           6                    6            50   use strict;
               6                                 15   
               6                                 46   
5090           6                    6            41   use warnings FATAL => 'all';
               6                                 16   
               6                                 34   
5091           6                    6            35   use English qw(-no_match_vars);
               6                                 21   
               6                                 33   
5092                                                  
5093  ***      6            50      6            43   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 16   
               6                                 95   
5094                                                  our $tbl_ident = qr/(?:`[^`]+`|\w+)(?:\.(?:`[^`]+`|\w+))?/;
5095                                                  our $tbl_regex = qr{
5096                                                           \b(?:FROM|JOIN|(?<!KEY\s)UPDATE|INTO) # Words that precede table names
5097                                                           \b\s*
5098                                                           \(?                                   # Optional paren around tables
5099                                                           ($tbl_ident
5100                                                              (?: (?:\s+ (?:AS\s+)? \w+)?, \s*$tbl_ident )*
5101                                                           )
5102                                                        }xio;
5103                                                  our $has_derived = qr{
5104                                                        \b(?:FROM|JOIN|,)
5105                                                        \s*\(\s*SELECT
5106                                                     }xi;
5107                                                  
5108                                                  our $data_def_stmts = qr/(?:CREATE|ALTER|TRUNCATE|DROP|RENAME)/i;
5109                                                  
5110                                                  our $data_manip_stmts = qr/(?:INSERT|UPDATE|DELETE|REPLACE)/i;
5111                                                  
5112                                                  sub new {
5113           6                    6            26      my ( $class ) = @_;
5114           6                                 66      bless {}, $class;
5115                                                  }
5116                                                  
5117                                                  sub get_tables {
5118         205                  205          1349      my ( $self, $query ) = @_;
5119  ***    205     50                         866      return unless $query;
5120         205                                477      MKDEBUG && _d('Getting tables for', $query);
5121                                                  
5122         205                               1667      my ( $ddl_stmt ) = $query =~ m/^\s*($data_def_stmts)\b/i;
5123         205    100                         777      if ( $ddl_stmt ) {
5124           4                                 10         MKDEBUG && _d('Special table type:', $ddl_stmt);
5125           4                                 14         $query =~ s/IF NOT EXISTS//i;
5126           4    100                          29         if ( $query =~ m/$ddl_stmt DATABASE\b/i ) {
5127           2                                  5            MKDEBUG && _d('Query alters a database, not a table');
5128           2                                 11            return ();
5129                                                        }
5130  ***      2     50     33                   37         if ( $ddl_stmt =~ m/CREATE/i && $query =~ m/$ddl_stmt\b.+?\bSELECT\b/i ) {
5131  ***      0                                  0            my ($select) = $query =~ m/\b(SELECT\b.+)/is;
5132  ***      0                                  0            MKDEBUG && _d('CREATE TABLE ... SELECT:', $select);
5133  ***      0                                  0            return $self->get_tables($select);
5134                                                        }
5135           2                                 40         my ($tbl) = $query =~ m/TABLE\s+($tbl_ident)(\s+.*)?/i;
5136           2                                  5         MKDEBUG && _d('Matches table:', $tbl);
5137           2                                  8         return ($tbl);
5138                                                     }
5139                                                  
5140         201                               8037      $query =~ s/ (?:LOW_PRIORITY|IGNORE|STRAIGHT_JOIN)//ig;
5141                                                  
5142         201    100                         943      if ( $query =~ /^\s*LOCK TABLES/i ) {
5143           2                                 10         MKDEBUG && _d('Special table type: LOCK TABLES');
5144           2                                 17         $query =~ s/^(\s*LOCK TABLES\s+)//;
5145           2                                 19         $query =~ s/\s+(?:READ|WRITE|LOCAL)+\s*//g;
5146           2                                  7         MKDEBUG && _d('Locked tables:', $query);
5147           2                                  8         $query = "FROM $query";
5148                                                     }
5149                                                  
5150         201                               2366      $query =~ s/\\["']//g;                # quoted strings
5151         201                               2143      $query =~ s/".*?"/?/sg;               # quoted strings
5152         201                              19485      $query =~ s/'.*?'/?/sg;               # quoted strings
5153                                                  
5154         201                                510      my @tables;
5155         201                              42796      foreach my $tbls ( $query =~ m/$tbl_regex/gio ) {
5156         155                                346         MKDEBUG && _d('Match tables:', $tbls);
5157                                                  
5158         155    100                         671         next if $tbls =~ m/\ASELECT\b/i;
5159                                                  
5160         153                                745         foreach my $tbl ( split(',', $tbls) ) {
5161         159                               1846            $tbl =~ s/\s*($tbl_ident)(\s+.*)?/$1/gio;
5162                                                  
5163  ***    159     50                         798            if ( $tbl !~ m/[a-zA-Z]/ ) {
5164  ***      0                                  0               MKDEBUG && _d('Skipping suspicious table name:', $tbl);
5165  ***      0                                  0               next;
5166                                                           }
5167                                                  
5168         159                                943            push @tables, $tbl;
5169                                                        }
5170                                                     }
5171         201                               1044      return @tables;
5172                                                  }
5173                                                  
5174                                                  sub has_derived_table {
5175           3                    3            15      my ( $self, $query ) = @_;
5176           3                                 31      my $match = $query =~ m/$has_derived/;
5177           3                                  9      MKDEBUG && _d($query, 'has ' . ($match ? 'a' : 'no') . ' derived table');
5178           3                                 18      return $match;
5179                                                  }
5180                                                  
5181                                                  sub get_aliases {
5182  ***      0                    0             0      my ( $self, $query ) = @_;
5183  ***      0      0                           0      return unless $query;
5184  ***      0                                  0      my $aliases;
5185                                                  
5186  ***      0                                  0      $query =~ s/ (?:LOW_PRIORITY|IGNORE|STRAIGHT_JOIN)//ig;
5187                                                  
5188  ***      0                                  0      $query =~ s/ (?:INNER|OUTER|CROSS|LEFT|RIGHT|NATURAL)//ig;
5189                                                  
5190  ***      0                                  0      my ($tbl_refs, $from) = $query =~ m{
5191                                                        (
5192                                                           (FROM|INTO|UPDATE)\b\s*   # Keyword before table refs
5193                                                           .+?                       # Table refs
5194                                                        )
5195                                                        (?:\s+|\z)                   # If the query does not end with the table
5196                                                        (?:WHERE|ORDER|LIMIT|HAVING|SET|VALUES|\z) # Keyword after table refs
5197                                                     }ix;
5198                                                  
5199  ***      0      0      0                    0      die "Failed to parse table references from $query"
5200                                                        unless $tbl_refs && $from;
5201                                                  
5202  ***      0                                  0      MKDEBUG && _d('tbl refs:', $tbl_refs);
5203                                                  
5204  ***      0                                  0      my $before_tbl = qr/(?:,|JOIN|\s|$from)+/i;
5205                                                  
5206  ***      0                                  0      my $after_tbl  = qr/(?:,|JOIN|ON|USING|\z)/i;
5207                                                  
5208  ***      0                                  0      $tbl_refs =~ s/ = /=/g;
5209                                                  
5210  ***      0                                  0      while (
5211                                                        $tbl_refs =~ m{
5212                                                           $before_tbl\b\s*
5213                                                              ( ($tbl_ident) (?:\s+ (?:AS\s+)? (\w+))? )
5214                                                           \s*$after_tbl
5215                                                        }xgio )
5216                                                     {
5217  ***      0                                  0         my ( $tbl_ref, $db_tbl, $alias ) = ($1, $2, $3);
5218  ***      0                                  0         MKDEBUG && _d('Match table:', $tbl_ref);
5219                                                  
5220  ***      0      0                           0         if ( $tbl_ref =~ m/^AS\s+\w+/i ) {
5221  ***      0                                  0            MKDEBUG && _d('Subquery', $tbl_ref);
5222  ***      0                                  0            $aliases->{$alias} = undef;
5223  ***      0                                  0            next;
5224                                                        }
5225                                                  
5226  ***      0                                  0         my ( $db, $tbl ) = $db_tbl =~ m/^(?:(.*?)\.)?(.*)/;
5227  ***      0             0                    0         $aliases->{$alias || $tbl} = $tbl;
5228  ***      0      0                           0         $aliases->{DATABASE}->{$tbl} = $db if $db;
5229                                                     }
5230  ***      0                                  0      return $aliases;
5231                                                  }
5232                                                  
5233                                                  sub split {
5234           5                    5            23      my ( $self, $query ) = @_;
5235  ***      5     50                          20      return unless $query;
5236           5                                 23      $query = $self->clean_query($query);
5237           5                                 12      MKDEBUG && _d('Splitting', $query);
5238                                                  
5239           5                                 33      my $verbs = qr{SELECT|INSERT|UPDATE|DELETE|REPLACE|UNION|CREATE}i;
5240                                                  
5241           5                                 84      my @split_statements = grep { $_ } split(m/\b($verbs\b(?!(?:\s*\()))/io, $query);
              15                                 52   
5242                                                  
5243           5                                 16      my @statements;
5244  ***      5     50                          19      if ( @split_statements == 1 ) {
5245  ***      0                                  0         push @statements, $query;
5246                                                     }
5247                                                     else {
5248                                                        for ( my $i = 0; $i <= $#split_statements; $i += 2 ) {
5249           5                                 26            push @statements, $split_statements[$i].$split_statements[$i+1];
5250                                                  
5251  ***      5     50     33                   43            if ( $statements[-2] && $statements[-2] =~ m/on duplicate key\s+$/i ) {
5252  ***      0                                  0               $statements[-2] .= pop @statements;
5253                                                           }
5254           5                                 15         }
5255                                                     }
5256                                                  
5257           5                                 12      MKDEBUG && _d('statements:', map { $_ ? "<$_>" : 'none' } @statements);
5258           5                                 35      return @statements;
5259                                                  }
5260                                                  
5261                                                  sub clean_query {
5262           5                    5            19      my ( $self, $query ) = @_;
5263  ***      5     50                          20      return unless $query;
5264           5                                 18      $query =~ s!/\*.*?\*/! !g;  # Remove /* comment blocks */
5265           5                                 19      $query =~ s/^\s+//;         # Remove leading spaces
5266           5                                 23      $query =~ s/\s+$//;         # Remove trailing spaces
5267           5                                 24      $query =~ s/\s{2,}/ /g;     # Remove extra spaces
5268           5                                 20      return $query;
5269                                                  }
5270                                                  
5271                                                  sub split_subquery {
5272  ***      0                    0             0      my ( $self, $query ) = @_;
5273  ***      0      0                           0      return unless $query;
5274  ***      0                                  0      $query = $self->clean_query($query);
5275  ***      0                                  0      $query =~ s/;$//;
5276                                                  
5277  ***      0                                  0      my @subqueries;
5278  ***      0                                  0      my $sqno = 0;  # subquery number
5279  ***      0                                  0      my $pos  = 0;
5280  ***      0                                  0      while ( $query =~ m/(\S+)(?:\s+|\Z)/g ) {
5281  ***      0                                  0         $pos = pos($query);
5282  ***      0                                  0         my $word = $1;
5283  ***      0                                  0         MKDEBUG && _d($word, $sqno);
5284  ***      0      0                           0         if ( $word =~ m/^\(?SELECT\b/i ) {
5285  ***      0                                  0            my $start_pos = $pos - length($word) - 1;
5286  ***      0      0                           0            if ( $start_pos ) {
5287  ***      0                                  0               $sqno++;
5288  ***      0                                  0               MKDEBUG && _d('Subquery', $sqno, 'starts at', $start_pos);
5289  ***      0                                  0               $subqueries[$sqno] = {
5290                                                                 start_pos => $start_pos,
5291                                                                 end_pos   => 0,
5292                                                                 len       => 0,
5293                                                                 words     => [$word],
5294                                                                 lp        => 1, # left parentheses
5295                                                                 rp        => 0, # right parentheses
5296                                                                 done      => 0,
5297                                                              };
5298                                                           }
5299                                                           else {
5300  ***      0                                  0               MKDEBUG && _d('Main SELECT at pos 0');
5301                                                           }
5302                                                        }
5303                                                        else {
5304  ***      0      0                           0            next unless $sqno;  # next unless we're in a subquery
5305  ***      0                                  0            MKDEBUG && _d('In subquery', $sqno);
5306  ***      0                                  0            my $sq = $subqueries[$sqno];
5307  ***      0      0                           0            if ( $sq->{done} ) {
5308  ***      0                                  0               MKDEBUG && _d('This subquery is done; SQL is for',
5309                                                                 ($sqno - 1 ? "subquery $sqno" : "the main SELECT"));
5310  ***      0                                  0               next;
5311                                                           }
5312  ***      0                                  0            push @{$sq->{words}}, $word;
      ***      0                                  0   
5313  ***      0             0                    0            my $lp = ($word =~ tr/\(//) || 0;
5314  ***      0             0                    0            my $rp = ($word =~ tr/\)//) || 0;
5315  ***      0                                  0            MKDEBUG && _d('parentheses left', $lp, 'right', $rp);
5316  ***      0      0                           0            if ( ($sq->{lp} + $lp) - ($sq->{rp} + $rp) == 0 ) {
5317  ***      0                                  0               my $end_pos = $pos - 1;
5318  ***      0                                  0               MKDEBUG && _d('Subquery', $sqno, 'ends at', $end_pos);
5319  ***      0                                  0               $sq->{end_pos} = $end_pos;
5320  ***      0                                  0               $sq->{len}     = $end_pos - $sq->{start_pos};
5321                                                           }
5322                                                        }
5323                                                     }
5324                                                  
5325  ***      0                                  0      for my $i ( 1..$#subqueries ) {
5326  ***      0                                  0         my $sq = $subqueries[$i];
5327  ***      0      0                           0         next unless $sq;
5328  ***      0                                  0         $sq->{sql} = join(' ', @{$sq->{words}});
      ***      0                                  0   
5329  ***      0                                  0         substr $query,
5330                                                           $sq->{start_pos} + 1,  # +1 for (
5331                                                           $sq->{len} - 1,        # -1 for )
5332                                                           "__subquery_$i";
5333                                                     }
5334                                                  
5335  ***      0                                  0      return $query, map { $_->{sql} } grep { defined $_ } @subqueries;
      ***      0                                  0   
      ***      0                                  0   
5336                                                  }
5337                                                  
5338                                                  sub query_type {
5339           5                    5            24      my ( $self, $query, $qr ) = @_;
5340           5                                 25      my ($type, undef) = $qr->distill_verbs($query);
5341           5                                 14      my $rw;
5342  ***      5    100     33                   66      if ( $type =~ m/^SELECT\b/ ) {
      ***            50                               
5343           4                                 14         $rw = 'read';
5344                                                     }
5345                                                     elsif ( $type =~ m/^$data_manip_stmts\b/
5346                                                             || $type =~ m/^$data_def_stmts\b/  ) {
5347           1                                  5         $rw = 'write'
5348                                                     }
5349                                                  
5350                                                     return {
5351           5                                 37         type => $type,
5352                                                        rw   => $rw,
5353                                                     }
5354                                                  }
5355                                                  
5356                                                  sub _d {
5357  ***      0                    0             0      my ($package, undef, $line) = caller 0;
5358  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
5359  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
5360                                                          @_;
5361  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
5362                                                  }
5363                                                  
5364                                                  1;
5365                                                  
5366                                                  # ###########################################################################
5367                                                  # End QueryParser package
5368                                                  # ###########################################################################
5369                                                  
5370                                                  # ###########################################################################
5371                                                  # MySQLDump package 5266
5372                                                  # ###########################################################################
5373                                                  package MySQLDump;
5374                                                  
5375           6                    6            60   use strict;
               6                                 14   
               6                                 44   
5376           6                    6            38   use warnings FATAL => 'all';
               6                                 17   
               6                                 38   
5377                                                  
5378           6                    6            37   use English qw(-no_match_vars);
               6                                 15   
               6                                 46   
5379                                                  
5380  ***      6            50      6            46   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 31   
               6                                 93   
5381                                                  
5382                                                  ( our $before = <<'EOF') =~ s/^   //gm;
5383                                                     /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
5384                                                     /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
5385                                                     /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
5386                                                     /*!40101 SET NAMES utf8 */;
5387                                                     /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
5388                                                     /*!40103 SET TIME_ZONE='+00:00' */;
5389                                                     /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
5390                                                     /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
5391                                                     /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
5392                                                     /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
5393                                                  EOF
5394                                                  
5395                                                  ( our $after = <<'EOF') =~ s/^   //gm;
5396                                                     /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
5397                                                     /*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
5398                                                     /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
5399                                                     /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
5400                                                     /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
5401                                                     /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
5402                                                     /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
5403                                                     /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
5404                                                  EOF
5405                                                  
5406                                                  sub new {
5407  ***      0                    0             0      my ( $class, %args ) = @_;
5408  ***      0      0                           0      $args{cache} = 1 unless defined $args{cache};
5409  ***      0                                  0      my $self = bless \%args, $class;
5410  ***      0                                  0      return $self;
5411                                                  }
5412                                                  
5413                                                  sub dump {
5414  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl, $what ) = @_;
5415                                                  
5416  ***      0      0                           0      if ( $what eq 'table' ) {
      ***             0                               
      ***             0                               
5417  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
5418  ***      0      0                           0         return unless $ddl;
5419  ***      0      0                           0         if ( $ddl->[0] eq 'table' ) {
5420  ***      0                                  0            return $before
5421                                                              . 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
5422                                                              . $ddl->[1] . ";\n";
5423                                                        }
5424                                                        else {
5425  ***      0                                  0            return 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
5426                                                              . '/*!50001 DROP VIEW IF EXISTS '
5427                                                              . $quoter->quote($tbl) . "*/;\n/*!50001 "
5428                                                              . $self->get_tmp_table($dbh, $quoter, $db, $tbl) . "*/;\n";
5429                                                        }
5430                                                     }
5431                                                     elsif ( $what eq 'triggers' ) {
5432  ***      0                                  0         my $trgs = $self->get_triggers($dbh, $quoter, $db, $tbl);
5433  ***      0      0      0                    0         if ( $trgs && @$trgs ) {
5434  ***      0                                  0            my $result = $before . "\nDELIMITER ;;\n";
5435  ***      0                                  0            foreach my $trg ( @$trgs ) {
5436  ***      0      0                           0               if ( $trg->{sql_mode} ) {
5437  ***      0                                  0                  $result .= qq{/*!50003 SET SESSION SQL_MODE='$trg->{sql_mode}' */;;\n};
5438                                                              }
5439  ***      0                                  0               $result .= "/*!50003 CREATE */ ";
5440  ***      0      0                           0               if ( $trg->{definer} ) {
5441  ***      0                                  0                  my ( $user, $host )
5442  ***      0                                  0                     = map { s/'/''/g; "'$_'"; }
      ***      0                                  0   
5443                                                                      split('@', $trg->{definer}, 2);
5444  ***      0                                  0                  $result .= "/*!50017 DEFINER=$user\@$host */ ";
5445                                                              }
5446  ***      0                                  0               $result .= sprintf("/*!50003 TRIGGER %s %s %s ON %s\nFOR EACH ROW %s */;;\n\n",
5447                                                                 $quoter->quote($trg->{trigger}),
5448  ***      0                                  0                  @{$trg}{qw(timing event)},
5449                                                                 $quoter->quote($trg->{table}),
5450                                                                 $trg->{statement});
5451                                                           }
5452  ***      0                                  0            $result .= "DELIMITER ;\n\n/*!50003 SET SESSION SQL_MODE=\@OLD_SQL_MODE */;\n\n";
5453  ***      0                                  0            return $result;
5454                                                        }
5455                                                        else {
5456  ***      0                                  0            return undef;
5457                                                        }
5458                                                     }
5459                                                     elsif ( $what eq 'view' ) {
5460  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
5461  ***      0                                  0         return '/*!50001 DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
5462                                                           . '/*!50001 DROP VIEW IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
5463                                                           . '/*!50001 ' . $ddl->[1] . "*/;\n";
5464                                                     }
5465                                                     else {
5466  ***      0                                  0         die "You didn't say what to dump.";
5467                                                     }
5468                                                  }
5469                                                  
5470                                                  sub _use_db {
5471  ***      0                    0             0      my ( $self, $dbh, $quoter, $new ) = @_;
5472  ***      0      0                           0      if ( !$new ) {
5473  ***      0                                  0         MKDEBUG && _d('No new DB to use');
5474  ***      0                                  0         return;
5475                                                     }
5476  ***      0                                  0      my $sql = 'SELECT DATABASE()';
5477  ***      0                                  0      MKDEBUG && _d($sql);
5478  ***      0                                  0      my $curr = $dbh->selectrow_array($sql);
5479  ***      0      0      0                    0      if ( $curr && $new && $curr eq $new ) {
      ***                    0                        
5480  ***      0                                  0         MKDEBUG && _d('Current and new DB are the same');
5481  ***      0                                  0         return $curr;
5482                                                     }
5483  ***      0                                  0      $sql = 'USE ' . $quoter->quote($new);
5484  ***      0                                  0      MKDEBUG && _d($sql);
5485  ***      0                                  0      $dbh->do($sql);
5486  ***      0                                  0      return $curr;
5487                                                  }
5488                                                  
5489                                                  sub get_create_table {
5490  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
5491  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{tables}->{$db}->{$tbl} ) {
5492  ***      0                                  0         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
5493                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
5494                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
5495                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
5496  ***      0                                  0         MKDEBUG && _d($sql);
5497  ***      0                                  0         eval { $dbh->do($sql); };
      ***      0                                  0   
5498  ***      0                                  0         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
5499  ***      0                                  0         my $curr_db = $self->_use_db($dbh, $quoter, $db);
5500  ***      0                                  0         $sql = "SHOW CREATE TABLE " . $quoter->quote($db, $tbl);
5501  ***      0                                  0         MKDEBUG && _d($sql);
5502  ***      0                                  0         my $href;
5503  ***      0                                  0         eval { $href = $dbh->selectrow_hashref($sql); };
      ***      0                                  0   
5504  ***      0      0                           0         if ( $EVAL_ERROR ) {
5505  ***      0                                  0            warn "Failed to $sql.  The table may be damaged.\nError: $EVAL_ERROR";
5506  ***      0                                  0            return;
5507                                                        }
5508  ***      0                                  0         $self->_use_db($dbh, $quoter, $curr_db);
5509  ***      0                                  0         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
5510                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
5511  ***      0                                  0         MKDEBUG && _d($sql);
5512  ***      0                                  0         $dbh->do($sql);
5513  ***      0                                  0         my ($key) = grep { m/create table/i } keys %$href;
      ***      0                                  0   
5514  ***      0      0                           0         if ( $key ) {
5515  ***      0                                  0            MKDEBUG && _d('This table is a base table');
5516  ***      0                                  0            $self->{tables}->{$db}->{$tbl} = [ 'table', $href->{$key} ];
5517                                                        }
5518                                                        else {
5519  ***      0                                  0            MKDEBUG && _d('This table is a view');
5520  ***      0                                  0            ($key) = grep { m/create view/i } keys %$href;
      ***      0                                  0   
5521  ***      0                                  0            $self->{tables}->{$db}->{$tbl} = [ 'view', $href->{$key} ];
5522                                                        }
5523                                                     }
5524  ***      0                                  0      return $self->{tables}->{$db}->{$tbl};
5525                                                  }
5526                                                  
5527                                                  sub get_columns {
5528  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
5529  ***      0                                  0      MKDEBUG && _d('Get columns for', $db, $tbl);
5530  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{columns}->{$db}->{$tbl} ) {
5531  ***      0                                  0         my $curr_db = $self->_use_db($dbh, $quoter, $db);
5532  ***      0                                  0         my $sql = "SHOW COLUMNS FROM " . $quoter->quote($db, $tbl);
5533  ***      0                                  0         MKDEBUG && _d($sql);
5534  ***      0                                  0         my $cols = $dbh->selectall_arrayref($sql, { Slice => {} });
5535  ***      0                                  0         $self->_use_db($dbh, $quoter, $curr_db);
5536  ***      0                                  0         $self->{columns}->{$db}->{$tbl} = [
5537                                                           map {
5538  ***      0                                  0               my %row;
5539  ***      0                                  0               @row{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
5540  ***      0                                  0               \%row;
5541                                                           } @$cols
5542                                                        ];
5543                                                     }
5544  ***      0                                  0      return $self->{columns}->{$db}->{$tbl};
5545                                                  }
5546                                                  
5547                                                  sub get_tmp_table {
5548  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
5549  ***      0                                  0      my $result = 'CREATE TABLE ' . $quoter->quote($tbl) . " (\n";
5550  ***      0                                  0      $result .= join(",\n",
5551  ***      0                                  0         map { '  ' . $quoter->quote($_->{field}) . ' ' . $_->{type} }
5552  ***      0                                  0         @{$self->get_columns($dbh, $quoter, $db, $tbl)});
5553  ***      0                                  0      $result .= "\n)";
5554  ***      0                                  0      MKDEBUG && _d($result);
5555  ***      0                                  0      return $result;
5556                                                  }
5557                                                  
5558                                                  sub get_triggers {
5559  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
5560  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{triggers}->{$db} ) {
5561  ***      0                                  0         $self->{triggers}->{$db} = {};
5562  ***      0                                  0         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
5563                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
5564                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
5565                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
5566  ***      0                                  0         MKDEBUG && _d($sql);
5567  ***      0                                  0         eval { $dbh->do($sql); };
      ***      0                                  0   
5568  ***      0                                  0         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
5569  ***      0                                  0         $sql = "SHOW TRIGGERS FROM " . $quoter->quote($db);
5570  ***      0                                  0         MKDEBUG && _d($sql);
5571  ***      0                                  0         my $sth = $dbh->prepare($sql);
5572  ***      0                                  0         $sth->execute();
5573  ***      0      0                           0         if ( $sth->rows ) {
5574  ***      0                                  0            my $trgs = $sth->fetchall_arrayref({});
5575  ***      0                                  0            foreach my $trg (@$trgs) {
5576  ***      0                                  0               my %trg;
5577  ***      0                                  0               @trg{ map { lc $_ } keys %$trg } = values %$trg;
      ***      0                                  0   
5578  ***      0                                  0               push @{ $self->{triggers}->{$db}->{ $trg{table} } }, \%trg;
      ***      0                                  0   
5579                                                           }
5580                                                        }
5581  ***      0                                  0         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
5582                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
5583  ***      0                                  0         MKDEBUG && _d($sql);
5584  ***      0                                  0         $dbh->do($sql);
5585                                                     }
5586  ***      0      0                           0      if ( $tbl ) {
5587  ***      0                                  0         return $self->{triggers}->{$db}->{$tbl};
5588                                                     }
5589  ***      0                                  0      return values %{$self->{triggers}->{$db}};
      ***      0                                  0   
5590                                                  }
5591                                                  
5592                                                  sub get_databases {
5593  ***      0                    0             0      my ( $self, $dbh, $quoter, $like ) = @_;
5594  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{databases} || $like ) {
      ***                    0                        
5595  ***      0                                  0         my $sql = 'SHOW DATABASES';
5596  ***      0                                  0         my @params;
5597  ***      0      0                           0         if ( $like ) {
5598  ***      0                                  0            $sql .= ' LIKE ?';
5599  ***      0                                  0            push @params, $like;
5600                                                        }
5601  ***      0                                  0         my $sth = $dbh->prepare($sql);
5602  ***      0                                  0         MKDEBUG && _d($sql, @params);
5603  ***      0                                  0         $sth->execute( @params );
5604  ***      0                                  0         my @dbs = map { $_->[0] } @{$sth->fetchall_arrayref()};
      ***      0                                  0   
      ***      0                                  0   
5605  ***      0      0                           0         $self->{databases} = \@dbs unless $like;
5606  ***      0                                  0         return @dbs;
5607                                                     }
5608  ***      0                                  0      return @{$self->{databases}};
      ***      0                                  0   
5609                                                  }
5610                                                  
5611                                                  sub get_table_status {
5612  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
5613  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_status}->{$db} || $like ) {
      ***                    0                        
5614  ***      0                                  0         my $sql = "SHOW TABLE STATUS FROM " . $quoter->quote($db);
5615  ***      0                                  0         my @params;
5616  ***      0      0                           0         if ( $like ) {
5617  ***      0                                  0            $sql .= ' LIKE ?';
5618  ***      0                                  0            push @params, $like;
5619                                                        }
5620  ***      0                                  0         MKDEBUG && _d($sql, @params);
5621  ***      0                                  0         my $sth = $dbh->prepare($sql);
5622  ***      0                                  0         $sth->execute(@params);
5623  ***      0                                  0         my @tables = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
5624  ***      0                                  0         @tables = map {
5625  ***      0                                  0            my %tbl; # Make a copy with lowercased keys
5626  ***      0                                  0            @tbl{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
5627  ***      0             0                    0            $tbl{engine} ||= $tbl{type} || $tbl{comment};
      ***                    0                        
5628  ***      0                                  0            delete $tbl{type};
5629  ***      0                                  0            \%tbl;
5630                                                        } @tables;
5631  ***      0      0                           0         $self->{table_status}->{$db} = \@tables unless $like;
5632  ***      0                                  0         return @tables;
5633                                                     }
5634  ***      0                                  0      return @{$self->{table_status}->{$db}};
      ***      0                                  0   
5635                                                  }
5636                                                  
5637                                                  sub get_table_list {
5638  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
5639  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_list}->{$db} || $like ) {
      ***                    0                        
5640  ***      0                                  0         my $sql = "SHOW /*!50002 FULL*/ TABLES FROM " . $quoter->quote($db);
5641  ***      0                                  0         my @params;
5642  ***      0      0                           0         if ( $like ) {
5643  ***      0                                  0            $sql .= ' LIKE ?';
5644  ***      0                                  0            push @params, $like;
5645                                                        }
5646  ***      0                                  0         MKDEBUG && _d($sql, @params);
5647  ***      0                                  0         my $sth = $dbh->prepare($sql);
5648  ***      0                                  0         $sth->execute(@params);
5649  ***      0                                  0         my @tables = @{$sth->fetchall_arrayref()};
      ***      0                                  0   
5650  ***      0      0      0                    0         @tables = map {
5651  ***      0                                  0            my %tbl = (
5652                                                              name   => $_->[0],
5653                                                              engine => ($_->[1] || '') eq 'VIEW' ? 'VIEW' : '',
5654                                                           );
5655  ***      0                                  0            \%tbl;
5656                                                        } @tables;
5657  ***      0      0                           0         $self->{table_list}->{$db} = \@tables unless $like;
5658  ***      0                                  0         return @tables;
5659                                                     }
5660  ***      0                                  0      return @{$self->{table_list}->{$db}};
      ***      0                                  0   
5661                                                  }
5662                                                  
5663                                                  sub _d {
5664  ***      0                    0             0      my ($package, undef, $line) = caller 0;
5665  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
5666  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
5667                                                          @_;
5668  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
5669                                                  }
5670                                                  
5671                                                  1;
5672                                                  
5673                                                  # ###########################################################################
5674                                                  # End MySQLDump package
5675                                                  # ###########################################################################
5676                                                  
5677                                                  # ###########################################################################
5678                                                  # TableParser package 5266
5679                                                  # ###########################################################################
5680                                                  package TableParser;
5681                                                  
5682           6                    6            64   use strict;
               6                                 19   
               6                                 66   
5683           6                    6            37   use warnings FATAL => 'all';
               6                                 39   
               6                                 40   
5684           6                    6            38   use English qw(-no_match_vars);
               6                                 16   
               6                                 34   
5685           6                    6            46   use Data::Dumper;
               6                                 16   
               6                                 40   
5686                                                  $Data::Dumper::Indent    = 1;
5687                                                  $Data::Dumper::Sortkeys  = 1;
5688                                                  $Data::Dumper::Quotekeys = 0;
5689                                                  
5690  ***      6            50      6            47   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 20   
               6                                102   
5691                                                  
5692                                                  
5693                                                  sub new {
5694  ***      0                    0             0      my ( $class, %args ) = @_;
5695  ***      0                                  0      my @required_args = qw(Quoter);
5696  ***      0                                  0      foreach my $arg ( @required_args ) {
5697  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
5698                                                     }
5699  ***      0                                  0      my $self = { %args };
5700  ***      0                                  0      return bless $self, $class;
5701                                                  }
5702                                                  
5703                                                  
5704                                                  sub parse {
5705  ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
5706  ***      0      0                           0      return unless $ddl;
5707  ***      0      0                           0      if ( ref $ddl eq 'ARRAY' ) {
5708  ***      0      0                           0         if ( lc $ddl->[0] eq 'table' ) {
5709  ***      0                                  0            $ddl = $ddl->[1];
5710                                                        }
5711                                                        else {
5712                                                           return {
5713  ***      0                                  0               engine => 'VIEW',
5714                                                           };
5715                                                        }
5716                                                     }
5717                                                  
5718  ***      0      0                           0      if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
5719  ***      0                                  0         die "Cannot parse table definition; is ANSI quoting "
5720                                                           . "enabled or SQL_QUOTE_SHOW_CREATE disabled?";
5721                                                     }
5722                                                  
5723  ***      0                                  0      my ($name)     = $ddl =~ m/CREATE (?:TEMPORARY )?TABLE\s+(`.+?`)/;
5724  ***      0      0                           0      (undef, $name) = $self->{Quoter}->split_unquote($name) if $name;
5725                                                  
5726  ***      0                                  0      $ddl =~ s/(`[^`]+`)/\L$1/g;
5727                                                  
5728  ***      0                                  0      my $engine = $self->get_engine($ddl);
5729                                                  
5730  ***      0                                  0      my @defs   = $ddl =~ m/^(\s+`.*?),?$/gm;
5731  ***      0                                  0      my @cols   = map { $_ =~ m/`([^`]+)`/ } @defs;
      ***      0                                  0   
5732  ***      0                                  0      MKDEBUG && _d('Columns:', join(', ', @cols));
5733                                                  
5734  ***      0                                  0      my %def_for;
5735  ***      0                                  0      @def_for{@cols} = @defs;
5736                                                  
5737  ***      0                                  0      my (@nums, @null);
5738  ***      0                                  0      my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
5739  ***      0                                  0      foreach my $col ( @cols ) {
5740  ***      0                                  0         my $def = $def_for{$col};
5741  ***      0                                  0         my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
5742  ***      0      0                           0         die "Can't determine column type for $def" unless $type;
5743  ***      0                                  0         $type_for{$col} = $type;
5744  ***      0      0                           0         if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
5745  ***      0                                  0            push @nums, $col;
5746  ***      0                                  0            $is_numeric{$col} = 1;
5747                                                        }
5748  ***      0      0                           0         if ( $def !~ m/NOT NULL/ ) {
5749  ***      0                                  0            push @null, $col;
5750  ***      0                                  0            $is_nullable{$col} = 1;
5751                                                        }
5752  ***      0      0                           0         $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
5753                                                     }
5754                                                  
5755  ***      0                                  0      my ($keys, $clustered_key) = $self->get_keys($ddl, $opts, \%is_nullable);
5756                                                  
5757                                                     return {
5758  ***      0                                  0         name           => $name,
5759                                                        cols           => \@cols,
5760  ***      0                                  0         col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
5761  ***      0                                  0         is_col         => { map { $_ => 1 } @cols },
5762                                                        null_cols      => \@null,
5763                                                        is_nullable    => \%is_nullable,
5764                                                        is_autoinc     => \%is_autoinc,
5765                                                        clustered_key  => $clustered_key,
5766                                                        keys           => $keys,
5767                                                        defs           => \%def_for,
5768                                                        numeric_cols   => \@nums,
5769                                                        is_numeric     => \%is_numeric,
5770                                                        engine         => $engine,
5771                                                        type_for       => \%type_for,
5772                                                     };
5773                                                  }
5774                                                  
5775                                                  sub sort_indexes {
5776  ***      0                    0             0      my ( $self, $tbl ) = @_;
5777                                                  
5778                                                     my @indexes
5779  ***      0                                  0         = sort {
5780  ***      0                                  0            (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
5781                                                           || ( !$tbl->{keys}->{$a}->{is_unique} <=> !$tbl->{keys}->{$b}->{is_unique} )
5782                                                           || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
5783  ***      0      0      0                    0            || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      ***      0             0                    0   
5784                                                        }
5785                                                        grep {
5786  ***      0                                  0            $tbl->{keys}->{$_}->{type} eq 'BTREE'
5787                                                        }
5788  ***      0                                  0         sort keys %{$tbl->{keys}};
5789                                                  
5790  ***      0                                  0      MKDEBUG && _d('Indexes sorted best-first:', join(', ', @indexes));
5791  ***      0                                  0      return @indexes;
5792                                                  }
5793                                                  
5794                                                  sub find_best_index {
5795  ***      0                    0             0      my ( $self, $tbl, $index ) = @_;
5796  ***      0                                  0      my $best;
5797  ***      0      0                           0      if ( $index ) {
5798  ***      0                                  0         ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
      ***      0                                  0   
      ***      0                                  0   
5799                                                     }
5800  ***      0      0                           0      if ( !$best ) {
5801  ***      0      0                           0         if ( $index ) {
5802  ***      0                                  0            die "Index '$index' does not exist in table";
5803                                                        }
5804                                                        else {
5805  ***      0                                  0            ($best) = $self->sort_indexes($tbl);
5806                                                        }
5807                                                     }
5808  ***      0                                  0      MKDEBUG && _d('Best index found is', $best);
5809  ***      0                                  0      return $best;
5810                                                  }
5811                                                  
5812                                                  sub find_possible_keys {
5813  ***      0                    0             0      my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
5814  ***      0      0                           0      return () unless $where;
5815  ***      0                                  0      my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
5816                                                        . ' WHERE ' . $where;
5817  ***      0                                  0      MKDEBUG && _d($sql);
5818  ***      0                                  0      my $expl = $dbh->selectrow_hashref($sql);
5819  ***      0                                  0      $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
      ***      0                                  0   
5820  ***      0      0                           0      if ( $expl->{possible_keys} ) {
5821  ***      0                                  0         MKDEBUG && _d('possible_keys =', $expl->{possible_keys});
5822  ***      0                                  0         my @candidates = split(',', $expl->{possible_keys});
5823  ***      0                                  0         my %possible   = map { $_ => 1 } @candidates;
      ***      0                                  0   
5824  ***      0      0                           0         if ( $expl->{key} ) {
5825  ***      0                                  0            MKDEBUG && _d('MySQL chose', $expl->{key});
5826  ***      0                                  0            unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
      ***      0                                  0   
5827  ***      0                                  0            MKDEBUG && _d('Before deduping:', join(', ', @candidates));
5828  ***      0                                  0            my %seen;
5829  ***      0                                  0            @candidates = grep { !$seen{$_}++ } @candidates;
      ***      0                                  0   
5830                                                        }
5831  ***      0                                  0         MKDEBUG && _d('Final list:', join(', ', @candidates));
5832  ***      0                                  0         return @candidates;
5833                                                     }
5834                                                     else {
5835  ***      0                                  0         MKDEBUG && _d('No keys in possible_keys');
5836  ***      0                                  0         return ();
5837                                                     }
5838                                                  }
5839                                                  
5840                                                  sub check_table {
5841  ***      0                    0             0      my ( $self, %args ) = @_;
5842  ***      0                                  0      my @required_args = qw(dbh db tbl);
5843  ***      0                                  0      foreach my $arg ( @required_args ) {
5844  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
5845                                                     }
5846  ***      0                                  0      my ($dbh, $db, $tbl) = @args{@required_args};
5847  ***      0                                  0      my $q      = $self->{Quoter};
5848  ***      0                                  0      my $db_tbl = $q->quote($db, $tbl);
5849  ***      0                                  0      MKDEBUG && _d('Checking', $db_tbl);
5850                                                  
5851  ***      0                                  0      my $sql = "SHOW TABLES FROM " . $q->quote($db)
5852                                                             . ' LIKE ' . $q->literal_like($tbl);
5853  ***      0                                  0      MKDEBUG && _d($sql);
5854  ***      0                                  0      my $row;
5855  ***      0                                  0      eval {
5856  ***      0                                  0         $row = $dbh->selectrow_arrayref($sql);
5857                                                     };
5858  ***      0      0                           0      if ( $EVAL_ERROR ) {
5859  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
5860  ***      0                                  0         return 0;
5861                                                     }
5862  ***      0      0      0                    0      if ( !$row->[0] || $row->[0] ne $tbl ) {
5863  ***      0                                  0         MKDEBUG && _d('Table does not exist');
5864  ***      0                                  0         return 0;
5865                                                     }
5866                                                  
5867  ***      0                                  0      MKDEBUG && _d('Table exists; no privs to check');
5868  ***      0      0                           0      return 1 unless $args{all_privs};
5869                                                  
5870  ***      0                                  0      $sql = "SHOW FULL COLUMNS FROM $db_tbl";
5871  ***      0                                  0      MKDEBUG && _d($sql);
5872  ***      0                                  0      eval {
5873  ***      0                                  0         $row = $dbh->selectrow_hashref($sql);
5874                                                     };
5875  ***      0      0                           0      if ( $EVAL_ERROR ) {
5876  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
5877  ***      0                                  0         return 0;
5878                                                     }
5879  ***      0      0                           0      if ( !scalar keys %$row ) {
5880  ***      0                                  0         MKDEBUG && _d('Table has no columns:', Dumper($row));
5881  ***      0                                  0         return 0;
5882                                                     }
5883  ***      0             0                    0      my $privs = $row->{privileges} || $row->{Privileges};
5884                                                  
5885  ***      0                                  0      $sql = "DELETE FROM $db_tbl LIMIT 0";
5886  ***      0                                  0      MKDEBUG && _d($sql);
5887  ***      0                                  0      eval {
5888  ***      0                                  0         $dbh->do($sql);
5889                                                     };
5890  ***      0      0                           0      my $can_delete = $EVAL_ERROR ? 0 : 1;
5891                                                  
5892  ***      0                                  0      MKDEBUG && _d('User privs on', $db_tbl, ':', $privs,
5893                                                        ($can_delete ? 'delete' : ''));
5894                                                  
5895  ***      0      0      0                    0      if ( !($privs =~ m/select/ && $privs =~ m/insert/ && $privs =~ m/update/
      ***                    0                        
      ***                    0                        
5896                                                            && $can_delete) ) {
5897  ***      0                                  0         MKDEBUG && _d('User does not have all privs');
5898  ***      0                                  0         return 0;
5899                                                     }
5900                                                  
5901  ***      0                                  0      MKDEBUG && _d('User has all privs');
5902  ***      0                                  0      return 1;
5903                                                  }
5904                                                  
5905                                                  sub get_engine {
5906  ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
5907  ***      0                                  0      my ( $engine ) = $ddl =~ m/\).*?(?:ENGINE|TYPE)=(\w+)/;
5908  ***      0                                  0      MKDEBUG && _d('Storage engine:', $engine);
5909  ***      0             0                    0      return $engine || undef;
5910                                                  }
5911                                                  
5912                                                  sub get_keys {
5913  ***      0                    0             0      my ( $self, $ddl, $opts, $is_nullable ) = @_;
5914  ***      0                                  0      my $engine        = $self->get_engine($ddl);
5915  ***      0                                  0      my $keys          = {};
5916  ***      0                                  0      my $clustered_key = undef;
5917                                                  
5918                                                     KEY:
5919  ***      0                                  0      foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {
5920                                                  
5921  ***      0      0                           0         next KEY if $key =~ m/FOREIGN/;
5922                                                  
5923  ***      0                                  0         my $key_ddl = $key;
5924  ***      0                                  0         MKDEBUG && _d('Parsed key:', $key_ddl);
5925                                                  
5926  ***      0      0                           0         if ( $engine !~ m/MEMORY|HEAP/ ) {
5927  ***      0                                  0            $key =~ s/USING HASH/USING BTREE/;
5928                                                        }
5929                                                  
5930  ***      0                                  0         my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
5931  ***      0                                  0         my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
5932  ***      0             0                    0         $type = $type || $special || 'BTREE';
      ***                    0                        
5933  ***      0      0      0                    0         if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
      ***                    0                        
5934                                                           && $engine =~ m/HEAP|MEMORY/i )
5935                                                        {
5936  ***      0                                  0            $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
5937                                                        }
5938                                                  
5939  ***      0                                  0         my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
5940  ***      0      0                           0         my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
5941  ***      0                                  0         my @cols;
5942  ***      0                                  0         my @col_prefixes;
5943  ***      0                                  0         foreach my $col_def ( split(',', $cols) ) {
5944  ***      0                                  0            my ($name, $prefix) = $col_def =~ m/`([^`]+)`(?:\((\d+)\))?/;
5945  ***      0                                  0            push @cols, $name;
5946  ***      0                                  0            push @col_prefixes, $prefix;
5947                                                        }
5948  ***      0                                  0         $name =~ s/`//g;
5949                                                  
5950  ***      0                                  0         MKDEBUG && _d('Key', $name, 'cols:', join(', ', @cols));
5951                                                  
5952  ***      0                                  0         $keys->{$name} = {
5953                                                           name         => $name,
5954                                                           type         => $type,
5955                                                           colnames     => $cols,
5956                                                           cols         => \@cols,
5957                                                           col_prefixes => \@col_prefixes,
5958                                                           is_unique    => $unique,
5959  ***      0                                  0            is_nullable  => scalar(grep { $is_nullable->{$_} } @cols),
5960  ***      0                                  0            is_col       => { map { $_ => 1 } @cols },
5961                                                           ddl          => $key_ddl,
5962                                                        };
5963                                                  
5964  ***      0      0      0                    0         if ( $engine =~ m/InnoDB/i && !$clustered_key ) {
5965  ***      0                                  0            my $this_key = $keys->{$name};
5966  ***      0      0      0                    0            if ( $this_key->{name} eq 'PRIMARY' ) {
      ***             0                               
5967  ***      0                                  0               $clustered_key = 'PRIMARY';
5968                                                           }
5969                                                           elsif ( $this_key->{is_unique} && !$this_key->{is_nullable} ) {
5970  ***      0                                  0               $clustered_key = $this_key->{name};
5971                                                           }
5972  ***      0                                  0            MKDEBUG && $clustered_key && _d('This key is the clustered key');
5973                                                        }
5974                                                     }
5975                                                  
5976  ***      0                                  0      return $keys, $clustered_key;
5977                                                  }
5978                                                  
5979                                                  sub get_fks {
5980  ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
5981  ***      0                                  0      my $fks = {};
5982                                                  
5983  ***      0                                  0      foreach my $fk (
5984                                                        $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg )
5985                                                     {
5986  ***      0                                  0         my ( $name ) = $fk =~ m/CONSTRAINT `(.*?)`/;
5987  ***      0                                  0         my ( $cols ) = $fk =~ m/FOREIGN KEY \(([^\)]+)\)/;
5988  ***      0                                  0         my ( $parent, $parent_cols ) = $fk =~ m/REFERENCES (\S+) \(([^\)]+)\)/;
5989                                                  
5990  ***      0      0      0                    0         if ( $parent !~ m/\./ && $opts->{database} ) {
5991  ***      0                                  0            $parent = "`$opts->{database}`.$parent";
5992                                                        }
5993                                                  
5994  ***      0                                  0         $fks->{$name} = {
5995                                                           name           => $name,
5996                                                           colnames       => $cols,
5997  ***      0                                  0            cols           => [ map { s/[ `]+//g; $_; } split(',', $cols) ],
      ***      0                                  0   
5998                                                           parent_tbl     => $parent,
5999                                                           parent_colnames=> $parent_cols,
6000  ***      0                                  0            parent_cols    => [ map { s/[ `]+//g; $_; } split(',', $parent_cols) ],
      ***      0                                  0   
6001                                                           ddl            => $fk,
6002                                                        };
6003                                                     }
6004                                                  
6005  ***      0                                  0      return $fks;
6006                                                  }
6007                                                  
6008                                                  sub remove_auto_increment {
6009  ***      0                    0             0      my ( $self, $ddl ) = @_;
6010  ***      0                                  0      $ddl =~ s/(^\).*?) AUTO_INCREMENT=\d+\b/$1/m;
6011  ***      0                                  0      return $ddl;
6012                                                  }
6013                                                  
6014                                                  sub remove_secondary_indexes {
6015  ***      0                    0             0      my ( $self, $ddl ) = @_;
6016  ***      0                                  0      my $sec_indexes_ddl;
6017  ***      0                                  0      my $tbl_struct = $self->parse($ddl);
6018                                                  
6019  ***      0      0      0                    0      if ( ($tbl_struct->{engine} || '') =~ m/InnoDB/i ) {
6020  ***      0                                  0         my $clustered_key = $tbl_struct->{clustered_key};
6021  ***      0             0                    0         $clustered_key  ||= '';
6022                                                  
6023  ***      0                                  0         my @sec_indexes   = map {
6024  ***      0                                  0            my $key_def = $_->{ddl};
6025  ***      0                                  0            $key_def =~ s/([\(\)])/\\$1/g;
6026  ***      0                                  0            $ddl =~ s/\s+$key_def//;
6027  ***      0                                  0            "ADD $_->{ddl}";
6028                                                        }
6029  ***      0                                  0         grep { $_->{name} ne $clustered_key }
6030  ***      0                                  0         values %{$tbl_struct->{keys}};
6031  ***      0                                  0         MKDEBUG && _d('Secondary indexes:', Dumper(\@sec_indexes));
6032                                                  
6033  ***      0      0                           0         if ( @sec_indexes ) {
6034  ***      0                                  0            $sec_indexes_ddl = join(' ', @sec_indexes);
6035  ***      0                                  0            $sec_indexes_ddl =~ s/,$//;
6036                                                        }
6037                                                  
6038  ***      0                                  0         $ddl =~ s/,(\n\) )/$1/s;
6039                                                     }
6040                                                     else {
6041  ***      0                                  0         MKDEBUG && _d('Not removing secondary indexes from',
6042                                                           $tbl_struct->{engine}, 'table');
6043                                                     }
6044                                                  
6045  ***      0                                  0      return $ddl, $sec_indexes_ddl, $tbl_struct;
6046                                                  }
6047                                                  
6048                                                  sub _d {
6049  ***      0                    0             0      my ($package, undef, $line) = caller 0;
6050  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
6051  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
6052                                                          @_;
6053  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
6054                                                  }
6055                                                  
6056                                                  1;
6057                                                  
6058                                                  # ###########################################################################
6059                                                  # End TableParser package
6060                                                  # ###########################################################################
6061                                                  
6062                                                  # ###########################################################################
6063                                                  # QueryReview package 5266
6064                                                  # ###########################################################################
6065                                                  
6066                                                  package QueryReview;
6067                                                  
6068                                                  
6069           6                    6            57   use strict;
               6                                 18   
               6                                 43   
6070           6                    6            39   use warnings FATAL => 'all';
               6                                 31   
               6                                 43   
6071           6                    6            44   use English qw(-no_match_vars);
               6                                 13   
               6                                 37   
6072                                                  Transformers->import(qw(make_checksum parse_timestamp));
6073                                                  
6074           6                    6            44   use Data::Dumper;
               6                                 14   
               6                                 45   
6075                                                  
6076  ***      6            50      6            40   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 16   
               6                                101   
6077                                                  
6078                                                  my %basic_cols = map { $_ => 1 }
6079                                                     qw(checksum fingerprint sample first_seen last_seen reviewed_by
6080                                                        reviewed_on comments);
6081                                                  my %skip_cols  = map { $_ => 1 } qw(fingerprint sample checksum);
6082                                                  
6083                                                  sub new {
6084  ***      0                    0             0      my ( $class, %args ) = @_;
6085  ***      0                                  0      foreach my $arg ( qw(dbh db_tbl tbl_struct quoter) ) {
6086  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
6087                                                     }
6088                                                  
6089  ***      0                                  0      foreach my $col ( keys %basic_cols ) {
6090  ***      0      0                           0         die "Query review table $args{db_tbl} does not have a $col column"
6091                                                           unless $args{tbl_struct}->{is_col}->{$col};
6092                                                     }
6093                                                  
6094  ***      0      0                           0      my $now = defined $args{ts_default} ? $args{ts_default} : 'NOW()';
6095                                                  
6096  ***      0                                  0      my $sql = <<"      SQL";
6097                                                        INSERT INTO $args{db_tbl}
6098                                                        (checksum, fingerprint, sample, first_seen, last_seen)
6099                                                        VALUES(CONV(?, 16, 10), ?, ?, COALESCE(?, $now), COALESCE(?, $now))
6100                                                        ON DUPLICATE KEY UPDATE
6101                                                           first_seen = IF(
6102                                                              first_seen IS NULL,
6103                                                              COALESCE(?, $now),
6104                                                              LEAST(first_seen, COALESCE(?, $now))),
6105                                                           last_seen = IF(
6106                                                              last_seen IS NULL,
6107                                                              COALESCE(?, $now),
6108                                                              GREATEST(last_seen, COALESCE(?, $now)))
6109                                                        SQL
6110  ***      0                                  0      MKDEBUG && _d('SQL to insert into review table:', $sql);
6111  ***      0                                  0      my $insert_sth = $args{dbh}->prepare($sql);
6112                                                  
6113  ***      0                                  0      my @review_cols = grep { !$skip_cols{$_} } @{$args{tbl_struct}->{cols}};
      ***      0                                  0   
      ***      0                                  0   
6114  ***      0                                  0      $sql = "SELECT "
6115  ***      0                                  0           . join(', ', map { $args{quoter}->quote($_) } @review_cols)
6116                                                          . ", CONV(checksum, 10, 16) AS checksum_conv FROM $args{db_tbl}"
6117                                                          . " WHERE checksum=CONV(?, 16, 10)";
6118  ***      0                                  0      MKDEBUG && _d('SQL to select from review table:', $sql);
6119  ***      0                                  0      my $select_sth = $args{dbh}->prepare($sql);
6120                                                  
6121  ***      0                                  0      my $self = {
6122                                                        dbh         => $args{dbh},
6123                                                        db_tbl      => $args{db_tbl},
6124                                                        insert_sth  => $insert_sth,
6125                                                        select_sth  => $select_sth,
6126                                                        tbl_struct  => $args{tbl_struct},
6127                                                        quoter      => $args{quoter},
6128                                                        ts_default  => $now,
6129                                                     };
6130  ***      0                                  0      return bless $self, $class;
6131                                                  }
6132                                                  
6133                                                  sub set_history_options {
6134  ***      0                    0             0      my ( $self, %args ) = @_;
6135  ***      0                                  0      foreach my $arg ( qw(table dbh tbl_struct col_pat) ) {
6136  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
6137                                                     }
6138                                                  
6139  ***      0                                  0      my @cols;
6140  ***      0                                  0      my @metrics;
6141  ***      0                                  0      foreach my $col ( @{$args{tbl_struct}->{cols}} ) {
      ***      0                                  0   
6142  ***      0                                  0         my ( $attr, $metric ) = $col =~ m/$args{col_pat}/;
6143  ***      0      0      0                    0         next unless $attr && $metric;
6144  ***      0      0                           0         $attr = ucfirst $attr if $attr =~ m/_/; # TableParser lowercases
6145  ***      0                                  0         push @cols, $col;
6146  ***      0                                  0         push @metrics, [$attr, $metric];
6147                                                     }
6148                                                  
6149  ***      0                                  0      my $sql = "REPLACE INTO $args{table}("
6150                                                        . join(', ',
6151  ***      0      0      0                    0            map { $self->{quoter}->quote($_) } ('checksum', 'sample', @cols))
6152                                                        . ') VALUES (CONV(?, 16, 10), ?, '
6153                                                        . join(', ', map {
6154  ***      0                                  0            $_ eq 'ts_min' || $_ eq 'ts_max'
6155                                                              ? "COALESCE(?, $self->{ts_default})"
6156                                                              : '?'
6157                                                          } @cols) . ')';
6158  ***      0                                  0      MKDEBUG && _d($sql);
6159                                                  
6160  ***      0                                  0      $self->{history_sth}     = $args{dbh}->prepare($sql);
6161  ***      0                                  0      $self->{history_cols}    = \@cols;
6162  ***      0                                  0      $self->{history_metrics} = \@metrics;
6163                                                  }
6164                                                  
6165                                                  sub set_review_history {
6166  ***      0                    0             0      my ( $self, $id, $sample, %data ) = @_;
6167  ***      0                                  0      foreach my $thing ( qw(min max) ) {
6168  ***      0      0      0                    0         next unless defined $data{ts} && defined $data{ts}->{$thing};
6169  ***      0                                  0         $data{ts}->{$thing} = parse_timestamp($data{ts}->{$thing});
6170                                                     }
6171  ***      0                                  0      $self->{history_sth}->execute(
6172                                                        make_checksum($id),
6173                                                        $sample,
6174  ***      0                                  0         map { $data{$_->[0]}->{$_->[1]} } @{$self->{history_metrics}});
      ***      0                                  0   
6175                                                  }
6176                                                  
6177                                                  sub get_review_info {
6178  ***      0                    0             0      my ( $self, $id ) = @_;
6179  ***      0                                  0      $self->{select_sth}->execute(make_checksum($id));
6180  ***      0                                  0      my $review_vals = $self->{select_sth}->fetchall_arrayref({});
6181  ***      0      0      0                    0      if ( $review_vals && @$review_vals == 1 ) {
6182  ***      0                                  0         return $review_vals->[0];
6183                                                     }
6184  ***      0                                  0      return undef;
6185                                                  }
6186                                                  
6187                                                  sub set_review_info {
6188  ***      0                    0             0      my ( $self, %args ) = @_;
6189  ***      0      0                           0      $self->{insert_sth}->execute(
6190                                                        make_checksum($args{fingerprint}),
6191                                                        @args{qw(fingerprint sample)},
6192  ***      0                                  0         map { $args{$_} ? parse_timestamp($args{$_}) : undef }
6193                                                           qw(first_seen last_seen first_seen first_seen last_seen last_seen));
6194                                                  }
6195                                                  
6196                                                  sub review_cols {
6197  ***      0                    0             0      my ( $self ) = @_;
6198  ***      0                                  0      return grep { !$skip_cols{$_} } @{$self->{tbl_struct}->{cols}};
      ***      0                                  0   
      ***      0                                  0   
6199                                                  }
6200                                                  
6201                                                  sub _d {
6202  ***      0                    0             0      my ($package, undef, $line) = caller 0;
6203  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
6204  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
6205                                                          @_;
6206  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
6207                                                  }
6208                                                  
6209                                                  1;
6210                                                  # ###########################################################################
6211                                                  # End QueryReview package
6212                                                  # ###########################################################################
6213                                                  
6214                                                  # ###########################################################################
6215                                                  # Daemon package 5266
6216                                                  # ###########################################################################
6217                                                  
6218                                                  package Daemon;
6219                                                  
6220           6                    6            54   use strict;
               6                                 21   
               6                                 43   
6221           6                    6            40   use warnings FATAL => 'all';
               6                                 16   
               6                                 36   
6222                                                  
6223           6                    6            37   use POSIX qw(setsid);
               6                                 16   
               6                                 40   
6224           6                    6            38   use English qw(-no_match_vars);
               6                                 13   
               6                                 36   
6225                                                  
6226  ***      6            50      6            45   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 15   
               6                                 88   
6227                                                  
6228                                                  sub new {
6229  ***      0                    0             0      my ( $class, %args ) = @_;
6230  ***      0                                  0      foreach my $arg ( qw(o) ) {
6231  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
6232                                                     }
6233  ***      0                                  0      my $o = $args{o};
6234  ***      0      0                           0      my $self = {
      ***             0                               
6235                                                        o        => $o,
6236                                                        log_file => $o->has('log') ? $o->get('log') : undef,
6237                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
6238                                                     };
6239                                                  
6240  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
6241                                                  
6242  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
6243  ***      0                                  0      return bless $self, $class;
6244                                                  }
6245                                                  
6246                                                  sub daemonize {
6247  ***      0                    0             0      my ( $self ) = @_;
6248                                                  
6249  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
6250  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
6251  ***      0      0                           0      if ( $pid ) {
6252  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
6253  ***      0                                  0         exit;
6254                                                     }
6255                                                  
6256  ***      0                                  0      $self->{child} = 1;
6257                                                  
6258  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
6259  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
6260                                                  
6261  ***      0                                  0      $self->_make_PID_file();
6262                                                  
6263  ***      0                                  0      $OUTPUT_AUTOFLUSH = 1;
6264                                                  
6265  ***      0      0                           0      if ( -t STDIN ) {
6266  ***      0                                  0         close STDIN;
6267  ***      0      0                           0         open  STDIN, '/dev/null'
6268                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
6269                                                     }
6270                                                  
6271  ***      0      0                           0      if ( $self->{log_file} ) {
6272  ***      0                                  0         close STDOUT;
6273  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
6274                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
6275                                                  
6276  ***      0                                  0         close STDERR;
6277  ***      0      0                           0         open  STDERR, ">&STDOUT"
6278                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
6279                                                     }
6280                                                     else {
6281  ***      0      0                           0         if ( -t STDOUT ) {
6282  ***      0                                  0            close STDOUT;
6283  ***      0      0                           0            open  STDOUT, '>', '/dev/null'
6284                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
6285                                                        }
6286  ***      0      0                           0         if ( -t STDERR ) {
6287  ***      0                                  0            close STDERR;
6288  ***      0      0                           0            open  STDERR, '>', '/dev/null'
6289                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
6290                                                        }
6291                                                     }
6292                                                  
6293  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
6294  ***      0                                  0      return;
6295                                                  }
6296                                                  
6297                                                  sub check_PID_file {
6298  ***      0                    0             0      my ( $self, $file ) = @_;
6299  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
6300  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
6301  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
6302  ***      0                                  0         my $pid;
6303  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
6304  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
6305  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
6306  ***      0      0                           0         if ( $pid ) {
6307  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
6308  ***      0      0                           0            if ( $pid_is_alive ) {
6309  ***      0                                  0               die "The PID file $PID_file already exists "
6310                                                                 . " and the PID that it contains, $pid, is running";
6311                                                           }
6312                                                           else {
6313  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
6314                                                                 . "contains, $pid, is not running";
6315                                                           }
6316                                                        }
6317                                                        else {
6318  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
6319                                                              . "contain a PID";
6320                                                        }
6321                                                     }
6322                                                     else {
6323  ***      0                                  0         MKDEBUG && _d('No PID file');
6324                                                     }
6325  ***      0                                  0      return;
6326                                                  }
6327                                                  
6328                                                  sub make_PID_file {
6329  ***      0                    0             0      my ( $self ) = @_;
6330  ***      0      0                           0      if ( exists $self->{child} ) {
6331  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
6332                                                     }
6333  ***      0                                  0      $self->_make_PID_file();
6334  ***      0                                  0      $self->{rm_PID_file} = 1;
6335  ***      0                                  0      return;
6336                                                  }
6337                                                  
6338                                                  sub _make_PID_file {
6339  ***      0                    0             0      my ( $self ) = @_;
6340                                                  
6341  ***      0                                  0      my $PID_file = $self->{PID_file};
6342  ***      0      0                           0      if ( !$PID_file ) {
6343  ***      0                                  0         MKDEBUG && _d('No PID file to create');
6344  ***      0                                  0         return;
6345                                                     }
6346                                                  
6347  ***      0                                  0      $self->check_PID_file();
6348                                                  
6349  ***      0      0                           0      open my $PID_FH, '>', $PID_file
6350                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
6351  ***      0      0                           0      print $PID_FH $PID
6352                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
6353  ***      0      0                           0      close $PID_FH
6354                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
6355                                                  
6356  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
6357  ***      0                                  0      return;
6358                                                  }
6359                                                  
6360                                                  sub _remove_PID_file {
6361  ***      0                    0             0      my ( $self ) = @_;
6362  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
6363  ***      0      0                           0         unlink $self->{PID_file}
6364                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
6365  ***      0                                  0         MKDEBUG && _d('Removed PID file');
6366                                                     }
6367                                                     else {
6368  ***      0                                  0         MKDEBUG && _d('No PID to remove');
6369                                                     }
6370  ***      0                                  0      return;
6371                                                  }
6372                                                  
6373                                                  sub DESTROY {
6374  ***      0                    0             0      my ( $self ) = @_;
6375  ***      0      0      0                    0      $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
6376  ***      0                                  0      return;
6377                                                  }
6378                                                  
6379                                                  sub _d {
6380  ***      0                    0             0      my ($package, undef, $line) = caller 0;
6381  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
6382  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
6383                                                          @_;
6384  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
6385                                                  }
6386                                                  
6387                                                  1;
6388                                                  
6389                                                  # ###########################################################################
6390                                                  # End Daemon package
6391                                                  # ###########################################################################
6392                                                  
6393                                                  # ###########################################################################
6394                                                  # MemcachedProtocolParser package 5535
6395                                                  # ###########################################################################
6396                                                  package MemcachedProtocolParser;
6397                                                  
6398           6                    6            51   use strict;
               6                                 18   
               6                                 33   
6399           6                    6            42   use warnings FATAL => 'all';
               6                                 13   
               6                                 37   
6400           6                    6            35   use English qw(-no_match_vars);
               6                                 15   
               6                                 32   
6401                                                  
6402           6                    6            44   use Data::Dumper;
               6                                 12   
               6                                 39   
6403                                                  $Data::Dumper::Indent    = 1;
6404                                                  $Data::Dumper::Sortkeys  = 1;
6405                                                  $Data::Dumper::Quotekeys = 0;
6406                                                  
6407  ***      6            50      6            40   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 15   
               6                                 94   
6408                                                  
6409                                                  sub new {
6410  ***      0                    0             0      my ( $class, %args ) = @_;
6411                                                  
6412  ***      0      0                           0      my ( $server_port )
6413                                                        = $args{server} ? $args{server} =~ m/:(\w+)/ : ('11211');
6414  ***      0             0                    0      $server_port ||= '11211';  # In case $args{server} doesn't have a port.
6415                                                  
6416  ***      0                                  0      my $self = {
6417                                                        server      => $args{server},
6418                                                        server_port => $server_port,
6419                                                        sessions    => {},
6420                                                        o           => $args{o},
6421                                                     };
6422  ***      0                                  0      return bless $self, $class;
6423                                                  }
6424                                                  
6425                                                  sub parse_event {
6426  ***      0                    0             0      my ( $self, %args ) = @_;
6427  ***      0                                  0      my @required_args = qw(event);
6428  ***      0                                  0      foreach my $arg ( @required_args ) {
6429  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
6430                                                     }
6431  ***      0                                  0      my $packet = @args{@required_args};
6432                                                  
6433  ***      0                                  0      my $src_host = "$packet->{src_host}:$packet->{src_port}";
6434  ***      0                                  0      my $dst_host = "$packet->{dst_host}:$packet->{dst_port}";
6435                                                  
6436  ***      0      0                           0      if ( my $server = $self->{server} ) {  # Watch only the given server.
6437  ***      0      0      0                    0         if ( $src_host ne $server && $dst_host ne $server ) {
6438  ***      0                                  0            MKDEBUG && _d('Packet is not to or from', $server);
6439  ***      0                                  0            return;
6440                                                        }
6441                                                     }
6442                                                  
6443  ***      0                                  0      my $packet_from;
6444  ***      0                                  0      my $client;
6445  ***      0      0                           0      if ( $src_host =~ m/:$self->{server_port}$/ ) {
      ***             0                               
6446  ***      0                                  0         $packet_from = 'server';
6447  ***      0                                  0         $client      = $dst_host;
6448                                                     }
6449                                                     elsif ( $dst_host =~ m/:$self->{server_port}$/ ) {
6450  ***      0                                  0         $packet_from = 'client';
6451  ***      0                                  0         $client      = $src_host;
6452                                                     }
6453                                                     else {
6454  ***      0                                  0         warn 'Packet is not to or from memcached server: ', Dumper($packet);
6455  ***      0                                  0         return;
6456                                                     }
6457  ***      0                                  0      MKDEBUG && _d('Client:', $client);
6458                                                  
6459  ***      0      0                           0      if ( !exists $self->{sessions}->{$client} ) {
6460  ***      0                                  0         MKDEBUG && _d('New session');
6461  ***      0                                  0         $self->{sessions}->{$client} = {
6462                                                           client      => $client,
6463                                                           state       => undef,
6464                                                           raw_packets => [],
6465                                                        };
6466                                                     };
6467  ***      0                                  0      my $session = $self->{sessions}->{$client};
6468                                                  
6469  ***      0      0                           0      if ( $packet->{data_len} == 0 ) {
6470  ***      0                                  0         MKDEBUG && _d('No TCP data');
6471  ***      0                                  0         return;
6472                                                     }
6473                                                  
6474  ***      0                                  0      push @{$session->{raw_packets}}, $packet->{raw_packet};
      ***      0                                  0   
6475                                                  
6476  ***      0                                  0      $packet->{data} = pack('H*', $packet->{data});
6477  ***      0                                  0      my $event;
6478  ***      0      0                           0      if ( $packet_from eq 'server' ) {
      ***             0                               
6479  ***      0                                  0         $event = $self->_packet_from_server($packet, $session, $args{misc});
6480                                                     }
6481                                                     elsif ( $packet_from eq 'client' ) {
6482  ***      0                                  0         $event = $self->_packet_from_client($packet, $session, $args{misc});
6483                                                     }
6484                                                     else {
6485  ***      0                                  0         die 'Packet origin unknown';
6486                                                     }
6487                                                  
6488  ***      0                                  0      MKDEBUG && _d('Done with packet; event:', Dumper($event));
6489  ***      0                                  0      return $event;
6490                                                  }
6491                                                  
6492                                                  sub _packet_from_server {
6493  ***      0                    0             0      my ( $self, $packet, $session, $misc ) = @_;
6494  ***      0      0                           0      die "I need a packet"  unless $packet;
6495  ***      0      0                           0      die "I need a session" unless $session;
6496                                                  
6497  ***      0                                  0      MKDEBUG && _d('Packet is from server; client state:', $session->{state}); 
6498                                                  
6499  ***      0                                  0      my $data = $packet->{data};
6500                                                  
6501  ***      0      0                           0      if ( !$session->{state} ) {
6502  ***      0                                  0         MKDEBUG && _d('Ignoring mid-stream server response');
6503  ***      0                                  0         return;
6504                                                     }
6505                                                  
6506  ***      0      0                           0      if ( $session->{state} eq 'awaiting reply' ) {
6507  ***      0                                  0         MKDEBUG && _d('State is awaiting reply');
6508  ***      0                                  0         my ($line1, $rest) = $packet->{data} =~ m/\A(.*?)\r\n(.*)?/s;
6509                                                  
6510  ***      0                                  0         my @vals = $line1 =~ m/(\S+)/g;
6511  ***      0                                  0         $session->{res} = shift @vals;
6512  ***      0                                  0         MKDEBUG && _d('Result of last', $session->{cmd}, 'cmd:', $session->{res});
6513                                                  
6514  ***      0      0      0                    0         if ( $session->{cmd} eq 'incr' || $session->{cmd} eq 'decr' ) {
      ***             0                               
      ***             0                               
      ***             0                               
6515  ***      0                                  0            MKDEBUG && _d('It is an incr or decr');
6516  ***      0      0                           0            if ( $session->{res} !~ m/\D/ ) { # It's an integer, not an error
6517  ***      0                                  0               MKDEBUG && _d('Got a value for the incr/decr');
6518  ***      0                                  0               $session->{val} = $session->{res};
6519  ***      0                                  0               $session->{res} = '';
6520                                                           }
6521                                                        }
6522                                                        elsif ( $session->{res} eq 'VALUE' ) {
6523  ***      0                                  0            MKDEBUG && _d('It is the result of a "get"');
6524  ***      0                                  0            my ($key, $flags, $bytes) = @vals;
6525  ***      0      0                           0            defined $session->{flags} or $session->{flags} = $flags;
6526  ***      0      0                           0            defined $session->{bytes} or $session->{bytes} = $bytes;
6527  ***      0      0      0                    0            if ( $rest && $bytes ) {
6528  ***      0                                  0               MKDEBUG && _d('There is a value');
6529  ***      0      0                           0               if ( length($rest) > $bytes ) {
6530  ***      0                                  0                  MKDEBUG && _d('Looks like we got the whole response');
6531  ***      0                                  0                  $session->{val} = substr($rest, 0, $bytes); # Got the whole response.
6532                                                              }
6533                                                              else {
6534  ***      0                                  0                  MKDEBUG && _d('Got partial response, saving for later');
6535  ***      0                                  0                  push @{$session->{partial}}, [ $packet->{seq}, $rest ];
      ***      0                                  0   
6536  ***      0                                  0                  $session->{gathered} += length($rest);
6537  ***      0                                  0                  $session->{state} = 'partial recv';
6538  ***      0                                  0                  return; # Prevent firing an event.
6539                                                              }
6540                                                           }
6541                                                        }
6542                                                        elsif ( $session->{res} eq 'END' ) {
6543  ***      0                                  0            MKDEBUG && _d('Got an END without any data, firing NOT_FOUND');
6544  ***      0                                  0            $session->{res} = 'NOT_FOUND';
6545                                                        }
6546                                                        elsif ( $session->{res} !~ m/STORED|DELETED|NOT_FOUND/ ) {
6547  ***      0                                  0            MKDEBUG && _d('Unknown result');
6548                                                        }
6549                                                     }
6550                                                     else { # Should be 'partial recv'
6551  ***      0                                  0         MKDEBUG && _d('Session state: ', $session->{state});
6552  ***      0                                  0         push @{$session->{partial}}, [ $packet->{seq}, $data ];
      ***      0                                  0   
6553  ***      0                                  0         $session->{gathered} += length($data);
6554                                                        MKDEBUG && _d('Gathered', $session->{gathered}, 'bytes in',
6555  ***      0                                  0            scalar(@{$session->{partial}}), 'packets from server');
6556  ***      0      0                           0         if ( $session->{gathered} >= $session->{bytes} + 2 ) { # Done.
6557  ***      0                                  0            MKDEBUG && _d('End of partial response, preparing event');
6558  ***      0                                  0            my $val = join('',
6559  ***      0                                  0               map  { $_->[1] }
6560  ***      0                                  0               sort { $a->[0] <=> $b->[0] }
6561  ***      0                                  0                    @{$session->{partial}});
6562  ***      0                                  0            $session->{val} = substr($val, 0, $session->{bytes});
6563                                                        }
6564                                                        else {
6565  ***      0                                  0            MKDEBUG && _d('Partial response continues, no action');
6566  ***      0                                  0            return; # Prevent firing event.
6567                                                        }
6568                                                     }
6569                                                  
6570  ***      0                                  0      MKDEBUG && _d('Creating event, deleting session');
6571  ***      0                                  0      my $event = make_event($session, $packet);
6572  ***      0                                  0      delete $self->{sessions}->{$session->{client}}; # memcached is stateless!
6573  ***      0                                  0      $session->{raw_packets} = []; # Avoid keeping forever
6574  ***      0                                  0      return $event;
6575                                                  }
6576                                                  
6577                                                  sub _packet_from_client {
6578  ***      0                    0             0      my ( $self, $packet, $session, $misc ) = @_;
6579  ***      0      0                           0      die "I need a packet"  unless $packet;
6580  ***      0      0                           0      die "I need a session" unless $session;
6581                                                  
6582  ***      0                                  0      MKDEBUG && _d('Packet is from client; state:', $session->{state});
6583                                                  
6584  ***      0                                  0      my $event;
6585  ***      0      0      0                    0      if ( ($session->{state} || '') =~m/awaiting reply|partial recv/ ) {
6586  ***      0                                  0         MKDEBUG && _d("Expected data from the client, looks like interrupted");
6587  ***      0                                  0         $session->{res} = 'INTERRUPTED';
6588  ***      0                                  0         $event = make_event($session, $packet);
6589  ***      0                                  0         my $client = $session->{client};
6590  ***      0                                  0         delete @{$session}{keys %$session};
      ***      0                                  0   
6591  ***      0                                  0         $session->{client} = $client;
6592                                                     }
6593                                                  
6594  ***      0                                  0      my ($line1, $val);
6595  ***      0                                  0      my ($cmd, $key, $flags, $exptime, $bytes);
6596                                                     
6597  ***      0      0                           0      if ( !$session->{state} ) {
6598  ***      0                                  0         MKDEBUG && _d('Session state: ', $session->{state});
6599  ***      0                                  0         ($line1, $val) = $packet->{data} =~ m/\A(.*?)\r\n(.+)?/s;
6600  ***      0                                  0         my @vals = $line1 =~ m/(\S+)/g;
6601  ***      0                                  0         $cmd = lc shift @vals;
6602  ***      0                                  0         MKDEBUG && _d('$cmd is a ', $cmd);
6603  ***      0      0      0                    0         if ( $cmd eq 'set' || $cmd eq 'add' || $cmd eq 'replace' ) {
      ***             0      0                        
      ***             0      0                        
      ***             0                               
6604  ***      0                                  0            ($key, $flags, $exptime, $bytes) = @vals;
6605  ***      0                                  0            $session->{bytes} = $bytes;
6606                                                        }
6607                                                        elsif ( $cmd eq 'get' ) {
6608  ***      0                                  0            ($key) = @vals;
6609  ***      0      0                           0            if ( $val ) {
6610  ***      0                                  0               MKDEBUG && _d('Multiple cmds:', $val);
6611  ***      0                                  0               $val = undef;
6612                                                           }
6613                                                        }
6614                                                        elsif ( $cmd eq 'delete' ) {
6615  ***      0                                  0            ($key) = @vals; # TODO: handle the <queue_time>
6616  ***      0      0                           0            if ( $val ) {
6617  ***      0                                  0               MKDEBUG && _d('Multiple cmds:', $val);
6618  ***      0                                  0               $val = undef;
6619                                                           }
6620                                                        }
6621                                                        elsif ( $cmd eq 'incr' || $cmd eq 'decr' ) {
6622  ***      0                                  0            ($key) = @vals;
6623                                                        }
6624                                                        else {
6625  ***      0                                  0            MKDEBUG && _d("Don't know how to handle", $cmd, "command");
6626                                                        }
6627  ***      0                                  0         @{$session}{qw(cmd key flags exptime)}
      ***      0                                  0   
6628                                                           = ($cmd, $key, $flags, $exptime);
6629  ***      0                                  0         $session->{host}       = $packet->{src_host};
6630  ***      0                                  0         $session->{pos_in_log} = $packet->{pos_in_log};
6631  ***      0                                  0         $session->{ts}         = $packet->{ts};
6632                                                     }
6633                                                     else {
6634  ***      0                                  0         MKDEBUG && _d('Session state: ', $session->{state});
6635  ***      0                                  0         $val = $packet->{data};
6636                                                     }
6637                                                  
6638  ***      0                                  0      $session->{state} = 'awaiting reply'; # Assume we got the whole packet
6639  ***      0      0                           0      if ( $val ) {
6640  ***      0      0                           0         if ( $session->{bytes} + 2 == length($val) ) { # +2 for the \r\n
6641  ***      0                                  0            MKDEBUG && _d('Got the whole thing');
6642  ***      0                                  0            $val =~ s/\r\n\Z//; # We got the whole thing.
6643  ***      0                                  0            $session->{val} = $val;
6644                                                        }
6645                                                        else { # We apparently did NOT get the whole thing.
6646  ***      0                                  0            MKDEBUG && _d('Partial send, saving for later');
6647  ***      0                                  0            push @{$session->{partial}},
      ***      0                                  0   
6648                                                              [ $packet->{seq}, $val ];
6649  ***      0                                  0            $session->{gathered} += length($val);
6650                                                           MKDEBUG && _d('Gathered', $session->{gathered}, 'bytes in',
6651  ***      0                                  0               scalar(@{$session->{partial}}), 'packets from client');
6652  ***      0      0                           0            if ( $session->{gathered} >= $session->{bytes} + 2 ) { # Done.
6653  ***      0                                  0               MKDEBUG && _d('Message looks complete now, saving value');
6654  ***      0                                  0               $val = join('',
6655  ***      0                                  0                  map  { $_->[1] }
6656  ***      0                                  0                  sort { $a->[0] <=> $b->[0] }
6657  ***      0                                  0                       @{$session->{partial}});
6658  ***      0                                  0               $val =~ s/\r\n\Z//;
6659  ***      0                                  0               $session->{val} = $val;
6660                                                           }
6661                                                           else {
6662  ***      0                                  0               MKDEBUG && _d('Message not complete');
6663  ***      0                                  0               $val = '[INCOMPLETE]';
6664  ***      0                                  0               $session->{state} = 'partial send';
6665                                                           }
6666                                                        }
6667                                                     }
6668                                                  
6669  ***      0                                  0      return $event;
6670                                                  }
6671                                                  
6672                                                  sub make_event {
6673  ***      0                    0             0      my ( $session, $packet ) = @_;
6674  ***      0             0                    0      my $event = {
      ***                    0                        
      ***                    0                        
      ***                    0                        
6675                                                        cmd        => $session->{cmd},
6676                                                        key        => $session->{key},
6677                                                        val        => $session->{val} || '',
6678                                                        res        => $session->{res},
6679                                                        ts         => $session->{ts},
6680                                                        host       => $session->{host},
6681                                                        flags      => $session->{flags}   || 0,
6682                                                        exptime    => $session->{exptime} || 0,
6683                                                        bytes      => $session->{bytes}   || 0,
6684                                                        Query_time => timestamp_diff($session->{ts}, $packet->{ts}),
6685                                                        pos_in_log => $session->{pos_in_log},
6686                                                     };
6687  ***      0                                  0      return $event;
6688                                                  }
6689                                                  
6690                                                  sub _get_errors_fh {
6691  ***      0                    0             0      my ( $self ) = @_;
6692  ***      0                                  0      my $errors_fh = $self->{errors_fh};
6693  ***      0      0                           0      return $errors_fh if $errors_fh;
6694                                                  
6695  ***      0                                  0      my $o = $self->{o};
6696  ***      0      0      0                    0      if ( $o && $o->has('tcpdump-errors') && $o->got('tcpdump-errors') ) {
      ***                    0                        
6697  ***      0                                  0         my $errors_file = $o->get('tcpdump-errors');
6698  ***      0                                  0         MKDEBUG && _d('tcpdump-errors file:', $errors_file);
6699  ***      0      0                           0         open $errors_fh, '>>', $errors_file
6700                                                           or die "Cannot open tcpdump-errors file $errors_file: $OS_ERROR";
6701                                                     }
6702                                                  
6703  ***      0                                  0      $self->{errors_fh} = $errors_fh;
6704  ***      0                                  0      return $errors_fh;
6705                                                  }
6706                                                  
6707                                                  sub fail_session {
6708  ***      0                    0             0      my ( $self, $session, $reason ) = @_;
6709  ***      0                                  0      my $errors_fh = $self->_get_errors_fh();
6710  ***      0      0                           0      if ( $errors_fh ) {
6711  ***      0                                  0         $session->{reason_for_failure} = $reason;
6712  ***      0                                  0         my $session_dump = '# ' . Dumper($session);
6713  ***      0                                  0         chomp $session_dump;
6714  ***      0                                  0         $session_dump =~ s/\n/\n# /g;
6715  ***      0                                  0         print $errors_fh "$session_dump\n";
6716                                                        {
6717  ***      0                                  0            local $LIST_SEPARATOR = "\n";
      ***      0                                  0   
6718  ***      0                                  0            print $errors_fh "@{$session->{raw_packets}}";
      ***      0                                  0   
6719  ***      0                                  0            print $errors_fh "\n";
6720                                                        }
6721                                                     }
6722  ***      0                                  0      MKDEBUG && _d('Failed session', $session->{client}, 'because', $reason);
6723  ***      0                                  0      delete $self->{sessions}->{$session->{client}};
6724  ***      0                                  0      return;
6725                                                  }
6726                                                  
6727                                                  sub _d {
6728  ***      0                    0             0      my ($package, undef, $line) = caller 0;
6729  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
6730  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
6731                                                          @_;
6732  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
6733                                                  }
6734                                                  
6735                                                  sub timestamp_diff {
6736  ***      0                    0             0      my ( $start, $end ) = @_;
6737  ***      0                                  0      my $sd = substr($start, 0, 11, '');
6738  ***      0                                  0      my $ed = substr($end,   0, 11, '');
6739  ***      0                                  0      my ( $sh, $sm, $ss ) = split(/:/, $start);
6740  ***      0                                  0      my ( $eh, $em, $es ) = split(/:/, $end);
6741  ***      0                                  0      my $esecs = ($eh * 3600 + $em * 60 + $es);
6742  ***      0                                  0      my $ssecs = ($sh * 3600 + $sm * 60 + $ss);
6743  ***      0      0                           0      if ( $sd eq $ed ) {
6744  ***      0                                  0         return sprintf '%.6f', $esecs - $ssecs;
6745                                                     }
6746                                                     else { # Assume only one day boundary has been crossed, no DST, etc
6747  ***      0                                  0         return sprintf '%.6f', ( 86_400 - $ssecs ) + $esecs;
6748                                                     }
6749                                                  }
6750                                                  
6751                                                  1;
6752                                                  
6753                                                  # ###########################################################################
6754                                                  # End MemcachedProtocolParser package
6755                                                  # ###########################################################################
6756                                                  
6757                                                  # ###########################################################################
6758                                                  # MemcachedEvent package 5266
6759                                                  # ###########################################################################
6760                                                  package MemcachedEvent;
6761                                                  
6762                                                  
6763           6                    6            47   use strict;
               6                                 16   
               6                                 43   
6764           6                    6            44   use warnings FATAL => 'all';
               6                                 14   
               6                                 37   
6765           6                    6            42   use English qw(-no_match_vars);
               6                                 14   
               6                                 32   
6766                                                  
6767           6                    6            42   use Data::Dumper;
               6                                 14   
               6                                 33   
6768                                                  $Data::Dumper::Indent    = 1;
6769                                                  $Data::Dumper::Sortkeys  = 1;
6770                                                  $Data::Dumper::Quotekeys = 0;
6771                                                  
6772  ***      6            50      6            38   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 18   
               6                                121   
6773                                                  
6774                                                  my %cmds = map { $_ => 1 } qw(
6775                                                     set
6776                                                     add
6777                                                     replace
6778                                                     append
6779                                                     prepend
6780                                                     cas
6781                                                     get
6782                                                     gets
6783                                                     delete
6784                                                     incr
6785                                                     decr
6786                                                  );
6787                                                  
6788                                                  my %cmd_handler_for = (
6789                                                     set      => \&handle_storage_cmd,
6790                                                     add      => \&handle_storage_cmd,
6791                                                     replace  => \&handle_storage_cmd,
6792                                                     append   => \&handle_storage_cmd,
6793                                                     prepend  => \&handle_storage_cmd,
6794                                                     cas      => \&handle_storage_cmd,
6795                                                     get      => \&handle_retr_cmd,
6796                                                     gets     => \&handle_retr_cmd,
6797                                                  );
6798                                                  
6799                                                  sub new {
6800  ***      0                    0             0      my ( $class, %args ) = @_;
6801  ***      0                                  0      my $self = {};
6802  ***      0                                  0      return bless $self, $class;
6803                                                  }
6804                                                  
6805                                                  sub parse_event {
6806  ***      0                    0             0      my ( $self, %args ) = @_;
6807  ***      0                                  0      my $event = $args{event};
6808  ***      0      0                           0      return unless $event;
6809                                                  
6810  ***      0      0      0                    0      if ( !$event->{cmd} || !$event->{key} ) {
6811  ***      0                                  0         MKDEBUG && _d('Event has no cmd or key:', Dumper($event));
6812  ***      0                                  0         return;
6813                                                     }
6814                                                  
6815  ***      0      0                           0      if ( !$cmds{$event->{cmd}} ) {
6816  ***      0                                  0         MKDEBUG && _d("Don't know how to handle cmd:", $event->{cmd});
6817  ***      0                                  0         return;
6818                                                     }
6819                                                  
6820  ***      0                                  0      $event->{arg}         = "$event->{cmd} $event->{key}";
6821  ***      0                                  0      $event->{fingerprint} = $self->fingerprint($event->{arg});
6822  ***      0                                  0      $event->{key_print}   = $self->fingerprint($event->{key});
6823                                                  
6824  ***      0                                  0      map { $event->{"Memc_$_"} = 'No' } keys %cmds;
      ***      0                                  0   
6825  ***      0                                  0      $event->{"Memc_$event->{cmd}"} = 'Yes';  # Got this cmd.
6826  ***      0                                  0      $event->{Memc_error}           = 'No';  # A handler may change this.
6827  ***      0                                  0      $event->{Memc_miss}            = 'No';
6828  ***      0      0                           0      if ( $event->{res} ) {
6829  ***      0      0                           0         $event->{Memc_miss}         = 'Yes' if $event->{res} eq 'NOT_FOUND';
6830                                                     }
6831                                                     else {
6832  ***      0                                  0         MKDEBUG && _d('Event has no res:', Dumper($event));
6833                                                     }
6834                                                  
6835  ***      0      0                           0      if ( $cmd_handler_for{$event->{cmd}} ) {
6836  ***      0                                  0         return $cmd_handler_for{$event->{cmd}}->($event);
6837                                                     }
6838                                                  
6839  ***      0                                  0      return $event;
6840                                                  }
6841                                                  
6842                                                  sub fingerprint {
6843  ***      0                    0             0      my ( $self, $val ) = @_;
6844  ***      0                                  0      $val =~ s/[0-9A-Fa-f]{16,}|\d+/?/g;
6845  ***      0                                  0      return $val;
6846                                                  }
6847                                                  
6848                                                  sub handle_storage_cmd {
6849  ***      0                    0             0      my ( $event ) = @_;
6850                                                  
6851  ***      0      0                           0      if ( !$event->{res} ) {
6852  ***      0                                  0         MKDEBUG && _d('No result for event:', Dumper($event));
6853  ***      0                                  0         return;
6854                                                     }
6855                                                  
6856  ***      0      0                           0      $event->{'Memc_Not_Stored'} = $event->{res} eq 'NOT_STORED' ? 'Yes' : 'No';
6857  ***      0      0                           0      $event->{'Memc_Exists'}     = $event->{res} eq 'EXISTS'     ? 'Yes' : 'No';
6858                                                  
6859  ***      0                                  0      return $event;
6860                                                  }
6861                                                  
6862                                                  sub handle_retr_cmd {
6863  ***      0                    0             0      my ( $event ) = @_;
6864                                                  
6865  ***      0      0                           0      if ( !$event->{res} ) {
6866  ***      0                                  0         MKDEBUG && _d('No result for event:', Dumper($event));
6867  ***      0                                  0         return;
6868                                                     }
6869                                                  
6870  ***      0      0                           0      $event->{'Memc_error'} = $event->{res} eq 'INTERRUPTED' ? 'Yes' : 'No';
6871                                                  
6872  ***      0                                  0      return $event;
6873                                                  }
6874                                                  
6875                                                  
6876                                                  sub handle_delete {
6877  ***      0                    0             0      my ( $event ) = @_;
6878  ***      0                                  0      return $event;
6879                                                  }
6880                                                  
6881                                                  sub handle_incr_decr_cmd {
6882  ***      0                    0             0      my ( $event ) = @_;
6883  ***      0                                  0      return $event;
6884                                                  }
6885                                                  
6886                                                  sub _d {
6887  ***      0                    0             0      my ($package, undef, $line) = caller 0;
6888  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
6889  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
6890                                                          @_;
6891  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
6892                                                  }
6893                                                  
6894                                                  1;
6895                                                  
6896                                                  # ###########################################################################
6897                                                  # End MemcachedEvent package
6898                                                  # ###########################################################################
6899                                                  
6900                                                  # ###########################################################################
6901                                                  # BinaryLogParser package 5358
6902                                                  # ###########################################################################
6903                                                  package BinaryLogParser;
6904                                                  
6905           6                    6            45   use strict;
               6                                 16   
               6                                 37   
6906           6                    6            38   use warnings FATAL => 'all';
               6                                 15   
               6                                 30   
6907           6                    6            36   use English qw(-no_match_vars);
               6                                 14   
               6                                 31   
6908                                                  
6909           6                    6            48   use Data::Dumper;
               6                                 15   
               6                                 33   
6910                                                  $Data::Dumper::Indent    = 1;
6911                                                  $Data::Dumper::Sortkeys  = 1;
6912                                                  $Data::Dumper::Quotekeys = 0;
6913                                                  
6914  ***      6            50      6            44   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 20   
               6                                106   
6915                                                  
6916                                                  sub new {
6917           2                    2            13      my ( $class, %args ) = @_;
6918           2                                 12      my $self = {
6919                                                        delim     => undef,
6920                                                        delim_len => 0,
6921                                                     };
6922           2                                 22      return bless $self, $class;
6923                                                  }
6924                                                  
6925                                                  my $binlog_line_1 = qr/at (\d+)$/m;
6926                                                  my $binlog_line_2 = qr/^#(\d{6}\s+\d{1,2}:\d\d:\d\d)\s+server\s+id\s+(\d+)\s+end_log_pos\s+(\d+)\s+(\S+)\s*([^\n]*)$/m;
6927                                                  my $binlog_line_2_rest = qr/thread_id=(\d+)\s+exec_time=(\d+)\s+error_code=(\d+)/m;
6928                                                  
6929                                                  sub parse_event {
6930          17                   17            91      my ( $self, %args ) = @_;
6931          17                                 79      my @required_args = qw(next_event tell);
6932          17                                 55      foreach my $arg ( @required_args ) {
6933  ***     34     50                         159         die "I need a $arg argument" unless $args{$arg};
6934                                                     }
6935          17                                 71      my ($next_event, $tell) = @args{@required_args};
6936                                                  
6937          17                                 89      local $INPUT_RECORD_SEPARATOR = ";\n#";
6938          17                                 63      my $pos_in_log = $tell->();
6939          17                                 39      my $stmt;
6940          17                                 83      my ($delim, $delim_len) = ($self->{delim}, $self->{delim_len});
6941                                                  
6942                                                     EVENT:
6943          17                                 56      while ( defined($stmt = $next_event->()) ) {
6944          18                                 69         my @properties = ('pos_in_log', $pos_in_log);
6945          18                                 56         my ($ts, $sid, $end, $type, $rest);
6946          18                                 56         $pos_in_log = $tell->();
6947          18                                117         $stmt =~ s/;\n#?\Z//;
6948                                                  
6949          18                                 48         my ( $got_offset, $got_hdr );
6950          18                                 47         my $pos = 0;
6951          18                                 49         my $len = length($stmt);
6952          18                                 46         my $found_arg = 0;
6953                                                        LINE:
6954          18                                116         while ( $stmt =~ m/^(.*)$/mg ) { # /g requires scalar match.
6955          74                                206            $pos     = pos($stmt);  # Be careful not to mess this up!
6956          74                                254            my $line = $1;          # Necessary for /g and pos() to work.
6957          74    100                         357            $line    =~ s/$delim// if $delim;
6958          74                                166            MKDEBUG && _d($line);
6959                                                  
6960          74    100                         300            if ( $line =~ m/^\/\*.+\*\/;/ ) {
6961           6                                 12               MKDEBUG && _d('Comment line');
6962           6                                 35               next LINE;
6963                                                           }
6964                                                   
6965          68    100                         247            if ( $line =~ m/^DELIMITER/m ) {
6966           3                                 23               my ( $del ) = $line =~ m/^DELIMITER (\S*)$/m;
6967           3    100                          13               if ( $del ) {
6968           2                                  8                  $self->{delim_len} = $delim_len = length $del;
6969           2                                 10                  $self->{delim}     = $delim     = quotemeta $del;
6970           2                                  8                  MKDEBUG && _d('delimiter:', $delim);
6971                                                              }
6972                                                              else {
6973           1                                  2                  MKDEBUG && _d('Delimiter reset to ;');
6974           1                                  5                  $self->{delim}     = $delim     = undef;
6975           1                                  4                  $self->{delim_len} = $delim_len = 0;
6976                                                              }
6977           3                                 15               next LINE;
6978                                                           }
6979                                                  
6980          65    100                         242            next LINE if $line =~ m/End of log file/;
6981                                                  
6982          63    100    100                  699            if ( !$got_offset && (my ( $offset ) = $line =~ m/$binlog_line_1/m) ) {
                    100    100                        
                    100                               
6983          14                                 36               MKDEBUG && _d('Got the at offset line');
6984          14                                 51               push @properties, 'offset', $offset;
6985          14                                 92               $got_offset++;
6986                                                           }
6987                                                  
6988                                                           elsif ( !$got_hdr && $line =~ m/^#(\d{6}\s+\d{1,2}:\d\d:\d\d)/ ) {
6989          14                                185               ($ts, $sid, $end, $type, $rest) = $line =~ m/$binlog_line_2/m;
6990          14                                 41               MKDEBUG && _d('Got the header line; type:', $type, 'rest:', $rest);
6991          14                                 70               push @properties, 'cmd', 'Query', 'ts', $ts, 'server_id', $sid,
6992                                                                 'end_log_pos', $end;
6993          14                                 85               $got_hdr++;
6994                                                           }
6995                                                  
6996                                                           elsif ( $line =~ m/^(?:#|use |SET)/i ) {
6997                                                  
6998          20    100                         189               if ( my ( $db ) = $line =~ m/^use ([^;]+)/ ) {
                    100                               
6999           2                                  5                  MKDEBUG && _d("Got a default database:", $db);
7000           2                                 16                  push @properties, 'db', $db;
7001                                                              }
7002                                                  
7003                                                              elsif ( my ($setting) = $line =~ m/^SET\s+([^;]*)/ ) {
7004          17                                 40                  MKDEBUG && _d("Got some setting:", $setting);
7005          17                                236                  push @properties, map { s/\s+//; lc } split(/,|\s*=\s*/, $setting);
              50                                130   
              50                                244   
7006                                                              }
7007                                                  
7008                                                           }
7009                                                           else {
7010          15                                 34               MKDEBUG && _d("Got the query/arg line at pos", $pos);
7011          15                                 40               $found_arg++;
7012  ***     15    100     66                  125               if ( $got_offset && $got_hdr ) {
7013          13    100                          66                  if ( $type eq 'Xid' ) {
                    100                               
      ***            50                               
7014           3                                 20                     my ($xid) = $rest =~ m/(\d+)/;
7015           3                                 13                     push @properties, 'Xid', $xid;
7016                                                                 }
7017                                                                 elsif ( $type eq 'Query' ) {
7018           9                                 87                     my ($i, $t, $c) = $rest =~ m/$binlog_line_2_rest/m;
7019           9                                 50                     push @properties, 'Thread_id', $i, 'Query_time', $t,
7020                                                                                      'error_code', $c;
7021                                                                 }
7022                                                                 elsif ( $type eq 'Start:' ) {
7023           1                                  6                     MKDEBUG && _d("Binlog start");
7024                                                                 }
7025                                                                 else {
7026  ***      0                                  0                     MKDEBUG && _d('Unknown event type:', $type);
7027  ***      0                                  0                     next EVENT;
7028                                                                 }
7029                                                              }
7030                                                              else {
7031           2                                  7                  MKDEBUG && _d("It's not a query/arg, it's just some SQL fluff");
7032           2                                 10                  push @properties, 'cmd', 'Query', 'ts', undef;
7033                                                              }
7034                                                  
7035          15    100                          63               my $delim_len = ($pos == length($stmt) ? $delim_len : 0);
7036          15                                 74               my $arg = substr($stmt, $pos - length($line) - $delim_len);
7037                                                  
7038          15    100                          89               $arg =~ s/$delim// if $delim; # Remove the delimiter.
7039                                                  
7040          15    100                          63               if ( $arg =~ m/^DELIMITER/m ) {
7041           1                                  6                  my ( $del ) = $arg =~ m/^DELIMITER (\S*)$/m;
7042  ***      1     50                           4                  if ( $del ) {
7043  ***      0                                  0                     $self->{delim_len} = $delim_len = length $del;
7044  ***      0                                  0                     $self->{delim}     = $delim     = quotemeta $del;
7045  ***      0                                  0                     MKDEBUG && _d('delimiter:', $delim);
7046                                                                 }
7047                                                                 else {
7048           1                                  2                     MKDEBUG && _d('Delimiter reset to ;');
7049           1                                  3                     $del       = ';';
7050           1                                  4                     $self->{delim}     = $delim     = undef;
7051           1                                  4                     $self->{delim_len} = $delim_len = 0;
7052                                                                 }
7053                                                  
7054           1                                  5                  $arg =~ s/^DELIMITER.*$//m;  # Remove DELIMITER from arg.
7055                                                              }
7056                                                  
7057          15                                 53               $arg =~ s/;$//gm;  # Ensure ending ; are gone.
7058          15                                 94               $arg =~ s/\s+$//;  # Remove trailing spaces and newlines.
7059                                                  
7060          15                                 78               push @properties, 'arg', $arg, 'bytes', length($arg);
7061          15                                 49               last LINE;
7062                                                           }
7063                                                        } # LINE
7064                                                  
7065          18    100                          60         if ( $found_arg ) {
7066          15                                 32            MKDEBUG && _d('Properties of event:', Dumper(\@properties));
7067          15                                149            my $event = { @properties };
7068          15                                132            return $event;
7069                                                        }
7070                                                        else {
7071           3                                 15            MKDEBUG && _d('Event had no arg');
7072                                                        }
7073                                                     } # EVENT
7074                                                  
7075  ***      2     50                          15      $args{oktorun}->(0) if $args{oktorun};
7076           2                                 14      return;
7077                                                  }
7078                                                  
7079                                                  sub _d {
7080  ***      0                    0             0      my ($package, undef, $line) = caller 0;
7081  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
7082  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
7083                                                          @_;
7084  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
7085                                                  }
7086                                                  
7087                                                  1;
7088                                                  
7089                                                  # ###########################################################################
7090                                                  # End BinaryLogParser package
7091                                                  # ###########################################################################
7092                                                  
7093                                                  # ###########################################################################
7094                                                  # GeneralLogParser package 5359
7095                                                  # ###########################################################################
7096                                                  package GeneralLogParser;
7097                                                  
7098           6                    6            61   use strict;
               6                                 16   
               6                                 33   
7099           6                    6            38   use warnings FATAL => 'all';
               6                                 15   
               6                                 32   
7100           6                    6            47   use English qw(-no_match_vars);
               6                                 16   
               6                                 35   
7101                                                  
7102           6                    6            44   use Data::Dumper;
               6                                 13   
               6                                 32   
7103                                                  $Data::Dumper::Indent    = 1;
7104                                                  $Data::Dumper::Sortkeys  = 1;
7105                                                  $Data::Dumper::Quotekeys = 0;
7106                                                  
7107  ***      6            50      6            38   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 20   
               6                                 94   
7108                                                  
7109                                                  sub new {
7110           1                    1             5      my ( $class ) = @_;
7111           1                                  7      my $self = {
7112                                                        pending => [],
7113                                                        db_for  => {},
7114                                                     };
7115           1                                 19      return bless $self, $class;
7116                                                  }
7117                                                  
7118                                                  my $genlog_line_1= qr{
7119                                                     \A
7120                                                     (?:(\d{6}\s\d{1,2}:\d\d:\d\d))? # Timestamp
7121                                                     \s+
7122                                                     (?:\s*(\d+))                        # Thread ID
7123                                                     \s
7124                                                     (\w+)                               # Command
7125                                                     \s+
7126                                                     (.*)                                # Argument
7127                                                     \Z
7128                                                  }xs;
7129                                                  
7130                                                  sub parse_event {
7131           8                    8            44      my ( $self, %args ) = @_;
7132           8                                 66      my @required_args = qw(next_event tell);
7133           8                                 28      foreach my $arg ( @required_args ) {
7134  ***     16     50                          75         die "I need a $arg argument" unless $args{$arg};
7135                                                     }
7136           8                                 37      my ($next_event, $tell) = @args{@required_args};
7137                                                  
7138           8                                 25      my $pending = $self->{pending};
7139           8                                 29      my $db_for  = $self->{db_for};
7140           8                                 20      my $line;
7141           8                                 28      my $pos_in_log = $tell->();
7142                                                     LINE:
7143           8           100                   59      while (
7144                                                           defined($line = shift @$pending)
7145                                                        or defined($line = $next_event->())
7146                                                     ) {
7147           7                                 19         MKDEBUG && _d($line);
7148           7                                 98         my ($ts, $thread_id, $cmd, $arg) = $line =~ m/$genlog_line_1/;
7149  ***      7     50     33                   89         if ( !($thread_id && $cmd) ) {
7150  ***      0                                  0            MKDEBUG && _d('Not start of general log event');
7151  ***      0                                  0            next;
7152                                                        }
7153           7                                 34         my @properties = ('pos_in_log', $pos_in_log, 'ts', $ts,
7154                                                           'Thread_id', $thread_id);
7155                                                  
7156           7                                 22         $pos_in_log = $tell->();
7157                                                  
7158           7                                 22         @$pending = ();
7159           7    100                          27         if ( $cmd eq 'Query' ) {
7160           2                                  7            my $done = 0;
7161           2                                  5            do {
7162           5                                 16               $line = $next_event->();
7163  ***      5     50                          18               if ( $line ) {
7164           5                                112                  ($ts, $thread_id, $cmd, undef) = $line =~ m/$genlog_line_1/;
7165  ***      5    100     66                   39                  if ( $thread_id && $cmd ) {
7166           2                                  5                     MKDEBUG && _d('Event done');
7167           2                                  5                     $done = 1;
7168           2                                 17                     push @$pending, $line;
7169                                                                 }
7170                                                                 else {
7171           3                                  6                     MKDEBUG && _d('More arg:', $line);
7172           3                                 16                     $arg .= $line;
7173                                                                 }
7174                                                              }
7175                                                              else {
7176  ***      0                                  0                  MKDEBUG && _d('No more lines');
7177  ***      0                                  0                  $done = 1;
7178                                                              }
7179                                                           } until ( $done );
7180                                                  
7181           2                                  7            chomp $arg;
7182           2                                  8            push @properties, 'cmd', 'Query', 'arg', $arg;
7183           2                                  7            push @properties, 'bytes', length($properties[-1]);
7184  ***      2     50                          14            push @properties, 'db', $db_for->{$thread_id} if $db_for->{$thread_id};
7185                                                        }
7186                                                        else {
7187           5                                 19            push @properties, 'cmd', 'Admin';
7188                                                  
7189           5    100                          26            if ( $cmd eq 'Connect' ) {
                    100                               
7190  ***      2     50                          10               if ( $arg =~ m/^Access denied/ ) {
7191  ***      0                                  0                  $cmd = $arg;
7192                                                              }
7193                                                              else {
7194           2                                 18                  my ($user, undef, $db) = $arg =~ /(\S+)/g;
7195           2                                  6                  my $host;
7196           2                                 24                  ($user, $host) = split(/@/, $user);
7197           2                                  5                  MKDEBUG && _d('Connect', $user, '@', $host, 'on', $db);
7198                                                  
7199  ***      2     50                          11                  push @properties, 'user', $user if $user;
7200  ***      2     50                           9                  push @properties, 'host', $host if $host;
7201           2    100                          11                  push @properties, 'db',   $db   if $db;
7202           2                                 12                  $db_for->{$thread_id} = $db;
7203                                                              }
7204                                                           }
7205                                                           elsif ( $cmd eq 'Init' ) {
7206           1                                  3               $cmd = 'Init DB';
7207           1                                  8               $arg =~ s/^DB\s+//;
7208           1                                  5               my ($db) = $arg =~ /(\S+)/;
7209           1                                  3               MKDEBUG && _d('Init DB:', $db);
7210  ***      1     50                           7               push @properties, 'db',   $db   if $db;
7211           1                                  4               $db_for->{$thread_id} = $db;
7212                                                           }
7213                                                  
7214           5                                 26            push @properties, 'arg', "administrator command: $cmd";
7215           5                                 23            push @properties, 'bytes', length($properties[-1]);
7216                                                        }
7217                                                  
7218           7                                 22         push @properties, 'Query_time', 0;
7219                                                  
7220           7                                 16         MKDEBUG && _d('Properties of event:', Dumper(\@properties));
7221           7                                 54         my $event = { @properties };
7222           7                                 53         return $event;
7223                                                     } # LINE
7224                                                  
7225           1                                  3      @{$self->{pending}} = ();
               1                                  4   
7226  ***      1     50                          10      $args{oktorun}->(0) if $args{oktorun};
7227           1                                  7      return;
7228                                                  }
7229                                                  
7230                                                  sub _d {
7231  ***      0                    0             0      my ($package, undef, $line) = caller 0;
7232  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
7233  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
7234                                                          @_;
7235  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
7236                                                  }
7237                                                  
7238                                                  1;
7239                                                  
7240                                                  # ###########################################################################
7241                                                  # End GeneralLogParser package
7242                                                  # ###########################################################################
7243                                                  
7244                                                  # ###########################################################################
7245                                                  # ProtocolParser package 5266
7246                                                  # ###########################################################################
7247                                                  package ProtocolParser;
7248                                                  
7249           6                    6            44   use strict;
               6                                 13   
               6                                 32   
7250           6                    6            36   use warnings FATAL => 'all';
               6                                 13   
               6                                 32   
7251           6                    6            41   use English qw(-no_match_vars);
               6                                 13   
               6                                 30   
7252                                                  
7253                                                  eval {
7254                                                     require IO::Uncompress::Inflate;
7255                                                     IO::Uncompress::Inflate->import(qw(inflate $InflateError));
7256                                                  };
7257                                                  
7258           6                    6            41   use Data::Dumper;
               6                                 16   
               6                                 29   
7259                                                  $Data::Dumper::Indent    = 1;
7260                                                  $Data::Dumper::Sortkeys  = 1;
7261                                                  $Data::Dumper::Quotekeys = 0;
7262                                                  
7263  ***      6            50      6            40   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 15   
               6                                 86   
7264                                                  
7265                                                  sub new {
7266  ***      0                    0             0      my ( $class, %args ) = @_;
7267                                                  
7268  ***      0      0                           0      my ($server_port) = $args{server} =~ m/:(\w+)/ if $args{server};
7269  ***      0      0      0                    0      $server_port      = $args{server_port} if !$server_port && $args{server_port};
7270                                                  
7271  ***      0                                  0      my $self = {
7272                                                        server      => $args{server},
7273                                                        server_port => $server_port,
7274                                                        sessions    => {},
7275                                                        o           => $args{o},
7276                                                     };
7277                                                  
7278  ***      0                                  0      return bless $self, $class;
7279                                                  }
7280                                                  
7281                                                  sub parse_event {
7282  ***      0                    0             0      my ( $self, %args ) = @_;
7283  ***      0                                  0      my @required_args = qw(event);
7284  ***      0                                  0      foreach my $arg ( @required_args ) {
7285  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
7286                                                     }
7287  ***      0                                  0      my $packet = @args{@required_args};
7288                                                  
7289  ***      0      0                           0      if ( $self->{buffer} ) {
7290  ***      0                                  0         my ($packet_from, $session) = $self->_get_session($packet);
7291  ***      0      0                           0         if ( $packet->{data_len} ) {
7292  ***      0      0                           0            if ( $packet_from eq 'client' ) {
7293  ***      0                                  0               push @{$session->{client_packets}}, $packet;
      ***      0                                  0   
7294  ***      0                                  0               MKDEBUG && _d('Saved client packet');
7295                                                           }
7296                                                           else {
7297  ***      0                                  0               push @{$session->{server_packets}}, $packet;
      ***      0                                  0   
7298  ***      0                                  0               MKDEBUG && _d('Saved server packet');
7299                                                           }
7300                                                        }
7301                                                  
7302  ***      0      0      0                    0         return unless ($packet_from eq 'client')
      ***                    0                        
7303                                                                      && ($packet->{fin} || $packet->{rst});
7304                                                  
7305  ***      0                                  0         my $event;
7306  ***      0                                  0         map {
7307  ***      0                                  0            $event = $self->_parse_packet($_, $args{misc});
7308  ***      0                                  0         } sort { $a->{seq} <=> $b->{seq} }
7309  ***      0                                  0         @{$session->{client_packets}};
7310                                                        
7311  ***      0                                  0         map {
7312  ***      0                                  0            $event = $self->_parse_packet($_, $args{misc});
7313  ***      0                                  0         } sort { $a->{seq} <=> $b->{seq} }
7314  ***      0                                  0         @{$session->{server_packets}};
7315                                                  
7316  ***      0                                  0         return $event;
7317                                                     }
7318                                                  
7319  ***      0      0                           0      if ( $packet->{data_len} == 0 ) {
7320  ***      0                                  0         MKDEBUG && _d('No TCP data');
7321  ***      0                                  0         return;
7322                                                     }
7323                                                  
7324  ***      0                                  0      return $self->_parse_packet($packet, $args{misc});
7325                                                  }
7326                                                  
7327                                                  sub _parse_packet {
7328  ***      0                    0             0      my ( $self, $packet, $misc ) = @_;
7329                                                  
7330  ***      0                                  0      my ($packet_from, $session) = $self->_get_session($packet);
7331  ***      0                                  0      MKDEBUG && _d('State:', $session->{state});
7332                                                  
7333  ***      0      0                           0      push @{$session->{raw_packets}}, $packet->{raw_packet}
      ***      0                                  0   
7334                                                        unless $misc->{recurse};
7335                                                  
7336  ***      0      0                           0      if ( $session->{buff} ) {
7337  ***      0                                  0         $session->{buff_left} -= $packet->{data_len};
7338  ***      0      0                           0         if ( $session->{buff_left} > 0 ) {
7339  ***      0                                  0            MKDEBUG && _d('Added data to buff; expecting', $session->{buff_left},
7340                                                              'more bytes');
7341  ***      0                                  0            return;
7342                                                        }
7343                                                  
7344  ***      0                                  0         MKDEBUG && _d('Got all data; buff left:', $session->{buff_left});
7345  ***      0                                  0         $packet->{data}       = $session->{buff} . $packet->{data};
7346  ***      0                                  0         $packet->{data_len}  += length $session->{buff};
7347  ***      0                                  0         $session->{buff}      = '';
7348  ***      0                                  0         $session->{buff_left} = 0;
7349                                                     }
7350                                                  
7351  ***      0      0                           0      $packet->{data} = pack('H*', $packet->{data}) unless $misc->{recurse};
7352  ***      0                                  0      my $event;
7353  ***      0      0                           0      if ( $packet_from eq 'server' ) {
      ***             0                               
7354  ***      0                                  0         $event = $self->_packet_from_server($packet, $session, $misc);
7355                                                     }
7356                                                     elsif ( $packet_from eq 'client' ) {
7357  ***      0                                  0         $event = $self->_packet_from_client($packet, $session, $misc);
7358                                                     }
7359                                                     else {
7360  ***      0                                  0         die 'Packet origin unknown';
7361                                                     }
7362  ***      0                                  0      MKDEBUG && _d('State:', $session->{state});
7363                                                  
7364  ***      0      0                           0      if ( $session->{out_of_order} ) {
7365  ***      0                                  0         MKDEBUG && _d('Session packets are out of order');
7366  ***      0                                  0         push @{$session->{packets}}, $packet;
      ***      0                                  0   
7367  ***      0      0      0                    0         $session->{ts_min}
7368                                                           = $packet->{ts} if $packet->{ts} lt ($session->{ts_min} || '');
7369  ***      0      0      0                    0         $session->{ts_max}
7370                                                           = $packet->{ts} if $packet->{ts} gt ($session->{ts_max} || '');
7371  ***      0      0                           0         if ( $session->{have_all_packets} ) {
7372  ***      0                                  0            MKDEBUG && _d('Have all packets; ordering and processing');
7373  ***      0                                  0            delete $session->{out_of_order};
7374  ***      0                                  0            delete $session->{have_all_packets};
7375  ***      0                                  0            map {
7376  ***      0                                  0               $event = $self->_parse_packet($_, { recurse => 1 });
7377  ***      0                                  0            } sort { $a->{seq} <=> $b->{seq} } @{$session->{packets}};
      ***      0                                  0   
7378                                                        }
7379                                                     }
7380                                                  
7381  ***      0                                  0      MKDEBUG && _d('Done with packet; event:', Dumper($event));
7382  ***      0                                  0      return $event;
7383                                                  }
7384                                                  
7385                                                  sub _get_session {
7386  ***      0                    0             0      my ( $self, $packet ) = @_;
7387                                                  
7388  ***      0                                  0      my $src_host = "$packet->{src_host}:$packet->{src_port}";
7389  ***      0                                  0      my $dst_host = "$packet->{dst_host}:$packet->{dst_port}";
7390                                                  
7391  ***      0      0                           0      if ( my $server = $self->{server} ) {  # Watch only the given server.
7392  ***      0      0      0                    0         if ( $src_host ne $server && $dst_host ne $server ) {
7393  ***      0                                  0            MKDEBUG && _d('Packet is not to or from', $server);
7394  ***      0                                  0            return;
7395                                                        }
7396                                                     }
7397                                                  
7398  ***      0                                  0      my $packet_from;
7399  ***      0                                  0      my $client;
7400  ***      0      0                           0      if ( $src_host =~ m/:$self->{server_port}$/ ) {
      ***             0                               
7401  ***      0                                  0         $packet_from = 'server';
7402  ***      0                                  0         $client      = $dst_host;
7403                                                     }
7404                                                     elsif ( $dst_host =~ m/:$self->{server_port}$/ ) {
7405  ***      0                                  0         $packet_from = 'client';
7406  ***      0                                  0         $client      = $src_host;
7407                                                     }
7408                                                     else {
7409  ***      0                                  0         warn 'Packet is not to or from server: ', Dumper($packet);
7410  ***      0                                  0         return;
7411                                                     }
7412  ***      0                                  0      MKDEBUG && _d('Client:', $client);
7413                                                  
7414  ***      0      0                           0      if ( !exists $self->{sessions}->{$client} ) {
7415  ***      0                                  0         MKDEBUG && _d('New session');
7416  ***      0                                  0         $self->{sessions}->{$client} = {
7417                                                           client      => $client,
7418                                                           state       => undef,
7419                                                           raw_packets => [],
7420                                                        };
7421                                                     };
7422  ***      0                                  0      my $session = $self->{sessions}->{$client};
7423                                                  
7424  ***      0                                  0      return $packet_from, $session;
7425                                                  }
7426                                                  
7427                                                  sub _packet_from_server {
7428  ***      0                    0             0      die "Don't call parent class _packet_from_server()";
7429                                                  }
7430                                                  
7431                                                  sub _packet_from_client {
7432  ***      0                    0             0      die "Don't call parent class _packet_from_client()";
7433                                                  }
7434                                                  
7435                                                  sub make_event {
7436  ***      0                    0             0      my ( $self, $session, $packet ) = @_;
7437  ***      0      0                           0      die "Event has no attributes" unless scalar keys %{$session->{attribs}};
      ***      0                                  0   
7438  ***      0      0                           0      die "Query has no arg attribute" unless $session->{attribs}->{arg};
7439  ***      0             0                    0      my $start_request = $session->{start_request} || 0;
7440  ***      0             0                    0      my $start_reply   = $session->{start_reply}   || 0;
7441  ***      0             0                    0      my $end_reply     = $session->{end_reply}     || 0;
7442  ***      0                                  0      MKDEBUG && _d('Request start:', $start_request,
7443                                                        'reply start:', $start_reply, 'reply end:', $end_reply);
7444  ***      0                                  0      my $event = {
7445                                                        Query_time    => $self->timestamp_diff($start_request, $start_reply),
7446                                                        Transmit_time => $self->timestamp_diff($start_reply, $end_reply),
7447                                                     };
7448  ***      0                                  0      @{$event}{keys %{$session->{attribs}}} = values %{$session->{attribs}};
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
7449  ***      0                                  0      return $event;
7450                                                  }
7451                                                  
7452                                                  sub _get_errors_fh {
7453  ***      0                    0             0      my ( $self ) = @_;
7454  ***      0                                  0      my $errors_fh = $self->{errors_fh};
7455  ***      0      0                           0      return $errors_fh if $errors_fh;
7456                                                  
7457  ***      0                                  0      my $o = $self->{o};
7458  ***      0      0      0                    0      if ( $o && $o->has('tcpdump-errors') && $o->got('tcpdump-errors') ) {
      ***                    0                        
7459  ***      0                                  0         my $errors_file = $o->get('tcpdump-errors');
7460  ***      0                                  0         MKDEBUG && _d('tcpdump-errors file:', $errors_file);
7461  ***      0      0                           0         open $errors_fh, '>>', $errors_file
7462                                                           or die "Cannot open tcpdump-errors file $errors_file: $OS_ERROR";
7463                                                     }
7464                                                  
7465  ***      0                                  0      $self->{errors_fh} = $errors_fh;
7466  ***      0                                  0      return $errors_fh;
7467                                                  }
7468                                                  
7469                                                  sub fail_session {
7470  ***      0                    0             0      my ( $self, $session, $reason ) = @_;
7471  ***      0                                  0      my $errors_fh = $self->_get_errors_fh();
7472  ***      0      0                           0      if ( $errors_fh ) {
7473  ***      0                                  0         $session->{reason_for_failure} = $reason;
7474  ***      0                                  0         my $session_dump = '# ' . Dumper($session);
7475  ***      0                                  0         chomp $session_dump;
7476  ***      0                                  0         $session_dump =~ s/\n/\n# /g;
7477  ***      0                                  0         print $errors_fh "$session_dump\n";
7478                                                        {
7479  ***      0                                  0            local $LIST_SEPARATOR = "\n";
      ***      0                                  0   
7480  ***      0                                  0            print $errors_fh "@{$session->{raw_packets}}";
      ***      0                                  0   
7481  ***      0                                  0            print $errors_fh "\n";
7482                                                        }
7483                                                     }
7484  ***      0                                  0      MKDEBUG && _d('Failed session', $session->{client}, 'because', $reason);
7485  ***      0                                  0      delete $self->{sessions}->{$session->{client}};
7486  ***      0                                  0      return;
7487                                                  }
7488                                                  
7489                                                  sub timestamp_diff {
7490  ***      0                    0             0      my ( $self, $start, $end ) = @_;
7491  ***      0      0      0                    0      return 0 unless $start && $end;
7492  ***      0                                  0      my $sd = substr($start, 0, 11, '');
7493  ***      0                                  0      my $ed = substr($end,   0, 11, '');
7494  ***      0                                  0      my ( $sh, $sm, $ss ) = split(/:/, $start);
7495  ***      0                                  0      my ( $eh, $em, $es ) = split(/:/, $end);
7496  ***      0                                  0      my $esecs = ($eh * 3600 + $em * 60 + $es);
7497  ***      0                                  0      my $ssecs = ($sh * 3600 + $sm * 60 + $ss);
7498  ***      0      0                           0      if ( $sd eq $ed ) {
7499  ***      0                                  0         return sprintf '%.6f', $esecs - $ssecs;
7500                                                     }
7501                                                     else { # Assume only one day boundary has been crossed, no DST, etc
7502  ***      0                                  0         return sprintf '%.6f', ( 86_400 - $ssecs ) + $esecs;
7503                                                     }
7504                                                  }
7505                                                  
7506                                                  sub uncompress_data {
7507  ***      0                    0             0      my ( $self, $data, $len ) = @_;
7508  ***      0      0                           0      die "I need data" unless $data;
7509  ***      0      0                           0      die "I need a len argument" unless $len;
7510  ***      0      0                           0      die "I need a scalar reference to data" unless ref $data eq 'SCALAR';
7511  ***      0                                  0      MKDEBUG && _d('Uncompressing data');
7512  ***      0                                  0      our $InflateError;
7513                                                  
7514  ***      0                                  0      my $comp_bin_data = pack('H*', $$data);
7515                                                  
7516  ***      0                                  0      my $uncomp_bin_data = '';
7517  ***      0      0                           0      my $z = new IO::Uncompress::Inflate(
7518                                                        \$comp_bin_data
7519                                                     ) or die "IO::Uncompress::Inflate failed: $InflateError";
7520  ***      0      0                           0      my $status = $z->read(\$uncomp_bin_data, $len)
7521                                                        or die "IO::Uncompress::Inflate failed: $InflateError";
7522                                                  
7523  ***      0                                  0      my $uncomp_data = unpack('H*', $uncomp_bin_data);
7524                                                  
7525  ***      0                                  0      return \$uncomp_data;
7526                                                  }
7527                                                  
7528                                                  sub _d {
7529  ***      0                    0             0      my ($package, undef, $line) = caller 0;
7530  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
7531  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
7532                                                          @_;
7533  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
7534                                                  }
7535                                                  
7536                                                  1;
7537                                                  
7538                                                  # ###########################################################################
7539                                                  # End ProtocolParser package
7540                                                  # ###########################################################################
7541                                                  
7542                                                  # ###########################################################################
7543                                                  # HTTPProtocolParser package 5591
7544                                                  # ###########################################################################
7545                                                  package HTTPProtocolParser;
7546           6                    6            61   use base 'ProtocolParser';
               6                                 18   
               6                                 53   
7547                                                  
7548           6                    6            41   use strict;
               6                                 13   
               6                                 31   
7549           6                    6            37   use warnings FATAL => 'all';
               6                                 15   
               6                                 34   
7550           6                    6            35   use English qw(-no_match_vars);
               6                                 15   
               6                                 35   
7551                                                  
7552           6                    6            44   use Data::Dumper;
               6                                 17   
               6                                 31   
7553                                                  $Data::Dumper::Indent    = 1;
7554                                                  $Data::Dumper::Sortkeys  = 1;
7555                                                  $Data::Dumper::Quotekeys = 0;
7556                                                  
7557  ***      6            50      6            39   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 17   
               6                                 96   
7558                                                  
7559                                                  sub new {
7560  ***      0                    0             0      my ( $class, %args ) = @_;
7561  ***      0                                  0      my $self = $class->SUPER::new(
7562                                                        %args,
7563                                                        server_port => 80,
7564                                                     );
7565  ***      0                                  0      return $self;
7566                                                  }
7567                                                  
7568                                                  sub _packet_from_server {
7569  ***      0                    0             0      my ( $self, $packet, $session, $misc ) = @_;
7570  ***      0      0                           0      die "I need a packet"  unless $packet;
7571  ***      0      0                           0      die "I need a session" unless $session;
7572                                                  
7573  ***      0                                  0      MKDEBUG && _d('Packet is from server; client state:', $session->{state}); 
7574                                                  
7575  ***      0      0                           0      if ( !$session->{state} ) {
7576  ***      0                                  0         MKDEBUG && _d('Ignoring mid-stream server response');
7577  ***      0                                  0         return;
7578                                                     }
7579                                                  
7580  ***      0      0                           0      if ( $session->{out_of_order} ) {
7581  ***      0                                  0         my ($line1, $content);
7582  ***      0      0                           0         if ( !$session->{have_header} ) {
7583  ***      0                                  0            ($line1, $content) = $self->_parse_header(
7584                                                              $session, $packet->{data}, $packet->{data_len});
7585                                                        }
7586  ***      0      0                           0         if ( $line1 ) {
7587  ***      0                                  0            $session->{have_header} = 1;
7588  ***      0                                  0            $packet->{content_len}  = length $content;
7589  ***      0                                  0            MKDEBUG && _d('Got out of order header with',
7590                                                              $packet->{content_len}, 'bytes of content');
7591                                                        }
7592  ***      0             0                    0         my $have_len = $packet->{content_len} || $packet->{data_len};
7593  ***      0                                  0         map { $have_len += $_->{data_len} }
      ***      0                                  0   
7594  ***      0                                  0            @{$session->{packets}};
7595  ***      0      0      0                    0         $session->{have_all_packets}
7596                                                           = 1 if $session->{attribs}->{bytes}
7597                                                                  && $have_len >= $session->{attribs}->{bytes};
7598  ***      0                                  0         MKDEBUG && _d('Have', $have_len, 'of', $session->{attribs}->{bytes});
7599  ***      0                                  0         return;
7600                                                     }
7601                                                  
7602  ***      0      0                           0      if ( $session->{state} eq 'awaiting reply' ) {
      ***             0                               
7603                                                  
7604  ***      0      0                           0         $session->{start_reply} = $packet->{ts} unless $session->{start_reply};
7605                                                  
7606  ***      0                                  0         my ($line1, $content) = $self->_parse_header($session, $packet->{data},
7607                                                              $packet->{data_len});
7608                                                  
7609  ***      0      0                           0         if ( !$line1 ) {
7610  ***      0                                  0            $session->{out_of_order}     = 1;  # alert parent
7611  ***      0                                  0            $session->{have_all_packets} = 0;
7612  ***      0                                  0            return;
7613                                                        }
7614                                                  
7615  ***      0                                  0         my ($version, $code, $phrase) = $line1 =~ m/(\S+)/g;
7616  ***      0                                  0         $session->{attribs}->{Status_code} = $code;
7617  ***      0                                  0         MKDEBUG && _d('Status code for last', $session->{attribs}->{arg},
7618                                                           'request:', $session->{attribs}->{Status_code});
7619                                                  
7620  ***      0      0                           0         my $content_len = $content ? length $content : 0;
7621  ***      0                                  0         MKDEBUG && _d('Got', $content_len, 'bytes of content');
7622  ***      0      0      0                    0         if ( $session->{attribs}->{bytes}
7623                                                             && $content_len < $session->{attribs}->{bytes} ) {
7624  ***      0                                  0            $session->{data_len}  = $session->{attribs}->{bytes};
7625  ***      0                                  0            $session->{buff}      = $content;
7626  ***      0                                  0            $session->{buff_left} = $session->{attribs}->{bytes} - $content_len;
7627  ***      0                                  0            MKDEBUG && _d('Contents not complete,', $session->{buff_left},
7628                                                              'bytes left');
7629  ***      0                                  0            $session->{state} = 'recving content';
7630  ***      0                                  0            return;
7631                                                        }
7632                                                     }
7633                                                     elsif ( $session->{state} eq 'recving content' ) {
7634  ***      0      0                           0         if ( $session->{buff} ) {
7635  ***      0                                  0            MKDEBUG && _d('Receiving content,', $session->{buff_left},
7636                                                              'bytes left');
7637  ***      0                                  0            return;
7638                                                        }
7639  ***      0                                  0         MKDEBUG && _d('Contents received');
7640                                                     }
7641                                                     else {
7642  ***      0                                  0         warn "Server response in unknown state"; 
7643  ***      0                                  0         return;
7644                                                     }
7645                                                  
7646  ***      0                                  0      MKDEBUG && _d('Creating event, deleting session');
7647  ***      0             0                    0      $session->{end_reply} = $session->{ts_max} || $packet->{ts};
7648  ***      0                                  0      my $event = $self->make_event($session, $packet);
7649  ***      0                                  0      delete $self->{sessions}->{$session->{client}}; # http is stateless!
7650  ***      0                                  0      return $event;
7651                                                  }
7652                                                  
7653                                                  sub _packet_from_client {
7654  ***      0                    0             0      my ( $self, $packet, $session, $misc ) = @_;
7655  ***      0      0                           0      die "I need a packet"  unless $packet;
7656  ***      0      0                           0      die "I need a session" unless $session;
7657                                                  
7658  ***      0                                  0      MKDEBUG && _d('Packet is from client; state:', $session->{state});
7659                                                  
7660  ***      0                                  0      my $event;
7661  ***      0      0      0                    0      if ( ($session->{state} || '') =~ m/awaiting / ) {
7662  ***      0                                  0         MKDEBUG && _d('More client headers:', $packet->{data});
7663  ***      0                                  0         return;
7664                                                     }
7665                                                  
7666  ***      0      0                           0      if ( !$session->{state} ) {
7667  ***      0                                  0         $session->{state} = 'awaiting reply';
7668  ***      0                                  0         my ($line1, undef) = $self->_parse_header($session, $packet->{data}, $packet->{data_len});
7669  ***      0                                  0         my ($request, $page, $version) = $line1 =~ m/(\S+)/g;
7670  ***      0      0      0                    0         if ( !$request || !$page ) {
7671  ***      0                                  0            MKDEBUG && _d("Didn't get a request or page:", $request, $page);
7672  ***      0                                  0            return;
7673                                                        }
7674  ***      0                                  0         $request = lc $request;
7675  ***      0             0                    0         my $vh   = $session->{attribs}->{Virtual_host} || '';
7676  ***      0                                  0         my $arg = "$request $vh$page";
7677  ***      0                                  0         MKDEBUG && _d('arg:', $arg);
7678                                                  
7679  ***      0      0      0                    0         if ( $request eq 'get' || $request eq 'post' ) {
7680  ***      0                                  0            @{$session->{attribs}}{qw(arg)} = ($arg);
      ***      0                                  0   
7681                                                        }
7682                                                        else {
7683  ***      0                                  0            MKDEBUG && _d("Don't know how to handle a", $request, "request");
7684  ***      0                                  0            return;
7685                                                        }
7686                                                  
7687  ***      0                                  0         $session->{start_request}         = $packet->{ts};
7688  ***      0                                  0         $session->{attribs}->{host}       = $packet->{src_host};
7689  ***      0                                  0         $session->{attribs}->{pos_in_log} = $packet->{pos_in_log};
7690  ***      0                                  0         $session->{attribs}->{ts}         = $packet->{ts};
7691                                                     }
7692                                                     else {
7693  ***      0                                  0         die "Probably multiple GETs from client before a server response?"; 
7694                                                     }
7695                                                  
7696  ***      0                                  0      return $event;
7697                                                  }
7698                                                  
7699                                                  sub _parse_header {
7700  ***      0                    0             0      my ( $self, $session, $data, $len, $no_recurse ) = @_;
7701  ***      0      0                           0      die "I need data" unless $data;
7702  ***      0                                  0      my ($header, $content)    = split(/\r\n\r\n/, $data);
7703  ***      0                                  0      my ($line1, $header_vals) = $header  =~ m/\A(\S+ \S+ .+?)\r\n(.+)?/s;
7704  ***      0                                  0      MKDEBUG && _d('HTTP header:', $line1);
7705  ***      0      0                           0      return unless $line1;
7706                                                  
7707  ***      0      0                           0      if ( !$header_vals ) {
7708  ***      0                                  0         MKDEBUG && _d('No header vals');
7709  ***      0                                  0         return $line1, undef;
7710                                                     }
7711  ***      0                                  0      my @headers;
7712  ***      0                                  0      foreach my $val ( split(/\r\n/, $header_vals) ) {
7713  ***      0      0                           0         last unless $val;
7714  ***      0                                  0         MKDEBUG && _d('HTTP header:', $val);
7715  ***      0      0                           0         if ( $val =~ m/^Content-Length/i ) {
7716  ***      0                                  0            ($session->{attribs}->{bytes}) = $val =~ /: (\d+)/;
7717  ***      0                                  0            MKDEBUG && _d('Saved Content-Length:', $session->{attribs}->{bytes});
7718                                                        }
7719  ***      0      0                           0         if ( $val =~ m/Content-Encoding/i ) {
7720  ***      0                                  0            ($session->{compressed}) = $val =~ /: (\w+)/;
7721  ***      0                                  0            MKDEBUG && _d('Saved Content-Encoding:', $session->{compressed});
7722                                                        }
7723  ***      0      0                           0         if ( $val =~ m/^Host/i ) {
7724  ***      0                                  0            ($session->{attribs}->{Virtual_host}) = $val =~ /: (\S+)/;
7725  ***      0                                  0            MKDEBUG && _d('Saved Host:', ($session->{attribs}->{Virtual_host}));
7726                                                        }
7727                                                     }
7728  ***      0                                  0      return $line1, $content;
7729                                                  }
7730                                                  
7731                                                  sub _d {
7732  ***      0                    0             0      my ($package, undef, $line) = caller 0;
7733  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
7734  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
7735                                                          @_;
7736  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
7737                                                  }
7738                                                  
7739                                                  1;
7740                                                  
7741                                                  # ###########################################################################
7742                                                  # End HTTPProtocolParser package
7743                                                  # ###########################################################################
7744                                                  
7745                                                  # ###########################################################################
7746                                                  # ExecutionThrottler package 5266
7747                                                  # ###########################################################################
7748                                                  package ExecutionThrottler;
7749                                                  
7750           6                    6            57   use strict;
               6                                 15   
               6                                 39   
7751           6                    6            43   use warnings FATAL => 'all';
               6                                 19   
               6                                 53   
7752           6                    6            35   use English qw(-no_match_vars);
               6                                 16   
               6                                 33   
7753                                                  
7754           6                    6            46   use List::Util qw(sum min max);
               6                                 17   
               6                                 36   
7755           6                    6            38   use Time::HiRes qw(time);
               6                                 13   
               6                                 49   
7756           6                    6            40   use Data::Dumper;
               6                                 14   
               6                                 35   
7757                                                  $Data::Dumper::Indent    = 1;
7758                                                  $Data::Dumper::Sortkeys  = 1;
7759                                                  $Data::Dumper::Quotekeys = 0;
7760                                                  
7761  ***      6            50      6            37   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 15   
               6                                 80   
7762                                                  
7763                                                  sub new {
7764  ***      0                    0             0      my ( $class, %args ) = @_;
7765  ***      0                                  0      my @required_args = qw(rate_max get_rate check_int step);
7766  ***      0                                  0      foreach my $arg ( @required_args ) {
7767  ***      0      0                           0         die "I need a $arg argument" unless defined $args{$arg};
7768                                                     }
7769  ***      0                                  0      my $self = {
7770                                                        step       => 0.05,  # default
7771                                                        %args, 
7772                                                        rate_ok    => undef,
7773                                                        last_check => undef,
7774                                                        stats      => {
7775                                                           rate_avg     => 0,
7776                                                           rate_samples => [],
7777                                                        },
7778                                                        int_rates  => [],
7779                                                        skip_prob  => 0.0,
7780                                                     };
7781                                                  
7782  ***      0                                  0      return bless $self, $class;
7783                                                  }
7784                                                  
7785                                                  sub throttle {
7786  ***      0                    0             0      my ( $self, %args ) = @_;
7787  ***      0             0                    0      my $time = $args{misc}->{time} || time;
7788  ***      0      0                           0      if ( $self->_time_to_check($time) ) {
7789  ***      0                                  0         my $rate_avg = (sum(@{$self->{int_rates}})   || 0)
      ***      0                                  0   
7790  ***      0             0                    0                      / (scalar @{$self->{int_rates}} || 1);
      ***                    0                        
7791  ***      0                                  0         my $running_avg = $self->_save_rate_avg($rate_avg);
7792  ***      0                                  0         MKDEBUG && _d('Average rate for last interval:', $rate_avg);
7793                                                  
7794  ***      0      0                           0         if ( $args{stats} ) {
7795  ***      0                                  0            $args{stats}->{throttle_checked_rate}++;
7796  ***      0                                  0            $args{stats}->{throttle_rate_avg} = sprintf '%.2f', $running_avg;
7797                                                        }
7798                                                  
7799  ***      0                                  0         @{$self->{int_rates}} = ();
      ***      0                                  0   
7800                                                  
7801  ***      0      0                           0         if ( $rate_avg > $self->{rate_max} ) {
7802  ***      0                                  0            $self->{skip_prob} += $self->{step};
7803  ***      0      0                           0            $self->{skip_prob}  = 1.0 if $self->{skip_prob} > 1.0;
7804  ***      0                                  0            MKDEBUG && _d('Rate max exceeded');
7805  ***      0      0                           0            $args{stats}->{throttle_rate_max_exceeded}++ if $args{stats};
7806                                                        }
7807                                                        else {
7808  ***      0                                  0            $self->{skip_prob} -= $self->{step};
7809  ***      0      0                           0            $self->{skip_prob} = 0.0 if $self->{skip_prob} < 0.0;
7810  ***      0      0                           0            $args{stats}->{throttle_rate_ok}++ if $args{stats};
7811                                                        }
7812                                                  
7813  ***      0                                  0         MKDEBUG && _d('Skip probability:', $self->{skip_prob});
7814  ***      0                                  0         $self->{last_check} = $time;
7815                                                     }
7816                                                     else {
7817  ***      0                                  0         my $current_rate = $self->{get_rate}->();
7818  ***      0                                  0         push @{$self->{int_rates}}, $current_rate;
      ***      0                                  0   
7819  ***      0      0                           0         if ( $args{stats} ) {
7820  ***      0             0                    0            $args{stats}->{throttle_rate_min} = min(
7821                                                              ($args{stats}->{throttle_rate_min} || ()), $current_rate);
7822  ***      0             0                    0            $args{stats}->{throttle_rate_max} = max(
7823                                                              ($args{stats}->{throttle_rate_max} || ()), $current_rate);
7824                                                        }
7825  ***      0                                  0         MKDEBUG && _d('Current rate:', $current_rate);
7826                                                     } 
7827                                                  
7828  ***      0      0                           0      if ( $args{event} ) {
7829  ***      0      0                           0         $args{event}->{Skip_exec} = $self->{skip_prob} <= rand() ? 'No' : 'Yes';
7830                                                     }
7831                                                  
7832  ***      0                                  0      return $args{event};
7833                                                  }
7834                                                  
7835                                                  sub _time_to_check {
7836  ***      0                    0             0      my ( $self, $time ) = @_;
7837  ***      0      0                           0      if ( !$self->{last_check} ) {
7838  ***      0                                  0         $self->{last_check} = $time;
7839  ***      0                                  0         return 0;
7840                                                     }
7841  ***      0      0                           0      return $time - $self->{last_check} >= $self->{check_int} ? 1 : 0;
7842                                                  }
7843                                                  
7844                                                  sub rate_avg {
7845  ***      0                    0             0      my ( $self ) = @_;
7846  ***      0             0                    0      return $self->{stats}->{rate_avg} || 0;
7847                                                  }
7848                                                  
7849                                                  sub skip_probability {
7850  ***      0                    0             0      my ( $self ) = @_;
7851  ***      0                                  0      return $self->{skip_prob};
7852                                                  }
7853                                                  
7854                                                  sub _save_rate_avg {
7855  ***      0                    0             0      my ( $self, $rate ) = @_;
7856  ***      0                                  0      my $samples  = $self->{stats}->{rate_samples};
7857  ***      0                                  0      push @$samples, $rate;
7858  ***      0      0                           0      shift @$samples if @$samples > 1_000;
7859  ***      0                                  0      $self->{stats}->{rate_avg} = sum(@$samples) / (scalar @$samples);
7860  ***      0             0                    0      return $self->{stats}->{rate_avg} || 0;
7861                                                  }
7862                                                  
7863                                                  sub _d {
7864  ***      0                    0             0      my ($package, undef, $line) = caller 0;
7865  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
7866  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
7867                                                          @_;
7868  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
7869                                                  }
7870                                                  
7871                                                  1;
7872                                                  
7873                                                  # ###########################################################################
7874                                                  # End ExecutionThrottler package
7875                                                  # ###########################################################################
7876                                                  
7877                                                  # ###########################################################################
7878                                                  # This is a combination of modules and programs in one -- a runnable module.
7879                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
7880                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
7881                                                  #
7882                                                  # Check at the end of this package for the call to main() which actually runs
7883                                                  # the program.
7884                                                  # ###########################################################################
7885                                                  package mk_query_digest;
7886                                                  
7887           6                    6            44   use English qw(-no_match_vars);
               6                                 13   
               6                                 32   
7888           6                    6            42   use Time::Local qw(timelocal);
               6                                 37   
               6                                 41   
7889           6                    6            37   use Time::HiRes qw(time usleep);
               6                                 13   
               6                                 32   
7890           6                    6            40   use List::Util qw(max);
               6                                 17   
               6                                 29   
7891           6                    6            38   use POSIX qw(signal_h);
               6                                 14   
               6                                 59   
7892           6                    6            45   use Data::Dumper;
               6                                 13   
               6                                 29   
7893                                                  $Data::Dumper::Indent = 1;
7894                                                  $OUTPUT_AUTOFLUSH     = 1;
7895                                                  
7896                                                  Transformers->import(qw(shorten micro_t percentage_of ts make_checksum
7897                                                     any_unix_timestamp));
7898                                                  
7899  ***      6            50      6            44   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 19   
               6                                 78   
7900                                                  
7901           6                    6            92   use sigtrap 'handler', \&sig_int, 'normal-signals';
               6                                 18   
               6                                 91   
7902                                                  
7903                                                  # Global variables.  Only really essential variables should be here.
7904                                                  my $oktorun = 1;
7905                                                  my $dp = new DSNParser (
7906                                                     { key => 'D', copy => 1, desc => 'Database that contains the query review table' },
7907                                                     { key => 't', desc => 'Table to use as the query review table' } );
7908                                                  my $q  = new Quoter();
7909                                                  my $qp = new QueryParser();
7910                                                  my $qr = new QueryRewriter(QueryParser=>$qp);
7911                                                  my $ex_dbh;  # For --execute
7912                                                  my $ep_dbh;  # For --explain
7913                                                  my $ps_dbh;  # For Processlist
7914                                                  my $aux_dbh; # For --aux-dsn (--since/--until "MySQL expression")
7915                                                  
7916                                                  sub main {
7917          45                   45         97609      @ARGV = @_;  # set global ARGV for this package
7918                                                  
7919                                                     # ##########################################################################
7920                                                     # Get configuration information.
7921                                                     # ##########################################################################
7922          45                               1379      my $o = new OptionParser(
7923                                                        strict      => 0,
7924                                                        dp          => $dp,
7925                                                        prompt      => '[OPTION...] [FILE]',
7926                                                        description => q{parses and analyzes MySQL log files.  With no }
7927                                                                     . q{FILE, or when FILE is -, read standard input.},
7928                                                     );
7929          45                                526      $o->get_specs();
7930          45                                466      $o->get_opts();
7931                                                  
7932          45                                292      $dp->prop('set-vars', $o->get('set-vars'));
7933                                                  
7934                                                     # Frequently used options.
7935          45                                288      my $review_dsn = $o->get('review'); 
7936          45                                152      my @groupby    = @{$o->get('group-by')};
              45                                275   
7937          45                                211      my @orderby;
7938  ***     45    100     66                  147      if ( (grep { $_ eq 'genlog' || $_ eq 'GeneralLogParser' } @{$o->get('type')})
              45    100                         746   
              45                                198   
7939                                                          && !$o->got('order-by') ) {
7940           1                                  4         @orderby = 'Query_time:cnt';
7941                                                     }
7942                                                     else { 
7943          44                                127         @orderby = @{$o->get('order-by')};
              44                                208   
7944                                                     }
7945                                                  
7946  ***     45     50                         272      if ( !$o->get('help') ) {
7947  ***     45     50      0                  321         if ( $review_dsn
      ***                   33                        
7948                                                             && (!defined $review_dsn->{D} || !defined $review_dsn->{t}) ) {
7949  ***      0                                  0            $o->save_error('The --review DSN requires a D (database) and t'
7950                                                              . ' (table) part specifying the query review table');
7951                                                        }
7952  ***     45     50      0                  210         if ( $o->get('mirror')
      ***                   33                        
7953                                                             && (!$o->get('execute') || !$o->get('processlist')) ) {
7954  ***      0                                  0            $o->save_error('--mirror requires --execute and --processlist');
7955                                                        }
7956  ***     45     50     33                  204         if ( $o->get('outliers')
              45                                687   
7957          45                                212            && grep { $_ !~ m/^\w+:[0-9.]+(?::[0-9.]+)?$/ } @{$o->get('outliers')}
7958                                                        ) {
7959  ***      0                                  0            $o->save_error('--outliers requires two or three colon-separated fields');
7960                                                        }
7961  ***     45     50                         221         if ( $o->get('execute-throttle') ) {
7962  ***      0                                  0            my ($rate_max, $int, $step) = @{$o->get('execute-throttle')};
      ***      0                                  0   
7963  ***      0      0      0                    0            $o->save_error("--execute-throttle max time must be between 1 and 100")
      ***                    0                        
7964                                                              unless $rate_max && $rate_max > 0 && $rate_max <= 100;
7965  ***      0      0                           0            $o->save_error("No check interval value for --execute-throttle")
7966                                                              unless $int;
7967  ***      0      0                           0            $o->save_error("--execute-throttle check interval must be an integer")
7968                                                              if $int =~ m/[^\d]/;
7969  ***      0      0      0                    0            $o->save_error("--execute-throttle step must be between 1 and 100")
      ***                    0                        
7970                                                              if $step && ($step < 1 || $step > 100);
7971                                                        }
7972                                                     }
7973                                                  
7974                                                     # Set an orderby for each groupby; use the default orderby if there
7975                                                     # are more groupby than orderby attribs.
7976          45                                316      my $default_orderby = $o->get_defaults()->{'order-by'};
7977          45                                502      foreach my $i ( 0..$#groupby ) {
7978          46           100                  373         $orderby[$i] ||= $default_orderby;
7979                                                     }
7980          45                                434      $o->set('order-by', \@orderby);
7981                                                  
7982          45                                362      $o->usage_or_errors();
7983                                                  
7984                                                     # ########################################################################
7985                                                     # Set up for --explain
7986                                                     # ########################################################################
7987          45    100                         273      if ( $o->get('explain') ) {
7988           3                                 15         $ep_dbh = $dp->get_dbh(
7989                                                           $dp->get_cxn_params($o->get('explain')), {AutoCommit => 1});
7990           3                                 19         $ep_dbh->{InactiveDestroy}  = 1;  # Don't die on fork().
7991                                                     }
7992                                                  
7993                                                     # ########################################################################
7994                                                     # Set up for --review and --review-history.
7995                                                     # ########################################################################
7996          45                                130      my $qv;      # QueryReview
7997          45                                123      my $qv_dbh;  # For QueryReview
7998          45                                138      my $qv_dbh2; # For QueryReview and --review-history
7999  ***     45     50                         194      if ( $review_dsn ) {
8000  ***      0                                  0         my $tp  = new TableParser(Quoter => $q);
8001  ***      0                                  0         my $du  = new MySQLDump();
8002  ***      0                                  0         $qv_dbh = $dp->get_dbh(
8003                                                           $dp->get_cxn_params($review_dsn), {AutoCommit => 1});
8004  ***      0                                  0         $qv_dbh->{InactiveDestroy}  = 1;  # Don't die on fork().
8005  ***      0                                  0         my @db_tbl = @{$review_dsn}{qw(D t)};
      ***      0                                  0   
8006  ***      0                                  0         my $db_tbl = $q->quote(@db_tbl);
8007                                                  
8008                                                        # Create the review table if desired
8009  ***      0      0                           0         if ( $o->get('create-review-table') ) {
8010  ***      0                                  0            my $sql = $o->read_para_after(
8011                                                              __FILE__, qr/MAGIC_create_review/);
8012  ***      0                                  0            $sql =~ s/query_review/IF NOT EXISTS $db_tbl/;
8013  ***      0                                  0            MKDEBUG && _d($sql);
8014  ***      0                                  0            $qv_dbh->do($sql);
8015                                                        }
8016                                                  
8017                                                        # Check for existence and the permissions to insert into the
8018                                                        # table.
8019  ***      0      0                           0         if ( !$tp->check_table(
8020                                                              dbh       => $qv_dbh,
8021                                                              db        => $db_tbl[0],
8022                                                              tbl       => $db_tbl[1],
8023                                                              all_privs => 1) )
8024                                                        {
8025  ***      0                                  0            die "The query review table $db_tbl "
8026                                                              . "does not exist or you do not have INSERT privileges";
8027                                                        }
8028                                                  
8029                                                        # Set up the new QueryReview object.
8030  ***      0                                  0         my $struct = $tp->parse($du->get_create_table($qv_dbh, $q, @db_tbl));
8031  ***      0                                  0         $qv = new QueryReview(
8032                                                           dbh         => $qv_dbh,
8033                                                           db_tbl      => $db_tbl,
8034                                                           tbl_struct  => $struct,
8035                                                           quoter      => $q,
8036                                                        );
8037                                                  
8038                                                        # Set up the review-history table
8039  ***      0      0                           0         if ( $o->get('review-history') ) {
8040  ***      0                                  0            $qv_dbh2 = $dp->get_dbh(
8041                                                              $dp->get_cxn_params($o->get('review-history')), {AutoCommit => 1});
8042  ***      0                                  0            $qv_dbh2->{InactiveDestroy}  = 1;  # Don't die on fork().
8043  ***      0                                  0            my @hdb_tbl = @{$o->get('review-history')}{qw(D t)};
      ***      0                                  0   
8044  ***      0                                  0            my $hdb_tbl = $q->quote(@hdb_tbl);
8045                                                  
8046                                                           # Create the review-history table if desired
8047  ***      0      0                           0            if ( $o->get('create-review-history-table') ) {
8048  ***      0                                  0               my $sql = $o->read_para_after(
8049                                                                 __FILE__, qr/MAGIC_create_review_history/);
8050  ***      0                                  0               $sql =~ s/query_review_history/IF NOT EXISTS $hdb_tbl/;
8051  ***      0                                  0               MKDEBUG && _d($sql);
8052  ***      0                                  0               $qv_dbh2->do($sql);
8053                                                           }
8054                                                  
8055                                                           # Check for existence and the permissions to insert into the
8056                                                           # table.
8057  ***      0      0                           0            if ( !$tp->check_table(
8058                                                                 dbh       => $qv_dbh2,
8059                                                                 db        => $hdb_tbl[0],
8060                                                                 tbl       => $hdb_tbl[1],
8061                                                                 all_privs => 1) )
8062                                                           {
8063  ***      0                                  0               die "The query review history table $hdb_tbl "
8064                                                                 . "does not exist or you do not have INSERT privileges";
8065                                                           }
8066                                                  
8067                                                           # Inspect for MAGIC_history_cols.  Add them to the --select list
8068                                                           # only if an explicit --select list was given.  Otherwise, leave
8069                                                           # --select undef which will cause EventAggregator to aggregate every
8070                                                           # attribute available which will include the history columns.
8071                                                           # If no --select list was given and we make one by adding the history
8072                                                           # columsn to it, then EventAggregator will only aggregate the
8073                                                           # history columns and nothing else--we don't want this.
8074  ***      0                                  0            my $tbl = $tp->parse($du->get_create_table($qv_dbh2, $q, @hdb_tbl));
8075  ***      0                                  0            my $pat = $o->read_para_after(__FILE__, qr/MAGIC_history_cols/);
8076  ***      0                                  0            $pat    =~ s/\s+//g;
8077  ***      0                                  0            $pat    = qr/^(.*?)_($pat)$/;
8078                                                           # Get original --select values.
8079  ***      0                                  0            my %select = map { $_ => 1 } @{$o->get('select')};
      ***      0                                  0   
      ***      0                                  0   
8080  ***      0                                  0            foreach my $col ( @{$tbl->{cols}} ) {
      ***      0                                  0   
8081  ***      0                                  0               my ( $attr, $metric ) = $col =~ m/$pat/;
8082  ***      0      0      0                    0               next unless $attr && $metric;
8083  ***      0      0                           0               $attr = ucfirst $attr if $attr =~ m/_/; # TableParser lowercases
8084                                                              # Add history table values to original select values.
8085  ***      0                                  0               $select{$attr}++;
8086                                                           }
8087                                                  
8088  ***      0      0                           0            if ( $o->got('select') ) {
8089                                                              # Re-set --select with its original values plus the history
8090                                                              # table values.
8091  ***      0                                  0               $o->set('select', [keys %select]);
8092                                                              MKDEBUG && _d("--select after parsing --review-history table:", 
8093  ***      0                                  0                  @{$o->get('select')});
8094                                                           }
8095                                                  
8096                                                           # And tell the QueryReview that it has more work to do.
8097                                                           $qv->set_history_options(
8098  ***      0                                  0               table      => $hdb_tbl,
8099                                                              dbh        => $qv_dbh2,
8100                                                              tbl_struct => $tbl,
8101                                                              col_pat    => $pat,
8102                                                           );
8103                                                        }
8104                                                     }
8105                                                     
8106                                                     # ########################################################################
8107                                                     # Set up an array of callbacks to filter and transform events.  The first
8108                                                     # one should add the fingerprint to the event (except if we're parsing
8109                                                     # tcpdump output; see below).  After that, callbacks can do anything, as
8110                                                     # long as they return the event (failing to return the event terminates
8111                                                     # the chain).
8112                                                     # ########################################################################
8113          45                                195      my @callbacks;
8114          45                                107      my %callback_names;
8115          45                                126      my %prof;  # pipeline profile
8116          45                                112      my %stats; # general stats
8117          45                                176      my $misc = {};
8118  ***     45     50                         237      if ( $o->get('processlist') ) {
8119  ***      0                                  0         my $pl = new Processlist();
8120  ***      0                                  0         my ( $sth, $cxn );
8121  ***      0                                  0         my $cur_server = 'processlist';
8122  ***      0                                  0         my $cur_time   = 0;
8123                                                  
8124                                                        $misc = {
8125                                                           time  => 0,
8126                                                           etime => 0,
8127                                                           code  => sub {
8128  ***      0                    0             0               my $time = $misc->{time} = time();
8129  ***      0                                  0               my $err;
8130  ***      0             0                    0               do {
8131  ***      0                                  0                  eval { $sth->execute; };
      ***      0                                  0   
8132  ***      0                                  0                  $err = $EVAL_ERROR;
8133  ***      0      0                           0                  if ( $err ) { # Try to reconnect when there's an error.
8134  ***      0                                  0                     @{$misc}{qw(time etime)} = (0, 0);
      ***      0                                  0   
8135  ***      0                                  0                     eval {
8136  ***      0                                  0                        ($cur_server, $ps_dbh) = find_role(
8137                                                                          $o, $ps_dbh, $cur_server, 0, 'for --processlist');
8138  ***      0                                  0                        $cur_time = time();
8139  ***      0                                  0                        $sth      = $ps_dbh->prepare('SHOW FULL PROCESSLIST');
8140  ***      0                                  0                        $cxn      = $ps_dbh->{mysql_thread_id};
8141  ***      0                                  0                        $sth->execute();
8142                                                                    };
8143  ***      0                                  0                     $err = $EVAL_ERROR;
8144  ***      0      0                           0                     if ( $err ) {
8145  ***      0                                  0                        print STDERR $err;
8146  ***      0                                  0                        sleep 1;
8147                                                                    }
8148                                                                 }
8149                                                              } until ( $sth && !$err );
8150  ***      0      0      0                    0               if ( $o->get('mirror')
8151                                                                   && time() - $cur_time > $o->get('mirror')) {
8152  ***      0                                  0                  ($cur_server, $ps_dbh) = find_role($o, $ps_dbh, $cur_server,
8153                                                                    0, 'for --processlist');
8154  ***      0                                  0                  $cur_time = time();
8155                                                              }
8156  ***      0                                  0               $misc->{etime} = time() - $time;
8157  ***      0                                  0               [ grep { $_->[0] != $cxn } @{ $sth->fetchall_arrayref(); } ];
      ***      0                                  0   
      ***      0                                  0   
8158                                                           },
8159  ***      0                                  0         };
8160                                                  
8161                                                        push @callbacks, sub {
8162  ***      0                    0             0            my ( $event, %args ) = @_;
8163  ***      0                                  0            return $pl->parse_event(%args);
8164  ***      0                                  0         };
8165  ***      0                                  0         $callback_names{$callbacks[-1]} = ref $pl;
8166  ***      0                                  0         MKDEBUG && _d('Added Processlist module to callbacks');
8167                                                     }
8168                                                     else {
8169          45                                977         my %alias_for = (
8170                                                           slowlog   => ['SlowLogParser'],
8171                                                           binlog    => ['BinaryLogParser'],
8172                                                           genlog    => ['GeneralLogParser'],
8173                                                           tcpdump   => ['TcpdumpParser','MySQLProtocolParser'],
8174                                                           memcached => ['TcpdumpParser','MemcachedProtocolParser',
8175                                                                         'MemcachedEvent'],
8176                                                           http      => ['TcpdumpParser','HTTPProtocolParser'],
8177                                                        );
8178          45                                215         my $type = $o->get('type');
8179  ***     45     50                         368         $type    = $alias_for{$type->[0]} if $alias_for{$type->[0]};
8180                                                  
8181          45                                184         foreach my $module ( @$type ) {
8182          48                                133            my $parser;
8183          48                                169            eval {
8184          48                                232               $parser = $module->new(
8185                                                                 server => $o->get('watch-server'),
8186                                                                 o      => $o,
8187                                                              );
8188                                                           };
8189  ***     48     50                         227            if ( $EVAL_ERROR ) {
8190  ***      0                                  0               die "Failed to load $module module: $EVAL_ERROR";
8191                                                           }
8192                                                           push @callbacks, sub {
8193         447                  447          4305               my ( $event, %args ) = @_;
8194         447                               3947               return $parser->parse_event(%args);
8195          48                                609            };
8196          48                                338            $callback_names{$callbacks[-1]} = ref $parser;
8197          48                                852            MKDEBUG && _d('Added', $module, 'module to callbacks');
8198                                                        }
8199                                                     }
8200                                                  
8201                                                     # Filter early for --since and --until.
8202          45                                144      my $past_since;
8203          45                                121      my $at_until;
8204                                                     # If --since or --until is a MySQL expression, then any_unix_timestamp()
8205                                                     # will need this callback to execute the expression.  We don't know what
8206                                                     # type of time value the user gave, so we'll create the callback in any case.
8207  ***     45     50                         215      if ( my $aux_dsn = $o->get('aux-dsn') ) {
8208  ***      0                                  0         $aux_dbh = $dp->get_dbh($dp->get_cxn_params($aux_dsn), {AutoCommit => 1});
8209  ***      0                                  0         $aux_dbh->{InactiveDestroy}  = 1;  # Don't die on fork().
8210                                                     }
8211  ***     45            33                 1186      $aux_dbh ||= $qv_dbh || $qv_dbh2 || $ex_dbh || $ps_dbh || $ep_dbh;
      ***                   66                        
      ***                   66                        
                           100                        
                           100                        
8212          45                                145      MKDEBUG && _d('aux dbh:', $aux_dbh);
8213                                                     my $time_callback = sub {
8214  ***      0                    0             0         my ( $exp ) = @_;
8215  ***      0      0                           0         return unless $aux_dbh;
8216  ***      0                                  0         my $sql = "SELECT UNIX_TIMESTAMP($exp)";
8217  ***      0                                  0         MKDEBUG && _d($sql);
8218  ***      0                                  0         return $aux_dbh->selectall_arrayref($sql)->[0]->[0];
8219          45                                457      };
8220  ***     45     50                         205      if ( $o->get('since') ) {
8221  ***      0                                  0         my $since = any_unix_timestamp($o->get('since'), $time_callback);
8222  ***      0      0                           0         die "Invalid --since value" unless $since;
8223                                                        push @callbacks, sub {
8224  ***      0                    0             0            my ( $event ) = @_;
8225  ***      0                                  0            MKDEBUG && _d('callback: --since');
8226  ***      0      0                           0            if ( $past_since ) {
8227  ***      0                                  0               MKDEBUG && _d('Already past --since');
8228  ***      0                                  0               return $event;
8229                                                           }
8230  ***      0      0                           0            if ( $event->{ts} ) {
8231  ***      0                                  0               my $ts = any_unix_timestamp($event->{ts}, $time_callback);
8232  ***      0      0      0                    0               if ( ($ts || 0) >= $since ) {
8233  ***      0                                  0                  MKDEBUG && _d('Event is at or past --since');
8234  ***      0                                  0                  $past_since = 1;
8235  ***      0                                  0                  return $event;
8236                                                              }
8237                                                              else {
8238  ***      0                                  0                  MKDEBUG && _d('Event is before --since');
8239                                                              }
8240                                                           }
8241  ***      0                                  0            return;
8242  ***      0                                  0         };
8243  ***      0                                  0         $callback_names{$callbacks[-1]} = 'since';
8244                                                     }
8245  ***     45     50                         214      if ( $o->get('until') ) {
8246  ***      0                                  0         my $until = any_unix_timestamp($o->get('until'), $time_callback);
8247  ***      0      0                           0         die "Invalid --until value" unless $until;
8248                                                        push @callbacks, sub {
8249  ***      0                    0             0            my ( $event ) = @_;
8250  ***      0                                  0            MKDEBUG && _d('callback: --until');
8251  ***      0      0                           0            if ( $at_until ) {
8252  ***      0                                  0               MKDEBUG && _d('Already past --until');
8253  ***      0                                  0               return;
8254                                                           }
8255  ***      0      0                           0            if ( $event->{ts} ) {
8256  ***      0                                  0               my $ts = any_unix_timestamp($event->{ts}, $time_callback);
8257  ***      0      0      0                    0               if ( ($ts || 0) >= $until ) {
8258  ***      0                                  0                  MKDEBUG && _d('Event at or after --until');
8259  ***      0                                  0                  $at_until = 1;
8260  ***      0                                  0                  return;
8261                                                              }
8262                                                              else {
8263  ***      0                                  0                  MKDEBUG && _d('Event is before --until');
8264                                                              }
8265                                                           }
8266  ***      0                                  0            return $event;
8267  ***      0                                  0         };
8268  ***      0                                  0         $callback_names{$callbacks[-1]} = 'until';
8269                                                     }
8270                                                  
8271          45    100                         182      if ( grep { $_ eq 'fingerprint' } @groupby ) {
              46                                356   
8272                                                        push @callbacks, sub {
8273         317                  317          1878            my ( $event ) = @_;
8274         317                               1240            MKDEBUG && _d('callback: fingerprint');
8275                                                           # Skip events which do not have the groupby attribute.
8276         317                               1558            my $groupby_val = $event->{arg};
8277  ***    317     50                        1398            return unless $groupby_val;
8278         317                               2147            $event->{fingerprint} = $qr->fingerprint($groupby_val);
8279         317                               1219            return $event;
8280          38                                376         };
8281          38                                221         $callback_names{$callbacks[-1]} = 'fingerprint';
8282                                                     }
8283                                                  
8284                                                     # Make subs which map attrib aliases to their primary attrib.
8285          45                                136      foreach my $alt_attrib ( @{$o->get('attribute-aliases')} ) {
              45                                213   
8286          45                                422         push @callbacks, make_alt_attrib($alt_attrib);
8287          45                                336         $callback_names{$callbacks[-1]} = 'attribute aliases';
8288                                                     }
8289                                                  
8290                                                     # Carry attribs forward for --inherit-attributes.
8291          45                                188      my $prev_vals = {};
8292          45                                236      my $inherit_attrib_sub = make_inherit_attribs(
8293                                                        $o->get('inherit-attributes'),
8294                                                        $prev_vals
8295                                                     );
8296  ***     45     50                         256      push @callbacks, $inherit_attrib_sub if $inherit_attrib_sub;
8297          45                                245      $callback_names{$callbacks[-1]} = 'inherit attributes';
8298                                                  
8299          45    100                         178      if ( grep { $_ eq 'tables' } @groupby ) {
              46                                245   
8300                                                        push @callbacks, sub {
8301           2                    2            11            my ( $event ) = @_;
8302           2                                  6            MKDEBUG && _d('callback: tables');
8303           2                                  8            my $group_by_val = $event->{arg};
8304  ***      2     50                          10            return 0 unless defined $group_by_val;
8305           2                                 10            $event->{tables} = [
8306                                                              map {
8307                                                                 # Canonicalize and add the db name in front
8308           2                                 19                  $_ =~ s/`//g;
8309  ***      2    100     33                   24                  if ($_ !~ m/\./ && (my $db = $event->{db} || $event->{Schema})) {
      ***                   66                        
8310           1                                  5                     $_ = "$db.$_";
8311                                                                 }
8312           2                                 15                  $_;
8313                                                              }
8314                                                              $qp->get_tables($group_by_val)
8315                                                           ];
8316           2                                  8            return $event;
8317           1                                 10         };
8318           1                                  9         $callback_names{$callbacks[-1]} = 'tables';
8319                                                     }
8320                                                  
8321          45                                132      my %distill_args;
8322  ***     45     50     33                  238      if ( $o->get('type') eq 'memcached' || $o->get('type') eq 'http' ) {
8323  ***      0                                  0         $distill_args{generic} = 1;
8324  ***      0      0                           0         if ( $o->get('type') eq 'http' ) {
8325                                                           # Remove stuff after url.
8326                                                           $distill_args{trf} = sub {
8327  ***      0                    0             0               my ( $query ) = @_;
8328  ***      0                                  0               $query =~ s/(\S+ \S+?)(?:[?;].+)/$1/;
8329  ***      0                                  0               return $query;
8330  ***      0                                  0            };
8331                                                        }
8332                                                     }
8333          45    100                         172      if ( grep { $_ eq 'distill' } @groupby ) {
              46                                271   
8334                                                        push @callbacks, sub {
8335          11                   11            64            my ( $event ) = @_;
8336          11                                 38            MKDEBUG && _d('callback: distill');
8337          11                                 46            my $group_by_val = $event->{arg};
8338  ***     11     50                          56            return 0 unless defined $group_by_val;
8339          11                                104            $event->{distill} = $qr->distill($group_by_val, %distill_args);
8340          11                                 33            MKDEBUG && !$event->{distill} && _d('Cannot distill', $event->{arg});
8341          11                                 42            return $event;
8342           3                                 39         };
8343           3                                 20         $callback_names{$callbacks[-1]} = 'distill';
8344                                                     }
8345                                                  
8346                                                     # Filter after special attributes, like fingerprint, tables,
8347                                                     # distill, etc., have been created.
8348          45    100                         252      if ( $o->get('filter') ) {
8349           1                                 20         my $filter = $o->get('filter');
8350  ***      1     50     33                   22         if ( -f $filter && -r $filter ) {
8351  ***      0                                  0            MKDEBUG && _d('Reading file', $filter, 'for --filter code');
8352  ***      0      0                           0            open my $fh, "<", $filter or die "Cannot open $filter: $OS_ERROR";
8353  ***      0                                  0            $filter = do { local $/ = undef; <$fh> };
      ***      0                                  0   
      ***      0                                  0   
8354  ***      0                                  0            close $fh;
8355                                                        }
8356                                                        else {
8357           1                                  9            $filter = "( $filter )";  # issue 565
8358                                                        }
8359           1                                  7         my $code   = "sub { MKDEBUG && _d('callback: filter');  my(\$event) = shift; $filter && return \$event; };";
8360           1                                  8         MKDEBUG && _d('--filter code:', $code);
8361  ***      1     50                         145         my $sub = eval $code
8362                                                           or die "Error compiling --filter code: $code\n$EVAL_ERROR";
8363           1                                  7         push @callbacks, $sub;
8364           1                                 10         $callback_names{$callbacks[-1]} = 'filter';
8365                                                     }
8366                                                  
8367          45    100                         269      if ( $o->get('zero-admin') ) {
8368                                                        push @callbacks, sub {
8369         331                  331          1922            my ( $event ) = @_;
8370         331                               1292            MKDEBUG && _d('callback: zero admin');
8371  ***    331    100     66                 3765            if ( $event->{arg} && $event->{arg} =~ m/^# administrator/ ) {
8372          11                                 65               $event->{Rows_sent}     = 0;
8373          11                                 58               $event->{Rows_read}     = 0;
8374          11                                 45               $event->{Rows_examined} = 0;
8375                                                           }
8376         331                               1200            return $event;
8377          44                                451         };
8378          44                                247         $callback_names{$callbacks[-1]} = 'zero admin';
8379                                                     }
8380                                                  
8381  ***     45     50                         263      if ( $o->got('sample') ) {
8382  ***      0                                  0         my $group_by_val = $groupby[0];
8383  ***      0                                  0         my $num_samples  = $o->get('sample');
8384  ***      0      0                           0         if ( $group_by_val ) {
8385  ***      0                                  0            my %seen;
8386                                                           push @callbacks, sub {
8387  ***      0                    0             0               my ($event) = @_;
8388  ***      0                                  0               MKDEBUG && _d('callback: sample');
8389  ***      0      0                           0               if ( ++$seen{$event->{$group_by_val}} <= $num_samples ) {
8390  ***      0                                  0                  MKDEBUG && _d("--sample permits event",
8391                                                                    $event->{$group_by_val});
8392  ***      0                                  0                  return $event;
8393                                                              }
8394  ***      0                                  0               MKDEBUG && _d("--sample rejects event", $event->{$group_by_val});
8395  ***      0                                  0               return;
8396  ***      0                                  0            };
8397  ***      0                                  0            $callback_names{$callbacks[-1]} = 'sample';
8398                                                        }
8399                                                     }
8400                                                  
8401  ***     45     50                         207      if ( $o->get('print') ) {
8402  ***      0                                  0         my $w = new SlowLogWriter();
8403                                                        push @callbacks, sub {
8404  ***      0                    0             0            my ( $event ) = @_;
8405  ***      0                                  0            MKDEBUG && _d('callback: print');
8406  ***      0                                  0            $w->write(*STDOUT, $event);
8407  ***      0                                  0            return $event;
8408  ***      0                                  0         };
8409  ***      0                                  0         $callback_names{$callbacks[-1]} = 'print';
8410                                                     }
8411                                                  
8412          45                                204      my $et;
8413  ***     45     50                         196      if ( my $et_args = $o->get('execute-throttle') ) {
8414                                                        # These were check earlier; no need to check them again.
8415  ***      0                                  0         my ($rate_max, $int, $step) = @{$o->get('execute-throttle')};
      ***      0                                  0   
8416  ***      0             0                    0         $step ||= 5;
8417  ***      0                                  0         $step  /= 100;  # step specified as percent but $et expect 0.1=10%, etc.
8418  ***      0                                  0         MKDEBUG && _d('Execute throttle:', $rate_max, $int, $step);
8419                                                  
8420                                                        my $get_rate = sub {
8421  ***      0             0      0             0            return percentage_of(
      ***                    0                        
8422                                                              $prof{callback}->{'execute'}->{time} || 0,
8423                                                              $prof{total}->{time}                 || 0,
8424                                                           );
8425  ***      0                                  0         };
8426                                                  
8427  ***      0                                  0         $et = new ExecutionThrottler(
8428                                                           rate_max  => $rate_max,
8429                                                           get_rate  => $get_rate,
8430                                                           check_int => $int,
8431                                                           step      => $step,
8432                                                        );
8433                                                        push @callbacks, sub {
8434  ***      0                    0             0            my ( $event, %args ) = @_;
8435  ***      0                                  0            MKDEBUG && _d('callback: throttle');
8436  ***      0                                  0            return $et->throttle(%args);
8437  ***      0                                  0         };
8438  ***      0                                  0         $callback_names{$callbacks[-1]} = 'execute throttle';
8439                                                     }
8440                                                  
8441          45    100                         202      if ( $o->get('execute') ) {
8442           2                                  7         my $cur_server = 'execute';
8443           2                                 17         ($cur_server, $ex_dbh) = find_role($o, $ex_dbh, $cur_server,
8444                                                              1, 'for --execute');
8445           2                                 25         my $cur_time = time();
8446           2                                  6         my $curdb;
8447                                                        push @callbacks, sub {
8448           2                    2            10            my ( $event ) = @_;
8449           2                                  8            MKDEBUG && _d('callback: execute');
8450           2                                  9            $event->{Exec_orig_time} = $event->{Query_time};
8451  ***      2     50     50                   22            if ( ($event->{Skip_exec} || '') eq 'Yes' ) {
8452  ***      0                                  0               MKDEBUG && _d('Not executing event because of --execute-throttle');
8453                                                              # Zero Query_time to 'Exec time' will show the real time
8454                                                              # spent executing queries.
8455  ***      0                                  0               $event->{Query_time} = 0;
8456  ***      0                                  0               $stats{execute_skipped}++;
8457  ***      0                                  0               return $event;
8458                                                           }
8459           2                                  6            $stats{execute_executed}++;
8460           2                                 11            my $db = $event->{db};
8461           2                                  6            eval {
8462  ***      2     50      0                   12               if ( $db && (!$curdb || $db ne $curdb) ) {
      ***                   33                        
8463  ***      0                                  0                  $ex_dbh->do("USE $db");
8464  ***      0                                  0                  $curdb = $db;
8465                                                              } 
8466           2                                 11               my $start = time();
8467           2                                530               $ex_dbh->do($event->{arg});
8468           1                                 13               my $end = time();
8469           1                                  9               $event->{Query_time} = $end - $start;
8470           1                                 10               $event->{Exec_diff_time}
8471                                                                 = $event->{Query_time} - $event->{Exec_orig_time};
8472  ***      1     50     33                    7               if ( $o->get('mirror') && $end - $cur_time > $o->get('mirror') ) {
8473  ***      0                                  0                  ($cur_server, $ex_dbh) = find_role($o, $ex_dbh, $cur_server,
8474                                                                       1, 'for --execute');
8475  ***      0                                  0                  $cur_time = $end;
8476                                                              }
8477                                                           };
8478           2    100                          14            if ( $EVAL_ERROR ) {
8479           1                                  2               MKDEBUG && _d($EVAL_ERROR);
8480           1                                  4               $stats{execute_error}++;
8481                                                              # Don't try to re-execute the statement.  Just skip it.
8482  ***      1     50                           6               if ( $EVAL_ERROR =~ m/server has gone away/ ) {
8483  ***      0                                  0                  print STDERR $EVAL_ERROR;
8484  ***      0                                  0                  eval {
8485  ***      0                                  0                     ($cur_server, $ex_dbh) = find_role($o, $ex_dbh, $cur_server,
8486                                                                       1, 'for --execute');
8487  ***      0                                  0                     $cur_time = time();
8488                                                                 };
8489  ***      0      0                           0                  if ( $EVAL_ERROR ) {
8490  ***      0                                  0                     print STDERR $EVAL_ERROR;
8491  ***      0                                  0                     sleep 1;
8492                                                                 }
8493  ***      0                                  0                  return 0;
8494                                                              }
8495  ***      1     50                           5               if ( $EVAL_ERROR =~ m/No database/ ) {
8496           1                                  4                  $stats{execute_no_database}++;
8497                                                              }
8498                                                           }
8499           2                                  8            return $event;
8500           2                                 45         };
8501           2                                 15         $callback_names{$callbacks[-1]} = 'execute';
8502                                                     }
8503                                                  
8504                                                     # Finally, add aggregator obj for each groupby attrib to the callbacks.
8505                                                     # These aggregating objs should be the last callbacks.
8506          45                                136      my @ea;  # EventAggregators
8507          45                                123      my @tl;  # EventTimeline (aggregators)
8508          45                                286      foreach my $i ( 0..$#groupby  ) {
8509          46                                240         my $groupby = $groupby[$i];
8510                                                  
8511                                                        # This shouldn't happen.
8512  ***     46     50                         214         die "No --order-by value for --group-by $groupby" unless $orderby[$i];
8513                                                  
8514          46                                363         my ( $orderby_attrib, $orderby_func ) = split(/:/, $orderby[$i]);
8515                                                  
8516           1                                  9         my %attributes = map {
8517           1                                 26            my ($name, @alt) = split(/:/, $_);
8518           1                                 10            $name => [$name, @alt];
8519                                                        }
8520          46                                242         grep { $_ !~ m/^$groupby\b/ }
8521          46                                178         @{$o->get('select')};
8522                                                  
8523                                                        # Create an EventAggregator for this groupby attrib and
8524                                                        # add it to callbacks.
8525          46                                357         my $ea = new EventAggregator(
8526                                                           groupby           => $groupby,
8527                                                           attributes        => { %attributes },
8528                                                           worst             => $orderby_attrib,
8529                                                           attrib_limit      => $o->get('attribute-value-limit'),
8530                                                           ignore_attributes => $o->get('ignore-attributes'),
8531                                                           unroll_limit      => $o->get('check-attributes-limit'),
8532                                                           type_for => {
8533                                                              val          => 'string',
8534                                                              key_print    => 'string',
8535                                                              Status_code  => 'string',
8536                                                              Statement_id => 'string',
8537                                                              Error_no     => 'string',
8538                                                           },
8539                                                        );
8540          46                                246         push @ea, $ea;
8541                                                        push @callbacks, sub {
8542         339                  339          1883            my ( $event ) = @_;
8543         339                               2221            $ea->aggregate($event);
8544         339                               1494            return $event;
8545          46                                431         };
8546          46                                290         $callback_names{$callbacks[-1]} = "aggregate $groupby";
8547                                                  
8548                                                        # If user wants a timeline report, too, then create an EventTimeline
8549                                                        # aggregator for this groupby attrib and add it to the callbacks, too.
8550          46    100                         214         if ( $o->get('timeline') ) {
8551           1                                 24            my $tl = new EventTimeline(
8552                                                              groupby    => [$groupby],
8553                                                              attributes => [qw(Query_time ts)],
8554                                                           );
8555           1                                  4            push @tl, $tl;
8556                                                           push @callbacks, sub {
8557           8                    8            46               my ( $event ) = @_;
8558           8                                 58               $tl->aggregate($event);
8559           8                                 26               return $event;
8560           1                                  8            };
8561           1                                 11            $callback_names{$callbacks[-1]} = "timeline $groupby";
8562                                                        }
8563                                                     }
8564                                                  
8565  ***     45     50                         217      if ( $o->get('processlist') ) {
8566                                                        push @callbacks, sub {
8567  ***      0                    0             0            MKDEBUG && _d('callback: interval sleep');
8568  ***      0                                  0            usleep($o->get('interval') * 1_000_000);
8569  ***      0                                  0            return @_;
8570  ***      0                                  0         };
8571  ***      0                                  0         $callback_names{$callbacks[-1]} = 'interval sleep';
8572                                                     }
8573                                                  
8574                                                     # ########################################################################
8575                                                     # Daemonize now that everything is setup and ready to work.
8576                                                     # ########################################################################
8577          45                                144      my $daemon;
8578  ***     45     50                         190      if ( $o->get('daemonize') ) {
      ***            50                               
8579  ***      0                                  0         $daemon = new Daemon(o=>$o);
8580  ***      0                                  0         $daemon->daemonize();
8581  ***      0                                  0         MKDEBUG && _d('I am a daemon now');
8582                                                     }
8583                                                     elsif ( $o->get('pid') ) {
8584                                                        # We're not daemoninzing, it just handles PID stuff.
8585  ***      0                                  0         $daemon = new Daemon(o=>$o);
8586  ***      0                                  0         $daemon->make_PID_file();
8587                                                     }
8588                                                  
8589                                                     # ##########################################################################
8590                                                     # Parse the input.
8591                                                     # ##########################################################################
8592          45    100                         243      if ( my $patterns = $o->get('embedded-attributes') ) {
8593           1                                 28         $misc->{embed}   = qr/$patterns->[0]/o;
8594           1                                 24         $misc->{capture} = qr/$patterns->[1]/o;
8595           1                                  6         MKDEBUG && _d('Patterns for embedded attributes:', $misc->{embed},
8596                                                              $misc->{capture});
8597                                                     }
8598                                                     
8599  ***     45     50                         231      if ( @ARGV == 0 ) {
8600  ***      0                                  0         push @ARGV, '-'; # Magical STDIN filename.
8601                                                     }
8602                                                  
8603                                                     # Create callback to read next event.  Some inputs, like Processlist,
8604                                                     # may use something else but most use this.
8605          45                                152      my $fh;
8606          45                                119      my $next_event;
8607  ***     45     50                         190      if ( my $read_time = $o->get('read-timeout') ) {
8608  ***      0                    0             0         $next_event = sub { return read_timeout($fh, $read_time); };
      ***      0                                  0   
8609                                                     }
8610                                                     else {
8611          45                  420           408         $next_event = sub { return <$fh>; };
             420                               8659   
8612                                                     }
8613          45                  747          1360      my $tell = sub { return tell $fh; };
             747                               3364   
8614                                                  
8615          45                                410      my $start = time();
8616  ***     45            50                  199      my $end   = $start + ($o->get('run-time') || 0); # When we should exit
8617          45                                150      my $now   = $start;
8618          45                                146      my $iters = 0;
8619                                                     ITERATION:
8620  ***     45            66                  434      while (  # Quit if instructed to, or if iterations are exceeded.
      ***                   66                        
8621                                                        $oktorun
8622                                                        && (!$o->get('iterations') || $iters++ < $o->get('iterations') )
8623                                                     ) {
8624                                                  
8625  ***     45     50                         215         if ( $o->get('print-iterations') ) {
8626  ***      0                                  0            my $iter_start = time;
8627  ***      0                                  0            MKDEBUG && _d('Iteration', $iters, 'started at', ts($iter_start));
8628  ***      0                                  0            print "\n# Iteration $iters started at ", ts($iter_start), "\n";
8629                                                        }
8630                                                  
8631                                                        EVENT:
8632  ***     45            33                  683         while (                                 # Quit if:
      ***                   33                        
8633                                                           $oktorun                             # instructed to quit
8634                                                           && ($start == $end || $now < $end) ) # or time is exceeded
8635                                                        {
8636         457    100                        1880            if ( !$fh ) {
8637          90                                372               my $file = shift @ARGV;
8638          90    100                         394               if ( !$file ) {
8639          45                                107                  MKDEBUG && _d('No more files to parse');
8640          45                                163                  last EVENT;
8641                                                              }
8642                                                  
8643  ***     45     50                         199               if ( $file eq '-' ) {
8644  ***      0                                  0                  $fh = *STDIN;
8645  ***      0                                  0                  MKDEBUG && _d('Reading STDIN');
8646                                                              }
8647                                                              else {
8648  ***     45     50                        2337                  if ( !open $fh, "<", $file ) {
8649  ***      0                                  0                     $fh = undef;
8650  ***      0                                  0                     warn "Cannot open $file: $OS_ERROR\n";
8651  ***      0                                  0                     next EVENT;
8652                                                                 }
8653          45                                114                  MKDEBUG && _d('Reading', $file);
8654                                                  
8655                                                                 # Reset these var in case we read two logs out of order by time.
8656          45                                136                  $past_since = 0;
8657          45                                180                  $at_until   = 0;
8658                                                              }
8659                                                           }
8660                                                  
8661         412                               1276            eval {
8662                                                              # Run events through the pipeline.  The first pipeline process
8663                                                              # is usually responsible for getting the next event.  The pipeline
8664                                                              # stops if a process does not return the event.  This main loop
8665                                                              # stops if a process sets oktorun to false; it usually does this
8666                                                              # when there are no more events, but it may do it for other reasons.
8667                                                              # Some inputs are infinite streams of events, like the proclist,
8668                                                              # so oktorun is never set to false and it's the user's job to tell
8669                                                              # us when to stop.
8670         412                               1550               my $event       = {};
8671         412                               1196               my $more_events = 1;
8672         412                   45          2781               my $oktorun_sub = sub { $more_events = $_[0]; };
              45                                139   
8673         412                               1569               foreach my $callback ( @callbacks ) {
8674  ***   2147     50                        7556                  last unless $oktorun;  # the global oktorun var
8675        2147                               9993                  my $start = time;
8676        2147                              13137                  $event = $callback->(
8677                                                                    $event,  # for backwards compatibility
8678                                                                    event      => $event,  # new interface
8679                                                                    next_event => $next_event,
8680                                                                    tell       => $tell,
8681                                                                    oktorun    => $oktorun_sub,
8682                                                                    misc       => $misc,
8683                                                                    stats      => \%stats,
8684                                                                 );
8685        2147                              11990                  my $end  = time;
8686        2147                               6784                  my $t    = $end - $start;
8687  ***   2147            33                11431                  my $name = $callback_names{$callback} || $callback;
8688        2147                              10260                  $prof{callback}->{$name}->{time} += $t;
8689        2147                               8405                  $prof{callback}->{$name}->{count}++;
8690        2147                               7684                  $prof{total}->{time} += $t;
8691        2147                               7981                  $prof{total}->{count}++;
8692        2147    100                        9709                  last unless $event;
8693                                                              }
8694         412    100                        3589               if ( !$more_events ) {
8695          45                                107                  MKDEBUG && _d('No more events');
8696  ***     45     50                         676                  close $fh if $fh;
8697          45                                227                  $fh = undef;
8698                                                              }
8699                                                           };
8700  ***    412     50                        1766            if ( $EVAL_ERROR ) {
8701  ***      0                                  0               _d($EVAL_ERROR);
8702  ***      0                                  0               $stats{pipeline_error}++;
8703                                                  
8704                                                              # Don't ignore failure to open a file, else we'll get
8705                                                              # "tell() on closed filehandle" errors.
8706  ***      0      0                           0               last EVENT if $EVAL_ERROR =~ m/Cannot open/;
8707                                                  
8708  ***      0      0                           0               last EVENT unless $o->get('continue-on-error');
8709                                                           }
8710         412                               5948            $now = time();
8711                                                        }  # EVENT
8712                                                  
8713                                                        # ######################################################################
8714                                                        # Done parsing events, now do something with the aggregated query
8715                                                        # results for each class (i.e. each groupby), probably --report them,
8716                                                        # or maybe just save them for --review.
8717                                                        # ######################################################################
8718          45                                750         my $qrf    = new QueryReportFormatter();
8719          45                                300         my @select = ( $ea[0]->get_attributes() );
8720          45                                191         MKDEBUG && _d('attribs for reports:', @select);
8721                                                  
8722                                                        # First, and only once, print the global report analysis header.
8723          45    100    100                  316         if ( $o->get('report') && $o->get('report-format')->{header} ) {
8724  ***      6     50                          29            print $qrf->header() if $o->get('report-format')->{rusage};
8725                                                  
8726                                                           # It doesn't matter which ea we use here because they will all have
8727                                                           # the same attributes; they only differ in how they were grouped.
8728           6                                 22            my $ea = $ea[0];
8729  ***      6     50                          32            if ( !$ea->events_processed() ) {
8730  ***      0                                  0               print "# No events processed.\n";
8731                                                           }
8732                                                           else {
8733           6                                 63               my ( $orderby_attrib, $orderby_func ) = split(/:/, $orderby[0]);
8734           6                                 40               $orderby_attrib = check_orderby_attrib($orderby_attrib, $ea, $o);
8735          81                                360               print $qrf->global_report(
8736                                                                 $ea,
8737           6                                 31                  select => [ grep { $_ !~ m/^(?:user|db|pos_in_log)$/ } @select ],
8738                                                                 worst  => $orderby_attrib,
8739                                                                 no_zero_bool => !$o->get('zero-bool'),
8740                                                              );
8741                                                           }
8742                                                        }
8743                                                  
8744                                                        # #####################################################################
8745                                                        # Do the reports for each groupby/class.
8746                                                        # #####################################################################
8747          45                                351         for my $i ( 0..$#groupby ) {
8748          46                                254            my $groupby = $groupby[$i];
8749          46                                177            my $ea      = $ea[$i];
8750          46                                400            my ( $orderby_attrib, $orderby_func ) = split(/:/, $orderby[$i]);
8751          46                                361            $orderby_attrib = check_orderby_attrib($orderby_attrib, $ea, $o);
8752          46                                130            MKDEBUG && _d('Doing reports for groupby', $groupby, 'orderby',
8753                                                              $orderby_attrib, $orderby_func);
8754                                                  
8755                                                           # We don't report on all queries, just the worst, i.e. the top
8756                                                           # however many.
8757          46           100                  218            my $limit = $o->get('limit')->[$i] || '95%:20';
8758          46                                160            my ($total, $count);
8759          46    100                         528            if ( $limit =~ m/^\d+$/ ) {
8760          41                                136               $count = $limit;
8761                                                           }
8762                                                           else {
8763                                                              # It's a percentage, so grab as many as needed to get to
8764                                                              # that % of the file.
8765           5                                 49               ($total, $count) = $limit =~ m/(\d+)/g;
8766           5           100                   34               $total *= ($ea->results->{globals}->{$orderby_attrib}->{sum} || 0)
8767                                                                      / 100;
8768                                                           }
8769  ***     46            50                  492            my %top_spec = (
8770                                                              attrib  => $orderby_attrib,
8771                                                              orderby => $orderby_func || 'cnt',
8772                                                              total   => $total,
8773                                                              count   => $count,
8774                                                           );
8775          46    100                         211            if ( $o->get('outliers')->[$i] ) {
8776          45                                235               @top_spec{qw(ol_attrib ol_limit ol_freq)}
8777                                                                 = split(/:/, $o->get('outliers')->[$i]);
8778                                                           }
8779                                                           # The queries that will be reported.
8780          46                                444            my @worst = $ea->top_events(%top_spec);
8781                                                  
8782          46                                221            my $expected_range = $o->get('expected-range');
8783  ***     46            66                  646            my $explain_why
      ***                   66                        
8784                                                              = $expected_range
8785                                                              && (@worst < $expected_range->[0] || @worst > $expected_range->[1]);
8786                                                   
8787          46                                120            my @table_access;
8788          46                                122            my @profiles;
8789          46                                128            my $total_r = 0;
8790          46                                119            my @prepared;       # prepared statements
8791          46                                143            my %seen_prepared;  # report each PREP-EXEC pair once
8792                                                  
8793                                                           # Print a header for this groupby/class if we're doing the standard
8794                                                           # query report and there's more than one class or there's one class
8795                                                           # but it's not the normal class grouped by fingerprint.
8796          46    100    100                  188            if ( $o->get('report')
                           100                        
                           100                        
8797                                                                && $o->get('report-format')->{query_report}
8798                                                                && (@groupby > 1 || $groupby ne 'fingerprint') )
8799                                                           {
8800           8                                 88               print "\n# ", ( '#' x 72 ), "\n";
8801           8                                 37               print "# Report grouped by $groupby\n";
8802           8                                 36               print '# ', ( '#' x 72 ), "\n";
8803                                                           }
8804                                                  
8805                                                           # ##################################################################
8806                                                           # Do the reports for each query in this groupby/class.
8807                                                           # ##################################################################
8808                                                           ITEM:
8809          46                                240            foreach my $rank ( 1 .. @worst ) {
8810         104                                645               my $item          = $worst[$rank - 1]->[0];
8811         104                                600               my $stats         = $ea->results->{classes}->{$item};
8812         104                                507               my $sample        = $ea->results->{samples}->{$item};
8813  ***    104            50                  928               my $samp_query    = $sample->{arg} || '';
8814                                                  
8815                                                              # ###############################################################
8816                                                              # Save the profile for this item.  It's printed later, maybe.
8817                                                              # ###############################################################
8818         104    100                        1412               my %profile = (
                    100                               
8819                                                                 rank   => $rank,
8820                                                                 r      => $stats->{Query_time}->{sum},
8821                                                                 cnt    => $stats->{Query_time}->{cnt},
8822                                                                 sample => $groupby eq 'fingerprint' ? $qr->distill($samp_query,
8823                                                                                                                    %distill_args)
8824                                                                                                     : $item,
8825                                                                 id     => $groupby eq 'fingerprint' ? make_checksum($item)
8826                                                                                                     : '',
8827                                                              );
8828         104                                528               $total_r += $profile{r};
8829         104                                501               push @profiles, \%profile;
8830                                                  
8831                                                              # ###############################################################
8832                                                              # Saved prepared statement values.
8833                                                              # ###############################################################
8834  ***    104     50     33                  650               if ( $stats->{Statement_id} && $item =~ m/^(?:prepare|execute) / ) {
8835                                                                 # Each PREPARE (probably) has some EXECUTE and each EXECUTE
8836                                                                 # (should) have some PREPARE.  But these are only the top N
8837                                                                 # events so we can get here a PREPARE but not its EXECUTE or
8838                                                                 # vice-versa.  The prepared statements report requires both
8839                                                                 # so this code gets the missing pair from the ea stats.
8840  ***      0                                  0                  my ($prep_stmt, $prep, $prep_r, $prep_cnt);
8841  ***      0                                  0                  my ($exec_stmt, $exec, $exec_r, $exec_cnt);
8842  ***      0      0                           0                  if ( $item =~ m/^prepare / ) {
8843  ***      0                                  0                     $prep_stmt           = $item;
8844  ***      0                                  0                     ($exec_stmt = $item) =~ s/^prepare /execute /;
8845                                                                 }
8846                                                                 else {
8847  ***      0                                  0                     ($prep_stmt = $item) =~ s/^execute /prepare /;
8848  ***      0                                  0                     $exec_stmt           = $item;
8849                                                                 }
8850                                                  
8851                                                                 # If both the PREPARE and EXECUTE are in the top N, then
8852                                                                 # only report the pair once.
8853  ***      0      0                           0                  if ( !$seen_prepared{$prep_stmt}++ ) {
8854  ***      0                                  0                     $exec     = $ea->results->{classes}->{$exec_stmt};
8855  ***      0                                  0                     $exec_r   = $exec->{Query_time}->{sum};
8856  ***      0                                  0                     $exec_cnt = $exec->{Query_time}->{cnt};
8857                                                  
8858  ***      0                                  0                     $prep     = $ea->results->{classes}->{$prep_stmt};
8859  ***      0                                  0                     $prep_r   = $prep->{Query_time}->{sum};
8860  ***      0                                  0                     $prep_cnt = scalar keys %{$prep->{Statement_id}->{unq}},
      ***      0                                  0   
8861                                                  
8862                                                                    push @prepared, {
8863                                                                       prep_r    => $prep_r, 
8864                                                                       prep_cnt  => $prep_cnt,
8865                                                                       exec_r    => $exec_r,
8866                                                                       exec_cnt  => $exec_cnt,
8867                                                                       %profile,    # reuse profile for rank, id and sample
8868                                                                    };
8869                                                                 }
8870                                                              }
8871                                                  
8872                                                              # ###############################################################
8873                                                              # Prepare for --review and --review-history.
8874                                                              # ###############################################################
8875         104                                318               my $review_vals;
8876         104                                408               my %history;
8877  ***    104     50                         406               if ( $qv ) {
8878  ***      0                                  0                  $review_vals = $qv->get_review_info($item);
8879  ***      0      0      0                    0                  if ( $review_vals->{reviewed_by} && !$o->get('report-all') ) {
8880                                                                    # This item has already been reviewed, skip it.  But before
8881                                                                    # doing so, save the history if necessary.
8882  ***      0      0                           0                     if ( $o->get('review-history') ) {
8883  ***      0             0                    0                        $qv->set_review_history(
8884                                                                          $item, $sample->{arg} || '', %history);
8885                                                                    }
8886  ***      0                                  0                     next ITEM;
8887                                                                 }
8888                                                  
8889  ***      0      0                           0                  if ( $o->get('review-history') ) {
8890  ***      0                                  0                     foreach my $attrib ( @select ) {
8891  ***      0                                  0                        $history{$attrib} = $ea->metrics(
8892                                                                          attrib => $attrib,
8893                                                                          where  => $item,
8894                                                                       );
8895                                                                    }
8896                                                                 }
8897                                                              }
8898                                                  
8899                                                              # ###############################################################
8900                                                              # Get tables for either --for-explain or --table-access.
8901                                                              # ###############################################################
8902           1                                  7               my ($default_db) = $sample->{db}       ? $sample->{db}
8903         104    100                         714                                : $stats->{db}->{unq} ? keys %{$stats->{db}->{unq}}
                    100                               
8904                                                                               :                       undef;
8905         104                                293               my @tables;
8906  ***    104     50     33                  466               if ( $o->get('for-explain') || $o->get('table-access') ){
8907         104                                641                  @tables = extract_tables($samp_query, $default_db);
8908         104    100                         462                  push @table_access, $samp_query if $o->get('table-access');
8909                                                              }
8910                                                  
8911                                                              # ###############################################################
8912                                                              # Print the standard query analysis report.
8913                                                              # ###############################################################
8914         104    100    100                  432               if ( $o->get('report')
8915                                                                   && $o->get('report-format')->{query_report} ) {
8916          89                                508                  print "\n";
8917        1263                               5178                  print $qrf->event_report(
8918                                                                    $ea,
8919          89    100                         427                     select => [ grep { $_ !~ m/^(?:pos_in_log)$/ } @select ],
8920                                                                    where  => $item,
8921                                                                    rank   => $rank,
8922                                                                    worst  => $orderby_attrib,
8923                                                                    reason => $explain_why ? $worst[$rank - 1]->[1] : '',
8924                                                                    no_zero_bool => !$o->get('zero-bool'),
8925                                                                 );
8926          89                               1008                  print $qrf->chart_distro(
8927                                                                    $ea,
8928                                                                    attribute  => $orderby_attrib,
8929                                                                    where      => $item,
8930                                                                 );
8931                                                  
8932  ***     89     50                         464                  if ( $qv ) {
8933                                                                    # Print the review information that is already in the table
8934                                                                    # before putting anything new into the table.
8935  ***      0                                  0                     print "# Review information\n";
8936  ***      0                                  0                     foreach my $col ( $qv->review_cols() ) {
8937  ***      0                                  0                        my $val = $review_vals->{$col};
8938  ***      0      0      0                    0                        if ( !$val || $val ne '0000-00-00 00:00:00' ) { # issue 202
8939  ***      0      0                           0                           printf "# %13s: %-s\n", $col, ($val ? $val : '');
8940                                                                       }
8941                                                                    }
8942                                                                 }
8943                                                  
8944          89    100                         464               if ( $groupby eq 'fingerprint' ) {
8945                                                                 # Shorten it if necessary (issue 216 and 292).
8946  ***     79     50                         539                  $samp_query = $qr->shorten($samp_query, $o->get('shorten'))
8947                                                                    if $o->get('shorten');
8948                                                              }
8949                                                                 # Print the query fingerprint.
8950  ***     89     50     66                  722                  if ( $groupby eq 'fingerprint' && $o->get('fingerprints') ) {
8951  ***      0                                  0                     print "# Fingerprint\n#    $item\n";
8952                                                                 }
8953                                                  
8954          89    100                         386                  if ( $groupby eq 'fingerprint' ) {
8955  ***     79     50                         330                     print_tables(@tables) if $o->get('for-explain');
8956          79    100                         654                     if ( $item =~ m/^(?:[\(\s]*select|insert|replace)/ ) {
8957          38    100                         215                        if ( $item =~ m/^(?:insert|replace)/ ) { # No EXPLAIN
8958          15                                107                           print $samp_query, "\\G\n";
8959                                                                       }
8960                                                                       else {
8961          23                                131                           print "# EXPLAIN\n$samp_query\\G\n"; 
8962          23                                133                           print_explain($ep_dbh, $samp_query, $default_db);
8963                                                                       }
8964                                                                    }
8965                                                                    else {
8966          41                                204                        print "$samp_query\\G\n"; 
8967          41                                237                        my $converted = $qr->convert_to_select($samp_query);
8968  ***     41    100     33                  182                        if ( $o->get('for-explain')
      ***                   66                        
8969                                                                            && $converted
8970                                                                            && $converted =~ m/^[\(\s]*select/i ) {
8971                                                                          # It converted OK to a SELECT
8972          15                                 54                           print "# Converted for EXPLAIN\n# EXPLAIN\n";
8973          15                                 76                           print "$converted\\G\n";
8974                                                                       }
8975                                                                    }
8976                                                                 }
8977                                                                 else {
8978          10    100                          63                     if ( $groupby eq 'tables' ) {
8979           1                                  7                        my ( $db, $tbl ) = $q->split_unquote($item);
8980           1                                  8                        print_tables([$db, $tbl]);
8981                                                                    }
8982          10                                 45                     print $item, "\n"; 
8983                                                                 }
8984                                                              } # Print standard query analysis report
8985                                                  
8986                                                              # ###############################################################
8987                                                              # Update --review and --review-history.
8988                                                              # ###############################################################
8989  ***    104     50                         843               if ( $qv ) {
8990  ***      0             0                    0                  $qv->set_review_info(
8991                                                                    fingerprint => $item,
8992                                                                    sample      => $sample->{arg} || '',
8993                                                                    first_seen  => $stats->{ts}->{min},
8994                                                                    last_seen   => $stats->{ts}->{max}
8995                                                                 );
8996  ***      0      0                           0                  if ( $o->get('review-history') ) {
8997  ***      0             0                    0                     $qv->set_review_history(
8998                                                                       $item, $sample->{arg} || '', %history);
8999                                                                 }
9000                                                              }
9001                                                           } # Each worst ITEM
9002                                                  
9003                                                           # ##################################################################
9004                                                           # Print per-class reports.
9005                                                           # ##################################################################
9006                                                  
9007                                                           # Print timeline.
9008          46    100                         250            if ( $o->get('timeline') ) {
9009           1                                  5               my $tl = $tl[$i];
9010           1                   11             7               $tl->report($tl->results(), sub { print @_ });
              11                                 58   
9011                                                           }
9012                                                  
9013                                                           # Print table access.
9014          46    100                         219            if ( $o->get('table-access') ) {
9015           2                                  6               my @subqueries;
9016                                                              map {
9017           2                                  8                  eval {
               5                                 46   
9018           5                                 36                     push @subqueries, $qp->split($_);
9019                                                                 };
9020  ***      5     50                          24                  if ( $EVAL_ERROR ) {
9021  ***      0                                  0                     MKDEBUG && _d($EVAL_ERROR);
9022  ***      0                                  0                     warn "Cannot get table access for query $_";
9023                                                                 }
9024                                                              } @table_access; 
9025                                                  
9026           2                                  6               my %seen;
9027  ***      2     50                          11               print "\n" if $o->get('report');
9028           2                                  8               foreach my $subquery ( @subqueries ) {
9029           5                                 34                  my $rw = $qp->query_type($subquery, $qr)->{rw};
9030  ***      5     50                          25                  next unless $rw;
9031           5                                 24                  my @tables = $qp->get_tables($subquery);
9032  ***      5     50                          20                  next unless scalar @tables;
9033           5                                 18                  foreach my $db_tbl ( @tables ) {
9034           5    100                          29                     next if $seen{$db_tbl}++; # Unique-ify for issue 337.
9035           4                                 18                     my ($db, $tbl) = $q->split_unquote($db_tbl);
9036  ***      4     50                          19                     $db            = $db ? "`$db`."  : '';
9037           4                                 40                     print "$rw $db`$tbl`\n";
9038                                                                 }
9039                                                              }
9040                                                           }
9041                                                  
9042                                                           # Print profile (issue 381).
9043          46    100    100                  206            if ( $o->get('report') && $o->get('report-format')->{profile} ) {
9044           8                                112               my $report = new ReportFormatter(
9045                                                                 line_width       => 74,
9046                                                                 long_last_column => 1,
9047                                                              );
9048           8                                 71               $report->set_title('Profile');
9049           8                                140               $report->set_columns(
9050                                                                 { name => 'Rank',          right_justify => 1, },
9051                                                                 { name => 'Query ID',                          },
9052                                                                 { name => 'Response time', right_justify => 1, },
9053                                                                 { name => 'Calls',         right_justify => 1, },
9054                                                                 { name => 'R/Call',        right_justify => 1, },
9055                                                                 { name => 'Item',                              },
9056                                                              );
9057                                                  
9058           8                                 27               foreach my $item ( sort { $a->{rank} <=> $b->{rank} } @profiles ) {
              32                                124   
9059          26                                373                  my $rt  = sprintf('%10.4f', $item->{r});
9060          26           100                  265                  my $rtp = sprintf('%4.1f%%', $item->{r} / ($total_r || 1) * 100);
9061          26                                173                  my $rc  = sprintf('%8.4f', $item->{r} / $item->{cnt});
9062          26                                412                  $report->add_line(
9063                                                                    $item->{rank},
9064                                                                    "0x$item->{id}",
9065                                                                    "$rt $rtp",
9066                                                                    $item->{cnt},
9067                                                                    $rc,
9068                                                                    $item->{sample},
9069                                                                 );
9070                                                              }
9071           8                                 67               print "\n" . $report->get_report();
9072                                                           }
9073                                                  
9074                                                           # Print prepared statements (issue 740).
9075  ***     46     50     66                  285            if ( $o->get('report') && $o->get('report-format')->{prepared}
      ***                   50                        
9076                                                                && scalar @prepared ) {
9077  ***      0                                  0               my $report = new ReportFormatter(
9078                                                                 line_width       => 74,
9079                                                                 long_last_column => 1,
9080                                                              );
9081  ***      0                                  0               $report->set_title('Prepared statements');
9082  ***      0                                  0               $report->set_columns(
9083                                                                 { name => 'Rank',          right_justify => 1, },
9084                                                                 { name => 'Query ID',                          },
9085                                                                 { name => 'PREP',          right_justify => 1, },
9086                                                                 { name => 'PREP Response', right_justify => 1, },
9087                                                                 { name => 'EXEC',          right_justify => 1, },
9088                                                                 { name => 'EXEC Response', right_justify => 1, },
9089                                                                 { name => 'Item',                              },
9090                                                              );
9091                                                  
9092  ***      0                                  0               foreach my $item ( sort { $a->{rank} <=> $b->{rank} } @prepared ) {
      ***      0                                  0   
9093  ***      0                                  0                  my $exec_rt   = sprintf('%10.4f', $item->{exec_r});
9094  ***      0             0                    0                  my $exec_rtp  = sprintf('%4.1f%%', $item->{exec_r} / ($total_r || 1) * 100);
9095  ***      0                                  0                  my $prep_rt   = sprintf('%10.4f', $item->{prep_r});
9096  ***      0             0                    0                  my $prep_rtp  = sprintf('%4.1f%%', $item->{prep_r} / ($total_r || 1) * 100);
9097                                                  
9098  ***      0             0                    0                  $report->add_line(
      ***                    0                        
9099                                                                    $item->{rank},
9100                                                                    "0x$item->{id}",
9101                                                                    $item->{prep_cnt} || 0,
9102                                                                    "$prep_rt $prep_rtp",
9103                                                                    $item->{exec_cnt} || 0,
9104                                                                    "$exec_rt $exec_rtp",
9105                                                                    $item->{sample},
9106                                                                 );
9107                                                              }
9108  ***      0                                  0               print "\n" . $report->get_report();
9109                                                           }
9110                                                        } # Each groupby
9111                                                  
9112                                                  
9113                                                        # Reset the start/end/now times so the next iteration will run for the
9114                                                        # same amount of time.
9115          45                                377         $start = time();
9116  ***     45            50                  198         $end   = $start + ($o->get('run-time') || 0); # When we should exit
9117          45                                145         $now   = $start;
9118                                                  
9119          45                                274         foreach my $ea ( @ea, @tl ) {
9120          47                                377            $ea->reset_aggregated_data();
9121                                                        }
9122                                                  
9123  ***     45     50                         288         if ( $o->get('pipeline-profile') ) {
9124  ***      0                                  0            my $report = new ReportFormatter(
9125                                                              line_width => 74,
9126                                                           );
9127  ***      0                                  0            $report->set_columns(
9128                                                              { name => 'Process'                   },
9129                                                              { name => 'Time',  right_justify => 1 },
9130                                                              { name => 'Count', right_justify => 1 },
9131                                                           );
9132  ***      0                                  0            $report->set_title('Pipeline profile');
9133  ***      0                                  0            foreach my $callback ( @callbacks ) {
9134  ***      0             0                    0               my $name = $callback_names{$callback} || $callback;
9135  ***      0             0                    0               my $t    = $prof{callback}->{$name}->{time} || 0;
9136  ***      0             0                    0               my $tp   = sprintf('%.2f %4.1f%%', $t,
9137                                                                             $t / ($prof{total}->{time} || 1) * 100);
9138  ***      0             0                    0               $report->add_line($name, $tp,
9139                                                                 $prof{callback}->{$name}->{count} || 0);
9140                                                              
9141                                                              # Reset profile for next iteration.
9142  ***      0                                  0               map { $prof{callback}->{$name}->{$_} = 0 }
      ***      0                                  0   
9143  ***      0                                  0                  keys %{$prof{callback}->{$name}};
9144                                                           }
9145  ***      0                                  0            map { $prof{total}->{$_} = 0 } keys %{$prof{total}};
      ***      0                                  0   
      ***      0                                  0   
9146                                                  
9147  ***      0                                  0            print "\n" . $report->get_report();
9148                                                        }
9149                                                  
9150          45    100                         219         if ( $o->get('statistics') ) {
9151  ***      2     50                          13            if ( keys %stats ) {
9152           2                                 41               my $report = new ReportFormatter(
9153                                                                 line_width => 74,
9154                                                              );
9155           2                                 23               $report->set_columns(
9156                                                                 { name => 'Statistic',                    },
9157                                                                 { name => 'Value',     right_justify => 1 },
9158                                                              );
9159           2                                 15               foreach my $stat ( sort keys %stats ) {
9160  ***      4            50                   32                  $report->add_line($stat, $stats{$stat} || 0);
9161                                                  
9162                                                                 # Reset stats for next iteration.
9163           4                                 17                  $stats{$stat} = 0;
9164                                                              }
9165           2                                 11               print "\n" . $report->get_report();
9166                                                           }
9167                                                           else {
9168  ***      0                                  0               print "\n# No statistics values.\n";
9169                                                           }
9170                                                        }
9171                                                     } # ITERATION
9172                                                  
9173                                                     # Disconnect all open $dbh's
9174          45                                246      map { $dp->disconnect($_) } grep { $_ }
               5                                 38   
             225                                686   
9175                                                        ($qv_dbh, $qv_dbh2, $ex_dbh, $ps_dbh, $ep_dbh);
9176                                                  
9177          45                              43451      return 0;
9178                                                  } # End main().
9179                                                  
9180                                                  # ############################################################################
9181                                                  # Subroutines.
9182                                                  # ############################################################################
9183                                                  sub extract_tables {
9184         104                  104          1096      my ( $query, $default_db ) = @_;
9185         104                                323      MKDEBUG && _d('Extracting tables');
9186         104                                288      my @tables;
9187         104                                275      my %seen;
9188         104                                533      foreach my $db_tbl ( $qp->get_tables($query) ) {
9189  ***     77     50                         304         next unless $db_tbl;
9190          77    100                         476         next if $seen{$db_tbl}++; # Unique-ify for issue 337.
9191          74                                523         my ( $db, $tbl ) = $q->split_unquote($db_tbl);
9192          74           100                  683         push @tables, [ $db || $default_db, $tbl ];
9193                                                     }
9194         104                                531      return @tables;
9195                                                  }
9196                                                  
9197                                                  # Gets a default database and a list of arrayrefs of [db, tbl] to print out
9198                                                  sub print_tables {
9199          80                   80           341      my ( @tables ) = @_;
9200          80    100                         373      return unless @tables;
9201          51                                185      print "# Tables\n";
9202          51                                233      foreach my $db_tbl ( @tables ) {
9203          58                                278         my ( $db, $tbl ) = @$db_tbl;
9204          58    100                         418         print '#    SHOW TABLE STATUS',
9205                                                           ($db ? " FROM `$db`" : ''), " LIKE '$tbl'\\G\n";
9206         116                                540         print "#    SHOW CREATE TABLE ",
9207          58                                249            $q->quote(grep { $_ } @$db_tbl), "\\G\n";
9208                                                     }
9209          51                                158      return;
9210                                                  }
9211                                                  
9212                                                  sub print_explain {
9213          23                   23           128      my ( $dbh, $query, $db ) = @_;
9214  ***     23    100     66                  190      return unless $dbh && $query;
9215           3                                 11      eval {
9216  ***      3     50                          23         if ( !$qp->has_derived_table($query) ) {
9217  ***      3     50                          12            if ( $db ) {
9218           3                                 15               $dbh->do("USE " . $q->quote($db));
9219                                                           }
9220           3                                  9            my $sth = $dbh->prepare("EXPLAIN /*!50100 PARTITIONS */ $query");
9221           3                                571            $sth->execute();
9222           2                                 10            my $i = 1;
9223           2                                 57            while ( my @row = $sth->fetchrow_array() ) {
9224           2                                 18               print "# *************************** ", $i++,
9225                                                                 ". row ***************************\n";
9226           2                                 19               foreach my $j ( 0 .. $#row ) {
9227          20    100                         142                  printf "# %13s: %s\n", $sth->{NAME}->[$j],
9228                                                                    defined $row[$j] ? $row[$j] : 'NULL';
9229                                                              }
9230                                                           }
9231                                                        }
9232                                                     };
9233           3    100                         110      if ( $EVAL_ERROR ) {
9234           1                                  3         MKDEBUG && _d("Problem explaining", $query, $EVAL_ERROR);
9235           1                                  8         print "# EXPLAIN failed: $EVAL_ERROR";
9236                                                     }
9237                                                  }
9238                                                  
9239                                                  # Pass in the currently open $dbh (if any), where $current points to ('execute'
9240                                                  # or 'processlist') and whether you want to be connected to the read_only
9241                                                  # server.  Get back which server you're looking at, and the $dbh.  Assumes that
9242                                                  # one of the servers is ALWAYS read only and the other is ALWAYS not!  If
9243                                                  # there's some transition period where this isn't true, maybe both will end up
9244                                                  # pointing to the same place, but that should resolve shortly.
9245                                                  # The magic switching functionality only works if --mirror is given!  Otherwise
9246                                                  # it just returns the correct $dbh.  $comment is some descriptive text for
9247                                                  # debuggin, like 'for --execute'.
9248                                                  sub find_role {
9249           2                    2            13      my ( $o, $dbh, $current, $read_only, $comment ) = @_;
9250  ***      2     50     66                   59      if ( !$dbh || !$dbh->ping ) {
9251           2                                  5         MKDEBUG && _d('Getting a dbh from', $current, $comment);
9252           2                                 10         $dbh = $dp->get_dbh(
9253                                                           $dp->get_cxn_params($o->get($current)), {AutoCommit => 1});
9254           2                                 13         $dbh->{InactiveDestroy}  = 1;  # Don't die on fork().
9255                                                     }
9256  ***      2     50                          17      if ( $o->get('mirror') ) {
9257  ***      0                                  0         my ( $is_read_only ) = $dbh->selectrow_array('SELECT @@global.read_only');
9258  ***      0                                  0         MKDEBUG && _d("read_only on", $current, $comment, ':',
9259                                                                      $is_read_only, '(want', $read_only, ')');
9260  ***      0      0                           0         if ( $is_read_only != $read_only ) {
9261  ***      0      0                           0            $current = $current eq 'execute' ? 'processlist' : 'execute';
9262  ***      0                                  0            MKDEBUG && _d("read_only wrong", $comment, "getting a dbh from", $current);
9263  ***      0                                  0            $dbh = $dp->get_dbh(
9264                                                              $dp->get_cxn_params($o->get($current)), {AutoCommit => 1});
9265  ***      0                                  0            $dbh->{InactiveDestroy}  = 1;  # Don't die on fork().
9266                                                        }
9267                                                     }
9268           2                                 12      return ($current, $dbh);
9269                                                  }
9270                                                  
9271                                                  # Catches signals so we can exit gracefully.
9272                                                  sub sig_int {
9273  ***      0                    0             0      my ( $signal ) = @_;
9274  ***      0      0                           0      if ( $oktorun ) {
9275  ***      0                                  0         print STDERR "# Caught SIG$signal.\n";
9276  ***      0                                  0         $oktorun = 0;
9277                                                     }
9278                                                     else {
9279  ***      0                                  0         print STDERR "# Exiting on SIG$signal.\n";
9280  ***      0                                  0         exit(1);
9281                                                     }
9282                                                  }
9283                                                  
9284                                                  sub make_alt_attrib {
9285          45                   45           300      my ( $alt_attrib ) = @_;
9286          45                                411      my @alts   = split('\|', $alt_attrib);
9287          45                                180      my $attrib = shift @alts;
9288          45                                107      MKDEBUG && _d('Primary attrib:', $attrib, 'aliases:', @alts);
9289          45                                125      my @lines;
9290          45                                258      push @lines,
9291                                                        'sub { my ( $event ) = @_; ',
9292                                                        'MKDEBUG && _d("callback: alt attrib");',
9293                                                        "if ( exists \$event->{'$attrib'} ) { ",
9294          45                                541         (map { "delete \$event->{'$_'}; "; } @alts),
9295                                                        'return $event; }',     
9296                                                        # Primary attrib doesn't exist; look for alts
9297                                                        (map {
9298          45                                267            "if ( exists \$event->{'$_'} ) { "
9299                                                           . "\$event->{'$attrib'} = \$event->{'$_'}; "
9300                                                           . "delete \$event->{'$_'}; "
9301                                                           . 'return $event; }';
9302                                                        } @alts),
9303                                                        'return $event; }';
9304          45                                115      MKDEBUG && _d('attrib alias sub for', $attrib, ':', @lines);
9305          45                               7360      my $sub = eval join("\n", @lines);
9306  ***     45     50                         280      die if $EVAL_ERROR;
9307          45                                232      return $sub;
9308                                                  }
9309                                                  
9310                                                  sub make_inherit_attribs {
9311          45                   45           207      my ( $attribs, $prev ) = @_;
9312          45                                153      my @lines;
9313          90                                800      push @lines,
9314                                                        'sub { my ( $event ) = @_; ',
9315                                                        'MKDEBUG && _d("callback: inherit attribs");',
9316                                                        (map {
9317          45                                205            "if ( defined \$event->{'$_'} ) { \$prev->{'$_'} = \$event->{'$_'} } else { \$event->{'$_'} = \$prev->{'$_'}; }"
9318                                                         } @$attribs),
9319                                                        'return $event; }';
9320          45                                123      MKDEBUG && _d('inherit attribs sub:', @lines);
9321          45                               5199      my $sub = eval join("\n", @lines);
9322  ***     45     50                         276      die if $EVAL_ERROR;
9323          45                                273      return $sub;
9324                                                  }
9325                                                  
9326                                                  # Checks that the orderby attrib exists in the ea, returns the default
9327                                                  # orderby attrib if not.
9328                                                  sub check_orderby_attrib {
9329          52                   52           271      my ( $orderby_attrib, $ea, $o ) = @_;
9330                                                  
9331          52    100    100                  268      if ( !$ea->type_for($orderby_attrib) && $orderby_attrib ne 'Query_time' ) {
9332           1                                  5         my $default_orderby = $o->get_defaults()->{'order-by'};
9333                                                  
9334                                                        # Print the notice only if the query report is being printed, too.
9335  ***      1     50                           4         if ( $o->get('report-format')->{query_report} ) {
9336           1                                 14            print "--order-by attribute $orderby_attrib doesn't exist, "
9337                                                              . "using $default_orderby\n";
9338                                                        }
9339                                                  
9340                                                        # Fall back to the default orderby attrib.
9341           1                                  6         ( $orderby_attrib, undef ) = split(/:/, $default_orderby);
9342                                                     }
9343                                                  
9344          52                                154      MKDEBUG && _d('orderby attrib:', $orderby_attrib);
9345          52                                223      return $orderby_attrib;
9346                                                  }
9347                                                  
9348                                                  # Read the fh and timeout after t seconds.
9349                                                  sub read_timeout {
9350  ***      0                    0                    my ( $fh, $t ) = @_;
9351  ***      0      0                                  return unless $fh;
9352  ***      0             0                           $t ||= 0;  # will reset alarm and cause read to wait forever
9353                                                  
9354                                                     # Set the SIGALRM handler.
9355  ***      0                                         my $mask   = POSIX::SigSet->new(&POSIX::SIGALRM);
9356                                                     my $action = POSIX::SigAction->new(
9357                                                        sub {
9358                                                           # This sub is called when a SIGALRM is received.
9359  ***      0                    0                          die 'read timeout';
9360                                                        },
9361  ***      0                                            $mask,
9362                                                     );
9363  ***      0                                         my $oldaction = POSIX::SigAction->new();
9364  ***      0                                         sigaction(&POSIX::SIGALRM, $action, $oldaction);
9365                                                  
9366  ***      0                                         my $res;
9367  ***      0                                         eval {
9368  ***      0                                            alarm $t;
9369  ***      0                                            $res = <$fh>;
9370  ***      0                                            alarm 0;
9371                                                     };
9372  ***      0      0                                  if ( $EVAL_ERROR ) {
9373  ***      0                                            MKDEBUG && _d('Read error:', $EVAL_ERROR);
9374  ***      0      0                                     die $EVAL_ERROR unless $EVAL_ERROR =~ m/read timeout/;
9375  ***      0                                            $oktorun = 0;
9376  ***      0                                            $res     = undef;  # res is a blank string after a timeout
9377                                                     }
9378  ***      0                                         return $res;
9379                                                  }
9380                                                  
9381                                                  sub _d {
9382  ***      0                    0                    my ($package, undef, $line) = caller 0;
9383  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
9384  ***      0                                              map { defined $_ ? $_ : 'undef' }
9385                                                          @_;
9386  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
9387                                                  }
9388                                                  
9389                                                  # ############################################################################
9390                                                  # Run the program.
9391                                                  # ############################################################################
9392                                                  if ( !caller ) { exit main(@ARGV); }
9393                                                  
9394                                                  1; # Because this is a module as well as a script.
9395                                                  
9396                                                  # #############################################################################
9397                                                  # Documentation.
9398                                                  # #############################################################################
9399                                                  
9400                                                  =pod
9401                                                  
9402                                                  =head1 NAME
9403                                                  
9404                                                  mk-query-digest - Parses logs and more.  Analyze, transform, filter, review and
9405                                                  report on queries.
9406                                                  
9407                                                  =head1 SYNOPSIS
9408                                                  
9409                                                  Analyze and report on a slow log:
9410                                                  
9411                                                   mk-query-digest /path/to/slow.log
9412                                                  
9413                                                  Review a slow log, saving results to the test.query_review table in a MySQL
9414                                                  server running on host1.  See L<"--review"> for more on reviewing queries:
9415                                                  
9416                                                   mk-query-digest --review h=host1,D=test,t=query_review /path/to/slow.log
9417                                                  
9418                                                  Watch a server's SHOW FULL PROCESSLIST and analyze the queries as if they were
9419                                                  from a slow query log:
9420                                                  
9421                                                   mk-query-digest --processlist h=host1
9422                                                  
9423                                                  Watch a server's SHOW FULL PROCESSLIST, filter out everything but SELECT
9424                                                  queries, and replay the queries against another server, then use the timings
9425                                                  from replaying them to analyze their performance:
9426                                                  
9427                                                   mk-query-digest --processlist h=host1 --execute h=another_server \
9428                                                     --filter '$event->{fingerprint} =~ m/^select/'
9429                                                  
9430                                                  =head1 RISKS
9431                                                  
9432                                                  The following section is included to inform users about the potential risks,
9433                                                  whether known or unknown, of using this tool.  The two main categories of risks
9434                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
9435                                                  tools) and those created by bugs.
9436                                                  
9437                                                  By default mk-query-digest merely collects and aggregates data from the files
9438                                                  specified.  It is designed to be as efficient as possible, but depending on the
9439                                                  input you give it, it can use a lot of CPU and memory.  Practically speaking, it
9440                                                  is safe to run even on production systems, but you might want to monitor it
9441                                                  until you are satisfied that the input you give it does not cause undue load.
9442                                                  
9443                                                  Various options will cause mk-query-digest to insert data into tables, execute
9444                                                  SQL queries, and so on.  These include the L<"--execute"> option and
9445                                                  L<"--review">.
9446                                                  
9447                                                  At the time of this release, we know of no bugs that could cause serious harm to
9448                                                  users.
9449                                                  
9450                                                  The authoritative source for updated information is always the online issue
9451                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
9452                                                  see a list of such issues at the following URL:
9453                                                  L<http://www.maatkit.org/bugs/mk-query-digest>.
9454                                                  
9455                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
9456                                                  
9457                                                  =head1 DESCRIPTION
9458                                                  
9459                                                  This tool was formerly known as mk-log-parser.
9460                                                  
9461                                                  C<mk-query-digest> is a framework for doing things with events from a query
9462                                                  source such as the slow query log or PROCESSLIST.  By default it acts as a very
9463                                                  sophisticated log analysis tool.  You can group and sort queries in many
9464                                                  different ways simultaneously and find the most expensive queries, or create a
9465                                                  timeline of queries in the log, for example.  It can also do a "query review,"
9466                                                  which means to save a sample of each type of query into a MySQL table so you can
9467                                                  easily see whether you've reviewed and analyzed a query before.  The benefit of
9468                                                  this is that you can keep track of changes to your server's queries and avoid
9469                                                  repeated work.  You can also save other information with the queries, such as
9470                                                  comments, issue numbers in your ticketing system, and so on.
9471                                                  
9472                                                  Note that this is a work in *very* active progress and you should expect
9473                                                  incompatible changes in the future.
9474                                                  
9475                                                  =head1 ATTRIBUTES
9476                                                  
9477                                                  mk-query-digest works on events, which are a collection of key/value pairs
9478                                                  called attributes.  You'll recognize most of the attributes right away:
9479                                                  Query_time, Lock_time, and so on.  You can just look at a slow log and see them.
9480                                                  However, there are some that don't exist in the slow log, and slow logs
9481                                                  may actually include different kinds of attributes (for example, you may have a
9482                                                  server with the Percona patches).
9483                                                  
9484                                                  For a full list of attributes, see
9485                                                  L<http://code.google.com/p/maatkit/wiki/EventAttributes>.
9486                                                  
9487                                                  =head2 memcached
9488                                                  
9489                                                  memcached events have additional attributes related to the memcached protocol:
9490                                                  cmd, key, res (result) and val.  Also, boolean attributes are created for
9491                                                  the various commands, misses and errors: Memc_CMD where CMD is a memcached
9492                                                  command (get, set, delete, etc.), Memc_error and Memc_miss.
9493                                                  
9494                                                  These attributes are no different from slow log attributes, so you can use them
9495                                                  with L<"--[no]report">, L<"--group-by">, in a L<"--filter">, etc.
9496                                                  
9497                                                  These attributes and more are documented at
9498                                                  L<http://code.google.com/p/maatkit/wiki/EventAttributes>.
9499                                                  
9500                                                  =head1 OUTPUT
9501                                                  
9502                                                  The default output is a query analysis report.  The L<"--[no]report"> option
9503                                                  controls whether or not this report is printed.  Sometimes you may wish to
9504                                                  parse all the queries but suppress the report, for example when using
9505                                                  L<"--print"> or L<"--review">.
9506                                                  
9507                                                  There is one paragraph for each class of query analyzed.  A "class" of queries
9508                                                  all have the same value for the L<"--group-by"> attribute which is
9509                                                  "fingerprint" by default.  (See L<"ATTRIBUTES">.)  A fingerprint is an
9510                                                  abstracted version of the query text with literals removed, whitespace
9511                                                  collapsed, and so forth.  The report is formatted so it's easy to paste into
9512                                                  emails without wrapping, and all non-query lines begin with a comment, so you
9513                                                  can save it to a .sql file and open it in your favorite syntax-highlighting
9514                                                  text editor.  There is a response-time profile at the very end.
9515                                                  
9516                                                  The report begins with one paragraph about the entire analysis run.  The
9517                                                  information is very similar to what you'll see for each class of queries in the
9518                                                  log, but it doesn't have some information that would be too expensive to keep
9519                                                  globally for the analysis.  It also has some statistics about the code's
9520                                                  excution itself, such as the CPU and memory usage.
9521                                                  
9522                                                  Following this, each query then appears in a paragraph.  Here's a sample,
9523                                                  slightly reformatted so 'perldoc' will not wrap lines in a terminal.  The
9524                                                  following will all be one paragraph, but we'll break it up for commentary.
9525                                                  
9526                                                   # Query 2: 0.01 QPS, 0.02x conc, ID 0xFDEA8D2993C9CAF3 at byte 160665
9527                                                  
9528                                                  This line identifies the sequential number of the query in the sort order
9529                                                  specified by L<"--order-by">.  Then there's the queries per second, and the
9530                                                  approximate concurrency for this query (calculated as a function of the timespan
9531                                                  and total Query_time).  Next there's a query ID.  This ID is a hex version of
9532                                                  the query's checksum in the database, if you're using L<"--review">.  You can
9533                                                  select the reviewed query's details from the database with a query like C<SELECT
9534                                                  .... WHERE checksum=0xFDEA8D2993C9CAF3>.
9535                                                  
9536                                                  Finally, in case you want to find a sample of the query in the log file, there's
9537                                                  the byte offset where you can look.  (This is not always accurate, due to some
9538                                                  silly anomalies in the slow-log format, but it's usually right.)  The position
9539                                                  refers to the worst sample, which we'll see more about below.
9540                                                  
9541                                                  Next is the table of metrics about this class of queries.
9542                                                  
9543                                                   #           pct   total    min    max     avg     95%  stddev  median
9544                                                   # Count       0       2
9545                                                   # Exec time  13   1105s   552s   554s    553s    554s      2s    553s
9546                                                   # Lock time   0   216us   99us  117us   108us   117us    12us   108us
9547                                                   # Rows sent  20   6.26M  3.13M  3.13M   3.13M   3.13M   12.73   3.13M
9548                                                   # Rows exam   0   6.26M  3.13M  3.13M   3.13M   3.13M   12.73   3.13M
9549                                                  
9550                                                  The first line is column headers for the table.  The percentage is the percent
9551                                                  of the total for the whole analysis run, and the total is the actual value of
9552                                                  the specified metric.  For example, in this case we can see that the query
9553                                                  executed 2 times, which is 13% of the total number of queries in the file.  The
9554                                                  min, max and avg columns are self-explanatory.  The 95% column shows the 95th
9555                                                  percentile; 95% of the values are less than or equal to this value.  The
9556                                                  standard deviation shows you how tightly grouped the values are.  The standard
9557                                                  deviation and median are both calculated from the 95th percentile, discarding
9558                                                  the extremely large values.
9559                                                  
9560                                                  The stddev, median and 95th percentile statistics are approximate.  Exact
9561                                                  statistics require keeping every value seen, sorting, and doing some
9562                                                  calculations on them.  This uses a lot of memory.  To avoid this, we keep 1000
9563                                                  buckets, each of them 5% bigger than the one before, ranging from .000001 up to
9564                                                  a very big number.  When we see a value we increment the bucket into which it
9565                                                  falls.  Thus we have fixed memory per class of queries.  The drawback is the
9566                                                  imprecision, which typically falls in the 5 percent range.
9567                                                  
9568                                                  Next we have statistics on the users, databases and time range for the query.
9569                                                  
9570                                                   # Users       1   user1
9571                                                   # Databases   2     db1(1), db2(1)
9572                                                   # Time range 2008-11-26 04:55:18 to 2008-11-27 00:15:15
9573                                                  
9574                                                  The users and databases are shown as a count of distinct values, followed by the
9575                                                  values.  If there's only one, it's shown alone; if there are many, we show each
9576                                                  of the most frequent ones, followed by the number of times it appears.
9577                                                  
9578                                                   # Query_time distribution
9579                                                   #   1us
9580                                                   #  10us
9581                                                   # 100us
9582                                                   #   1ms
9583                                                   #  10ms
9584                                                   # 100ms
9585                                                   #    1s
9586                                                   #  10s+  #############################################################
9587                                                  
9588                                                  The execution times show a logarithmic chart of time clustering.  Each query
9589                                                  goes into one of the "buckets" and is counted up.  The buckets are powers of
9590                                                  ten.  The first bucket is all values in the "single microsecond range" -- that
9591                                                  is, less than 10us.  The second is "tens of microseconds," which is from 10us
9592                                                  up to (but not including) 100us; and so on.
9593                                                  
9594                                                   # Tables
9595                                                   #    SHOW TABLE STATUS LIKE 'table1'\G
9596                                                   #    SHOW CREATE TABLE `table1`\G
9597                                                   # EXPLAIN
9598                                                   SELECT * FROM table1\G
9599                                                  
9600                                                  This section is a convenience: if you're trying to optimize the queries you see
9601                                                  in the slow log, you probably want to examine the table structure and size.
9602                                                  These are copy-and-paste-ready commands to do that.
9603                                                  
9604                                                  Finally, we see a sample of the queries in this class of query.  This is not a
9605                                                  random sample.  It is the query that performed the worst, according to the sort
9606                                                  order given by L<"--order-by">.  You will normally see a commented C<# EXPLAIN>
9607                                                  line just before it, so you can copy-paste the query to examine its EXPLAIN
9608                                                  plan. But for non-SELECT queries that isn't possible to do, so the tool tries to
9609                                                  transform the query into a roughly equivalent SELECT query, and adds that below.
9610                                                  
9611                                                  If you want to find this sample event in the log, use the offset mentioned
9612                                                  above, and something like the following:
9613                                                  
9614                                                    tail -c +<offset> /path/to/file | head
9615                                                  
9616                                                  The final bit of output is the response-time profile over the events.  This is a
9617                                                  summarized view of what we've already seen.  Here is a sample:
9618                                                  
9619                                                    # Rank Query ID           Response time    Calls   R/Call     Item
9620                                                    # ==== ================== ================ ======= ========== ====
9621                                                    #    1 0x31DA25F95494CA95     0.1494 99.9%       1   0.149435 SHOW
9622                                                    #    2 0x3AEAAD0E15D725B5     0.0001  0.1%       2   0.000041 SET
9623                                                    #    3 0x813031B8BBC3B329     0.0000  0.0%       1   0.000015 COMMIT
9624                                                  
9625                                                  The columns should be fairly self-explanatory: rank, query ID, response time sum
9626                                                  and percentage of total; number of calls and response time per call; and the
9627                                                  distilled query (see L<"distill"> for more detail on this).
9628                                                  
9629                                                  =head1 QUERY REVIEWS
9630                                                  
9631                                                  A "query review" is the process of storing all the query fingerprints analyzed.
9632                                                  This has several benefits:
9633                                                  
9634                                                  =over
9635                                                  
9636                                                  =item *
9637                                                  
9638                                                  You can add meta-data to classes of queries, such as marking them for follow-up,
9639                                                  adding notes to queries, or marking them with an issue ID for your issue
9640                                                  tracking system.
9641                                                  
9642                                                  =item *
9643                                                  
9644                                                  You can refer to the stored values on subsequent runs so you'll know whether
9645                                                  you've seen a query before.  This can help you cut down on duplicated work.
9646                                                  
9647                                                  =item *
9648                                                  
9649                                                  You can store historical data such as the row count, query times, and generally
9650                                                  anything you can see in the report.
9651                                                  
9652                                                  =back
9653                                                  
9654                                                  To use this feature, you run mk-query-digest with the L<"--review"> option.  It
9655                                                  will store the fingerprints and other information into the table you specify.
9656                                                  Next time you run it with the same option, it will do the following:
9657                                                  
9658                                                  =over
9659                                                  
9660                                                  =item *
9661                                                  
9662                                                  It won't show you queries you've already reviewed.  A query is considered to be
9663                                                  already reviewed if you've set a value for the C<reviewed_by> column.  (If you
9664                                                  want to see queries you've already reviewed, use the L<"--report-all"> option.)
9665                                                  
9666                                                  =item *
9667                                                  
9668                                                  Queries that you've reviewed, and don't appear in the output, will cause gaps in
9669                                                  the query number sequence in the first line of each paragraph.  And the value
9670                                                  you've specified for L<"--limit"> will still be honored.  So if you've reviewed all
9671                                                  queries in the top 10 and you ask for the top 10, you won't see anything in the
9672                                                  output.
9673                                                  
9674                                                  =item *
9675                                                  
9676                                                  If you want to see the queries you've already reviewed, you can specify
9677                                                  L<"--report-all">.  Then you'll see the normal analysis output, but you'll also see
9678                                                  the information from the review table, just below the execution time graph.  For
9679                                                  example,
9680                                                  
9681                                                    # Review information
9682                                                    #      comments: really bad IN() subquery, fix soon!
9683                                                    #    first_seen: 2008-12-01 11:48:57
9684                                                    #   jira_ticket: 1933
9685                                                    #     last_seen: 2008-12-18 11:49:07
9686                                                    #      priority: high
9687                                                    #   reviewed_by: xaprb
9688                                                    #   reviewed_on: 2008-12-18 15:03:11
9689                                                  
9690                                                  You can see how useful this meta-data is -- as you analyze your queries, you get
9691                                                  your comments integrated right into the report.
9692                                                  
9693                                                  If you add the L<"--review-history"> option, it will also store information into
9694                                                  a separate database table, so you can keep historical trending information on
9695                                                  classes of queries.
9696                                                  
9697                                                  =back
9698                                                  
9699                                                  =head1 FINGERPRINTS
9700                                                  
9701                                                  A query fingerprint is the abstracted form of a query, which makes it possible
9702                                                  to group similar queries together.  Abstracting a query removes literal values,
9703                                                  normalizes whitespace, and so on.  For example, these two queries:
9704                                                  
9705                                                    SELECT name, password FROM user WHERE id='12823';
9706                                                    select name,   password from user
9707                                                       where id=5;
9708                                                  
9709                                                  Both of those queries will fingerprint to
9710                                                  
9711                                                    select name, password from user where id=?
9712                                                  
9713                                                  Once the query's fingerprint is known, we can then talk about a query as though
9714                                                  it represents all similar queries.
9715                                                  
9716                                                  What C<mk-query-digest> does is analogous to a GROUP BY statement in SQL.
9717                                                  If your command-line looks like this,
9718                                                  
9719                                                    mk-query-digest /path/to/slow.log --select Rows_read,Rows_sent \
9720                                                        --group-by fingerprint --order-by Query_time:sum --limit 10
9721                                                  
9722                                                  The corresponding pseudo-SQL looks like this:
9723                                                  
9724                                                    SELECT WORST(query BY Query_time), SUM(Query_time), ...
9725                                                    FROM /path/to/slow.log
9726                                                    GROUP BY FINGERPRINT(query)
9727                                                    ORDER BY SUM(Query_time) DESC
9728                                                    LIMIT 10
9729                                                  
9730                                                  You can also use the value C<distill>, which is a kind of super-fingerprint.
9731                                                  See L<"--group-by"> for more.
9732                                                  
9733                                                  =head2 memcached
9734                                                  
9735                                                  If parsing memcached input (L<"--type"> memcached), the fingerprint is an
9736                                                  abstracted version of the command and key, with placeholders removed.
9737                                                  For example, "get user_123_preferences" fingerprints to
9738                                                  "get user_?_preferences".
9739                                                  
9740                                                  There is also a "key_print" which a fingerprinted version of the key.  For
9741                                                  the example above, its key_print is "user_?_preferences".
9742                                                  
9743                                                  =head1 OPTIONS
9744                                                  
9745                                                  DSN values in L<"--review-history"> default to values in L<"--review"> if COPY
9746                                                  is yes.
9747                                                  
9748                                                  =over
9749                                                  
9750                                                  =item --ask-pass
9751                                                  
9752                                                  Prompt for a password when connecting to MySQL.
9753                                                  
9754                                                  =item --attribute-aliases
9755                                                  
9756                                                  type: array; default: db|Schema
9757                                                  
9758                                                  List of attribute|alias,etc.
9759                                                  
9760                                                  Certain attributes have multiple names, like db and Schema.  If an event does
9761                                                  not have the priamry attribute, mk-query-digest looks for an alias attribute.
9762                                                  If it finds an alias, it creates the primary attribute with the alias
9763                                                  attribute's value and removes the alias attribute.
9764                                                  
9765                                                  If the event has the primary attribute, all alias attributes are deleted.
9766                                                  
9767                                                  This helps to simplify event attributes so that, for example, there will not
9768                                                  be report lines for both db and Schema.
9769                                                  
9770                                                  =item --attribute-value-limit
9771                                                  
9772                                                  type: int; default: 4294967296
9773                                                  
9774                                                  A sanity limit for attribute values.
9775                                                  
9776                                                  This option deals with bugs in slow-logging functionality that causes large
9777                                                  values for attributes.  If the attribute's value is bigger than this, the
9778                                                  last-seen value for that class of query is used instead.
9779                                                  
9780                                                  =item --aux-dsn
9781                                                  
9782                                                  type: DSN
9783                                                  
9784                                                  Auxiliary DSN used for special options.
9785                                                  
9786                                                  The following options may require a DSN even when only parsing a slow log file:
9787                                                  
9788                                                    * L<"--since">
9789                                                    * L<"--until">
9790                                                  
9791                                                  See each option for why it might require a DSN.
9792                                                  
9793                                                  =item --charset
9794                                                  
9795                                                  short form: -A; type: string
9796                                                  
9797                                                  Default character set.  If the value is utf8, sets Perl's binmode on
9798                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
9799                                                  runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
9800                                                  binmode on STDOUT without the utf8 layer, and runs SET NAMES after
9801                                                  connecting to MySQL.
9802                                                  
9803                                                  =item --check-attributes-limit
9804                                                  
9805                                                  type: int; default: 1000
9806                                                  
9807                                                  Stop checking for new attributes after this many events.
9808                                                  
9809                                                  For better speed, mk-query-digest stops checking events for new attributes
9810                                                  after a certain number of events.  Any new attributes after this number
9811                                                  will be ignored and will not be reported.
9812                                                  
9813                                                  One special case is new attributes for pre-existing query classes
9814                                                  (see L<"--group-by"> about query classes).  New attributes will not be added
9815                                                  to pre-existing query classes even if the attributes are detected before the
9816                                                  L<"--check-attributes-limit"> limit.
9817                                                  
9818                                                  =item --config
9819                                                  
9820                                                  type: Array
9821                                                  
9822                                                  Read this comma-separated list of config files; if specified, this must be the
9823                                                  first option on the command line.
9824                                                  
9825                                                  =item --[no]continue-on-error
9826                                                  
9827                                                  default: yes
9828                                                  
9829                                                  Continue parsing even if there is an error.
9830                                                  
9831                                                  =item --create-review-history-table
9832                                                  
9833                                                  Create the L<"--review-history"> table if it does not exist.
9834                                                  
9835                                                  This option causes the table specified by L<"--review-history"> to be created
9836                                                  with the default structure shown in the documentation for that option.
9837                                                  
9838                                                  =item --create-review-table
9839                                                  
9840                                                  Create the L<"--review"> table if it does not exist.
9841                                                  
9842                                                  This option causes the table specified by L<"--review"> to be created with the
9843                                                  default structure shown in the documentation for that option.
9844                                                  
9845                                                  =item --daemonize
9846                                                  
9847                                                  Fork to the background and detach from the shell.  POSIX
9848                                                  operating systems only.
9849                                                  
9850                                                  =item --defaults-file
9851                                                  
9852                                                  short form: -F; type: string
9853                                                  
9854                                                  Only read mysql options from the given file.  You must give an absolute pathname.
9855                                                  
9856                                                  =item --embedded-attributes
9857                                                  
9858                                                  type: array
9859                                                  
9860                                                  Two Perl regex patterns to capture pseudo-attributes embedded in queries.
9861                                                  
9862                                                  Embedded attributes might be special attribute-value pairs that you've hidden
9863                                                  in comments.  The first regex should match the entire set of attributes (in
9864                                                  case there are multiple).  The second regex should match and capture
9865                                                  attribute-value pairs from the first regex.
9866                                                  
9867                                                  For example, suppose your query looks like the following:
9868                                                  
9869                                                    SELECT * from users -- file: /login.php, line: 493;
9870                                                  
9871                                                  You might run mk-query-digest with the following option:
9872                                                  
9873                                                    mk-query-digest --embedded-attributes ' -- .*','(\w+): ([^\,]+)'
9874                                                  
9875                                                  The first regular expression captures the whole comment:
9876                                                  
9877                                                    " -- file: /login.php, line: 493;"
9878                                                  
9879                                                  The second one splits it into attribute-value pairs and adds them to the event:
9880                                                  
9881                                                     ATTRIBUTE  VALUE
9882                                                     =========  ==========
9883                                                     file       /login.php
9884                                                     line       493
9885                                                  
9886                                                  B<NOTE>: All commas in the regex patterns must be escaped with \ otherwise
9887                                                  the pattern will break.
9888                                                  
9889                                                  =item --execute
9890                                                  
9891                                                  type: DSN
9892                                                  
9893                                                  Execute queries on this DSN.
9894                                                  
9895                                                  Adds a callback into the chain, after filters but before the reports.  Events
9896                                                  are executed on this DSN.  If they are successful, the time they take to execute
9897                                                  overwrites the event's Query_time attribute.  If unsuccessful, the callback
9898                                                  returns false and terminates the chain.
9899                                                  
9900                                                  If the connection fails, mk-query-digest tries to reconnect once per second.
9901                                                  
9902                                                  See also L<"--mirror"> and L<"--execute-throttle">.
9903                                                  
9904                                                  =item --execute-throttle
9905                                                  
9906                                                  type: array
9907                                                  
9908                                                  Throttle values for L<"--execute">.
9909                                                  
9910                                                  By default L<"--execute"> runs without any limitations or concerns for the
9911                                                  amount of time that it takes to execute the events.  The L<"--execute-throttle">
9912                                                  allows you to limit the amount of time spent doing L<"--execute"> relative
9913                                                  to the other processes that handle events.  This works by marking some events
9914                                                  with a C<Skip_exec> attribute when L<"--execute"> begins to take too much time.
9915                                                  L<"--execute"> will not execute an event if this attribute is true.  This
9916                                                  indirectly decreases the time spent doing L<"--execute">.
9917                                                  
9918                                                  The L<"--execute-throttle"> option takes at least two comma-separated values:
9919                                                  max allowed L<"--execute"> time as a percentage and a check interval time.  An
9920                                                  optional third value is a percentage step for increasing and decreasing the
9921                                                  probability that an event will be marked C<Skip_exec> true.  5 (percent) is
9922                                                  the default step.
9923                                                  
9924                                                  For example: L<"--execute-throttle"> C<70,60,10>.  This will limit
9925                                                  L<"--execute"> to 70% of total event processing time, checked every minute
9926                                                  (60 seconds) and probability stepped up and down by 10%.  When L<"--execute">
9927                                                  exceeds 70%, the probability that events will be marked C<Skip_exec> true
9928                                                  increases by 10%. L<"--execute"> time is checked again after another minute.
9929                                                  If it's still above 70%, then the probability will increase another 10%.
9930                                                  Or, if it's dropped below 70%, then the probability will decrease by 10%.
9931                                                  
9932                                                  =item --expected-range
9933                                                  
9934                                                  type: array; default: 5,10
9935                                                  
9936                                                  Explain items when there are more or fewer than expected.
9937                                                  
9938                                                  Defines the number of items expected to be seen in the report given by
9939                                                  L<"--[no]report">, as controlled by L<"--limit"> and L<"--outliers">.  If
9940                                                  there  are more or fewer items in the report, each one will explain why it was
9941                                                  included.
9942                                                  
9943                                                  =item --explain
9944                                                  
9945                                                  type: DSN
9946                                                  
9947                                                  Run EXPLAIN for the sample query with this DSN and print results.
9948                                                  
9949                                                  This works only when L<"--group-by"> includes fingerprint.  It causes
9950                                                  mk-query-digest to run EXPLAIN and include the output into the report.  For
9951                                                  safety, queries that appear to have a subquery that EXPLAIN will execute won't
9952                                                  be EXPLAINed.  Those are typically "derived table" queries of the form
9953                                                  
9954                                                    select ... from ( select .... ) der;
9955                                                  
9956                                                  =item --filter
9957                                                  
9958                                                  type: string
9959                                                  
9960                                                  Discard events for which this Perl code doesn't return true.
9961                                                  
9962                                                  This option is a string of Perl code or a file containing Perl code that gets
9963                                                  compiled into a subroutine with one argument: $event.  This is a hashref.
9964                                                  If the given value is a readable file, then mk-query-digest reads the entire
9965                                                  file and uses its contents as the code.  The file should not contain
9966                                                  a shebang (#!/usr/bin/perl) line.
9967                                                  
9968                                                  If the code returns true, the chain of callbacks continues; otherwise it ends.
9969                                                  The code is the last statement in the subroutine other than C<return $event>. 
9970                                                  The subroutine template is:
9971                                                  
9972                                                    sub { $event = shift; filter && return $event; }
9973                                                  
9974                                                  Filters given on the command line are wrapped inside parentheses like like
9975                                                  C<( filter )>.  For complex, multi-line filters, you must put the code inside
9976                                                  a file so it will not be wrapped inside parentheses.  Either way, the filter
9977                                                  must produce syntactically valid code given the template.  For example, an
9978                                                  if-else branch given on the command line would not be valid:
9979                                                  
9980                                                    --filter 'if () { } else { }'  # WRONG
9981                                                  
9982                                                  Since it's given on the command line, the if-else branch would be wrapped inside
9983                                                  parentheses which is not syntactically valid.  So to accomplish something more
9984                                                  complex like this would require putting the code in a file, for example
9985                                                  filter.txt:
9986                                                  
9987                                                    my $event_ok; if (...) { $event_ok=1; } else { $event_ok=0; } $event_ok
9988                                                  
9989                                                  Then specify C<--filter filter.txt> to read the code from filter.txt.
9990                                                  
9991                                                  If the filter code won't compile, mk-query-digest will die with an error.
9992                                                  If the filter code does compile, an error may still occur at runtime if the
9993                                                  code tries to do something wrong (like pattern match an undefined value).
9994                                                  mk-query-digest does not provide any safeguards so code carefully!
9995                                                  
9996                                                  An example filter that discards everything but SELECT statements:
9997                                                  
9998                                                    --filter '$event->{arg} =~ m/^select/i'
9999                                                  
10000                                                 This is compiled into a subroutine like the following:
10001                                                 
10002                                                   sub { $event = shift; ( $event->{arg} =~ m/^select/i ) && return $event; }
10003                                                 
10004                                                 It is permissible for the code to have side effects (to alter $event).
10005                                                 
10006                                                 You can find an explanation of the structure of $event at
10007                                                 L<http://code.google.com/p/maatkit/wiki/EventAttributes>.
10008                                                 
10009                                                 Here are more examples of filter code:
10010                                                 
10011                                                 =over
10012                                                 
10013                                                 =item Host/IP matches domain.com
10014                                                 
10015                                                 --filter '($event->{host} || $event->{ip} || "") =~ m/domain.com/'
10016                                                 
10017                                                 Sometimes MySQL logs the host where the IP is expected.  Therefore, we
10018                                                 check both.
10019                                                 
10020                                                 =item User matches john
10021                                                 
10022                                                 --filter '($event->{user} || "") =~ m/john/'
10023                                                 
10024                                                 =item More than 1 warning
10025                                                 
10026                                                 --filter '($event->{Warning_count} || 0) > 1'
10027                                                 
10028                                                 =item Query does full table scan or full join
10029                                                 
10030                                                 --filter '(($event->{Full_scan} || "") eq "Yes") || (($event->{Full_join} || "") eq "Yes")'
10031                                                 
10032                                                 =item Query was not served from query cache
10033                                                 
10034                                                 --filter '($event->{QC_Hit} || "") eq "No"'
10035                                                 
10036                                                 =item Query is 1 MB or larger
10037                                                 
10038                                                 --filter '$event->{bytes} >= 1_048_576'
10039                                                 
10040                                                 =back
10041                                                 
10042                                                 =item --fingerprints
10043                                                 
10044                                                 Add query fingerprints to the standard query analysis report.  This is mostly
10045                                                 useful for debugging purposes.
10046                                                 
10047                                                 =item --[no]for-explain
10048                                                 
10049                                                 default: yes
10050                                                 
10051                                                 Print extra information to make analysis easy.
10052                                                 
10053                                                 This option adds code snippets to make it easy to run SHOW CREATE TABLE and SHOW
10054                                                 TABLE STATUS for the query's tables.  It also rewrites non-SELECT queries into a
10055                                                 SELECT that might be helpful for determining the non-SELECT statement's index
10056                                                 usage.
10057                                                 
10058                                                 =item --group-by
10059                                                 
10060                                                 type: Array; default: fingerprint
10061                                                 
10062                                                 Which attribute of the events to group by.
10063                                                 
10064                                                 In general, you can group queries into classes based on any attribute of the
10065                                                 query, such as C<user> or C<db>, which will by default show you which users
10066                                                 and which databases get the most C<Query_time>.  The default attribute,
10067                                                 C<fingerprint>, groups similar, abstracted queries into classes; see below
10068                                                 and see also L<"FINGERPRINTS">.
10069                                                 
10070                                                 A report is printed for each L<"--group-by"> value (unless C<--no-report> is
10071                                                 given).  Therefore, C<--group-by user,db> means "report on queries with the
10072                                                 same user and report on queries with the same db"--it does not mean "report
10073                                                 on queries with the same user and db."  See also L<"OUTPUT">.
10074                                                 
10075                                                 Every value must have a corresponding value in the same position in
10076                                                 L<"--order-by">.  However, adding values to L<"--group-by"> will automatically
10077                                                 add values to L<"--order-by">, for your convenience.
10078                                                 
10079                                                 There are several magical values that cause some extra data mining to happen
10080                                                 before the grouping takes place:
10081                                                 
10082                                                 =over
10083                                                 
10084                                                 =item fingerprint
10085                                                 
10086                                                 This causes events to be fingerprinted to abstract queries into
10087                                                 a canonical form, which is then used to group events together into a class.
10088                                                 See L<"FINGERPRINTS"> for more about fingerprinting.
10089                                                 
10090                                                 =item tables
10091                                                 
10092                                                 This causes events to be inspected for what appear to be tables, and
10093                                                 then aggregated by that.  Note that a query that contains two or more tables
10094                                                 will be counted as many times as there are tables; so a join against two tables
10095                                                 will count the Query_time against both tables.
10096                                                 
10097                                                 =item distill
10098                                                 
10099                                                 This is a sort of super-fingerprint that collapses queries down
10100                                                 into a suggestion of what they do, such as C<INSERT SELECT table1 table2>.
10101                                                 
10102                                                 =back
10103                                                 
10104                                                 If parsing memcached input (L<"--type"> memcached), there are other
10105                                                 attributes which you can group by: key_print (see memcached section in
10106                                                 L<"FINGERPRINTS">), cmd, key, res and val (see memcached section in
10107                                                 L<"ATTRIBUTES">).
10108                                                 
10109                                                 =item --help
10110                                                 
10111                                                 Show help and exit.
10112                                                 
10113                                                 =item --host
10114                                                 
10115                                                 short form: -h; type: string
10116                                                 
10117                                                 Connect to host.
10118                                                 
10119                                                 =item --ignore-attributes
10120                                                 
10121                                                 type: array; default: arg, cmd, insert_id, ip, port, Thread_id, timestamp, exptime, flags, key, res, val, server_id, offset, end_log_pos, Xid
10122                                                 
10123                                                 Do not aggregate these attributes when auto-detecting L<"--select">.
10124                                                 
10125                                                 If you do not specify L<"--select"> then mk-query-digest auto-detects and
10126                                                 aggregates every attribute that it finds in the slow log.  Some attributes,
10127                                                 however, should not be aggregated.  This option allows you to specify a list
10128                                                 of attributes to ignore.  This only works when no explicit L<"--select"> is
10129                                                 given.
10130                                                 
10131                                                 =item --inherit-attributes
10132                                                 
10133                                                 type: array; default: db,ts
10134                                                 
10135                                                 If missing, inherit these attributes from the last event that had them.
10136                                                 
10137                                                 This option sets which attributes are inherited or carried forward to events
10138                                                 which do not have them.  For example, if one event has the db attribute equal
10139                                                 to "foo", but the next event doesn't have the db attribute, then it inherits
10140                                                 "foo" for its db attribute.
10141                                                 
10142                                                 Inheritance is usually desirable, but in some cases it might confuse things.
10143                                                 If a query inherits a database that it doesn't actually use, then this could
10144                                                 confuse L<"--execute">.
10145                                                 
10146                                                 =item --interval
10147                                                 
10148                                                 type: float; default: .1
10149                                                 
10150                                                 How frequently to poll the processlist, in seconds.
10151                                                 
10152                                                 =item --iterations
10153                                                 
10154                                                 type: int; default: 1
10155                                                 
10156                                                 How many times to iterate through the collect-and-report cycle.  If 0, iterate
10157                                                 to infinity.  See also L<"--run-time">.
10158                                                 
10159                                                 =item --limit
10160                                                 
10161                                                 type: Array; default: 95%:20
10162                                                 
10163                                                 Limit output to the given percentage or count.
10164                                                 
10165                                                 If the argument is an integer, report only the top N worst queries.  If the
10166                                                 argument is an integer followed by the C<%> sign, report that percentage of the
10167                                                 worst queries.  If the percentage is followed by a colon and another integer,
10168                                                 report the top percentage or the number specified by that integer, whichever
10169                                                 comes first.
10170                                                 
10171                                                 The value is actually a comma-separated array of values, one for each item in
10172                                                 L<"--group-by">.  If you don't specify a value for any of those items, the
10173                                                 default is the top 95%.
10174                                                 
10175                                                 See also L<"--outliers">.
10176                                                 
10177                                                 =item --log
10178                                                 
10179                                                 type: string
10180                                                 
10181                                                 Print all output to this file when daemonized.
10182                                                 
10183                                                 =item --mirror
10184                                                 
10185                                                 type: float
10186                                                 
10187                                                 How often to check whether connections should be moved, depending on
10188                                                 C<read_only>.  Requires L<"--processlist"> and L<"--execute">.
10189                                                 
10190                                                 This option causes mk-query-digest to check every N seconds whether it is reading
10191                                                 from a read-write server and executing against a read-only server, which is a
10192                                                 sensible way to set up two servers if you're doing something like master-master
10193                                                 replication.  The L<http://code.google.com/p/mysql-master-master/> master-master
10194                                                 toolkit does this. The aim is to keep the passive server ready for failover,
10195                                                 which is impossible without putting it under a realistic workload.
10196                                                 
10197                                                 =item --order-by
10198                                                 
10199                                                 type: Array; default: Query_time:sum
10200                                                 
10201                                                 Sort events by this attribute and aggregate function.
10202                                                 
10203                                                 This is a comma-separated list of order-by expressions, one for each
10204                                                 L<"--group-by"> attribute.  The default C<Query_time:sum> is used for
10205                                                 L<"--group-by"> attributes without explicitly given L<"--order-by"> attributes
10206                                                 (that is, if you specify more L<"--group-by"> attributes than corresponding
10207                                                 L<"--order-by"> attributes).  The syntax is C<attribute:aggregate>.  See
10208                                                 L<"ATTRIBUTES"> for valid attributes.  Valid aggregates are:
10209                                                 
10210                                                    Aggregate Meaning
10211                                                    ========= ============================
10212                                                    sum       Sum/total attribute value
10213                                                    min       Minimum attribute value
10214                                                    max       Maximum attribute value
10215                                                    cnt       Frequency/count of the query
10216                                                 
10217                                                 For example, the default C<Query_time:sum> means that queries in the
10218                                                 query analysis report will be ordered (sorted) by their total query execution
10219                                                 time ("Exec time").  C<Query_time:max> orders the queries by their
10220                                                 maximum query execution time, so the query with the single largest
10221                                                 C<Query_time> will be list first.  C<cnt> refers more to the frequency
10222                                                 of the query as a whole, how often it appears; "Count" is its corresponding
10223                                                 line in the query analysis report.  So any attribute and C<cnt> should yield
10224                                                 the same report wherein queries are sorted by the number of times they
10225                                                 appear.
10226                                                 
10227                                                 When parsing general logs (L<"--type"> C<genlog>), the default L<"--order-by">
10228                                                 becomes C<Query_time:cnt>.  General logs do not report query times so only
10229                                                 the C<cnt> aggregate makes sense because all query times are zero.
10230                                                 
10231                                                 If you specify an attribute that doesn't exist in the events, then
10232                                                 mk-query-digest falls back to the default C<Query_time:sum> and prints a notice
10233                                                 at the beginning of the report for each query class.
10234                                                 
10235                                                 =item --outliers
10236                                                 
10237                                                 type: array; default: Query_time:1:10
10238                                                 
10239                                                 Report outliers by attribute:percentile:count.
10240                                                 
10241                                                 The syntax of this option is a comma-separated list of colon-delimited strings.
10242                                                 The first field is the attribute by which an outlier is defined.  The second is
10243                                                 a number that is compared to the attribute's 95th percentile.  The third is
10244                                                 optional, and is compared to the attribute's cnt aggregate.  Queries that pass
10245                                                 this specification are added to the report, regardless of any limits you
10246                                                 specified in L<"--limit">.
10247                                                 
10248                                                 For example, to report queries whose 95th percentile Query_time is at least 60
10249                                                 seconds and which are seen at least 5 times, use the following argument:
10250                                                 
10251                                                   --outliers Query_time:60:5
10252                                                 
10253                                                 You can specify an --outliers option for each value in L<"--group-by">.
10254                                                 
10255                                                 =item --password
10256                                                 
10257                                                 short form: -p; type: string
10258                                                 
10259                                                 Password to use when connecting.
10260                                                 
10261                                                 =item --pid
10262                                                 
10263                                                 type: string
10264                                                 
10265                                                 Create the given PID file when daemonized.  The file contains the process
10266                                                 ID of the daemonized instance.  The PID file is removed when the
10267                                                 daemonized instance exits.  The program checks for the existence of the
10268                                                 PID file when starting; if it exists and the process with the matching PID
10269                                                 exists, the program exits.
10270                                                 
10271                                                 =item --pipeline-profile
10272                                                 
10273                                                 Print a profile of the pipeline processes.
10274                                                 
10275                                                 =item --port
10276                                                 
10277                                                 short form: -P; type: int
10278                                                 
10279                                                 Port number to use for connection.
10280                                                 
10281                                                 =item --print
10282                                                 
10283                                                 Print log events to STDOUT in standard slow-query-log format.
10284                                                 
10285                                                 =item --print-iterations
10286                                                 
10287                                                 Print the start time for each L<"--iterations">.
10288                                                 
10289                                                 This option causes a line like the following to be printed at the start
10290                                                 of each L<"--iterations"> report:
10291                                                 
10292                                                   # Iteration 2 started at 2009-11-24T14:39:48.345780 
10293                                                 
10294                                                 This line will print even if C<--no-report> is specified.  If C<--iterations 0>
10295                                                 is specified, each iteration number will be C<0>.
10296                                                 
10297                                                 =item --processlist
10298                                                 
10299                                                 type: DSN
10300                                                 
10301                                                 Poll this DSN's processlist for queries, with L<"--interval"> sleep between.
10302                                                 
10303                                                 If the connection fails, mk-query-digest tries to reopen it once per second. See
10304                                                 also L<"--mirror">.
10305                                                 
10306                                                 =item --read-timeout
10307                                                 
10308                                                 type: time; default: 0
10309                                                 
10310                                                 Wait this long for an event from the input; 0 to wait forever.
10311                                                 
10312                                                 This option sets the maximum time to wait for an event from the input.  It
10313                                                 applies to all types of input except L<"--processlist">.  If an
10314                                                 event is not received after the specified time, the script stops reading the
10315                                                 input and prints its reports.  If L<"--iterations"> is 0 or greater than
10316                                                 1, the next iteration will begin, else the script will exit.
10317                                                 
10318                                                 This option requires the Perl POSIX module.
10319                                                 
10320                                                 =item --[no]report
10321                                                 
10322                                                 default: yes
10323                                                 
10324                                                 Print out reports on the aggregate results from L<"--group-by">.
10325                                                 
10326                                                 This is the standard slow-log analysis functionality.  See L<"OUTPUT"> for the
10327                                                 description of what this does and what the results look like.
10328                                                 
10329                                                 =item --report-all
10330                                                 
10331                                                 Include all queries, even if they have already been reviewed.
10332                                                 
10333                                                 =item --report-format
10334                                                 
10335                                                 type: Hash; default: rusage,header,query_report,profile,prepared
10336                                                 
10337                                                 Print these elements in the query analysis report.  Valid element names are
10338                                                 rusage, header, query_report, profile and prepared.  The rusage is information
10339                                                 about CPU times and memory usage.  The header is information about the entire
10340                                                 analysis run.  The query_report is detailed information on each query in the
10341                                                 report.  The profile is a compact table of queries for an at-a-glance view of
10342                                                 the report. Order does not matter; you cannot use this parameter to influence
10343                                                 the order of items in the report, only the presence or absence of items.
10344                                                 The prepared report listed prepared statements, the number of times each
10345                                                 was prepared and executed.  It only prints if there were prepared statements.
10346                                                 
10347                                                 See L<"OUTPUT"> for more information on the various parts of the query report.
10348                                                 
10349                                                 =item --review
10350                                                 
10351                                                 type: DSN
10352                                                 
10353                                                 Store a sample of each class of query in this DSN.
10354                                                 
10355                                                 The argument specifies a table to store all unique query fingerprints in.  The
10356                                                 table must have at least the following columns.  You can add more columns for
10357                                                 your own special purposes, but they won't be used by mk-query-digest.  The
10358                                                 following CREATE TABLE definition is also used for L<"--create-review-table">.
10359                                                 MAGIC_create_review:
10360                                                 
10361                                                   CREATE TABLE query_review (
10362                                                      checksum     BIGINT UNSIGNED NOT NULL PRIMARY KEY,
10363                                                      fingerprint  TEXT NOT NULL,
10364                                                      sample       TEXT NOT NULL,
10365                                                      first_seen   DATETIME,
10366                                                      last_seen    DATETIME,
10367                                                      reviewed_by  VARCHAR(20),
10368                                                      reviewed_on  DATETIME,
10369                                                      comments     TEXT
10370                                                   )
10371                                                 
10372                                                 The columns are as follows:
10373                                                 
10374                                                   COLUMN       MEANING
10375                                                   ===========  ===============
10376                                                   checksum     A 64-bit checksum of the query fingerprint
10377                                                   fingerprint  The abstracted version of the query; its primary key
10378                                                   sample       The query text of a sample of the class of queries
10379                                                   first_seen   The smallest timestamp of this class of queries
10380                                                   last_seen    The largest timestamp of this class of queries
10381                                                   reviewed_by  Initially NULL; if set, query is skipped thereafter
10382                                                   reviewed_on  Initially NULL; not assigned any special meaning
10383                                                   comments     Initially NULL; not assigned any special meaning
10384                                                 
10385                                                 Note that the C<fingerprint> column is the true primary key for a class of
10386                                                 queries.  The C<checksum> is just a cryptographic hash of this value, which
10387                                                 provides a shorter value that is very likely to also be unique.
10388                                                 
10389                                                 After parsing and aggregating events, your table should contain a row for each
10390                                                 fingerprint.  This option depends on C<--group-by fingerprint> (which is the
10391                                                 default).  It will not work otherwise.
10392                                                 
10393                                                 =item --review-history
10394                                                 
10395                                                 type: DSN
10396                                                 
10397                                                 The table in which to store historical values for review trend analysis.
10398                                                 
10399                                                 Each time you review queries with L<"--review">, mk-query-digest will save
10400                                                 information into this table so you can see how classes of queries have changed
10401                                                 over time.
10402                                                 
10403                                                 This DSN inherits unspecified values from L<"--review">.  It should mention a
10404                                                 table in which to store statistics about each class of queries.  mk-query-digest
10405                                                 verifies the existence of the table, and your privileges to insert, delete and
10406                                                 update on that table.
10407                                                 
10408                                                 mk-query-digest then inspects the columns in the table.  The table must have at
10409                                                 least the following columns:
10410                                                 
10411                                                   CREATE TABLE query_review_history (
10412                                                     checksum     BIGINT UNSIGNED NOT NULL,
10413                                                     sample       TEXT NOT NULL
10414                                                   );
10415                                                 
10416                                                 Any columns not mentioned above are inspected to see if they follow a certain
10417                                                 naming convention.  The column is special if the name ends with an underscore
10418                                                 followed by any of these MAGIC_history_cols values:
10419                                                 
10420                                                   pct|avt|cnt|sum|min|max|pct_95|stddev|median|rank
10421                                                 
10422                                                 If the column ends with one of those values, then the prefix is interpreted as
10423                                                 the event attribute to store in that column, and the suffix is interpreted as
10424                                                 the metric to be stored.  For example, a column named Query_time_min will be
10425                                                 used to store the minimum Query_time for the class of events.  The presence of
10426                                                 this column will also add Query_time to the L<"--select"> list.
10427                                                 
10428                                                 The table should also have a primary key, but that is up to you, depending on
10429                                                 how you want to store the historical data.  We suggest adding ts_min and ts_max
10430                                                 columns and making them part of the primary key along with the checksum.  But
10431                                                 you could also just add a ts_min column and make it a DATE type, so you'd get
10432                                                 one row per class of queries per day.
10433                                                 
10434                                                 The default table structure follows.  The following MAGIC_create_review_history
10435                                                 table definition is used for L<"--create-review-history-table">:
10436                                                 
10437                                                  CREATE TABLE query_review_history (
10438                                                    checksum             BIGINT UNSIGNED NOT NULL,
10439                                                    sample               TEXT NOT NULL,
10440                                                    ts_min               DATETIME,
10441                                                    ts_max               DATETIME,
10442                                                    ts_cnt               FLOAT,
10443                                                    Query_time_sum       FLOAT,
10444                                                    Query_time_min       FLOAT,
10445                                                    Query_time_max       FLOAT,
10446                                                    Query_time_pct_95    FLOAT,
10447                                                    Query_time_stddev    FLOAT,
10448                                                    Query_time_median    FLOAT,
10449                                                    Lock_time_sum        FLOAT,
10450                                                    Lock_time_min        FLOAT,
10451                                                    Lock_time_max        FLOAT,
10452                                                    Lock_time_pct_95     FLOAT,
10453                                                    Lock_time_stddev     FLOAT,
10454                                                    Lock_time_median     FLOAT,
10455                                                    Rows_sent_sum        FLOAT,
10456                                                    Rows_sent_min        FLOAT,
10457                                                    Rows_sent_max        FLOAT,
10458                                                    Rows_sent_pct_95     FLOAT,
10459                                                    Rows_sent_stddev     FLOAT,
10460                                                    Rows_sent_median     FLOAT,
10461                                                    Rows_examined_sum    FLOAT,
10462                                                    Rows_examined_min    FLOAT,
10463                                                    Rows_examined_max    FLOAT,
10464                                                    Rows_examined_pct_95 FLOAT,
10465                                                    Rows_examined_stddev FLOAT,
10466                                                    Rows_examined_median FLOAT,
10467                                                    PRIMARY KEY(checksum, ts_min, ts_max)
10468                                                  );
10469                                                 
10470                                                 Note that we store the count (cnt) for the ts attribute only; it will be
10471                                                 redundant to store this for other attributes.
10472                                                 
10473                                                 =item --run-time
10474                                                 
10475                                                 type: time
10476                                                 
10477                                                 How long to run before exiting.  The default is to run forever (you can
10478                                                 interrupt with CTRL-C).  See also L<"--iterations">.
10479                                                 
10480                                                 =item --sample
10481                                                 
10482                                                 type: int
10483                                                 
10484                                                 Filter out all but the first N occurrences of each query.  The queries are
10485                                                 filtered on the first value in L<"--group-by">, so by default, this will filter
10486                                                 by query fingerprint.  For example, C<--sample 2> will permit two sample queries
10487                                                 for each fingerprint.  Useful in conjunction with L<"--print"> to print out the
10488                                                 queries.  You probably want to set C<--no-report> to avoid the overhead of
10489                                                 aggregating and reporting if you're just using this to print out samples of
10490                                                 queries.  A complete example:
10491                                                 
10492                                                   mk-query-digest --sample 2 --no-report --print slow.log
10493                                                 
10494                                                 =item --select
10495                                                 
10496                                                 type: Array
10497                                                 
10498                                                 Compute aggregate statistics for these attributes.
10499                                                 
10500                                                 By default mk-query-digest auto-detects, aggregates and prints metrics for
10501                                                 every query attribute that it finds in the slow query log.  This option
10502                                                 specifies a list of only the attributes that you want.  You can specify an
10503                                                 alternative attribute with a colon.  For example, C<db:Schema> uses db if it's
10504                                                 available, and Schema if it's not.
10505                                                 
10506                                                 Previously, mk-query-digest only aggregated these attributes:
10507                                                 
10508                                                   Query_time,Lock_time,Rows_sent,Rows_examined,user,db:Schema,ts
10509                                                 
10510                                                 Attributes specified in the L<"--review-history"> table will always be selected 
10511                                                 even if you do not specify L<"--select">.
10512                                                 
10513                                                 See also L<"--ignore-attributes"> and L<"ATTRIBUTES">.
10514                                                 
10515                                                 =item --set-vars
10516                                                 
10517                                                 type: string; default: wait_timeout=10000
10518                                                 
10519                                                 Set these MySQL variables.  Immediately after connecting to MySQL, this
10520                                                 string will be appended to SET and executed.
10521                                                 
10522                                                 =item --shorten
10523                                                 
10524                                                 type: int; default: 1024
10525                                                 
10526                                                 Shorten long statements in reports.
10527                                                 
10528                                                 Shortens long statements, replacing the omitted portion with a C</*... omitted
10529                                                 ...*/> comment.  This applies only to the output in reports, not to information
10530                                                 stored for L<"--review"> or other places.  It prevents a large statement from
10531                                                 causing difficulty in a report.  The argument is the preferred length of the
10532                                                 shortened statement.  Not all statements can be shortened, but very large INSERT
10533                                                 and similar statements often can; and so can IN() lists, although only the first
10534                                                 such list in the statement will be shortened.
10535                                                 
10536                                                 If it shortens something beyond recognition, you can find the original statement
10537                                                 in the log, at the offset shown in the report header (see L<"OUTPUT">).
10538                                                 
10539                                                 =item --since
10540                                                 
10541                                                 type: string
10542                                                 
10543                                                 Parse only queries newer than this value (parse queries since this date).
10544                                                 
10545                                                 This option allows you to ignore queries older than a certain value and parse
10546                                                 only those queries which are more recent than the value.  The value can be
10547                                                 several types:
10548                                                 
10549                                                   * Simple time value N with optional suffix: N[shmd], where
10550                                                     s=seconds, h=hours, m=minutes, d=days (default s if no suffix
10551                                                     given); this is like saying "since N[shmd] ago"
10552                                                   * Full date with optional hours:minutes:seconds: YYYY-MM-DD [HH:MM::SS]
10553                                                   * Short, MySQL-style date: YYMMDD [HH:MM:SS]
10554                                                   * Any time expression evaluated by MySQL: C<CURRENT_DATE - INTERVAL 7 DAY>
10555                                                 
10556                                                 If you give a MySQL time expression, then you must also specifiy a DSN
10557                                                 so that mk-query-digest can connect to MySQL to evalue the expression.  If you
10558                                                 specify L<"--execute">, L<"--explain">, L<"--processlist">, L<"--review">
10559                                                 or L<"--review-history">, then one of these DSNs will be used automatically.
10560                                                 Otherwise, you must specify an L<"--aux-dsn"> or mk-query-digest will die
10561                                                 saying that the value is invalid.
10562                                                 
10563                                                 The MySQL time expression is warpped inside a query like
10564                                                 "SELECT UNIX_TIMESTAMP(<expression>)", so be sure that the expression is
10565                                                 valid inside this query.  For example, do not use UNIX_TIMESTAMP() because
10566                                                 UNIX_TIMESTAMP(UNIX_TIMESTAMP()) returns 0.
10567                                                 
10568                                                 Events are assumed to be in chronological--older events at the beginning of
10569                                                 the log and newer events at the end of the log.  L<"--since"> is strict: it
10570                                                 ignores all queries until one is found that is new enough.  Therefore, if
10571                                                 the query events are not consistently timestamped, some may be ignored which
10572                                                 are actually new enough.
10573                                                 
10574                                                 See also L<"--until">.
10575                                                 
10576                                                 =item --socket
10577                                                 
10578                                                 short form: -S; type: string
10579                                                 
10580                                                 Socket file to use for connection.
10581                                                 
10582                                                 =item --statistics
10583                                                 
10584                                                 Print statistics.
10585                                                 
10586                                                 =item --table-access
10587                                                 
10588                                                 Print a table access report.
10589                                                 
10590                                                 The table access report shows which tables are accessed by all the queries
10591                                                 and if the access is a read or write.  The report looks like:
10592                                                 
10593                                                   write `baz`.`tbl`
10594                                                   read `baz`.`new_tbl`
10595                                                   write `baz`.`tbl3`
10596                                                   write `db6`.`tbl6`
10597                                                 
10598                                                 If you pipe the output to L<sort>, the read and write tables will be grouped
10599                                                 together and sorted alphabetically:
10600                                                 
10601                                                   read `baz`.`new_tbl`
10602                                                   write `baz`.`tbl`
10603                                                   write `baz`.`tbl3`
10604                                                   write `db6`.`tbl6`
10605                                                 
10606                                                 =item --tcpdump-errors
10607                                                 
10608                                                 type: string
10609                                                 
10610                                                 Write the tcpdump data to this file on error.  If mk-query-digest doesn't
10611                                                 parse the stream correctly for some reason, the session's packets since the
10612                                                 last query event will be written out to create a usable test case.  If this
10613                                                 happens, mk-query-digest will not raise an error; it will just discard the
10614                                                 session's saved state and permit the tool to continue working.  See L<"tcpdump">
10615                                                 for more information about parsing tcpdump output.
10616                                                 
10617                                                 =item --timeline
10618                                                 
10619                                                 Show a timeline of events.
10620                                                 
10621                                                 This option makes mk-query-digest print another kind of report: a timeline of
10622                                                 the events.  Each query is still grouped and aggregate into classes according to
10623                                                 L<"--group-by">, but then they are printed in chronological order.  The timeline
10624                                                 report prints out the timestamp, interval, count and value of each classes.
10625                                                 
10626                                                 If all you want is the timeline report, then specifiy C<--no-report> to
10627                                                 suppress the default query analysis report.  Otherwise, the timeline report
10628                                                 will be printed at the end before the response-time profile
10629                                                 (see L<"--report-format"> and L<"OUTPUT">).
10630                                                 
10631                                                 For example, this:
10632                                                 
10633                                                   mk-query-digest /path/to/log --group-by distill --timeline
10634                                                 
10635                                                 will print something like:
10636                                                 
10637                                                   # ########################################################################
10638                                                   # distill report
10639                                                   # ########################################################################
10640                                                   # 2009-07-25 11:19:27 1+00:00:01   2 SELECT foo
10641                                                   # 2009-07-27 11:19:30      00:01   2 SELECT bar
10642                                                   # 2009-07-27 11:30:00 1+06:30:00   2 SELECT foo
10643                                                 
10644                                                 =item --type
10645                                                 
10646                                                 type: Array
10647                                                 
10648                                                 The type of input to parse (default slowlog).  The permitted types are
10649                                                 
10650                                                 =over
10651                                                 
10652                                                 =item binlog
10653                                                 
10654                                                 Parse a binary log file.
10655                                                 
10656                                                 =item genlog
10657                                                 
10658                                                 Parse a MySQL general log file.  General logs lack a lot of L<"ATTRIBUTES">,
10659                                                 notably C<Query_time>.  The default L<"--order-by"> for general logs
10660                                                 changes to C<Query_time:cnt>.
10661                                                 
10662                                                 =item http
10663                                                 
10664                                                 Parse HTTP traffic from tcpdump.
10665                                                 
10666                                                 =item slowlog
10667                                                 
10668                                                 Parse a log file in any variation of MySQL slow-log format.
10669                                                 
10670                                                 =item tcpdump
10671                                                 
10672                                                 Inspect network packets and decode the MySQL client protocol, extracting queries
10673                                                 and responses from it.
10674                                                 
10675                                                 mk-query-digest does not actually watch the network (i.e. it does NOT "sniff
10676                                                 packets").  Instead, it's just parsing the output of tcpdump.  You are
10677                                                 responsible for generating this output; mk-query-digest does not do it for you.
10678                                                 Then you send this to mk-query-digest as you would any log file: as files on the
10679                                                 command line or to STDIN.
10680                                                 
10681                                                 The parser expects the input to be formatted with the following options: C<-x -n
10682                                                 -q -tttt>.  For example, if you want to capture output from your local machine,
10683                                                 you can do something like
10684                                                 
10685                                                   tcpdump -i eth0 port 3306 -s 65535 -c 1000 -x -n -q -tttt > mysql.tcp.txt
10686                                                   mk-query-digest --type tcpdump mysql.tcp.txt
10687                                                 
10688                                                 The other tcpdump parameters, such as -s, -c, and -i, are up to you.  Just make
10689                                                 sure the output looks like this:
10690                                                 
10691                                                   2009-04-12 09:50:16.804849 IP 127.0.0.1.42167 > 127.0.0.1.3306: tcp 37
10692                                                       0x0000:  4508 0059 6eb2 4000 4006 cde2 7f00 0001
10693                                                       0x0010:  ....
10694                                                 
10695                                                 Remember tcpdump has a handy -c option to stop after it captures some number of
10696                                                 packets!  That's very useful for testing your tcpdump command.  Note that
10697                                                 tcpdump can't capture traffic on a Unix socket.  Read
10698                                                 L<http://bugs.mysql.com/bug.php?id=31577> if you're confused about this.
10699                                                 
10700                                                 All MySQL servers running on port 3306 are automatically detected in the
10701                                                 tcpdump output.  Therefore, if the tcpdump out contains packets from
10702                                                 multiple servers on port 3306 (for example, 10.0.0.1:3306, 10.0.0.2:3306,
10703                                                 etc.), all packets/queries from all these servers will be analyzed
10704                                                 together as if they were one server.
10705                                                 
10706                                                 If you're analyzing traffic for a MySQL server that is not running on port
10707                                                 3306, see L<"--watch-server">.
10708                                                 
10709                                                 Also note that mk-query-digest may fail to report the database for queries
10710                                                 when parsing tcpdump output.  The database is discovered only in the initial
10711                                                 connect events for a new client or when <USE db> is executed.  If the tcpdump
10712                                                 output contains neither of these, then mk-query-digest cannot discover the
10713                                                 database.
10714                                                 
10715                                                 The MySQL client protocol implementation is not complete; server-side prepared
10716                                                 statements are not yet supported, and naturally, SSL-encrypted traffic cannot be
10717                                                 inspected and decoded.
10718                                                 
10719                                                 =item memcached
10720                                                 
10721                                                 Similar to tcpdump, but the expected input is memcached packets
10722                                                 instead of MySQL packets.  For example:
10723                                                 
10724                                                   tcpdump -i eth0 port 11211 -s 65535 -x -n -q -tttt > memcached.tcp.txt
10725                                                   mk-query-digest --type memcached memcached.tcp.txt
10726                                                 
10727                                                 memcached uses port 11211 by default.
10728                                                 
10729                                                 =back
10730                                                 
10731                                                 =item --until
10732                                                 
10733                                                 type: string
10734                                                 
10735                                                 Parse only queries older than this value (parse queries until this date).
10736                                                 
10737                                                 This option allows you to ignore queries newer than a certain value and parse
10738                                                 only those queries which are older than the value.  The value can be one of
10739                                                 the same types listed for L<"--since">.
10740                                                 
10741                                                 Unlike L<"--since">, L<"--until"> is not strict: all queries are parsed until
10742                                                 one has a timestamp that is equal to or greater than L<"--until">.  Then
10743                                                 all subsequent queries are ignored.
10744                                                 
10745                                                 =item --user
10746                                                 
10747                                                 short form: -u; type: string
10748                                                 
10749                                                 User for login if not current user.
10750                                                 
10751                                                 =item --version
10752                                                 
10753                                                 Show version and exit.
10754                                                 
10755                                                 =item --watch-server
10756                                                 
10757                                                 type: string
10758                                                 
10759                                                 This option tells mk-query-digest which server IP address and port (like
10760                                                 "10.0.0.1:3306") to watch when parsing tcpdump (for L<"--type"> tcpdump and
10761                                                 memcached); all other servers are ignored.  If you don't specify it,
10762                                                 mk-query-digest watches all servers by looking for any IP address using port
10763                                                 3306 or "mysql".  If you're watching a server with a non-standard port, this
10764                                                 won't work, so you must specify the IP address and port to watch.
10765                                                 
10766                                                 If you want to watch a mix of servers, some running on standard port 3306
10767                                                 and some running on non-standard ports, you need to create separate
10768                                                 tcpdump outputs for the non-stanard port servers and then specify this
10769                                                 option for each.  At present mk-query-digest cannot auto-detect servers on
10770                                                 port 3306 and also be told to watch a server on a non-standard port.
10771                                                 
10772                                                 =item --[no]zero-admin
10773                                                 
10774                                                 default: yes
10775                                                 
10776                                                 Zero out the Rows_XXX properties for administrator command events.
10777                                                 
10778                                                 =item --zero-bool
10779                                                 
10780                                                 Print 0% boolean values in report.
10781                                                 
10782                                                 =back
10783                                                 
10784                                                 =head1 DOWNLOADING
10785                                                 
10786                                                 You can download Maatkit from Google Code at
10787                                                 L<http://code.google.com/p/maatkit/>, or you can get any of the tools
10788                                                 easily with a command like the following:
10789                                                 
10790                                                    wget http://www.maatkit.org/get/toolname
10791                                                    or
10792                                                    wget http://www.maatkit.org/trunk/toolname
10793                                                 
10794                                                 Where C<toolname> can be replaced with the name (or fragment of a name) of any
10795                                                 of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
10796                                                 needed.  The first URL gets the latest released version of the tool, and the
10797                                                 second gets the latest trunk code from Subversion.
10798                                                 
10799                                                 =head1 ENVIRONMENT
10800                                                 
10801                                                 The environment variable C<MKDEBUG> enables verbose debugging output in all of
10802                                                 the Maatkit tools:
10803                                                 
10804                                                    MKDEBUG=1 mk-....
10805                                                 
10806                                                 =head1 SYSTEM REQUIREMENTS
10807                                                 
10808                                                 You need Perl and some core packages that ought to be installed in any
10809                                                 reasonably new version of Perl.
10810                                                 
10811                                                 =head1 BUGS
10812                                                 
10813                                                 For list of known bugs see L<http://www.maatkit.org/bugs/mk-query-digest>.
10814                                                 
10815                                                 Please use Google Code Issues and Groups to report bugs or request support:
10816                                                 L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
10817                                                 discuss Maatkit.
10818                                                 
10819                                                 Please include the complete command-line used to reproduce the problem you are
10820                                                 seeing, the version of all MySQL servers involved, the complete output of the
10821                                                 tool when run with L<"--version">, and if possible, debugging output produced by
10822                                                 running with the C<MKDEBUG=1> environment variable.
10823                                                 
10824                                                 =head1 COPYRIGHT, LICENSE AND WARRANTY
10825                                                 
10826                                                 This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
10827                                                 Feedback and improvements are welcome.
10828                                                 
10829                                                 THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
10830                                                 WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
10831                                                 MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
10832                                                 
10833                                                 This program is free software; you can redistribute it and/or modify it under
10834                                                 the terms of the GNU General Public License as published by the Free Software
10835                                                 Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
10836                                                 systems, you can issue `man perlgpl' or `man perlartistic' to read these
10837                                                 licenses.
10838                                                 
10839                                                 You should have received a copy of the GNU General Public License along with
10840                                                 this program; if not, write to the Free Software Foundation, Inc., 59 Temple
10841                                                 Place, Suite 330, Boston, MA  02111-1307  USA.
10842                                                 
10843                                                 =head1 AUTHOR
10844                                                 
10845                                                 Baron Schwartz, Daniel Nichter
10846                                                 
10847                                                 =head1 ABOUT MAATKIT
10848                                                 
10849                                                 This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
10850                                                 was created by Baron Schwartz; Baron and Daniel Nichter are the primary
10851                                                 code contributors.  Both are employed by Percona.  Financial support for
10852                                                 Maatkit development is primarily provided by Percona and its clients. 
10853                                                 
10854                                                 =head1 VERSION
10855                                                 
10856                                                 This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5725 $.
10857                                                 
10858                                                 =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
101          100     45     26   if (@_ > 2)
110          100      5      7   if (not $dsn)
122   ***     50     29      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
134   ***     50      0     61   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
140          100     32     29   if (not defined $final_props{$key})
147   ***     50      0     29   unless exists $opts{$key}
150   ***     50      0      7   if (my $required = $self->prop('required'))
152   ***      0      0      0   unless $final_props{$key}
161   ***     50      0      5   unless ref $o eq 'OptionParser'
164          100     35     10   if $o->has($_)
174   ***      0      0      0   unless ref $dsn
175   ***      0      0      0   $_ eq 'p' ? :
176   ***      0      0      0   if defined $$dsn{$_}
189   ***      0      0      0   $opts{$key}{'copy'} ? :
203   ***     50      0      7   if ($driver eq 'Pg') { }
235   ***     50      0      7   $cxn_string =~ /charset=utf8/ ? :
244   ***     50      0      7   if (not $have_dbi)
263   ***     50      7      0   if ($cxn_string =~ /mysql/i)
271   ***     50      0      7   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
276   ***      0      0      0   if ($charset eq 'utf8') { }
277   ***      0      0      0   unless binmode STDOUT, ':utf8'
281   ***      0      0      0   unless binmode STDOUT
285          100      5      2   if ($self->prop('set-vars'))
292   ***     50      0      7   if (not $dbh and $EVAL_ERROR)
294   ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
307   ***      0      0      0   if (not $tries)
329   ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
346   ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
356   ***      0      0      0   unless $dsn_1
357   ***      0      0      0   unless $dsn_2
361   ***      0      0      0   if ($args{'overwrite'}) { }
362   ***      0      0      0   defined $$dsn_1{$key} ? :
365   ***      0      0      0   defined $$dsn_2{$key} ? :
374   ***      0      0      0   defined $_ ? :
414   ***      0      0      0   unless defined $val
415   ***      0      0      0   if $val eq ''
417   ***      0      0      0   if (not defined $is_numeric)
418   ***      0      0      0   $val =~ /^0|\D/ ? :
421   ***      0      0      0   if $is_numeric
431          100     40     39   if (not $tbl)
440   ***      0      0      0   unless $like
479   ***     50      0     45   unless $args{$arg}
485   ***     50     45      0   exists $args{'strict'} ? :
528   ***     50      0     45   unless open my $fh, '<', $file
548          100  54405     45   unless $para =~ /^=head1 OPTIONS/
553          100     45     45   if $para =~ /^=over/
561   ***     50      0     45   unless $para
564          100   2835     45   if (my($option) = $para =~ /^=item --(.*)/)
571          100   2160    675   if ($para =~ /: /) { }
575   ***     50      0   3195   unless $attributes{$attrib}
579          100    315   1845   if ($attribs{'short form'})
595   ***     50      0   2835   if $para =~ /^=item/
597          100    180   2655   if (my($base_option) = $option =~ /^\[no\](.*)/)
602          100    315   2520   $attribs{'short form'} ? :
             100    180   2655   $attribs{'negatable'} ? :
      ***     50      0   2835   $attribs{'cumulative'} ? :
             100   1980    855   $attribs{'type'} ? :
             100    855   1980   $attribs{'default'} ? :
      ***     50      0   2835   $attribs{'group'} ? :
614   ***     50      0  10530   unless $para
617          100     45  10485   if ($para =~ /^=head1/)
621          100   2835   7650   if $para =~ /^=item --/
625   ***     50      0     45   unless @specs
636          100   2835     45   if (ref $opt) { }
641   ***     50      0   2835   if (not $long)
646   ***     50      0   2835   if exists $$self{'opts'}{$long}
649   ***     50      0   2835   if (length $long == 1)
654          100    315   2520   if ($short) { }
655   ***     50      0    315   if exists $$self{'short_opts'}{$short}
664          100    180   2655   $$opt{'spec'} =~ /!/ ? :
665   ***     50      0   2835   $$opt{'spec'} =~ /\+/ ? :
666   ***     50      0   2835   $$opt{'desc'} =~ /required/ ? :
678   ***     50      0   2835   if ($type and $type eq 'd' and not $$self{'dp'})
683          100    990   1845   if $type and $type =~ /[HhAadzm]/
685          100    900   1935   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
686   ***     50    900      0   defined $def ? :
690          100     45   2790   if ($long eq 'config')
694   ***     50      0   2835   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
707   ***     50      0     45   if ($opt =~ /mutually exclusive|one and only one/)
712   ***     50      0     45   if ($opt =~ /at least one|one and only one/)
717   ***     50     45      0   if ($opt =~ /default to/)
722   ***     50      0     45   if ($opt =~ /restricted to option groups/)
732   ***     50      0     45   unless $rule_ok
749   ***     50      0     90   unless exists $$self{'opts'}{$long}
773   ***      0      0      0   unless exists $$self{'opts'}{$long}
793   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50    133      0   exists $$self{'opts'}{$opt} ? :
798   ***     50      0    133   if ($$opt{'is_cumulative'}) { }
813   ***     50      0   1890   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100    945   1890   exists $$self{'defaults'}{$long} ? :
822   ***     50      0     45   if (@ARGV and $ARGV[0] eq '--config')
826   ***     50     45      0   if ($self->has('config'))
832   ***     50    180      0   if ($EVAL_ERROR)
833   ***     50      0    180   $self->got('config') ? :
848   ***     50      0     45   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
851   ***     50      0     45   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
852   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
858   ***     50      0     45   if (@ARGV and $$self{'strict'})
864   ***      0      0      0   if (@set > 1)
875   ***      0      0      0   if (@set == 0)
885          100    123   2712   if ($$opt{'got'}) { }
      ***     50      0   2712   elsif ($$opt{'is_required'}) { }
886   ***     50      0    123   if (exists $$self{'disables'}{$long})
893   ***     50      0    123   if (exists $$self{'allowed_groups'}{$long})
905   ***      0      0      0   if $restricted_opt eq $long
906   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
911   ***      0      0      0   if (@restricted_opts)
913   ***      0      0      0   if (@restricted_opts == 1) { }
942          100    855   1980   unless $opt and $$opt{'type'}
945   ***     50      0   1980   if ($val and $$opt{'type'} eq 'm') { }
             100      5   1975   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0   1975   elsif ($val and $$opt{'type'} eq 'z') { }
             100     45   1930   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100    496   1434   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
948   ***      0      0      0   if (not $suffix)
954   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
955   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
970   ***     50      0      5   if ($from_key)
981   ***      0      0      0   if (defined $num) { }
982   ***      0      0      0   if ($factor)
1009         100     35   3580   length $opt == 1 ? :
1010  ***     50      0   3615   unless $long and exists $$self{'opts'}{$long}
1017  ***     50      0    226   length $opt == 1 ? :
1018  ***     50      0    226   unless $long and exists $$self{'opts'}{$long}
1025         100     45     45   length $opt == 1 ? :
1026         100     80     10   defined $long ? :
1031  ***     50      0     45   length $opt == 1 ? :
1032  ***     50      0     45   unless $long and exists $$self{'opts'}{$long}
1059  ***      0      0      0   unless $ENV{'DONT_BREAK_LINES'}
1067  ***     50      0     45   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0     45   elsif (scalar @{$$self{'errors'};}) { }
1068  ***      0      0      0   unless print $self->print_usage
1072  ***      0      0      0   unless print $self->print_errors
1081  ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
1090  ***      0      0      0   unless $$self{'got_opts'}
1093  ***      0      0      0   $$_{'is_negatable'} ? :
1097  ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
1113  ***      0      0      0   $group eq 'default' ? :
1119  ***      0      0      0   $$opt{'is_negatable'} ? :
1122  ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
1131  ***      0      0      0   if ($short) { }
1140  ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
1144  ***      0      0      0   if ($$self{'dp'})
1152  ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
1164  ***      0      0      0   if ref $_[0] eq 'OptionParser'
1167  ***      0      0      0   unless print $prompt
1175  ***      0      0      0   unless print "\n"
1178  ***      0      0      0   if ($EVAL_ERROR)
1200  ***     50    180      0   unless open my $fh, '<', $filename
1208  ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
1211  ***      0      0      0   if ($line eq '--')
1216  ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
1234  ***      0      0      0   unless open my $fh, '<', $file
1238  ***      0      0      0   unless $para =~ /^=pod$/m
1242  ***      0      0      0   unless $para =~ /$regex/
1247  ***      0      0      0   unless close $fh
1261  ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
1276  ***      0      0      0   defined $_ ? :
1324  ***     50      0   1169   defined $args{'p_ms'} ? :
1325  ***     50      0   1169   defined $args{'p_s'} ? :
1328         100      6   1163   if $t < 0
1330         100     91   1078   if $t =~ /e/
1334         100    333    836   if ($t > 0 and $t <= 0.000999) { }
             100    191    645   elsif ($t >= 0.001 and $t <= 0.999999) { }
             100    181    464   elsif ($t >= 1) { }
1355  ***     50      0    633   $p ? :
1362  ***      0      0      0   unless $secs
1364  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
1369  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
1388         100     14   3051   defined $args{'p'} ? :
1389         100    216   2849   defined $args{'d'} ? :
1396         100    293   2772   $num =~ /\./ || $n ? :
1405  ***      0      0      0   $gmt ? :
1411  ***      0      0      0   if (my($us) = $time =~ /(\.\d+)$/)
1421  ***     50    206      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^$mysql_ts$/)
1424         100     18    188   defined $f ? :
             100     18    188   defined $f ? :
1433  ***     50     30      0   if (my($y, $m, $d, $h, $i, $s, $us) = $val =~ /^$proper_ts$/)
1434  ***     50      0     30   $gmt ? :
1437         100      4     26   if (defined $us)
1449  ***      0      0      0   if (my($n, $suffix) = $val =~ /^$n_ts$/) { }
      ***      0      0      0   elsif (my($ymd, $hms) = $val =~ /^(\d{6})(?:\s+(\d+:\d+:\d+))?/) { }
      ***      0      0      0   elsif (($ymd, $hms) = $val =~ /^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) { }
1450  ***      0      0      0   $suffix eq 'd' ? :
      ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1460  ***      0      0      0   unless $hms
1465  ***      0      0      0   unless $hms
1470  ***      0      0      0   if $callback and ref $callback eq 'CODE'
1486  ***      0      0      0   defined $_ ? :
1538  ***     50      0     98   unless $query
1541  ***     50      0     98   if ($query =~ /$vlc_rf/i)
1558         100     77      2   unless $query =~ /IN\s*\(\s*(?!select)/i
1584  ***      0      0      0   unless @vals > 20
1596  ***     50      0    317   if $query =~ m[\ASELECT /\*!40001 SQL_NO_CACHE \*/ \* FROM `]
1598  ***     50      0    317   if $query =~ m[/\*\w+\.\w+:[0-9]/[0-9]\*/]
1600         100     11    306   if $query =~ /\A# administrator command: /
1602  ***     50      0    306   if $query =~ /\A\s*(call\s+\S+)\(/i
1604         100      8    298   if (my($beginning) = $query =~ /\A((?:INSERT|REPLACE)(?: IGNORE)?\s+INTO.+?VALUES\s*\(.*?\))\s*,\s*\(/is)
1610  ***     50      0    306   if $query =~ s/\Ause \S+\Z/use ?/i
1638  ***     50      0    103   if $query =~ /\A\s*call\s+(\S+)\(/i
1639  ***     50      0    103   if $query =~ /\A\s*use\s+/
1640  ***     50      0    103   if $query =~ /\A\s*UNLOCK TABLES/i
1641  ***     50      0    103   if $query =~ /\A\s*xa\s+(\S+)/i
1643         100      5     98   if ($query =~ /\A# administrator command:/)
1651         100      4     94   if ($query =~ /\A\s*SHOW\s+/i)
1669         100      2     92   if ($dds)
1671  ***     50      2      0   if $obj
1676  ***     50      2      0   $obj ? :
1693  ***     50      0     94   unless $qp
1701         100      2     92   if $table
1714  ***     50      0     98   if ($args{'generic'}) { }
1716  ***      0      0      0   unless $cmd
1717  ***      0      0      0   $arg ? :
1722         100      4     94   if ($verbs and $verbs =~ /^SHOW/) { }
1737  ***     50      0     98   if ($args{'trf'})
1746  ***     50      0     41   unless $query
1765         100     27     14   unless $query =~ s/
                 \A.*?
                 update\s+(.*?)
                 \s+set\b(.*?)
                 (?:\s*where\b(.*?))?
                 (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
                 \Z
              /__update_to_select($1, $2, $3, $4);/eisx or $query =~ s/
                    \A.*?
                    (?:insert|replace)\s+
                    .*?\binto\b(.*?)\(([^\)]+)\)\s*
                    values?\s*(\(.*?\))\s*
                    (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
                    \Z
                 /__insert_to_select($1, $2, $3);/eisx
1779  ***      0      0      0   $1 =~ /\*/ ? :
1788  ***     50      0      1   if ($join =~ /\bjoin\b/)
1802  ***      0      0      0   if (@cols == @vals) { }
1813         100      8      6   $where ? :
      ***     50      0     14   $limit ? :
1820  ***      0      0      0   unless $query
1821  ***      0      0      0   $query =~ /\A\s*select/i ? :
1828  ***      0      0      0   defined $_ ? :
1884  ***      0      0      0   unless $args{$arg}
1889  ***      0      0      0   unless $code
1892  ***      0      0      0   if ($$self{'curr_rows'}) { }
1898  ***      0      0      0   if ($rows and scalar @$rows) { }
1915  ***      0      0      0   if (not $curr and @curr)
1919  ***      0      0      0   if (not $prev and @prev)
1923  ***      0      0      0   if ($curr or $prev)
1924  ***      0      0      0   if ($curr and $prev and $$curr[0] == $$prev[0]) { }
      ***      0      0      0   elsif (not $curr or $curr and $prev and $$curr[0] > $$prev[0]) { }
1926  ***      0      0      0   $$curr[5] =~ /\D/ ? :
1928  ***      0      0      0   if ($$prev[7])
1929  ***      0      0      0   if (not $$curr[7] or $$prev[7] ne $$curr[7]) { }
      ***      0      0      0   elsif (defined $$curr[5] and $$curr[5] < $$prev[5]) { }
      ***      0      0      0   elsif ($$curr[7] and defined $$curr[5] and $$misc{'time'} - $$curr[5] - $$prev[8] - $$prev[9] - $$misc{'etime'} > $fudge) { }
1944  ***      0      0      0   if ($is_new)
1948  ***      0      0      0   if ($$curr[7])
1949  ***      0      0      0   if ($$prev[7] and not $is_new) { }
1970  ***      0      0      0   if ($$curr[7] and defined $$curr[5])
1982  ***      0      0      0   scalar @curr ? :
1991  ***      0      0      0   if ($$row[5] < $time - $$row[10])
2025  ***      0      0      0   if ($find_spec{'busy_time'} and ($$query{'Command'} || '') eq 'Query')
2026  ***      0      0      0   if ($$query{'Time'} < $find_spec{'busy_time'})
2034  ***      0      0      0   if ($find_spec{'idle_time'} and ($$query{'Command'} || '') eq 'Sleep')
2035  ***      0      0      0   if ($$query{'Time'} < $find_spec{'idle_time'})
2046  ***      0      0      0   if (defined $find_spec{'ignore'}{$property} and $self->$filter($query, $find_spec{'ignore'}{$property}))
2051  ***      0      0      0   if (defined $find_spec{'match'}{$property})
2052  ***      0      0      0   if (not $self->$filter($query, $find_spec{'match'}{$property}))
2060  ***      0      0      0   if ($matched)
2068  ***      0      0      0   if (@matches and $find_spec{'only_oldest'})
2120  ***      0      0      0   defined $_ ? :
2157  ***     50      0     76   unless $args{$arg}
2165  ***     50      0     35   if $raw_packet =~ /^$/
2166         100     32      3   if $pos_in_log
2169         100     32      3   unless $raw_packet =~ /\A20/
2178  ***     50      3      0   if $args{'oktorun'}
2184  ***     50      0     35   unless $packet
2198  ***     50     35      0   length $data == 2 * $ip_plen ? :
2209         100     18      1   length $data > 10 ? :
             100     19     16   $data ? :
2235  ***     50      0     70   unless $port
2236         100     24     46   $port eq 'mysql' ? :
      ***     50      0     70   $port eq 'http' ? :
      ***     50      0     70   $port eq 'memcached' ? :
2244  ***      0      0      0   defined $_ ? :
2453  ***     50      0      3   $args{'server'} ? :
2473  ***     50      0     35   unless $args{$arg}
2480  ***     50      0     35   if (my $server = $$self{'server'})
2481  ***      0      0      0   if ($src_host ne $server and $dst_host ne $server)
2489         100     18     17   if ($src_host =~ /:$$self{'server_port'}$/) { }
      ***     50     17      0   elsif ($dst_host =~ /:$$self{'server_port'}$/) { }
2504         100     19     16   if ($$packet{'data_len'} >= 5)
2507         100      9     26   if (not exists $$self{'sessions'}{$client})
2508         100      2      7   if ($$packet{'syn'}) { }
             100      1      6   elsif ($packetno == 0) { }
2537  ***     50      0     29   if ($$packet{'syn'} and $$session{'n_queries'} > 0 || $$session{'state'})
2544         100     10     19   if ($$packet{'data_len'} == 0)
2550  ***     50      0     19   if ($$session{'compress'})
2551  ***      0      0      0   unless $self->uncompress_packet($packet, $session)
2554  ***     50      0     19   if ($$session{'buff'} and $packet_from eq 'client') { }
2569  ***     50      0     19   if ($EVAL_ERROR)
2578         100     10      9   if ($packet_from eq 'server') { }
      ***     50      9      0   elsif ($packet_from eq 'client') { }
2582  ***     50      0      9   if ($$session{'buff'}) { }
      ***     50      0      9   elsif ($$packet{'mysql_data_len'} > $$packet{'data_len'} - 4) { }
2583  ***      0      0      0   if ($$session{'buff_left'} <= 0) { }
2593  ***      0      0      0   if ($$session{'cmd'} and ($$session{'state'} || '') eq 'awaiting_reply')
2612  ***     50      0      9   if ($$session{'cmd'} and ($$session{'state'} || '') eq 'awaiting_reply')
2626         100      2     17   if ($$session{'closed'})
2636  ***     50      0     10   unless $packet
2637  ***     50      0     10   unless $session
2641  ***     50      0     10   if (($$session{'server_seq'} || '') eq $$packet{'seq'})
2653  ***     50      0     10   if (not $first_byte)
2658         100      2      8   if (not $$session{'state'}) { }
2659  ***     50      2      0   if ($first_byte eq '0a' and length $data >= 33 and $data =~ /00{13}/) { }
      ***      0      0      0   elsif ($$session{'buff'}) { }
2661  ***     50      0      2   if (not $handshake)
2668  ***     50      0      2   unless $$session{'ts'}
2681         100      1      7   if ($first_byte eq '00') { }
             100      1      6   elsif ($first_byte eq 'ff') { }
      ***     50      0      6   elsif ($first_byte eq 'fe' and $$packet{'mysql_data_len'} < 9) { }
2682  ***     50      1      0   if (($$session{'state'} || '') eq 'client_auth') { }
      ***      0      0      0   elsif ($$session{'cmd'}) { }
2700  ***      0      0      0   if ($com eq '16') { }
2703  ***      0      0      0   if (not $ok)
2717  ***      0      0      0   if (not $ok)
2724  ***      0      0      0   if ($com eq '03' or $com eq '17' or $com eq '1a') { }
      ***      0      0      0   elsif ($com eq '16') { }
2756  ***     50      0      1   if (not $error)
2762  ***     50      1      0   if ($$session{'state'} eq 'client_auth') { }
      ***      0      0      0   elsif ($$session{'cmd'}) { }
2777  ***      0      0      0   if ($com eq '03' or $com eq '17') { }
2787  ***      0      0      0   $$error{'errno'} ? :
2801  ***      0      0      0   if ($$packet{'mysql_data_len'} == 1 and $$session{'state'} eq 'client_auth' and $$packet{'number'} == 2) { }
2815  ***     50      6      0   if ($$session{'cmd'}) { }
2820  ***     50      6      0   if ($com eq '03' or $com eq '17') { }
2830  ***     50      6      0   if ($$packet{'complete'})
2833  ***     50      6      0   if ($warning_count)
2836  ***     50      0      6   $flags & 16 ? :
2838  ***     50      0      6   $flags & 32 ? :
2856  ***     50      0      9   unless $packet
2857  ***     50      0      9   unless $session
2861  ***     50      0      9   if (($$session{'client_seq'} || '') eq $$packet{'seq'})
2871         100      2      7   if (($$session{'state'} || '') eq 'server_handshake') { }
      ***     50      0      7   elsif (($$session{'state'} || '') eq 'client_auth_resend') { }
      ***     50      0      7   elsif (($$session{'state'} || '') eq 'awaiting_reply') { }
2874  ***     50      0      2   if (not $handshake)
2890  ***      0      0      0   $$session{'cmd'}{'arg'} ? :
2896  ***     50      0      7   if ($$packet{'number'} != 0)
2901         100      1      6   if (not defined $$session{'compress'})
2902  ***     50      0      1   unless $self->detect_compression($packet, $session)
2907  ***     50      0      7   if (not $com)
2912  ***     50      0      7   if ($$com{'code'} eq '17') { }
      ***     50      0      7   elsif ($$com{'code'} eq '1a') { }
2915  ***      0      0      0   if (not $exec)
2925  ***      0      0      0   if (not $sth_id)
2942         100      1      6   if ($$com{'code'} eq '01') { }
      ***     50      0      6   elsif ($$com{'code'} eq '19') { }
2957  ***      0      0      0   if (not $sth_id)
2983         100      1      8   if (not $$session{'thread_id'})
2989  ***     50      0      9   $$event{'No_good_index_used'} ? :
      ***     50      0      9   $$event{'No_index_used'} ? :
3038  ***     50      9      0   if ($sd eq $ed) { }
3056  ***      0      0      0   $len ? :
3063  ***      0      0      0   unless $data
3069  ***      0      0      0   if ($first_byte <= 251) { }
      ***      0      0      0   elsif ($first_byte == 252) { }
      ***      0      0      0   elsif ($first_byte == 253) { }
      ***      0      0      0   elsif ($first_byte == 254) { }
3096  ***     50      0     76   if ($len)
3115  ***      0      0      0   if ($first_byte < 251) { }
      ***      0      0      0   elsif ($first_byte == 252) { }
      ***      0      0      0   elsif ($first_byte == 253) { }
      ***      0      0      0   elsif ($first_byte == 254) { }
3131  ***     50      0      1   unless $data
3133  ***     50      0      1   if (length $data < 16)
3139  ***     50      0      1   unless $marker eq '#'
3153  ***      0      0      0   unless $data
3155  ***      0      0      0   if (length $data < 12)
3177  ***      0      0      0   unless $data
3179  ***      0      0      0   if (length $data < 8)
3197  ***     50      0      2   unless $data
3222  ***     50      0      2   unless $data
3233  ***     50      0      2   if (not $buff_len)
3244         100      1      1   $db ? :
3255  ***     50      0      8   unless $data and $len
3261  ***     50      0      8   if (not $com)
3265  ***     50      8      0   if ($code ne '17' and $code ne '19' and $code ne '1a')
3282  ***      0      0      0   unless $data and $sths
3285  ***      0      0      0   unless defined $sth_id
3288  ***      0      0      0   if (not $sth)
3300  ***      0      0      0   if ($new_params) { }
3310  ***      0      0      0   if $data
3319  ***      0      0      0   if ($null_bitmap & 2 ** $i) { }
3325  ***      0      0      0   if ($unpack_type{$types[$i]}) { }
3338  ***      0      0      0   if $len
3351  ***      0      0      0   unless $data
3358  ***     50      0      4   unless $flags
3364         100     30     42   $flags_dec & $flagno ? :
3371  ***      0      0      0   unless $data
3372  ***      0      0      0   unless $len
3373  ***      0      0      0   unless ref $data eq 'SCALAR'
3380  ***      0      0      0   unless my $z = 'IO::Uncompress::Inflate'->new(\$comp_bin_data)
3383  ***      0      0      0   unless my $status = $z->read(\$uncomp_bin_data, $len)
3395  ***     50      0      1   if ($com and $$com{'code'} eq '00') { }
3400  ***      0      0      0   unless $self->uncompress_packet($packet, $session)
3412  ***      0      0      0   unless $packet
3413  ***      0      0      0   unless $session
3432  ***      0      0      0   if ($EVAL_ERROR)
3438  ***      0      0      0   if ($uncomp_data_len) { }
3443  ***      0      0      0   if ($EVAL_ERROR)
3460  ***     50      0     19   unless $packet
3478  ***      0      0      0   if $errors_fh
3481  ***      0      0      0   if ($o and $o->has('tcpdump-errors') and $o->got('tcpdump-errors'))
3484  ***      0      0      0   unless open $errors_fh, '>>', $errors_file
3496  ***      0      0      0   if ($errors_fh)
3522  ***      0      0      0   defined $_ ? :
3570  ***     50      0    698   unless $args{$arg}
3588         100      6    304   if ($stmt =~ s/$slow_log_hd_line//go)
3590         100      1      5   if (@chunks > 1)
3597         100    272     38   unless $stmt =~ /\A#/
3611         100   1440    297   if ($line =~ /^(?:#|use |SET (?:last_insert_id|insert_id|timestamp))/o) { }
3613         100     53   1387   if (not $got_ts and my($time) = $line =~ /$slow_log_ts_line/o) { }
             100    103   1284   elsif (not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o) { }
             100     10   1274   elsif (not $got_ac and $line =~ /^# (?:administrator command:.*)$/) { }
             100    988    286   elsif ($line =~ /^# +[A-Z][A-Za-z_]+: \S+/) { }
             100     39    247   elsif (not $got_db and my($db) = $line =~ /^use ([^;]+)/) { }
             100     20    227   elsif (not $got_set and my($setting) = $line =~ /^SET\s+([^;]*)/) { }
3617         100     16     37   if (not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o)
3660         100      3   1437   if (not $found_arg and $pos == $len)
3663  ***     50      3      0   if (defined(my $l = &$next_event())) { }
3680         100      1    296   if ($args{'misc'} and $args{'misc'}{'embed'} and my($e) = $arg =~ /($args{'misc'}{'embed'})/)
3695  ***     50     39      0   if $args{'oktorun'}
3701  ***      0      0      0   defined $_ ? :
3731  ***      0      0      0   if ($$event{'ts'})
3734  ***      0      0      0   if ($$event{'user'})
3738  ***      0      0      0   if ($$event{'ip'} and $$event{'port'})
3741  ***      0      0      0   if ($$event{'Thread_id'})
3745  ***      0      0      0   exists $$event{'QC_Hit'} ? :
3747  ***      0      0      0   unless $_
3752  ***      0      0      0   if ($percona_patched)
3753  ***      0      0      0   unless $_
3758  ***      0      0      0   if (exists $$event{'InnoDB_IO_r_ops'}) { }
3759  ***      0      0      0   unless $_
3770  ***      0      0      0   if ($$event{'db'})
3773  ***      0      0      0   if ($$event{'arg'} =~ /^administrator command/)
3783  ***      0      0      0   defined $_ ? :
3818  ***     50      0     92   unless $args{$arg}
3837  ***     50      0     46   unless $args{'type_for'}
3848         100     45      1   scalar keys %$attributes == 0 ? :
3871  ***     50      0    339   unless defined $group_by
3876  ***     50      0    339   if $$self{'unrolled_loops'}
3879  ***     50    339      0   if ($$self{'n_events'} <= $$self{'unroll_limit'}) { }
3881         100    337      2   if $$self{'detect_attribs'}
3886         100    153   4960   if (not exists $$event{$attrib})
3890  ***     50    153      0   unless $alt_attrib
3894         100     20   4940   ref $group_by ? :
3899         100    999   3961   if (not $handler)
3908         100    415   4545   unless $handler
3931  ***      0      0      0   ref $group_by ? :
3946  ***      0      0      0   if (ref $group_by)
3956  ***      0      0      0   if $EVAL_ERROR
3983  ***     50      0    999   unless defined $attrib
3986  ***     50      0    999   if (ref $val eq 'ARRAY')
3990         100    415    584   unless defined $val
3993         100     97    146   $val =~ /^(?:Yes|No)$/ ? :
             100    338    243   $val =~ /^(?:\d+|$float_re)$/o ? :
             100      3    581   $self->type_for($attrib) ? :
4001         100    435    149   $type =~ /num|bool/ ? :
             100    246    338   $type =~ /bool|string/ ? :
             100    338    246   $type eq 'num' ? :
             100     97    487   $type eq 'bool' ? :
4016         100     97    487   if ($args{'trf'})
4022  ***     50   1168      0   if ($args{'min'})
4023         100    676    492   $type eq 'num' ? :
4029  ***     50   1168      0   if ($args{'max'})
4030         100    676    492   $type eq 'num' ? :
4036         100    870    298   if ($args{'sum'})
4039  ***     50   1168      0   if ($args{'cnt'})
4042         100    676    492   if ($args{'all'})
4051         100    246    338   if ($args{'unq'})
4054         100     44    540   if ($args{'wor'})
4055  ***     50     44      0   $type eq 'num' ? :
4064         100     45    539   if ($attrib eq 'Query_time')
4072         100    338    246   if ($args{'all'} and $type eq 'num' and $$self{'attrib_limit'})
4087  ***     50      0    584   $is_array ? :
      ***     50      0    584   $is_array ? :
4099  ***     50      0    584   $is_array ? :
      ***     50      0    584   $is_array ? :
4112  ***     50      0    584   if $EVAL_ERROR
4118         100   1806   2990   if $val < 1e-06
4120  ***     50      0   2990   $idx > 999 ? :
4125         100      6   5994   if $bucket == 0
4126  ***     50      0   5994   if $bucket < 0 or $bucket > 999
4133         100     83      6   if @buck_tens
4164  ***     50      0    574   unless defined $vals and @$vals and $$args{'cnt'}
4168         100    526     48   if ($n_vals == 1 or $$args{'max'} == $$args{'min'}) { }
             100     29     19   elsif ($n_vals == 2) { }
4170         100    244    282   $v > 0 ? :
4171  ***     50      0    492   $bucket < 0 ? :
             100     34    492   $bucket > 7 ? :
4181         100     46     12   $v && $v > 0 ? :
4182  ***     50      0     50   $bucket < 0 ? :
             100      8     50   $bucket > 7 ? :
4194         100      1     18   $n_vals >= 10 ? :
4212         100  18943     57   unless $val
4216         100     19     38   if not $bucket_95 and $sum_excl > $top_vals
4218         100     19     38   if (not $median and $total_left <= $mid)
4219         100     17      2   $cutoff % 2 || $val > 1 ? :
4229         100     17      2   $var > 0 ? :
4231  ***     50      0     19   $stddev > $maxstdev ? :
4248  ***      0      0      0   unless $args{$arg}
4257  ***      0      0      0   $global_cnt && $$store{'cnt'} ? :
      ***      0      0      0   $$store{'sum'} && $$store{'cnt'} ? :
4281         100    104     13   if (!$args{'total'} || $total < $args{'total'} and !$args{'count'} || $count < $args{'count'}) { }
      ***     50      0     13   elsif ($args{'ol_attrib'} and !$args{'ol_freq'} || $$classes{$groupby}{$args{'ol_attrib'}}{'cnt'} >= $args{'ol_freq'}) { }
4296  ***      0      0      0   if ($$stats{'pct_95'} >= $args{'ol_limit'})
4309  ***     50      0    337   unless $event
4312         100   1605   4692   if $_ ne $$self{'groupby'} and not exists $$self{'attributes'}{$_}
4342  ***     50    604      0   unless @attribs
4353  ***      0      0      0   if $EVAL_ERROR
4359  ***      0      0      0   defined $_ ? :
4392  ***      0      0      0   unless $args{$arg}
4414  ***     50      0     52   unless defined $$col{'name'}
4415  ***     50      0     52   if ($$col{'fixed_wdith'} and $$col{'fixed_width'} < length $$col{'name'})
4430  ***     50      0     30   unless $n_cols == $n_vals
4438  ***     50      0    164   if ($$col{'fixed_width'} and $width > $$col{'fixed_width'})
4439  ***      0      0      0   if ($$col{'truncate'}) { }
4461         100      8      2   $$self{'long_last_column'} ? :
4468         100     34     10   $$col{'right_justify'} ? :
4474         100      8      2   if ($$self{'long_last_column'})
4480         100      8      2   if $$self{'title'}
4485  ***     50     10      0   if ($$self{'underline_header'})
4493         100      2      8   if ($$self{'truncate_underline'} and 2 + $underline_len > $$self{'line_width'})
4511  ***      0      0      0   defined $_ ? :
4572  ***      0      0      0   if ($EVAL_ERROR)
4586         100      5      1   if ($global_cnt and $$stats{'globals'}{'ts'} and ($$stats{'globals'}{'ts'}{'max'} || '') gt ($$stats{'globals'}{'ts'}{'min'} || ''))
4615  ***     50      0     65   unless $attrib_type
4616  ***     50      0     65   unless exists $$stats{'globals'}{$attrib}
4617         100      6     59   if ($formatting_function{$attrib}) { }
4625         100     44     15   if ($attrib_type eq 'num') { }
             100      6      9   elsif ($attrib_type eq 'string') { }
      ***     50      9      0   elsif ($attrib_type eq 'bool') { }
4626         100      8     36   $attrib =~ /time$/ ? :
4634  ***     50    308      0   defined $_ ? :
4641  ***     50      0      9   if ($$store{'sum'} > 0 or not $opts{'no_zero_bool'})
4650         100     44      9   unless $attrib_type eq 'bool'
4664  ***     50      0     89   unless $store
4671         100     10     79   if ($global_cnt and $$store{'ts'} and ($$store{'ts'}{'max'} || '') gt ($$store{'ts'}{'min'} || ''))
4684         100     79     10   $$ea{'groupby'} eq 'fingerprint' ? :
4695         100     57     32   if ($opts{'reason'})
4696  ***     50     57      0   $opts{'reason'} eq 'top' ? :
4709         100     26   1150   unless $attrib_type
4710         100    117   1033   unless exists $$store{$attrib}
4712         100      4   1029   unless scalar %$vals
4713         100     78    951   if ($formatting_function{$attrib}) { }
4721         100    530    421   if ($attrib_type eq 'num') { }
             100    206    215   elsif ($attrib_type eq 'string') { }
      ***     50    215      0   elsif ($attrib_type eq 'bool') { }
4722         100    159    371   $attrib =~ /time$/ ? :
4729  ***     50   3710      0   defined $_ ? :
4740         100     14    201   if ($$vals{'sum'} > 0 or not $opts{'no_zero_bool'})
4750         100    736    215   unless $attrib_type eq 'bool'
4763  ***     50      0     89   unless defined $vals and scalar @$vals
4776         100     79    633   if $n_vals > $max_val
4783  ***     50      0    712   if $n_marks < 1 and $n_vals > 0
4784         100     87    625   $n_marks ? :
4795         100      6     89   if ($global)
4805         100     84    780   if ($val =~ /^InnoDB/)
4816         100      6    481   $val eq 'Error_no' ? :
             100     68    487   $val eq 'host' ? :
             100     95    555   $val eq 'Query_time' ? :
             100     68    650   $val eq 'db' ? :
             100     62    718   $val eq 'user' ? :
             100     84    780   $val eq 'ts' ? :
4828  ***     50    206      0   if (exists $$stats{'unq'}) { }
4830         100    200      6   if (1 == keys %$cnt_for)
4832  ***     50      0    200   if length $str > 44
4837  ***     50      6      0   unless $$cnt_for{$b} <=> $$cnt_for{$a}
4842         100      1     11   if (length $str > 10) { }
4848  ***     50      0     12   if length($line) + length($print_str) > 47
4853  ***     50      0      6   if ($i < @top)
4881         100    626    615   if (exists $basic_attrib{$attrib}) { }
4885         100    384    231   if (($ea->type_for($attrib) || '') ne 'bool') { }
4904  ***      0      0      0   defined $_ ? :
4937  ***     50      0      2   unless $args{$arg}
4957         100      1      7   if (not $handler)
4961  ***     50      0      8   unless $handler
4978  ***     50      0      2   unless defined $val
4980  ***     50      0      1   $val =~ /^(?:Yes|No)$/ ? :
             100      1      1   $val =~ /^(?:\d+|$float_re)$/o ? :
4993  ***     50      0      2   if ($type eq 'bool')
4997         100      1      1   $type eq 'num' ? :
5002         100      1      1   $type eq 'num' ? :
5007         100      1      1   if ($type eq 'num')
5039  ***     50      0      1   if $EVAL_ERROR
5051  ***     50      8      0   if ($t = $$res[2]{'ts'} and $$t{'min'}) { }
5054  ***     50      0      8   if ($$t{'max'} and $$t{'max'} gt $$t{'min'}) { }
5072  ***      0      0      0   defined $_ ? :
5119  ***     50      0    205   unless $query
5123         100      4    201   if ($ddl_stmt)
5126         100      2      2   if ($query =~ /$ddl_stmt DATABASE\b/i)
5130  ***     50      0      2   if ($ddl_stmt =~ /CREATE/i and $query =~ /$ddl_stmt\b.+?\bSELECT\b/i)
5142         100      2    199   if ($query =~ /^\s*LOCK TABLES/i)
5158         100      2    153   if $tbls =~ /\ASELECT\b/i
5163  ***     50      0    159   if (not $tbl =~ /[a-zA-Z]/)
5183  ***      0      0      0   unless $query
5199  ***      0      0      0   unless $tbl_refs and $from
5220  ***      0      0      0   if ($tbl_ref =~ /^AS\s+\w+/i)
5228  ***      0      0      0   if $db
5235  ***     50      0      5   unless $query
5244  ***     50      0      5   if (@split_statements == 1) { }
5251  ***     50      0      5   if ($statements[-2] and $statements[-2] =~ /on duplicate key\s+$/i)
5263  ***     50      0      5   unless $query
5273  ***      0      0      0   unless $query
5284  ***      0      0      0   if ($word =~ /^\(?SELECT\b/i) { }
5286  ***      0      0      0   if ($start_pos) { }
5304  ***      0      0      0   unless $sqno
5307  ***      0      0      0   if ($$sq{'done'})
5316  ***      0      0      0   if ($$sq{'lp'} + $lp - ($$sq{'rp'} + $rp) == 0)
5327  ***      0      0      0   unless $sq
5342         100      4      1   if ($type =~ /^SELECT\b/) { }
      ***     50      1      0   elsif ($type =~ /^$data_manip_stmts\b/ or $type =~ /^$data_def_stmts\b/) { }
5358  ***      0      0      0   defined $_ ? :
5408  ***      0      0      0   unless defined $args{'cache'}
5416  ***      0      0      0   if ($what eq 'table') { }
      ***      0      0      0   elsif ($what eq 'triggers') { }
      ***      0      0      0   elsif ($what eq 'view') { }
5418  ***      0      0      0   unless $ddl
5419  ***      0      0      0   if ($$ddl[0] eq 'table') { }
5433  ***      0      0      0   if ($trgs and @$trgs) { }
5436  ***      0      0      0   if ($$trg{'sql_mode'})
5440  ***      0      0      0   if ($$trg{'definer'})
5472  ***      0      0      0   if (not $new)
5479  ***      0      0      0   if ($curr and $new and $curr eq $new)
5491  ***      0      0      0   if (not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl})
5504  ***      0      0      0   if ($EVAL_ERROR)
5514  ***      0      0      0   if ($key) { }
5530  ***      0      0      0   if (not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl})
5560  ***      0      0      0   if (not $$self{'cache'} or not $$self{'triggers'}{$db})
5573  ***      0      0      0   if ($sth->rows)
5586  ***      0      0      0   if ($tbl)
5594  ***      0      0      0   if (not $$self{'cache'} or not $$self{'databases'} or $like)
5597  ***      0      0      0   if ($like)
5605  ***      0      0      0   unless $like
5613  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_status'}{$db} or $like)
5616  ***      0      0      0   if ($like)
5631  ***      0      0      0   unless $like
5639  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_list'}{$db} or $like)
5642  ***      0      0      0   if ($like)
5650  ***      0      0      0   ($$_[1] || '') eq 'VIEW' ? :
5657  ***      0      0      0   unless $like
5665  ***      0      0      0   defined $_ ? :
5697  ***      0      0      0   unless $args{$arg}
5706  ***      0      0      0   unless $ddl
5707  ***      0      0      0   if (ref $ddl eq 'ARRAY')
5708  ***      0      0      0   if (lc $$ddl[0] eq 'table') { }
5718  ***      0      0      0   if (not $ddl =~ /CREATE (?:TEMPORARY )?TABLE `/)
5724  ***      0      0      0   if $name
5742  ***      0      0      0   unless $type
5744  ***      0      0      0   if ($type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/)
5748  ***      0      0      0   if (not $def =~ /NOT NULL/)
5752  ***      0      0      0   $def =~ /AUTO_INCREMENT/i ? :
5783  ***      0      0      0   unless ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
5797  ***      0      0      0   if ($index)
5800  ***      0      0      0   if (not $best)
5801  ***      0      0      0   if ($index) { }
5814  ***      0      0      0   unless $where
5820  ***      0      0      0   if ($$expl{'possible_keys'}) { }
5824  ***      0      0      0   if ($$expl{'key'})
5844  ***      0      0      0   unless $args{$arg}
5858  ***      0      0      0   if ($EVAL_ERROR)
5862  ***      0      0      0   if (not $$row[0] or $$row[0] ne $tbl)
5868  ***      0      0      0   unless $args{'all_privs'}
5875  ***      0      0      0   if ($EVAL_ERROR)
5879  ***      0      0      0   if (not scalar keys %$row)
5890  ***      0      0      0   $EVAL_ERROR ? :
5895  ***      0      0      0   if (not $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete)
5921  ***      0      0      0   if $key =~ /FOREIGN/
5926  ***      0      0      0   if (not $engine =~ /MEMORY|HEAP/)
5933  ***      0      0      0   if ($$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i)
5940  ***      0      0      0   $key =~ /PRIMARY|UNIQUE/ ? :
5964  ***      0      0      0   if ($engine =~ /InnoDB/i and not $clustered_key)
5966  ***      0      0      0   if ($$this_key{'name'} eq 'PRIMARY') { }
      ***      0      0      0   elsif ($$this_key{'is_unique'} and not $$this_key{'is_nullable'}) { }
5990  ***      0      0      0   if (not $parent =~ /\./ and $$opts{'database'})
6019  ***      0      0      0   if (($$tbl_struct{'engine'} || '') =~ /InnoDB/i) { }
6033  ***      0      0      0   if (@sec_indexes)
6050  ***      0      0      0   defined $_ ? :
6086  ***      0      0      0   unless $args{$arg}
6090  ***      0      0      0   unless $args{'tbl_struct'}{'is_col'}{$col}
6094  ***      0      0      0   defined $args{'ts_default'} ? :
6136  ***      0      0      0   unless $args{$arg}
6143  ***      0      0      0   unless $attr and $metric
6144  ***      0      0      0   if $attr =~ /_/
6151  ***      0      0      0   $_ eq 'ts_min' || $_ eq 'ts_max' ? :
6168  ***      0      0      0   unless defined $data{'ts'} and defined $data{'ts'}{$thing}
6181  ***      0      0      0   if ($review_vals and @$review_vals == 1)
6189  ***      0      0      0   $args{$_} ? :
6203  ***      0      0      0   defined $_ ? :
6231  ***      0      0      0   unless $args{$arg}
6234  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
6250  ***      0      0      0   unless defined(my $pid = fork)
6251  ***      0      0      0   if ($pid)
6258  ***      0      0      0   unless POSIX::setsid()
6259  ***      0      0      0   unless chdir '/'
6265  ***      0      0      0   if (-t STDIN)
6267  ***      0      0      0   unless open STDIN, '/dev/null'
6271  ***      0      0      0   if ($$self{'log_file'}) { }
6273  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
6277  ***      0      0      0   unless open STDERR, '>&STDOUT'
6281  ***      0      0      0   if (-t STDOUT)
6283  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
6286  ***      0      0      0   if (-t STDERR)
6288  ***      0      0      0   unless open STDERR, '>', '/dev/null'
6299  ***      0      0      0   $self ? :
6301  ***      0      0      0   if ($PID_file and -f $PID_file) { }
6304  ***      0      0      0   if $EVAL_ERROR
6306  ***      0      0      0   if ($pid) { }
6308  ***      0      0      0   if ($pid_is_alive) { }
6330  ***      0      0      0   if (exists $$self{'child'})
6342  ***      0      0      0   if (not $PID_file)
6349  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
6351  ***      0      0      0   unless print $PID_FH $PID
6353  ***      0      0      0   unless close $PID_FH
6362  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
6363  ***      0      0      0   unless unlink $$self{'PID_file'}
6375  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
6381  ***      0      0      0   defined $_ ? :
6412  ***      0      0      0   $args{'server'} ? :
6429  ***      0      0      0   unless $args{$arg}
6436  ***      0      0      0   if (my $server = $$self{'server'})
6437  ***      0      0      0   if ($src_host ne $server and $dst_host ne $server)
6445  ***      0      0      0   if ($src_host =~ /:$$self{'server_port'}$/) { }
      ***      0      0      0   elsif ($dst_host =~ /:$$self{'server_port'}$/) { }
6459  ***      0      0      0   if (not exists $$self{'sessions'}{$client})
6469  ***      0      0      0   if ($$packet{'data_len'} == 0)
6478  ***      0      0      0   if ($packet_from eq 'server') { }
      ***      0      0      0   elsif ($packet_from eq 'client') { }
6494  ***      0      0      0   unless $packet
6495  ***      0      0      0   unless $session
6501  ***      0      0      0   if (not $$session{'state'})
6506  ***      0      0      0   if ($$session{'state'} eq 'awaiting reply') { }
6514  ***      0      0      0   if ($$session{'cmd'} eq 'incr' or $$session{'cmd'} eq 'decr') { }
      ***      0      0      0   elsif ($$session{'res'} eq 'VALUE') { }
      ***      0      0      0   elsif ($$session{'res'} eq 'END') { }
      ***      0      0      0   elsif (not $$session{'res'} =~ /STORED|DELETED|NOT_FOUND/) { }
6516  ***      0      0      0   if (not $$session{'res'} =~ /\D/)
6525  ***      0      0      0   unless defined $$session{'flags'}
6526  ***      0      0      0   unless defined $$session{'bytes'}
6527  ***      0      0      0   if ($rest and $bytes)
6529  ***      0      0      0   if (length $rest > $bytes) { }
6556  ***      0      0      0   if ($$session{'gathered'} >= $$session{'bytes'} + 2) { }
6579  ***      0      0      0   unless $packet
6580  ***      0      0      0   unless $session
6585  ***      0      0      0   if (($$session{'state'} || '') =~ /awaiting reply|partial recv/)
6597  ***      0      0      0   if (not $$session{'state'}) { }
6603  ***      0      0      0   if ($cmd eq 'set' or $cmd eq 'add' or $cmd eq 'replace') { }
      ***      0      0      0   elsif ($cmd eq 'get') { }
      ***      0      0      0   elsif ($cmd eq 'delete') { }
      ***      0      0      0   elsif ($cmd eq 'incr' or $cmd eq 'decr') { }
6609  ***      0      0      0   if ($val)
6616  ***      0      0      0   if ($val)
6639  ***      0      0      0   if ($val)
6640  ***      0      0      0   if ($$session{'bytes'} + 2 == length $val) { }
6652  ***      0      0      0   if ($$session{'gathered'} >= $$session{'bytes'} + 2) { }
6693  ***      0      0      0   if $errors_fh
6696  ***      0      0      0   if ($o and $o->has('tcpdump-errors') and $o->got('tcpdump-errors'))
6699  ***      0      0      0   unless open $errors_fh, '>>', $errors_file
6710  ***      0      0      0   if ($errors_fh)
6729  ***      0      0      0   defined $_ ? :
6743  ***      0      0      0   if ($sd eq $ed) { }
6808  ***      0      0      0   unless $event
6810  ***      0      0      0   if (not $$event{'cmd'} or not $$event{'key'})
6815  ***      0      0      0   if (not $cmds{$$event{'cmd'}})
6828  ***      0      0      0   if ($$event{'res'}) { }
6829  ***      0      0      0   if $$event{'res'} eq 'NOT_FOUND'
6835  ***      0      0      0   if ($cmd_handler_for{$$event{'cmd'}})
6851  ***      0      0      0   if (not $$event{'res'})
6856  ***      0      0      0   $$event{'res'} eq 'NOT_STORED' ? :
6857  ***      0      0      0   $$event{'res'} eq 'EXISTS' ? :
6865  ***      0      0      0   if (not $$event{'res'})
6870  ***      0      0      0   $$event{'res'} eq 'INTERRUPTED' ? :
6888  ***      0      0      0   defined $_ ? :
6933  ***     50      0     34   unless $args{$arg}
6957         100     64     10   if $delim
6960         100      6     68   if ($line =~ m[^/\*.+\*/;])
6965         100      3     65   if ($line =~ /^DELIMITER/m)
6967         100      2      1   if ($del) { }
6980         100      2     63   if $line =~ /End of log file/
6982         100     14     49   if (not $got_offset and my($offset) = $line =~ /$binlog_line_1/m) { }
             100     14     35   elsif (not $got_hdr and $line =~ /^#(\d{6}\s+\d{1,2}:\d\d:\d\d)/) { }
             100     20     15   elsif ($line =~ /^(?:#|use |SET)/i) { }
6998         100      2     18   if (my($db) = $line =~ /^use ([^;]+)/) { }
             100     17      1   elsif (my($setting) = $line =~ /^SET\s+([^;]*)/) { }
7012         100     13      2   if ($got_offset and $got_hdr) { }
7013         100      3     10   if ($type eq 'Xid') { }
             100      9      1   elsif ($type eq 'Query') { }
      ***     50      1      0   elsif ($type eq 'Start:') { }
7035         100      5     10   $pos == length $stmt ? :
7038         100     13      2   if $delim
7040         100      1     14   if ($arg =~ /^DELIMITER/m)
7042  ***     50      0      1   if ($del) { }
7065         100     15      3   if ($found_arg) { }
7075  ***     50      2      0   if $args{'oktorun'}
7081  ***      0      0      0   defined $_ ? :
7134  ***     50      0     16   unless $args{$arg}
7149  ***     50      0      7   if (not $thread_id && $cmd)
7159         100      2      5   if ($cmd eq 'Query') { }
7163  ***     50      5      0   if ($line) { }
7165         100      2      3   if ($thread_id and $cmd) { }
7184  ***     50      2      0   if $$db_for{$thread_id}
7189         100      2      3   if ($cmd eq 'Connect') { }
             100      1      2   elsif ($cmd eq 'Init') { }
7190  ***     50      0      2   if ($arg =~ /^Access denied/) { }
7199  ***     50      2      0   if $user
7200  ***     50      2      0   if $host
7201         100      1      1   if $db
7210  ***     50      1      0   if $db
7226  ***     50      1      0   if $args{'oktorun'}
7232  ***      0      0      0   defined $_ ? :
7268  ***      0      0      0   if $args{'server'}
7269  ***      0      0      0   if not $server_port and $args{'server_port'}
7285  ***      0      0      0   unless $args{$arg}
7289  ***      0      0      0   if ($$self{'buffer'})
7291  ***      0      0      0   if ($$packet{'data_len'})
7292  ***      0      0      0   if ($packet_from eq 'client') { }
7302  ***      0      0      0   unless $packet_from eq 'client' and $$packet{'fin'} || $$packet{'rst'}
7319  ***      0      0      0   if ($$packet{'data_len'} == 0)
7333  ***      0      0      0   unless $$misc{'recurse'}
7336  ***      0      0      0   if ($$session{'buff'})
7338  ***      0      0      0   if ($$session{'buff_left'} > 0)
7351  ***      0      0      0   unless $$misc{'recurse'}
7353  ***      0      0      0   if ($packet_from eq 'server') { }
      ***      0      0      0   elsif ($packet_from eq 'client') { }
7364  ***      0      0      0   if ($$session{'out_of_order'})
7367  ***      0      0      0   if $$packet{'ts'} lt ($$session{'ts_min'} || '')
7369  ***      0      0      0   if $$packet{'ts'} gt ($$session{'ts_max'} || '')
7371  ***      0      0      0   if ($$session{'have_all_packets'})
7391  ***      0      0      0   if (my $server = $$self{'server'})
7392  ***      0      0      0   if ($src_host ne $server and $dst_host ne $server)
7400  ***      0      0      0   if ($src_host =~ /:$$self{'server_port'}$/) { }
      ***      0      0      0   elsif ($dst_host =~ /:$$self{'server_port'}$/) { }
7414  ***      0      0      0   if (not exists $$self{'sessions'}{$client})
7437  ***      0      0      0   unless scalar keys %{$$session{'attribs'};}
7438  ***      0      0      0   unless $$session{'attribs'}{'arg'}
7455  ***      0      0      0   if $errors_fh
7458  ***      0      0      0   if ($o and $o->has('tcpdump-errors') and $o->got('tcpdump-errors'))
7461  ***      0      0      0   unless open $errors_fh, '>>', $errors_file
7472  ***      0      0      0   if ($errors_fh)
7491  ***      0      0      0   unless $start and $end
7498  ***      0      0      0   if ($sd eq $ed) { }
7508  ***      0      0      0   unless $data
7509  ***      0      0      0   unless $len
7510  ***      0      0      0   unless ref $data eq 'SCALAR'
7517  ***      0      0      0   unless my $z = 'IO::Uncompress::Inflate'->new(\$comp_bin_data)
7520  ***      0      0      0   unless my $status = $z->read(\$uncomp_bin_data, $len)
7530  ***      0      0      0   defined $_ ? :
7570  ***      0      0      0   unless $packet
7571  ***      0      0      0   unless $session
7575  ***      0      0      0   if (not $$session{'state'})
7580  ***      0      0      0   if ($$session{'out_of_order'})
7582  ***      0      0      0   if (not $$session{'have_header'})
7586  ***      0      0      0   if ($line1)
7595  ***      0      0      0   if $$session{'attribs'}{'bytes'} and $have_len >= $$session{'attribs'}{'bytes'}
7602  ***      0      0      0   if ($$session{'state'} eq 'awaiting reply') { }
      ***      0      0      0   elsif ($$session{'state'} eq 'recving content') { }
7604  ***      0      0      0   unless $$session{'start_reply'}
7609  ***      0      0      0   if (not $line1)
7620  ***      0      0      0   $content ? :
7622  ***      0      0      0   if ($$session{'attribs'}{'bytes'} and $content_len < $$session{'attribs'}{'bytes'})
7634  ***      0      0      0   if ($$session{'buff'})
7655  ***      0      0      0   unless $packet
7656  ***      0      0      0   unless $session
7661  ***      0      0      0   if (($$session{'state'} || '') =~ /awaiting /)
7666  ***      0      0      0   if (not $$session{'state'}) { }
7670  ***      0      0      0   if (not $request or not $page)
7679  ***      0      0      0   if ($request eq 'get' or $request eq 'post') { }
7701  ***      0      0      0   unless $data
7705  ***      0      0      0   unless $line1
7707  ***      0      0      0   if (not $header_vals)
7713  ***      0      0      0   unless $val
7715  ***      0      0      0   if ($val =~ /^Content-Length/i)
7719  ***      0      0      0   if ($val =~ /Content-Encoding/i)
7723  ***      0      0      0   if ($val =~ /^Host/i)
7733  ***      0      0      0   defined $_ ? :
7767  ***      0      0      0   unless defined $args{$arg}
7788  ***      0      0      0   if ($self->_time_to_check($time)) { }
7794  ***      0      0      0   if ($args{'stats'})
7801  ***      0      0      0   if ($rate_avg > $$self{'rate_max'}) { }
7803  ***      0      0      0   if $$self{'skip_prob'} > 1
7805  ***      0      0      0   if $args{'stats'}
7809  ***      0      0      0   if $$self{'skip_prob'} < 0
7810  ***      0      0      0   if $args{'stats'}
7819  ***      0      0      0   if ($args{'stats'})
7828  ***      0      0      0   if ($args{'event'})
7829  ***      0      0      0   $$self{'skip_prob'} <= rand() ? :
7837  ***      0      0      0   if (not $$self{'last_check'})
7841  ***      0      0      0   $time - $$self{'last_check'} >= $$self{'check_int'} ? :
7858  ***      0      0      0   if @$samples > 1000
7865  ***      0      0      0   defined $_ ? :
7938         100     44      1   unless $_ eq 'genlog'
             100      1     44   if (grep {$_ eq 'GeneralLogParser' unless $_ eq 'genlog';} @{$o->get('type');} and not $o->got('order-by')) { }
7946  ***     50     45      0   if (not $o->get('help'))
7947  ***     50      0     45   if ($review_dsn and !defined($$review_dsn{'D'}) || !defined($$review_dsn{'t'}))
7952  ***     50      0     45   if ($o->get('mirror') and !$o->get('execute') || !$o->get('processlist'))
7956  ***     50      0     45   if ($o->get('outliers') and grep {not $_ =~ /^\w+:[0-9.]+(?::[0-9.]+)?$/;} @{$o->get('outliers');})
7961  ***     50      0     45   if ($o->get('execute-throttle'))
7963  ***      0      0      0   unless $rate_max and $rate_max > 0 and $rate_max <= 100
7965  ***      0      0      0   unless $int
7967  ***      0      0      0   if $int =~ /[^\d]/
7969  ***      0      0      0   if $step and $step < 1 || $step > 100
7987         100      3     42   if ($o->get('explain'))
7999  ***     50      0     45   if ($review_dsn)
8009  ***      0      0      0   if ($o->get('create-review-table'))
8019  ***      0      0      0   if (not $tp->check_table('dbh', $qv_dbh, 'db', $db_tbl[0], 'tbl', $db_tbl[1], 'all_privs', 1))
8039  ***      0      0      0   if ($o->get('review-history'))
8047  ***      0      0      0   if ($o->get('create-review-history-table'))
8057  ***      0      0      0   if (not $tp->check_table('dbh', $qv_dbh2, 'db', $hdb_tbl[0], 'tbl', $hdb_tbl[1], 'all_privs', 1))
8082  ***      0      0      0   unless $attr and $metric
8083  ***      0      0      0   if $attr =~ /_/
8088  ***      0      0      0   if ($o->got('select'))
8118  ***     50      0     45   if ($o->get('processlist')) { }
8133  ***      0      0      0   if ($err)
8144  ***      0      0      0   if ($err)
8150  ***      0      0      0   if ($o->get('mirror') and time - $cur_time > $o->get('mirror'))
8179  ***     50     45      0   if $alias_for{$$type[0]}
8189  ***     50      0     48   if ($EVAL_ERROR)
8207  ***     50      0     45   if (my $aux_dsn = $o->get('aux-dsn'))
8215  ***      0      0      0   unless $aux_dbh
8220  ***     50      0     45   if ($o->get('since'))
8222  ***      0      0      0   unless $since
8226  ***      0      0      0   if ($past_since)
8230  ***      0      0      0   if ($$event{'ts'})
8232  ***      0      0      0   if (($ts || 0) >= $since) { }
8245  ***     50      0     45   if ($o->get('until'))
8247  ***      0      0      0   unless $until
8251  ***      0      0      0   if ($at_until)
8255  ***      0      0      0   if ($$event{'ts'})
8257  ***      0      0      0   if (($ts || 0) >= $until) { }
8271         100     38      7   if (grep {$_ eq 'fingerprint';} @groupby)
8277  ***     50      0    317   unless $groupby_val
8296  ***     50     45      0   if $inherit_attrib_sub
8299         100      1     44   if (grep {$_ eq 'tables';} @groupby)
8304  ***     50      0      2   unless defined $group_by_val
8309         100      1      1   if (not $_ =~ /\./ and my $db = $$event{'db'} || $$event{'Schema'})
8322  ***     50      0     45   if ($o->get('type') eq 'memcached' or $o->get('type') eq 'http')
8324  ***      0      0      0   if ($o->get('type') eq 'http')
8333         100      3     42   if (grep {$_ eq 'distill';} @groupby)
8338  ***     50      0     11   unless defined $group_by_val
8348         100      1     44   if ($o->get('filter'))
8350  ***     50      0      1   if (-f $filter and -r $filter) { }
8352  ***      0      0      0   unless open my $fh, '<', $filter
8361  ***     50      0      1   unless my $sub = eval $code
8367         100     44      1   if ($o->get('zero-admin'))
8371         100     11    320   if ($$event{'arg'} and $$event{'arg'} =~ /^# administrator/)
8381  ***     50      0     45   if ($o->got('sample'))
8384  ***      0      0      0   if ($group_by_val)
8389  ***      0      0      0   if (++$seen{$$event{$group_by_val}} <= $num_samples)
8401  ***     50      0     45   if ($o->get('print'))
8413  ***     50      0     45   if (my $et_args = $o->get('execute-throttle'))
8441         100      2     43   if ($o->get('execute'))
8451  ***     50      0      2   if (($$event{'Skip_exec'} || '') eq 'Yes')
8462  ***     50      0      2   if ($db and !$curdb || $db ne $curdb)
8472  ***     50      0      1   if ($o->get('mirror') and $end - $cur_time > $o->get('mirror'))
8478         100      1      1   if ($EVAL_ERROR)
8482  ***     50      0      1   if ($EVAL_ERROR =~ /server has gone away/)
8489  ***      0      0      0   if ($EVAL_ERROR)
8495  ***     50      1      0   if ($EVAL_ERROR =~ /No database/)
8512  ***     50      0     46   unless $orderby[$i]
8550         100      1     45   if ($o->get('timeline'))
8565  ***     50      0     45   if ($o->get('processlist'))
8578  ***     50      0     45   if ($o->get('daemonize')) { }
      ***     50      0     45   elsif ($o->get('pid')) { }
8592         100      1     44   if (my $patterns = $o->get('embedded-attributes'))
8599  ***     50      0     45   if (@ARGV == 0)
8607  ***     50      0     45   if (my $read_time = $o->get('read-timeout')) { }
8625  ***     50      0     45   if ($o->get('print-iterations'))
8636         100     90    367   if (not $fh)
8638         100     45     45   if (not $file)
8643  ***     50      0     45   if ($file eq '-') { }
8648  ***     50      0     45   if (not open $fh, '<', $file)
8674  ***     50      0   2147   unless $oktorun
8692         100     78   2069   unless $event
8694         100     45    367   if (not $more_events)
8696  ***     50     45      0   if $fh
8700  ***     50      0    412   if ($EVAL_ERROR)
8706  ***      0      0      0   if $EVAL_ERROR =~ /Cannot open/
8708  ***      0      0      0   unless $o->get('continue-on-error')
8723         100      6     39   if ($o->get('report') and $o->get('report-format')->{'header'})
8724  ***     50      0      6   if $o->get('report-format')->{'rusage'}
8729  ***     50      0      6   if (not $ea->events_processed) { }
8759         100     41      5   if ($limit =~ /^\d+$/) { }
8775         100     45      1   if ($o->get('outliers')->[$i])
8796         100      8     38   if ($o->get('report') and $o->get('report-format')->{'query_report'} and @groupby > 1 || $groupby ne 'fingerprint')
8818         100     87     17   $groupby eq 'fingerprint' ? :
             100     87     17   $groupby eq 'fingerprint' ? :
8834  ***     50      0    104   if ($$stats{'Statement_id'} and $item =~ /^(?:prepare|execute) /)
8842  ***      0      0      0   if ($item =~ /^prepare /) { }
8853  ***      0      0      0   if (not $seen_prepared{$prep_stmt}++)
8877  ***     50      0    104   if ($qv)
8879  ***      0      0      0   if ($$review_vals{'reviewed_by'} and not $o->get('report-all'))
8882  ***      0      0      0   if ($o->get('review-history'))
8889  ***      0      0      0   if ($o->get('review-history'))
8903         100      1     22   $$stats{'db'}{'unq'} ? :
             100     81     23   $$sample{'db'} ? :
8906  ***     50    104      0   if ($o->get('for-explain') or $o->get('table-access'))
8908         100      5     99   if $o->get('table-access')
8914         100     89     15   if ($o->get('report') and $o->get('report-format')->{'query_report'})
8919         100     57     32   $explain_why ? :
8932  ***     50      0     89   if ($qv)
8938  ***      0      0      0   if (not $val or $val ne '0000-00-00 00:00:00')
8939  ***      0      0      0   $val ? :
8944         100     79     10   if ($groupby eq 'fingerprint')
8946  ***     50     79      0   if $o->get('shorten')
8950  ***     50      0     89   if ($groupby eq 'fingerprint' and $o->get('fingerprints'))
8954         100     79     10   if ($groupby eq 'fingerprint') { }
8955  ***     50     79      0   if $o->get('for-explain')
8956         100     38     41   if ($item =~ /^(?:[\(\s]*select|insert|replace)/) { }
8957         100     15     23   if ($item =~ /^(?:insert|replace)/) { }
8968         100     15     26   if ($o->get('for-explain') and $converted and $converted =~ /^[\(\s]*select/i)
8978         100      1      9   if ($groupby eq 'tables')
8989  ***     50      0    104   if ($qv)
8996  ***      0      0      0   if ($o->get('review-history'))
9008         100      1     45   if ($o->get('timeline'))
9014         100      2     44   if ($o->get('table-access'))
9020  ***     50      0      5   if ($EVAL_ERROR)
9027  ***     50      0      2   if $o->get('report')
9030  ***     50      0      5   unless $rw
9032  ***     50      0      5   unless scalar @tables
9034         100      1      4   if $seen{$db_tbl}++
9036  ***     50      0      4   $db ? :
9043         100      8     38   if ($o->get('report') and $o->get('report-format')->{'profile'})
9075  ***     50      0     46   if ($o->get('report') and $o->get('report-format')->{'prepared'} and scalar @prepared)
9123  ***     50      0     45   if ($o->get('pipeline-profile'))
9150         100      2     43   if ($o->get('statistics'))
9151  ***     50      2      0   if (keys %stats) { }
9189  ***     50      0     77   unless $db_tbl
9190         100      3     74   if $seen{$db_tbl}++
9200         100     29     51   unless @tables
9204         100     48     10   $db ? :
9214         100     20      3   unless $dbh and $query
9216  ***     50      3      0   if (not $qp->has_derived_table($query))
9217  ***     50      3      0   if ($db)
9227         100     14      6   defined $row[$j] ? :
9233         100      1      2   if ($EVAL_ERROR)
9250  ***     50      2      0   if (not $dbh or not $dbh->ping)
9256  ***     50      0      2   if ($o->get('mirror'))
9260  ***      0      0      0   if ($is_read_only != $read_only)
9261  ***      0      0      0   $current eq 'execute' ? :
9274  ***      0      0      0   if ($oktorun) { }
9306  ***     50      0     45   if $EVAL_ERROR
9322  ***     50      0     45   if $EVAL_ERROR
9331         100      1     51   if (not $ea->type_for($orderby_attrib) and $orderby_attrib ne 'Query_time')
9335  ***     50      1      0   if ($o->get('report-format')->{'query_report'})
9351  ***      0      0      0   unless $fh
9372  ***      0      0      0   if ($EVAL_ERROR)
9374  ***      0      0      0   unless $EVAL_ERROR =~ /read timeout/
9383  ***      0      0      0   defined $_ ? :


Conditions
----------

and 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
1898  ***      0      0      0   $rows and scalar @$rows
4763  ***     50      0     89   defined $vals and scalar @$vals
9075  ***     50     46      0   $o->get('report') and $o->get('report-format')->{'prepared'} and scalar @prepared

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
134   ***     66     29     32      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33     61      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
256   ***     66      7      0      7   not $dbh and $tries--
292   ***     33      7      0      0   not $dbh and $EVAL_ERROR
678          100    855   1710    270   $type and $type eq 'd'
      ***     66   2565    270      0   $type and $type eq 'd' and not $$self{'dp'}
683          100    855    990    990   $type and $type =~ /[HhAadzm]/
822   ***     33      0     45      0   @ARGV and $ARGV[0] eq '--config'
851   ***     33      0     45      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
858   ***     33      0     45      0   @ARGV and $$self{'strict'}
942   ***     66      0    855   1980   $opt and $$opt{'type'}
945   ***     66   1207    773      0   $val and $$opt{'type'} eq 'm'
             100   1207    768      5   $val and $$opt{'type'} eq 'd'
      ***     66   1207    768      0   $val and $$opt{'type'} eq 'z'
      ***     66   1207    723      0   defined $val and $$opt{'type'} eq 'h'
             100   1163    271    226   defined $val and $$opt{'type'} eq 'a'
1010  ***     33      0      0   3615   $long and exists $$self{'opts'}{$long}
1018  ***     33      0      0    226   $long and exists $$self{'opts'}{$long}
1032  ***     33      0      0     45   $long and exists $$self{'opts'}{$long}
1122  ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
1216  ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1334         100    464    372    333   $t > 0 and $t <= 0.000999
             100    464    181    191   $t >= 0.001 and $t <= 0.999999
1392  ***     66   3065      0     56   $num >= $d and $n < @units - 1
1470  ***      0      0      0      0   $callback and ref $callback eq 'CODE'
1562  ***     33      0      2      0   $length > 0 and $query_length > $length
      ***     33      2      0      0   $length > 0 and $query_length > $length and $query_length < ($last_length || $query_length + 1)
1722         100      6     88      4   $verbs and $verbs =~ /^SHOW/
1915  ***      0      0      0      0   not $curr and @curr
1919  ***      0      0      0      0   not $prev and @prev
1924  ***      0      0      0      0   $curr and $prev
      ***      0      0      0      0   $curr and $prev and $$curr[0] == $$prev[0]
      ***      0      0      0      0   $curr and $prev
      ***      0      0      0      0   $curr and $prev and $$curr[0] > $$prev[0]
1929  ***      0      0      0      0   defined $$curr[5] and $$curr[5] < $$prev[5]
      ***      0      0      0      0   $$curr[7] and defined $$curr[5]
      ***      0      0      0      0   $$curr[7] and defined $$curr[5] and $$misc{'time'} - $$curr[5] - $$prev[8] - $$prev[9] - $$misc{'etime'} > $fudge
1949  ***      0      0      0      0   $$prev[7] and not $is_new
1970  ***      0      0      0      0   $$curr[7] and defined $$curr[5]
2025  ***      0      0      0      0   $find_spec{'busy_time'} and ($$query{'Command'} || '') eq 'Query'
2034  ***      0      0      0      0   $find_spec{'idle_time'} and ($$query{'Command'} || '') eq 'Sleep'
2046  ***      0      0      0      0   defined $find_spec{'ignore'}{$property} and $self->$filter($query, $find_spec{'ignore'}{$property})
2068  ***      0      0      0      0   @matches and $find_spec{'only_oldest'}
2079  ***      0      0      0      0   defined $property && defined $$query{'Id'}
      ***      0      0      0      0   defined $property && defined $$query{'Id'} && $$query{'Id'} == $property
2084  ***      0      0      0      0   defined $property && defined $$query{'User'}
      ***      0      0      0      0   defined $property && defined $$query{'User'} && $$query{'User'} =~ /$property/
2090  ***      0      0      0      0   defined $property && defined $$query{'Host'}
      ***      0      0      0      0   defined $property && defined $$query{'Host'} && $$query{'Host'} =~ /$property/
2096  ***      0      0      0      0   defined $property && defined $$query{'db'}
      ***      0      0      0      0   defined $property && defined $$query{'db'} && $$query{'db'} =~ /$property/
2102  ***      0      0      0      0   defined $property && defined $$query{'State'}
      ***      0      0      0      0   defined $property && defined $$query{'State'} && $$query{'State'} =~ /$property/
2108  ***      0      0      0      0   defined $property && defined $$query{'Command'}
      ***      0      0      0      0   defined $property && defined $$query{'Command'} && $$query{'Command'} =~ /$property/
2114  ***      0      0      0      0   defined $property && defined $$query{'Info'}
      ***      0      0      0      0   defined $property && defined $$query{'Info'} && $$query{'Info'} =~ /$property/
2481  ***      0      0      0      0   $src_host ne $server and $dst_host ne $server
2537  ***     66     25      4      0   $$packet{'syn'} and $$session{'n_queries'} > 0 || $$session{'state'}
2554  ***     33     19      0      0   $$session{'buff'} and $packet_from eq 'client'
2593  ***      0      0      0      0   $$session{'cmd'} and ($$session{'state'} || '') eq 'awaiting_reply'
2612  ***     33      9      0      0   $$session{'cmd'} and ($$session{'state'} || '') eq 'awaiting_reply'
2659  ***     33      0      0      2   $first_byte eq '0a' and length $data >= 33
      ***     33      0      0      2   $first_byte eq '0a' and length $data >= 33 and $data =~ /00{13}/
2681  ***     33      6      0      0   $first_byte eq 'fe' and $$packet{'mysql_data_len'} < 9
2801  ***      0      0      0      0   $$packet{'mysql_data_len'} == 1 and $$session{'state'} eq 'client_auth'
      ***      0      0      0      0   $$packet{'mysql_data_len'} == 1 and $$session{'state'} eq 'client_auth' and $$packet{'number'} == 2
3255  ***     33      0      0      8   $data and $len
3265  ***     33      0      0      8   $code ne '17' and $code ne '19'
      ***     33      0      0      8   $code ne '17' and $code ne '19' and $code ne '1a'
3282  ***      0      0      0      0   $data and $sths
3395  ***     33      0      1      0   $com and $$com{'code'} eq '00'
3481  ***      0      0      0      0   $o and $o->has('tcpdump-errors')
      ***      0      0      0      0   $o and $o->has('tcpdump-errors') and $o->got('tcpdump-errors')
3613         100    201   1186     53   not $got_ts and my($time) = $line =~ /$slow_log_ts_line/o
             100    516    768    103   not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o
      ***     66      0   1274     10   not $got_ac and $line =~ /^# (?:administrator command:.*)$/
             100      5    242     39   not $got_db and my($db) = $line =~ /^use ([^;]+)/
      ***     66      0    227     20   not $got_set and my($setting) = $line =~ /^SET\s+([^;]*)/
3617  ***     66      0     37     16   not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o
3660         100     10   1427      3   not $found_arg and $pos == $len
3680  ***     66      0    296      1   $args{'misc'} and $args{'misc'}{'embed'}
      ***     66    296      0      1   $args{'misc'} and $args{'misc'}{'embed'} and my($e) = $arg =~ /($args{'misc'}{'embed'})/
3738  ***      0      0      0      0   $$event{'ip'} and $$event{'port'}
4072  ***     66    246      0    338   $args{'all'} and $type eq 'num'
      ***     66    246      0    338   $args{'all'} and $type eq 'num' and $$self{'attrib_limit'}
4164  ***     33      0      0    574   defined $vals and @$vals
      ***     33      0      0    574   defined $vals and @$vals and $$args{'cnt'}
4181         100      6      6     46   $v && $v > 0
4216         100     37      1     19   not $bucket_95 and $sum_excl > $top_vals
4218         100     19     19     19   not $median and $total_left <= $mid
4257  ***      0      0      0      0   $global_cnt && $$store{'cnt'}
      ***      0      0      0      0   $$store{'sum'} && $$store{'cnt'}
4281         100      1     12    104   !$args{'total'} || $total < $args{'total'} and !$args{'count'} || $count < $args{'count'}
      ***     66      1     12      0   $args{'ol_attrib'} and !$args{'ol_freq'} || $$classes{$groupby}{$args{'ol_attrib'}}{'cnt'} >= $args{'ol_freq'}
4312         100    337   4355   1605   $_ ne $$self{'groupby'} and not exists $$self{'attributes'}{$_}
4415  ***     33     52      0      0   $$col{'fixed_wdith'} and $$col{'fixed_width'} < length $$col{'name'}
4438  ***     33    164      0      0   $$col{'fixed_width'} and $width > $$col{'fixed_width'}
4493  ***     66      0      8      2   $$self{'truncate_underline'} and 2 + $underline_len > $$self{'line_width'}
4586  ***     33      0      0      6   $global_cnt and $$stats{'globals'}{'ts'}
      ***     66      0      1      5   $global_cnt and $$stats{'globals'}{'ts'} and ($$stats{'globals'}{'ts'}{'max'} || '') gt ($$stats{'globals'}{'ts'}{'min'} || '')
4671  ***     66      0      2     87   $global_cnt and $$store{'ts'}
             100      2     77     10   $global_cnt and $$store{'ts'} and ($$store{'ts'}{'max'} || '') gt ($$store{'ts'}{'min'} || '')
4783  ***     66     87    625      0   $n_marks < 1 and $n_vals > 0
5051  ***     33      0      0      8   $t = $$res[2]{'ts'} and $$t{'min'}
5054  ***     33      0      8      0   $$t{'max'} and $$t{'max'} gt $$t{'min'}
5130  ***     33      0      2      0   $ddl_stmt =~ /CREATE/i and $query =~ /$ddl_stmt\b.+?\bSELECT\b/i
5199  ***      0      0      0      0   $tbl_refs and $from
5251  ***     33      5      0      0   $statements[-2] and $statements[-2] =~ /on duplicate key\s+$/i
5433  ***      0      0      0      0   $trgs and @$trgs
5479  ***      0      0      0      0   $curr and $new
      ***      0      0      0      0   $curr and $new and $curr eq $new
5895  ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete
5933  ***      0      0      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000'
      ***      0      0      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i
5964  ***      0      0      0      0   $engine =~ /InnoDB/i and not $clustered_key
5966  ***      0      0      0      0   $$this_key{'is_unique'} and not $$this_key{'is_nullable'}
5990  ***      0      0      0      0   not $parent =~ /\./ and $$opts{'database'}
6143  ***      0      0      0      0   $attr and $metric
6168  ***      0      0      0      0   defined $data{'ts'} and defined $data{'ts'}{$thing}
6181  ***      0      0      0      0   $review_vals and @$review_vals == 1
6301  ***      0      0      0      0   $PID_file and -f $PID_file
6362  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
6437  ***      0      0      0      0   $src_host ne $server and $dst_host ne $server
6527  ***      0      0      0      0   $rest and $bytes
6696  ***      0      0      0      0   $o and $o->has('tcpdump-errors')
      ***      0      0      0      0   $o and $o->has('tcpdump-errors') and $o->got('tcpdump-errors')
6982         100     47      2     14   not $got_offset and my($offset) = $line =~ /$binlog_line_1/m
             100     33      2     14   not $got_hdr and $line =~ /^#(\d{6}\s+\d{1,2}:\d\d:\d\d)/
7012  ***     66      2      0     13   $got_offset and $got_hdr
7149  ***     33      0      0      7   $thread_id && $cmd
7165  ***     66      3      0      2   $thread_id and $cmd
7269  ***      0      0      0      0   not $server_port and $args{'server_port'}
7302  ***      0      0      0      0   $packet_from eq 'client' and $$packet{'fin'} || $$packet{'rst'}
7392  ***      0      0      0      0   $src_host ne $server and $dst_host ne $server
7458  ***      0      0      0      0   $o and $o->has('tcpdump-errors')
      ***      0      0      0      0   $o and $o->has('tcpdump-errors') and $o->got('tcpdump-errors')
7491  ***      0      0      0      0   $start and $end
7595  ***      0      0      0      0   $$session{'attribs'}{'bytes'} and $have_len >= $$session{'attribs'}{'bytes'}
7622  ***      0      0      0      0   $$session{'attribs'}{'bytes'} and $content_len < $$session{'attribs'}{'bytes'}
7938  ***     66     44      0      1   grep {$_ eq 'GeneralLogParser' unless $_ eq 'genlog';} @{$o->get('type');} and not $o->got('order-by')
7947  ***     33     45      0      0   $review_dsn and !defined($$review_dsn{'D'}) || !defined($$review_dsn{'t'})
7952  ***     33     45      0      0   $o->get('mirror') and !$o->get('execute') || !$o->get('processlist')
7956  ***     33      0     45      0   $o->get('outliers') and grep {not $_ =~ /^\w+:[0-9.]+(?::[0-9.]+)?$/;} @{$o->get('outliers');}
7963  ***      0      0      0      0   $rate_max and $rate_max > 0
      ***      0      0      0      0   $rate_max and $rate_max > 0 and $rate_max <= 100
7969  ***      0      0      0      0   $step and $step < 1 || $step > 100
8082  ***      0      0      0      0   $attr and $metric
8130  ***      0      0      0      0   $sth and not $err
8150  ***      0      0      0      0   $o->get('mirror') and time - $cur_time > $o->get('mirror')
8309  ***     66      1      0      1   not $_ =~ /\./ and my $db = $$event{'db'} || $$event{'Schema'}
8350  ***     33      1      0      0   -f $filter and -r $filter
8371  ***     66      0    320     11   $$event{'arg'} and $$event{'arg'} =~ /^# administrator/
8462  ***     33      2      0      0   $db and !$curdb || $db ne $curdb
8472  ***     33      1      0      0   $o->get('mirror') and $end - $cur_time > $o->get('mirror')
8620  ***     66      0     45     45   $oktorun and !$o->get('iterations') || $iters++ < $o->get('iterations')
8632  ***     33      0      0    457   $oktorun and $start == $end || $now < $end
8723         100      3     36      6   $o->get('report') and $o->get('report-format')->{'header'}
8783  ***     66      0      7     39   $expected_range && (@worst < $$expected_range[0] || @worst > $$expected_range[1])
8796         100      3      1     42   $o->get('report') and $o->get('report-format')->{'query_report'}
             100      4     34      8   $o->get('report') and $o->get('report-format')->{'query_report'} and @groupby > 1 || $groupby ne 'fingerprint'
8834  ***     33    104      0      0   $$stats{'Statement_id'} and $item =~ /^(?:prepare|execute) /
8879  ***      0      0      0      0   $$review_vals{'reviewed_by'} and not $o->get('report-all')
8914         100     12      3     89   $o->get('report') and $o->get('report-format')->{'query_report'}
8950  ***     66     10     79      0   $groupby eq 'fingerprint' and $o->get('fingerprints')
8968  ***     33      0      0     41   $o->get('for-explain') and $converted
      ***     66      0     26     15   $o->get('for-explain') and $converted and $converted =~ /^[\(\s]*select/i
9043         100      3     35      8   $o->get('report') and $o->get('report-format')->{'profile'}
9075  ***     66      3     43      0   $o->get('report') and $o->get('report-format')->{'prepared'}
9214  ***     66     20      0      3   $dbh and $query
9331         100     50      1      1   not $ea->type_for($orderby_attrib) and $orderby_attrib ne 'Query_time'

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
44    ***     50      0      6   $ENV{'MKDEBUG'} || 0
115          100      5      2   $prev ||= {}
116   ***     50      0      7   $defaults ||= {}
189   ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
202   ***     50      0      7   $self->prop('dbidriver') || ''
206   ***      0      0      0   $$info{'D'} || ''
212          100      1      6   $$info{'D'} || ''
234   ***     50      7      0   $opts ||= {}
329   ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
345   ***      0      0      0   $level ||= 0
346   ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
396   ***     50      0      6   $ENV{'MKDEBUG'} || 0
463   ***     50      0      6   $ENV{'MKDEBUG'} || 0
482   ***     50     45      0   $program_name ||= $PROGRAM_NAME
483   ***     50     45      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
485   ***     50     45      0   $args{'prompt'} || '<options>'
      ***     50     45      0   $args{'dp'} || undef
527   ***     50      0     45   $file ||= '/home/daniel/dev/maatkit/mk-query-digest/mk-query-digest'
668   ***     50   2835      0   $$opt{'group'} ||= 'default'
950   ***      0      0      0   $s || 's'
959   ***      0      0      0   $prefix || ''
987   ***      0      0      0   $pre || ''
994   ***     50     45      0   $val || ''
997          100    452     44   $val || ''
1055  ***      0      0      0   $$self{'description'} || ''
1124  ***      0      0      0   $s ||= 's'
1150  ***      0      0      0   $$opt{'type'} || ''
1300  ***     50      0      6   $ENV{'MKDEBUG'} || 0
1354  ***     50      0    633   $args{'p'} || 0
1356         100    417    216   $of ||= 1
1361  ***      0      0      0   $secs ||= 0
1508  ***     50      0      6   $ENV{'MKDEBUG'} || 0
1854  ***     50      0      6   $ENV{'MKDEBUG'} || 0
1907  ***      0      0      0   $$self{'prev_rows'} ||= []
1908  ***      0      0      0   $$self{'new_rows'} ||= []
2025  ***      0      0      0   $$query{'Command'} || ''
2034  ***      0      0      0   $$query{'Command'} || ''
2145  ***     50      0      6   $ENV{'MKDEBUG'} || 0
2290  ***     50      0      6   $ENV{'MKDEBUG'} || 0
2455  ***     50      3      0   $server_port ||= '3306|mysql'
2593  ***      0      0      0   $$session{'state'} || ''
2612  ***      0      0      0   $$session{'state'} || ''
2641         100      7      3   $$session{'server_seq'} || ''
2682  ***     50      1      0   $$session{'state'} || ''
2861         100      6      3   $$session{'client_seq'} || ''
2871         100      2      7   $$session{'state'} || ''
      ***     50      0      7   $$session{'state'} || ''
      ***     50      0      7   $$session{'state'} || ''
2989         100      1      8   $$event{'Error_no'} || 'none'
      ***     50      0      9   $$event{'Rows_affected'} || 0
      ***     50      0      9   $$event{'Warning_count'} || 0
3292  ***      0      0      0   int(($$sth{'num_params'} + 7) / 8) || 1
3544  ***     50      0      6   $ENV{'MKDEBUG'} || 0
3722  ***     50      0      6   $ENV{'MKDEBUG'} || 0
3820  ***     50     46      0   $args{'attributes'} || {}
3848  ***     50     46      0   $args{'unroll_limit'} || 1000
3895         100   3347   1613   $$self{'result_classes'}{$val}{$attrib} ||= {}
3896         100   4356    604   $$self{'result_globals'}{$attrib} ||= {}
3909         100   4424    121   $$samples{$val} ||= $event
4169         100    312    214   $$args{'max'} || 0
4184  ***     50     29      0   $$args{'max'} || 0
4185         100     23      6   $$args{'min'} || 0
4230  ***     50     19      0   $$args{'max'} || 0
             100     17      2   $$args{'min'} || 0
4381  ***     50      0      6   $ENV{'MKDEBUG'} || 0
4459  ***     50     10      0   $$self{'line_prefix'} || ''
4566  ***      0      0      0   $rss || 0
      ***      0      0      0   $vsz || 0
4583  ***     50      6      0   $$stats{'globals'}{$opts{'worst'}}{'cnt'} || 0
4586  ***     50      6      0   $$stats{'globals'}{'ts'}{'max'} || ''
      ***     50      6      0   $$stats{'globals'}{'ts'}{'min'} || ''
4604         100      5      1   $qps || 0
             100      3      3   $conc || 0
4671         100     78      9   $$store{'ts'}{'max'} || ''
             100     78      9   $$store{'ts'}{'min'} || ''
4684  ***     50     89      0   $opts{'rank'} || 0
             100     10     79   $qps || 0
             100      8     81   $conc || 0
             100     69     20   $$sample{'pos_in_log'} || 0
4782         100    624     88   $vals_per_mark || 1
4822  ***     50     14      0   $$stats{'sum'} || 0
4885  ***     50    615      0   $ea->type_for($attrib) || ''
4929  ***     50      0      6   $ENV{'MKDEBUG'} || 0
5093  ***     50      0      6   $ENV{'MKDEBUG'} || 0
5313  ***      0      0      0   $word =~ tr/(// || 0
5314  ***      0      0      0   $word =~ tr/)// || 0
5380  ***     50      0      6   $ENV{'MKDEBUG'} || 0
5650  ***      0      0      0   $$_[1] || ''
5690  ***     50      0      6   $ENV{'MKDEBUG'} || 0
5909  ***      0      0      0   $engine || undef
5932  ***      0      0      0   $type || $special || 'BTREE'
6019  ***      0      0      0   $$tbl_struct{'engine'} || ''
6021  ***      0      0      0   $clustered_key ||= ''
6076  ***     50      0      6   $ENV{'MKDEBUG'} || 0
6226  ***     50      0      6   $ENV{'MKDEBUG'} || 0
6407  ***     50      0      6   $ENV{'MKDEBUG'} || 0
6414  ***      0      0      0   $server_port ||= '11211'
6585  ***      0      0      0   $$session{'state'} || ''
6674  ***      0      0      0   $$session{'val'} || ''
      ***      0      0      0   $$session{'flags'} || 0
      ***      0      0      0   $$session{'exptime'} || 0
      ***      0      0      0   $$session{'bytes'} || 0
6772  ***     50      0      6   $ENV{'MKDEBUG'} || 0
6914  ***     50      0      6   $ENV{'MKDEBUG'} || 0
7107  ***     50      0      6   $ENV{'MKDEBUG'} || 0
7263  ***     50      0      6   $ENV{'MKDEBUG'} || 0
7367  ***      0      0      0   $$session{'ts_min'} || ''
7369  ***      0      0      0   $$session{'ts_max'} || ''
7439  ***      0      0      0   $$session{'start_request'} || 0
7440  ***      0      0      0   $$session{'start_reply'} || 0
7441  ***      0      0      0   $$session{'end_reply'} || 0
7557  ***     50      0      6   $ENV{'MKDEBUG'} || 0
7661  ***      0      0      0   $$session{'state'} || ''
7675  ***      0      0      0   $$session{'attribs'}{'Virtual_host'} || ''
7761  ***     50      0      6   $ENV{'MKDEBUG'} || 0
7790  ***      0      0      0   sum(@{$$self{'int_rates'};}) || 0
      ***      0      0      0   scalar @{$$self{'int_rates'};} || 1
7846  ***      0      0      0   $$self{'stats'}{'rate_avg'} || 0
7860  ***      0      0      0   $$self{'stats'}{'rate_avg'} || 0
7899  ***     50      0      6   $ENV{'MKDEBUG'} || 0
7978         100     45      1   $orderby[$i] ||= $default_orderby
8211         100      2     43   $aux_dbh ||= $qv_dbh || $qv_dbh2 || $ex_dbh || $ps_dbh || $ep_dbh
8232  ***      0      0      0   $ts || 0
8257  ***      0      0      0   $ts || 0
8416  ***      0      0      0   $step ||= 5
8421  ***      0      0      0   $prof{'callback'}{'execute'}{'time'} || 0
      ***      0      0      0   $prof{'total'}{'time'} || 0
8451  ***     50      0      2   $$event{'Skip_exec'} || ''
8616  ***     50      0     45   $o->get('run-time') || 0
8757         100     45      1   $o->get('limit')->[$i] || '95%:20'
8766         100      3      2   $ea->results->{'globals'}{$orderby_attrib}{'sum'} || 0
8769  ***     50     46      0   $orderby_func || 'cnt'
8813  ***     50    104      0   $$sample{'arg'} || ''
8883  ***      0      0      0   $$sample{'arg'} || ''
8990  ***      0      0      0   $$sample{'arg'} || ''
8997  ***      0      0      0   $$sample{'arg'} || ''
9060         100     16     10   $total_r || 1
9094  ***      0      0      0   $total_r || 1
9096  ***      0      0      0   $total_r || 1
9098  ***      0      0      0   $$item{'prep_cnt'} || 0
      ***      0      0      0   $$item{'exec_cnt'} || 0
9116  ***     50      0     45   $o->get('run-time') || 0
9135  ***      0      0      0   $prof{'callback'}{$name}{'time'} || 0
9136  ***      0      0      0   $prof{'total'}{'time'} || 1
9138  ***      0      0      0   $prof{'callback'}{$name}{'count'} || 0
9160  ***     50      4      0   $stats{$stat} || 0
9352  ***      0      0      0   $t ||= 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
225   ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
226   ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
227   ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
228   ***      0      0      0      0   $$dsn{'u'} ||= $user
229   ***      0      0      0      0   $$dsn{'D'} ||= $db
483   ***     33     45      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***     33     45      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
945   ***     66     45      0   1930   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
             100    270    226   1434   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1364  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
1396  ***     66    293      0   2772   $num =~ /\./ || $n
1562  ***      0      0      0      0   $last_length || $query_length + 1
1692  ***     33      0     94      0   $args{'QueryParser'} || $$self{'QueryParser'}
1765  ***     66     14      0     27   $query =~ s/
                 \A.*?
                 update\s+(.*?)
                 \s+set\b(.*?)
                 (?:\s*where\b(.*?))?
                 (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
                 \Z
              /__update_to_select($1, $2, $3, $4);/eisx or $query =~ s/
                    \A.*?
                    (?:insert|replace)\s+
                    .*?\binto\b(.*?)\(([^\)]+)\)\s*
                    values?\s*(\(.*?\))\s*
                    (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
                    \Z
                 /__insert_to_select($1, $2, $3);/eisx
1923  ***      0      0      0      0   $curr or $prev
1924  ***      0      0      0      0   not $curr or $curr and $prev and $$curr[0] > $$prev[0]
1929  ***      0      0      0      0   not $$curr[7] or $$prev[7] ne $$curr[7]
2537  ***     33      0      0      4   $$session{'n_queries'} > 0 || $$session{'state'}
2604  ***      0      0      0      0   $$session{'buff_left'} ||= $$packet{'mysql_data_len'} - ($$packet{'data_len'} - 4)
2724  ***      0      0      0      0   $com eq '03' or $com eq '17'
      ***      0      0      0      0   $com eq '03' or $com eq '17' or $com eq '1a'
2777  ***      0      0      0      0   $com eq '03' or $com eq '17'
2820  ***     33      6      0      0   $com eq '03' or $com eq '17'
3581         100      1    309     39   defined($stmt = shift @$pending) or defined($stmt = &$next_event())
4126  ***     33      0      0   5994   $bucket < 0 or $bucket > 999
4168         100    417    109     48   $n_vals == 1 or $$args{'max'} == $$args{'min'}
4219         100     13      4      2   $cutoff % 2 || $val > 1
4281         100    105     11      1   !$args{'total'} || $total < $args{'total'}
      ***     66      0    104     12   !$args{'count'} || $count < $args{'count'}
      ***     33      0      0     12   !$args{'ol_freq'} || $$classes{$groupby}{$args{'ol_attrib'}}{'cnt'} >= $args{'ol_freq'}
4641  ***     33      0      0      9   $$store{'sum'} > 0 or not $opts{'no_zero_bool'}
4740  ***     66     14      0    201   $$vals{'sum'} > 0 or not $opts{'no_zero_bool'}
5227  ***      0      0      0      0   $alias or $tbl
5342  ***     33      1      0      0   $type =~ /^$data_manip_stmts\b/ or $type =~ /^$data_def_stmts\b/
5491  ***      0      0      0      0   not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl}
5530  ***      0      0      0      0   not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl}
5560  ***      0      0      0      0   not $$self{'cache'} or not $$self{'triggers'}{$db}
5594  ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'} or $like
5613  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db} or $like
5627  ***      0      0      0      0   $tbl{'type'} || $tbl{'comment'}
      ***      0      0      0      0   $tbl{'engine'} ||= $tbl{'type'} || $tbl{'comment'}
5639  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db} or $like
5783  ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'}
      ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
5862  ***      0      0      0      0   not $$row[0] or $$row[0] ne $tbl
5883  ***      0      0      0      0   $$row{'privileges'} || $$row{'Privileges'}
5932  ***      0      0      0      0   $type || $special
6151  ***      0      0      0      0   $_ eq 'ts_min' || $_ eq 'ts_max'
6375  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
6514  ***      0      0      0      0   $$session{'cmd'} eq 'incr' or $$session{'cmd'} eq 'decr'
6603  ***      0      0      0      0   $cmd eq 'set' or $cmd eq 'add'
      ***      0      0      0      0   $cmd eq 'set' or $cmd eq 'add' or $cmd eq 'replace'
      ***      0      0      0      0   $cmd eq 'incr' or $cmd eq 'decr'
6810  ***      0      0      0      0   not $$event{'cmd'} or not $$event{'key'}
7143         100      2      5      1   defined($line = shift @$pending) or defined($line = &$next_event())
7302  ***      0      0      0      0   $$packet{'fin'} || $$packet{'rst'}
7592  ***      0      0      0      0   $$packet{'content_len'} || $$packet{'data_len'}
7647  ***      0      0      0      0   $$session{'ts_max'} || $$packet{'ts'}
7670  ***      0      0      0      0   not $request or not $page
7679  ***      0      0      0      0   $request eq 'get' or $request eq 'post'
7787  ***      0      0      0      0   $args{'misc'}{'time'} || time
7820  ***      0      0      0      0   $args{'stats'}{'throttle_rate_min'} || ()
7822  ***      0      0      0      0   $args{'stats'}{'throttle_rate_max'} || ()
7947  ***      0      0      0      0   !defined($$review_dsn{'D'}) || !defined($$review_dsn{'t'})
7952  ***      0      0      0      0   !$o->get('execute') || !$o->get('processlist')
7969  ***      0      0      0      0   $step < 1 || $step > 100
8211  ***     33      0      0     43   $qv_dbh || $qv_dbh2
      ***     66      0      1     42   $qv_dbh || $qv_dbh2 || $ex_dbh
      ***     66      1      0     42   $qv_dbh || $qv_dbh2 || $ex_dbh || $ps_dbh
             100      1      1     41   $qv_dbh || $qv_dbh2 || $ex_dbh || $ps_dbh || $ep_dbh
8309  ***     33      1      0      0   $$event{'db'} || $$event{'Schema'}
8322  ***     33      0      0     45   $o->get('type') eq 'memcached' or $o->get('type') eq 'http'
8462  ***      0      0      0      0   !$curdb || $db ne $curdb
8620  ***     66      0     45     45   !$o->get('iterations') || $iters++ < $o->get('iterations')
8632  ***     33    457      0      0   $start == $end || $now < $end
8687  ***     33   2147      0      0   $callback_names{$callback} || $callback
8783  ***     66     39      0      7   @worst < $$expected_range[0] || @worst > $$expected_range[1]
8796         100      2      6     34   @groupby > 1 || $groupby ne 'fingerprint'
8906  ***     33    104      0      0   $o->get('for-explain') or $o->get('table-access')
8938  ***      0      0      0      0   not $val or $val ne '0000-00-00 00:00:00'
9134  ***      0      0      0      0   $callback_names{$callback} || $callback
9192         100     38     22     14   $db || $default_db
9250  ***     66      1      1      0   not $dbh or not $dbh->ping


Covered Subroutines
-------------------

Subroutine                         Count Location                                                     
---------------------------------- ----- -------------------------------------------------------------
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1294
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1295
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1296
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1297
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1298
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1300
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1501
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1502
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1506
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1508
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1845
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1846
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1847
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1849
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1854
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1867
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:20  
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:21  
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2138
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2139
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2140
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2141
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2145
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2262
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2263
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2264
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2271
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2290
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2323
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2406
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:32  
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:33  
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:34  
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:35  
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3539
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3540
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3541
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3542
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3544
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3718
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3719
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3720
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3722
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3800
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3801
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3802
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3804
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3805
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3806
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3807
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3808
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3809
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:389 
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:390 
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:394 
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:396 
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4376
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4377
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4378
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4379
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4381
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4383
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:44  
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4530
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4531
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4532
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4537
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4538
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4539
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:456 
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:457 
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:459 
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:460 
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:461 
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:463 
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4924
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4925
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4926
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4929
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4930
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4931
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4932
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5089
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5090
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5091
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5093
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5375
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5376
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5378
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5380
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5682
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5683
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5684
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5685
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5690
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6069
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6070
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6071
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6074
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6076
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6220
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6221
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6223
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6224
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6226
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6398
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6399
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6400
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6402
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6407
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6763
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6764
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6765
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6767
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6772
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6905
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6906
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6907
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6909
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6914
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7098
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7099
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7100
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7102
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7107
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7249
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7250
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7251
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7258
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7263
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7546
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7548
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7549
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7550
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7552
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7557
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7750
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7751
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7752
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7754
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7755
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7756
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7761
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7887
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7888
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7889
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7890
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7891
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7892
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7899
BEGIN                                  6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7901
__ANON__                             153 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4342
__ANON__                             447 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8193
__ANON__                             317 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8273
__ANON__                               2 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8301
__ANON__                              11 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8335
__ANON__                             331 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8369
__ANON__                               2 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8448
__ANON__                             133 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:846 
__ANON__                             339 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8542
__ANON__                               8 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8557
__ANON__                             420 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8611
__ANON__                             747 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8613
__ANON__                              45 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8672
__ANON__                              11 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:9010
__delete_to_select                     1 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1787
__distill_tables                      94 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1691
__update_to_select                    14 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1812
_delete_buff                           9 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3515
_get_participants                     45 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:746 
_make_event                            9 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2977
_packet_from_client                    9 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2855
_packet_from_server                   10 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2635
_parse_packet                         35 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2183
_parse_specs                          45 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:632 
_pod_to_specs                         45 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:526 
_read_config_file                    180 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1199
_set_option                          133 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:792 
_validate_type                      2835 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:941 
add_line                              30 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4426
add_new_attributes                   337 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4308
aggregate                            339 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3868
aggregate                              8 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4955
bucket_idx                          4796 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4117
bucket_value                        6000 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4124
buckets_of                            89 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4133
calculate_statistical_metrics        574 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4156
chart_distro                          89 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4759
check_orderby_attrib                  52 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:9329
clean_query                            5 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5262
convert_to_select                     41 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1745
detect_compression                     1 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3392
disconnect                             5 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:338 
distill                               98 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1712
distill_verbs                        103 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1636
event_report                          89 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4659
events_processed                       6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4334
extract_tables                       104 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:9184
find_role                              2 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:9249
fingerprint                          317 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1594
format_bool_attrib                    14 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4820
format_string_list                   206 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4827
get                                 3615 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1008
get_attributes                        45 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4329
get_cxn_params                         7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:199 
get_dbh                                7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:233 
get_defaults                          46 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:782 
get_defaults_files                    45 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:521 
get_opts                              45 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:809 
get_report                            10 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4457
get_specs                             45 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:514 
get_tables                           205 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5118
global_report                          6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4579
got                                  226 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1016
has                                   90 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1024
has_derived_table                      3 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5175
main                                  45 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7917
make_alt_attrib                      604 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4339
make_alt_attrib                       45 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:9285
make_checksum                        176 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1478
make_handler                         999 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3982
make_handler                           1 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4971
make_header                           95 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4792
make_inherit_attribs                  45 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:9311
make_label                           864 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4803
micro_t                             1169 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1323
new                                    6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1531
new                                    3 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2148
new                                    3 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2451
new                                   39 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3547
new                                   46 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3816
new                                    6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:399 
new                                   10 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4389
new                                   45 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4553
new                                    8 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:47  
new                                   45 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:477 
new                                    1 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4935
new                                    6 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5113
new                                    2 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6917
new                                    1 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7110
parse                                 12 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:109 
parse_client_handshake_packet          2 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3221
parse_com_packet                       8 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3254
parse_error_packet                     1 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3130
parse_event                           38 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2154
parse_event                           35 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2470
parse_event                          349 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3567
parse_event                           17 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6930
parse_event                            8 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7131
parse_flags                            4 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3357
parse_options                          5 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:160 
parse_server_handshake_packet          2 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3196
parse_timestamp                      206 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1420
percentage_of                        633 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1353
port_number                           70 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2234
print_explain                         23 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:9213
print_tables                          80 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:9199
prop                                  71 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:100 
query_type                             5 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5339
quote                                 61 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:404 
remove_mysql_header                   19 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3459
report                                 1 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5044
reset_aggregated_data                 46 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3854
reset_aggregated_data                  1 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4950
results                              397 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3963
results                                1 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4966
set                                   45 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1030
set_columns                           10 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4411
set_title                              8 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4405
shorten                             3065 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1387
shorten                               79 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1548
sort_attribs                          95 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4864
split                                  5 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5234
split_unquote                         79 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:428 
strip_comments                        98 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1537
tcp_timestamp                          9 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3025
timestamp_diff                         9 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3031
to_num                                76 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3095
to_string                             16 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3047
top_events                            46 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4270
type_for                            2495 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3977
unix_timestamp                        30 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1432
usage_or_errors                       45 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1066

Uncovered Subroutines
---------------------

Subroutine                         Count Location                                                     
---------------------------------- ----- -------------------------------------------------------------
DESTROY                                0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6374
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8128
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8162
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8214
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8224
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8249
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8327
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8387
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8404
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8421
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8434
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8567
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8608
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:9359
__insert_to_select                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1795
__shorten                              0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1582
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1275
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1485
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1827
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2119
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2243
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3521
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3700
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:373 
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3782
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4358
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4510
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4903
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5071
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5357
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5664
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6049
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6202
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6380
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6728
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6887
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7080
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7231
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7529
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7732
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7864
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:9382
_find_match_Command                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2107
_find_match_Host                       0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2089
_find_match_Id                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2078
_find_match_Info                       0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2113
_find_match_State                      0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2101
_find_match_User                       0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2083
_find_match_db                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2095
_get_errors_fh                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3476
_get_errors_fh                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6691
_get_errors_fh                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7453
_get_rows                              0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2010
_get_session                           0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7386
_make_PID_file                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6339
_make_unrolled_loops                   0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3923
_packet_from_client                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6578
_packet_from_client                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7432
_packet_from_client                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7654
_packet_from_server                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6493
_packet_from_server                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7428
_packet_from_server                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7569
_parse_header                          0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7700
_parse_packet                          0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7328
_remove_PID_file                       0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6361
_save_rate_avg                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7855
_time_to_check                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7836
_use_db                                0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5471
any_unix_timestamp                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1447
as_string                              0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:173 
attributes                             0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3972
check_PID_file                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6298
check_table                            0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5841
clone                                  0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1252
convert_select_list                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1778
copy                                   0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:355 
daemonize                              0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6247
decode_len                             0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3062
descr                                  0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1054
dump                                   0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5414
errors                                 0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1044
fail_session                           0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3493
fail_session                           0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6708
fail_session                           0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7470
fill_in_dsn                            0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:221 
find                                   0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2017
find_best_index                        0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5795
find_possible_keys                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5813
fingerprint                            0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6843
get_aliases                            0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5182
get_columns                            0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5528
get_create_table                       0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5490
get_databases                          0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5593
get_engine                             0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5906
get_fks                                0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5980
get_groups                             0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:787 
get_hostname                           0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:328 
get_keys                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5913
get_lcb                                0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3113
get_review_info                        0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6178
get_sth_id                             0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3350
get_table_list                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5638
get_table_status                       0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5612
get_tmp_table                          0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5548
get_triggers                           0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5559
handle_delete                          0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6877
handle_incr_decr_cmd                   0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6882
handle_retr_cmd                        0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6863
handle_storage_cmd                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6849
header                                 0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4558
literal_like                           0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:439 
make_PID_file                          0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6329
make_event                             0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1989
make_event                             0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6673
make_event                             0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7436
metrics                                0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4246
new                                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1870
new                                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3725
new                                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5407
new                                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5694
new                                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6084
new                                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6229
new                                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6410
new                                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6800
new                                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7266
new                                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7560
new                                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7764
opts                                   0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:758 
parse                                  0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5705
parse_event                            0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1881
parse_event                            0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6426
parse_event                            0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6806
parse_event                            0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7282
parse_execute_packet                   0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3281
parse_ok_packet                        0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3152
parse_ok_prepared_statement_packet     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3176
print_active_handles                   0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:344 
print_errors                           0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1079
print_usage                            0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1089
prompt                                 0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1049
prompt_noecho                          0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1164
quote_val                              0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:412 
rate_avg                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7845
read_para_after                        0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1233
read_timeout                           0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:9350
remove_auto_increment                  0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6009
remove_secondary_indexes               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6015
review_cols                            0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6197
save_error                             0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1039
secs_to_time                           0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1360
set_defaults                           0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:770 
set_history_options                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6134
set_review_history                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6166
set_review_info                        0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6188
short_opts                             0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:764 
sig_int                                0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:9273
skip_probability                       0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7850
sort_indexes                           0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5776
split_subquery                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5272
throttle                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7786
timestamp_diff                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6736
timestamp_diff                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7490
to_double                              0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3108
ts                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1404
uncompress_data                        0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3370
uncompress_data                        0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7507
uncompress_packet                      0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3411
unpack_string                          0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3052
usage                                  0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:182 
wrap_in_derived                        0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1819
write                                  0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3730


