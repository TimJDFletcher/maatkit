---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...ry-digest/mk-query-digest   50.7   38.0   34.0   62.6    n/a  100.0   46.1
Total                          50.7   38.0   34.0   62.6    n/a  100.0   46.1
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:38:53 2010
Finish:       Fri Feb 19 16:38:53 2010

Run:          ./101_slowlog_analyses.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:38:54 2010
Finish:       Fri Feb 19 16:39:00 2010

Run:          ./102_binlog_analyses.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:39:06 2010
Finish:       Fri Feb 19 16:39:06 2010

Run:          ./103_genlog_analyses.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:39:12 2010
Finish:       Fri Feb 19 16:39:13 2010

Run:          ./104_mysql_analyses.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:39:19 2010
Finish:       Fri Feb 19 16:39:19 2010

Run:          ./105_memcached_analyses.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:39:25 2010
Finish:       Fri Feb 19 16:39:28 2010

Run:          ./106_http_analyses.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:39:29 2010
Finish:       Fri Feb 19 16:39:29 2010

Run:          ./107_option_sanity.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:39:31 2010
Finish:       Fri Feb 19 16:39:31 2010

Run:          ./108_prepared_statements_analyses.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:39:33 2010
Finish:       Fri Feb 19 16:39:34 2010

Run:          ./109_continue_on_error.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:39:40 2010
Finish:       Fri Feb 19 16:39:40 2010

Run:          ./110_daemon.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:39:42 2010
Finish:       Fri Feb 19 16:39:43 2010

Run:          ./111_attrib_inheritance.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:39:45 2010
Finish:       Fri Feb 19 16:39:45 2010

Run:          ./112_since_until.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:39:47 2010
Finish:       Fri Feb 19 16:39:49 2010

Run:          ./113_group_by_order_by.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:39:51 2010
Finish:       Fri Feb 19 16:39:51 2010

Run:          ./114_sample.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:39:53 2010
Finish:       Fri Feb 19 16:39:53 2010

Run:          ./115_standard_options.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:39:55 2010
Finish:       Fri Feb 19 16:39:56 2010

Run:          ./116_run_time.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:39:58 2010
Finish:       Fri Feb 19 16:40:01 2010

Run:          ./117_collect_and_report_cycles.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:40:03 2010
Finish:       Fri Feb 19 16:40:08 2010

Run:          ./118_explain_partitions.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:40:10 2010
Finish:       Fri Feb 19 16:40:10 2010

Run:          ./119_review.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:40:12 2010
Finish:       Fri Feb 19 16:40:15 2010

Run:          ./120_explain.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:40:17 2010
Finish:       Fri Feb 19 16:40:17 2010

Run:          ./121_mirror.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:40:23 2010
Finish:       Fri Feb 19 16:40:34 2010

Run:          ./122_read_timeout.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:40:36 2010
Finish:       Fri Feb 19 16:40:41 2010

Run:          ./123_execute.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:40:44 2010
Finish:       Fri Feb 19 16:40:45 2010

Run:          ./201_issue_232.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:40:50 2010
Finish:       Fri Feb 19 16:40:51 2010

Run:          ./202_issue_687.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:40:52 2010
Finish:       Fri Feb 19 16:40:53 2010

Run:          ./203_issue_565.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:40:54 2010
Finish:       Fri Feb 19 16:40:55 2010

Run:          ./204_issue_360.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:40:56 2010
Finish:       Fri Feb 19 16:41:00 2010

Run:          ./205_issue_514.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Feb 19 16:41:01 2010
Finish:       Fri Feb 19 16:41:01 2010

/home/daniel/dev/maatkit/mk-query-digest/mk-query-digest

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This program is copyright 2007-@CURRENTYEAR@ Percona Inc.
4                                                     # Feedback and improvements are welcome.
5                                                     #
6                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
7                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
8                                                     # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
9                                                     #
10                                                    # This program is free software; you can redistribute it and/or modify it under
11                                                    # the terms of the GNU General Public License as published by the Free Software
12                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
13                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
14                                                    # licenses.
15                                                    #
16                                                    # You should have received a copy of the GNU General Public License along with
17                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
18                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
19                                                    
20             7                    7            63   use strict;
               7                                 19   
               7                                 51   
21             7                    7            44   use warnings FATAL => 'all';
               7                                 19   
               7                                 54   
22                                                    
23                                                    our $VERSION = '@VERSION@';
24                                                    our $DISTRIB = '@DISTRIB@';
25                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5819 $ =~ m/(\d+)/g, 0));
26                                                    
27                                                    # ###########################################################################
28                                                    # DSNParser package 5266
29                                                    # ###########################################################################
30                                                    package DSNParser;
31                                                    
32             7                    7            48   use strict;
               7                                 16   
               7                                 37   
33             7                    7            44   use warnings FATAL => 'all';
               7                                 16   
               7                                 33   
34             7                    7            44   use English qw(-no_match_vars);
               7                                 22   
               7                                 53   
35             7                    7            52   use Data::Dumper;
               7                                 16   
               7                                 59   
36                                                    $Data::Dumper::Indent    = 0;
37                                                    $Data::Dumper::Quotekeys = 0;
38                                                    
39                                                    eval {
40                                                       require DBI;
41                                                    };
42                                                    my $have_dbi = $EVAL_ERROR ? 0 : 1;
43                                                    
44    ***      7            50      7            49   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 15   
               7                                103   
45                                                    
46                                                    sub new {
47             9                    9            61      my ( $class, @opts ) = @_;
48             9                                238      my $self = {
49                                                          opts => {
50                                                             A => {
51                                                                desc => 'Default character set',
52                                                                dsn  => 'charset',
53                                                                copy => 1,
54                                                             },
55                                                             D => {
56                                                                desc => 'Database to use',
57                                                                dsn  => 'database',
58                                                                copy => 1,
59                                                             },
60                                                             F => {
61                                                                desc => 'Only read default options from the given file',
62                                                                dsn  => 'mysql_read_default_file',
63                                                                copy => 1,
64                                                             },
65                                                             h => {
66                                                                desc => 'Connect to host',
67                                                                dsn  => 'host',
68                                                                copy => 1,
69                                                             },
70                                                             p => {
71                                                                desc => 'Password to use when connecting',
72                                                                dsn  => 'password',
73                                                                copy => 1,
74                                                             },
75                                                             P => {
76                                                                desc => 'Port number to use for connection',
77                                                                dsn  => 'port',
78                                                                copy => 1,
79                                                             },
80                                                             S => {
81                                                                desc => 'Socket file to use for connection',
82                                                                dsn  => 'mysql_socket',
83                                                                copy => 1,
84                                                             },
85                                                             u => {
86                                                                desc => 'User for login if not current user',
87                                                                dsn  => 'user',
88                                                                copy => 1,
89                                                             },
90                                                          },
91                                                       };
92             9                                 37      foreach my $opt ( @opts ) {
93            14                                 36         MKDEBUG && _d('Adding extra property', $opt->{key});
94            14                                117         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
95                                                       }
96             9                                119      return bless $self, $class;
97                                                    }
98                                                    
99                                                    sub prop {
100           80                   80           497      my ( $self, $prop, $value ) = @_;
101           80    100                         448      if ( @_ > 2 ) {
102           54                                207         MKDEBUG && _d('Setting', $prop, 'property');
103           54                                234         $self->{$prop} = $value;
104                                                      }
105           80                                472      return $self->{$prop};
106                                                   }
107                                                   
108                                                   sub parse {
109           12                   12           354      my ( $self, $dsn, $prev, $defaults ) = @_;
110           12    100                          78      if ( !$dsn ) {
111            5                                 12         MKDEBUG && _d('No DSN to parse');
112            5                                 24         return;
113                                                      }
114            7                                 22      MKDEBUG && _d('Parsing', $dsn);
115            7           100                   38      $prev     ||= {};
116   ***      7            50                   49      $defaults ||= {};
117            7                                 36      my %given_props;
118            7                                 27      my %final_props;
119            7                                 23      my %opts = %{$self->{opts}};
               7                                 99   
120                                                   
121            7                                 80      foreach my $dsn_part ( split(/,/, $dsn) ) {
122   ***     29     50                         286         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
123           29                                157            $given_props{$prop_key} = $prop_val;
124                                                         }
125                                                         else {
126   ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
127   ***      0                                  0            $given_props{h} = $dsn_part;
128                                                         }
129                                                      }
130                                                   
131            7                                 49      foreach my $key ( keys %opts ) {
132           61                                159         MKDEBUG && _d('Finding value for', $key);
133           61                                384         $final_props{$key} = $given_props{$key};
134   ***     61     50     66                  588         if (   !defined $final_props{$key}
      ***                   33                        
135                                                              && defined $prev->{$key} && $opts{$key}->{copy} )
136                                                         {
137   ***      0                                  0            $final_props{$key} = $prev->{$key};
138   ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
139                                                         }
140           61    100                         332         if ( !defined $final_props{$key} ) {
141           32                                120            $final_props{$key} = $defaults->{$key};
142           32                                113            MKDEBUG && _d('Copying value for', $key, 'from defaults');
143                                                         }
144                                                      }
145                                                   
146            7                                 47      foreach my $key ( keys %given_props ) {
147   ***     29     50                         147         die "Unrecognized DSN part '$key' in '$dsn'\n"
148                                                            unless exists $opts{$key};
149                                                      }
150   ***      7     50                          54      if ( (my $required = $self->prop('required')) ) {
151   ***      0                                  0         foreach my $key ( keys %$required ) {
152   ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
153                                                         }
154                                                      }
155                                                   
156            7                                 67      return \%final_props;
157                                                   }
158                                                   
159                                                   sub parse_options {
160            5                    5            28      my ( $self, $o ) = @_;
161   ***      5     50                          36      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
162   ***      0                                  0      my $dsn_string
163                                                         = join(',',
164           45    100                         193             map  { "$_=".$o->get($_); }
165            5                                 65             grep { $o->has($_) && $o->get($_) }
166            5                                 22             keys %{$self->{opts}}
167                                                           );
168            5                                 25      MKDEBUG && _d('DSN string made from options:', $dsn_string);
169            5                                 35      return $self->parse($dsn_string);
170                                                   }
171                                                   
172                                                   sub as_string {
173   ***      0                    0             0      my ( $self, $dsn ) = @_;
174   ***      0      0                           0      return $dsn unless ref $dsn;
175   ***      0      0                           0      return join(',',
176   ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
177   ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
178                                                         sort keys %$dsn );
179                                                   }
180                                                   
181                                                   sub usage {
182   ***      0                    0             0      my ( $self ) = @_;
183   ***      0                                  0      my $usage
184                                                         = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
185                                                         . "  KEY  COPY  MEANING\n"
186                                                         . "  ===  ====  =============================================\n";
187   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
188   ***      0                                  0      foreach my $key ( sort keys %opts ) {
189   ***      0      0      0                    0         $usage .= "  $key    "
190                                                                .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
191                                                                .  ($opts{$key}->{desc} || '[No description]')
192                                                                . "\n";
193                                                      }
194   ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
195   ***      0                                  0      return $usage;
196                                                   }
197                                                   
198                                                   sub get_cxn_params {
199            7                    7            57      my ( $self, $info ) = @_;
200            7                                 23      my $dsn;
201            7                                 25      my %opts = %{$self->{opts}};
               7                                 97   
202   ***      7            50                   48      my $driver = $self->prop('dbidriver') || '';
203   ***      7     50                          54      if ( $driver eq 'Pg' ) {
204   ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
205   ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
206   ***      0             0                    0                        grep { defined $info->{$_} }
207                                                                        qw(h P));
208                                                      }
209                                                      else {
210           14                                129         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
211           35                                150            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
212            7           100                  107                        grep { defined $info->{$_} }
213                                                                        qw(F h P S A))
214                                                            . ';mysql_read_default_group=client';
215                                                      }
216            7                                 25      MKDEBUG && _d($dsn);
217            7                                 93      return ($dsn, $info->{u}, $info->{p});
218                                                   }
219                                                   
220                                                   sub fill_in_dsn {
221   ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
222   ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
223   ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
224   ***      0                                  0      $user =~ s/@.*//;
225   ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
226   ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
227   ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
228   ***      0             0                    0      $dsn->{u} ||= $user;
229   ***      0             0                    0      $dsn->{D} ||= $db;
230                                                   }
231                                                   
232                                                   sub get_dbh {
233            7                    7            66      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
234   ***      7            50                   39      $opts ||= {};
235   ***      7     50                         113      my $defaults = {
236                                                         AutoCommit         => 0,
237                                                         RaiseError         => 1,
238                                                         PrintError         => 0,
239                                                         ShowErrorStatement => 1,
240                                                         mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
241                                                      };
242            7                                 43      @{$defaults}{ keys %$opts } = values %$opts;
               7                                 34   
243                                                   
244   ***      7     50                          38      if ( !$have_dbi ) {
245   ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
246                                                            . "installed or not found.  Run 'perl -MDBI' to see the directories "
247                                                            . "that Perl searches for DBI.  If DBI is not installed, try:\n"
248                                                            . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
249                                                            . "  RHEL/CentOS    yum install perl-DBI\n"
250                                                            . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
251                                                   
252                                                      }
253                                                   
254            7                                 24      my $dbh;
255            7                                 22      my $tries = 2;
256   ***      7            66                   95      while ( !$dbh && $tries-- ) {
257                                                         MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
258            7                                 21            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
259                                                   
260            7                                 23         eval {
261            7                                110            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
262                                                   
263   ***      7     50                          95            if ( $cxn_string =~ m/mysql/i ) {
264            7                                 21               my $sql;
265                                                   
266            7                                 33               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
267                                                                    . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
268            7                                 18               MKDEBUG && _d($dbh, ':', $sql);
269            7                               3860               $dbh->do($sql);
270                                                   
271   ***      7     50                          90               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
272   ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
273   ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
274   ***      0                                  0                  $dbh->do($sql);
275   ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
276   ***      0      0                           0                  if ( $charset eq 'utf8' ) {
277   ***      0      0                           0                     binmode(STDOUT, ':utf8')
278                                                                        or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
279                                                                  }
280                                                                  else {
281   ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
282                                                                  }
283                                                               }
284                                                   
285            7    100                          52               if ( $self->prop('set-vars') ) {
286            5                                 30                  $sql = "SET " . $self->prop('set-vars');
287            5                                 16                  MKDEBUG && _d($dbh, ':', $sql);
288            5                                561                  $dbh->do($sql);
289                                                               }
290                                                            }
291                                                         };
292   ***      7     50     33                   98         if ( !$dbh && $EVAL_ERROR ) {
293   ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
294   ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
295   ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
296   ***      0                                  0               delete $defaults->{mysql_enable_utf8};
297                                                            }
298                                                            elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
299   ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
300                                                                  . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
301                                                                  . "the directories that Perl searches for DBD::mysql.  If "
302                                                                  . "DBD::mysql is not installed, try:\n"
303                                                                  . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
304                                                                  . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
305                                                                  . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
306                                                            }
307   ***      0      0                           0            if ( !$tries ) {
308   ***      0                                  0               die $EVAL_ERROR;
309                                                            }
310                                                         }
311                                                      }
312                                                   
313            7                                 22      MKDEBUG && _d('DBH info: ',
314                                                         $dbh,
315                                                         Dumper($dbh->selectrow_hashref(
316                                                            'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
317                                                         'Connection info:',      $dbh->{mysql_hostinfo},
318                                                         'Character set info:',   Dumper($dbh->selectall_arrayref(
319                                                                        'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
320                                                         '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
321                                                         '$DBI::VERSION:',        $DBI::VERSION,
322                                                      );
323                                                   
324            7                                 49      return $dbh;
325                                                   }
326                                                   
327                                                   sub get_hostname {
328   ***      0                    0             0      my ( $self, $dbh ) = @_;
329   ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
330   ***      0                                  0         return $host;
331                                                      }
332   ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
333                                                         'SELECT /*!50038 @@hostname, */ 1');
334   ***      0                                  0      return $hostname;
335                                                   }
336                                                   
337                                                   sub disconnect {
338            5                    5            22      my ( $self, $dbh ) = @_;
339            5                                 11      MKDEBUG && $self->print_active_handles($dbh);
340            5                                663      $dbh->disconnect;
341                                                   }
342                                                   
343                                                   sub print_active_handles {
344   ***      0                    0             0      my ( $self, $thing, $level ) = @_;
345   ***      0             0                    0      $level ||= 0;
346   ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
347                                                         $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
348                                                         or die "Cannot print: $OS_ERROR";
349   ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
350   ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
351                                                      }
352                                                   }
353                                                   
354                                                   sub copy {
355   ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
356   ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
357   ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
358   ***      0                                  0      my %new_dsn = map {
359   ***      0                                  0         my $key = $_;
360   ***      0                                  0         my $val;
361   ***      0      0                           0         if ( $args{overwrite} ) {
362   ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
363                                                         }
364                                                         else {
365   ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
366                                                         }
367   ***      0                                  0         $key => $val;
368   ***      0                                  0      } keys %{$self->{opts}};
369   ***      0                                  0      return \%new_dsn;
370                                                   }
371                                                   
372                                                   sub _d {
373   ***      0                    0             0      my ($package, undef, $line) = caller 0;
374   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
375   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
376                                                           @_;
377   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
378                                                   }
379                                                   
380                                                   1;
381                                                   
382                                                   # ###########################################################################
383                                                   # End DSNParser package
384                                                   # ###########################################################################
385                                                   
386                                                   # ###########################################################################
387                                                   # Quoter package 5697
388                                                   # ###########################################################################
389                                                   package Quoter;
390                                                   
391            7                    7            63   use strict;
               7                                 26   
               7                                 52   
392            7                    7            42   use warnings FATAL => 'all';
               7                                 17   
               7                                 41   
393            7                    7            49   use English qw(-no_match_vars);
               7                                 18   
               7                                 41   
394                                                   
395   ***      7            50      7            49   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 17   
               7                                104   
396                                                   
397                                                   sub new {
398            7                    7            31      my ( $class ) = @_;
399            7                                 69      return bless {}, $class;
400                                                   }
401                                                   
402                                                   sub quote {
403           73                   73           410      my ( $self, @vals ) = @_;
404           73                                331      foreach my $val ( @vals ) {
405          133                                537         $val =~ s/`/``/g;
406                                                      }
407           73                                309      return join('.', map { '`' . $_ . '`' } @vals);
             133                               1338   
408                                                   }
409                                                   
410                                                   sub quote_val {
411   ***      0                    0             0      my ( $self, $val, $is_numeric ) = @_;
412                                                   
413   ***      0      0                           0      return 'NULL' unless defined $val;  # undef = NULL
414   ***      0      0                           0      return "''" if $val eq '';          # blank string = ''
415                                                   
416   ***      0      0                           0      if ( !defined $is_numeric ) {
417   ***      0      0                           0         $is_numeric = $val =~ m/^0|\D/ ? 0 : 1;
418                                                      }
419                                                   
420   ***      0      0                           0      return $val if $is_numeric;
421                                                   
422   ***      0                                  0      $val =~ s/(['\\])/\\$1/g;
423   ***      0                                  0      return "'$val'";
424                                                   }
425                                                   
426                                                   sub split_unquote {
427           91                   91           496      my ( $self, $db_tbl, $default_db ) = @_;
428           91                                405      $db_tbl =~ s/`//g;
429           91                                430      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
430           91    100                         433      if ( !$tbl ) {
431           40                                166         $tbl = $db;
432           40                                124         $db  = $default_db;
433                                                      }
434           91                                465      return ($db, $tbl);
435                                                   }
436                                                   
437                                                   sub literal_like {
438   ***      0                    0             0      my ( $self, $like ) = @_;
439   ***      0      0                           0      return unless $like;
440   ***      0                                  0      $like =~ s/([%_])/\\$1/g;
441   ***      0                                  0      return "'$like'";
442                                                   }
443                                                   
444                                                   1;
445                                                   
446                                                   # ###########################################################################
447                                                   # End Quoter package
448                                                   # ###########################################################################
449                                                   
450                                                   # ###########################################################################
451                                                   # OptionParser package 5770
452                                                   # ###########################################################################
453                                                   package OptionParser;
454                                                   
455            7                    7            53   use strict;
               7                                 18   
               7                                 37   
456            7                    7            43   use warnings FATAL => 'all';
               7                                 25   
               7                                 36   
457                                                   
458            7                    7            83   use Getopt::Long;
               7                                 24   
               7                                 50   
459            7                    7            51   use List::Util qw(max);
               7                                 18   
               7                                 82   
460            7                    7            47   use English qw(-no_match_vars);
               7                                 17   
               7                                 46   
461                                                   
462   ***      7            50      7            48   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 18   
               7                                111   
463                                                   
464                                                   my $POD_link_re = '[LC]<"?([^">]+)"?>';
465                                                   
466                                                   my %attributes = (
467                                                      'type'       => 1,
468                                                      'short form' => 1,
469                                                      'group'      => 1,
470                                                      'default'    => 1,
471                                                      'cumulative' => 1,
472                                                      'negatable'  => 1,
473                                                   );
474                                                   
475                                                   sub new {
476           54                   54          1322      my ( $class, %args ) = @_;
477           54                                440      foreach my $arg ( qw(description) ) {
478   ***     54     50                         607         die "I need a $arg argument" unless $args{$arg};
479                                                      }
480           54                               1152      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
481   ***     54            50                  322      $program_name ||= $PROGRAM_NAME;
482   ***     54            33                  771      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                   33                        
      ***                   50                        
483                                                   
484   ***     54     50     50                 4557      my $self = {
      ***                   50                        
485                                                         description    => $args{description},
486                                                         prompt         => $args{prompt} || '<options>',
487                                                         strict         => (exists $args{strict} ? $args{strict} : 1),
488                                                         dp             => $args{dp}     || undef,
489                                                         program_name   => $program_name,
490                                                         opts           => {},
491                                                         got_opts       => 0,
492                                                         short_opts     => {},
493                                                         defaults       => {},
494                                                         groups         => {},
495                                                         allowed_groups => {},
496                                                         errors         => [],
497                                                         rules          => [],  # desc of rules for --help
498                                                         mutex          => [],  # rule: opts are mutually exclusive
499                                                         atleast1       => [],  # rule: at least one opt is required
500                                                         disables       => {},  # rule: opt disables other opts 
501                                                         defaults_to    => {},  # rule: opt defaults to value of other opt
502                                                         default_files  => [
503                                                            "/etc/maatkit/maatkit.conf",
504                                                            "/etc/maatkit/$program_name.conf",
505                                                            "$home/.maatkit.conf",
506                                                            "$home/.$program_name.conf",
507                                                         ],
508                                                      };
509           54                                707      return bless $self, $class;
510                                                   }
511                                                   
512                                                   sub get_specs {
513           54                   54           345      my ( $self, $file ) = @_;
514           54                                507      my @specs = $self->_pod_to_specs($file);
515           54                               2401      $self->_parse_specs(@specs);
516           54                                451      return;
517                                                   }
518                                                   
519                                                   sub get_defaults_files {
520           54                   54           265      my ( $self ) = @_;
521           54                                178      return @{$self->{default_files}};
              54                                635   
522                                                   }
523                                                   
524                                                   sub _pod_to_specs {
525           54                   54           270      my ( $self, $file ) = @_;
526   ***     54            50                  480      $file ||= __FILE__;
527   ***     54     50                        2200      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
528                                                   
529           54                               1686      my %types = (
530                                                         string => 's', # standard Getopt type
531                                                         'int'  => 'i', # standard Getopt type
532                                                         float  => 'f', # standard Getopt type
533                                                         Hash   => 'H', # hash, formed from a comma-separated list
534                                                         hash   => 'h', # hash as above, but only if a value is given
535                                                         Array  => 'A', # array, similar to Hash
536                                                         array  => 'a', # array, similar to hash
537                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
538                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
539                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
540                                                      );
541           54                                361      my @specs = ();
542           54                                308      my @rules = ();
543           54                                232      my $para;
544                                                   
545           54                                461      local $INPUT_RECORD_SEPARATOR = '';
546           54                               2349      while ( $para = <$fh> ) {
547        66852    100                      442500         next unless $para =~ m/^=head1 OPTIONS/;
548           54                                247         last;
549                                                      }
550                                                   
551           54                                416      while ( $para = <$fh> ) {
552          108    100                         753         last if $para =~ m/^=over/;
553           54                                273         chomp $para;
554           54                                660         $para =~ s/\s+/ /g;
555           54                               2224         $para =~ s/$POD_link_re/$1/go;
556           54                                194         MKDEBUG && _d('Option rule:', $para);
557           54                                626         push @rules, $para;
558                                                      }
559                                                   
560   ***     54     50                         335      die 'POD has no OPTIONS section' unless $para;
561                                                   
562           54                                209      do {
563         3456    100                       22788         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
564         3402                               9598            chomp $para;
565         3402                               7491            MKDEBUG && _d($para);
566         3402                               7951            my %attribs;
567                                                   
568         3402                              12285            $para = <$fh>; # read next paragraph, possibly attributes
569                                                   
570         3402    100                       12838            if ( $para =~ m/: / ) { # attributes
571         2592                              11608               $para =~ s/\s+\Z//g;
572         3834                              24835               %attribs = map {
573         2592                              11965                     my ( $attrib, $val) = split(/: /, $_);
574   ***   3834     50                       16933                     die "Unrecognized attribute for --$option: $attrib"
575                                                                        unless $attributes{$attrib};
576         3834                              22474                     ($attrib, $val);
577                                                                  } split(/; /, $para);
578         2592    100                       11733               if ( $attribs{'short form'} ) {
579          378                               1940                  $attribs{'short form'} =~ s/-//;
580                                                               }
581         2592                              11306               $para = <$fh>; # read next paragraph, probably short help desc
582                                                            }
583                                                            else {
584          810                               2047               MKDEBUG && _d('Option has no attributes');
585                                                            }
586                                                   
587         3402                              22956            $para =~ s/\s+\Z//g;
588         3402                              24365            $para =~ s/\s+/ /g;
589         3402                              16933            $para =~ s/$POD_link_re/$1/go;
590                                                   
591         3402                              13372            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
592         3402                               7852            MKDEBUG && _d('Short help:', $para);
593                                                   
594   ***   3402     50                       13475            die "No description after option spec $option" if $para =~ m/^=item/;
595                                                   
596         3402    100                       16156            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
597          216                                657               $option = $base_option;
598          216                                939               $attribs{'negatable'} = 1;
599                                                            }
600                                                   
601         3402    100                       58613            push @specs, {
                    100                               
      ***            50                               
                    100                               
                    100                               
      ***            50                               
602                                                               spec  => $option
603                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
604                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
605                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
606                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
607                                                               desc  => $para
608                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
609                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
610                                                            };
611                                                         }
612         3456                              23902         while ( $para = <$fh> ) {
613   ***  12636     50                       42179            last unless $para;
614                                                   
615                                                   
616        12636    100                       45099            if ( $para =~ m/^=head1/ ) {
617           54                                200               $para = undef; # Can't 'last' out of a do {} block.
618           54                                347               last;
619                                                            }
620        12582    100                       77294            last if $para =~ m/^=item --/;
621                                                         }
622                                                      } while ( $para );
623                                                   
624   ***     54     50                         257      die 'No valid specs in POD OPTIONS' unless @specs;
625                                                   
626           54                                829      close $fh;
627           54                                231      return @specs, @rules;
628                                                   }
629                                                   
630                                                   sub _parse_specs {
631           54                   54          1034      my ( $self, @specs ) = @_;
632           54                                306      my %disables; # special rule that requires deferred checking
633                                                   
634           54                                345      foreach my $opt ( @specs ) {
635         3456    100                       12289         if ( ref $opt ) { # It's an option spec, not a rule.
636                                                            MKDEBUG && _d('Parsing opt spec:',
637         3402                               7495               map { ($_, '=>', $opt->{$_}) } keys %$opt);
638                                                   
639         3402                              25115            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
640   ***   3402     50                       13709            if ( !$long ) {
641   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
642                                                            }
643         3402                              11811            $opt->{long} = $long;
644                                                   
645   ***   3402     50                       15260            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
646         3402                              15471            $self->{opts}->{$long} = $opt;
647                                                   
648   ***   3402     50                       13151            if ( length $long == 1 ) {
649   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
650   ***      0                                  0               $self->{short_opts}->{$long} = $long;
651                                                            }
652                                                   
653         3402    100                       11009            if ( $short ) {
654   ***    378     50                        1743               die "Duplicate short option -$short"
655                                                                  if exists $self->{short_opts}->{$short};
656          378                               1772               $self->{short_opts}->{$short} = $long;
657          378                               1360               $opt->{short} = $short;
658                                                            }
659                                                            else {
660         3024                              10615               $opt->{short} = undef;
661                                                            }
662                                                   
663         3402    100                       17448            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
664   ***   3402     50                       16813            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
665   ***   3402     50                       19295            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
666                                                   
667   ***   3402            50                13668            $opt->{group} ||= 'default';
668         3402                              17155            $self->{groups}->{ $opt->{group} }->{$long} = 1;
669                                                   
670         3402                              11451            $opt->{value} = undef;
671         3402                              11308            $opt->{got}   = 0;
672                                                   
673         3402                              18188            my ( $type ) = $opt->{spec} =~ m/=(.)/;
674         3402                              12583            $opt->{type} = $type;
675         3402                               7282            MKDEBUG && _d($long, 'type:', $type);
676                                                   
677   ***   3402     50    100                30728            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                   66                        
678   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
679                                                                  . "was given when this OptionParser object was created";
680                                                            }
681                                                   
682         3402    100    100                26846            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
683                                                   
684         3402    100                       21500            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
685   ***   1080     50                        6062               $self->{defaults}->{$long} = defined $def ? $def : 1;
686         1080                               2609               MKDEBUG && _d($long, 'default:', $def);
687                                                            }
688                                                   
689         3402    100                       13021            if ( $long eq 'config' ) {
690           54                                370               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
691                                                            }
692                                                   
693   ***   3402     50                       16657            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
694   ***      0                                  0               $disables{$long} = $dis;
695   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
696                                                            }
697                                                   
698         3402                              15797            $self->{opts}->{$long} = $opt;
699                                                         }
700                                                         else { # It's an option rule, not a spec.
701           54                                156            MKDEBUG && _d('Parsing rule:', $opt); 
702           54                                169            push @{$self->{rules}}, $opt;
              54                                370   
703           54                                401            my @participants = $self->_get_participants($opt);
704           54                                207            my $rule_ok = 0;
705                                                   
706   ***     54     50                         553            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
707   ***      0                                  0               $rule_ok = 1;
708   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
709   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
710                                                            }
711   ***     54     50                         459            if ( $opt =~ m/at least one|one and only one/ ) {
712   ***      0                                  0               $rule_ok = 1;
713   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
714   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
715                                                            }
716   ***     54     50                         417            if ( $opt =~ m/default to/ ) {
717           54                                190               $rule_ok = 1;
718           54                                330               $self->{defaults_to}->{$participants[0]} = $participants[1];
719           54                                152               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
720                                                            }
721   ***     54     50                         360            if ( $opt =~ m/restricted to option groups/ ) {
722   ***      0                                  0               $rule_ok = 1;
723   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
724   ***      0                                  0               my @groups = split(',', $groups);
725   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
726   ***      0                                  0                  s/\s+//;
727   ***      0                                  0                  $_ => 1;
728                                                               } @groups;
729                                                            }
730                                                   
731   ***     54     50                         332            die "Unrecognized option rule: $opt" unless $rule_ok;
732                                                         }
733                                                      }
734                                                   
735           54                                483      foreach my $long ( keys %disables ) {
736   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
737   ***      0                                  0         $self->{disables}->{$long} = \@participants;
738   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
739                                                      }
740                                                   
741           54                                512      return; 
742                                                   }
743                                                   
744                                                   sub _get_participants {
745           54                   54           310      my ( $self, $str ) = @_;
746           54                                198      my @participants;
747           54                                672      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
748   ***    108     50                         585         die "Option --$long does not exist while processing rule $str"
749                                                            unless exists $self->{opts}->{$long};
750          108                                583         push @participants, $long;
751                                                      }
752           54                                162      MKDEBUG && _d('Participants for', $str, ':', @participants);
753           54                                428      return @participants;
754                                                   }
755                                                   
756                                                   sub opts {
757   ***      0                    0             0      my ( $self ) = @_;
758   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
759   ***      0                                  0      return %opts;
760                                                   }
761                                                   
762                                                   sub short_opts {
763   ***      0                    0             0      my ( $self ) = @_;
764   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
765   ***      0                                  0      return %short_opts;
766                                                   }
767                                                   
768                                                   sub set_defaults {
769   ***      0                    0             0      my ( $self, %defaults ) = @_;
770   ***      0                                  0      $self->{defaults} = {};
771   ***      0                                  0      foreach my $long ( keys %defaults ) {
772   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
773                                                            unless exists $self->{opts}->{$long};
774   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
775   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
776                                                      }
777   ***      0                                  0      return;
778                                                   }
779                                                   
780                                                   sub get_defaults {
781           55                   55           229      my ( $self ) = @_;
782           55                                337      return $self->{defaults};
783                                                   }
784                                                   
785                                                   sub get_groups {
786   ***      0                    0             0      my ( $self ) = @_;
787   ***      0                                  0      return $self->{groups};
788                                                   }
789                                                   
790                                                   sub _set_option {
791          170                  170           831      my ( $self, $opt, $val ) = @_;
792   ***    170      0                         395      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
793                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
794                                                               : die "Getopt::Long gave a nonexistent option: $opt";
795                                                   
796          170                                343      $opt = $self->{opts}->{$long};
797   ***    170     50                         994      if ( $opt->{is_cumulative} ) {
798   ***      0                                  0         $opt->{value}++;
799                                                      }
800                                                      else {
801          170                                708         $opt->{value} = $val;
802                                                      }
803          170                                578      $opt->{got} = 1;
804          170                                648      MKDEBUG && _d('Got option', $long, '=', $val);
805                                                   }
806                                                   
807                                                   sub get_opts {
808           54                   54           244      my ( $self ) = @_; 
809                                                   
810           54                                178      foreach my $long ( keys %{$self->{opts}} ) {
              54                               1069   
811         3402                              13496         $self->{opts}->{$long}->{got} = 0;
812   ***   3402     50                       26460         $self->{opts}->{$long}->{value}
                    100                               
813                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
814                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
815                                                            : undef;
816                                                      }
817           54                                454      $self->{got_opts} = 0;
818                                                   
819           54                                283      $self->{errors} = [];
820                                                   
821   ***     54     50     33                  862      if ( @ARGV && $ARGV[0] eq "--config" ) {
822   ***      0                                  0         shift @ARGV;
823   ***      0                                  0         $self->_set_option('config', shift @ARGV);
824                                                      }
825   ***     54     50                         559      if ( $self->has('config') ) {
826           54                                186         my @extra_args;
827           54                                435         foreach my $filename ( split(',', $self->get('config')) ) {
828          216                                609            eval {
829          216                               1169               push @extra_args, $self->_read_config_file($filename);
830                                                            };
831   ***    216     50                        1123            if ( $EVAL_ERROR ) {
832   ***    216     50                        1005               if ( $self->got('config') ) {
833   ***      0                                  0                  die $EVAL_ERROR;
834                                                               }
835                                                               elsif ( MKDEBUG ) {
836                                                                  _d($EVAL_ERROR);
837                                                               }
838                                                            }
839                                                         }
840           54                                303         unshift @ARGV, @extra_args;
841                                                      }
842                                                   
843           54                                681      Getopt::Long::Configure('no_ignore_case', 'bundling');
844                                                      GetOptions(
845         3348                  170         25618         map    { $_->{spec} => sub { $self->_set_option(@_); } }
             170                                943   
            3402                              13614   
846           54                                528         grep   { $_->{long} ne 'config' } # --config is handled specially above.
847   ***     54     50                         208         values %{$self->{opts}}
848                                                      ) or $self->save_error('Error parsing options');
849                                                   
850   ***     54     50     33                 6934      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
851   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
852                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
853                                                               or die "Cannot print: $OS_ERROR";
854   ***      0                                  0         exit 0;
855                                                      }
856                                                   
857   ***     54     50     33                  794      if ( @ARGV && $self->{strict} ) {
858   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
859                                                      }
860                                                   
861           54                                188      foreach my $mutex ( @{$self->{mutex}} ) {
              54                                437   
862   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
863   ***      0      0                           0         if ( @set > 1 ) {
864   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
865   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
866                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
867                                                                    . ' are mutually exclusive.';
868   ***      0                                  0            $self->save_error($err);
869                                                         }
870                                                      }
871                                                   
872           54                                196      foreach my $required ( @{$self->{atleast1}} ) {
              54                                322   
873   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
874   ***      0      0                           0         if ( @set == 0 ) {
875   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
876   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
877                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
878   ***      0                                  0            $self->save_error("Specify at least one of $err");
879                                                         }
880                                                      }
881                                                   
882           54                                180      foreach my $long ( keys %{$self->{opts}} ) {
              54                                933   
883         3402                              13189         my $opt = $self->{opts}->{$long};
884         3402    100                       18933         if ( $opt->{got} ) {
      ***            50                               
885   ***    159     50                         984            if ( exists $self->{disables}->{$long} ) {
886   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
887   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
888   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
889                                                                  'because', $long,'disables them');
890                                                            }
891                                                   
892   ***    159     50                         889            if ( exists $self->{allowed_groups}->{$long} ) {
893                                                   
894   ***      0                                  0               my @restricted_groups = grep {
895   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
896   ***      0                                  0               } keys %{$self->{groups}};
897                                                   
898   ***      0                                  0               my @restricted_opts;
899   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
900   ***      0                                  0                  RESTRICTED_OPT:
901   ***      0                                  0                  foreach my $restricted_opt (
902                                                                     keys %{$self->{groups}->{$restricted_group}} )
903                                                                  {
904   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
905   ***      0      0                           0                     push @restricted_opts, $restricted_opt
906                                                                        if $self->{opts}->{$restricted_opt}->{got};
907                                                                  }
908                                                               }
909                                                   
910   ***      0      0                           0               if ( @restricted_opts ) {
911   ***      0                                  0                  my $err;
912   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
913   ***      0                                  0                     $err = "--$restricted_opts[0]";
914                                                                  }
915                                                                  else {
916   ***      0                                  0                     $err = join(', ',
917   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
918   ***      0                                  0                               grep { $_ } 
919                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
920                                                                            )
921                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
922                                                                  }
923   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
924                                                               }
925                                                            }
926                                                   
927                                                         }
928                                                         elsif ( $opt->{is_required} ) { 
929   ***      0                                  0            $self->save_error("Required option --$long must be specified");
930                                                         }
931                                                   
932         3402                              12419         $self->_validate_type($opt);
933                                                      }
934                                                   
935           54                                655      $self->{got_opts} = 1;
936           54                                197      return;
937                                                   }
938                                                   
939                                                   sub _validate_type {
940         3402                 3402         12010      my ( $self, $opt ) = @_;
941   ***   3402    100     66                29575      return unless $opt && $opt->{type};
942         2376                               7892      my $val = $opt->{value};
943                                                   
944   ***   2376     50     66                61844      if ( $val && $opt->{type} eq 'm' ) {  # type time
                    100    100                        
      ***            50     66                        
      ***           100     66                        
      ***           100     66                        
                           100                        
                           100                        
945   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
946   ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
947   ***      0      0                           0         if ( !$suffix ) {
948   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
949   ***      0             0                    0            $suffix = $s || 's';
950   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
951                                                               $opt->{long}, '(value:', $val, ')');
952                                                         }
953   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
954   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
955                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
956                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
957                                                                 :                  $num * 86400;   # Days
958   ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
959   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
960                                                         }
961                                                         else {
962   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
963                                                         }
964                                                      }
965                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
966            5                                 27         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
967            5                                 22         my $prev = {};
968            5                                 30         my $from_key = $self->{defaults_to}->{ $opt->{long} };
969   ***      5     50                          28         if ( $from_key ) {
970   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
971   ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
972                                                         }
973            5                                 62         my $defaults = $self->{dp}->parse_options($self);
974            5                                 32         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
975                                                      }
976                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
977   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
978   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
979   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
980   ***      0      0                           0         if ( defined $num ) {
981   ***      0      0                           0            if ( $factor ) {
982   ***      0                                  0               $num *= $factor_for{$factor};
983   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
984                                                                  'to num', $num, '* factor', $factor);
985                                                            }
986   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
987                                                         }
988                                                         else {
989   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
990                                                         }
991                                                      }
992                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
993   ***     54            50                  643         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
              70                                493   
994                                                      }
995                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
996          595           100                 5784         $opt->{value} = [ split(/(?<!\\),\s*/, ($val || '')) ];
997                                                      }
998                                                      else {
999         1722                               4178         MKDEBUG && _d('Nothing to validate for option',
1000                                                           $opt->{long}, 'type', $opt->{type}, 'value', $val);
1001                                                     }
1002                                                  
1003        2376                               8322      return;
1004                                                  }
1005                                                  
1006                                                  sub get {
1007        4379                 4379         17538      my ( $self, $opt ) = @_;
1008        4379    100                       18513      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1009  ***   4379     50     33                38752      die "Option $opt does not exist"
1010                                                        unless $long && exists $self->{opts}->{$long};
1011        4379                              40857      return $self->{opts}->{$long}->{value};
1012                                                  }
1013                                                  
1014                                                  sub got {
1015         271                  271          1224      my ( $self, $opt ) = @_;
1016  ***    271     50                        1287      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1017  ***    271     50     33                 2575      die "Option $opt does not exist"
1018                                                        unless $long && exists $self->{opts}->{$long};
1019         271                               1783      return $self->{opts}->{$long}->{got};
1020                                                  }
1021                                                  
1022                                                  sub has {
1023          99                   99           543      my ( $self, $opt ) = @_;
1024          99    100                         588      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1025          99    100                         917      return defined $long ? exists $self->{opts}->{$long} : 0;
1026                                                  }
1027                                                  
1028                                                  sub set {
1029          54                   54           298      my ( $self, $opt, $val ) = @_;
1030  ***     54     50                         401      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1031  ***     54     50     33                  710      die "Option $opt does not exist"
1032                                                        unless $long && exists $self->{opts}->{$long};
1033          54                                268      $self->{opts}->{$long}->{value} = $val;
1034          54                                206      return;
1035                                                  }
1036                                                  
1037                                                  sub save_error {
1038  ***      0                    0             0      my ( $self, $error ) = @_;
1039  ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
1040                                                  }
1041                                                  
1042                                                  sub errors {
1043  ***      0                    0             0      my ( $self ) = @_;
1044  ***      0                                  0      return $self->{errors};
1045                                                  }
1046                                                  
1047                                                  sub prompt {
1048  ***      0                    0             0      my ( $self ) = @_;
1049  ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
1050                                                  }
1051                                                  
1052                                                  sub descr {
1053  ***      0                    0             0      my ( $self ) = @_;
1054  ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
1055                                                                . "  For more details, please use the --help option, "
1056                                                                . "or try 'perldoc $PROGRAM_NAME' "
1057                                                                . "for complete documentation.";
1058  ***      0      0                           0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g)
1059                                                        unless $ENV{DONT_BREAK_LINES};
1060  ***      0                                  0      $descr =~ s/ +$//mg;
1061  ***      0                                  0      return $descr;
1062                                                  }
1063                                                  
1064                                                  sub usage_or_errors {
1065          54                   54           279      my ( $self ) = @_;
1066  ***     54     50                         357      if ( $self->{opts}->{help}->{got} ) {
      ***     54     50                         305   
1067  ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
1068  ***      0                                  0         exit 0;
1069                                                     }
1070                                                     elsif ( scalar @{$self->{errors}} ) {
1071  ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
1072  ***      0                                  0         exit 0;
1073                                                     }
1074          54                                174      return;
1075                                                  }
1076                                                  
1077                                                  sub print_errors {
1078  ***      0                    0             0      my ( $self ) = @_;
1079  ***      0                                  0      my $usage = $self->prompt() . "\n";
1080  ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
1081  ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
1082                                                                . "\n";
1083                                                     }
1084  ***      0                                  0      return $usage . "\n" . $self->descr();
1085                                                  }
1086                                                  
1087                                                  sub print_usage {
1088  ***      0                    0             0      my ( $self ) = @_;
1089  ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
1090  ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
1091                                                  
1092  ***      0      0                           0      my $maxl = max(
1093  ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
1094                                                        @opts);
1095                                                  
1096  ***      0      0                           0      my $maxs = max(0,
1097  ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
1098  ***      0                                  0         values %{$self->{short_opts}});
1099                                                  
1100  ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
1101  ***      0                                  0      my $rcol = 80 - $lcol - 6;
1102  ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
1103                                                  
1104  ***      0                                  0      $maxs = max($lcol - 3, $maxs);
1105                                                  
1106  ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
1107                                                  
1108  ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
1109  ***      0                                  0      push @groups, 'default';
1110                                                  
1111  ***      0                                  0      foreach my $group ( reverse @groups ) {
1112  ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
1113  ***      0                                  0         foreach my $opt (
      ***      0                                  0   
1114  ***      0                                  0            sort { $a->{long} cmp $b->{long} }
1115                                                           grep { $_->{group} eq $group }
1116                                                           @opts )
1117                                                        {
1118  ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
1119  ***      0                                  0            my $short = $opt->{short};
1120  ***      0                                  0            my $desc  = $opt->{desc};
1121  ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
1122  ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
1123  ***      0             0                    0               $s    ||= 's';
1124  ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
1125  ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
1126                                                                     . "d=days; if no suffix, $s is used.";
1127                                                           }
1128  ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
1129  ***      0                                  0            $desc =~ s/ +$//mg;
1130  ***      0      0                           0            if ( $short ) {
1131  ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
1132                                                           }
1133                                                           else {
1134  ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
1135                                                           }
1136                                                        }
1137                                                     }
1138                                                  
1139  ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
1140  ***      0                                  0         $usage .= "\nRules:\n\n";
1141  ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
1142                                                     }
1143  ***      0      0                           0      if ( $self->{dp} ) {
1144  ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
1145                                                     }
1146  ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
1147  ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
1148  ***      0                                  0         my $val   = $opt->{value};
1149  ***      0             0                    0         my $type  = $opt->{type} || '';
1150  ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
1151  ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
1152                                                                  : !defined $val             ? '(No value)'
1153                                                                  : $type eq 'd'              ? $self->{dp}->as_string($val)
1154                                                                  : $type =~ m/H|h/           ? join(',', sort keys %$val)
1155                                                                  : $type =~ m/A|a/           ? join(',', @$val)
1156                                                                  :                             $val;
1157  ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
1158                                                     }
1159  ***      0                                  0      return $usage;
1160                                                  }
1161                                                  
1162                                                  sub prompt_noecho {
1163  ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
1164  ***      0                                  0      my ( $prompt ) = @_;
1165  ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
1166  ***      0      0                           0      print $prompt
1167                                                        or die "Cannot print: $OS_ERROR";
1168  ***      0                                  0      my $response;
1169  ***      0                                  0      eval {
1170  ***      0                                  0         require Term::ReadKey;
1171  ***      0                                  0         Term::ReadKey::ReadMode('noecho');
1172  ***      0                                  0         chomp($response = <STDIN>);
1173  ***      0                                  0         Term::ReadKey::ReadMode('normal');
1174  ***      0      0                           0         print "\n"
1175                                                           or die "Cannot print: $OS_ERROR";
1176                                                     };
1177  ***      0      0                           0      if ( $EVAL_ERROR ) {
1178  ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
1179                                                     }
1180  ***      0                                  0      return $response;
1181                                                  }
1182                                                  
1183                                                  if ( MKDEBUG ) {
1184                                                     print '# ', $^X, ' ', $], "\n";
1185                                                     my $uname = `uname -a`;
1186                                                     if ( $uname ) {
1187                                                        $uname =~ s/\s+/ /g;
1188                                                        print "# $uname\n";
1189                                                     }
1190                                                     printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
1191                                                        $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
1192                                                        ($main::SVN_REV || ''), __LINE__);
1193                                                     print('# Arguments: ',
1194                                                        join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
1195                                                  }
1196                                                  
1197                                                  sub _read_config_file {
1198         216                  216           963      my ( $self, $filename ) = @_;
1199  ***    216     50                         603      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
1200  ***      0                                  0      my @args;
1201  ***      0                                  0      my $prefix = '--';
1202  ***      0                                  0      my $parse  = 1;
1203                                                  
1204                                                     LINE:
1205  ***      0                                  0      while ( my $line = <$fh> ) {
1206  ***      0                                  0         chomp $line;
1207  ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
1208  ***      0                                  0         $line =~ s/\s+#.*$//g;
1209  ***      0                                  0         $line =~ s/^\s+|\s+$//g;
1210  ***      0      0                           0         if ( $line eq '--' ) {
1211  ***      0                                  0            $prefix = '';
1212  ***      0                                  0            $parse  = 0;
1213  ***      0                                  0            next LINE;
1214                                                        }
1215  ***      0      0      0                    0         if ( $parse
      ***             0                               
1216                                                           && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
1217                                                        ) {
1218  ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
1219                                                        }
1220                                                        elsif ( $line =~ m/./ ) {
1221  ***      0                                  0            push @args, $line;
1222                                                        }
1223                                                        else {
1224  ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
1225                                                        }
1226                                                     }
1227  ***      0                                  0      close $fh;
1228  ***      0                                  0      return @args;
1229                                                  }
1230                                                  
1231                                                  sub read_para_after {
1232  ***      0                    0             0      my ( $self, $file, $regex ) = @_;
1233  ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
1234  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
1235  ***      0                                  0      my $para;
1236  ***      0                                  0      while ( $para = <$fh> ) {
1237  ***      0      0                           0         next unless $para =~ m/^=pod$/m;
1238  ***      0                                  0         last;
1239                                                     }
1240  ***      0                                  0      while ( $para = <$fh> ) {
1241  ***      0      0                           0         next unless $para =~ m/$regex/;
1242  ***      0                                  0         last;
1243                                                     }
1244  ***      0                                  0      $para = <$fh>;
1245  ***      0                                  0      chomp($para);
1246  ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
1247  ***      0                                  0      return $para;
1248                                                  }
1249                                                  
1250                                                  sub clone {
1251  ***      0                    0             0      my ( $self ) = @_;
1252                                                  
1253  ***      0                                  0      my %clone = map {
1254  ***      0                                  0         my $hashref  = $self->{$_};
1255  ***      0                                  0         my $val_copy = {};
1256  ***      0                                  0         foreach my $key ( keys %$hashref ) {
1257  ***      0                                  0            my $ref = ref $hashref->{$key};
1258  ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
1259  ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
1260  ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
1261                                                                             : $hashref->{$key};
1262                                                        }
1263  ***      0                                  0         $_ => $val_copy;
1264                                                     } qw(opts short_opts defaults);
1265                                                  
1266  ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
1267  ***      0                                  0         $clone{$scalar} = $self->{$scalar};
1268                                                     }
1269                                                  
1270  ***      0                                  0      return bless \%clone;     
1271                                                  }
1272                                                  
1273                                                  sub parse_section {
1274  ***      0                    0             0      my ( $self, %args ) = @_;
1275  ***      0                                  0      my ($file, $section, $subsection, $trf)
1276                                                        = @args{qw(file section subsection trf)};
1277                                                  
1278  ***      0             0                    0      $file ||= __FILE__;
1279  ***      0      0                           0      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
1280                                                     
1281  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
1282                                                  
1283  ***      0                                  0      my $para;
1284  ***      0                                  0      while ( $para = <$fh> ) {
1285  ***      0      0                           0         next unless $para =~ m/^=head1 $section/o;
1286  ***      0                                  0         last;
1287                                                     }
1288                                                  
1289  ***      0      0                           0      if ( $subsection ) {
1290  ***      0                                  0         while ( $para = <$fh> ) {
1291  ***      0      0                           0            next unless $para =~ m/^=head2 $subsection/o;
1292                                                           last
1293  ***      0                                  0         }
1294                                                     }
1295                                                  
1296  ***      0                                  0      my @chunks;
1297  ***      0                                  0      while ( $para = <$fh> ) {
1298  ***      0      0                           0         last if ($subsection ? $para =~ m/^=head[12]/ : $para =~ m/^=head1/);
      ***             0                               
1299  ***      0      0                           0         next if $para =~ m/=head/;
1300  ***      0                                  0         chomp $para;
1301  ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
1302  ***      0      0                           0         if ( $trf ) {
1303  ***      0                                  0            $para = $trf->($para);
1304  ***      0      0                           0            next unless $para;
1305                                                        }
1306  ***      0                                  0         push @chunks, $para;
1307                                                     }
1308                                                  
1309  ***      0                                  0      return @chunks;
1310                                                  }
1311                                                  
1312                                                  sub _d {
1313  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1314  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1315  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1316                                                          @_;
1317  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1318                                                  }
1319                                                  
1320                                                  1;
1321                                                  
1322                                                  # ###########################################################################
1323                                                  # End OptionParser package
1324                                                  # ###########################################################################
1325                                                  
1326                                                  # ###########################################################################
1327                                                  # Transformers package 5715
1328                                                  # ###########################################################################
1329                                                  
1330                                                  package Transformers;
1331                                                  
1332           7                    7            84   use strict;
               7                                 17   
               7                                 59   
1333           7                    7            48   use warnings FATAL => 'all';
               7                                 18   
               7                                 51   
1334           7                    7            43   use English qw(-no_match_vars);
               7                                 17   
               7                                 50   
1335           7                    7            93   use Time::Local qw(timegm timelocal);
               7                                 18   
               7                                 78   
1336           7                    7            64   use Digest::MD5 qw(md5_hex);
               7                                 14   
               7                                 52   
1337                                                  
1338  ***      7            50      7            43   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 16   
               7                                 91   
1339                                                  
1340                                                  require Exporter;
1341                                                  our @ISA         = qw(Exporter);
1342                                                  our %EXPORT_TAGS = ();
1343                                                  our @EXPORT      = ();
1344                                                  our @EXPORT_OK   = qw(
1345                                                     micro_t
1346                                                     percentage_of
1347                                                     secs_to_time
1348                                                     time_to_secs
1349                                                     shorten
1350                                                     ts
1351                                                     parse_timestamp
1352                                                     unix_timestamp
1353                                                     any_unix_timestamp
1354                                                     make_checksum
1355                                                  );
1356                                                  
1357                                                  our $mysql_ts  = qr/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?/;
1358                                                  our $proper_ts = qr/(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(\.\d+)?/;
1359                                                  our $n_ts      = qr/(\d{1,5})([shmd]?)/; # Limit \d{1,5} because \d{6} looks
1360                                                  
1361                                                  sub micro_t {
1362        1295                 1295          5060      my ( $t, %args ) = @_;
1363  ***   1295     50                        5276      my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
1364  ***   1295     50                        4689      my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
1365        1295                               2988      my $f;
1366                                                  
1367        1295    100                        4899      $t = 0 if $t < 0;
1368                                                  
1369        1295    100                        6986      $t = sprintf('%.17f', $t) if $t =~ /e/;
1370                                                  
1371        1295                               7681      $t =~ s/\.(\d{1,6})\d*/\.$1/;
1372                                                  
1373        1295    100    100                12832      if ($t > 0 && $t <= 0.000999) {
                    100    100                        
                    100                               
1374         430                               2416         $f = ($t * 1000000) . 'us';
1375                                                     }
1376                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
1377         192                                908         $f = sprintf("%.${p_ms}f", $t * 1000);
1378         192                                666         $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
1379                                                     }
1380                                                     elsif ($t >= 1) {
1381         181                                782         $f = sprintf("%.${p_s}f", $t);
1382         181                                643         $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
1383                                                     }
1384                                                     else {
1385         492                               1396         $f = 0;  # $t should = 0 at this point
1386                                                     }
1387                                                  
1388        1295                               5960      return $f;
1389                                                  }
1390                                                  
1391                                                  sub percentage_of {
1392         722                  722          2953      my ( $is, $of, %args ) = @_;
1393  ***    722            50                 5115      my $p   = $args{p} || 0; # float precision
1394  ***    722     50                        2566      my $fmt = $p ? "%.${p}f" : "%d";
1395         722           100                 7059      return sprintf $fmt, ($is * 100) / ($of ||= 1);
1396                                                  }
1397                                                  
1398                                                  sub secs_to_time {
1399  ***      0                    0             0      my ( $secs, $fmt ) = @_;
1400  ***      0             0                    0      $secs ||= 0;
1401  ***      0      0                           0      return '00:00' unless $secs;
1402                                                  
1403  ***      0      0      0                    0      $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
1404                                                            : $secs >= 3_600  ? 'h'
1405                                                            :                   'm';
1406                                                  
1407                                                     return
1408  ***      0      0                           0         $fmt eq 'd' ? sprintf(
      ***             0                               
1409                                                           "%d+%02d:%02d:%02d",
1410                                                           int($secs / 86_400),
1411                                                           int(($secs % 86_400) / 3_600),
1412                                                           int(($secs % 3_600) / 60),
1413                                                           $secs % 60)
1414                                                        : $fmt eq 'h' ? sprintf(
1415                                                           "%02d:%02d:%02d",
1416                                                           int(($secs % 86_400) / 3_600),
1417                                                           int(($secs % 3_600) / 60),
1418                                                           $secs % 60)
1419                                                        : sprintf(
1420                                                           "%02d:%02d",
1421                                                           int(($secs % 3_600) / 60),
1422                                                           $secs % 60);
1423                                                  }
1424                                                  
1425                                                  sub time_to_secs {
1426  ***      0                    0             0      my ( $val, $default_suffix ) = @_;
1427  ***      0      0                           0      die "I need a val argument" unless defined $val;
1428  ***      0                                  0      my $t = 0;
1429  ***      0                                  0      my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
1430  ***      0             0                    0      $suffix = $suffix || $default_suffix || 's';
      ***                    0                        
1431  ***      0      0                           0      if ( $suffix =~ m/[smhd]/ ) {
1432  ***      0      0                           0         $t = $suffix eq 's' ? $num * 1        # Seconds
      ***             0                               
      ***             0                               
1433                                                           : $suffix eq 'm' ? $num * 60       # Minutes
1434                                                           : $suffix eq 'h' ? $num * 3600     # Hours
1435                                                           :                  $num * 86400;   # Days
1436                                                  
1437  ***      0      0      0                    0         $t *= -1 if $prefix && $prefix eq '-';
1438                                                     }
1439                                                     else {
1440  ***      0                                  0         die "Invalid suffix for $val: $suffix";
1441                                                     }
1442  ***      0                                  0      return $t;
1443                                                  }
1444                                                  
1445                                                  sub shorten {
1446        3485                 3485         13055      my ( $num, %args ) = @_;
1447        3485    100                       13538      my $p = defined $args{p} ? $args{p} : 2;     # float precision
1448        3485    100                       12718      my $d = defined $args{d} ? $args{d} : 1_024; # divisor
1449        3485                               8903      my $n = 0;
1450        3485                              18353      my @units = ('', qw(k M G T P E Z Y));
1451  ***   3485            66                18423      while ( $num >= $d && $n < @units - 1 ) {
1452          56                                159         $num /= $d;
1453          56                                342         ++$n;
1454                                                     }
1455  ***   3485    100     66                42307      return sprintf(
1456                                                        $num =~ m/\./ || $n
1457                                                           ? "%.${p}f%s"
1458                                                           : '%d',
1459                                                        $num, $units[$n]);
1460                                                  }
1461                                                  
1462                                                  sub ts {
1463  ***      0                    0             0      my ( $time, $gmt ) = @_;
1464  ***      0      0                           0      my ( $sec, $min, $hour, $mday, $mon, $year )
1465                                                        = $gmt ? gmtime($time) : localtime($time);
1466  ***      0                                  0      $mon  += 1;
1467  ***      0                                  0      $year += 1900;
1468  ***      0                                  0      my $val = sprintf("%d-%02d-%02dT%02d:%02d:%02d",
1469                                                        $year, $mon, $mday, $hour, $min, $sec);
1470  ***      0      0                           0      if ( my ($us) = $time =~ m/(\.\d+)$/ ) {
1471  ***      0                                  0         $us = sprintf("%.6f", $us);
1472  ***      0                                  0         $us =~ s/^0\././;
1473  ***      0                                  0         $val .= $us;
1474                                                     }
1475  ***      0                                  0      return $val;
1476                                                  }
1477                                                  
1478                                                  sub parse_timestamp {
1479         250                  250           989      my ( $val ) = @_;
1480  ***    250     50                        3987      if ( my($y, $m, $d, $h, $i, $s, $f)
1481                                                           = $val =~ m/^$mysql_ts$/ )
1482                                                     {
1483         250    100                        3053         return sprintf "%d-%02d-%02d %02d:%02d:"
                    100                               
1484                                                                       . (defined $f ? '%02.6f' : '%02d'),
1485                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
1486                                                     }
1487  ***      0                                  0      return $val;
1488                                                  }
1489                                                  
1490                                                  sub unix_timestamp {
1491          38                   38           167      my ( $val, $gmt ) = @_;
1492          38    100                         660      if ( my($y, $m, $d, $h, $i, $s, $us) = $val =~ m/^$proper_ts$/ ) {
1493  ***     30     50                         258         $val = $gmt
1494                                                           ? timegm($s, $i, $h, $d, $m - 1, $y)
1495                                                           : timelocal($s, $i, $h, $d, $m - 1, $y);
1496          30    100                         125         if ( defined $us ) {
1497           4                                 32            $us = sprintf('%.6f', $us);
1498           4                                 20            $us =~ s/^0\././;
1499           4                                 13            $val .= $us;
1500                                                        }
1501                                                     }
1502          38                                392      return $val;
1503                                                  }
1504                                                  
1505                                                  sub any_unix_timestamp {
1506  ***      0                    0             0      my ( $val, $callback ) = @_;
1507                                                  
1508  ***      0      0                           0      if ( my ($n, $suffix) = $val =~ m/^$n_ts$/ ) {
      ***             0                               
      ***             0                               
      ***             0                               
1509  ***      0      0                           0         $n = $suffix eq 's' ? $n            # Seconds
      ***             0                               
      ***             0                               
      ***             0                               
1510                                                           : $suffix eq 'm' ? $n * 60       # Minutes
1511                                                           : $suffix eq 'h' ? $n * 3600     # Hours
1512                                                           : $suffix eq 'd' ? $n * 86400    # Days
1513                                                           :                  $n;           # default: Seconds
1514  ***      0                                  0         MKDEBUG && _d('ts is now - N[shmd]:', $n);
1515  ***      0                                  0         return time - $n;
1516                                                     }
1517                                                     elsif ( $val =~ m/^\d{9,}/ ) {
1518  ***      0                                  0         MKDEBUG && _d('ts is already a unix timestamp');
1519  ***      0                                  0         return $val;
1520                                                     }
1521                                                     elsif ( my ($ymd, $hms) = $val =~ m/^(\d{6})(?:\s+(\d+:\d+:\d+))?/ ) {
1522  ***      0                                  0         MKDEBUG && _d('ts is MySQL slow log timestamp');
1523  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
1524  ***      0                                  0         return unix_timestamp(parse_timestamp($val));
1525                                                     }
1526                                                     elsif ( ($ymd, $hms) = $val =~ m/^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) {
1527  ***      0                                  0         MKDEBUG && _d('ts is properly formatted timestamp');
1528  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
1529  ***      0                                  0         return unix_timestamp($val);
1530                                                     }
1531                                                     else {
1532  ***      0                                  0         MKDEBUG && _d('ts is MySQL expression');
1533  ***      0      0      0                    0         return $callback->($val) if $callback && ref $callback eq 'CODE';
1534                                                     }
1535                                                  
1536  ***      0                                  0      MKDEBUG && _d('Unknown ts type:', $val);
1537  ***      0                                  0      return;
1538                                                  }
1539                                                  
1540                                                  sub make_checksum {
1541         210                  210           966      my ( $val ) = @_;
1542         210                               1813      my $checksum = uc substr(md5_hex($val), -16);
1543         210                                518      MKDEBUG && _d($checksum, 'checksum for', $val);
1544         210                               2159      return $checksum;
1545                                                  }
1546                                                  
1547                                                  sub _d {
1548  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1549  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1550  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1551                                                          @_;
1552  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1553                                                  }
1554                                                  
1555                                                  1;
1556                                                  
1557                                                  # ###########################################################################
1558                                                  # End Transformers package
1559                                                  # ###########################################################################
1560                                                  
1561                                                  # ###########################################################################
1562                                                  # QueryRewriter package 5706
1563                                                  # ###########################################################################
1564           7                    7            71   use strict;
               7                                 16   
               7                                 52   
1565           7                    7            42   use warnings FATAL => 'all';
               7                                 19   
               7                                 42   
1566                                                  
1567                                                  package QueryRewriter;
1568                                                  
1569           7                    7            45   use English qw(-no_match_vars);
               7                                 15   
               7                                 48   
1570                                                  
1571  ***      7            50      7            46   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 18   
               7                                103   
1572                                                  
1573                                                  our $verbs   = qr{^SHOW|^FLUSH|^COMMIT|^ROLLBACK|^BEGIN|SELECT|INSERT
1574                                                                    |UPDATE|DELETE|REPLACE|^SET|UNION|^START|^LOCK}xi;
1575                                                  my $quote_re = qr/"(?:(?!(?<!\\)").)*"|'(?:(?!(?<!\\)').)*'/; # Costly!
1576                                                  my $bal;
1577                                                  $bal         = qr/
1578                                                                    \(
1579                                                                    (?:
1580                                                                       (?> [^()]+ )    # Non-parens without backtracking
1581                                                                       |
1582                                                                       (??{ $bal })    # Group with matching parens
1583                                                                    )*
1584                                                                    \)
1585                                                                   /x;
1586                                                  
1587                                                  my $olc_re = qr/(?:--|#)[^'"\r\n]*(?=[\r\n]|\Z)/;  # One-line comments
1588                                                  my $mlc_re = qr#/\*[^!].*?\*/#sm;                  # But not /*!version */
1589                                                  my $vlc_re = qr#/\*.*?[0-9+].*?\*/#sm;             # For SHOW + /*!version */
1590                                                  my $vlc_rf = qr#^(SHOW).*?/\*![0-9+].*?\*/#sm;     # Variation for SHOW
1591                                                  
1592                                                  
1593                                                  sub new {
1594           7                    7            42      my ( $class, %args ) = @_;
1595           7                                 37      my $self = { %args };
1596           7                                 73      return bless $self, $class;
1597                                                  }
1598                                                  
1599                                                  sub strip_comments {
1600         115                  115           899      my ( $self, $query ) = @_;
1601  ***    115     50                         502      return unless $query;
1602         115                               3921      $query =~ s/$olc_re//go;
1603         115                                830      $query =~ s/$mlc_re//go;
1604  ***    115     50                        1587      if ( $query =~ m/$vlc_rf/i ) { # contains show + version
1605  ***      0                                  0         $query =~ s/$vlc_re//go;
1606                                                     }
1607         115                                594      return $query;
1608                                                  }
1609                                                  
1610                                                  sub shorten {
1611          96                   96          1317      my ( $self, $query, $length ) = @_;
1612          96                              57115      $query =~ s{
1613                                                        \A(
1614                                                           (?:INSERT|REPLACE)
1615                                                           (?:\s+LOW_PRIORITY|DELAYED|HIGH_PRIORITY|IGNORE)?
1616                                                           (?:\s\w+)*\s+\S+\s+VALUES\s*\(.*?\)
1617                                                        )
1618                                                        \s*,\s*\(.*?(ON\s+DUPLICATE|\Z)}
1619                                                        {$1 /*... omitted ...*/$2}xsi;
1620                                                  
1621          96    100                         878      return $query unless $query =~ m/IN\s*\(\s*(?!select)/i;
1622                                                  
1623           2                                  8      my $last_length  = 0;
1624           2                                  7      my $query_length = length($query);
1625  ***      2            33                   29      while (
      ***                    0                        
      ***                   33                        
1626                                                        $length          > 0
1627                                                        && $query_length > $length
1628                                                        && $query_length < ( $last_length || $query_length + 1 )
1629                                                     ) {
1630  ***      0                                  0         $last_length = $query_length;
1631  ***      0                                  0         $query =~ s{
1632  ***      0                                  0            (\bIN\s*\()    # The opening of an IN list
1633                                                           ([^\)]+)       # Contents of the list, assuming no item contains paren
1634                                                           (?=\))           # Close of the list
1635                                                        }
1636                                                        {
1637                                                           $1 . __shorten($2)
1638                                                        }gexsi;
1639                                                     }
1640                                                  
1641           2                                 10      return $query;
1642                                                  }
1643                                                  
1644                                                  sub __shorten {
1645  ***      0                    0             0      my ( $snippet ) = @_;
1646  ***      0                                  0      my @vals = split(/,/, $snippet);
1647  ***      0      0                           0      return $snippet unless @vals > 20;
1648  ***      0                                  0      my @keep = splice(@vals, 0, 20);  # Remove and save the first 20 items
1649                                                     return
1650  ***      0                                  0         join(',', @keep)
1651                                                        . "/*... omitted "
1652                                                        . scalar(@vals)
1653                                                        . " items ...*/";
1654                                                  }
1655                                                  
1656                                                  sub fingerprint {
1657         346                  346          2590      my ( $self, $query ) = @_;
1658                                                  
1659  ***    346     50                        1964      $query =~ m#\ASELECT /\*!40001 SQL_NO_CACHE \*/ \* FROM `# # mysqldump query
1660                                                        && return 'mysqldump';
1661  ***    346     50                        2248      $query =~ m#/\*\w+\.\w+:[0-9]/[0-9]\*/#     # mk-table-checksum, etc query
1662                                                        && return 'maatkit';
1663         346    100                        1854      $query =~ m/\A# administrator command: /
1664                                                        && return $query;
1665  ***    335     50                        1698      $query =~ m/\A\s*(call\s+\S+)\(/i
1666                                                        && return lc($1); # Warning! $1 used, be careful.
1667         335    100                        2055      if ( my ($beginning) = $query =~ m/\A((?:INSERT|REPLACE)(?: IGNORE)?\s+INTO.+?VALUES\s*\(.*?\))\s*,\s*\(/is ) {
1668           8                                 39         $query = $beginning; # Shorten multi-value INSERT statements ASAP
1669                                                     }
1670                                                    
1671         335                               1876      $query =~ s/$olc_re//go;
1672         335                               1526      $query =~ s/$mlc_re//go;
1673  ***    335     50                        1762      $query =~ s/\Ause \S+\Z/use ?/i       # Abstract the DB in USE
1674                                                        && return $query;
1675                                                  
1676         335                               1088      $query =~ s/\\["']//g;                # quoted strings
1677         335                               1122      $query =~ s/".*?"/?/sg;               # quoted strings
1678         335                               1115      $query =~ s/'.*?'/?/sg;               # quoted strings
1679         335                               1255      $query =~ s/[0-9+-][0-9a-f.xb+-]*/?/g;# Anything vaguely resembling numbers
1680         335                               1050      $query =~ s/[xb.+-]\?/?/g;            # Clean up leftovers
1681         335                               1105      $query =~ s/\A\s+//;                  # Chop off leading whitespace
1682         335                               1071      chomp $query;                         # Kill trailing whitespace
1683         335                               1306      $query =~ tr[ \n\t\r\f][ ]s;          # Collapse whitespace
1684         335                               1269      $query = lc $query;
1685         335                               1060      $query =~ s/\bnull\b/?/g;             # Get rid of NULLs
1686         335                               1526      $query =~ s{                          # Collapse IN and VALUES lists
1687                                                                 \b(in|values?)(?:[\s,]*\([\s?,]*\))+
1688                                                                }
1689                                                                {$1(?+)}gx;
1690         335                               1226      $query =~ s{                          # Collapse UNION
1691                                                                 \b(select\s.*?)(?:(\sunion(?:\sall)?)\s\1)+
1692                                                                }
1693                                                                {$1 /*repeat$2*/}xg;
1694         335                               1182      $query =~ s/\blimit \?(?:, ?\?| offset \?)?/limit ?/; # LIMIT
1695         335                               1740      return $query;
1696                                                  }
1697                                                  
1698                                                  sub distill_verbs {
1699         120                  120           978      my ( $self, $query ) = @_;
1700                                                  
1701  ***    120     50                         798      $query =~ m/\A\s*call\s+(\S+)\(/i && return "CALL $1";
1702  ***    120     50                        1426      $query =~ m/\A\s*use\s+/          && return "USE";
1703  ***    120     50                         596      $query =~ m/\A\s*UNLOCK TABLES/i  && return "UNLOCK";
1704  ***    120     50                         569      $query =~ m/\A\s*xa\s+(\S+)/i     && return "XA_$1";
1705                                                  
1706         120    100                         545      if ( $query =~ m/\A# administrator command:/ ) {
1707           5                                 30         $query =~ s/# administrator command:/ADMIN/go;
1708           5                                 30         $query = uc $query;
1709           5                                 35         return $query;
1710                                                     }
1711                                                  
1712         115                                798      $query = $self->strip_comments($query);
1713                                                  
1714         115    100                         741      if ( $query =~ m/\A\s*SHOW\s+/i ) {
1715           4                                 11         MKDEBUG && _d($query);
1716                                                  
1717           4                                 23         $query = uc $query;
1718           4                                 22         $query =~ s/\s+(?:GLOBAL|SESSION|FULL|STORAGE|ENGINE)\b/ /g;
1719           4                                 22         $query =~ s/\s+COUNT[^)]+\)//g;
1720                                                  
1721           4                                 13         $query =~ s/\s+(?:FOR|FROM|LIKE|WHERE|LIMIT|IN)\b.+//ms;
1722                                                  
1723           4                                 60         $query =~ s/\A(SHOW(?:\s+\S+){1,2}).*\Z/$1/s;
1724           4                                 20         $query =~ s/\s+/ /g;
1725           4                                  8         MKDEBUG && _d($query);
1726           4                                 27         return $query;
1727                                                     }
1728                                                  
1729         111                                412      eval $QueryParser::data_def_stmts;
1730         111                                297      eval $QueryParser::tbl_ident;
1731         111                               1421      my ( $dds ) = $query =~ /^\s*($QueryParser::data_def_stmts)\b/i;
1732         111    100                         533      if ( $dds) {
1733           2                                 42         my ( $obj ) = $query =~ m/$dds.+(DATABASE|TABLE)\b/i;
1734  ***      2     50                          11         $obj = uc $obj if $obj;
1735           2                                  5         MKDEBUG && _d('Data def statment:', $dds, 'obj:', $obj);
1736           2                                 58         my ($db_or_tbl)
1737                                                           = $query =~ m/(?:TABLE|DATABASE)\s+($QueryParser::tbl_ident)(\s+.*)?/i;
1738           2                                  6         MKDEBUG && _d('Matches db or table:', $db_or_tbl);
1739  ***      2     50                          17         return uc($dds . ($obj ? " $obj" : '')), $db_or_tbl;
1740                                                     }
1741                                                  
1742         109                             140690      my @verbs = $query =~ m/\b($verbs)\b/gio;
1743         109                                413      @verbs    = do {
1744         109                                350         my $last = '';
1745         109                                419         grep { my $pass = $_ ne $last; $last = $_; $pass } map { uc } @verbs;
             105                                395   
             105                                295   
             105                                527   
             105                                485   
1746                                                     };
1747         109                                470      my $verbs = join(q{ }, @verbs);
1748         109                                420      $verbs =~ s/( UNION SELECT)+/ UNION/g;
1749                                                  
1750         109                                547      return $verbs;
1751                                                  }
1752                                                  
1753                                                  sub __distill_tables {
1754         111                  111          1213      my ( $self, $query, $table, %args ) = @_;
1755  ***    111            33                 1295      my $qp = $args{QueryParser} || $self->{QueryParser};
1756  ***    111     50                         503      die "I need a QueryParser argument" unless $qp;
1757                                                  
1758          89                                351      my @tables = map {
1759          89                                370         $_ =~ s/`//g;
1760          89                                732         $_ =~ s/(_?)[0-9]+/$1?/g;
1761          89                                449         $_;
1762         111                                889      } grep { defined $_ } $qp->get_tables($query);
1763                                                  
1764         111    100                         523      push @tables, $table if $table;
1765                                                  
1766         111                                358      @tables = do {
1767         111                                338         my $last = '';
1768         111                                433         grep { my $pass = $_ ne $last; $last = $_; $pass } @tables;
              91                                338   
              91                                264   
              91                                412   
1769                                                     };
1770                                                  
1771         111                                542      return @tables;
1772                                                  }
1773                                                  
1774                                                  sub distill {
1775         115                  115          1191      my ( $self, $query, %args ) = @_;
1776                                                  
1777  ***    115     50                         557      if ( $args{generic} ) {
1778  ***      0                                  0         my ($cmd, $arg) = $query =~ m/^(\S+)\s+(\S+)/;
1779  ***      0      0                           0         return '' unless $cmd;
1780  ***      0      0                           0         $query = (uc $cmd) . ($arg ? " $arg" : '');
1781                                                     }
1782                                                     else {
1783         115                                860         my ($verbs, $table)  = $self->distill_verbs($query, %args);
1784                                                  
1785         115    100    100                 1317         if ( $verbs && $verbs =~ m/^SHOW/ ) {
1786           4                                 35            my %alias_for = qw(
1787                                                              SCHEMA   DATABASE
1788                                                              KEYS     INDEX
1789                                                              INDEXES  INDEX
1790                                                           );
1791           4                                 20            map { $verbs =~ s/$_/$alias_for{$_}/ } keys %alias_for;
              12                                145   
1792           4                                 21            $query = $verbs;
1793                                                        }
1794                                                        else {
1795         111                                805            my @tables = $self->__distill_tables($query, $table, %args);
1796         111                                569            $query     = join(q{ }, $verbs, @tables); 
1797                                                        } 
1798                                                     }
1799                                                  
1800  ***    115     50                         532      if ( $args{trf} ) {
1801  ***      0                                  0         $query = $args{trf}->($query, %args);
1802                                                     }
1803                                                  
1804         115                               1015      return $query;
1805                                                  }
1806                                                  
1807                                                  sub convert_to_select {
1808          55                   55           297      my ( $self, $query ) = @_;
1809  ***     55     50                         257      return unless $query;
1810          14                                107      $query =~ s{
      ***      0                                  0   
1811                                                                   \A.*?
1812                                                                   update\s+(.*?)
1813                                                                   \s+set\b(.*?)
1814                                                                   (?:\s*where\b(.*?))?
1815                                                                   (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
1816                                                                   \Z
1817                                                                }
1818                                                                {__update_to_select($1, $2, $3, $4)}exsi
1819  ***      0                                  0         || $query =~ s{
1820                                                                      \A.*?
1821                                                                      (?:insert(?:\s+ignore)?|replace)\s+
1822                                                                      .*?\binto\b(.*?)\(([^\)]+)\)\s*
1823                                                                      values?\s*(\(.*?\))\s*
1824                                                                      (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
1825                                                                      \Z
1826                                                                   }
1827                                                                   {__insert_to_select($1, $2, $3)}exsi
1828           1                                  8         || $query =~ s{
1829                                                                      \A.*?
1830                                                                      (?:insert(?:\s+ignore)?|replace)\s+
1831                                                                      (?:.*?\binto)\b(.*?)\s*
1832                                                                      set?\s*\b(.*?)\s*
1833                                                                      (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
1834                                                                      \Z
1835                                                                   }
1836                                                                   {__insert_to_select_with_set($1, $2)}exsi
1837  ***     55    100     66                 1604         || $query =~ s{
      ***                   66                        
1838                                                                      \A.*?
1839                                                                      delete\s+(.*?)
1840                                                                      \bfrom\b(.*)
1841                                                                      \Z
1842                                                                   }
1843                                                                   {__delete_to_select($1, $2)}exsi;
1844          55                                513      $query =~ s/\s*on\s+duplicate\s+key\s+update.*\Z//si;
1845          55                                379      $query =~ s/\A.*?(?=\bSELECT\s*\b)//ism;
1846          55                                252      return $query;
1847                                                  }
1848                                                  
1849                                                  sub convert_select_list {
1850  ***      0                    0             0      my ( $self, $query ) = @_;
1851  ***      0      0                           0      $query =~ s{
      ***      0                                  0   
1852                                                                 \A\s*select(.*?)\bfrom\b
1853                                                                }
1854                                                                {$1 =~ m/\*/ ? "select 1 from" : "select isnull(coalesce($1)) from"}exi;
1855  ***      0                                  0      return $query;
1856                                                  }
1857                                                  
1858                                                  sub __delete_to_select {
1859           1                    1             9      my ( $delete, $join ) = @_;
1860  ***      1     50                           8      if ( $join =~ m/\bjoin\b/ ) {
1861  ***      0                                  0         return "select 1 from $join";
1862                                                     }
1863           1                                  7      return "select * from $join";
1864                                                  }
1865                                                  
1866                                                  sub __insert_to_select {
1867  ***      0                    0             0      my ( $tbl, $cols, $vals ) = @_;
1868  ***      0                                  0      MKDEBUG && _d('Args:', @_);
1869  ***      0                                  0      my @cols = split(/,/, $cols);
1870  ***      0                                  0      MKDEBUG && _d('Cols:', @cols);
1871  ***      0                                  0      $vals =~ s/^\(|\)$//g; # Strip leading/trailing parens
1872  ***      0                                  0      my @vals = $vals =~ m/($quote_re|[^,]*${bal}[^,]*|[^,]+)/g;
1873  ***      0                                  0      MKDEBUG && _d('Vals:', @vals);
1874  ***      0      0                           0      if ( @cols == @vals ) {
1875  ***      0                                  0         return "select * from $tbl where "
1876  ***      0                                  0            . join(' and ', map { "$cols[$_]=$vals[$_]" } (0..$#cols));
1877                                                     }
1878                                                     else {
1879  ***      0                                  0         return "select * from $tbl limit 1";
1880                                                     }
1881                                                  }
1882                                                  
1883                                                  sub __insert_to_select_with_set {
1884  ***      0                    0             0      my ( $from, $set ) = @_;
1885  ***      0                                  0      $set =~ s/,/ and /g;
1886  ***      0                                  0      return "select * from $from where $set ";
1887                                                  }
1888                                                  
1889                                                  sub __update_to_select {
1890          14                   14           148      my ( $from, $set, $where, $limit ) = @_;
1891          14    100                         235      return "select $set from $from "
      ***            50                               
1892                                                        . ( $where ? "where $where" : '' )
1893                                                        . ( $limit ? " $limit "      : '' );
1894                                                  }
1895                                                  
1896                                                  sub wrap_in_derived {
1897  ***      0                    0             0      my ( $self, $query ) = @_;
1898  ***      0      0                           0      return unless $query;
1899  ***      0      0                           0      return $query =~ m/\A\s*select/i
1900                                                        ? "select 1 from ($query) as x limit 1"
1901                                                        : $query;
1902                                                  }
1903                                                  
1904                                                  sub _d {
1905  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1906  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1907  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1908                                                          @_;
1909  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1910                                                  }
1911                                                  
1912                                                  1;
1913                                                  
1914                                                  # ###########################################################################
1915                                                  # End QueryRewriter package
1916                                                  # ###########################################################################
1917                                                  
1918                                                  # ###########################################################################
1919                                                  # Processlist package 5266
1920                                                  # ###########################################################################
1921                                                  package Processlist;
1922                                                  
1923           7                    7            56   use strict;
               7                                 19   
               7                                 45   
1924           7                    7            40   use warnings FATAL => 'all';
               7                                 21   
               7                                 54   
1925           7                    7            43   use English qw(-no_match_vars);
               7                                 17   
               7                                 50   
1926                                                  
1927           7                    7            48   use Data::Dumper;
               7                                 15   
               7                                 44   
1928                                                  $Data::Dumper::Indent    = 1;
1929                                                  $Data::Dumper::Sortkeys  = 1;
1930                                                  $Data::Dumper::Quotekeys = 0;
1931                                                  
1932  ***      7            50      7            43   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 26   
               7                                 93   
1933                                                  use constant {
1934           7                                 85      ID      => 0,
1935                                                     USER    => 1,
1936                                                     HOST    => 2,
1937                                                     DB      => 3,
1938                                                     COMMAND => 4,
1939                                                     TIME    => 5,
1940                                                     STATE   => 6,
1941                                                     INFO    => 7,
1942                                                     START   => 8, # Calculated start time of statement
1943                                                     ETIME   => 9, # Exec time of SHOW PROCESSLIST (margin of error in START)
1944                                                     FSEEN   => 10, # First time ever seen
1945           7                    7            47   };
               7                                 23   
1946                                                  
1947                                                  sub new {
1948  ***      0                    0             0      my ( $class, %args ) = @_;
1949  ***      0                                  0      my $self = {
1950                                                        prev_rows => [],
1951                                                        new_rows  => [],
1952                                                        curr_row  => undef,
1953                                                        prev_row  => undef,
1954                                                     };
1955  ***      0                                  0      return bless $self, $class;
1956                                                  }
1957                                                  
1958                                                  sub parse_event {
1959  ***      0                    0             0      my ( $self, %args ) = @_;
1960  ***      0                                  0      my @required_args = qw(misc);
1961  ***      0                                  0      foreach my $arg ( @required_args ) {
1962  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1963                                                     }
1964  ***      0                                  0      my ($misc) = @args{@required_args};
1965                                                  
1966  ***      0                                  0      my $code = $misc->{code};
1967  ***      0      0                           0      die "I need a code arg to misc" unless $code;
1968                                                  
1969  ***      0                                  0      my @curr;
1970  ***      0      0                           0      if ( $self->{curr_rows} ) {
1971  ***      0                                  0         MKDEBUG && _d('Current rows from last call');
1972  ***      0                                  0         @curr = @{$self->{curr_rows}};
      ***      0                                  0   
1973                                                     }
1974                                                     else {
1975  ***      0                                  0         my $rows = $code->();
1976  ***      0      0      0                    0         if ( $rows && scalar @$rows ) {
1977  ***      0                                  0            MKDEBUG && _d('Got new current rows');
1978  ***      0                                  0            @curr = sort { $a->[ID] <=> $b->[ID] } @$rows;
      ***      0                                  0   
1979                                                        }
1980                                                        else {
1981  ***      0                                  0            MKDEBUG && _d('No current rows');
1982                                                        }
1983                                                     }
1984                                                  
1985  ***      0             0                    0      my @prev = @{$self->{prev_rows} ||= []};
      ***      0                                  0   
1986  ***      0             0                    0      my @new  = @{$self->{new_rows}  ||= []};; # Becomes next invocation's @prev
      ***      0                                  0   
1987  ***      0                                  0      my $curr = $self->{curr_row}; # Rows from each source
1988  ***      0                                  0      my $prev = $self->{prev_row};
1989  ***      0                                  0      my $event;
1990                                                  
1991  ***      0                                  0      MKDEBUG && _d('Rows:', scalar @prev, 'prev,', scalar @curr, 'current');
1992                                                  
1993  ***      0      0      0                    0      if ( !$curr && @curr ) {
1994  ***      0                                  0         MKDEBUG && _d('Fetching row from curr');
1995  ***      0                                  0         $curr = shift @curr;
1996                                                     }
1997  ***      0      0      0                    0      if ( !$prev && @prev ) {
1998  ***      0                                  0         MKDEBUG && _d('Fetching row from prev');
1999  ***      0                                  0         $prev = shift @prev;
2000                                                     }
2001  ***      0      0      0                    0      if ( $curr || $prev ) {
2002  ***      0      0      0                    0         if ( $curr && $prev && $curr->[ID] == $prev->[ID] ) {
      ***             0      0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
2003  ***      0                                  0            MKDEBUG && _d('$curr and $prev are the same cxn');
2004  ***      0      0                           0            my $fudge = $curr->[TIME] =~ m/\D/ ? 0.001 : 1; # Micro-precision?
2005  ***      0                                  0            my $is_new = 0;
2006  ***      0      0                           0            if ( $prev->[INFO] ) {
2007  ***      0      0      0                    0               if (!$curr->[INFO] || $prev->[INFO] ne $curr->[INFO]) {
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
2008  ***      0                                  0                  MKDEBUG && _d('$curr has a new query');
2009  ***      0                                  0                  $is_new = 1;
2010                                                              }
2011                                                              elsif (defined $curr->[TIME] && $curr->[TIME] < $prev->[TIME]) {
2012  ***      0                                  0                  MKDEBUG && _d('$curr time is less than $prev time');
2013  ***      0                                  0                  $is_new = 1;
2014                                                              }
2015                                                              elsif ( $curr->[INFO] && defined $curr->[TIME]
2016                                                                      && $misc->{time} - $curr->[TIME] - $prev->[START]
2017                                                                         - $prev->[ETIME] - $misc->{etime} > $fudge
2018                                                              ) {
2019  ***      0                                  0                  MKDEBUG && _d('$curr has same query that restarted');
2020  ***      0                                  0                  $is_new = 1;
2021                                                              }
2022  ***      0      0                           0               if ( $is_new ) {
2023  ***      0                                  0                  $event = $self->make_event($prev, $misc->{time});
2024                                                              }
2025                                                           }
2026  ***      0      0                           0            if ( $curr->[INFO] ) {
2027  ***      0      0      0                    0               if ( $prev->[INFO] && !$is_new ) {
2028  ***      0                                  0                  MKDEBUG && _d('Pushing old history item back onto $prev');
2029  ***      0                                  0                  push @new, [ @$prev ];
2030                                                              }
2031                                                              else {
2032  ***      0                                  0                  MKDEBUG && _d('Pushing new history item onto $prev');
2033  ***      0                                  0                  push @new,
2034                                                                    [ @$curr, int($misc->{time} - $curr->[TIME]),
2035                                                                       $misc->{etime}, $misc->{time} ];
2036                                                              }
2037                                                           }
2038  ***      0                                  0            $curr = $prev = undef; # Fetch another from each.
2039                                                        }
2040                                                        elsif ( !$curr
2041                                                                || ($curr && $prev && $curr->[ID] > $prev->[ID]) ) {
2042  ***      0                                  0            MKDEBUG && _d('$curr is not in $prev');
2043  ***      0                                  0            $event = $self->make_event($prev, $misc->{time});
2044  ***      0                                  0            $prev = undef;
2045                                                        }
2046                                                        else { # This else must be entered, to prevent infinite loops.
2047  ***      0                                  0            MKDEBUG && _d('$prev is not in $curr');
2048  ***      0      0      0                    0            if ( $curr->[INFO] && defined $curr->[TIME] ) {
2049  ***      0                                  0               MKDEBUG && _d('Pushing new history item onto $prev');
2050  ***      0                                  0               push @new,
2051                                                                 [ @$curr, int($misc->{time} - $curr->[TIME]),
2052                                                                    $misc->{etime}, $misc->{time} ];
2053                                                           }
2054  ***      0                                  0            $curr = undef; # No infinite loops.
2055                                                        }
2056                                                     }
2057                                                  
2058  ***      0                                  0      $self->{prev_rows} = \@new;
2059  ***      0                                  0      $self->{prev_row}  = $prev;
2060  ***      0      0                           0      $self->{curr_rows} = scalar @curr ? \@curr : undef;
2061  ***      0                                  0      $self->{curr_row}  = $curr;
2062                                                  
2063  ***      0                                  0      return $event;
2064                                                  }
2065                                                  
2066                                                  sub make_event {
2067  ***      0                    0             0      my ( $self, $row, $time ) = @_;
2068  ***      0                                  0      my $Query_time = $row->[TIME];
2069  ***      0      0                           0      if ( $row->[TIME] < $time - $row->[FSEEN] ) {
2070  ***      0                                  0         $Query_time = $time - $row->[FSEEN];
2071                                                     }
2072  ***      0                                  0      my $event = {
2073                                                        id         => $row->[ID],
2074                                                        db         => $row->[DB],
2075                                                        user       => $row->[USER],
2076                                                        host       => $row->[HOST],
2077                                                        arg        => $row->[INFO],
2078                                                        bytes      => length($row->[INFO]),
2079                                                        ts         => Transformers::ts($row->[START] + $row->[TIME]), # Query END time
2080                                                        Query_time => $Query_time,
2081                                                        Lock_time  => 0,               # TODO
2082                                                     };
2083  ***      0                                  0      MKDEBUG && _d('Properties of event:', Dumper($event));
2084  ***      0                                  0      return $event;
2085                                                  }
2086                                                  
2087                                                  sub _get_rows {
2088  ***      0                    0             0      my ( $self ) = @_;
2089  ***      0                                  0      my %rows = map { $_ => $self->{$_} }
      ***      0                                  0   
2090                                                        qw(prev_rows new_rows curr_row prev_row);
2091  ***      0                                  0      return \%rows;
2092                                                  }
2093                                                  
2094                                                  sub find {
2095  ***      0                    0             0      my ( $self, $proclist, %find_spec ) = @_;
2096  ***      0                                  0      MKDEBUG && _d('find specs:', Dumper(\%find_spec));
2097  ***      0                                  0      my @matches;
2098                                                     QUERY:
2099  ***      0                                  0      foreach my $query ( @$proclist ) {
2100  ***      0                                  0         MKDEBUG && _d('Checking query', Dumper($query));
2101  ***      0                                  0         my $matched = 0;
2102                                                  
2103  ***      0      0      0                    0         if ( $find_spec{busy_time} && ($query->{Command} || '') eq 'Query' ) {
      ***                    0                        
2104  ***      0      0                           0            if ( $query->{Time} < $find_spec{busy_time} ) {
2105  ***      0                                  0               MKDEBUG && _d("Query isn't running long enough");
2106  ***      0                                  0               next QUERY;
2107                                                           }
2108  ***      0                                  0            MKDEBUG && _d('Exceeds busy time');
2109  ***      0                                  0            $matched++;
2110                                                        }
2111                                                  
2112  ***      0      0      0                    0         if ( $find_spec{idle_time} && ($query->{Command} || '') eq 'Sleep' ) {
      ***                    0                        
2113  ***      0      0                           0            if ( $query->{Time} < $find_spec{idle_time} ) {
2114  ***      0                                  0               MKDEBUG && _d("Query isn't idle long enough");
2115  ***      0                                  0               next QUERY;
2116                                                           }
2117  ***      0                                  0            MKDEBUG && _d('Exceeds idle time');
2118  ***      0                                  0            $matched++;
2119                                                        }
2120                                                  
2121                                                        PROPERTY:
2122  ***      0                                  0         foreach my $property ( qw(Id User Host db State Command Info) ) {
2123  ***      0                                  0            my $filter = "_find_match_$property";
2124  ***      0      0      0                    0            if ( defined $find_spec{ignore}->{$property}
2125                                                                && $self->$filter($query, $find_spec{ignore}->{$property}) ) {
2126  ***      0                                  0               MKDEBUG && _d('Query matches ignore', $property, 'spec');
2127  ***      0                                  0               next QUERY;
2128                                                           }
2129  ***      0      0                           0            if ( defined $find_spec{match}->{$property} ) {
2130  ***      0      0                           0               if ( !$self->$filter($query, $find_spec{match}->{$property}) ) {
2131  ***      0                                  0                  MKDEBUG && _d('Query does not match', $property, 'spec');
2132  ***      0                                  0                  next QUERY;
2133                                                              }
2134  ***      0                                  0               MKDEBUG && _d('Query matches', $property, 'spec');
2135  ***      0                                  0               $matched++;
2136                                                           }
2137                                                        }
2138  ***      0      0                           0         if ( $matched ) {
2139  ***      0                                  0            MKDEBUG && _d("Query matched one or more specs, adding");
2140  ***      0                                  0            push @matches, $query;
2141  ***      0                                  0            next QUERY;
2142                                                        }
2143  ***      0                                  0         MKDEBUG && _d('Query does not match any specs, ignoring');
2144                                                     } # QUERY
2145                                                  
2146  ***      0      0      0                    0      if ( @matches && $find_spec{only_oldest} ) {
2147  ***      0                                  0         my ( $oldest ) = reverse sort { $a->{Time} <=> $b->{Time} } @matches;
      ***      0                                  0   
2148  ***      0                                  0         MKDEBUG && _d('Oldest query:', Dumper($oldest));
2149  ***      0                                  0         @matches = $oldest;
2150                                                     }
2151                                                  
2152  ***      0                                  0      return @matches;
2153                                                  }
2154                                                  
2155                                                  sub _find_match_Id {
2156  ***      0                    0             0      my ( $self, $query, $property ) = @_;
2157  ***      0             0                    0      return defined $property && defined $query->{Id} && $query->{Id} == $property;
      ***                    0                        
2158                                                  }
2159                                                  
2160                                                  sub _find_match_User {
2161  ***      0                    0             0      my ( $self, $query, $property ) = @_;
2162  ***      0             0                    0      return defined $property && defined $query->{User}
      ***                    0                        
2163                                                        && $query->{User} =~ m/$property/;
2164                                                  }
2165                                                  
2166                                                  sub _find_match_Host {
2167  ***      0                    0             0      my ( $self, $query, $property ) = @_;
2168  ***      0             0                    0      return defined $property && defined $query->{Host}
      ***                    0                        
2169                                                        && $query->{Host} =~ m/$property/;
2170                                                  }
2171                                                  
2172                                                  sub _find_match_db {
2173  ***      0                    0             0      my ( $self, $query, $property ) = @_;
2174  ***      0             0                    0      return defined $property && defined $query->{db}
      ***                    0                        
2175                                                        && $query->{db} =~ m/$property/;
2176                                                  }
2177                                                  
2178                                                  sub _find_match_State {
2179  ***      0                    0             0      my ( $self, $query, $property ) = @_;
2180  ***      0             0                    0      return defined $property && defined $query->{State}
      ***                    0                        
2181                                                        && $query->{State} =~ m/$property/;
2182                                                  }
2183                                                  
2184                                                  sub _find_match_Command {
2185  ***      0                    0             0      my ( $self, $query, $property ) = @_;
2186  ***      0             0                    0      return defined $property && defined $query->{Command}
      ***                    0                        
2187                                                        && $query->{Command} =~ m/$property/;
2188                                                  }
2189                                                  
2190                                                  sub _find_match_Info {
2191  ***      0                    0             0      my ( $self, $query, $property ) = @_;
2192  ***      0             0                    0      return defined $property && defined $query->{Info}
      ***                    0                        
2193                                                        && $query->{Info} =~ m/$property/;
2194                                                  }
2195                                                  
2196                                                  sub _d {
2197  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2198  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2199  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2200                                                          @_;
2201  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2202                                                  }
2203                                                  
2204                                                  1;
2205                                                  
2206                                                  # ###########################################################################
2207                                                  # End Processlist package
2208                                                  # ###########################################################################
2209                                                  
2210                                                  # ###########################################################################
2211                                                  # TcpdumpParser package 5818
2212                                                  # ###########################################################################
2213                                                  package TcpdumpParser;
2214                                                  
2215                                                  
2216           7                    7            56   use strict;
               7                                 18   
               7                                 40   
2217           7                    7            45   use warnings FATAL => 'all';
               7                                 15   
               7                                 40   
2218           7                    7            44   use English qw(-no_match_vars);
               7                                 19   
               7                                 37   
2219           7                    7            45   use Data::Dumper;
               7                                 19   
               7                                 36   
2220                                                  $Data::Dumper::Indent   = 1;
2221                                                  $Data::Dumper::Sortkeys = 1;
2222                                                  
2223  ***      7            50      7            44   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 17   
               7                                107   
2224                                                  
2225                                                  sub new {
2226          12                   12           126      my ( $class, %args ) = @_;
2227          12                                 67      my $self = {};
2228          12                                136      return bless $self, $class;
2229                                                  }
2230                                                  
2231                                                  sub parse_event {
2232         113                  113           631      my ( $self, %args ) = @_;
2233         113                                561      my @required_args = qw(next_event tell);
2234         113                                385      foreach my $arg ( @required_args ) {
2235  ***    226     50                        1080         die "I need a $arg argument" unless $args{$arg};
2236                                                     }
2237         113                                500      my ($next_event, $tell) = @args{@required_args};
2238                                                  
2239         113                                661      local $INPUT_RECORD_SEPARATOR = "\n20";
2240                                                  
2241         113                                413      my $pos_in_log = $tell->();
2242         113                                452      while ( defined(my $raw_packet = $next_event->()) ) {
2243  ***    101     50                         645         next if $raw_packet =~ m/^$/;  # issue 564
2244         101    100                         417         $pos_in_log -= 1 if $pos_in_log;
2245                                                  
2246         101                                554         $raw_packet =~ s/\n20\Z//;
2247         101    100                         613         $raw_packet = "20$raw_packet" unless $raw_packet =~ m/\A20/;
2248                                                  
2249         101                               1380         $raw_packet =~ s/0x0000:.+?(450.) /0x0000:  $1 /;
2250                                                  
2251         101                                503         my $packet = $self->_parse_packet($raw_packet);
2252         101                                386         $packet->{pos_in_log} = $pos_in_log;
2253         101                                471         $packet->{raw_packet} = $raw_packet;
2254                                                  
2255         101                                775         return $packet;
2256                                                     }
2257                                                  
2258  ***     12     50                          90      $args{oktorun}->(0) if $args{oktorun};
2259          12                                 76      return;
2260                                                  }
2261                                                  
2262                                                  sub _parse_packet {
2263         101                  101           518      my ( $self, $packet ) = @_;
2264  ***    101     50                         429      die "I need a packet" unless $packet;
2265                                                  
2266         101                               1051      my ( $ts, $source, $dest )  = $packet =~ m/\A(\S+ \S+).*? IP .*?(\S+) > (\S+):/;
2267         101                                824      my ( $src_host, $src_port ) = $source =~ m/((?:\d+\.){3}\d+)\.(\w+)/;
2268         101                                693      my ( $dst_host, $dst_port ) = $dest   =~ m/((?:\d+\.){3}\d+)\.(\w+)/;
2269                                                  
2270         101                                497      $src_port = $self->port_number($src_port);
2271         101                                354      $dst_port = $self->port_number($dst_port);
2272                                                     
2273         101                                711      my $hex = qr/[0-9a-f]/;
2274         101                               3721      (my $data = join('', $packet =~ m/\s+0x$hex+:\s((?:\s$hex{2,4})+)/go)) =~ s/\s+//g; 
2275                                                  
2276         101                                569      my $ip_hlen = hex(substr($data, 1, 1)); # Num of 32-bit words in header.
2277         101                                363      my $ip_plen = hex(substr($data, 4, 4)); # Num of BYTES in IPv4 datagram.
2278  ***    101     50                         535      my $complete = length($data) == 2 * $ip_plen ? 1 : 0;
2279                                                  
2280         101                                414      my $tcp_hlen = hex(substr($data, ($ip_hlen + 3) * 8, 1));
2281                                                  
2282         101                                416      my $seq = hex(substr($data, ($ip_hlen + 1) * 8, 8));
2283         101                                412      my $ack = hex(substr($data, ($ip_hlen + 2) * 8, 8));
2284                                                  
2285         101                                467      my $flags = hex(substr($data, (($ip_hlen + 3) * 8) + 2, 2));
2286                                                  
2287         101                                378      $data = substr($data, ($ip_hlen + $tcp_hlen) * 8);
2288                                                  
2289         101    100                        2157      my $pkt = {
                    100                               
2290                                                        ts        => $ts,
2291                                                        seq       => $seq,
2292                                                        ack       => $ack,
2293                                                        fin       => $flags & 0x01,
2294                                                        syn       => $flags & 0x02,
2295                                                        rst       => $flags & 0x04,
2296                                                        src_host  => $src_host,
2297                                                        src_port  => $src_port,
2298                                                        dst_host  => $dst_host,
2299                                                        dst_port  => $dst_port,
2300                                                        complete  => $complete,
2301                                                        ip_hlen   => $ip_hlen,
2302                                                        tcp_hlen  => $tcp_hlen,
2303                                                        dgram_len => $ip_plen,
2304                                                        data_len  => $ip_plen - (($ip_hlen + $tcp_hlen) * 4),
2305                                                        data      => $data ? substr($data, 0, 10).(length $data > 10 ? '...' : '')
2306                                                                           : '',
2307                                                     };
2308         101                                259      MKDEBUG && _d('packet:', Dumper($pkt));
2309         101                                390      $pkt->{data} = $data;
2310         101                                705      return $pkt;
2311                                                  }
2312                                                  
2313                                                  sub port_number {
2314         202                  202           755      my ( $self, $port ) = @_;
2315  ***    202     50                         735      return unless $port;
2316         202    100                        1399      return $port eq 'memcached' ? 11211
      ***            50                               
      ***            50                               
2317                                                          : $port eq 'http'      ? 80
2318                                                          : $port eq 'mysql'     ? 3306
2319                                                          :                        $port; 
2320                                                  }
2321                                                  
2322                                                  sub _d {
2323  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2324  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2325  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2326                                                          @_;
2327  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2328                                                  }
2329                                                  
2330                                                  1;
2331                                                  
2332                                                  # ###########################################################################
2333                                                  # End TcpdumpParser package
2334                                                  # ###########################################################################
2335                                                  
2336                                                  # ###########################################################################
2337                                                  # MySQLProtocolParser package 5809
2338                                                  # ###########################################################################
2339                                                  package MySQLProtocolParser;
2340                                                  
2341                                                  
2342           7                    7            54   use strict;
               7                                 31   
               7                                 41   
2343           7                    7            42   use warnings FATAL => 'all';
               7                                 15   
               7                                 40   
2344           7                    7            48   use English qw(-no_match_vars);
               7                                 15   
               7                                 39   
2345                                                  
2346                                                  eval {
2347                                                     require IO::Uncompress::Inflate;
2348                                                     IO::Uncompress::Inflate->import(qw(inflate $InflateError));
2349                                                  };
2350                                                  
2351           7                    7            45   use Data::Dumper;
               7                                 18   
               7                                 35   
2352                                                  $Data::Dumper::Indent    = 1;
2353                                                  $Data::Dumper::Sortkeys  = 1;
2354                                                  $Data::Dumper::Quotekeys = 0;
2355                                                  
2356                                                  require Exporter;
2357                                                  our @ISA         = qw(Exporter);
2358                                                  our %EXPORT_TAGS = ();
2359                                                  our @EXPORT      = ();
2360                                                  our @EXPORT_OK   = qw(
2361                                                     parse_error_packet
2362                                                     parse_ok_packet
2363                                                     parse_ok_prepared_statement_packet
2364                                                     parse_server_handshake_packet
2365                                                     parse_client_handshake_packet
2366                                                     parse_com_packet
2367                                                     parse_flags
2368                                                  );
2369                                                  
2370  ***      7            50      7            47   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 39   
               7                                 97   
2371                                                  use constant {
2372           7                                240      COM_SLEEP               => '00',
2373                                                     COM_QUIT                => '01',
2374                                                     COM_INIT_DB             => '02',
2375                                                     COM_QUERY               => '03',
2376                                                     COM_FIELD_LIST          => '04',
2377                                                     COM_CREATE_DB           => '05',
2378                                                     COM_DROP_DB             => '06',
2379                                                     COM_REFRESH             => '07',
2380                                                     COM_SHUTDOWN            => '08',
2381                                                     COM_STATISTICS          => '09',
2382                                                     COM_PROCESS_INFO        => '0a',
2383                                                     COM_CONNECT             => '0b',
2384                                                     COM_PROCESS_KILL        => '0c',
2385                                                     COM_DEBUG               => '0d',
2386                                                     COM_PING                => '0e',
2387                                                     COM_TIME                => '0f',
2388                                                     COM_DELAYED_INSERT      => '10',
2389                                                     COM_CHANGE_USER         => '11',
2390                                                     COM_BINLOG_DUMP         => '12',
2391                                                     COM_TABLE_DUMP          => '13',
2392                                                     COM_CONNECT_OUT         => '14',
2393                                                     COM_REGISTER_SLAVE      => '15',
2394                                                     COM_STMT_PREPARE        => '16',
2395                                                     COM_STMT_EXECUTE        => '17',
2396                                                     COM_STMT_SEND_LONG_DATA => '18',
2397                                                     COM_STMT_CLOSE          => '19',
2398                                                     COM_STMT_RESET          => '1a',
2399                                                     COM_SET_OPTION          => '1b',
2400                                                     COM_STMT_FETCH          => '1c',
2401                                                     SERVER_QUERY_NO_GOOD_INDEX_USED => 16,
2402                                                     SERVER_QUERY_NO_INDEX_USED      => 32,
2403           7                    7            44   };
               7                                 21   
2404                                                  
2405                                                  my %com_for = (
2406                                                     '00' => 'COM_SLEEP',
2407                                                     '01' => 'COM_QUIT',
2408                                                     '02' => 'COM_INIT_DB',
2409                                                     '03' => 'COM_QUERY',
2410                                                     '04' => 'COM_FIELD_LIST',
2411                                                     '05' => 'COM_CREATE_DB',
2412                                                     '06' => 'COM_DROP_DB',
2413                                                     '07' => 'COM_REFRESH',
2414                                                     '08' => 'COM_SHUTDOWN',
2415                                                     '09' => 'COM_STATISTICS',
2416                                                     '0a' => 'COM_PROCESS_INFO',
2417                                                     '0b' => 'COM_CONNECT',
2418                                                     '0c' => 'COM_PROCESS_KILL',
2419                                                     '0d' => 'COM_DEBUG',
2420                                                     '0e' => 'COM_PING',
2421                                                     '0f' => 'COM_TIME',
2422                                                     '10' => 'COM_DELAYED_INSERT',
2423                                                     '11' => 'COM_CHANGE_USER',
2424                                                     '12' => 'COM_BINLOG_DUMP',
2425                                                     '13' => 'COM_TABLE_DUMP',
2426                                                     '14' => 'COM_CONNECT_OUT',
2427                                                     '15' => 'COM_REGISTER_SLAVE',
2428                                                     '16' => 'COM_STMT_PREPARE',
2429                                                     '17' => 'COM_STMT_EXECUTE',
2430                                                     '18' => 'COM_STMT_SEND_LONG_DATA',
2431                                                     '19' => 'COM_STMT_CLOSE',
2432                                                     '1a' => 'COM_STMT_RESET',
2433                                                     '1b' => 'COM_SET_OPTION',
2434                                                     '1c' => 'COM_STMT_FETCH',
2435                                                  );
2436                                                  
2437                                                  my %flag_for = (
2438                                                     'CLIENT_LONG_PASSWORD'     => 1,       # new more secure passwords 
2439                                                     'CLIENT_FOUND_ROWS'        => 2,       # Found instead of affected rows 
2440                                                     'CLIENT_LONG_FLAG'         => 4,       # Get all column flags 
2441                                                     'CLIENT_CONNECT_WITH_DB'   => 8,       # One can specify db on connect 
2442                                                     'CLIENT_NO_SCHEMA'         => 16,      # Don't allow database.table.column 
2443                                                     'CLIENT_COMPRESS'          => 32,      # Can use compression protocol 
2444                                                     'CLIENT_ODBC'              => 64,      # Odbc client 
2445                                                     'CLIENT_LOCAL_FILES'       => 128,     # Can use LOAD DATA LOCAL 
2446                                                     'CLIENT_IGNORE_SPACE'      => 256,     # Ignore spaces before '(' 
2447                                                     'CLIENT_PROTOCOL_41'       => 512,     # New 4.1 protocol 
2448                                                     'CLIENT_INTERACTIVE'       => 1024,    # This is an interactive client 
2449                                                     'CLIENT_SSL'               => 2048,    # Switch to SSL after handshake 
2450                                                     'CLIENT_IGNORE_SIGPIPE'    => 4096,    # IGNORE sigpipes 
2451                                                     'CLIENT_TRANSACTIONS'      => 8192,    # Client knows about transactions 
2452                                                     'CLIENT_RESERVED'          => 16384,   # Old flag for 4.1 protocol  
2453                                                     'CLIENT_SECURE_CONNECTION' => 32768,   # New 4.1 authentication 
2454                                                     'CLIENT_MULTI_STATEMENTS'  => 65536,   # Enable/disable multi-stmt support 
2455                                                     'CLIENT_MULTI_RESULTS'     => 131072,  # Enable/disable multi-results 
2456                                                  );
2457                                                  
2458                                                  use constant {
2459           7                                199      MYSQL_TYPE_DECIMAL      => 0,
2460                                                     MYSQL_TYPE_TINY         => 1,
2461                                                     MYSQL_TYPE_SHORT        => 2,
2462                                                     MYSQL_TYPE_LONG         => 3,
2463                                                     MYSQL_TYPE_FLOAT        => 4,
2464                                                     MYSQL_TYPE_DOUBLE       => 5,
2465                                                     MYSQL_TYPE_NULL         => 6,
2466                                                     MYSQL_TYPE_TIMESTAMP    => 7,
2467                                                     MYSQL_TYPE_LONGLONG     => 8,
2468                                                     MYSQL_TYPE_INT24        => 9,
2469                                                     MYSQL_TYPE_DATE         => 10,
2470                                                     MYSQL_TYPE_TIME         => 11,
2471                                                     MYSQL_TYPE_DATETIME     => 12,
2472                                                     MYSQL_TYPE_YEAR         => 13,
2473                                                     MYSQL_TYPE_NEWDATE      => 14,
2474                                                     MYSQL_TYPE_VARCHAR      => 15,
2475                                                     MYSQL_TYPE_BIT          => 16,
2476                                                     MYSQL_TYPE_NEWDECIMAL   => 246,
2477                                                     MYSQL_TYPE_ENUM         => 247,
2478                                                     MYSQL_TYPE_SET          => 248,
2479                                                     MYSQL_TYPE_TINY_BLOB    => 249,
2480                                                     MYSQL_TYPE_MEDIUM_BLOB  => 250,
2481                                                     MYSQL_TYPE_LONG_BLOB    => 251,
2482                                                     MYSQL_TYPE_BLOB         => 252,
2483                                                     MYSQL_TYPE_VAR_STRING   => 253,
2484                                                     MYSQL_TYPE_STRING       => 254,
2485                                                     MYSQL_TYPE_GEOMETRY     => 255,
2486           7                    7            46   };
               7                                 17   
2487                                                  
2488                                                  my %type_for = (
2489                                                     0   => 'MYSQL_TYPE_DECIMAL',
2490                                                     1   => 'MYSQL_TYPE_TINY',
2491                                                     2   => 'MYSQL_TYPE_SHORT',
2492                                                     3   => 'MYSQL_TYPE_LONG',
2493                                                     4   => 'MYSQL_TYPE_FLOAT',
2494                                                     5   => 'MYSQL_TYPE_DOUBLE',
2495                                                     6   => 'MYSQL_TYPE_NULL',
2496                                                     7   => 'MYSQL_TYPE_TIMESTAMP',
2497                                                     8   => 'MYSQL_TYPE_LONGLONG',
2498                                                     9   => 'MYSQL_TYPE_INT24',
2499                                                     10  => 'MYSQL_TYPE_DATE',
2500                                                     11  => 'MYSQL_TYPE_TIME',
2501                                                     12  => 'MYSQL_TYPE_DATETIME',
2502                                                     13  => 'MYSQL_TYPE_YEAR',
2503                                                     14  => 'MYSQL_TYPE_NEWDATE',
2504                                                     15  => 'MYSQL_TYPE_VARCHAR',
2505                                                     16  => 'MYSQL_TYPE_BIT',
2506                                                     246 => 'MYSQL_TYPE_NEWDECIMAL',
2507                                                     247 => 'MYSQL_TYPE_ENUM',
2508                                                     248 => 'MYSQL_TYPE_SET',
2509                                                     249 => 'MYSQL_TYPE_TINY_BLOB',
2510                                                     250 => 'MYSQL_TYPE_MEDIUM_BLOB',
2511                                                     251 => 'MYSQL_TYPE_LONG_BLOB',
2512                                                     252 => 'MYSQL_TYPE_BLOB',
2513                                                     253 => 'MYSQL_TYPE_VAR_STRING',
2514                                                     254 => 'MYSQL_TYPE_STRING',
2515                                                     255 => 'MYSQL_TYPE_GEOMETRY',
2516                                                  );
2517                                                  
2518                                                  my %unpack_type = (
2519                                                     MYSQL_TYPE_NULL       => sub { return 'NULL', 0; },
2520                                                     MYSQL_TYPE_TINY       => sub { return to_num(@_, 1), 1; },
2521                                                     MySQL_TYPE_SHORT      => sub { return to_num(@_, 2), 2; },
2522                                                     MYSQL_TYPE_LONG       => sub { return to_num(@_, 4), 4; },
2523                                                     MYSQL_TYPE_LONGLONG   => sub { return to_num(@_, 8), 8; },
2524                                                     MYSQL_TYPE_DOUBLE     => sub { return to_double(@_), 8; },
2525                                                     MYSQL_TYPE_VARCHAR    => \&unpack_string,
2526                                                     MYSQL_TYPE_VAR_STRING => \&unpack_string,
2527                                                     MYSQL_TYPE_STRING     => \&unpack_string,
2528                                                  );
2529                                                  
2530                                                  sub new {
2531          12                   12            90      my ( $class, %args ) = @_;
2532                                                  
2533          12           100                  174      my $self = {
2534                                                        server         => $args{server},
2535                                                        port           => $args{port} || '3306',
2536                                                        version        => '41',    # MySQL proto version; not used yet
2537                                                        sessions       => {},
2538                                                        o              => $args{o},
2539                                                        fake_thread_id => 2**32,   # see _make_event()
2540                                                     };
2541          12                                 32      MKDEBUG && $self->{server} && _d('Watching only server', $self->{server});
2542          12                                 94      return bless $self, $class;
2543                                                  }
2544                                                  
2545                                                  sub parse_event {
2546         101                  101           598      my ( $self, %args ) = @_;
2547         101                                458      my @required_args = qw(event);
2548         101                                371      foreach my $arg ( @required_args ) {
2549  ***    101     50                         623         die "I need a $arg argument" unless $args{$arg};
2550                                                     }
2551         101                                387      my $packet = @args{@required_args};
2552                                                  
2553         101                                503      my $src_host = "$packet->{src_host}:$packet->{src_port}";
2554         101                                463      my $dst_host = "$packet->{dst_host}:$packet->{dst_port}";
2555                                                  
2556         101    100                         534      if ( my $server = $self->{server} ) {  # Watch only the given server.
2557          66                                267         $server .= ":$self->{port}";
2558  ***     66     50     66                  572         if ( $src_host ne $server && $dst_host ne $server ) {
2559  ***      0                                  0            MKDEBUG && _d('Packet is not to or from', $server);
2560  ***      0                                  0            return;
2561                                                        }
2562                                                     }
2563                                                  
2564         101                                243      my $packet_from;
2565         101                                255      my $client;
2566         101    100                         905      if ( $src_host =~ m/:$self->{port}$/ ) {
      ***            50                               
2567          49                                146         $packet_from = 'server';
2568          49                                147         $client      = $dst_host;
2569                                                     }
2570                                                     elsif ( $dst_host =~ m/:$self->{port}$/ ) {
2571          52                                148         $packet_from = 'client';
2572          52                                162         $client      = $src_host;
2573                                                     }
2574                                                     else {
2575  ***      0                                  0         MKDEBUG && _d('Packet is not to or from a MySQL server');
2576  ***      0                                  0         return;
2577                                                     }
2578         101                                227      MKDEBUG && _d('Client', $client);
2579                                                  
2580         101                                295      my $packetno = -1;
2581         101    100                         493      if ( $packet->{data_len} >= 5 ) {
2582          73                                558         $packetno = to_num(substr($packet->{data}, 6, 2));
2583                                                     }
2584         101    100                         570      if ( !exists $self->{sessions}->{$client} ) {
2585          21    100                         128         if ( $packet->{syn} ) {
                    100                               
2586           2                                  6            MKDEBUG && _d('New session (SYN)');
2587                                                        }
2588                                                        elsif ( $packetno == 0 ) {
2589          10                                 28            MKDEBUG && _d('New session (packetno 0)');
2590                                                        }
2591                                                        else {
2592           9                                 21            MKDEBUG && _d('Ignoring mid-stream', $packet_from, 'data,',
2593                                                              'packetno', $packetno);
2594           9                                 48            return;
2595                                                        }
2596                                                  
2597          12                                225         $self->{sessions}->{$client} = {
2598                                                           client        => $client,
2599                                                           ts            => $packet->{ts},
2600                                                           state         => undef,
2601                                                           compress      => undef,
2602                                                           raw_packets   => [],
2603                                                           buff          => '',
2604                                                           sths          => {},
2605                                                           attribs       => {},
2606                                                           n_queries     => 0,
2607                                                        };
2608                                                     }
2609          92                                389      my $session = $self->{sessions}->{$client};
2610          92                                220      MKDEBUG && _d('Client state:', $session->{state});
2611                                                  
2612          92                                237      push @{$session->{raw_packets}}, $packet->{raw_packet};
              92                                552   
2613                                                  
2614  ***     92     50     33                  568      if ( $packet->{syn} && ($session->{n_queries} > 0 || $session->{state}) ) {
      ***                   66                        
2615  ***      0                                  0         MKDEBUG && _d('Client port reuse and last session did not quit');
2616  ***      0                                  0         $self->fail_session($session,
2617                                                              'client port reuse and last session did not quit');
2618  ***      0                                  0         return $self->parse_event(%args);
2619                                                     }
2620                                                  
2621          92    100                         409      if ( $packet->{data_len} == 0 ) {
2622                                                        MKDEBUG && _d('TCP control:',
2623          19                                 41            map { uc $_ } grep { $packet->{$_} } qw(syn ack fin rst));
2624          19                                113         return;
2625                                                     }
2626                                                  
2627  ***     73     50                         334      if ( $session->{compress} ) {
2628  ***      0      0                           0         return unless $self->uncompress_packet($packet, $session);
2629                                                     }
2630                                                  
2631  ***     73     50     33                  402      if ( $session->{buff} && $packet_from eq 'client' ) {
2632  ***      0                                  0         $session->{buff}      .= $packet->{data};
2633  ***      0                                  0         $packet->{data}        = $session->{buff};
2634  ***      0                                  0         $session->{buff_left} -= $packet->{data_len};
2635                                                  
2636  ***      0                                  0         $packet->{mysql_data_len} = $session->{mysql_data_len};
2637  ***      0                                  0         $packet->{number}         = $session->{number};
2638                                                  
2639  ***      0                                  0         MKDEBUG && _d('Appending data to buff; expecting',
2640                                                           $session->{buff_left}, 'more bytes');
2641                                                     }
2642                                                     else { 
2643          73                                228         eval {
2644          73                                379            remove_mysql_header($packet);
2645                                                        };
2646  ***     73     50                         314         if ( $EVAL_ERROR ) {
2647  ***      0                                  0            MKDEBUG && _d('remove_mysql_header() failed; failing session');
2648  ***      0                                  0            $session->{EVAL_ERROR} = $EVAL_ERROR;
2649  ***      0                                  0            $self->fail_session($session, 'remove_mysql_header() failed');
2650  ***      0                                  0            return;
2651                                                        }
2652                                                     }
2653                                                  
2654          73                                195      my $event;
2655          73    100                         390      if ( $packet_from eq 'server' ) {
      ***            50                               
2656          35                                242         $event = $self->_packet_from_server($packet, $session, $args{misc});
2657                                                     }
2658                                                     elsif ( $packet_from eq 'client' ) {
2659  ***     38     50                         307         if ( $session->{buff} ) {
      ***            50                               
2660  ***      0      0                           0            if ( $session->{buff_left} <= 0 ) {
2661  ***      0                                  0               MKDEBUG && _d('Data is complete');
2662  ***      0                                  0               $self->_delete_buff($session);
2663                                                           }
2664                                                           else {
2665  ***      0                                  0               return;  # waiting for more data; buff_left was reported earlier
2666                                                           }
2667                                                        }
2668                                                        elsif ( $packet->{mysql_data_len} > ($packet->{data_len} - 4) ) {
2669                                                  
2670  ***      0      0      0                    0            if ( $session->{cmd} && ($session->{state} || '') eq 'awaiting_reply' ) {
      ***                    0                        
2671  ***      0                                  0               MKDEBUG && _d('No server OK to previous command (frag)');
2672  ***      0                                  0               $self->fail_session($session, 'no server OK to previous command');
2673  ***      0                                  0               $packet->{data} = $packet->{mysql_hdr} . $packet->{data};
2674  ***      0                                  0               return $self->parse_event(%args);
2675                                                           }
2676                                                  
2677  ***      0                                  0            $session->{buff}           = $packet->{data};
2678  ***      0                                  0            $session->{mysql_data_len} = $packet->{mysql_data_len};
2679  ***      0                                  0            $session->{number}         = $packet->{number};
2680                                                  
2681  ***      0             0                    0            $session->{buff_left}
2682                                                              ||= $packet->{mysql_data_len} - ($packet->{data_len} - 4);
2683                                                  
2684  ***      0                                  0            MKDEBUG && _d('Data not complete; expecting',
2685                                                              $session->{buff_left}, 'more bytes');
2686  ***      0                                  0            return;
2687                                                        }
2688                                                  
2689  ***     38     50      0                  313         if ( $session->{cmd} && ($session->{state} || '') eq 'awaiting_reply' ) {
      ***                   33                        
2690  ***      0                                  0            MKDEBUG && _d('No server OK to previous command');
2691  ***      0                                  0            $self->fail_session($session, 'no server OK to previous command');
2692  ***      0                                  0            $packet->{data} = $packet->{mysql_hdr} . $packet->{data};
2693  ***      0                                  0            return $self->parse_event(%args);
2694                                                        }
2695                                                  
2696          38                                285         $event = $self->_packet_from_client($packet, $session, $args{misc});
2697                                                     }
2698                                                     else {
2699  ***      0                                  0         die 'Packet origin unknown';
2700                                                     }
2701                                                  
2702          73                                197      MKDEBUG && _d('Done parsing packet; client state:', $session->{state});
2703          73    100                         348      if ( $session->{closed} ) {
2704           3                                 15         delete $self->{sessions}->{$session->{client}};
2705           3                                  9         MKDEBUG && _d('Session deleted');
2706                                                     }
2707                                                  
2708          73                                483      return $event;
2709                                                  }
2710                                                  
2711                                                  sub _packet_from_server {
2712          35                   35           178      my ( $self, $packet, $session, $misc ) = @_;
2713  ***     35     50                         159      die "I need a packet"  unless $packet;
2714  ***     35     50                         156      die "I need a session" unless $session;
2715                                                  
2716          35                                 88      MKDEBUG && _d('Packet is from server; client state:', $session->{state}); 
2717                                                  
2718  ***     35     50    100                  351      if ( ($session->{server_seq} || '') eq $packet->{seq} ) {
2719  ***      0                                  0         push @{ $session->{server_retransmissions} }, $packet->{seq};
      ***      0                                  0   
2720  ***      0                                  0         MKDEBUG && _d('TCP retransmission');
2721  ***      0                                  0         return;
2722                                                     }
2723          35                                167      $session->{server_seq} = $packet->{seq};
2724                                                  
2725          35                                137      my $data = $packet->{data};
2726                                                  
2727                                                  
2728          35                                155      my ( $first_byte ) = substr($data, 0, 2, '');
2729          35                                 80      MKDEBUG && _d('First byte of packet:', $first_byte);
2730  ***     35     50                         160      if ( !$first_byte ) {
2731  ***      0                                  0         $self->fail_session($session, 'no first byte');
2732  ***      0                                  0         return;
2733                                                     }
2734                                                  
2735          35    100                         150      if ( !$session->{state} ) {
2736  ***      2     50     33                   60         if ( $first_byte eq '0a' && length $data >= 33 && $data =~ m/00{13}/ ) {
      ***             0     33                        
2737           2                                 13            my $handshake = parse_server_handshake_packet($data);
2738  ***      2     50                           8            if ( !$handshake ) {
2739  ***      0                                  0               $self->fail_session($session, 'failed to parse server handshake');
2740  ***      0                                  0               return;
2741                                                           }
2742           2                                 13            $session->{state}     = 'server_handshake';
2743           2                                  8            $session->{thread_id} = $handshake->{thread_id};
2744                                                  
2745  ***      2     50                          16            $session->{ts} = $packet->{ts} unless $session->{ts};
2746                                                        }
2747                                                        elsif ( $session->{buff} ) {
2748  ***      0                                  0            $self->fail_session($session,
2749                                                              'got server response before full buffer');
2750  ***      0                                  0            return;
2751                                                        }
2752                                                        else {
2753  ***      0                                  0            MKDEBUG && _d('Ignoring mid-stream server response');
2754  ***      0                                  0            return;
2755                                                        }
2756                                                     }
2757                                                     else {
2758  ***     33    100     33                  272         if ( $first_byte eq '00' ) { 
                    100                               
      ***            50                               
2759  ***     11    100     50                  101            if ( ($session->{state} || '') eq 'client_auth' ) {
      ***            50                               
2760                                                  
2761           1                                  9               $session->{compress} = $session->{will_compress};
2762           1                                  7               delete $session->{will_compress};
2763           1                                  6               MKDEBUG && $session->{compress} && _d('Packets will be compressed');
2764                                                  
2765           1                                  6               MKDEBUG && _d('Admin command: Connect');
2766           1                                 18               return $self->_make_event(
2767                                                                 {  cmd => 'Admin',
2768                                                                    arg => 'administrator command: Connect',
2769                                                                    ts  => $packet->{ts}, # Events are timestamped when they end
2770                                                                 },
2771                                                                 $packet, $session
2772                                                              );
2773                                                           }
2774                                                           elsif ( $session->{cmd} ) {
2775          10                                 50               my $com = $session->{cmd}->{cmd};
2776          10                                 28               my $ok;
2777  ***     10     50                          45               if ( $com eq COM_STMT_PREPARE ) {
2778          10                                 32                  MKDEBUG && _d('OK for prepared statement');
2779          10                                 61                  $ok = parse_ok_prepared_statement_packet($data);
2780  ***     10     50                          41                  if ( !$ok ) {
2781  ***      0                                  0                     $self->fail_session($session,
2782                                                                       'failed to parse OK prepared statement packet');
2783  ***      0                                  0                     return;
2784                                                                 }
2785          10                                 39                  my $sth_id = $ok->{sth_id};
2786          10                                 53                  $session->{attribs}->{Statement_id} = $sth_id;
2787                                                  
2788          10                                 83                  $session->{sths}->{$sth_id} = $ok;
2789          10                                 80                  $session->{sths}->{$sth_id}->{statement}
2790                                                                    = $session->{cmd}->{arg};
2791                                                              }
2792                                                              else {
2793  ***      0                                  0                  $ok  = parse_ok_packet($data);
2794  ***      0      0                           0                  if ( !$ok ) {
2795  ***      0                                  0                     $self->fail_session($session, 'failed to parse OK packet');
2796  ***      0                                  0                     return;
2797                                                                 }
2798                                                              }
2799                                                  
2800          10                                 35               my $arg;
2801  ***     10     50     33                  198               if ( $com eq COM_QUERY
      ***            50     33                        
2802                                                                   || $com eq COM_STMT_EXECUTE || $com eq COM_STMT_RESET ) {
2803  ***      0                                  0                  $com = 'Query';
2804  ***      0                                  0                  $arg = $session->{cmd}->{arg};
2805                                                              }
2806                                                              elsif ( $com eq COM_STMT_PREPARE ) {
2807          10                                 33                  $com = 'Query';
2808          10                                 50                  $arg = "PREPARE $session->{cmd}->{arg}";
2809                                                              }
2810                                                              else {
2811  ***      0                                  0                  $arg = 'administrator command: '
2812                                                                      . ucfirst(lc(substr($com_for{$com}, 4)));
2813  ***      0                                  0                  $com = 'Admin';
2814                                                              }
2815                                                  
2816          10                                149               return $self->_make_event(
2817                                                                 {  cmd           => $com,
2818                                                                    arg           => $arg,
2819                                                                    ts            => $packet->{ts},
2820                                                                    Insert_id     => $ok->{insert_id},
2821                                                                    Warning_count => $ok->{warnings},
2822                                                                    Rows_affected => $ok->{affected_rows},
2823                                                                 },
2824                                                                 $packet, $session
2825                                                              );
2826                                                           } 
2827                                                           else {
2828  ***      0                                  0               MKDEBUG && _d('Looks like an OK packet but session has no cmd');
2829                                                           }
2830                                                        }
2831                                                        elsif ( $first_byte eq 'ff' ) {
2832           1                                  5            my $error = parse_error_packet($data);
2833  ***      1     50                           5            if ( !$error ) {
2834  ***      0                                  0               $self->fail_session($session, 'failed to parse error packet');
2835  ***      0                                  0               return;
2836                                                           }
2837           1                                  3            my $event;
2838                                                  
2839  ***      1     50                           5            if ( $session->{state} eq 'client_auth' ) {
      ***             0                               
2840           1                                  3               MKDEBUG && _d('Connection failed');
2841           1                                  7               $event = {
2842                                                                 cmd       => 'Admin',
2843                                                                 arg       => 'administrator command: Connect',
2844                                                                 ts        => $packet->{ts},
2845                                                                 Error_no  => $error->{errno},
2846                                                              };
2847           1                                  7               $session->{closed} = 1;  # delete session when done
2848           1                                  5               return $self->_make_event($event, $packet, $session);
2849                                                           }
2850                                                           elsif ( $session->{cmd} ) {
2851  ***      0                                  0               my $com = $session->{cmd}->{cmd};
2852  ***      0                                  0               my $arg;
2853                                                  
2854  ***      0      0      0                    0               if ( $com eq COM_QUERY || $com eq COM_STMT_EXECUTE ) {
2855  ***      0                                  0                  $com = 'Query';
2856  ***      0                                  0                  $arg = $session->{cmd}->{arg};
2857                                                              }
2858                                                              else {
2859  ***      0                                  0                  $arg = 'administrator command: '
2860                                                                      . ucfirst(lc(substr($com_for{$com}, 4)));
2861  ***      0                                  0                  $com = 'Admin';
2862                                                              }
2863                                                  
2864  ***      0      0                           0               $event = {
2865                                                                 cmd       => $com,
2866                                                                 arg       => $arg,
2867                                                                 ts        => $packet->{ts},
2868                                                                 Error_no  => $error->{errno} ? "#$error->{errno}" : 'none',
2869                                                              };
2870  ***      0                                  0               return $self->_make_event($event, $packet, $session);
2871                                                           }
2872                                                           else {
2873  ***      0                                  0               MKDEBUG && _d('Looks like an error packet but client is not '
2874                                                                 . 'authenticating and session has no cmd');
2875                                                           }
2876                                                        }
2877                                                        elsif ( $first_byte eq 'fe' && $packet->{mysql_data_len} < 9 ) {
2878  ***      0      0      0                    0            if ( $packet->{mysql_data_len} == 1
      ***                    0                        
2879                                                                && $session->{state} eq 'client_auth'
2880                                                                && $packet->{number} == 2 )
2881                                                           {
2882  ***      0                                  0               MKDEBUG && _d('Server has old password table;',
2883                                                                 'client will resend password using old algorithm');
2884  ***      0                                  0               $session->{state} = 'client_auth_resend';
2885                                                           }
2886                                                           else {
2887  ***      0                                  0               MKDEBUG && _d('Got an EOF packet');
2888  ***      0                                  0               $self->fail_session($session, 'got an unexpected EOF packet');
2889                                                           }
2890                                                        }
2891                                                        else {
2892  ***     21     50                         109            if ( $session->{cmd} ) {
2893          21                                 59               MKDEBUG && _d('Got a row/field/result packet');
2894          21                                100               my $com = $session->{cmd}->{cmd};
2895          21                                 48               MKDEBUG && _d('Responding to client', $com_for{$com});
2896          21                                111               my $event = { ts  => $packet->{ts} };
2897  ***     21     50     66                  175               if ( $com eq COM_QUERY || $com eq COM_STMT_EXECUTE ) {
2898          21                                 90                  $event->{cmd} = 'Query';
2899          21                                113                  $event->{arg} = $session->{cmd}->{arg};
2900                                                              }
2901                                                              else {
2902  ***      0                                  0                  $event->{arg} = 'administrator command: '
2903                                                                      . ucfirst(lc(substr($com_for{$com}, 4)));
2904  ***      0                                  0                  $event->{cmd} = 'Admin';
2905                                                              }
2906                                                  
2907  ***     21     50                         101               if ( $packet->{complete} ) {
2908          21                                228                  my ( $warning_count, $status_flags )
2909                                                                    = $data =~ m/fe(.{4})(.{4})\Z/;
2910  ***     21     50                         114                  if ( $warning_count ) { 
2911          21                                 83                     $event->{Warnings} = to_num($warning_count);
2912          21                                 82                     my $flags = to_num($status_flags); # TODO set all flags?
2913  ***     21     50                         124                     $event->{No_good_index_used}
2914                                                                       = $flags & SERVER_QUERY_NO_GOOD_INDEX_USED ? 1 : 0;
2915          21    100                         120                     $event->{No_index_used}
2916                                                                       = $flags & SERVER_QUERY_NO_INDEX_USED ? 1 : 0;
2917                                                                 }
2918                                                              }
2919                                                  
2920          21                                128               return $self->_make_event($event, $packet, $session);
2921                                                           }
2922                                                           else {
2923  ***      0                                  0               MKDEBUG && _d('Unknown in-stream server response');
2924                                                           }
2925                                                        }
2926                                                     }
2927                                                  
2928           2                                  8      return;
2929                                                  }
2930                                                  
2931                                                  sub _packet_from_client {
2932          38                   38           220      my ( $self, $packet, $session, $misc ) = @_;
2933  ***     38     50                         171      die "I need a packet"  unless $packet;
2934  ***     38     50                         155      die "I need a session" unless $session;
2935                                                  
2936          38                                 93      MKDEBUG && _d('Packet is from client; state:', $session->{state}); 
2937                                                  
2938  ***     38     50    100                  392      if ( ($session->{client_seq} || '') eq $packet->{seq} ) {
2939  ***      0                                  0         push @{ $session->{client_retransmissions} }, $packet->{seq};
      ***      0                                  0   
2940  ***      0                                  0         MKDEBUG && _d('TCP retransmission');
2941  ***      0                                  0         return;
2942                                                     }
2943          38                                179      $session->{client_seq} = $packet->{seq};
2944                                                  
2945          38                                151      my $data  = $packet->{data};
2946          38                                143      my $ts    = $packet->{ts};
2947                                                  
2948          38    100    100                  950      if ( ($session->{state} || '') eq 'server_handshake' ) {
      ***            50     50                        
      ***            50     50                        
2949           2                                  5         MKDEBUG && _d('Expecting client authentication packet');
2950           2                                 11         my $handshake = parse_client_handshake_packet($data);
2951  ***      2     50                           8         if ( !$handshake ) {
2952  ***      0                                  0            $self->fail_session($session, 'failed to parse client handshake');
2953  ***      0                                  0            return;
2954                                                        }
2955           2                                  8         $session->{state}         = 'client_auth';
2956           2                                  8         $session->{pos_in_log}    = $packet->{pos_in_log};
2957           2                                  9         $session->{user}          = $handshake->{user};
2958           2                                  8         $session->{db}            = $handshake->{db};
2959                                                  
2960           2                                 18         $session->{will_compress} = $handshake->{flags}->{CLIENT_COMPRESS};
2961                                                     }
2962                                                     elsif ( ($session->{state} || '') eq 'client_auth_resend' ) {
2963  ***      0                                  0         MKDEBUG && _d('Client resending password using old algorithm');
2964  ***      0                                  0         $session->{state} = 'client_auth';
2965                                                     }
2966                                                     elsif ( ($session->{state} || '') eq 'awaiting_reply' ) {
2967  ***      0      0                           0         my $arg = $session->{cmd}->{arg} ? substr($session->{cmd}->{arg}, 0, 50)
2968                                                                : 'unknown';
2969  ***      0                                  0         MKDEBUG && _d('More data for previous command:', $arg, '...'); 
2970  ***      0                                  0         return;
2971                                                     }
2972                                                     else {
2973  ***     36     50                         224         if ( $packet->{number} != 0 ) {
2974  ***      0                                  0            $self->fail_session($session, 'client cmd not packet 0');
2975  ***      0                                  0            return;
2976                                                        }
2977                                                  
2978          36    100                         187         if ( !defined $session->{compress} ) {
2979  ***     10     50                          86            return unless $self->detect_compression($packet, $session);
2980          10                                 46            $data = $packet->{data};
2981                                                        }
2982                                                  
2983          36                                198         my $com = parse_com_packet($data, $packet->{mysql_data_len});
2984  ***     36     50                         170         if ( !$com ) {
2985  ***      0                                  0            $self->fail_session($session, 'failed to parse COM packet');
2986  ***      0                                  0            return;
2987                                                        }
2988                                                  
2989          36    100                         235         if ( $com->{code} eq COM_STMT_EXECUTE ) {
      ***            50                               
2990          12                                 33            MKDEBUG && _d('Execute prepared statement');
2991          12                                 97            my $exec = parse_execute_packet($com->{data}, $session->{sths});
2992  ***     12     50                          56            if ( !$exec ) {
2993  ***      0                                  0               MKDEBUG && _d('Failed to parse execute packet');
2994  ***      0                                  0               $session->{state} = undef;
2995  ***      0                                  0               return;
2996                                                           }
2997          12                                 58            $com->{data} = $exec->{arg};
2998          12                                 83            $session->{attribs}->{Statement_id} = $exec->{sth_id};
2999                                                        }
3000                                                        elsif ( $com->{code} eq COM_STMT_RESET ) {
3001  ***      0                                  0            my $sth_id = get_sth_id($com->{data});
3002  ***      0      0                           0            if ( !$sth_id ) {
3003  ***      0                                  0               $self->fail_session($session,
3004                                                                 'failed to parse prepared statement reset packet');
3005  ***      0                                  0               return;
3006                                                           }
3007  ***      0                                  0            $com->{data} = "RESET $sth_id";
3008  ***      0                                  0            $session->{attribs}->{Statement_id} = $sth_id;
3009                                                        }
3010                                                  
3011          36                                146         $session->{state}      = 'awaiting_reply';
3012          36                                147         $session->{pos_in_log} = $packet->{pos_in_log};
3013          36                                126         $session->{ts}         = $ts;
3014          36                                249         $session->{cmd}        = {
3015                                                           cmd => $com->{code},
3016                                                           arg => $com->{data},
3017                                                        };
3018                                                  
3019          36    100                         328         if ( $com->{code} eq COM_QUIT ) { # Fire right away; will cleanup later.
                    100                               
3020           2                                  4            MKDEBUG && _d('Got a COM_QUIT');
3021                                                  
3022           2                                  9            $session->{closed} = 1;  # delete session when done
3023                                                  
3024           2                                 17            return $self->_make_event(
3025                                                              {  cmd       => 'Admin',
3026                                                                 arg       => 'administrator command: Quit',
3027                                                                 ts        => $ts,
3028                                                              },
3029                                                              $packet, $session
3030                                                           );
3031                                                        }
3032                                                        elsif ( $com->{code} eq COM_STMT_CLOSE ) {
3033           3                                 20            my $sth_id = get_sth_id($com->{data});
3034  ***      3     50                          12            if ( !$sth_id ) {
3035  ***      0                                  0               $self->fail_session($session,
3036                                                                 'failed to parse prepared statement close packet');
3037  ***      0                                  0               return;
3038                                                           }
3039           3                                 24            delete $session->{sths}->{$sth_id};
3040           3                                 23            return $self->_make_event(
3041                                                              {  cmd       => 'Query',
3042                                                                 arg       => "DEALLOCATE PREPARE $sth_id",
3043                                                                 ts        => $ts,
3044                                                              },
3045                                                              $packet, $session
3046                                                           );
3047                                                        }
3048                                                     }
3049                                                  
3050          33                                137      return;
3051                                                  }
3052                                                  
3053                                                  sub _make_event {
3054          38                   38           201      my ( $self, $event, $packet, $session ) = @_;
3055          38                                120      MKDEBUG && _d('Making event');
3056                                                  
3057          38                                154      $session->{raw_packets}  = [];
3058          38                                259      $self->_delete_buff($session);
3059                                                  
3060          38    100                         194      if ( !$session->{thread_id} ) {
3061          10                                 26         MKDEBUG && _d('Giving session fake thread id', $self->{fake_thread_id});
3062          10                                 60         $session->{thread_id} = $self->{fake_thread_id}++;
3063                                                     }
3064                                                  
3065          38                                404      my ($host, $port) = $session->{client} =~ m/((?:\d+\.){3}\d+)\:(\w+)/;
3066  ***     38     50    100                  353      my $new_event = {
      ***           100     50                        
      ***                   50                        
3067                                                        cmd        => $event->{cmd},
3068                                                        arg        => $event->{arg},
3069                                                        bytes      => length( $event->{arg} ),
3070                                                        ts         => tcp_timestamp( $event->{ts} ),
3071                                                        host       => $host,
3072                                                        ip         => $host,
3073                                                        port       => $port,
3074                                                        db         => $session->{db},
3075                                                        user       => $session->{user},
3076                                                        Thread_id  => $session->{thread_id},
3077                                                        pos_in_log => $session->{pos_in_log},
3078                                                        Query_time => timestamp_diff($session->{ts}, $packet->{ts}),
3079                                                        Error_no   => $event->{Error_no} || 'none',
3080                                                        Rows_affected      => ($event->{Rows_affected} || 0),
3081                                                        Warning_count      => ($event->{Warning_count} || 0),
3082                                                        No_good_index_used => ($event->{No_good_index_used} ? 'Yes' : 'No'),
3083                                                        No_index_used      => ($event->{No_index_used}      ? 'Yes' : 'No'),
3084                                                     };
3085          38                                138      @{$new_event}{keys %{$session->{attribs}}} = values %{$session->{attribs}};
              38                                155   
              38                                159   
              38                                256   
3086          38                                 99      MKDEBUG && _d('Properties of event:', Dumper($new_event));
3087                                                  
3088          38                                169      delete $session->{cmd};
3089                                                  
3090          38                                136      $session->{state} = undef;
3091                                                  
3092          38                                137      $session->{attribs} = {};
3093                                                  
3094          38                                157      $session->{n_queries}++;
3095          38                                167      $session->{server_retransmissions} = [];
3096          38                                153      $session->{client_retransmissions} = [];
3097                                                  
3098          38                                228      return $new_event;
3099                                                  }
3100                                                  
3101                                                  sub tcp_timestamp {
3102          38                   38           180      my ( $ts ) = @_;
3103          38                                568      $ts =~ s/^\d\d(\d\d)-(\d\d)-(\d\d)/$1$2$3/;
3104          38                                451      return $ts;
3105                                                  }
3106                                                  
3107                                                  sub timestamp_diff {
3108          38                   38           193      my ( $start, $end ) = @_;
3109          38                                175      my $sd = substr($start, 0, 11, '');
3110          38                                141      my $ed = substr($end,   0, 11, '');
3111          38                                271      my ( $sh, $sm, $ss ) = split(/:/, $start);
3112          38                                192      my ( $eh, $em, $es ) = split(/:/, $end);
3113          38                                251      my $esecs = ($eh * 3600 + $em * 60 + $es);
3114          38                                171      my $ssecs = ($sh * 3600 + $sm * 60 + $ss);
3115  ***     38     50                         173      if ( $sd eq $ed ) {
3116          38                               1940         return sprintf '%.6f', $esecs - $ssecs;
3117                                                     }
3118                                                     else { # Assume only one day boundary has been crossed, no DST, etc
3119  ***      0                                  0         return sprintf '%.6f', ( 86_400 - $ssecs ) + $esecs;
3120                                                     }
3121                                                  }
3122                                                  
3123                                                  sub to_string {
3124          39                   39           201      my ( $data ) = @_;
3125          39                                310      return pack('H*', $data);
3126                                                  }
3127                                                  
3128                                                  sub unpack_string {
3129           5                    5            23      my ( $data ) = @_;
3130           5                                 16      my $len        = 0;
3131           5                                 13      my $encode_len = 0;
3132           5                                 28      ($data, $len, $encode_len) = decode_len($data);
3133  ***      5     50                          28      my $t = 'H' . ($len ? $len * 2 : '*');
3134           5                                 29      $data = pack($t, $data);
3135           5                                 31      return "\"$data\"", $encode_len + $len;
3136                                                  }
3137                                                  
3138                                                  sub decode_len {
3139           5                    5            20      my ( $data ) = @_;
3140  ***      5     50                          19      return unless $data;
3141                                                  
3142           5                                 28      my $first_byte = to_num(substr($data, 0, 2, ''));
3143                                                  
3144           5                                 18      my $len;
3145           5                                 13      my $encode_len;
3146  ***      5     50                          21      if ( $first_byte <= 251 ) {
      ***             0                               
      ***             0                               
      ***             0                               
3147           5                                 13         $len        = $first_byte;
3148           5                                 14         $encode_len = 1;
3149                                                     }
3150                                                     elsif ( $first_byte == 252 ) {
3151  ***      0                                  0         $len        = to_num(substr($data, 4, ''));
3152  ***      0                                  0         $encode_len = 2;
3153                                                     }
3154                                                     elsif ( $first_byte == 253 ) {
3155  ***      0                                  0         $len        = to_num(substr($data, 6, ''));
3156  ***      0                                  0         $encode_len = 3;
3157                                                     }
3158                                                     elsif ( $first_byte == 254 ) {
3159  ***      0                                  0         $len        = to_num(substr($data, 16, ''));
3160  ***      0                                  0         $encode_len = 8;
3161                                                     }
3162                                                     else {
3163  ***      0                                  0         MKDEBUG && _d('data:', $data, 'first byte:', $first_byte);
3164  ***      0                                  0         die "Invalid length encoded byte: $first_byte";
3165                                                     }
3166                                                  
3167           5                                 14      MKDEBUG && _d('len:', $len, 'encode len', $encode_len);
3168           5                                 26      return $data, $len, $encode_len;
3169                                                  }
3170                                                  
3171                                                  sub to_num {
3172         351                  351          1483      my ( $str, $len ) = @_;
3173  ***    351     50                        1305      if ( $len ) {
3174  ***      0                                  0         $str = substr($str, 0, $len * 2);
3175                                                     }
3176         351                               1987      my @bytes = $str =~ m/(..)/g;
3177         351                               1107      my $result = 0;
3178         351                               1773      foreach my $i ( 0 .. $#bytes ) {
3179         642                               3324         $result += hex($bytes[$i]) * (16 ** ($i * 2));
3180                                                     }
3181         351                               1480      return $result;
3182                                                  }
3183                                                  
3184                                                  sub to_double {
3185  ***      0                    0             0      my ( $str ) = @_;
3186  ***      0                                  0      return unpack('d', pack('H*', $str));
3187                                                  }
3188                                                  
3189                                                  sub get_lcb {
3190  ***      0                    0             0      my ( $string ) = @_;
3191  ***      0                                  0      my $first_byte = hex(substr($$string, 0, 2, ''));
3192  ***      0      0                           0      if ( $first_byte < 251 ) {
      ***             0                               
      ***             0                               
      ***             0                               
3193  ***      0                                  0         return $first_byte;
3194                                                     }
3195                                                     elsif ( $first_byte == 252 ) {
3196  ***      0                                  0         return to_num(substr($$string, 0, 4, ''));
3197                                                     }
3198                                                     elsif ( $first_byte == 253 ) {
3199  ***      0                                  0         return to_num(substr($$string, 0, 6, ''));
3200                                                     }
3201                                                     elsif ( $first_byte == 254 ) {
3202  ***      0                                  0         return to_num(substr($$string, 0, 16, ''));
3203                                                     }
3204                                                  }
3205                                                  
3206                                                  sub parse_error_packet {
3207           1                    1             4      my ( $data ) = @_;
3208  ***      1     50                           5      return unless $data;
3209           1                                  3      MKDEBUG && _d('ERROR data:', $data);
3210  ***      1     50                           5      if ( length $data < 16 ) {
3211  ***      0                                  0         MKDEBUG && _d('Error packet is too short:', $data);
3212  ***      0                                  0         return;
3213                                                     }
3214           1                                  5      my $errno    = to_num(substr($data, 0, 4));
3215           1                                  5      my $marker   = to_string(substr($data, 4, 2));
3216  ***      1     50                           5      return unless $marker eq '#';
3217           1                                  4      my $sqlstate = to_string(substr($data, 6, 10));
3218           1                                  9      my $message  = to_string(substr($data, 16));
3219           1                                  8      my $pkt = {
3220                                                        errno    => $errno,
3221                                                        sqlstate => $marker . $sqlstate,
3222                                                        message  => $message,
3223                                                     };
3224           1                                  3      MKDEBUG && _d('Error packet:', Dumper($pkt));
3225           1                                  3      return $pkt;
3226                                                  }
3227                                                  
3228                                                  sub parse_ok_packet {
3229  ***      0                    0             0      my ( $data ) = @_;
3230  ***      0      0                           0      return unless $data;
3231  ***      0                                  0      MKDEBUG && _d('OK data:', $data);
3232  ***      0      0                           0      if ( length $data < 12 ) {
3233  ***      0                                  0         MKDEBUG && _d('OK packet is too short:', $data);
3234  ***      0                                  0         return;
3235                                                     }
3236  ***      0                                  0      my $affected_rows = get_lcb(\$data);
3237  ***      0                                  0      my $insert_id     = get_lcb(\$data);
3238  ***      0                                  0      my $status        = to_num(substr($data, 0, 4, ''));
3239  ***      0                                  0      my $warnings      = to_num(substr($data, 0, 4, ''));
3240  ***      0                                  0      my $message       = to_string($data);
3241  ***      0                                  0      my $pkt = {
3242                                                        affected_rows => $affected_rows,
3243                                                        insert_id     => $insert_id,
3244                                                        status        => $status,
3245                                                        warnings      => $warnings,
3246                                                        message       => $message,
3247                                                     };
3248  ***      0                                  0      MKDEBUG && _d('OK packet:', Dumper($pkt));
3249  ***      0                                  0      return $pkt;
3250                                                  }
3251                                                  
3252                                                  sub parse_ok_prepared_statement_packet {
3253          10                   10            50      my ( $data ) = @_;
3254  ***     10     50                          46      return unless $data;
3255          10                                 26      MKDEBUG && _d('OK prepared statement data:', $data);
3256  ***     10     50                          54      if ( length $data < 8 ) {
3257  ***      0                                  0         MKDEBUG && _d('OK prepared statement packet is too short:', $data);
3258  ***      0                                  0         return;
3259                                                     }
3260          10                                 51      my $sth_id     = to_num(substr($data, 0, 8, ''));
3261          10                                 52      my $num_cols   = to_num(substr($data, 0, 4, ''));
3262          10                                 48      my $num_params = to_num(substr($data, 0, 4, ''));
3263          10                                 61      my $pkt = {
3264                                                        sth_id     => $sth_id,
3265                                                        num_cols   => $num_cols,
3266                                                        num_params => $num_params,
3267                                                     };
3268          10                                 30      MKDEBUG && _d('OK prepared packet:', Dumper($pkt));
3269          10                                 39      return $pkt;
3270                                                  }
3271                                                  
3272                                                  sub parse_server_handshake_packet {
3273           2                    2             8      my ( $data ) = @_;
3274  ***      2     50                          10      return unless $data;
3275           2                                  5      MKDEBUG && _d('Server handshake data:', $data);
3276           2                                 17      my $handshake_pattern = qr{
3277                                                        ^                 # -----                ----
3278                                                        (.+?)00           # n Null-Term String   server_version
3279                                                        (.{8})            # 4                    thread_id
3280                                                        .{16}             # 8                    scramble_buff
3281                                                        .{2}              # 1                    filler: always 0x00
3282                                                        (.{4})            # 2                    server_capabilities
3283                                                        .{2}              # 1                    server_language
3284                                                        .{4}              # 2                    server_status
3285                                                        .{26}             # 13                   filler: always 0x00
3286                                                     }x;
3287           2                                 29      my ( $server_version, $thread_id, $flags ) = $data =~ m/$handshake_pattern/;
3288           2                                 14      my $pkt = {
3289                                                        server_version => to_string($server_version),
3290                                                        thread_id      => to_num($thread_id),
3291                                                        flags          => parse_flags($flags),
3292                                                     };
3293           2                                  5      MKDEBUG && _d('Server handshake packet:', Dumper($pkt));
3294           2                                 11      return $pkt;
3295                                                  }
3296                                                  
3297                                                  sub parse_client_handshake_packet {
3298           2                    2             9      my ( $data ) = @_;
3299  ***      2     50                           9      return unless $data;
3300           2                                  5      MKDEBUG && _d('Client handshake data:', $data);
3301           2                                 27      my ( $flags, $user, $buff_len ) = $data =~ m{
3302                                                        ^
3303                                                        (.{8})         # Client flags
3304                                                        .{10}          # Max packet size, charset
3305                                                        (?:00){23}     # Filler
3306                                                        ((?:..)+?)00   # Null-terminated user name
3307                                                        (..)           # Length-coding byte for scramble buff
3308                                                     }x;
3309                                                  
3310  ***      2     50                          10      if ( !$buff_len ) {
3311  ***      0                                  0         MKDEBUG && _d('Did not match client handshake packet');
3312  ***      0                                  0         return;
3313                                                     }
3314                                                  
3315           2                                  7      my $code_len = hex($buff_len);
3316           2                                 44      my ( $db ) = $data =~ m!
3317                                                        ^.{64}${user}00..   # Everything matched before
3318                                                        (?:..){$code_len}   # The scramble buffer
3319                                                        (.*)00\Z            # The database name
3320                                                     !x;
3321           2    100                           9      my $pkt = {
3322                                                        user  => to_string($user),
3323                                                        db    => $db ? to_string($db) : '',
3324                                                        flags => parse_flags($flags),
3325                                                     };
3326           2                                  6      MKDEBUG && _d('Client handshake packet:', Dumper($pkt));
3327           2                                 11      return $pkt;
3328                                                  }
3329                                                  
3330                                                  sub parse_com_packet {
3331          46                   46           271      my ( $data, $len ) = @_;
3332  ***     46     50     33                  404      return unless $data && $len;
3333          46                                120      MKDEBUG && _d('COM data:',
3334                                                        (substr($data, 0, 100).(length $data > 100 ? '...' : '')),
3335                                                        'len:', $len);
3336          46                                185      my $code = substr($data, 0, 2);
3337          46                                185      my $com  = $com_for{$code};
3338  ***     46     50                         194      if ( !$com ) {
3339  ***      0                                  0         MKDEBUG && _d('Did not match COM packet');
3340  ***      0                                  0         return;
3341                                                     }
3342          46    100    100                  624      if (    $code ne COM_STMT_EXECUTE
      ***                   66                        
3343                                                          && $code ne COM_STMT_CLOSE
3344                                                          && $code ne COM_STMT_RESET )
3345                                                     {
3346          31                                231         $data = to_string(substr($data, 2, ($len - 1) * 2));
3347                                                     }
3348          46                                322      my $pkt = {
3349                                                        code => $code,
3350                                                        com  => $com,
3351                                                        data => $data,
3352                                                     };
3353          46                                110      MKDEBUG && _d('COM packet:', Dumper($pkt));
3354          46                                193      return $pkt;
3355                                                  }
3356                                                  
3357                                                  sub parse_execute_packet {
3358          12                   12            70      my ( $data, $sths ) = @_;
3359  ***     12     50     33                  109      return unless $data && $sths;
3360                                                  
3361          12                                 80      my $sth_id = to_num(substr($data, 2, 8));
3362  ***     12     50                          53      return unless defined $sth_id;
3363                                                  
3364          12                                 56      my $sth = $sths->{$sth_id};
3365  ***     12     50                          49      if ( !$sth ) {
3366  ***      0                                  0         MKDEBUG && _d('Skipping unknown statement handle', $sth_id);
3367  ***      0                                  0         return;
3368                                                     }
3369          12           100                  121      my $null_count  = int(($sth->{num_params} + 7) / 8) || 1;
3370          12                                 63      my $null_bitmap = to_num(substr($data, 20, $null_count * 2));
3371          12                                 30      MKDEBUG && _d('NULL bitmap:', $null_bitmap, 'count:', $null_count);
3372                                                     
3373          12                                 98      substr($data, 0, 20 + ($null_count * 2), '');
3374                                                  
3375          12                                 55      my $new_params = to_num(substr($data, 0, 2, ''));
3376          12                                 36      my @types; 
3377          12    100                          44      if ( $new_params ) {
3378           4                                 11         MKDEBUG && _d('New param types');
3379           4                                 22         for my $i ( 0..($sth->{num_params}-1) ) {
3380           9                                 42            my $type = to_num(substr($data, 0, 4, ''));
3381           9                                 48            push @types, $type_for{$type};
3382           9                                 27            MKDEBUG && _d('Param', $i, 'type:', $type, $type_for{$type});
3383                                                        }
3384           4                                 21         $sth->{types} = \@types;
3385                                                     }
3386                                                     else {
3387  ***      8     50                          35         @types = @{$sth->{types}} if $data;
      ***      0                                  0   
3388                                                     }
3389                                                  
3390                                                  
3391          12                                 63      my $arg  = $sth->{statement};
3392          12                                 29      MKDEBUG && _d('Statement:', $arg);
3393          12                                 63      for my $i ( 0..($sth->{num_params}-1) ) {
3394           9                                 23         my $val;
3395           9                                 20         my $len;  # in bytes
3396           9    100                          43         if ( $null_bitmap & (2**$i) ) {
3397           4                                 11            MKDEBUG && _d('Param', $i, 'is NULL (bitmap)');
3398           4                                 15            $val = 'NULL';
3399           4                                 14            $len = 0;
3400                                                        }
3401                                                        else {
3402  ***      5     50                          25            if ( $unpack_type{$types[$i]} ) {
3403           5                                 29               ($val, $len) = $unpack_type{$types[$i]}->($data);
3404                                                           }
3405                                                           else {
3406  ***      0                                  0               MKDEBUG && _d('No handler for param', $i, 'type', $types[$i]);
3407  ***      0                                  0               $val = '?';
3408  ***      0                                  0               $len = 0;
3409                                                           }
3410                                                        }
3411                                                  
3412           9                                 23         MKDEBUG && _d('Param', $i, 'val:', $val);
3413           9                                 60         $arg =~ s/\?/$val/;
3414                                                  
3415           9    100                          52         substr($data, 0, $len * 2, '') if $len;
3416                                                     }
3417                                                  
3418          12                                 83      my $pkt = {
3419                                                        sth_id => $sth_id,
3420                                                        arg    => "EXECUTE $arg",
3421                                                     };
3422          12                                 49      MKDEBUG && _d('Execute packet:', Dumper($pkt));
3423          12                                 61      return $pkt;
3424                                                  }
3425                                                  
3426                                                  sub get_sth_id {
3427           3                    3            15      my ( $data ) = @_;
3428  ***      3     50                          13      return unless $data;
3429           3                                 13      my $sth_id = to_num(substr($data, 2, 8));
3430           3                                 10      return $sth_id;
3431                                                  }
3432                                                  
3433                                                  sub parse_flags {
3434           4                    4            14      my ( $flags ) = @_;
3435  ***      4     50                          16      die "I need flags" unless $flags;
3436           4                                  9      MKDEBUG && _d('Flag data:', $flags);
3437           4                                 50      my %flags     = %flag_for;
3438           4                                 27      my $flags_dec = to_num($flags);
3439           4                                 22      foreach my $flag ( keys %flag_for ) {
3440          72                                200         my $flagno    = $flag_for{$flag};
3441          72    100                         289         $flags{$flag} = ($flags_dec & $flagno ? 1 : 0);
3442                                                     }
3443           4                                 31      return \%flags;
3444                                                  }
3445                                                  
3446                                                  sub uncompress_data {
3447  ***      0                    0             0      my ( $data, $len ) = @_;
3448  ***      0      0                           0      die "I need data" unless $data;
3449  ***      0      0                           0      die "I need a len argument" unless $len;
3450  ***      0      0                           0      die "I need a scalar reference to data" unless ref $data eq 'SCALAR';
3451  ***      0                                  0      MKDEBUG && _d('Uncompressing data');
3452  ***      0                                  0      our $InflateError;
3453                                                  
3454  ***      0                                  0      my $comp_bin_data = pack('H*', $$data);
3455                                                  
3456  ***      0                                  0      my $uncomp_bin_data = '';
3457  ***      0      0                           0      my $z = new IO::Uncompress::Inflate(
3458                                                        \$comp_bin_data
3459                                                     ) or die "IO::Uncompress::Inflate failed: $InflateError";
3460  ***      0      0                           0      my $status = $z->read(\$uncomp_bin_data, $len)
3461                                                        or die "IO::Uncompress::Inflate failed: $InflateError";
3462                                                  
3463  ***      0                                  0      my $uncomp_data = unpack('H*', $uncomp_bin_data);
3464                                                  
3465  ***      0                                  0      return \$uncomp_data;
3466                                                  }
3467                                                  
3468                                                  sub detect_compression {
3469          10                   10            51      my ( $self, $packet, $session ) = @_;
3470          10                                 31      MKDEBUG && _d('Checking for client compression');
3471          10                                 95      my $com = parse_com_packet($packet->{data}, $packet->{mysql_data_len});
3472  ***     10     50     33                  128      if ( $com && $com->{code} eq COM_SLEEP ) {
3473  ***      0                                  0         MKDEBUG && _d('Client is using compression');
3474  ***      0                                  0         $session->{compress} = 1;
3475                                                  
3476  ***      0                                  0         $packet->{data} = $packet->{mysql_hdr} . $packet->{data};
3477  ***      0      0                           0         return 0 unless $self->uncompress_packet($packet, $session);
3478  ***      0                                  0         remove_mysql_header($packet);
3479                                                     }
3480                                                     else {
3481          10                                 24         MKDEBUG && _d('Client is NOT using compression');
3482          10                                 40         $session->{compress} = 0;
3483                                                     }
3484          10                                 64      return 1;
3485                                                  }
3486                                                  
3487                                                  sub uncompress_packet {
3488  ***      0                    0             0      my ( $self, $packet, $session ) = @_;
3489  ***      0      0                           0      die "I need a packet"  unless $packet;
3490  ***      0      0                           0      die "I need a session" unless $session;
3491                                                  
3492                                                  
3493  ***      0                                  0      my $data;
3494  ***      0                                  0      my $comp_hdr;
3495  ***      0                                  0      my $comp_data_len;
3496  ***      0                                  0      my $pkt_num;
3497  ***      0                                  0      my $uncomp_data_len;
3498  ***      0                                  0      eval {
3499  ***      0                                  0         $data            = \$packet->{data};
3500  ***      0                                  0         $comp_hdr        = substr($$data, 0, 14, '');
3501  ***      0                                  0         $comp_data_len   = to_num(substr($comp_hdr, 0, 6));
3502  ***      0                                  0         $pkt_num         = to_num(substr($comp_hdr, 6, 2));
3503  ***      0                                  0         $uncomp_data_len = to_num(substr($comp_hdr, 8, 6));
3504  ***      0                                  0         MKDEBUG && _d('Compression header data:', $comp_hdr,
3505                                                           'compressed data len (bytes)', $comp_data_len,
3506                                                           'number', $pkt_num,
3507                                                           'uncompressed data len (bytes)', $uncomp_data_len);
3508                                                     };
3509  ***      0      0                           0      if ( $EVAL_ERROR ) {
3510  ***      0                                  0         $session->{EVAL_ERROR} = $EVAL_ERROR;
3511  ***      0                                  0         $self->fail_session($session, 'failed to parse compression header');
3512  ***      0                                  0         return 0;
3513                                                     }
3514                                                  
3515  ***      0      0                           0      if ( $uncomp_data_len ) {
3516  ***      0                                  0         eval {
3517  ***      0                                  0            $data = uncompress_data($data, $uncomp_data_len);
3518  ***      0                                  0            $packet->{data} = $$data;
3519                                                        };
3520  ***      0      0                           0         if ( $EVAL_ERROR ) {
3521  ***      0                                  0            $session->{EVAL_ERROR} = $EVAL_ERROR;
3522  ***      0                                  0            $self->fail_session($session, 'failed to uncompress data');
3523  ***      0                                  0            die "Cannot uncompress packet.  Check that IO::Uncompress::Inflate "
3524                                                              . "is installed.\nError: $EVAL_ERROR";
3525                                                        }
3526                                                     }
3527                                                     else {
3528  ***      0                                  0         MKDEBUG && _d('Packet is not really compressed');
3529  ***      0                                  0         $packet->{data} = $$data;
3530                                                     }
3531                                                  
3532  ***      0                                  0      return 1;
3533                                                  }
3534                                                  
3535                                                  sub remove_mysql_header {
3536          73                   73           274      my ( $packet ) = @_;
3537  ***     73     50                         284      die "I need a packet" unless $packet;
3538                                                  
3539          73                                396      my $mysql_hdr      = substr($packet->{data}, 0, 8, '');
3540          73                                311      my $mysql_data_len = to_num(substr($mysql_hdr, 0, 6));
3541          73                                341      my $pkt_num        = to_num(substr($mysql_hdr, 6, 2));
3542          73                                191      MKDEBUG && _d('MySQL packet: header data', $mysql_hdr,
3543                                                        'data len (bytes)', $mysql_data_len, 'number', $pkt_num);
3544                                                  
3545          73                                317      $packet->{mysql_hdr}      = $mysql_hdr;
3546          73                                293      $packet->{mysql_data_len} = $mysql_data_len;
3547          73                                251      $packet->{number}         = $pkt_num;
3548                                                  
3549          73                                269      return;
3550                                                  }
3551                                                  
3552                                                  sub _get_errors_fh {
3553  ***      0                    0             0      my ( $self ) = @_;
3554  ***      0                                  0      my $errors_fh = $self->{errors_fh};
3555  ***      0      0                           0      return $errors_fh if $errors_fh;
3556                                                  
3557  ***      0                                  0      my $o = $self->{o};
3558  ***      0      0      0                    0      if ( $o && $o->has('tcpdump-errors') && $o->got('tcpdump-errors') ) {
      ***                    0                        
3559  ***      0                                  0         my $errors_file = $o->get('tcpdump-errors');
3560  ***      0                                  0         MKDEBUG && _d('tcpdump-errors file:', $errors_file);
3561  ***      0      0                           0         open $errors_fh, '>>', $errors_file
3562                                                           or die "Cannot open tcpdump-errors file $errors_file: $OS_ERROR";
3563                                                     }
3564                                                  
3565  ***      0                                  0      $self->{errors_fh} = $errors_fh;
3566  ***      0                                  0      return $errors_fh;
3567                                                  }
3568                                                  
3569                                                  sub fail_session {
3570  ***      0                    0             0      my ( $self, $session, $reason ) = @_;
3571  ***      0                                  0      MKDEBUG && _d('Client', $session->{client}, 'failed because', $reason);
3572  ***      0                                  0      my $errors_fh = $self->_get_errors_fh();
3573  ***      0      0                           0      if ( $errors_fh ) {
3574  ***      0                                  0         my $raw_packets = $session->{raw_packets};
3575  ***      0                                  0         delete $session->{raw_packets};  # Don't dump, it's printed below.
3576  ***      0                                  0         $session->{reason_for_failure} = $reason;
3577  ***      0                                  0         my $session_dump = '# ' . Dumper($session);
3578  ***      0                                  0         chomp $session_dump;
3579  ***      0                                  0         $session_dump =~ s/\n/\n# /g;
3580  ***      0                                  0         print $errors_fh "$session_dump\n";
3581                                                        {
3582  ***      0                                  0            local $LIST_SEPARATOR = "\n";
      ***      0                                  0   
3583  ***      0                                  0            print $errors_fh "@$raw_packets";
3584  ***      0                                  0            print $errors_fh "\n";
3585                                                        }
3586                                                     }
3587  ***      0                                  0      delete $self->{sessions}->{$session->{client}};
3588  ***      0                                  0      return;
3589                                                  }
3590                                                  
3591                                                  sub _delete_buff {
3592          38                   38           162      my ( $self, $session ) = @_;
3593          38                                157      map { delete $session->{$_} } qw(buff buff_left mysql_data_len);
             114                                417   
3594          38                                120      return;
3595                                                  }
3596                                                  
3597                                                  sub _d {
3598  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3599  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3600  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3601                                                          @_;
3602  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3603                                                  }
3604                                                  
3605                                                  1;
3606                                                  
3607                                                  # ###########################################################################
3608                                                  # End MySQLProtocolParser package
3609                                                  # ###########################################################################
3610                                                  
3611                                                  # ###########################################################################
3612                                                  # SlowLogParser package 5357
3613                                                  # ###########################################################################
3614                                                  package SlowLogParser;
3615                                                  
3616           7                    7            79   use strict;
               7                                 18   
               7                                 59   
3617           7                    7            49   use warnings FATAL => 'all';
               7                                 18   
               7                                 56   
3618           7                    7            43   use English qw(-no_match_vars);
               7                                 18   
               7                                 43   
3619           7                    7            53   use Data::Dumper;
               7                                 17   
               7                                 44   
3620                                                  
3621  ***      7            50      7            44   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 17   
               7                                104   
3622                                                  
3623                                                  sub new {
3624          39                   39           286      my ( $class ) = @_;
3625          39                                239      my $self = {
3626                                                        pending => [],
3627                                                     };
3628          39                                276      return bless $self, $class;
3629                                                  }
3630                                                  
3631                                                  my $slow_log_ts_line = qr/^# Time: ([0-9: ]{15})/;
3632                                                  my $slow_log_uh_line = qr/# User\@Host: ([^\[]+|\[[^[]+\]).*?@ (\S*) \[(.*)\]/;
3633                                                  my $slow_log_hd_line = qr{
3634                                                        ^(?:
3635                                                        T[cC][pP]\s[pP]ort:\s+\d+ # case differs on windows/unix
3636                                                        |
3637                                                        [/A-Z].*mysqld,\sVersion.*(?:started\swith:|embedded\slibrary)
3638                                                        |
3639                                                        Time\s+Id\s+Command
3640                                                        ).*\n
3641                                                     }xm;
3642                                                  
3643                                                  sub parse_event {
3644         349                  349          2146      my ( $self, %args ) = @_;
3645         349                               1864      my @required_args = qw(next_event tell);
3646         349                               1265      foreach my $arg ( @required_args ) {
3647  ***    698     50                        3376         die "I need a $arg argument" unless $args{$arg};
3648                                                     }
3649         349                               1624      my ($next_event, $tell) = @args{@required_args};
3650                                                  
3651         349                               1413      my $pending = $self->{pending};
3652         349                               2048      local $INPUT_RECORD_SEPARATOR = ";\n#";
3653         349                               1296      my $trimlen    = length($INPUT_RECORD_SEPARATOR);
3654         349                               1319      my $pos_in_log = $tell->();
3655         349                                965      my $stmt;
3656                                                  
3657                                                     EVENT:
3658         349           100                 2771      while (
3659                                                           defined($stmt = shift @$pending)
3660                                                        or defined($stmt = $next_event->())
3661                                                     ) {
3662         310                               1693         my @properties = ('cmd', 'Query', 'pos_in_log', $pos_in_log);
3663         310                               1116         $pos_in_log = $tell->();
3664                                                  
3665         310    100                       12280         if ( $stmt =~ s/$slow_log_hd_line//go ){ # Throw away header lines in log
3666           6                                 66            my @chunks = split(/$INPUT_RECORD_SEPARATOR/o, $stmt);
3667           6    100                          46            if ( @chunks > 1 ) {
3668           1                                  7               MKDEBUG && _d("Found multiple chunks");
3669           1                                  8               $stmt = shift @chunks;
3670           1                                 13               unshift @$pending, @chunks;
3671                                                           }
3672                                                        }
3673                                                  
3674         310    100                        2620         $stmt = '#' . $stmt unless $stmt =~ m/\A#/;
3675         310                               2235         $stmt =~ s/;\n#?\Z//;
3676                                                  
3677                                                  
3678         310                               1099         my ($got_ts, $got_uh, $got_ac, $got_db, $got_set, $got_embed);
3679         310                                913         my $pos = 0;
3680         310                                883         my $len = length($stmt);
3681         310                                887         my $found_arg = 0;
3682                                                        LINE:
3683         310                               2166         while ( $stmt =~ m/^(.*)$/mg ) { # /g is important, requires scalar match.
3684        1737                               5109            $pos     = pos($stmt);  # Be careful not to mess this up!
3685        1737                               6906            my $line = $1;          # Necessary for /g and pos() to work.
3686        1737                               3835            MKDEBUG && _d($line);
3687                                                  
3688        1737    100                        7987            if ($line =~ m/^(?:#|use |SET (?:last_insert_id|insert_id|timestamp))/o) {
3689                                                  
3690        1440    100    100                32429               if ( !$got_ts && (my ( $time ) = $line =~ m/$slow_log_ts_line/o)) {
                    100    100                        
      ***           100     66                        
                    100    100                        
      ***           100     66                        
                    100                               
3691          53                                143                  MKDEBUG && _d("Got ts", $time);
3692          53                                227                  push @properties, 'ts', $time;
3693          53                                210                  ++$got_ts;
3694  ***     53    100     66                  932                  if ( !$got_uh
3695                                                                    && ( my ( $user, $host, $ip ) = $line =~ m/$slow_log_uh_line/o )
3696                                                                 ) {
3697          16                                 52                     MKDEBUG && _d("Got user, host, ip", $user, $host, $ip);
3698          16                                101                     push @properties, 'user', $user, 'host', $host, 'ip', $ip;
3699          16                                 74                     ++$got_uh;
3700                                                                 }
3701                                                              }
3702                                                  
3703                                                              elsif ( !$got_uh
3704                                                                    && ( my ( $user, $host, $ip ) = $line =~ m/$slow_log_uh_line/o )
3705                                                              ) {
3706         103                                280                  MKDEBUG && _d("Got user, host, ip", $user, $host, $ip);
3707         103                                568                  push @properties, 'user', $user, 'host', $host, 'ip', $ip;
3708         103                                322                  ++$got_uh;
3709                                                              }
3710                                                  
3711                                                              elsif (!$got_ac && $line =~ m/^# (?:administrator command:.*)$/) {
3712          10                                 44                  MKDEBUG && _d("Got admin command");
3713          10                                 69                  push @properties, 'cmd', 'Admin', 'arg', $line;
3714          10                                 72                  push @properties, 'bytes', length($properties[-1]);
3715          10                                 41                  ++$found_arg;
3716          10                                 44                  ++$got_ac;
3717                                                              }
3718                                                  
3719                                                              elsif ( $line =~ m/^# +[A-Z][A-Za-z_]+: \S+/ ) { # Make the test cheap!
3720         988                               2408                  MKDEBUG && _d("Got some line with properties");
3721         988                              11694                  my @temp = $line =~ m/(\w+):\s+(\S+|\Z)/g;
3722         988                               6030                  push @properties, @temp;
3723                                                              }
3724                                                  
3725                                                              elsif ( !$got_db && (my ( $db ) = $line =~ m/^use ([^;]+)/ ) ) {
3726          39                                 99                  MKDEBUG && _d("Got a default database:", $db);
3727          39                                153                  push @properties, 'db', $db;
3728          39                                115                  ++$got_db;
3729                                                              }
3730                                                  
3731                                                              elsif (!$got_set && (my ($setting) = $line =~ m/^SET\s+([^;]*)/)) {
3732          20                                 53                  MKDEBUG && _d("Got some setting:", $setting);
3733          20                                249                  push @properties, split(/,|\s*=\s*/, $setting);
3734          20                                 63                  ++$got_set;
3735                                                              }
3736                                                  
3737        1440    100    100                17378               if ( !$found_arg && $pos == $len ) {
3738           3                                 11                  MKDEBUG && _d("Did not find arg, looking for special cases");
3739           3                                 18                  local $INPUT_RECORD_SEPARATOR = ";\n";
3740  ***      3     50                          11                  if ( defined(my $l = $next_event->()) ) {
3741           3                                 11                     chomp $l;
3742           3                                  7                     MKDEBUG && _d("Found admin statement", $l);
3743           3                                 17                     push @properties, 'cmd', 'Admin', 'arg', '#' . $l;
3744           3                                 12                     push @properties, 'bytes', length($properties[-1]);
3745           3                                 26                     $found_arg++;
3746                                                                 }
3747                                                                 else {
3748  ***      0                                  0                     MKDEBUG && _d("I can't figure out what to do with this line");
3749  ***      0                                  0                     next EVENT;
3750                                                                 }
3751                                                              }
3752                                                           }
3753                                                           else {
3754         297                                742               MKDEBUG && _d("Got the query/arg line");
3755         297                               2146               my $arg = substr($stmt, $pos - length($line));
3756         297                               1668               push @properties, 'arg', $arg, 'bytes', length($arg);
3757  ***    297    100     66                 3629               if ( $args{misc} && $args{misc}->{embed}
      ***                   66                        
3758                                                                 && ( my ($e) = $arg =~ m/($args{misc}->{embed})/)
3759                                                              ) {
3760           1                                 19                  push @properties, $e =~ m/$args{misc}->{capture}/g;
3761                                                              }
3762         297                               1031               last LINE;
3763                                                           }
3764                                                        }
3765                                                  
3766         310                                983         MKDEBUG && _d('Properties of event:', Dumper(\@properties));
3767         310                               4780         my $event = { @properties };
3768         310                               3312         return $event;
3769                                                     } # EVENT
3770                                                  
3771          39                                167      @$pending = ();
3772  ***     39     50                         257      $args{oktorun}->(0) if $args{oktorun};
3773          39                                281      return;
3774                                                  }
3775                                                  
3776                                                  sub _d {
3777  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3778  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3779  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3780                                                          @_;
3781  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3782                                                  }
3783                                                  
3784                                                  1;
3785                                                  
3786                                                  # ###########################################################################
3787                                                  # End SlowLogParser package
3788                                                  # ###########################################################################
3789                                                  
3790                                                  # ###########################################################################
3791                                                  # SlowLogWriter package 5266
3792                                                  # ###########################################################################
3793                                                  package SlowLogWriter;
3794                                                  
3795           7                    7            67   use strict;
               7                                 17   
               7                                 40   
3796           7                    7            44   use warnings FATAL => 'all';
               7                                 16   
               7                                 37   
3797           7                    7            42   use English qw(-no_match_vars);
               7                                 15   
               7                                 41   
3798                                                  
3799  ***      7            50      7            44   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 18   
               7                                112   
3800                                                  
3801                                                  sub new {
3802  ***      0                    0             0      my ( $class ) = @_;
3803  ***      0                                  0      bless {}, $class;
3804                                                  }
3805                                                  
3806                                                  sub write {
3807  ***      0                    0             0      my ( $self, $fh, $event ) = @_;
3808  ***      0      0                           0      if ( $event->{ts} ) {
3809  ***      0                                  0         print $fh "# Time: $event->{ts}\n";
3810                                                     }
3811  ***      0      0                           0      if ( $event->{user} ) {
3812  ***      0                                  0         printf $fh "# User\@Host: %s[%s] \@ %s []\n",
3813                                                           $event->{user}, $event->{user}, $event->{host};
3814                                                     }
3815  ***      0      0      0                    0      if ( $event->{ip} && $event->{port} ) {
3816  ***      0                                  0         printf $fh "# Client: $event->{ip}:$event->{port}\n";
3817                                                     }
3818  ***      0      0                           0      if ( $event->{Thread_id} ) {
3819  ***      0                                  0         printf $fh "# Thread_id: $event->{Thread_id}\n";
3820                                                     }
3821                                                  
3822  ***      0      0                           0      my $percona_patched = exists $event->{QC_Hit} ? 1 : 0;
3823                                                  
3824  ***      0      0                           0      printf $fh
3825                                                        "# Query_time: %.6f  Lock_time: %.6f  Rows_sent: %d  Rows_examined: %d\n",
3826  ***      0                                  0         map { $_ || 0 }
3827  ***      0                                  0            @{$event}{qw(Query_time Lock_time Rows_sent Rows_examined)};
3828                                                  
3829  ***      0      0                           0      if ( $percona_patched ) {
3830  ***      0      0                           0         printf $fh
3831                                                           "# QC_Hit: %s  Full_scan: %s  Full_join: %s  Tmp_table: %s  Disk_tmp_table: %s\n# Filesort: %s  Disk_filesort: %s  Merge_passes: %d\n",
3832  ***      0                                  0            map { $_ || 0 }
3833  ***      0                                  0               @{$event}{qw(QC_Hit Full_scan Full_join Tmp_table Disk_tmp_table Filesort Disk_filesort Merge_passes)};
3834                                                  
3835  ***      0      0                           0         if ( exists $event->{InnoDB_IO_r_ops} ) {
3836  ***      0      0                           0            printf $fh
3837                                                              "#   InnoDB_IO_r_ops: %d  InnoDB_IO_r_bytes: %d  InnoDB_IO_r_wait: %s\n#   InnoDB_rec_lock_wait: %s  InnoDB_queue_wait: %s\n#   InnoDB_pages_distinct: %d\n",
3838  ***      0                                  0               map { $_ || 0 }
3839  ***      0                                  0                  @{$event}{qw(InnoDB_IO_r_ops InnoDB_IO_r_bytes InnoDB_IO_r_wait InnoDB_rec_lock_wait InnoDB_queue_wait InnoDB_pages_distinct)};
3840                                                  
3841                                                        } 
3842                                                        else {
3843  ***      0                                  0            printf $fh "# No InnoDB statistics available for this query\n";
3844                                                        }
3845                                                     }
3846                                                  
3847  ***      0      0                           0      if ( $event->{db} ) {
3848  ***      0                                  0         printf $fh "use %s;\n", $event->{db};
3849                                                     }
3850  ***      0      0                           0      if ( $event->{arg} =~ m/^administrator command/ ) {
3851  ***      0                                  0         print $fh '# ';
3852                                                     }
3853  ***      0                                  0      print $fh $event->{arg}, ";\n";
3854                                                  
3855  ***      0                                  0      return;
3856                                                  }
3857                                                  
3858                                                  sub _d {
3859  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3860  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3861  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3862                                                          @_;
3863  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3864                                                  }
3865                                                  
3866                                                  1;
3867                                                  
3868                                                  # ###########################################################################
3869                                                  # End SlowLogWriter package
3870                                                  # ###########################################################################
3871                                                  
3872                                                  # ###########################################################################
3873                                                  # EventAggregator package 4916
3874                                                  # ###########################################################################
3875                                                  package EventAggregator;
3876                                                  
3877           7                    7            47   use strict;
               7                                 30   
               7                                 34   
3878           7                    7            40   use warnings FATAL => 'all';
               7                                 21   
               7                                 33   
3879           7                    7            42   use English qw(-no_match_vars);
               7                                 16   
               7                                 42   
3880                                                  
3881           7                    7            44   use constant MKDEBUG      => $ENV{MKDEBUG};
               7                                 19   
               7                                 47   
3882           7                    7            42   use constant BUCK_SIZE    => 1.05;
               7                                 18   
               7                                 35   
3883           7                    7            39   use constant BASE_LOG     => log(BUCK_SIZE);
               7                                 19   
               7                                 31   
3884           7                    7            46   use constant BASE_OFFSET  => abs(1 - log(0.000001) / BASE_LOG); # 284.1617969
               7                                 16   
               7                                 31   
3885           7                    7            41   use constant NUM_BUCK     => 1000;
               7                                 19   
               7                                 49   
3886           7                    7            46   use constant MIN_BUCK     => .000001;
               7                                 21   
               7                                 36   
3887                                                  
3888                                                  our @buckets  = map { 0 } (0..NUM_BUCK-1);
3889                                                  
3890                                                  my @buck_vals = map { bucket_value($_); } (0..NUM_BUCK-1);
3891                                                  
3892                                                  sub new {
3893          55                   55           969      my ( $class, %args ) = @_;
3894          55                                384      foreach my $arg ( qw(groupby worst) ) {
3895  ***    110     50                         605         die "I need a $arg argument" unless $args{$arg};
3896                                                     }
3897  ***     55            50                  312      my $attributes = $args{attributes} || {};
3898         880                               4944      my $self = {
3899                                                        groupby        => $args{groupby},
3900                                                        detect_attribs => scalar keys %$attributes == 0 ? 1 : 0,
3901                                                        all_attribs    => [ keys %$attributes ],
3902                                                        ignore_attribs => {
3903         880                               3204            map  { $_ => $args{attributes}->{$_} }
3904          55                                275            grep { $_ ne $args{groupby} }
3905           1                                 11            @{$args{ignore_attributes}}
3906                                                        },
3907                                                        attributes     => {
3908           1                                  8            map  { $_ => $args{attributes}->{$_} }
3909           1                                 12            grep { $_ ne $args{groupby} }
3910                                                           keys %$attributes
3911                                                        },
3912                                                        alt_attribs    => {
3913           1                                  7            map  { $_ => make_alt_attrib(@{$args{attributes}->{$_}}) }
               1                                  4   
3914  ***     55     50                        1049            grep { $_ ne $args{groupby} }
3915                                                           keys %$attributes
3916                                                        },
3917                                                        worst        => $args{worst},
3918                                                        unroll_limit => $args{unroll_limit} || 1000,
3919                                                        attrib_limit => $args{attrib_limit},
3920                                                        result_classes => {},
3921                                                        result_globals => {},
3922                                                        result_samples => {},
3923                                                        n_events       => 0,
3924                                                        unrolled_loops => undef,
3925  ***     55    100     50                  494         type_for       => { %{$args{type_for} || { Query_time => 'num' }} },
3926                                                     };
3927          55                                747      return bless $self, $class;
3928                                                  }
3929                                                  
3930                                                  sub reset_aggregated_data {
3931          55                   55           258      my ( $self ) = @_;
3932          55                                170      foreach my $class ( values %{$self->{result_classes}} ) {
              55                                454   
3933         138                                875         foreach my $attrib ( values %$class ) {
3934        1833                               7127            delete @{$attrib}{keys %$attrib};
            1833                              29090   
3935                                                        }
3936                                                     }
3937          55                                195      foreach my $class ( values %{$self->{result_globals}} ) {
              55                                435   
3938         718                               2925         delete @{$class}{keys %$class};
             718                              11478   
3939                                                     }
3940          55                                194      delete @{$self->{result_samples}}{keys %{$self->{result_samples}}};
              55                               1010   
              55                                350   
3941          55                                389      $self->{n_events} = 0;
3942                                                  }
3943                                                  
3944                                                  sub aggregate {
3945         368                  368          1442      my ( $self, $event ) = @_;
3946                                                  
3947         368                               1831      my $group_by = $event->{$self->{groupby}};
3948  ***    368     50                        1580      return unless defined $group_by;
3949                                                  
3950         368                               1239      $self->{n_events}++;
3951         368                                878      MKDEBUG && _d('event', $self->{n_events});
3952                                                  
3953  ***    368     50                        1656      return $self->{unrolled_loops}->($self, $event, $group_by)
3954                                                        if $self->{unrolled_loops};
3955                                                  
3956  ***    368     50                        1987      if ( $self->{n_events} <= $self->{unroll_limit} ) {
3957                                                  
3958         368    100                        2712         $self->add_new_attributes($event) if $self->{detect_attribs};
3959                                                  
3960         368                               2602         ATTRIB:
3961         368                               1055         foreach my $attrib ( keys %{$self->{attributes}} ) {
3962                                                  
3963        5487    100                       23741            if ( !exists $event->{$attrib} ) {
3964         157                                357               MKDEBUG && _d("attrib doesn't exist in event:", $attrib);
3965         157                                771               my $alt_attrib = $self->{alt_attribs}->{$attrib}->($event);
3966         157                                333               MKDEBUG && _d('alt attrib:', $alt_attrib);
3967  ***    157     50                         715               next ATTRIB unless $alt_attrib;
3968                                                           }
3969                                                  
3970                                                           GROUPBY:
3971        5330    100                       21461            foreach my $val ( ref $group_by ? @$group_by : ($group_by) ) {
3972        5330           100                38291               my $class_attrib  = $self->{result_classes}->{$val}->{$attrib} ||= {};
3973        5330           100                28736               my $global_attrib = $self->{result_globals}->{$attrib} ||= {};
3974        5330                              16472               my $samples       = $self->{result_samples};
3975        5330                              19301               my $handler = $self->{handlers}->{ $attrib };
3976        5330    100                       19021               if ( !$handler ) {
3977        1153                               8602                  $handler = $self->make_handler(
3978                                                                    $attrib,
3979                                                                    $event,
3980                                                                    wor => $self->{worst} eq $attrib,
3981                                                                    alt => $self->{attributes}->{$attrib},
3982                                                                 );
3983        1153                               5245                  $self->{handlers}->{$attrib} = $handler;
3984                                                              }
3985        5330    100                       19879               next GROUPBY unless $handler;
3986        4857           100                19707               $samples->{$val} ||= $event; # Initialize to the first event.
3987        4857                              23237               $handler->($event, $class_attrib, $global_attrib, $samples, $group_by);
3988                                                           }
3989                                                        }
3990                                                     }
3991                                                     else {
3992  ***      0                                  0         $self->_make_unrolled_loops($event);
3993  ***      0                                  0         $self->{unrolled_loops}->($self, $event, $group_by);
3994                                                     }
3995                                                  
3996         368                               1932      return;
3997                                                  }
3998                                                  
3999                                                  sub _make_unrolled_loops {
4000  ***      0                    0             0      my ( $self, $event ) = @_;
4001                                                  
4002  ***      0                                  0      my $group_by = $event->{$self->{groupby}};
4003                                                  
4004  ***      0                                  0      my @attrs   = grep { $self->{handlers}->{$_} } keys %{$self->{attributes}};
      ***      0                                  0   
      ***      0                                  0   
4005  ***      0                                  0      my $globs   = $self->{result_globals}; # Global stats for each
4006  ***      0                                  0      my $samples = $self->{result_samples};
4007                                                  
4008  ***      0      0                           0      my @lines = (
4009                                                        'my ( $self, $event, $group_by ) = @_;',
4010                                                        'my ($val, $class, $global, $idx);',
4011                                                        (ref $group_by ? ('foreach my $group_by ( @$group_by ) {') : ()),
4012                                                        'my $temp = $self->{result_classes}->{ $group_by }
4013                                                           ||= { map { $_ => { } } @attrs };',
4014                                                        '$samples->{$group_by} ||= $event;', # Always start with the first.
4015                                                     );
4016  ***      0                                  0      foreach my $i ( 0 .. $#attrs ) {
4017  ***      0                                  0         push @lines, (
4018                                                           '$class  = $temp->{\''  . $attrs[$i] . '\'};',
4019                                                           '$global = $globs->{\'' . $attrs[$i] . '\'};',
4020                                                           $self->{unrolled_for}->{$attrs[$i]},
4021                                                        );
4022                                                     }
4023  ***      0      0                           0      if ( ref $group_by ) {
4024  ***      0                                  0         push @lines, '}'; # Close the loop opened above
4025                                                     }
4026  ***      0                                  0      @lines = map { s/^/   /gm; $_ } @lines; # Indent for debugging
      ***      0                                  0   
      ***      0                                  0   
4027  ***      0                                  0      unshift @lines, 'sub {';
4028  ***      0                                  0      push @lines, '}';
4029                                                  
4030  ***      0                                  0      my $code = join("\n", @lines);
4031  ***      0                                  0      MKDEBUG && _d('Unrolled subroutine:', @lines);
4032  ***      0                                  0      my $sub = eval $code;
4033  ***      0      0                           0      die $EVAL_ERROR if $EVAL_ERROR;
4034  ***      0                                  0      $self->{unrolled_loops} = $sub;
4035                                                  
4036  ***      0                                  0      return;
4037                                                  }
4038                                                  
4039                                                  sub results {
4040         478                  478          1706      my ( $self ) = @_;
4041                                                     return {
4042         478                               4339         classes => $self->{result_classes},
4043                                                        globals => $self->{result_globals},
4044                                                        samples => $self->{result_samples},
4045                                                     };
4046                                                  }
4047                                                  
4048                                                  sub attributes {
4049  ***      0                    0             0      my ( $self ) = @_;
4050  ***      0                                  0      return $self->{type_for};
4051                                                  }
4052                                                  
4053                                                  sub type_for {
4054        2950                 2950         11525      my ( $self, $attrib ) = @_;
4055        2950                              23193      return $self->{type_for}->{$attrib};
4056                                                  }
4057                                                  
4058                                                  sub make_handler {
4059        1153                 1153          7942      my ( $self, $attrib, $event, %args ) = @_;
4060  ***   1153     50                        5190      die "I need an attrib" unless defined $attrib;
4061        1153                               3275      my ($val) = grep { defined $_ } map { $event->{$_} } @{ $args{alt} };
            1153                               4243   
            1153                               4835   
            1153                               4724   
4062        1153                               3552      my $is_array = 0;
4063  ***   1153     50                        4637      if (ref $val eq 'ARRAY') {
4064  ***      0                                  0         $is_array = 1;
4065  ***      0                                  0         $val      = $val->[0];
4066                                                     }
4067        1153    100                        5336      return unless defined $val; # Can't decide type if it's undef.
4068                                                  
4069         680                               4371      my $float_re = qr{[+-]?(?:(?=\d|[.])\d+(?:[.])\d{0,})(?:E[+-]?\d+)?}i;
4070         680    100                        2994      my $type = $self->type_for($attrib)         ? $self->type_for($attrib)
                    100                               
                    100                               
4071                                                              : $val  =~ m/^(?:\d+|$float_re)$/o ? 'num'
4072                                                              : $val  =~ m/^(?:Yes|No)$/         ? 'bool'
4073                                                              :                                    'string';
4074         680                               1684      MKDEBUG && _d('Type for', $attrib, 'is', $type,
4075                                                        '(sample:', $val, '), is array:', $is_array);
4076         680                               3151      $self->{type_for}->{$attrib} = $type;
4077                                                  
4078         680    100                       15526      %args = ( # Set up defaults
                    100                               
                    100                               
                    100                               
4079                                                        min => 1,
4080                                                        max => 1,
4081                                                        sum => $type =~ m/num|bool/    ? 1 : 0,
4082                                                        cnt => 1,
4083                                                        unq => $type =~ m/bool|string/ ? 1 : 0,
4084                                                        all => $type eq 'num'          ? 1 : 0,
4085                                                        glo => 1,
4086                                                        trf => ($type eq 'bool') ? q{(($val || '') eq 'Yes') ? 1 : 0} : undef,
4087                                                        wor => 0,
4088                                                        alt => [],
4089                                                        %args,
4090                                                     );
4091                                                  
4092         680                               4243      my @lines = ("# type: $type"); # Lines of code for the subroutine
4093         680    100                        2977      if ( $args{trf} ) {
4094         115                                577         push @lines, q{$val = } . $args{trf} . ';';
4095                                                     }
4096                                                  
4097         680                               2416      foreach my $place ( qw($class $global) ) {
4098        1360                               3259         my @tmp;
4099  ***   1360     50                        5731         if ( $args{min} ) {
4100        1360    100                        5212            my $op   = $type eq 'num' ? '<' : 'lt';
4101        1360                               5973            push @tmp, (
4102                                                              'PLACE->{min} = $val if !defined PLACE->{min} || $val '
4103                                                                 . $op . ' PLACE->{min};',
4104                                                           );
4105                                                        }
4106  ***   1360     50                        5431         if ( $args{max} ) {
4107        1360    100                        5282            my $op = ($type eq 'num') ? '>' : 'gt';
4108        1360                               5272            push @tmp, (
4109                                                              'PLACE->{max} = $val if !defined PLACE->{max} || $val '
4110                                                                 . $op . ' PLACE->{max};',
4111                                                           );
4112                                                        }
4113        1360    100                        5449         if ( $args{sum} ) {
4114         996                               3138            push @tmp, 'PLACE->{sum} += $val;';
4115                                                        }
4116  ***   1360     50                        5460         if ( $args{cnt} ) {
4117        1360                               4237            push @tmp, '++PLACE->{cnt};';
4118                                                        }
4119        1360    100                        5487         if ( $args{all} ) {
4120         766                               2869            push @tmp, (
4121                                                              'exists PLACE->{all} or PLACE->{all} = [ @buckets ];',
4122                                                              '++PLACE->{all}->[ EventAggregator::bucket_idx($val) ];',
4123                                                           );
4124                                                        }
4125        1360                               4527         push @lines, map { s/PLACE/$place/g; $_ } @tmp;
            6608                              33551   
            6608                              24735   
4126                                                     }
4127                                                  
4128         680    100                        3046      if ( $args{unq} ) {
4129         297                               1082         push @lines, '++$class->{unq}->{$val};';
4130                                                     }
4131         680    100                        2806      if ( $args{wor} ) {
4132  ***     53     50                         272         my $op = $type eq 'num' ? '>=' : 'ge';
4133          53                                360         push @lines, (
4134                                                           'if ( $val ' . $op . ' ($class->{max} || 0) ) {',
4135                                                           '   $samples->{$group_by} = $event;',
4136                                                           '}',
4137                                                        );
4138                                                     }
4139                                                  
4140         680                               1712      my @broken_query_time;
4141         680    100                        2671      if ( $attrib eq 'Query_time' ) {
4142          54                                320         push @broken_query_time, (
4143                                                           '$val =~ s/^(\d+(?:\.\d+)?).*/$1/;',
4144                                                           '$event->{\''.$attrib.'\'} = $val;',
4145                                                        );
4146                                                     }
4147                                                  
4148         680                               1661      my @limit;
4149  ***    680    100     66                 7477      if ( $args{all} && $type eq 'num' && $self->{attrib_limit} ) {
      ***                   66                        
4150         383                               2465         push @limit, (
4151                                                           "if ( \$val > $self->{attrib_limit} ) {",
4152                                                           '   $val = $class->{last} ||= 0;',
4153                                                           '}',
4154                                                           '$class->{last} = $val;',
4155                                                        );
4156                                                     }
4157                                                  
4158  ***      0                                  0      my @unrolled = (
4159                                                        "\$val = \$event->{'$attrib'};",
4160                                                        ($is_array ? ('foreach my $val ( @$val ) {') : ()),
4161         680                               3260         (map { "\$val = \$event->{'$_'} unless defined \$val;" }
4162         680                               2736            grep { $_ ne $attrib } @{$args{alt}}),
            9499                              35213   
4163                                                        'defined $val && do {',
4164  ***    680     50                        3271         ( map { s/^/   /gm; $_ } (@broken_query_time, @limit, @lines) ), # Indent for debugging
      ***   9499     50                       36878   
4165                                                        '};',
4166                                                        ($is_array ? ('}') : ()),
4167                                                     );
4168         680                               7687      $self->{unrolled_for}->{$attrib} = join("\n", @unrolled);
4169                                                  
4170  ***      0                                  0      unshift @lines, (
4171                                                        'sub {',
4172                                                        'my ( $event, $class, $global, $samples, $group_by ) = @_;',
4173                                                        'my ($val, $idx);', # NOTE: define all variables here
4174                                                        "\$val = \$event->{'$attrib'};",
4175         680                               5406         (map { "\$val = \$event->{'$_'} unless defined \$val;" }
4176  ***    680     50                        3081            grep { $_ ne $attrib } @{$args{alt}}),
      ***    680     50                        2604   
4177                                                        'return unless defined $val;',
4178                                                        ($is_array ? ('foreach my $val ( @$val ) {') : ()),
4179                                                        @broken_query_time,
4180                                                        @limit,
4181                                                        ($is_array ? ('}') : ()),
4182                                                     );
4183         680                               2147      push @lines, '}';
4184         680                               4390      my $code = join("\n", @lines);
4185         680                               3412      $self->{code_for}->{$attrib} = $code;
4186                                                  
4187         680                               1576      MKDEBUG && _d('Metric handler for', $attrib, ':', @lines);
4188         680                             140316      my $sub = eval join("\n", @lines);
4189  ***    680     50                        3045      die if $EVAL_ERROR;
4190         680                               8526      return $sub;
4191                                                  }
4192                                                  
4193                                                  sub bucket_idx {
4194        5093                 5093         18686      my ( $val ) = @_;
4195        5093    100                       25938      return 0 if $val < MIN_BUCK;
4196        3145                              14054      my $idx = int(BASE_OFFSET + log($val)/BASE_LOG);
4197  ***   3145     50                       19077      return $idx > (NUM_BUCK-1) ? (NUM_BUCK-1) : $idx;
4198                                                  }
4199                                                  
4200                                                  sub bucket_value {
4201        7000                 7000         21253      my ( $bucket ) = @_;
4202        7000    100                       25304      return 0 if $bucket == 0;
4203  ***   6993     50     33                51557      die "Invalid bucket: $bucket" if $bucket < 0 || $bucket > (NUM_BUCK-1);
4204        6993                              32187      return (BUCK_SIZE**($bucket-1)) * MIN_BUCK;
4205                                                  }
4206                                                  
4207                                                  {
4208                                                     my @buck_tens;
4209                                                     sub buckets_of {
4210         106    100           106         17782         return @buck_tens if @buck_tens;
4211                                                  
4212           7                                 27         my $start_bucket  = 0;
4213           7                                 24         my @base10_starts = (0);
4214           7                                 34         map { push @base10_starts, (10**$_)*MIN_BUCK } (1..7);
              49                                216   
4215                                                  
4216           7                                 66         for my $base10_bucket ( 0..($#base10_starts-1) ) {
4217          49                                217            my $next_bucket = bucket_idx( $base10_starts[$base10_bucket+1] );
4218          49                                114            MKDEBUG && _d('Base 10 bucket', $base10_bucket, 'maps to',
4219                                                              'base 1.05 buckets', $start_bucket, '..', $next_bucket-1);
4220          49                                199            for my $base1_05_bucket ($start_bucket..($next_bucket-1)) {
4221        2317                               7716               $buck_tens[$base1_05_bucket] = $base10_bucket;
4222                                                           }
4223          49                                179            $start_bucket = $next_bucket;
4224                                                        }
4225                                                  
4226           7                                360         map { $buck_tens[$_] = 7 } ($start_bucket..(NUM_BUCK-1));
            4683                              15688   
4227                                                  
4228           7                               1488         return @buck_tens;
4229                                                     }
4230                                                  }
4231                                                  
4232                                                  sub calculate_statistical_metrics {
4233         646                  646          2521      my ( $self, $vals, $args ) = @_;
4234         646                               3781      my $statistical_metrics = {
4235                                                        pct_95    => 0,
4236                                                        stddev    => 0,
4237                                                        median    => 0,
4238                                                        cutoff    => undef,
4239                                                     };
4240                                                  
4241  ***    646     50     33                 8138      return $statistical_metrics
      ***                   33                        
4242                                                        unless defined $vals && @$vals && $args->{cnt};
4243                                                  
4244         646                               2017      my $n_vals = $args->{cnt};
4245         646    100    100                 4359      if ( $n_vals == 1 || $args->{max} == $args->{min} ) {
                    100                               
4246         592           100                 3359         my $v      = $args->{max} || 0;
4247         592    100                        3628         my $bucket = int(6 + ( log($v > 0 ? $v : MIN_BUCK) / log(10)));
4248  ***    592     50                        2760         $bucket    = $bucket > 7 ? 7 : $bucket < 0 ? 0 : $bucket;
                    100                               
4249                                                        return {
4250         592                               4170            pct_95 => $v,
4251                                                           stddev => 0,
4252                                                           median => $v,
4253                                                           cutoff => $n_vals,
4254                                                        };
4255                                                     }
4256                                                     elsif ( $n_vals == 2 ) {
4257          29                                134         foreach my $v ( $args->{min}, $args->{max} ) {
4258          58    100    100                  567            my $bucket = int(6 + ( log($v && $v > 0 ? $v : MIN_BUCK) / log(10)));
4259  ***     58     50                         339            $bucket = $bucket > 7 ? 7 : $bucket < 0 ? 0 : $bucket;
                    100                               
4260                                                        }
4261  ***     29            50                  185         my $v      = $args->{max} || 0;
4262          29           100                  192         my $mean = (($args->{min} || 0) + $v) / 2;
4263                                                        return {
4264          29                                288            pct_95 => $v,
4265                                                           stddev => sqrt((($v - $mean) ** 2) *2),
4266                                                           median => $mean,
4267                                                           cutoff => $n_vals,
4268                                                        };
4269                                                     }
4270                                                  
4271          25    100                         130      my $cutoff = $n_vals >= 10 ? int ( $n_vals * 0.95 ) : $n_vals;
4272          25                                 86      $statistical_metrics->{cutoff} = $cutoff;
4273                                                  
4274          25                                 68      my $total_left = $n_vals;
4275          25                                 80      my $top_vals   = $n_vals - $cutoff; # vals > 95th
4276          25                                 67      my $sum_excl   = 0;
4277          25                                 79      my $sum        = 0;
4278          25                                 69      my $sumsq      = 0;
4279          25                                101      my $mid        = int($n_vals / 2);
4280          25                                 66      my $median     = 0;
4281          25                                 68      my $prev       = NUM_BUCK-1; # Used for getting median when $cutoff is odd
4282          25                                 70      my $bucket_95  = 0; # top bucket in 95th
4283                                                  
4284          25                                 68      MKDEBUG && _d('total vals:', $total_left, 'top vals:', $top_vals, 'mid:', $mid);
4285                                                  
4286                                                     BUCKET:
4287          25                                188      for my $bucket ( reverse 0..(NUM_BUCK-1) ) {
4288       25000                              71257         my $val = $vals->[$bucket];
4289       25000    100                       92136         next BUCKET unless $val; 
4290                                                  
4291          84                                222         $total_left -= $val;
4292          84                                227         $sum_excl   += $val;
4293          84    100    100                  551         $bucket_95   = $bucket if !$bucket_95 && $sum_excl > $top_vals;
4294                                                  
4295          84    100    100                  585         if ( !$median && $total_left <= $mid ) {
4296          25    100    100                  234            $median = (($cutoff % 2) || ($val > 1)) ? $buck_vals[$bucket]
4297                                                                   : ($buck_vals[$bucket] + $buck_vals[$prev]) / 2;
4298                                                        }
4299                                                  
4300          84                                336         $sum    += $val * $buck_vals[$bucket];
4301          84                                327         $sumsq  += $val * ($buck_vals[$bucket]**2);
4302          84                                260         $prev   =  $bucket;
4303                                                     }
4304                                                  
4305          25                                141      my $var      = $sumsq/$n_vals - ( ($sum/$n_vals) ** 2 );
4306          25    100                         153      my $stddev   = $var > 0 ? sqrt($var) : 0;
4307  ***     25            50                  198      my $maxstdev = (($args->{max} || 0) - ($args->{min} || 0)) / 2;
                           100                        
4308  ***     25     50                         105      $stddev      = $stddev > $maxstdev ? $maxstdev : $stddev;
4309                                                  
4310          25                                 57      MKDEBUG && _d('sum:', $sum, 'sumsq:', $sumsq, 'stddev:', $stddev,
4311                                                        'median:', $median, 'prev bucket:', $prev,
4312                                                        'total left:', $total_left, 'sum excl', $sum_excl,
4313                                                        'bucket 95:', $bucket_95, $buck_vals[$bucket_95]);
4314                                                  
4315          25                                 94      $statistical_metrics->{stddev} = $stddev;
4316          25                                 94      $statistical_metrics->{pct_95} = $buck_vals[$bucket_95];
4317          25                                 81      $statistical_metrics->{median} = $median;
4318                                                  
4319          25                                108      return $statistical_metrics;
4320                                                  }
4321                                                  
4322                                                  sub metrics {
4323  ***      0                    0             0      my ( $self, %args ) = @_;
4324  ***      0                                  0      foreach my $arg ( qw(attrib where) ) {
4325  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
4326                                                     }
4327  ***      0                                  0      my $stats = $self->results;
4328  ***      0                                  0      my $store = $stats->{classes}->{$args{where}}->{$args{attrib}};
4329                                                  
4330  ***      0                                  0      my $global_cnt = $stats->{globals}->{$args{attrib}}->{cnt};
4331  ***      0                                  0      my $metrics    = $self->calculate_statistical_metrics($store->{all}, $store);
4332                                                  
4333                                                     return {
4334  ***      0      0      0                    0         cnt    => $store->{cnt},
      ***             0      0                        
4335                                                        pct    => $global_cnt && $store->{cnt} ? $store->{cnt} / $global_cnt : 0,
4336                                                        sum    => $store->{sum},
4337                                                        min    => $store->{min},
4338                                                        max    => $store->{max},
4339                                                        avg    => $store->{sum} && $store->{cnt} ? $store->{sum} / $store->{cnt} : 0,
4340                                                        median => $metrics->{median},
4341                                                        pct_95 => $metrics->{pct_95},
4342                                                        stddev => $metrics->{stddev},
4343                                                     };
4344                                                  }
4345                                                  
4346                                                  sub top_events {
4347          55                   55           616      my ( $self, %args ) = @_;
4348          55                                307      my $classes = $self->{result_classes};
4349         131                                998      my @sorted = reverse sort { # Sorted list of $groupby values
4350         138                                855         $classes->{$a}->{$args{attrib}}->{$args{orderby}}
4351                                                           <=> $classes->{$b}->{$args{attrib}}->{$args{orderby}}
4352                                                        } grep {
4353          55                                384            defined $classes->{$_}->{$args{attrib}}->{$args{orderby}}
4354                                                        } keys %$classes;
4355          55                                407      my @chosen;
4356          55                                223      my ($total, $count) = (0, 0);
4357          55                                259      foreach my $groupby ( @sorted ) {
4358         134    100    100                 2164         if ( 
      ***            50     66                        
                           100                        
      ***                   33                        
      ***                   66                        
4359                                                           (!$args{total} || $total < $args{total} )
4360                                                           && ( !$args{count} || $count < $args{count} )
4361                                                        ) {
4362         121                                602            push @chosen, [$groupby, 'top'];
4363                                                        }
4364                                                  
4365                                                        elsif ( $args{ol_attrib} && (!$args{ol_freq}
4366                                                           || $classes->{$groupby}->{$args{ol_attrib}}->{cnt} >= $args{ol_freq})
4367                                                        ) {
4368  ***      0                                  0            MKDEBUG && _d('Calculating statistical_metrics');
4369  ***      0                                  0            my $stats = $self->calculate_statistical_metrics(
4370                                                              $classes->{$groupby}->{$args{ol_attrib}}->{all},
4371                                                              $classes->{$groupby}->{$args{ol_attrib}}
4372                                                           );
4373  ***      0      0                           0            if ( $stats->{pct_95} >= $args{ol_limit} ) {
4374  ***      0                                  0               push @chosen, [$groupby, 'outlier'];
4375                                                           }
4376                                                        }
4377                                                  
4378         134                                787         $total += $classes->{$groupby}->{$args{attrib}}->{$args{orderby}};
4379         134                                446         $count++;
4380                                                     }
4381          55                                387      return @chosen;
4382                                                  }
4383                                                  
4384                                                  sub add_new_attributes {
4385         366                  366          1551      my ( $self, $event ) = @_;
4386  ***    366     50                        1386      return unless $event;
4387                                                  
4388         717                               2004      map {
4389        6841    100    100                67233         my $attrib = $_;
4390         717                               3215         $self->{attributes}->{$attrib}  = [$attrib];
4391         717                               2602         $self->{alt_attribs}->{$attrib} = make_alt_attrib($attrib);
4392         717                               1929         push @{$self->{all_attribs}}, $attrib;
             717                               2739   
4393         717                               2241         MKDEBUG && _d('Added new attribute:', $attrib);
4394                                                     }
4395                                                     grep {
4396         366                               2548         $_ ne $self->{groupby}
4397                                                        && !exists $self->{attributes}->{$_}
4398                                                        && !exists $self->{ignore_attribs}->{$_}
4399                                                     }
4400                                                     keys %$event;
4401                                                  
4402         366                               1650      return;
4403                                                  }
4404                                                  
4405                                                  sub get_attributes {
4406          54                   54           247      my ( $self ) = @_;
4407          54                                158      return @{$self->{all_attribs}};
              54                                769   
4408                                                  }
4409                                                  
4410                                                  sub events_processed {
4411           7                    7            30      my ( $self ) = @_;
4412           7                                 50      return $self->{n_events};
4413                                                  }
4414                                                  
4415                                                  sub make_alt_attrib {
4416         718                  718          2772      my ( @attribs ) = @_;
4417                                                  
4418         718                               2146      my $attrib = shift @attribs;  # Primary attribute.
4419  ***    718     50           157          5883      return sub {} unless @attribs;  # No alternates.
             157                                488   
4420                                                  
4421  ***      0                                  0      my @lines;
4422  ***      0                                  0      push @lines, 'sub { my ( $event ) = @_; my $alt_attrib;';
4423  ***      0                                  0      push @lines, map  {
4424  ***      0                                  0            "\$alt_attrib = '$_' if !defined \$alt_attrib "
4425                                                           . "&& exists \$event->{'$_'};"
4426                                                        } @attribs;
4427  ***      0                                  0      push @lines, 'return $alt_attrib; }';
4428  ***      0                                  0      MKDEBUG && _d('alt attrib sub for', $attrib, ':', @lines);
4429  ***      0                                  0      my $sub = eval join("\n", @lines);
4430  ***      0      0                           0      die if $EVAL_ERROR;
4431  ***      0                                  0      return $sub;
4432                                                  }
4433                                                  
4434                                                  sub _d {
4435  ***      0                    0             0      my ($package, undef, $line) = caller 0;
4436  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
4437  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
4438                                                          @_;
4439  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4440                                                  }
4441                                                  
4442                                                  1;
4443                                                  
4444                                                  # ###########################################################################
4445                                                  # End EventAggregator package
4446                                                  # ###########################################################################
4447                                                  
4448                                                  # ###########################################################################
4449                                                  # ReportFormatter package 5763
4450                                                  # ###########################################################################
4451                                                  package ReportFormatter;
4452                                                  
4453           7                    7            66   use strict;
               7                                 26   
               7                                 92   
4454           7                    7            43   use warnings FATAL => 'all';
               7                                 20   
               7                                 45   
4455           7                    7            43   use English qw(-no_match_vars);
               7                                 16   
               7                                 50   
4456           7                    7            52   use List::Util qw(min max);
               7                                 17   
               7                                124   
4457                                                  
4458                                                  eval { require Term::ReadKey };
4459                                                  my $have_term = $EVAL_ERROR ? 0 : 1;
4460                                                  
4461  ***      7            50      7            43   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 19   
               7                                101   
4462                                                  
4463           7                    7            44   use Data::Dumper;
               7                                 20   
               7                                 37   
4464                                                  $Data::Dumper::Indent    = 1;
4465                                                  $Data::Dumper::Sortkeys  = 1;
4466                                                  $Data::Dumper::Quotekeys = 0;
4467                                                  
4468                                                  sub new {
4469          12                   12            87      my ( $class, %args ) = @_;
4470          12                                 51      my @required_args = qw();
4471          12                                 56      foreach my $arg ( @required_args ) {
4472  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
4473                                                     }
4474          12                                132      my $self = {
4475                                                        underline_header   => 1,
4476                                                        line_prefix        => '# ',
4477                                                        line_width         => 78,
4478                                                        truncate_underline => 1,
4479                                                        column_spacing     => ' ',
4480                                                        %args,             # args above can be overriden, args below cannot
4481                                                        n_cols             => 0,
4482                                                     };
4483                                                  
4484  ***     12     50                          74      if ( $self->{line_width} eq 'auto' ) {
4485  ***      0      0                           0         die "Cannot auto-detect line width because the Term::ReadKey module "
4486                                                           . "is not installed" unless $have_term;
4487  ***      0                                  0         ($self->{line_width}) = GetTerminalSize();
4488                                                     }
4489          12                                 27      MKDEBUG && _d('Line width:', $self->{line_width});
4490                                                  
4491          12                                183      return bless $self, $class;
4492                                                  }
4493                                                  
4494                                                  sub set_title {
4495          10                   10            46      my ( $self, $title ) = @_;
4496          10                                 50      $self->{title} = $title;
4497          10                                 32      return;
4498                                                  }
4499                                                  
4500                                                  sub set_columns {
4501          12                   12            60      my ( $self, @cols ) = @_;
4502          12                                 62      push @{$self->{cols}}, map {
              65                                172   
4503          12                                 44         my $col = $_;
4504  ***     65     50                         269         die "Column does not have a name" unless defined $col->{name};
4505  ***     65     50     33                  330         if ( $col->{fixed_wdith} && $col->{fixed_width} < length $col->{name} ) { 
4506  ***      0                                  0            die "Fixed width $col->{fixed_wdith} is less than length of "
4507                                                              . "column name '$col->{name}'";
4508                                                        }
4509  ***     65     50     33                  331         if ( $col->{min_width} && $col->{min_width} < length $col->{name} ) {
4510  ***      0                                  0            die "Minimum width $col->{min_width} is less than length of "
4511                                                              . "column name '$col->{name}'";
4512                                                        }
4513  ***     65            50                  311         $col->{truncate_mark} ||= '...';
4514  ***     65            50                  293         $col->{type}          ||= 's';
4515  ***     65            50                  622         $col->{min_width}     ||= $col->{fixed_width} || 0;
      ***                   33                        
4516  ***     65            50                  629         $col->{max_width}     ||= $col->{fixed_width} || 0;
      ***                   33                        
4517          65                                249         $col->{min_val_width}   = length $col->{name};
4518          65                                254         $col->{max_val_width}   = length $col->{name};
4519          65                                220         $col;
4520                                                     } @cols;
4521          12                                 56      $self->{n_cols} = scalar @cols;
4522          12                                 43      return;
4523                                                  }
4524                                                  
4525                                                  sub add_line {
4526          34                   34           225      my ( $self, @vals ) = @_;
4527          34                                127      my $n_vals = scalar @vals;
4528  ***     34     50                         183      $self->_column_error("Number of columns ($$self->{n_cols}) and "
4529                                                        . "values ($n_vals) do not match") unless $self->{n_cols} == $n_vals;
4530                                                  
4531          34                                100      my @line;
4532          34                                179      for my $i ( 0..$#vals ) {
4533         189                                677         my $col      = $self->{cols}->[$i];
4534  ***    189     50                         769         my $val      = defined $vals[$i] ? $vals[$i] : $col->{undef_value};
4535         189                                528         my $width    = length $val;
4536         189                                450         my $too_wide = 0;  # this var does double duty: it's a bool and also
4537  ***    189     50     33                  955         if ( $col->{fixed_width} && $width > $col->{fixed_width} ) {
4538  ***      0                                  0            $too_wide = $col->{fixed_width};
4539                                                        }
4540  ***    189     50     33                  934         if ( $col->{max_width} && $width > $col->{max_width} ) {
4541  ***      0                                  0            $too_wide = $col->{max_width};
4542                                                        }
4543  ***    189     50                         622         if ( $too_wide ) {
4544  ***      0      0                           0            $self->_column_error("Value '$val' is too wide for column "
4545                                                              . $col->{name}) unless $col->{truncate};
4546  ***      0                                  0            $val = $self->_truncate($col, $val, $too_wide);
4547  ***      0                                  0            MKDEBUG && _d('Truncated', $vals[$i], 'to', $val);
4548                                                        }
4549         189                                959         $col->{min_val_width} = min($width, $col->{min_val_width});
4550         189                                875         $col->{max_val_width} = max($width, $col->{max_val_width});
4551  ***    189     50                         712         $val = $col->{trf}->($val) if $col->{trf};
4552         189                                720         push @line, $val;
4553                                                     }
4554          34                                 93      push @{$self->{lines}}, \@line;
              34                                168   
4555                                                  
4556          34                                165      return;
4557                                                  }
4558                                                  
4559                                                  sub get_report {
4560          12                   12            46      my ( $self ) = @_;
4561                                                  
4562          12                                 60      my $n_cols = $self->{n_cols} - 1;
4563          12    100                          65      $n_cols   -= 1 if $self->{long_last_column};  # handle this col specially
4564          12                                 32      my @col_fmts;
4565          12                                 64      for my $i ( 0..$n_cols ) {
4566          55                                189         my $col = $self->{cols}->[$i];
4567  ***     55    100     33                  747         my $col_fmt = '%'
      ***                   50                        
      ***                   50                        
4568                                                                    . ($col->{right_justify} ? '' : '-')
4569                                                                    . ($col->{max_width} || $col->{max_val_width} || '')
4570                                                                    . ($col->{type} || 's');
4571          55                                200         push @col_fmts, $col_fmt;
4572                                                     }
4573          12    100                          70      if ( $self->{long_last_column} ) {
4574          10                                 36         push @col_fmts, '%s';  # Let the column's value extend rightward forever
4575                                                     }
4576  ***     12            50                  102      my $fmt = ($self->{line_prefix} || '')
4577                                                             . join($self->{column_spacing}, @col_fmts);
4578          12                                 29      MKDEBUG && _d('Format:', $fmt);
4579                                                  
4580          12                                250      (my $hdr_fmt = $fmt) =~ s/%([^-])/%-$1/g;
4581                                                  
4582          12                                 36      my @lines;
4583          12    100                         100      push @lines, sprintf "$self->{line_prefix}$self->{title}" if $self->{title};
4584          12                                 45      push @lines, sprintf $hdr_fmt, map { $_->{name} } @{$self->{cols}};
              65                                274   
              12                                 56   
4585                                                  
4586  ***     12     50                          75      if ( $self->{underline_header} ) {
4587          12                                 45         my $underline_len = 0;
4588          65                                250         my @underlines = map {
4589          12                                 50            my $underline = '=' x $_->{max_val_width};
4590          65                                182            $underline_len += length $underline;
4591          65                                245            $underline;
4592          12                                 34         } @{$self->{cols}};
4593          12                                 51         $underline_len += (scalar @underlines) - 1;
4594  ***     12    100     66                  169         if ( $self->{truncate_underline}
4595                                                             && (2 + $underline_len) > $self->{line_width} ) {
4596           3                                 16            my $over = $self->{line_width} - (2 + $underline_len);
4597           3                                 18            $underlines[-1] = substr($underlines[-1], 0, $over);
4598                                                        }
4599          12                                 77         push @lines, sprintf $fmt, @underlines;
4600                                                     }
4601                                                  
4602          12                                 34      foreach my $line ( @{$self->{lines}} ) {
              12                                 63   
4603          34                                186         push @lines, sprintf $fmt, @$line;
4604                                                     }
4605                                                  
4606          12                                333      return join("\n", @lines) . "\n";
4607                                                  }
4608                                                  
4609                                                  sub _truncate {
4610  ***      0                    0             0      my ( $self, $col, $val, $width ) = @_;
4611  ***      0                                  0      $val  = substr($val, 0, $width - length $col->{truncate_mark});
4612  ***      0                                  0      $val .= $col->{truncate_mark};
4613  ***      0                                  0      return $val;
4614                                                  }
4615                                                  
4616                                                  sub _column_error {
4617  ***      0                    0             0      my ( $self, $err ) = @_;
4618  ***      0                                  0      my $msg = "Column error: $err";
4619  ***      0      0                           0      $self->{column_errors} eq 'die' ? die $msg : warn $msg;
4620  ***      0                                  0      return;
4621                                                  }
4622                                                  
4623                                                  sub _d {
4624  ***      0                    0             0      my ($package, undef, $line) = caller 0;
4625  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
4626  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
4627                                                          @_;
4628  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4629                                                  }
4630                                                  
4631                                                  1;
4632                                                  
4633                                                  # ###########################################################################
4634                                                  # End ReportFormatter package
4635                                                  # ###########################################################################
4636                                                  
4637                                                  # ###########################################################################
4638                                                  # QueryReportFormatter package 5764
4639                                                  # ###########################################################################
4640                                                  
4641                                                  
4642                                                  package QueryReportFormatter;
4643                                                  
4644           7                    7            51   use strict;
               7                                 20   
               7                                 56   
4645           7                    7            46   use warnings FATAL => 'all';
               7                                 17   
               7                                 44   
4646           7                    7            46   use English qw(-no_match_vars);
               7                                 16   
               7                                 39   
4647                                                  
4648                                                  Transformers->import(
4649                                                     qw(shorten micro_t parse_timestamp unix_timestamp
4650                                                        make_checksum percentage_of));
4651                                                  
4652           7                    7            44   use constant MKDEBUG           => $ENV{MKDEBUG};
               7                                 37   
               7                                 55   
4653           7                    7            42   use constant LINE_LENGTH       => 74;
               7                                 18   
               7                                 33   
4654           7                    7            61   use constant MAX_STRING_LENGTH => 10;
               7                                 17   
               7                                 32   
4655                                                  
4656                                                  my %formatting_function = (
4657                                                     ts => sub {
4658                                                        my ( $stats ) = @_;
4659                                                        my $min = parse_timestamp($stats->{min} || '');
4660                                                        my $max = parse_timestamp($stats->{max} || '');
4661                                                        return $min && $max ? "$min to $max" : '';
4662                                                     },
4663                                                  );
4664                                                  
4665                                                  my $bool_format = '# %3s%% %-6s %s';
4666                                                  
4667                                                  sub new {
4668          54                   54           446      my ( $class, %args ) = @_;
4669                                                  
4670  ***     54            50                  359      my $label_width = $args{label_width} || 9;
4671  ***     54     50                         296      if ( lc($label_width) eq 'auto' ) {
4672  ***      0                                  0         $label_width = 9;  # Start with default, try to increase it.
4673  ***      0                                  0         eval {
4674  ***      0                                  0            require Term::ReadKey;
4675  ***      0                                  0            Term::ReadKey->import(qw(GetTerminalSize));
4676  ***      0                                  0            (my $w) = GetTerminalSize();
4677  ***      0      0                           0            if ( $w > 80 ) {
4678  ***      0             0                    0               do $label_width++ while $label_width < 15 && --$w >= 80;
4679                                                           }
4680                                                        };
4681                                                     }
4682          54                                148      MKDEBUG && _d('Label width:', $label_width);
4683                                                  
4684          54                                318      my $self = {
4685                                                        %args,
4686                                                        label_width => $label_width,
4687                                                     };
4688          54                                505      return bless $self, $class;
4689                                                  }
4690                                                  
4691                                                  sub header {
4692  ***      0                    0             0      my ($self) = @_;
4693                                                  
4694  ***      0                                  0      my ( $rss, $vsz, $user, $system ) = ( 0, 0, 0, 0 );
4695  ***      0                                  0      my $result = '';
4696  ***      0                                  0      eval {
4697  ***      0                                  0         my $mem = `ps -o rss,vsz -p $PID 2>&1`;
4698  ***      0                                  0         ( $rss, $vsz ) = $mem =~ m/(\d+)/g;
4699  ***      0                                  0         ( $user, $system ) = times();
4700  ***      0             0                    0         $result = sprintf "# %s user time, %s system time, %s rss, %s vsz\n",
      ***                    0                        
4701                                                           micro_t( $user,   p_s => 1, p_ms => 1 ),
4702                                                           micro_t( $system, p_s => 1, p_ms => 1 ),
4703                                                           shorten( ($rss || 0) * 1_024 ),
4704                                                           shorten( ($vsz || 0) * 1_024 );
4705                                                     };
4706  ***      0      0                           0      if ( $EVAL_ERROR ) {
4707  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
4708                                                     }
4709  ***      0                                  0      return $result;
4710                                                  }
4711                                                  
4712                                                  sub global_report {
4713           7                    7            64      my ( $self, $ea, %opts ) = @_;
4714           7                                 50      my $stats = $ea->results;
4715           7                                 23      my @result;
4716                                                  
4717  ***      7            50                   52      my $global_cnt = $stats->{globals}->{$opts{worst}}->{cnt} || 0;
4718                                                  
4719           7                                 27      my ($qps, $conc) = (0, 0);
4720  ***      7    100     33                  206      if ( $global_cnt && $stats->{globals}->{ts}
      ***                   50                        
      ***                   50                        
      ***                   66                        
4721                                                        && ($stats->{globals}->{ts}->{max} || '')
4722                                                           gt ($stats->{globals}->{ts}->{min} || '')
4723                                                     ) {
4724           6                                 18         eval {
4725           6                                 59            my $min  = parse_timestamp($stats->{globals}->{ts}->{min});
4726           6                                 41            my $max  = parse_timestamp($stats->{globals}->{ts}->{max});
4727           6                                 48            my $diff = unix_timestamp($max) - unix_timestamp($min);
4728           5                                 25            $qps     = $global_cnt / $diff;
4729           5                                 34            $conc    = $stats->{globals}->{$opts{worst}}->{sum} / $diff;
4730                                                        };
4731                                                     }
4732                                                  
4733                                                     MKDEBUG && _d('global_cnt:', $global_cnt, 'unique:',
4734           7                                 22         scalar keys %{$stats->{classes}}, 'qps:', $qps, 'conc:', $conc);
4735           7                                 51      my $line = sprintf(
4736                                                        '# Overall: %s total, %s unique, %s QPS, %sx concurrency ',
4737                                                        shorten($global_cnt, d=>1_000),
4738           7           100                   73         shorten(scalar keys %{$stats->{classes}}, d=>1_000),
                           100                        
4739                                                        shorten($qps  || 0, d=>1_000),
4740                                                        shorten($conc || 0, d=>1_000));
4741           7                                 54      $line .= ('_' x (LINE_LENGTH - length($line) + $self->{label_width} - 9));
4742           7                                 33      push @result, $line;
4743                                                  
4744           7                                 65      my ($format, @headers) = $self->make_header('global');
4745           7                                 57      push @result, sprintf($format, '', @headers);
4746                                                  
4747           7                                 27      foreach my $attrib ( sort_attribs($ea, @{$opts{select}}) ) {
               7                                 66   
4748          75                                298         my $attrib_type = $ea->type_for($attrib);
4749  ***     75     50                         285         next unless $attrib_type; 
4750  ***     75     50                         338         next unless exists $stats->{globals}->{$attrib};
4751          75    100                         283         if ( $formatting_function{$attrib} ) { # Handle special cases
4752          70                                236            push @result, sprintf $format, $self->make_label($attrib),
4753                                                              $formatting_function{$attrib}->($stats->{globals}->{$attrib}),
4754           7                                 31               (map { '' } 0..9); # just for good measure
4755                                                        }
4756                                                        else {
4757          68                                258            my $store = $stats->{globals}->{$attrib};
4758          68                                156            my @values;
4759          68    100                         294            if ( $attrib_type eq 'num' ) {
                    100                               
      ***            50                               
4760          48    100                         235               my $func = $attrib =~ m/time$/ ? \&micro_t : \&shorten;
4761          48                                114               MKDEBUG && _d('Calculating global statistical_metrics for', $attrib);
4762          48                                255               my $metrics = $ea->calculate_statistical_metrics($store->{all}, $store);
4763          48                                288               @values = (
4764          48                                334                  @{$store}{qw(sum min max)},
4765                                                                 $store->{sum} / $store->{cnt},
4766          48                                181                  @{$metrics}{qw(pct_95 stddev median)},
4767                                                              );
4768  ***     48     50                         188               @values = map { defined $_ ? $func->($_) : '' } @values;
             336                               1435   
4769                                                           }
4770                                                           elsif ( $attrib_type eq 'string' ) {
4771           9                                 24               MKDEBUG && _d('Ignoring string attrib', $attrib);
4772           9                                 38               next;
4773                                                           }
4774                                                           elsif ( $attrib_type eq 'bool' ) {
4775  ***     11    100     66                  110               if ( $store->{sum} > 0 || !$opts{no_zero_bool} ) {
4776           1                                  6                  push @result,
4777                                                                    sprintf $bool_format, format_bool_attrib($store), $attrib;
4778                                                              }
4779                                                           }
4780                                                           else {
4781  ***      0                                  0               @values = ('', $store->{min}, $store->{max}, '', '', '', '');
4782                                                           }
4783                                                  
4784          59    100                         432            push @result, sprintf $format, $self->make_label($attrib), @values
4785                                                              unless $attrib_type eq 'bool';  # bool does its own thing.
4786                                                        }
4787                                                     }
4788                                                  
4789           7                                 53      return join("\n", map { s/\s+$//; $_ } @result) . "\n";
              70                                352   
              70                                370   
4790                                                  }
4791                                                  
4792                                                  sub event_report {
4793         106                  106          1223      my ( $self, $ea, %opts ) = @_;
4794         106                                605      my $stats = $ea->results;
4795         106                                315      my @result;
4796                                                  
4797         106                                538      my $store = $stats->{classes}->{$opts{where}};
4798  ***    106     50                         466      return "# No such event $opts{where}\n" unless $store;
4799         106                                543      my $sample = $stats->{samples}->{$opts{where}};
4800                                                  
4801         106                                576      my $global_cnt = $stats->{globals}->{$opts{worst}}->{cnt};
4802         106                                521      my $class_cnt  = $store->{$opts{worst}}->{cnt};
4803                                                  
4804         106                                411      my ($qps, $conc) = (0, 0);
4805  ***    106    100     66                 2336      if ( $global_cnt && $store->{ts}
                           100                        
                           100                        
                           100                        
4806                                                        && ($store->{ts}->{max} || '')
4807                                                           gt ($store->{ts}->{min} || '')
4808                                                     ) {
4809          13                                 49         eval {
4810          13                                 91            my $min  = parse_timestamp($store->{ts}->{min});
4811          13                                 81            my $max  = parse_timestamp($store->{ts}->{max});
4812          13                                 79            my $diff = unix_timestamp($max) - unix_timestamp($min);
4813          10                                 37            $qps     = $class_cnt / $diff;
4814          10                                 60            $conc    = $store->{$opts{worst}}->{sum} / $diff;
4815                                                        };
4816                                                     }
4817                                                  
4818  ***    106    100     50                 1864      my $line = sprintf(
                           100                        
                           100                        
                           100                        
4819                                                        '# %s %d: %s QPS, %sx concurrency, ID 0x%s at byte %d ',
4820                                                        ($ea->{groupby} eq 'fingerprint' ? 'Query' : 'Item'),
4821                                                        $opts{rank} || 0,
4822                                                        shorten($qps  || 0, d=>1_000),
4823                                                        shorten($conc || 0, d=>1_000),
4824                                                        make_checksum($opts{where}),
4825                                                        $sample->{pos_in_log} || 0);
4826         106                                711      $line .= ('_' x (LINE_LENGTH - length($line) + $self->{label_width} - 9));
4827         106                                465      push @result, $line;
4828                                                  
4829         106    100                         520      if ( $opts{reason} ) {
4830  ***     74     50                         558         push @result, "# This item is included in the report because it matches "
4831                                                           . ($opts{reason} eq 'top' ? '--limit.' : '--outliers.');
4832                                                     }
4833                                                  
4834         106                                687      my ($format, @headers) = $self->make_header();
4835         106                                830      push @result, sprintf($format, '', @headers);
4836                                                  
4837         954                               3114      push @result, sprintf
4838                                                        $format, 'Count', percentage_of($class_cnt, $global_cnt), $class_cnt,
4839         106                                722            map { '' } (1 ..9);
4840                                                  
4841         106                                428      foreach my $attrib ( sort_attribs($ea, @{$opts{select}}) ) {
             106                                742   
4842        1377                               5137         my $attrib_type = $ea->type_for($attrib);
4843        1377    100                        5074         next unless $attrib_type; 
4844        1317    100                        5381         next unless exists $store->{$attrib};
4845        1198                               3821         my $vals = $store->{$attrib};
4846        1198    100                        5746         next unless scalar %$vals;
4847        1194    100                        4717         if ( $formatting_function{$attrib} ) { # Handle special cases
4848         950                               3159            push @result, sprintf $format, $self->make_label($attrib),
4849                                                              $formatting_function{$attrib}->($vals),
4850          95                                450               (map { '' } 0..9); # just for good measure
4851                                                        }
4852                                                        else {
4853        1099                               2686            my @values;
4854        1099                               2523            my $pct;
4855        1099    100                        4733            if ( $attrib_type eq 'num' ) {
                    100                               
      ***            50                               
4856         598    100                        3115               my $func = $attrib =~ m/time$/ ? \&micro_t : \&shorten;
4857         598                               3063               my $metrics = $ea->calculate_statistical_metrics($vals->{all}, $vals);
4858         598                               3687               @values = (
4859         598                               3876                  @{$vals}{qw(sum min max)},
4860                                                                 $vals->{sum} / $vals->{cnt},
4861         598                               2068                  @{$metrics}{qw(pct_95 stddev median)},
4862                                                              );
4863  ***    598     50                        2280               @values = map { defined $_ ? $func->($_) : '' } @values;
            4186                              17990   
4864         598                               4516               $pct = percentage_of($vals->{sum},
4865                                                                 $stats->{globals}->{$attrib}->{sum});
4866                                                           }
4867                                                           elsif ( $attrib_type eq 'string' ) {
4868        2520                               7335               push @values,
4869                                                                 format_string_list($vals),
4870         252                               1120                  (map { '' } 0..9); # just for good measure
4871         252                                870               $pct = '';
4872                                                           }
4873                                                           elsif ( $attrib_type eq 'bool' ) {
4874  ***    249    100     66                 2346               if ( $vals->{sum} > 0 || !$opts{no_zero_bool} ) {
4875          17                                 90                  push @result,
4876                                                                    sprintf $bool_format, format_bool_attrib($vals), $attrib;
4877                                                              }
4878                                                           }
4879                                                           else {
4880  ***      0                                  0               @values = ('', $vals->{min}, $vals->{max}, '', '', '', '');
4881  ***      0                                  0               $pct = 0;
4882                                                           }
4883                                                  
4884        1099    100                        6534            push @result, sprintf $format, $self->make_label($attrib), $pct, @values
4885                                                              unless $attrib_type eq 'bool';  # bool does its own thing.
4886                                                        }
4887                                                     }
4888                                                  
4889         106                                616      return join("\n", map { s/\s+$//; $_ } @result) . "\n";
            1354                               6431   
            1354                               5789   
4890                                                  }
4891                                                  
4892                                                  sub chart_distro {
4893         106                  106           825      my ( $self, $ea, %opts ) = @_;
4894         106                                520      my $stats = $ea->results;
4895         106                                666      my $store = $stats->{classes}->{$opts{where}}->{$opts{attribute}};
4896         106                                376      my $vals  = $store->{all};
4897  ***    106     50     50                 1097      return "" unless defined $vals && scalar @$vals;
4898         106                                589      my @buck_tens = $ea->buckets_of(10);
4899         106                               4969      my @distro = map { 0 } (0 .. 7);
             848                               2511   
4900         106                               4751      map { $distro[$buck_tens[$_]] += $vals->[$_] } (1 .. @$vals - 1);
          105894                             402053   
4901                                                  
4902         106                               4919      my $max_val = 0;
4903         106                                286      my $vals_per_mark; # number of vals represented by 1 #-mark
4904         106                                301      my $max_disp_width = 64;
4905         106                                365      my $bar_fmt = "# %5s%s";
4906         106                                810      my @distro_labels = qw(1us 10us 100us 1ms 10ms 100ms 1s 10s+);
4907         106                                663      my @results = "# $opts{attribute} distribution";
4908                                                  
4909         106                                501      foreach my $n_vals ( @distro ) {
4910         848    100                        3590         $max_val = $n_vals if $n_vals > $max_val;
4911                                                     }
4912         106                                496      $vals_per_mark = $max_val / $max_disp_width;
4913                                                  
4914         106                                823      foreach my $i ( 0 .. $#distro ) {
4915         848                               2508         my $n_vals = $distro[$i];
4916         848           100                 3833         my $n_marks = $n_vals / ($vals_per_mark || 1);
4917  ***    848     50     66                 6457         $n_marks = 1 if $n_marks < 1 && $n_vals > 0;
4918         848    100                        3575         my $bar = ($n_marks ? '  ' : '') . '#' x $n_marks;
4919         848                               4334         push @results, sprintf $bar_fmt, $distro_labels[$i], $bar;
4920                                                     }
4921                                                  
4922         106                               3524      return join("\n", @results) . "\n";
4923                                                  }
4924                                                  
4925                                                  sub make_header {
4926         113                  113           518      my ( $self, $global ) = @_;
4927         113                                686      my $format = "# %-$self->{label_width}s %6s %7s %7s %7s %7s %7s %7s %7s";
4928         113                                673      my @headers = qw(pct total min max avg 95% stddev median);
4929         113    100                         506      if ( $global ) {
4930           7                                 86         $format =~ s/%(\d+)s/' ' x $1/e;
               7                                 56   
4931           7                                 21         shift @headers;
4932                                                     }
4933         113                               1124      return $format, @headers;
4934                                                  }
4935                                                  
4936                                                  sub make_label {
4937        1000                 1000          3948      my ( $self, $val ) = @_;
4938                                                  
4939        1000    100                        4348      if ( $val =~ m/^InnoDB/ ) {
4940          84                                666         $val =~ s/^InnoDB_(\w+)/IDB_$1/;
4941          84                                420         $val =~ s/r_(\w+)/r$1/;
4942                                                     }
4943                                                  
4944                                                     return  $val eq 'ts'         ? 'Time range'
4945                                                           : $val eq 'user'       ? 'Users'
4946                                                           : $val eq 'db'         ? 'Databases'
4947                                                           : $val eq 'Query_time' ? 'Exec time'
4948                                                           : $val eq 'host'       ? 'Hosts'
4949                                                           : $val eq 'Error_no'   ? 'Errors'
4950        1000    100                        9802            : do { $val =~ s/_/ /g; $val = substr($val, 0, $self->{label_width}); $val };
             547    100                        2550   
             547    100                        2407   
             547    100                        4419   
                    100                               
                    100                               
4951                                                  }
4952                                                  
4953                                                  sub format_bool_attrib {
4954          18                   18            66      my ( $stats ) = @_;
4955          18                                 97      my $p_true  = percentage_of($stats->{sum},  $stats->{cnt});
4956  ***     18            50                  118      my $n_true = '(' . shorten($stats->{sum} || 0, d=>1_000, p=>0) . ')';
4957          18                                109      return $p_true, $n_true;
4958                                                  }
4959                                                  
4960                                                  sub format_string_list {
4961         252                  252           904      my ( $stats ) = @_;
4962  ***    252     50                        1088      if ( exists $stats->{unq} ) {
4963         252                                820         my $cnt_for = $stats->{unq};
4964         252    100                        1418         if ( 1 == keys %$cnt_for ) {
4965         244                               1059            my ($str) = keys %$cnt_for;
4966  ***    244     50                        1049            $str = substr($str, 0, LINE_LENGTH - 30) . '...'
4967                                                              if length $str > LINE_LENGTH - 30;
4968         244                               1190            return (1, $str);
4969                                                        }
4970           8                                 41         my $line = '';
4971           8    100                          20         my @top = sort { $cnt_for->{$b} <=> $cnt_for->{$a} || $a cmp $b }
              19                                161   
4972                                                                       keys %$cnt_for;
4973           8                                 54         my $i = 0;
4974           8                                 47         foreach my $str ( @top ) {
4975          21                                 53            my $print_str;
4976          21    100                          90            if ( length $str > MAX_STRING_LENGTH ) {
4977           1                                  4               $print_str = substr($str, 0, MAX_STRING_LENGTH) . '...';
4978                                                           }
4979                                                           else {
4980          20                                 62               $print_str = $str;
4981                                                           }
4982  ***     21     50                          96            last if (length $line) + (length $print_str)  > LINE_LENGTH - 27;
4983          21                                105            $line .= "$print_str ($cnt_for->{$str}), ";
4984          21                                 69            $i++;
4985                                                        }
4986           8                                 69         $line =~ s/, $//;
4987  ***      8     50                          42         if ( $i < @top ) {
4988  ***      0                                  0            $line .= "... " . (@top - $i) . " more";
4989                                                        }
4990           8                                 49         return (scalar keys %$cnt_for, $line);
4991                                                     }
4992                                                     else {
4993  ***      0                                  0         return ($stats->{cnt});
4994                                                     }
4995                                                  }
4996                                                  
4997                                                  sub sort_attribs {
4998         113                  113          1123      my ( $ea, @attribs ) = @_;
4999         113                               1144      my %basic_attrib = (
5000                                                        Query_time    => 0,
5001                                                        Lock_time     => 1,
5002                                                        Rows_sent     => 2,
5003                                                        Rows_examined => 3,
5004                                                        user          => 4,
5005                                                        host          => 5,
5006                                                        db            => 6,
5007                                                        ts            => 7,
5008                                                     );
5009         113                                389      my @basic_attribs;
5010         113                                341      my @non_bool_attribs;
5011         113                                295      my @bool_attribs;
5012                                                  
5013                                                     ATTRIB:
5014         113                                580      foreach my $attrib ( @attribs ) {
5015        1452    100                        5095         if ( exists $basic_attrib{$attrib} ) {
5016         714                               2509            push @basic_attribs, $attrib;
5017                                                        }
5018                                                        else {
5019  ***    738    100     50                 2682            if ( ($ea->type_for($attrib) || '') ne 'bool' ) {
5020         471                               1929               push @non_bool_attribs, $attrib;
5021                                                           }
5022                                                           else {
5023         267                               1005               push @bool_attribs, $attrib;
5024                                                           }
5025                                                        }
5026                                                     }
5027                                                  
5028         113                                319      @non_bool_attribs = sort { uc $a cmp uc $b } @non_bool_attribs;
             745                               2226   
5029         113                                363      @bool_attribs     = sort { uc $a cmp uc $b } @bool_attribs;
             397                               1168   
5030        1141                               3671      @basic_attribs    = sort {
5031         113                                212            $basic_attrib{$a} <=> $basic_attrib{$b} } @basic_attribs;
5032                                                  
5033         113                               1360      return @basic_attribs, @non_bool_attribs, @bool_attribs;
5034                                                  }
5035                                                  
5036                                                  sub _d {
5037  ***      0                    0             0      my ($package, undef, $line) = caller 0;
5038  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
5039  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
5040                                                          @_;
5041  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
5042                                                  }
5043                                                  
5044                                                  1;
5045                                                  
5046                                                  # ###########################################################################
5047                                                  # End QueryReportFormatter package
5048                                                  # ###########################################################################
5049                                                  
5050                                                  # ###########################################################################
5051                                                  # EventTimeline package 5266
5052                                                  # ###########################################################################
5053                                                  
5054                                                  
5055                                                  package EventTimeline;
5056                                                  
5057                                                  
5058           7                    7            66   use strict;
               7                                 18   
               7                                 43   
5059           7                    7            49   use warnings FATAL => 'all';
               7                                 18   
               7                                 39   
5060           7                    7            42   use English qw(-no_match_vars);
               7                                 16   
               7                                 38   
5061                                                  Transformers->import(qw(parse_timestamp secs_to_time unix_timestamp));
5062                                                  
5063  ***      7            50      7            47   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 20   
               7                                 94   
5064           7                    7            41   use constant KEY     => 0;
               7                                 18   
               7                                 36   
5065           7                    7            63   use constant CNT     => 1;
               7                                 20   
               7                                 32   
5066           7                    7            48   use constant ATT     => 2;
               7                                 16   
               7                                 36   
5067                                                  
5068                                                  sub new {
5069           1                    1             9      my ( $class, %args ) = @_;
5070           1                                  5      foreach my $arg ( qw(groupby attributes) ) {
5071  ***      2     50                          15         die "I need a $arg argument" unless $args{$arg};
5072                                                     }
5073                                                  
5074           1                                  4      my %is_groupby = map { $_ => 1 } @{$args{groupby}};
               1                                  8   
               1                                  5   
5075                                                  
5076           2                                 35      return bless {
5077                                                        groupby    => $args{groupby},
5078           1                                  5         attributes => [ grep { !$is_groupby{$_} } @{$args{attributes}} ],
               1                                  4   
5079                                                        results    => [],
5080                                                     }, $class;
5081                                                  }
5082                                                  
5083                                                  sub reset_aggregated_data {
5084           1                    1             7      my ( $self ) = @_;
5085           1                                  8      $self->{results} = [];
5086                                                  }
5087                                                  
5088                                                  sub aggregate {
5089           8                    8            34      my ( $self, $event ) = @_;
5090           8                                 36      my $handler = $self->{handler};
5091           8    100                          53      if ( !$handler ) {
5092           1                                 10         $handler = $self->make_handler($event);
5093           1                                  5         $self->{handler} = $handler;
5094                                                     }
5095  ***      8     50                          36      return unless $handler;
5096           8                                 44      $handler->($event);
5097                                                  }
5098                                                  
5099                                                  sub results {
5100           1                    1             4      my ( $self ) = @_;
5101           1                                 27      return $self->{results};
5102                                                  }
5103                                                  
5104                                                  sub make_handler {
5105           1                    1             4      my ( $self, $event ) = @_;
5106                                                  
5107           1                                 16      my $float_re = qr{[+-]?(?:(?=\d|[.])\d*(?:[.])\d{0,})?(?:[E](?:[+-]?\d+)|)}i;
5108           1                                  3      my @lines; # lines of code for the subroutine
5109                                                  
5110           1                                  4      foreach my $attrib ( @{$self->{attributes}} ) {
               1                                  6   
5111           2                                 10         my ($val) = $event->{$attrib};
5112  ***      2     50                           9         next unless defined $val; # Can't decide type if it's undef.
5113                                                  
5114  ***      2     50                         168         my $type = $val  =~ m/^(?:\d+|$float_re)$/o ? 'num'
                    100                               
5115                                                                 : $val  =~ m/^(?:Yes|No)$/         ? 'bool'
5116                                                                 :                                    'string';
5117           2                                  5         MKDEBUG && _d('Type for', $attrib, 'is', $type, '(sample:', $val, ')');
5118           2                                 10         $self->{type_for}->{$attrib} = $type;
5119                                                  
5120           2                                 16         push @lines, (
5121                                                           "\$val = \$event->{$attrib};",
5122                                                           'defined $val && do {',
5123                                                           "# type: $type",
5124                                                           "\$store = \$last->[ATT]->{$attrib} ||= {};",
5125                                                        );
5126                                                  
5127  ***      2     50                          10         if ( $type eq 'bool' ) {
5128  ***      0                                  0            push @lines, q{$val = $val eq 'Yes' ? 1 : 0;};
5129  ***      0                                  0            $type = 'num';
5130                                                        }
5131           2    100                           9         my $op   = $type eq 'num' ? '<' : 'lt';
5132           2                                  8         push @lines, (
5133                                                           '$store->{min} = $val if !defined $store->{min} || $val '
5134                                                              . $op . ' $store->{min};',
5135                                                        );
5136           2    100                           9         $op = ($type eq 'num') ? '>' : 'gt';
5137           2                                  7         push @lines, (
5138                                                           '$store->{max} = $val if !defined $store->{max} || $val '
5139                                                              . $op . ' $store->{max};',
5140                                                        );
5141           2    100                           9         if ( $type eq 'num' ) {
5142           1                                  9            push @lines, '$store->{sum} += $val;';
5143                                                        }
5144           2                                 10         push @lines, '};';
5145                                                     }
5146                                                  
5147           1                                 22      unshift @lines, (
5148                                                        'sub {',
5149                                                        'my ( $event ) = @_;',
5150                                                        'my ($val, $last, $store);', # NOTE: define all variables here
5151                                                        '$last = $results->[-1];',
5152                                                        'if ( !$last || '
5153                                                           . join(' || ',
5154           1                                  9               map { "\$last->[KEY]->[$_] ne (\$event->{$self->{groupby}->[$_]} || 0)" }
5155           1                                 11                   (0 .. @{$self->{groupby}} -1))
5156                                                           . ' ) {',
5157                                                        '  $last = [['
5158                                                           . join(', ',
5159           1                                  6               map { "(\$event->{$self->{groupby}->[$_]} || 0)" }
5160           1                                  6                   (0 .. @{$self->{groupby}} -1))
5161                                                           . '], 0, {} ];',
5162                                                        '  push @$results, $last;',
5163                                                        '}',
5164                                                        '++$last->[CNT];',
5165                                                     );
5166           1                                  4      push @lines, '}';
5167           1                                  4      my $results = $self->{results}; # Referred to by the eval
5168           1                                 14      my $code = join("\n", @lines);
5169           1                                 10      $self->{code} = $code;
5170                                                  
5171           1                                  8      MKDEBUG && _d('Timeline handler:', $code);
5172           1                                  4      my $sub = eval $code;
5173  ***      1     50                           7      die if $EVAL_ERROR;
5174           1                                 13      return $sub;
5175                                                  }
5176                                                  
5177                                                  sub report {
5178           1                    1             8      my ( $self, $results, $callback ) = @_;
5179           1                                  9      $callback->("# " . ('#' x 72) . "\n");
5180           1                                  4      $callback->("# " . join(',', @{$self->{groupby}}) . " report\n");
               1                                  8   
5181           1                                  6      $callback->("# " . ('#' x 72) . "\n");
5182           1                                  7      foreach my $res ( @$results ) {
5183           8                                 18         my $t;
5184           8                                 17         my @vals;
5185  ***      8     50     33                   84         if ( ($t = $res->[ATT]->{ts}) && $t->{min} ) {
5186           8                                 36            my $min = parse_timestamp($t->{min});
5187           8                                 31            push @vals, $min;
5188  ***      8     50     33                   77            if ( $t->{max} && $t->{max} gt $t->{min} ) {
5189  ***      0                                  0               my $max  = parse_timestamp($t->{max});
5190  ***      0                                  0               my $diff = secs_to_time(unix_timestamp($max) - unix_timestamp($min));
5191  ***      0                                  0               push @vals, $diff;
5192                                                           }
5193                                                           else {
5194           8                                 26               push @vals, '0:00';
5195                                                           }
5196                                                        }
5197                                                        else {
5198  ***      0                                  0            push @vals, ('', '');
5199                                                        }
5200           8                                 52         $callback->(sprintf("# %19s %7s %3d %s\n", @vals, $res->[CNT], $res->[KEY]->[0]));
5201                                                     }
5202                                                  }
5203                                                  
5204                                                  sub _d {
5205  ***      0                    0             0      my ($package, undef, $line) = caller 0;
5206  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
5207  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
5208                                                          @_;
5209  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
5210                                                  }
5211                                                  
5212                                                  1;
5213                                                  
5214                                                  # ###########################################################################
5215                                                  # End EventTimeline package
5216                                                  # ###########################################################################
5217                                                  
5218                                                  # ###########################################################################
5219                                                  # QueryParser package 5783
5220                                                  # ###########################################################################
5221                                                  package QueryParser;
5222                                                  
5223           7                    7            57   use strict;
               7                                 21   
               7                                 38   
5224           7                    7            43   use warnings FATAL => 'all';
               7                                 17   
               7                                 37   
5225           7                    7            44   use English qw(-no_match_vars);
               7                                 19   
               7                                 38   
5226                                                  
5227  ***      7            50      7            51   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 20   
               7                                 93   
5228                                                  our $tbl_ident = qr/(?:`[^`]+`|\w+)(?:\.(?:`[^`]+`|\w+))?/;
5229                                                  our $tbl_regex = qr{
5230                                                           \b(?:FROM|JOIN|(?<!KEY\s)UPDATE|INTO) # Words that precede table names
5231                                                           \b\s*
5232                                                           \(?                                   # Optional paren around tables
5233                                                           ($tbl_ident
5234                                                              (?: (?:\s+ (?:AS\s+)? \w+)?, \s*$tbl_ident )*
5235                                                           )
5236                                                        }xio;
5237                                                  our $has_derived = qr{
5238                                                        \b(?:FROM|JOIN|,)
5239                                                        \s*\(\s*SELECT
5240                                                     }xi;
5241                                                  
5242                                                  our $data_def_stmts = qr/(?:CREATE|ALTER|TRUNCATE|DROP|RENAME)/i;
5243                                                  
5244                                                  our $data_manip_stmts = qr/(?:INSERT|UPDATE|DELETE|REPLACE)/i;
5245                                                  
5246                                                  sub new {
5247           7                    7            28      my ( $class ) = @_;
5248           7                                 69      bless {}, $class;
5249                                                  }
5250                                                  
5251                                                  sub get_tables {
5252         239                  239          1596      my ( $self, $query ) = @_;
5253  ***    239     50                         937      return unless $query;
5254         239                                567      MKDEBUG && _d('Getting tables for', $query);
5255                                                  
5256         239                               1940      my ( $ddl_stmt ) = $query =~ m/^\s*($data_def_stmts)\b/i;
5257         239    100                         934      if ( $ddl_stmt ) {
5258           4                                  9         MKDEBUG && _d('Special table type:', $ddl_stmt);
5259           4                                 13         $query =~ s/IF NOT EXISTS//i;
5260           4    100                          28         if ( $query =~ m/$ddl_stmt DATABASE\b/i ) {
5261           2                                  6            MKDEBUG && _d('Query alters a database, not a table');
5262           2                                 13            return ();
5263                                                        }
5264  ***      2     50     33                   36         if ( $ddl_stmt =~ m/CREATE/i && $query =~ m/$ddl_stmt\b.+?\bSELECT\b/i ) {
5265  ***      0                                  0            my ($select) = $query =~ m/\b(SELECT\b.+)/is;
5266  ***      0                                  0            MKDEBUG && _d('CREATE TABLE ... SELECT:', $select);
5267  ***      0                                  0            return $self->get_tables($select);
5268                                                        }
5269           2                                 40         my ($tbl) = $query =~ m/TABLE\s+($tbl_ident)(\s+.*)?/i;
5270           2                                  5         MKDEBUG && _d('Matches table:', $tbl);
5271           2                                  9         return ($tbl);
5272                                                     }
5273                                                  
5274         235                               8155      $query =~ s/ (?:LOW_PRIORITY|IGNORE|STRAIGHT_JOIN)//ig;
5275                                                  
5276         235    100                        1114      if ( $query =~ /^\s*LOCK TABLES/i ) {
5277           2                                  9         MKDEBUG && _d('Special table type: LOCK TABLES');
5278           2                                 16         $query =~ s/^(\s*LOCK TABLES\s+)//;
5279           2                                 20         $query =~ s/\s+(?:READ|WRITE|LOCAL)+\s*//g;
5280           2                                  6         MKDEBUG && _d('Locked tables:', $query);
5281           2                                 12         $query = "FROM $query";
5282                                                     }
5283                                                  
5284         235                               2460      $query =~ s/\\["']//g;                # quoted strings
5285         235                               2372      $query =~ s/".*?"/?/sg;               # quoted strings
5286         235                              19857      $query =~ s/'.*?'/?/sg;               # quoted strings
5287                                                  
5288         235                                621      my @tables;
5289         235                              43993      foreach my $tbls ( $query =~ m/$tbl_regex/gio ) {
5290         179                                474         MKDEBUG && _d('Match tables:', $tbls);
5291                                                  
5292         179    100                         777         next if $tbls =~ m/\ASELECT\b/i;
5293                                                  
5294         177                                879         foreach my $tbl ( split(',', $tbls) ) {
5295         183                               2215            $tbl =~ s/\s*($tbl_ident)(\s+.*)?/$1/gio;
5296                                                  
5297  ***    183     50                         957            if ( $tbl !~ m/[a-zA-Z]/ ) {
5298  ***      0                                  0               MKDEBUG && _d('Skipping suspicious table name:', $tbl);
5299  ***      0                                  0               next;
5300                                                           }
5301                                                  
5302         183                               1280            push @tables, $tbl;
5303                                                        }
5304                                                     }
5305         235                               1305      return @tables;
5306                                                  }
5307                                                  
5308                                                  sub has_derived_table {
5309           3                    3            12      my ( $self, $query ) = @_;
5310           3                                 33      my $match = $query =~ m/$has_derived/;
5311           3                                  9      MKDEBUG && _d($query, 'has ' . ($match ? 'a' : 'no') . ' derived table');
5312           3                                 22      return $match;
5313                                                  }
5314                                                  
5315                                                  sub get_aliases {
5316  ***      0                    0             0      my ( $self, $query, $list ) = @_;
5317  ***      0      0                           0      return unless $query;
5318  ***      0                                  0      my $aliases;
5319                                                  
5320  ***      0                                  0      $query =~ s/ (?:LOW_PRIORITY|IGNORE|STRAIGHT_JOIN)//ig;
5321                                                  
5322  ***      0                                  0      $query =~ s/ (?:INNER|OUTER|CROSS|LEFT|RIGHT|NATURAL)//ig;
5323                                                  
5324  ***      0                                  0      my ($tbl_refs, $from) = $query =~ m{
5325                                                        (
5326                                                           (FROM|INTO|UPDATE)\b\s*   # Keyword before table refs
5327                                                           .+?                       # Table refs
5328                                                        )
5329                                                        (?:\s+|\z)                   # If the query does not end with the table
5330                                                        (?:WHERE|ORDER|LIMIT|HAVING|SET|VALUES|\z) # Keyword after table refs
5331                                                     }ix;
5332                                                  
5333  ***      0      0                           0      if ( !$tbl_refs ) {
5334  ***      0                                  0         MKDEBUG && _d("No tables ref in", $query);
5335  ***      0      0                           0         return $list ? [] : {};
5336                                                     }
5337                                                  
5338  ***      0      0                           0      if ( $query =~ m/^(?:INSERT|REPLACE)/i ) {
5339  ***      0                                  0         $tbl_refs =~ s/\([^\)]+\)\s*//;
5340                                                     }
5341                                                  
5342  ***      0                                  0      MKDEBUG && _d('tbl refs:', $tbl_refs);
5343                                                  
5344  ***      0                                  0      my $before_tbl = qr/(?:,|JOIN|\s|$from)+/i;
5345                                                  
5346  ***      0                                  0      my $after_tbl  = qr/(?:,|JOIN|ON|USING|\z)/i;
5347                                                  
5348  ***      0                                  0      $tbl_refs =~ s/ = /=/g;
5349                                                  
5350  ***      0                                  0      while (
5351                                                        $tbl_refs =~ m{
5352                                                           $before_tbl\b\s*
5353                                                              ( ($tbl_ident) (?:\s+ (?:AS\s+)? (\w+))? )
5354                                                           \s*$after_tbl
5355                                                        }xgio )
5356                                                     {
5357  ***      0                                  0         my ( $tbl_ref, $db_tbl, $alias ) = ($1, $2, $3);
5358  ***      0                                  0         MKDEBUG && _d('Match table:', $tbl_ref);
5359                                                  
5360  ***      0      0                           0         if ( $tbl_ref =~ m/^AS\s+\w+/i ) {
5361  ***      0                                  0            MKDEBUG && _d('Subquery', $tbl_ref);
5362  ***      0      0                           0            $aliases->{$alias} = undef unless $list;
5363  ***      0                                  0            next;
5364                                                        }
5365                                                  
5366  ***      0      0                           0         if ( $list ) {
5367  ***      0                                  0            $tbl_ref =~ s/^\s+//g;
5368  ***      0                                  0            $tbl_ref =~ s/\s+$//g;
5369  ***      0                                  0            push @$aliases, $tbl_ref;
5370                                                        }
5371                                                        else {
5372  ***      0                                  0            my ( $db, $tbl ) = $db_tbl =~ m/^(?:(.*?)\.)?(.*)/;
5373  ***      0             0                    0            $aliases->{$alias || $tbl} = $tbl;
5374  ***      0      0                           0            $aliases->{DATABASE}->{$tbl} = $db if $db;
5375                                                        }
5376                                                     }
5377  ***      0                                  0      return $aliases;
5378                                                  }
5379                                                  
5380                                                  sub split {
5381           5                    5            24      my ( $self, $query ) = @_;
5382  ***      5     50                          20      return unless $query;
5383           5                                 23      $query = $self->clean_query($query);
5384           5                                 10      MKDEBUG && _d('Splitting', $query);
5385                                                  
5386           5                                 33      my $verbs = qr{SELECT|INSERT|UPDATE|DELETE|REPLACE|UNION|CREATE}i;
5387                                                  
5388           5                                 83      my @split_statements = grep { $_ } split(m/\b($verbs\b(?!(?:\s*\()))/io, $query);
              15                                 53   
5389                                                  
5390           5                                 15      my @statements;
5391  ***      5     50                          22      if ( @split_statements == 1 ) {
5392  ***      0                                  0         push @statements, $query;
5393                                                     }
5394                                                     else {
5395                                                        for ( my $i = 0; $i <= $#split_statements; $i += 2 ) {
5396           5                                 26            push @statements, $split_statements[$i].$split_statements[$i+1];
5397                                                  
5398  ***      5     50     33                   44            if ( $statements[-2] && $statements[-2] =~ m/on duplicate key\s+$/i ) {
5399  ***      0                                  0               $statements[-2] .= pop @statements;
5400                                                           }
5401           5                                 14         }
5402                                                     }
5403                                                  
5404           5                                 10      MKDEBUG && _d('statements:', map { $_ ? "<$_>" : 'none' } @statements);
5405           5                                 33      return @statements;
5406                                                  }
5407                                                  
5408                                                  sub clean_query {
5409           5                    5            19      my ( $self, $query ) = @_;
5410  ***      5     50                          21      return unless $query;
5411           5                                 16      $query =~ s!/\*.*?\*/! !g;  # Remove /* comment blocks */
5412           5                                 22      $query =~ s/^\s+//;         # Remove leading spaces
5413           5                                 23      $query =~ s/\s+$//;         # Remove trailing spaces
5414           5                                 20      $query =~ s/\s{2,}/ /g;     # Remove extra spaces
5415           5                                 20      return $query;
5416                                                  }
5417                                                  
5418                                                  sub split_subquery {
5419  ***      0                    0             0      my ( $self, $query ) = @_;
5420  ***      0      0                           0      return unless $query;
5421  ***      0                                  0      $query = $self->clean_query($query);
5422  ***      0                                  0      $query =~ s/;$//;
5423                                                  
5424  ***      0                                  0      my @subqueries;
5425  ***      0                                  0      my $sqno = 0;  # subquery number
5426  ***      0                                  0      my $pos  = 0;
5427  ***      0                                  0      while ( $query =~ m/(\S+)(?:\s+|\Z)/g ) {
5428  ***      0                                  0         $pos = pos($query);
5429  ***      0                                  0         my $word = $1;
5430  ***      0                                  0         MKDEBUG && _d($word, $sqno);
5431  ***      0      0                           0         if ( $word =~ m/^\(?SELECT\b/i ) {
5432  ***      0                                  0            my $start_pos = $pos - length($word) - 1;
5433  ***      0      0                           0            if ( $start_pos ) {
5434  ***      0                                  0               $sqno++;
5435  ***      0                                  0               MKDEBUG && _d('Subquery', $sqno, 'starts at', $start_pos);
5436  ***      0                                  0               $subqueries[$sqno] = {
5437                                                                 start_pos => $start_pos,
5438                                                                 end_pos   => 0,
5439                                                                 len       => 0,
5440                                                                 words     => [$word],
5441                                                                 lp        => 1, # left parentheses
5442                                                                 rp        => 0, # right parentheses
5443                                                                 done      => 0,
5444                                                              };
5445                                                           }
5446                                                           else {
5447  ***      0                                  0               MKDEBUG && _d('Main SELECT at pos 0');
5448                                                           }
5449                                                        }
5450                                                        else {
5451  ***      0      0                           0            next unless $sqno;  # next unless we're in a subquery
5452  ***      0                                  0            MKDEBUG && _d('In subquery', $sqno);
5453  ***      0                                  0            my $sq = $subqueries[$sqno];
5454  ***      0      0                           0            if ( $sq->{done} ) {
5455  ***      0                                  0               MKDEBUG && _d('This subquery is done; SQL is for',
5456                                                                 ($sqno - 1 ? "subquery $sqno" : "the main SELECT"));
5457  ***      0                                  0               next;
5458                                                           }
5459  ***      0                                  0            push @{$sq->{words}}, $word;
      ***      0                                  0   
5460  ***      0             0                    0            my $lp = ($word =~ tr/\(//) || 0;
5461  ***      0             0                    0            my $rp = ($word =~ tr/\)//) || 0;
5462  ***      0                                  0            MKDEBUG && _d('parentheses left', $lp, 'right', $rp);
5463  ***      0      0                           0            if ( ($sq->{lp} + $lp) - ($sq->{rp} + $rp) == 0 ) {
5464  ***      0                                  0               my $end_pos = $pos - 1;
5465  ***      0                                  0               MKDEBUG && _d('Subquery', $sqno, 'ends at', $end_pos);
5466  ***      0                                  0               $sq->{end_pos} = $end_pos;
5467  ***      0                                  0               $sq->{len}     = $end_pos - $sq->{start_pos};
5468                                                           }
5469                                                        }
5470                                                     }
5471                                                  
5472  ***      0                                  0      for my $i ( 1..$#subqueries ) {
5473  ***      0                                  0         my $sq = $subqueries[$i];
5474  ***      0      0                           0         next unless $sq;
5475  ***      0                                  0         $sq->{sql} = join(' ', @{$sq->{words}});
      ***      0                                  0   
5476  ***      0                                  0         substr $query,
5477                                                           $sq->{start_pos} + 1,  # +1 for (
5478                                                           $sq->{len} - 1,        # -1 for )
5479                                                           "__subquery_$i";
5480                                                     }
5481                                                  
5482  ***      0                                  0      return $query, map { $_->{sql} } grep { defined $_ } @subqueries;
      ***      0                                  0   
      ***      0                                  0   
5483                                                  }
5484                                                  
5485                                                  sub query_type {
5486           5                    5            22      my ( $self, $query, $qr ) = @_;
5487           5                                 22      my ($type, undef) = $qr->distill_verbs($query);
5488           5                                 17      my $rw;
5489  ***      5    100     33                   64      if ( $type =~ m/^SELECT\b/ ) {
      ***            50                               
5490           4                                 12         $rw = 'read';
5491                                                     }
5492                                                     elsif ( $type =~ m/^$data_manip_stmts\b/
5493                                                             || $type =~ m/^$data_def_stmts\b/  ) {
5494           1                                  4         $rw = 'write'
5495                                                     }
5496                                                  
5497                                                     return {
5498           5                                 35         type => $type,
5499                                                        rw   => $rw,
5500                                                     }
5501                                                  }
5502                                                  
5503                                                  sub get_columns {
5504  ***      0                    0             0      my ( $self, $query ) = @_;
5505  ***      0                                  0      my $cols = [];
5506  ***      0      0                           0      return $cols unless $query;
5507  ***      0                                  0      my $cols_def;
5508                                                  
5509  ***      0      0                           0      if ( $query =~ m/^SELECT/i ) {
      ***             0                               
5510  ***      0                                  0         $query =~ s/
5511                                                           ^SELECT\s+
5512                                                             (?:ALL
5513                                                                |DISTINCT
5514                                                                |DISTINCTROW
5515                                                                |HIGH_PRIORITY
5516                                                                |STRAIGHT_JOIN
5517                                                                |SQL_SMALL_RESULT
5518                                                                |SQL_BIG_RESULT
5519                                                                |SQL_BUFFER_RESULT
5520                                                                |SQL_CACHE
5521                                                                |SQL_NO_CACHE
5522                                                                |SQL_CALC_FOUND_ROWS
5523                                                             )\s+
5524                                                        /SELECT /xgi;
5525  ***      0                                  0         ($cols_def) = $query =~ m/^SELECT\s+(.+?)\s+FROM/i;
5526                                                     }
5527                                                     elsif ( $query =~ m/^(?:INSERT|REPLACE)/i ) {
5528  ***      0                                  0         ($cols_def) = $query =~ m/\(([^\)]+)\)\s*VALUE/i;
5529                                                     }
5530                                                  
5531  ***      0                                  0      MKDEBUG && _d('Columns:', $cols_def);
5532  ***      0      0                           0      if ( $cols_def ) {
5533  ***      0                                  0         @$cols = split(',', $cols_def);
5534  ***      0                                  0         map {
5535  ***      0                                  0            my $col = $_;
5536  ***      0                                  0            $col = s/^\s+//g;
5537  ***      0                                  0            $col = s/\s+$//g;
5538  ***      0                                  0            $col;
5539                                                        } @$cols;
5540                                                     }
5541                                                  
5542  ***      0                                  0      return $cols;
5543                                                  }
5544                                                  
5545                                                  sub parse {
5546  ***      0                    0             0      my ( $self, $query ) = @_;
5547  ***      0      0                           0      return unless $query;
5548  ***      0                                  0      my $parsed = {};
5549                                                  
5550  ***      0                                  0      $query =~ s/\n/ /g;
5551  ***      0                                  0      $query = $self->clean_query($query);
5552                                                  
5553  ***      0                                  0      $parsed->{query}   = [ $query ];
5554  ***      0                                  0      $parsed->{tables}  = $self->get_aliases($query, 1);
5555  ***      0                                  0      $parsed->{columns} = $self->get_columns($query);
5556                                                  
5557  ***      0                                  0      my ($dms) = $query =~ m/^(\w+)/;
5558  ***      0                                  0      $parsed->{dms} = [ lc $dms ],
5559                                                  
5560                                                  
5561                                                     return $parsed;
5562                                                  }
5563                                                  
5564                                                  sub _d {
5565  ***      0                    0             0      my ($package, undef, $line) = caller 0;
5566  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
5567  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
5568                                                          @_;
5569  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
5570                                                  }
5571                                                  
5572                                                  1;
5573                                                  
5574                                                  # ###########################################################################
5575                                                  # End QueryParser package
5576                                                  # ###########################################################################
5577                                                  
5578                                                  # ###########################################################################
5579                                                  # MySQLDump package 5266
5580                                                  # ###########################################################################
5581                                                  package MySQLDump;
5582                                                  
5583           7                    7            54   use strict;
               7                                 15   
               7                                 41   
5584           7                    7            44   use warnings FATAL => 'all';
               7                                 17   
               7                                 44   
5585                                                  
5586           7                    7            41   use English qw(-no_match_vars);
               7                                 18   
               7                                 34   
5587                                                  
5588  ***      7            50      7            45   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 18   
               7                                 90   
5589                                                  
5590                                                  ( our $before = <<'EOF') =~ s/^   //gm;
5591                                                     /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
5592                                                     /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
5593                                                     /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
5594                                                     /*!40101 SET NAMES utf8 */;
5595                                                     /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
5596                                                     /*!40103 SET TIME_ZONE='+00:00' */;
5597                                                     /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
5598                                                     /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
5599                                                     /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
5600                                                     /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
5601                                                  EOF
5602                                                  
5603                                                  ( our $after = <<'EOF') =~ s/^   //gm;
5604                                                     /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
5605                                                     /*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
5606                                                     /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
5607                                                     /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
5608                                                     /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
5609                                                     /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
5610                                                     /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
5611                                                     /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
5612                                                  EOF
5613                                                  
5614                                                  sub new {
5615  ***      0                    0             0      my ( $class, %args ) = @_;
5616  ***      0      0                           0      $args{cache} = 1 unless defined $args{cache};
5617  ***      0                                  0      my $self = bless \%args, $class;
5618  ***      0                                  0      return $self;
5619                                                  }
5620                                                  
5621                                                  sub dump {
5622  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl, $what ) = @_;
5623                                                  
5624  ***      0      0                           0      if ( $what eq 'table' ) {
      ***             0                               
      ***             0                               
5625  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
5626  ***      0      0                           0         return unless $ddl;
5627  ***      0      0                           0         if ( $ddl->[0] eq 'table' ) {
5628  ***      0                                  0            return $before
5629                                                              . 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
5630                                                              . $ddl->[1] . ";\n";
5631                                                        }
5632                                                        else {
5633  ***      0                                  0            return 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
5634                                                              . '/*!50001 DROP VIEW IF EXISTS '
5635                                                              . $quoter->quote($tbl) . "*/;\n/*!50001 "
5636                                                              . $self->get_tmp_table($dbh, $quoter, $db, $tbl) . "*/;\n";
5637                                                        }
5638                                                     }
5639                                                     elsif ( $what eq 'triggers' ) {
5640  ***      0                                  0         my $trgs = $self->get_triggers($dbh, $quoter, $db, $tbl);
5641  ***      0      0      0                    0         if ( $trgs && @$trgs ) {
5642  ***      0                                  0            my $result = $before . "\nDELIMITER ;;\n";
5643  ***      0                                  0            foreach my $trg ( @$trgs ) {
5644  ***      0      0                           0               if ( $trg->{sql_mode} ) {
5645  ***      0                                  0                  $result .= qq{/*!50003 SET SESSION SQL_MODE='$trg->{sql_mode}' */;;\n};
5646                                                              }
5647  ***      0                                  0               $result .= "/*!50003 CREATE */ ";
5648  ***      0      0                           0               if ( $trg->{definer} ) {
5649  ***      0                                  0                  my ( $user, $host )
5650  ***      0                                  0                     = map { s/'/''/g; "'$_'"; }
      ***      0                                  0   
5651                                                                      split('@', $trg->{definer}, 2);
5652  ***      0                                  0                  $result .= "/*!50017 DEFINER=$user\@$host */ ";
5653                                                              }
5654  ***      0                                  0               $result .= sprintf("/*!50003 TRIGGER %s %s %s ON %s\nFOR EACH ROW %s */;;\n\n",
5655                                                                 $quoter->quote($trg->{trigger}),
5656  ***      0                                  0                  @{$trg}{qw(timing event)},
5657                                                                 $quoter->quote($trg->{table}),
5658                                                                 $trg->{statement});
5659                                                           }
5660  ***      0                                  0            $result .= "DELIMITER ;\n\n/*!50003 SET SESSION SQL_MODE=\@OLD_SQL_MODE */;\n\n";
5661  ***      0                                  0            return $result;
5662                                                        }
5663                                                        else {
5664  ***      0                                  0            return undef;
5665                                                        }
5666                                                     }
5667                                                     elsif ( $what eq 'view' ) {
5668  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
5669  ***      0                                  0         return '/*!50001 DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
5670                                                           . '/*!50001 DROP VIEW IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
5671                                                           . '/*!50001 ' . $ddl->[1] . "*/;\n";
5672                                                     }
5673                                                     else {
5674  ***      0                                  0         die "You didn't say what to dump.";
5675                                                     }
5676                                                  }
5677                                                  
5678                                                  sub _use_db {
5679  ***      0                    0             0      my ( $self, $dbh, $quoter, $new ) = @_;
5680  ***      0      0                           0      if ( !$new ) {
5681  ***      0                                  0         MKDEBUG && _d('No new DB to use');
5682  ***      0                                  0         return;
5683                                                     }
5684  ***      0                                  0      my $sql = 'SELECT DATABASE()';
5685  ***      0                                  0      MKDEBUG && _d($sql);
5686  ***      0                                  0      my $curr = $dbh->selectrow_array($sql);
5687  ***      0      0      0                    0      if ( $curr && $new && $curr eq $new ) {
      ***                    0                        
5688  ***      0                                  0         MKDEBUG && _d('Current and new DB are the same');
5689  ***      0                                  0         return $curr;
5690                                                     }
5691  ***      0                                  0      $sql = 'USE ' . $quoter->quote($new);
5692  ***      0                                  0      MKDEBUG && _d($sql);
5693  ***      0                                  0      $dbh->do($sql);
5694  ***      0                                  0      return $curr;
5695                                                  }
5696                                                  
5697                                                  sub get_create_table {
5698  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
5699  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{tables}->{$db}->{$tbl} ) {
5700  ***      0                                  0         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
5701                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
5702                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
5703                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
5704  ***      0                                  0         MKDEBUG && _d($sql);
5705  ***      0                                  0         eval { $dbh->do($sql); };
      ***      0                                  0   
5706  ***      0                                  0         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
5707  ***      0                                  0         my $curr_db = $self->_use_db($dbh, $quoter, $db);
5708  ***      0                                  0         $sql = "SHOW CREATE TABLE " . $quoter->quote($db, $tbl);
5709  ***      0                                  0         MKDEBUG && _d($sql);
5710  ***      0                                  0         my $href;
5711  ***      0                                  0         eval { $href = $dbh->selectrow_hashref($sql); };
      ***      0                                  0   
5712  ***      0      0                           0         if ( $EVAL_ERROR ) {
5713  ***      0                                  0            warn "Failed to $sql.  The table may be damaged.\nError: $EVAL_ERROR";
5714  ***      0                                  0            return;
5715                                                        }
5716  ***      0                                  0         $self->_use_db($dbh, $quoter, $curr_db);
5717  ***      0                                  0         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
5718                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
5719  ***      0                                  0         MKDEBUG && _d($sql);
5720  ***      0                                  0         $dbh->do($sql);
5721  ***      0                                  0         my ($key) = grep { m/create table/i } keys %$href;
      ***      0                                  0   
5722  ***      0      0                           0         if ( $key ) {
5723  ***      0                                  0            MKDEBUG && _d('This table is a base table');
5724  ***      0                                  0            $self->{tables}->{$db}->{$tbl} = [ 'table', $href->{$key} ];
5725                                                        }
5726                                                        else {
5727  ***      0                                  0            MKDEBUG && _d('This table is a view');
5728  ***      0                                  0            ($key) = grep { m/create view/i } keys %$href;
      ***      0                                  0   
5729  ***      0                                  0            $self->{tables}->{$db}->{$tbl} = [ 'view', $href->{$key} ];
5730                                                        }
5731                                                     }
5732  ***      0                                  0      return $self->{tables}->{$db}->{$tbl};
5733                                                  }
5734                                                  
5735                                                  sub get_columns {
5736  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
5737  ***      0                                  0      MKDEBUG && _d('Get columns for', $db, $tbl);
5738  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{columns}->{$db}->{$tbl} ) {
5739  ***      0                                  0         my $curr_db = $self->_use_db($dbh, $quoter, $db);
5740  ***      0                                  0         my $sql = "SHOW COLUMNS FROM " . $quoter->quote($db, $tbl);
5741  ***      0                                  0         MKDEBUG && _d($sql);
5742  ***      0                                  0         my $cols = $dbh->selectall_arrayref($sql, { Slice => {} });
5743  ***      0                                  0         $self->_use_db($dbh, $quoter, $curr_db);
5744  ***      0                                  0         $self->{columns}->{$db}->{$tbl} = [
5745                                                           map {
5746  ***      0                                  0               my %row;
5747  ***      0                                  0               @row{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
5748  ***      0                                  0               \%row;
5749                                                           } @$cols
5750                                                        ];
5751                                                     }
5752  ***      0                                  0      return $self->{columns}->{$db}->{$tbl};
5753                                                  }
5754                                                  
5755                                                  sub get_tmp_table {
5756  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
5757  ***      0                                  0      my $result = 'CREATE TABLE ' . $quoter->quote($tbl) . " (\n";
5758  ***      0                                  0      $result .= join(",\n",
5759  ***      0                                  0         map { '  ' . $quoter->quote($_->{field}) . ' ' . $_->{type} }
5760  ***      0                                  0         @{$self->get_columns($dbh, $quoter, $db, $tbl)});
5761  ***      0                                  0      $result .= "\n)";
5762  ***      0                                  0      MKDEBUG && _d($result);
5763  ***      0                                  0      return $result;
5764                                                  }
5765                                                  
5766                                                  sub get_triggers {
5767  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
5768  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{triggers}->{$db} ) {
5769  ***      0                                  0         $self->{triggers}->{$db} = {};
5770  ***      0                                  0         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
5771                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
5772                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
5773                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
5774  ***      0                                  0         MKDEBUG && _d($sql);
5775  ***      0                                  0         eval { $dbh->do($sql); };
      ***      0                                  0   
5776  ***      0                                  0         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
5777  ***      0                                  0         $sql = "SHOW TRIGGERS FROM " . $quoter->quote($db);
5778  ***      0                                  0         MKDEBUG && _d($sql);
5779  ***      0                                  0         my $sth = $dbh->prepare($sql);
5780  ***      0                                  0         $sth->execute();
5781  ***      0      0                           0         if ( $sth->rows ) {
5782  ***      0                                  0            my $trgs = $sth->fetchall_arrayref({});
5783  ***      0                                  0            foreach my $trg (@$trgs) {
5784  ***      0                                  0               my %trg;
5785  ***      0                                  0               @trg{ map { lc $_ } keys %$trg } = values %$trg;
      ***      0                                  0   
5786  ***      0                                  0               push @{ $self->{triggers}->{$db}->{ $trg{table} } }, \%trg;
      ***      0                                  0   
5787                                                           }
5788                                                        }
5789  ***      0                                  0         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
5790                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
5791  ***      0                                  0         MKDEBUG && _d($sql);
5792  ***      0                                  0         $dbh->do($sql);
5793                                                     }
5794  ***      0      0                           0      if ( $tbl ) {
5795  ***      0                                  0         return $self->{triggers}->{$db}->{$tbl};
5796                                                     }
5797  ***      0                                  0      return values %{$self->{triggers}->{$db}};
      ***      0                                  0   
5798                                                  }
5799                                                  
5800                                                  sub get_databases {
5801  ***      0                    0             0      my ( $self, $dbh, $quoter, $like ) = @_;
5802  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{databases} || $like ) {
      ***                    0                        
5803  ***      0                                  0         my $sql = 'SHOW DATABASES';
5804  ***      0                                  0         my @params;
5805  ***      0      0                           0         if ( $like ) {
5806  ***      0                                  0            $sql .= ' LIKE ?';
5807  ***      0                                  0            push @params, $like;
5808                                                        }
5809  ***      0                                  0         my $sth = $dbh->prepare($sql);
5810  ***      0                                  0         MKDEBUG && _d($sql, @params);
5811  ***      0                                  0         $sth->execute( @params );
5812  ***      0                                  0         my @dbs = map { $_->[0] } @{$sth->fetchall_arrayref()};
      ***      0                                  0   
      ***      0                                  0   
5813  ***      0      0                           0         $self->{databases} = \@dbs unless $like;
5814  ***      0                                  0         return @dbs;
5815                                                     }
5816  ***      0                                  0      return @{$self->{databases}};
      ***      0                                  0   
5817                                                  }
5818                                                  
5819                                                  sub get_table_status {
5820  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
5821  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_status}->{$db} || $like ) {
      ***                    0                        
5822  ***      0                                  0         my $sql = "SHOW TABLE STATUS FROM " . $quoter->quote($db);
5823  ***      0                                  0         my @params;
5824  ***      0      0                           0         if ( $like ) {
5825  ***      0                                  0            $sql .= ' LIKE ?';
5826  ***      0                                  0            push @params, $like;
5827                                                        }
5828  ***      0                                  0         MKDEBUG && _d($sql, @params);
5829  ***      0                                  0         my $sth = $dbh->prepare($sql);
5830  ***      0                                  0         $sth->execute(@params);
5831  ***      0                                  0         my @tables = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
5832  ***      0                                  0         @tables = map {
5833  ***      0                                  0            my %tbl; # Make a copy with lowercased keys
5834  ***      0                                  0            @tbl{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
5835  ***      0             0                    0            $tbl{engine} ||= $tbl{type} || $tbl{comment};
      ***                    0                        
5836  ***      0                                  0            delete $tbl{type};
5837  ***      0                                  0            \%tbl;
5838                                                        } @tables;
5839  ***      0      0                           0         $self->{table_status}->{$db} = \@tables unless $like;
5840  ***      0                                  0         return @tables;
5841                                                     }
5842  ***      0                                  0      return @{$self->{table_status}->{$db}};
      ***      0                                  0   
5843                                                  }
5844                                                  
5845                                                  sub get_table_list {
5846  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
5847  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_list}->{$db} || $like ) {
      ***                    0                        
5848  ***      0                                  0         my $sql = "SHOW /*!50002 FULL*/ TABLES FROM " . $quoter->quote($db);
5849  ***      0                                  0         my @params;
5850  ***      0      0                           0         if ( $like ) {
5851  ***      0                                  0            $sql .= ' LIKE ?';
5852  ***      0                                  0            push @params, $like;
5853                                                        }
5854  ***      0                                  0         MKDEBUG && _d($sql, @params);
5855  ***      0                                  0         my $sth = $dbh->prepare($sql);
5856  ***      0                                  0         $sth->execute(@params);
5857  ***      0                                  0         my @tables = @{$sth->fetchall_arrayref()};
      ***      0                                  0   
5858  ***      0      0      0                    0         @tables = map {
5859  ***      0                                  0            my %tbl = (
5860                                                              name   => $_->[0],
5861                                                              engine => ($_->[1] || '') eq 'VIEW' ? 'VIEW' : '',
5862                                                           );
5863  ***      0                                  0            \%tbl;
5864                                                        } @tables;
5865  ***      0      0                           0         $self->{table_list}->{$db} = \@tables unless $like;
5866  ***      0                                  0         return @tables;
5867                                                     }
5868  ***      0                                  0      return @{$self->{table_list}->{$db}};
      ***      0                                  0   
5869                                                  }
5870                                                  
5871                                                  sub _d {
5872  ***      0                    0             0      my ($package, undef, $line) = caller 0;
5873  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
5874  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
5875                                                          @_;
5876  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
5877                                                  }
5878                                                  
5879                                                  1;
5880                                                  
5881                                                  # ###########################################################################
5882                                                  # End MySQLDump package
5883                                                  # ###########################################################################
5884                                                  
5885                                                  # ###########################################################################
5886                                                  # TableParser package 5693
5887                                                  # ###########################################################################
5888                                                  package TableParser;
5889                                                  
5890           7                    7            54   use strict;
               7                                 23   
               7                                 53   
5891           7                    7            44   use warnings FATAL => 'all';
               7                                 16   
               7                                 46   
5892           7                    7            44   use English qw(-no_match_vars);
               7                                 17   
               7                                 36   
5893           7                    7            49   use Data::Dumper;
               7                                 17   
               7                                 46   
5894                                                  $Data::Dumper::Indent    = 1;
5895                                                  $Data::Dumper::Sortkeys  = 1;
5896                                                  $Data::Dumper::Quotekeys = 0;
5897                                                  
5898  ***      7            50      7            53   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 16   
               7                                111   
5899                                                  
5900                                                  
5901                                                  sub new {
5902  ***      0                    0             0      my ( $class, %args ) = @_;
5903  ***      0                                  0      my @required_args = qw(Quoter);
5904  ***      0                                  0      foreach my $arg ( @required_args ) {
5905  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
5906                                                     }
5907  ***      0                                  0      my $self = { %args };
5908  ***      0                                  0      return bless $self, $class;
5909                                                  }
5910                                                  
5911                                                  
5912                                                  sub parse {
5913  ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
5914  ***      0      0                           0      return unless $ddl;
5915  ***      0      0                           0      if ( ref $ddl eq 'ARRAY' ) {
5916  ***      0      0                           0         if ( lc $ddl->[0] eq 'table' ) {
5917  ***      0                                  0            $ddl = $ddl->[1];
5918                                                        }
5919                                                        else {
5920                                                           return {
5921  ***      0                                  0               engine => 'VIEW',
5922                                                           };
5923                                                        }
5924                                                     }
5925                                                  
5926  ***      0      0                           0      if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
5927  ***      0                                  0         die "Cannot parse table definition; is ANSI quoting "
5928                                                           . "enabled or SQL_QUOTE_SHOW_CREATE disabled?";
5929                                                     }
5930                                                  
5931  ***      0                                  0      my ($name)     = $ddl =~ m/CREATE (?:TEMPORARY )?TABLE\s+(`.+?`)/;
5932  ***      0      0                           0      (undef, $name) = $self->{Quoter}->split_unquote($name) if $name;
5933                                                  
5934  ***      0                                  0      $ddl =~ s/(`[^`]+`)/\L$1/g;
5935                                                  
5936  ***      0                                  0      my $engine = $self->get_engine($ddl);
5937                                                  
5938  ***      0                                  0      my @defs   = $ddl =~ m/^(\s+`.*?),?$/gm;
5939  ***      0                                  0      my @cols   = map { $_ =~ m/`([^`]+)`/ } @defs;
      ***      0                                  0   
5940  ***      0                                  0      MKDEBUG && _d('Columns:', join(', ', @cols));
5941                                                  
5942  ***      0                                  0      my %def_for;
5943  ***      0                                  0      @def_for{@cols} = @defs;
5944                                                  
5945  ***      0                                  0      my (@nums, @null);
5946  ***      0                                  0      my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
5947  ***      0                                  0      foreach my $col ( @cols ) {
5948  ***      0                                  0         my $def = $def_for{$col};
5949  ***      0                                  0         my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
5950  ***      0      0                           0         die "Can't determine column type for $def" unless $type;
5951  ***      0                                  0         $type_for{$col} = $type;
5952  ***      0      0                           0         if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
5953  ***      0                                  0            push @nums, $col;
5954  ***      0                                  0            $is_numeric{$col} = 1;
5955                                                        }
5956  ***      0      0                           0         if ( $def !~ m/NOT NULL/ ) {
5957  ***      0                                  0            push @null, $col;
5958  ***      0                                  0            $is_nullable{$col} = 1;
5959                                                        }
5960  ***      0      0                           0         $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
5961                                                     }
5962                                                  
5963  ***      0                                  0      my ($keys, $clustered_key) = $self->get_keys($ddl, $opts, \%is_nullable);
5964                                                  
5965                                                     return {
5966  ***      0                                  0         name           => $name,
5967                                                        cols           => \@cols,
5968  ***      0                                  0         col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
5969  ***      0                                  0         is_col         => { map { $_ => 1 } @cols },
5970                                                        null_cols      => \@null,
5971                                                        is_nullable    => \%is_nullable,
5972                                                        is_autoinc     => \%is_autoinc,
5973                                                        clustered_key  => $clustered_key,
5974                                                        keys           => $keys,
5975                                                        defs           => \%def_for,
5976                                                        numeric_cols   => \@nums,
5977                                                        is_numeric     => \%is_numeric,
5978                                                        engine         => $engine,
5979                                                        type_for       => \%type_for,
5980                                                     };
5981                                                  }
5982                                                  
5983                                                  sub sort_indexes {
5984  ***      0                    0             0      my ( $self, $tbl ) = @_;
5985                                                  
5986                                                     my @indexes
5987  ***      0                                  0         = sort {
5988  ***      0                                  0            (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
5989                                                           || ( !$tbl->{keys}->{$a}->{is_unique} <=> !$tbl->{keys}->{$b}->{is_unique} )
5990                                                           || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
5991  ***      0      0      0                    0            || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      ***      0             0                    0   
5992                                                        }
5993                                                        grep {
5994  ***      0                                  0            $tbl->{keys}->{$_}->{type} eq 'BTREE'
5995                                                        }
5996  ***      0                                  0         sort keys %{$tbl->{keys}};
5997                                                  
5998  ***      0                                  0      MKDEBUG && _d('Indexes sorted best-first:', join(', ', @indexes));
5999  ***      0                                  0      return @indexes;
6000                                                  }
6001                                                  
6002                                                  sub find_best_index {
6003  ***      0                    0             0      my ( $self, $tbl, $index ) = @_;
6004  ***      0                                  0      my $best;
6005  ***      0      0                           0      if ( $index ) {
6006  ***      0                                  0         ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
      ***      0                                  0   
      ***      0                                  0   
6007                                                     }
6008  ***      0      0                           0      if ( !$best ) {
6009  ***      0      0                           0         if ( $index ) {
6010  ***      0                                  0            die "Index '$index' does not exist in table";
6011                                                        }
6012                                                        else {
6013  ***      0                                  0            ($best) = $self->sort_indexes($tbl);
6014                                                        }
6015                                                     }
6016  ***      0                                  0      MKDEBUG && _d('Best index found is', $best);
6017  ***      0                                  0      return $best;
6018                                                  }
6019                                                  
6020                                                  sub find_possible_keys {
6021  ***      0                    0             0      my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
6022  ***      0      0                           0      return () unless $where;
6023  ***      0                                  0      my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
6024                                                        . ' WHERE ' . $where;
6025  ***      0                                  0      MKDEBUG && _d($sql);
6026  ***      0                                  0      my $expl = $dbh->selectrow_hashref($sql);
6027  ***      0                                  0      $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
      ***      0                                  0   
6028  ***      0      0                           0      if ( $expl->{possible_keys} ) {
6029  ***      0                                  0         MKDEBUG && _d('possible_keys =', $expl->{possible_keys});
6030  ***      0                                  0         my @candidates = split(',', $expl->{possible_keys});
6031  ***      0                                  0         my %possible   = map { $_ => 1 } @candidates;
      ***      0                                  0   
6032  ***      0      0                           0         if ( $expl->{key} ) {
6033  ***      0                                  0            MKDEBUG && _d('MySQL chose', $expl->{key});
6034  ***      0                                  0            unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
      ***      0                                  0   
6035  ***      0                                  0            MKDEBUG && _d('Before deduping:', join(', ', @candidates));
6036  ***      0                                  0            my %seen;
6037  ***      0                                  0            @candidates = grep { !$seen{$_}++ } @candidates;
      ***      0                                  0   
6038                                                        }
6039  ***      0                                  0         MKDEBUG && _d('Final list:', join(', ', @candidates));
6040  ***      0                                  0         return @candidates;
6041                                                     }
6042                                                     else {
6043  ***      0                                  0         MKDEBUG && _d('No keys in possible_keys');
6044  ***      0                                  0         return ();
6045                                                     }
6046                                                  }
6047                                                  
6048                                                  sub check_table {
6049  ***      0                    0             0      my ( $self, %args ) = @_;
6050  ***      0                                  0      my @required_args = qw(dbh db tbl);
6051  ***      0                                  0      foreach my $arg ( @required_args ) {
6052  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
6053                                                     }
6054  ***      0                                  0      my ($dbh, $db, $tbl) = @args{@required_args};
6055  ***      0                                  0      my $q      = $self->{Quoter};
6056  ***      0                                  0      my $db_tbl = $q->quote($db, $tbl);
6057  ***      0                                  0      MKDEBUG && _d('Checking', $db_tbl);
6058                                                  
6059  ***      0                                  0      my $sql = "SHOW TABLES FROM " . $q->quote($db)
6060                                                             . ' LIKE ' . $q->literal_like($tbl);
6061  ***      0                                  0      MKDEBUG && _d($sql);
6062  ***      0                                  0      my $row;
6063  ***      0                                  0      eval {
6064  ***      0                                  0         $row = $dbh->selectrow_arrayref($sql);
6065                                                     };
6066  ***      0      0                           0      if ( $EVAL_ERROR ) {
6067  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
6068  ***      0                                  0         return 0;
6069                                                     }
6070  ***      0      0      0                    0      if ( !$row->[0] || $row->[0] ne $tbl ) {
6071  ***      0                                  0         MKDEBUG && _d('Table does not exist');
6072  ***      0                                  0         return 0;
6073                                                     }
6074                                                  
6075  ***      0                                  0      MKDEBUG && _d('Table exists; no privs to check');
6076  ***      0      0                           0      return 1 unless $args{all_privs};
6077                                                  
6078  ***      0                                  0      $sql = "SHOW FULL COLUMNS FROM $db_tbl";
6079  ***      0                                  0      MKDEBUG && _d($sql);
6080  ***      0                                  0      eval {
6081  ***      0                                  0         $row = $dbh->selectrow_hashref($sql);
6082                                                     };
6083  ***      0      0                           0      if ( $EVAL_ERROR ) {
6084  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
6085  ***      0                                  0         return 0;
6086                                                     }
6087  ***      0      0                           0      if ( !scalar keys %$row ) {
6088  ***      0                                  0         MKDEBUG && _d('Table has no columns:', Dumper($row));
6089  ***      0                                  0         return 0;
6090                                                     }
6091  ***      0             0                    0      my $privs = $row->{privileges} || $row->{Privileges};
6092                                                  
6093  ***      0                                  0      $sql = "DELETE FROM $db_tbl LIMIT 0";
6094  ***      0                                  0      MKDEBUG && _d($sql);
6095  ***      0                                  0      eval {
6096  ***      0                                  0         $dbh->do($sql);
6097                                                     };
6098  ***      0      0                           0      my $can_delete = $EVAL_ERROR ? 0 : 1;
6099                                                  
6100  ***      0                                  0      MKDEBUG && _d('User privs on', $db_tbl, ':', $privs,
6101                                                        ($can_delete ? 'delete' : ''));
6102                                                  
6103  ***      0      0      0                    0      if ( !($privs =~ m/select/ && $privs =~ m/insert/ && $privs =~ m/update/
      ***                    0                        
      ***                    0                        
6104                                                            && $can_delete) ) {
6105  ***      0                                  0         MKDEBUG && _d('User does not have all privs');
6106  ***      0                                  0         return 0;
6107                                                     }
6108                                                  
6109  ***      0                                  0      MKDEBUG && _d('User has all privs');
6110  ***      0                                  0      return 1;
6111                                                  }
6112                                                  
6113                                                  sub get_engine {
6114  ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
6115  ***      0                                  0      my ( $engine ) = $ddl =~ m/\).*?(?:ENGINE|TYPE)=(\w+)/;
6116  ***      0                                  0      MKDEBUG && _d('Storage engine:', $engine);
6117  ***      0             0                    0      return $engine || undef;
6118                                                  }
6119                                                  
6120                                                  sub get_keys {
6121  ***      0                    0             0      my ( $self, $ddl, $opts, $is_nullable ) = @_;
6122  ***      0                                  0      my $engine        = $self->get_engine($ddl);
6123  ***      0                                  0      my $keys          = {};
6124  ***      0                                  0      my $clustered_key = undef;
6125                                                  
6126                                                     KEY:
6127  ***      0                                  0      foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {
6128                                                  
6129  ***      0      0                           0         next KEY if $key =~ m/FOREIGN/;
6130                                                  
6131  ***      0                                  0         my $key_ddl = $key;
6132  ***      0                                  0         MKDEBUG && _d('Parsed key:', $key_ddl);
6133                                                  
6134  ***      0      0                           0         if ( $engine !~ m/MEMORY|HEAP/ ) {
6135  ***      0                                  0            $key =~ s/USING HASH/USING BTREE/;
6136                                                        }
6137                                                  
6138  ***      0                                  0         my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
6139  ***      0                                  0         my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
6140  ***      0             0                    0         $type = $type || $special || 'BTREE';
      ***                    0                        
6141  ***      0      0      0                    0         if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
      ***                    0                        
6142                                                           && $engine =~ m/HEAP|MEMORY/i )
6143                                                        {
6144  ***      0                                  0            $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
6145                                                        }
6146                                                  
6147  ***      0                                  0         my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
6148  ***      0      0                           0         my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
6149  ***      0                                  0         my @cols;
6150  ***      0                                  0         my @col_prefixes;
6151  ***      0                                  0         foreach my $col_def ( split(',', $cols) ) {
6152  ***      0                                  0            my ($name, $prefix) = $col_def =~ m/`([^`]+)`(?:\((\d+)\))?/;
6153  ***      0                                  0            push @cols, $name;
6154  ***      0                                  0            push @col_prefixes, $prefix;
6155                                                        }
6156  ***      0                                  0         $name =~ s/`//g;
6157                                                  
6158  ***      0                                  0         MKDEBUG && _d('Key', $name, 'cols:', join(', ', @cols));
6159                                                  
6160  ***      0                                  0         $keys->{$name} = {
6161                                                           name         => $name,
6162                                                           type         => $type,
6163                                                           colnames     => $cols,
6164                                                           cols         => \@cols,
6165                                                           col_prefixes => \@col_prefixes,
6166                                                           is_unique    => $unique,
6167  ***      0                                  0            is_nullable  => scalar(grep { $is_nullable->{$_} } @cols),
6168  ***      0                                  0            is_col       => { map { $_ => 1 } @cols },
6169                                                           ddl          => $key_ddl,
6170                                                        };
6171                                                  
6172  ***      0      0      0                    0         if ( $engine =~ m/InnoDB/i && !$clustered_key ) {
6173  ***      0                                  0            my $this_key = $keys->{$name};
6174  ***      0      0      0                    0            if ( $this_key->{name} eq 'PRIMARY' ) {
      ***             0                               
6175  ***      0                                  0               $clustered_key = 'PRIMARY';
6176                                                           }
6177                                                           elsif ( $this_key->{is_unique} && !$this_key->{is_nullable} ) {
6178  ***      0                                  0               $clustered_key = $this_key->{name};
6179                                                           }
6180  ***      0                                  0            MKDEBUG && $clustered_key && _d('This key is the clustered key');
6181                                                        }
6182                                                     }
6183                                                  
6184  ***      0                                  0      return $keys, $clustered_key;
6185                                                  }
6186                                                  
6187                                                  sub get_fks {
6188  ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
6189  ***      0                                  0      my $fks = {};
6190                                                  
6191  ***      0                                  0      foreach my $fk (
6192                                                        $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg )
6193                                                     {
6194  ***      0                                  0         my ( $name ) = $fk =~ m/CONSTRAINT `(.*?)`/;
6195  ***      0                                  0         my ( $cols ) = $fk =~ m/FOREIGN KEY \(([^\)]+)\)/;
6196  ***      0                                  0         my ( $parent, $parent_cols ) = $fk =~ m/REFERENCES (\S+) \(([^\)]+)\)/;
6197                                                  
6198  ***      0      0      0                    0         if ( $parent !~ m/\./ && $opts->{database} ) {
6199  ***      0                                  0            $parent = "`$opts->{database}`.$parent";
6200                                                        }
6201                                                  
6202  ***      0                                  0         $fks->{$name} = {
6203                                                           name           => $name,
6204                                                           colnames       => $cols,
6205  ***      0                                  0            cols           => [ map { s/[ `]+//g; $_; } split(',', $cols) ],
      ***      0                                  0   
6206                                                           parent_tbl     => $parent,
6207                                                           parent_colnames=> $parent_cols,
6208  ***      0                                  0            parent_cols    => [ map { s/[ `]+//g; $_; } split(',', $parent_cols) ],
      ***      0                                  0   
6209                                                           ddl            => $fk,
6210                                                        };
6211                                                     }
6212                                                  
6213  ***      0                                  0      return $fks;
6214                                                  }
6215                                                  
6216                                                  sub remove_auto_increment {
6217  ***      0                    0             0      my ( $self, $ddl ) = @_;
6218  ***      0                                  0      $ddl =~ s/(^\).*?) AUTO_INCREMENT=\d+\b/$1/m;
6219  ***      0                                  0      return $ddl;
6220                                                  }
6221                                                  
6222                                                  sub remove_secondary_indexes {
6223  ***      0                    0             0      my ( $self, $ddl ) = @_;
6224  ***      0                                  0      my $sec_indexes_ddl;
6225  ***      0                                  0      my $tbl_struct = $self->parse($ddl);
6226                                                  
6227  ***      0      0      0                    0      if ( ($tbl_struct->{engine} || '') =~ m/InnoDB/i ) {
6228  ***      0                                  0         my $clustered_key = $tbl_struct->{clustered_key};
6229  ***      0             0                    0         $clustered_key  ||= '';
6230                                                  
6231  ***      0                                  0         my @sec_indexes   = map {
6232  ***      0                                  0            my $key_def = $_->{ddl};
6233  ***      0                                  0            $key_def =~ s/([\(\)])/\\$1/g;
6234  ***      0                                  0            $ddl =~ s/\s+$key_def//;
6235                                                  
6236  ***      0                                  0            my $key_ddl = "ADD $_->{ddl}";
6237  ***      0      0                           0            $key_ddl   .= ',' unless $key_ddl =~ m/,$/;
6238  ***      0                                  0            $key_ddl;
6239                                                        }
6240  ***      0                                  0         grep { $_->{name} ne $clustered_key }
6241  ***      0                                  0         values %{$tbl_struct->{keys}};
6242  ***      0                                  0         MKDEBUG && _d('Secondary indexes:', Dumper(\@sec_indexes));
6243                                                  
6244  ***      0      0                           0         if ( @sec_indexes ) {
6245  ***      0                                  0            $sec_indexes_ddl = join(' ', @sec_indexes);
6246  ***      0                                  0            $sec_indexes_ddl =~ s/,$//;
6247                                                        }
6248                                                  
6249  ***      0                                  0         $ddl =~ s/,(\n\) )/$1/s;
6250                                                     }
6251                                                     else {
6252  ***      0                                  0         MKDEBUG && _d('Not removing secondary indexes from',
6253                                                           $tbl_struct->{engine}, 'table');
6254                                                     }
6255                                                  
6256  ***      0                                  0      return $ddl, $sec_indexes_ddl, $tbl_struct;
6257                                                  }
6258                                                  
6259                                                  sub _d {
6260  ***      0                    0             0      my ($package, undef, $line) = caller 0;
6261  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
6262  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
6263                                                          @_;
6264  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
6265                                                  }
6266                                                  
6267                                                  1;
6268                                                  
6269                                                  # ###########################################################################
6270                                                  # End TableParser package
6271                                                  # ###########################################################################
6272                                                  
6273                                                  # ###########################################################################
6274                                                  # QueryReview package 5266
6275                                                  # ###########################################################################
6276                                                  
6277                                                  package QueryReview;
6278                                                  
6279                                                  
6280           7                    7            73   use strict;
               7                                 25   
               7                                 48   
6281           7                    7            44   use warnings FATAL => 'all';
               7                                 21   
               7                                 71   
6282           7                    7            43   use English qw(-no_match_vars);
               7                                 16   
               7                                 47   
6283                                                  Transformers->import(qw(make_checksum parse_timestamp));
6284                                                  
6285           7                    7            53   use Data::Dumper;
               7                                 19   
               7                                 38   
6286                                                  
6287  ***      7            50      7            47   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 21   
               7                                107   
6288                                                  
6289                                                  my %basic_cols = map { $_ => 1 }
6290                                                     qw(checksum fingerprint sample first_seen last_seen reviewed_by
6291                                                        reviewed_on comments);
6292                                                  my %skip_cols  = map { $_ => 1 } qw(fingerprint sample checksum);
6293                                                  
6294                                                  sub new {
6295  ***      0                    0             0      my ( $class, %args ) = @_;
6296  ***      0                                  0      foreach my $arg ( qw(dbh db_tbl tbl_struct quoter) ) {
6297  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
6298                                                     }
6299                                                  
6300  ***      0                                  0      foreach my $col ( keys %basic_cols ) {
6301  ***      0      0                           0         die "Query review table $args{db_tbl} does not have a $col column"
6302                                                           unless $args{tbl_struct}->{is_col}->{$col};
6303                                                     }
6304                                                  
6305  ***      0      0                           0      my $now = defined $args{ts_default} ? $args{ts_default} : 'NOW()';
6306                                                  
6307  ***      0                                  0      my $sql = <<"      SQL";
6308                                                        INSERT INTO $args{db_tbl}
6309                                                        (checksum, fingerprint, sample, first_seen, last_seen)
6310                                                        VALUES(CONV(?, 16, 10), ?, ?, COALESCE(?, $now), COALESCE(?, $now))
6311                                                        ON DUPLICATE KEY UPDATE
6312                                                           first_seen = IF(
6313                                                              first_seen IS NULL,
6314                                                              COALESCE(?, $now),
6315                                                              LEAST(first_seen, COALESCE(?, $now))),
6316                                                           last_seen = IF(
6317                                                              last_seen IS NULL,
6318                                                              COALESCE(?, $now),
6319                                                              GREATEST(last_seen, COALESCE(?, $now)))
6320                                                        SQL
6321  ***      0                                  0      MKDEBUG && _d('SQL to insert into review table:', $sql);
6322  ***      0                                  0      my $insert_sth = $args{dbh}->prepare($sql);
6323                                                  
6324  ***      0                                  0      my @review_cols = grep { !$skip_cols{$_} } @{$args{tbl_struct}->{cols}};
      ***      0                                  0   
      ***      0                                  0   
6325  ***      0                                  0      $sql = "SELECT "
6326  ***      0                                  0           . join(', ', map { $args{quoter}->quote($_) } @review_cols)
6327                                                          . ", CONV(checksum, 10, 16) AS checksum_conv FROM $args{db_tbl}"
6328                                                          . " WHERE checksum=CONV(?, 16, 10)";
6329  ***      0                                  0      MKDEBUG && _d('SQL to select from review table:', $sql);
6330  ***      0                                  0      my $select_sth = $args{dbh}->prepare($sql);
6331                                                  
6332  ***      0                                  0      my $self = {
6333                                                        dbh         => $args{dbh},
6334                                                        db_tbl      => $args{db_tbl},
6335                                                        insert_sth  => $insert_sth,
6336                                                        select_sth  => $select_sth,
6337                                                        tbl_struct  => $args{tbl_struct},
6338                                                        quoter      => $args{quoter},
6339                                                        ts_default  => $now,
6340                                                     };
6341  ***      0                                  0      return bless $self, $class;
6342                                                  }
6343                                                  
6344                                                  sub set_history_options {
6345  ***      0                    0             0      my ( $self, %args ) = @_;
6346  ***      0                                  0      foreach my $arg ( qw(table dbh tbl_struct col_pat) ) {
6347  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
6348                                                     }
6349                                                  
6350  ***      0                                  0      my @cols;
6351  ***      0                                  0      my @metrics;
6352  ***      0                                  0      foreach my $col ( @{$args{tbl_struct}->{cols}} ) {
      ***      0                                  0   
6353  ***      0                                  0         my ( $attr, $metric ) = $col =~ m/$args{col_pat}/;
6354  ***      0      0      0                    0         next unless $attr && $metric;
6355  ***      0      0                           0         $attr = ucfirst $attr if $attr =~ m/_/; # TableParser lowercases
6356  ***      0                                  0         push @cols, $col;
6357  ***      0                                  0         push @metrics, [$attr, $metric];
6358                                                     }
6359                                                  
6360  ***      0                                  0      my $sql = "REPLACE INTO $args{table}("
6361                                                        . join(', ',
6362  ***      0      0      0                    0            map { $self->{quoter}->quote($_) } ('checksum', 'sample', @cols))
6363                                                        . ') VALUES (CONV(?, 16, 10), ?, '
6364                                                        . join(', ', map {
6365  ***      0                                  0            $_ eq 'ts_min' || $_ eq 'ts_max'
6366                                                              ? "COALESCE(?, $self->{ts_default})"
6367                                                              : '?'
6368                                                          } @cols) . ')';
6369  ***      0                                  0      MKDEBUG && _d($sql);
6370                                                  
6371  ***      0                                  0      $self->{history_sth}     = $args{dbh}->prepare($sql);
6372  ***      0                                  0      $self->{history_cols}    = \@cols;
6373  ***      0                                  0      $self->{history_metrics} = \@metrics;
6374                                                  }
6375                                                  
6376                                                  sub set_review_history {
6377  ***      0                    0             0      my ( $self, $id, $sample, %data ) = @_;
6378  ***      0                                  0      foreach my $thing ( qw(min max) ) {
6379  ***      0      0      0                    0         next unless defined $data{ts} && defined $data{ts}->{$thing};
6380  ***      0                                  0         $data{ts}->{$thing} = parse_timestamp($data{ts}->{$thing});
6381                                                     }
6382  ***      0                                  0      $self->{history_sth}->execute(
6383                                                        make_checksum($id),
6384                                                        $sample,
6385  ***      0                                  0         map { $data{$_->[0]}->{$_->[1]} } @{$self->{history_metrics}});
      ***      0                                  0   
6386                                                  }
6387                                                  
6388                                                  sub get_review_info {
6389  ***      0                    0             0      my ( $self, $id ) = @_;
6390  ***      0                                  0      $self->{select_sth}->execute(make_checksum($id));
6391  ***      0                                  0      my $review_vals = $self->{select_sth}->fetchall_arrayref({});
6392  ***      0      0      0                    0      if ( $review_vals && @$review_vals == 1 ) {
6393  ***      0                                  0         return $review_vals->[0];
6394                                                     }
6395  ***      0                                  0      return undef;
6396                                                  }
6397                                                  
6398                                                  sub set_review_info {
6399  ***      0                    0             0      my ( $self, %args ) = @_;
6400  ***      0      0                           0      $self->{insert_sth}->execute(
6401                                                        make_checksum($args{fingerprint}),
6402                                                        @args{qw(fingerprint sample)},
6403  ***      0                                  0         map { $args{$_} ? parse_timestamp($args{$_}) : undef }
6404                                                           qw(first_seen last_seen first_seen first_seen last_seen last_seen));
6405                                                  }
6406                                                  
6407                                                  sub review_cols {
6408  ***      0                    0             0      my ( $self ) = @_;
6409  ***      0                                  0      return grep { !$skip_cols{$_} } @{$self->{tbl_struct}->{cols}};
      ***      0                                  0   
      ***      0                                  0   
6410                                                  }
6411                                                  
6412                                                  sub _d {
6413  ***      0                    0             0      my ($package, undef, $line) = caller 0;
6414  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
6415  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
6416                                                          @_;
6417  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
6418                                                  }
6419                                                  
6420                                                  1;
6421                                                  # ###########################################################################
6422                                                  # End QueryReview package
6423                                                  # ###########################################################################
6424                                                  
6425                                                  # ###########################################################################
6426                                                  # Daemon package 5266
6427                                                  # ###########################################################################
6428                                                  
6429                                                  package Daemon;
6430                                                  
6431           7                    7            58   use strict;
               7                                 20   
               7                                 41   
6432           7                    7            46   use warnings FATAL => 'all';
               7                                 20   
               7                                 45   
6433                                                  
6434           7                    7            52   use POSIX qw(setsid);
               7                                 18   
               7                                 49   
6435           7                    7            40   use English qw(-no_match_vars);
               7                                 18   
               7                                 43   
6436                                                  
6437  ***      7            50      7            48   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 18   
               7                                109   
6438                                                  
6439                                                  sub new {
6440  ***      0                    0             0      my ( $class, %args ) = @_;
6441  ***      0                                  0      foreach my $arg ( qw(o) ) {
6442  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
6443                                                     }
6444  ***      0                                  0      my $o = $args{o};
6445  ***      0      0                           0      my $self = {
      ***             0                               
6446                                                        o        => $o,
6447                                                        log_file => $o->has('log') ? $o->get('log') : undef,
6448                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
6449                                                     };
6450                                                  
6451  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
6452                                                  
6453  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
6454  ***      0                                  0      return bless $self, $class;
6455                                                  }
6456                                                  
6457                                                  sub daemonize {
6458  ***      0                    0             0      my ( $self ) = @_;
6459                                                  
6460  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
6461  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
6462  ***      0      0                           0      if ( $pid ) {
6463  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
6464  ***      0                                  0         exit;
6465                                                     }
6466                                                  
6467  ***      0                                  0      $self->{child} = 1;
6468                                                  
6469  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
6470  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
6471                                                  
6472  ***      0                                  0      $self->_make_PID_file();
6473                                                  
6474  ***      0                                  0      $OUTPUT_AUTOFLUSH = 1;
6475                                                  
6476  ***      0      0                           0      if ( -t STDIN ) {
6477  ***      0                                  0         close STDIN;
6478  ***      0      0                           0         open  STDIN, '/dev/null'
6479                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
6480                                                     }
6481                                                  
6482  ***      0      0                           0      if ( $self->{log_file} ) {
6483  ***      0                                  0         close STDOUT;
6484  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
6485                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
6486                                                  
6487  ***      0                                  0         close STDERR;
6488  ***      0      0                           0         open  STDERR, ">&STDOUT"
6489                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
6490                                                     }
6491                                                     else {
6492  ***      0      0                           0         if ( -t STDOUT ) {
6493  ***      0                                  0            close STDOUT;
6494  ***      0      0                           0            open  STDOUT, '>', '/dev/null'
6495                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
6496                                                        }
6497  ***      0      0                           0         if ( -t STDERR ) {
6498  ***      0                                  0            close STDERR;
6499  ***      0      0                           0            open  STDERR, '>', '/dev/null'
6500                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
6501                                                        }
6502                                                     }
6503                                                  
6504  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
6505  ***      0                                  0      return;
6506                                                  }
6507                                                  
6508                                                  sub check_PID_file {
6509  ***      0                    0             0      my ( $self, $file ) = @_;
6510  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
6511  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
6512  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
6513  ***      0                                  0         my $pid;
6514  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
6515  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
6516  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
6517  ***      0      0                           0         if ( $pid ) {
6518  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
6519  ***      0      0                           0            if ( $pid_is_alive ) {
6520  ***      0                                  0               die "The PID file $PID_file already exists "
6521                                                                 . " and the PID that it contains, $pid, is running";
6522                                                           }
6523                                                           else {
6524  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
6525                                                                 . "contains, $pid, is not running";
6526                                                           }
6527                                                        }
6528                                                        else {
6529  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
6530                                                              . "contain a PID";
6531                                                        }
6532                                                     }
6533                                                     else {
6534  ***      0                                  0         MKDEBUG && _d('No PID file');
6535                                                     }
6536  ***      0                                  0      return;
6537                                                  }
6538                                                  
6539                                                  sub make_PID_file {
6540  ***      0                    0             0      my ( $self ) = @_;
6541  ***      0      0                           0      if ( exists $self->{child} ) {
6542  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
6543                                                     }
6544  ***      0                                  0      $self->_make_PID_file();
6545  ***      0                                  0      $self->{rm_PID_file} = 1;
6546  ***      0                                  0      return;
6547                                                  }
6548                                                  
6549                                                  sub _make_PID_file {
6550  ***      0                    0             0      my ( $self ) = @_;
6551                                                  
6552  ***      0                                  0      my $PID_file = $self->{PID_file};
6553  ***      0      0                           0      if ( !$PID_file ) {
6554  ***      0                                  0         MKDEBUG && _d('No PID file to create');
6555  ***      0                                  0         return;
6556                                                     }
6557                                                  
6558  ***      0                                  0      $self->check_PID_file();
6559                                                  
6560  ***      0      0                           0      open my $PID_FH, '>', $PID_file
6561                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
6562  ***      0      0                           0      print $PID_FH $PID
6563                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
6564  ***      0      0                           0      close $PID_FH
6565                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
6566                                                  
6567  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
6568  ***      0                                  0      return;
6569                                                  }
6570                                                  
6571                                                  sub _remove_PID_file {
6572  ***      0                    0             0      my ( $self ) = @_;
6573  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
6574  ***      0      0                           0         unlink $self->{PID_file}
6575                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
6576  ***      0                                  0         MKDEBUG && _d('Removed PID file');
6577                                                     }
6578                                                     else {
6579  ***      0                                  0         MKDEBUG && _d('No PID to remove');
6580                                                     }
6581  ***      0                                  0      return;
6582                                                  }
6583                                                  
6584                                                  sub DESTROY {
6585  ***      0                    0             0      my ( $self ) = @_;
6586  ***      0      0      0                    0      $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
6587  ***      0                                  0      return;
6588                                                  }
6589                                                  
6590                                                  sub _d {
6591  ***      0                    0             0      my ($package, undef, $line) = caller 0;
6592  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
6593  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
6594                                                          @_;
6595  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
6596                                                  }
6597                                                  
6598                                                  1;
6599                                                  
6600                                                  # ###########################################################################
6601                                                  # End Daemon package
6602                                                  # ###########################################################################
6603                                                  
6604                                                  # ###########################################################################
6605                                                  # MemcachedProtocolParser package 5810
6606                                                  # ###########################################################################
6607                                                  package MemcachedProtocolParser;
6608                                                  
6609           7                    7            54   use strict;
               7                                 21   
               7                                 39   
6610           7                    7            44   use warnings FATAL => 'all';
               7                                 18   
               7                                 41   
6611           7                    7            41   use English qw(-no_match_vars);
               7                                 17   
               7                                 47   
6612                                                  
6613           7                    7            47   use Data::Dumper;
               7                                 25   
               7                                 36   
6614                                                  $Data::Dumper::Indent    = 1;
6615                                                  $Data::Dumper::Sortkeys  = 1;
6616                                                  $Data::Dumper::Quotekeys = 0;
6617                                                  
6618  ***      7            50      7            45   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 22   
               7                                 92   
6619                                                  
6620                                                  sub new {
6621  ***      0                    0             0      my ( $class, %args ) = @_;
6622                                                  
6623  ***      0             0                    0      my $self = {
6624                                                        server      => $args{server},
6625                                                        port        => $args{port} || '11211',
6626                                                        sessions    => {},
6627                                                        o           => $args{o},
6628                                                     };
6629  ***      0                                  0      return bless $self, $class;
6630                                                  }
6631                                                  
6632                                                  sub parse_event {
6633  ***      0                    0             0      my ( $self, %args ) = @_;
6634  ***      0                                  0      my @required_args = qw(event);
6635  ***      0                                  0      foreach my $arg ( @required_args ) {
6636  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
6637                                                     }
6638  ***      0                                  0      my $packet = @args{@required_args};
6639                                                  
6640  ***      0                                  0      my $src_host = "$packet->{src_host}:$packet->{src_port}";
6641  ***      0                                  0      my $dst_host = "$packet->{dst_host}:$packet->{dst_port}";
6642                                                  
6643  ***      0      0                           0      if ( my $server = $self->{server} ) {  # Watch only the given server.
6644  ***      0                                  0         $server .= ":$self->{port}";
6645  ***      0      0      0                    0         if ( $src_host ne $server && $dst_host ne $server ) {
6646  ***      0                                  0            MKDEBUG && _d('Packet is not to or from', $server);
6647  ***      0                                  0            return;
6648                                                        }
6649                                                     }
6650                                                  
6651  ***      0                                  0      my $packet_from;
6652  ***      0                                  0      my $client;
6653  ***      0      0                           0      if ( $src_host =~ m/:$self->{port}$/ ) {
      ***             0                               
6654  ***      0                                  0         $packet_from = 'server';
6655  ***      0                                  0         $client      = $dst_host;
6656                                                     }
6657                                                     elsif ( $dst_host =~ m/:$self->{port}$/ ) {
6658  ***      0                                  0         $packet_from = 'client';
6659  ***      0                                  0         $client      = $src_host;
6660                                                     }
6661                                                     else {
6662  ***      0                                  0         warn 'Packet is not to or from memcached server: ', Dumper($packet);
6663  ***      0                                  0         return;
6664                                                     }
6665  ***      0                                  0      MKDEBUG && _d('Client:', $client);
6666                                                  
6667  ***      0      0                           0      if ( !exists $self->{sessions}->{$client} ) {
6668  ***      0                                  0         MKDEBUG && _d('New session');
6669  ***      0                                  0         $self->{sessions}->{$client} = {
6670                                                           client      => $client,
6671                                                           state       => undef,
6672                                                           raw_packets => [],
6673                                                        };
6674                                                     };
6675  ***      0                                  0      my $session = $self->{sessions}->{$client};
6676                                                  
6677  ***      0      0                           0      if ( $packet->{data_len} == 0 ) {
6678  ***      0                                  0         MKDEBUG && _d('No TCP data');
6679  ***      0                                  0         return;
6680                                                     }
6681                                                  
6682  ***      0                                  0      push @{$session->{raw_packets}}, $packet->{raw_packet};
      ***      0                                  0   
6683                                                  
6684  ***      0                                  0      $packet->{data} = pack('H*', $packet->{data});
6685  ***      0                                  0      my $event;
6686  ***      0      0                           0      if ( $packet_from eq 'server' ) {
      ***             0                               
6687  ***      0                                  0         $event = $self->_packet_from_server($packet, $session, $args{misc});
6688                                                     }
6689                                                     elsif ( $packet_from eq 'client' ) {
6690  ***      0                                  0         $event = $self->_packet_from_client($packet, $session, $args{misc});
6691                                                     }
6692                                                     else {
6693  ***      0                                  0         die 'Packet origin unknown';
6694                                                     }
6695                                                  
6696  ***      0                                  0      MKDEBUG && _d('Done with packet; event:', Dumper($event));
6697  ***      0                                  0      return $event;
6698                                                  }
6699                                                  
6700                                                  sub _packet_from_server {
6701  ***      0                    0             0      my ( $self, $packet, $session, $misc ) = @_;
6702  ***      0      0                           0      die "I need a packet"  unless $packet;
6703  ***      0      0                           0      die "I need a session" unless $session;
6704                                                  
6705  ***      0                                  0      MKDEBUG && _d('Packet is from server; client state:', $session->{state}); 
6706                                                  
6707  ***      0                                  0      my $data = $packet->{data};
6708                                                  
6709  ***      0      0                           0      if ( !$session->{state} ) {
6710  ***      0                                  0         MKDEBUG && _d('Ignoring mid-stream server response');
6711  ***      0                                  0         return;
6712                                                     }
6713                                                  
6714  ***      0      0                           0      if ( $session->{state} eq 'awaiting reply' ) {
6715  ***      0                                  0         MKDEBUG && _d('State is awaiting reply');
6716  ***      0                                  0         my ($line1, $rest) = $packet->{data} =~ m/\A(.*?)\r\n(.*)?/s;
6717                                                  
6718  ***      0                                  0         my @vals = $line1 =~ m/(\S+)/g;
6719  ***      0                                  0         $session->{res} = shift @vals;
6720  ***      0                                  0         MKDEBUG && _d('Result of last', $session->{cmd}, 'cmd:', $session->{res});
6721                                                  
6722  ***      0      0      0                    0         if ( $session->{cmd} eq 'incr' || $session->{cmd} eq 'decr' ) {
      ***             0                               
      ***             0                               
      ***             0                               
6723  ***      0                                  0            MKDEBUG && _d('It is an incr or decr');
6724  ***      0      0                           0            if ( $session->{res} !~ m/\D/ ) { # It's an integer, not an error
6725  ***      0                                  0               MKDEBUG && _d('Got a value for the incr/decr');
6726  ***      0                                  0               $session->{val} = $session->{res};
6727  ***      0                                  0               $session->{res} = '';
6728                                                           }
6729                                                        }
6730                                                        elsif ( $session->{res} eq 'VALUE' ) {
6731  ***      0                                  0            MKDEBUG && _d('It is the result of a "get"');
6732  ***      0                                  0            my ($key, $flags, $bytes) = @vals;
6733  ***      0      0                           0            defined $session->{flags} or $session->{flags} = $flags;
6734  ***      0      0                           0            defined $session->{bytes} or $session->{bytes} = $bytes;
6735  ***      0      0      0                    0            if ( $rest && $bytes ) {
6736  ***      0                                  0               MKDEBUG && _d('There is a value');
6737  ***      0      0                           0               if ( length($rest) > $bytes ) {
6738  ***      0                                  0                  MKDEBUG && _d('Looks like we got the whole response');
6739  ***      0                                  0                  $session->{val} = substr($rest, 0, $bytes); # Got the whole response.
6740                                                              }
6741                                                              else {
6742  ***      0                                  0                  MKDEBUG && _d('Got partial response, saving for later');
6743  ***      0                                  0                  push @{$session->{partial}}, [ $packet->{seq}, $rest ];
      ***      0                                  0   
6744  ***      0                                  0                  $session->{gathered} += length($rest);
6745  ***      0                                  0                  $session->{state} = 'partial recv';
6746  ***      0                                  0                  return; # Prevent firing an event.
6747                                                              }
6748                                                           }
6749                                                        }
6750                                                        elsif ( $session->{res} eq 'END' ) {
6751  ***      0                                  0            MKDEBUG && _d('Got an END without any data, firing NOT_FOUND');
6752  ***      0                                  0            $session->{res} = 'NOT_FOUND';
6753                                                        }
6754                                                        elsif ( $session->{res} !~ m/STORED|DELETED|NOT_FOUND/ ) {
6755  ***      0                                  0            MKDEBUG && _d('Unknown result');
6756                                                        }
6757                                                     }
6758                                                     else { # Should be 'partial recv'
6759  ***      0                                  0         MKDEBUG && _d('Session state: ', $session->{state});
6760  ***      0                                  0         push @{$session->{partial}}, [ $packet->{seq}, $data ];
      ***      0                                  0   
6761  ***      0                                  0         $session->{gathered} += length($data);
6762                                                        MKDEBUG && _d('Gathered', $session->{gathered}, 'bytes in',
6763  ***      0                                  0            scalar(@{$session->{partial}}), 'packets from server');
6764  ***      0      0                           0         if ( $session->{gathered} >= $session->{bytes} + 2 ) { # Done.
6765  ***      0                                  0            MKDEBUG && _d('End of partial response, preparing event');
6766  ***      0                                  0            my $val = join('',
6767  ***      0                                  0               map  { $_->[1] }
6768  ***      0                                  0               sort { $a->[0] <=> $b->[0] }
6769  ***      0                                  0                    @{$session->{partial}});
6770  ***      0                                  0            $session->{val} = substr($val, 0, $session->{bytes});
6771                                                        }
6772                                                        else {
6773  ***      0                                  0            MKDEBUG && _d('Partial response continues, no action');
6774  ***      0                                  0            return; # Prevent firing event.
6775                                                        }
6776                                                     }
6777                                                  
6778  ***      0                                  0      MKDEBUG && _d('Creating event, deleting session');
6779  ***      0                                  0      my $event = make_event($session, $packet);
6780  ***      0                                  0      delete $self->{sessions}->{$session->{client}}; # memcached is stateless!
6781  ***      0                                  0      $session->{raw_packets} = []; # Avoid keeping forever
6782  ***      0                                  0      return $event;
6783                                                  }
6784                                                  
6785                                                  sub _packet_from_client {
6786  ***      0                    0             0      my ( $self, $packet, $session, $misc ) = @_;
6787  ***      0      0                           0      die "I need a packet"  unless $packet;
6788  ***      0      0                           0      die "I need a session" unless $session;
6789                                                  
6790  ***      0                                  0      MKDEBUG && _d('Packet is from client; state:', $session->{state});
6791                                                  
6792  ***      0                                  0      my $event;
6793  ***      0      0      0                    0      if ( ($session->{state} || '') =~m/awaiting reply|partial recv/ ) {
6794  ***      0                                  0         MKDEBUG && _d("Expected data from the client, looks like interrupted");
6795  ***      0                                  0         $session->{res} = 'INTERRUPTED';
6796  ***      0                                  0         $event = make_event($session, $packet);
6797  ***      0                                  0         my $client = $session->{client};
6798  ***      0                                  0         delete @{$session}{keys %$session};
      ***      0                                  0   
6799  ***      0                                  0         $session->{client} = $client;
6800                                                     }
6801                                                  
6802  ***      0                                  0      my ($line1, $val);
6803  ***      0                                  0      my ($cmd, $key, $flags, $exptime, $bytes);
6804                                                     
6805  ***      0      0                           0      if ( !$session->{state} ) {
6806  ***      0                                  0         MKDEBUG && _d('Session state: ', $session->{state});
6807  ***      0                                  0         ($line1, $val) = $packet->{data} =~ m/\A(.*?)\r\n(.+)?/s;
6808  ***      0                                  0         my @vals = $line1 =~ m/(\S+)/g;
6809  ***      0                                  0         $cmd = lc shift @vals;
6810  ***      0                                  0         MKDEBUG && _d('$cmd is a ', $cmd);
6811  ***      0      0      0                    0         if ( $cmd eq 'set' || $cmd eq 'add' || $cmd eq 'replace' ) {
      ***             0      0                        
      ***             0      0                        
      ***             0                               
6812  ***      0                                  0            ($key, $flags, $exptime, $bytes) = @vals;
6813  ***      0                                  0            $session->{bytes} = $bytes;
6814                                                        }
6815                                                        elsif ( $cmd eq 'get' ) {
6816  ***      0                                  0            ($key) = @vals;
6817  ***      0      0                           0            if ( $val ) {
6818  ***      0                                  0               MKDEBUG && _d('Multiple cmds:', $val);
6819  ***      0                                  0               $val = undef;
6820                                                           }
6821                                                        }
6822                                                        elsif ( $cmd eq 'delete' ) {
6823  ***      0                                  0            ($key) = @vals; # TODO: handle the <queue_time>
6824  ***      0      0                           0            if ( $val ) {
6825  ***      0                                  0               MKDEBUG && _d('Multiple cmds:', $val);
6826  ***      0                                  0               $val = undef;
6827                                                           }
6828                                                        }
6829                                                        elsif ( $cmd eq 'incr' || $cmd eq 'decr' ) {
6830  ***      0                                  0            ($key) = @vals;
6831                                                        }
6832                                                        else {
6833  ***      0                                  0            MKDEBUG && _d("Don't know how to handle", $cmd, "command");
6834                                                        }
6835  ***      0                                  0         @{$session}{qw(cmd key flags exptime)}
      ***      0                                  0   
6836                                                           = ($cmd, $key, $flags, $exptime);
6837  ***      0                                  0         $session->{host}       = $packet->{src_host};
6838  ***      0                                  0         $session->{pos_in_log} = $packet->{pos_in_log};
6839  ***      0                                  0         $session->{ts}         = $packet->{ts};
6840                                                     }
6841                                                     else {
6842  ***      0                                  0         MKDEBUG && _d('Session state: ', $session->{state});
6843  ***      0                                  0         $val = $packet->{data};
6844                                                     }
6845                                                  
6846  ***      0                                  0      $session->{state} = 'awaiting reply'; # Assume we got the whole packet
6847  ***      0      0                           0      if ( $val ) {
6848  ***      0      0                           0         if ( $session->{bytes} + 2 == length($val) ) { # +2 for the \r\n
6849  ***      0                                  0            MKDEBUG && _d('Got the whole thing');
6850  ***      0                                  0            $val =~ s/\r\n\Z//; # We got the whole thing.
6851  ***      0                                  0            $session->{val} = $val;
6852                                                        }
6853                                                        else { # We apparently did NOT get the whole thing.
6854  ***      0                                  0            MKDEBUG && _d('Partial send, saving for later');
6855  ***      0                                  0            push @{$session->{partial}},
      ***      0                                  0   
6856                                                              [ $packet->{seq}, $val ];
6857  ***      0                                  0            $session->{gathered} += length($val);
6858                                                           MKDEBUG && _d('Gathered', $session->{gathered}, 'bytes in',
6859  ***      0                                  0               scalar(@{$session->{partial}}), 'packets from client');
6860  ***      0      0                           0            if ( $session->{gathered} >= $session->{bytes} + 2 ) { # Done.
6861  ***      0                                  0               MKDEBUG && _d('Message looks complete now, saving value');
6862  ***      0                                  0               $val = join('',
6863  ***      0                                  0                  map  { $_->[1] }
6864  ***      0                                  0                  sort { $a->[0] <=> $b->[0] }
6865  ***      0                                  0                       @{$session->{partial}});
6866  ***      0                                  0               $val =~ s/\r\n\Z//;
6867  ***      0                                  0               $session->{val} = $val;
6868                                                           }
6869                                                           else {
6870  ***      0                                  0               MKDEBUG && _d('Message not complete');
6871  ***      0                                  0               $val = '[INCOMPLETE]';
6872  ***      0                                  0               $session->{state} = 'partial send';
6873                                                           }
6874                                                        }
6875                                                     }
6876                                                  
6877  ***      0                                  0      return $event;
6878                                                  }
6879                                                  
6880                                                  sub make_event {
6881  ***      0                    0             0      my ( $session, $packet ) = @_;
6882  ***      0             0                    0      my $event = {
      ***                    0                        
      ***                    0                        
      ***                    0                        
6883                                                        cmd        => $session->{cmd},
6884                                                        key        => $session->{key},
6885                                                        val        => $session->{val} || '',
6886                                                        res        => $session->{res},
6887                                                        ts         => $session->{ts},
6888                                                        host       => $session->{host},
6889                                                        flags      => $session->{flags}   || 0,
6890                                                        exptime    => $session->{exptime} || 0,
6891                                                        bytes      => $session->{bytes}   || 0,
6892                                                        Query_time => timestamp_diff($session->{ts}, $packet->{ts}),
6893                                                        pos_in_log => $session->{pos_in_log},
6894                                                     };
6895  ***      0                                  0      return $event;
6896                                                  }
6897                                                  
6898                                                  sub _get_errors_fh {
6899  ***      0                    0             0      my ( $self ) = @_;
6900  ***      0                                  0      my $errors_fh = $self->{errors_fh};
6901  ***      0      0                           0      return $errors_fh if $errors_fh;
6902                                                  
6903  ***      0                                  0      my $o = $self->{o};
6904  ***      0      0      0                    0      if ( $o && $o->has('tcpdump-errors') && $o->got('tcpdump-errors') ) {
      ***                    0                        
6905  ***      0                                  0         my $errors_file = $o->get('tcpdump-errors');
6906  ***      0                                  0         MKDEBUG && _d('tcpdump-errors file:', $errors_file);
6907  ***      0      0                           0         open $errors_fh, '>>', $errors_file
6908                                                           or die "Cannot open tcpdump-errors file $errors_file: $OS_ERROR";
6909                                                     }
6910                                                  
6911  ***      0                                  0      $self->{errors_fh} = $errors_fh;
6912  ***      0                                  0      return $errors_fh;
6913                                                  }
6914                                                  
6915                                                  sub fail_session {
6916  ***      0                    0             0      my ( $self, $session, $reason ) = @_;
6917  ***      0                                  0      my $errors_fh = $self->_get_errors_fh();
6918  ***      0      0                           0      if ( $errors_fh ) {
6919  ***      0                                  0         $session->{reason_for_failure} = $reason;
6920  ***      0                                  0         my $session_dump = '# ' . Dumper($session);
6921  ***      0                                  0         chomp $session_dump;
6922  ***      0                                  0         $session_dump =~ s/\n/\n# /g;
6923  ***      0                                  0         print $errors_fh "$session_dump\n";
6924                                                        {
6925  ***      0                                  0            local $LIST_SEPARATOR = "\n";
      ***      0                                  0   
6926  ***      0                                  0            print $errors_fh "@{$session->{raw_packets}}";
      ***      0                                  0   
6927  ***      0                                  0            print $errors_fh "\n";
6928                                                        }
6929                                                     }
6930  ***      0                                  0      MKDEBUG && _d('Failed session', $session->{client}, 'because', $reason);
6931  ***      0                                  0      delete $self->{sessions}->{$session->{client}};
6932  ***      0                                  0      return;
6933                                                  }
6934                                                  
6935                                                  sub _d {
6936  ***      0                    0             0      my ($package, undef, $line) = caller 0;
6937  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
6938  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
6939                                                          @_;
6940  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
6941                                                  }
6942                                                  
6943                                                  sub timestamp_diff {
6944  ***      0                    0             0      my ( $start, $end ) = @_;
6945  ***      0                                  0      my $sd = substr($start, 0, 11, '');
6946  ***      0                                  0      my $ed = substr($end,   0, 11, '');
6947  ***      0                                  0      my ( $sh, $sm, $ss ) = split(/:/, $start);
6948  ***      0                                  0      my ( $eh, $em, $es ) = split(/:/, $end);
6949  ***      0                                  0      my $esecs = ($eh * 3600 + $em * 60 + $es);
6950  ***      0                                  0      my $ssecs = ($sh * 3600 + $sm * 60 + $ss);
6951  ***      0      0                           0      if ( $sd eq $ed ) {
6952  ***      0                                  0         return sprintf '%.6f', $esecs - $ssecs;
6953                                                     }
6954                                                     else { # Assume only one day boundary has been crossed, no DST, etc
6955  ***      0                                  0         return sprintf '%.6f', ( 86_400 - $ssecs ) + $esecs;
6956                                                     }
6957                                                  }
6958                                                  
6959                                                  1;
6960                                                  
6961                                                  # ###########################################################################
6962                                                  # End MemcachedProtocolParser package
6963                                                  # ###########################################################################
6964                                                  
6965                                                  # ###########################################################################
6966                                                  # MemcachedEvent package 5266
6967                                                  # ###########################################################################
6968                                                  package MemcachedEvent;
6969                                                  
6970                                                  
6971           7                    7            71   use strict;
               7                                 21   
               7                                 48   
6972           7                    7            44   use warnings FATAL => 'all';
               7                                 23   
               7                                 49   
6973           7                    7            42   use English qw(-no_match_vars);
               7                                 17   
               7                                 39   
6974                                                  
6975           7                    7            51   use Data::Dumper;
               7                                 17   
               7                                 46   
6976                                                  $Data::Dumper::Indent    = 1;
6977                                                  $Data::Dumper::Sortkeys  = 1;
6978                                                  $Data::Dumper::Quotekeys = 0;
6979                                                  
6980  ***      7            50      7            45   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 17   
               7                                136   
6981                                                  
6982                                                  my %cmds = map { $_ => 1 } qw(
6983                                                     set
6984                                                     add
6985                                                     replace
6986                                                     append
6987                                                     prepend
6988                                                     cas
6989                                                     get
6990                                                     gets
6991                                                     delete
6992                                                     incr
6993                                                     decr
6994                                                  );
6995                                                  
6996                                                  my %cmd_handler_for = (
6997                                                     set      => \&handle_storage_cmd,
6998                                                     add      => \&handle_storage_cmd,
6999                                                     replace  => \&handle_storage_cmd,
7000                                                     append   => \&handle_storage_cmd,
7001                                                     prepend  => \&handle_storage_cmd,
7002                                                     cas      => \&handle_storage_cmd,
7003                                                     get      => \&handle_retr_cmd,
7004                                                     gets     => \&handle_retr_cmd,
7005                                                  );
7006                                                  
7007                                                  sub new {
7008  ***      0                    0             0      my ( $class, %args ) = @_;
7009  ***      0                                  0      my $self = {};
7010  ***      0                                  0      return bless $self, $class;
7011                                                  }
7012                                                  
7013                                                  sub parse_event {
7014  ***      0                    0             0      my ( $self, %args ) = @_;
7015  ***      0                                  0      my $event = $args{event};
7016  ***      0      0                           0      return unless $event;
7017                                                  
7018  ***      0      0      0                    0      if ( !$event->{cmd} || !$event->{key} ) {
7019  ***      0                                  0         MKDEBUG && _d('Event has no cmd or key:', Dumper($event));
7020  ***      0                                  0         return;
7021                                                     }
7022                                                  
7023  ***      0      0                           0      if ( !$cmds{$event->{cmd}} ) {
7024  ***      0                                  0         MKDEBUG && _d("Don't know how to handle cmd:", $event->{cmd});
7025  ***      0                                  0         return;
7026                                                     }
7027                                                  
7028  ***      0                                  0      $event->{arg}         = "$event->{cmd} $event->{key}";
7029  ***      0                                  0      $event->{fingerprint} = $self->fingerprint($event->{arg});
7030  ***      0                                  0      $event->{key_print}   = $self->fingerprint($event->{key});
7031                                                  
7032  ***      0                                  0      map { $event->{"Memc_$_"} = 'No' } keys %cmds;
      ***      0                                  0   
7033  ***      0                                  0      $event->{"Memc_$event->{cmd}"} = 'Yes';  # Got this cmd.
7034  ***      0                                  0      $event->{Memc_error}           = 'No';  # A handler may change this.
7035  ***      0                                  0      $event->{Memc_miss}            = 'No';
7036  ***      0      0                           0      if ( $event->{res} ) {
7037  ***      0      0                           0         $event->{Memc_miss}         = 'Yes' if $event->{res} eq 'NOT_FOUND';
7038                                                     }
7039                                                     else {
7040  ***      0                                  0         MKDEBUG && _d('Event has no res:', Dumper($event));
7041                                                     }
7042                                                  
7043  ***      0      0                           0      if ( $cmd_handler_for{$event->{cmd}} ) {
7044  ***      0                                  0         return $cmd_handler_for{$event->{cmd}}->($event);
7045                                                     }
7046                                                  
7047  ***      0                                  0      return $event;
7048                                                  }
7049                                                  
7050                                                  sub fingerprint {
7051  ***      0                    0             0      my ( $self, $val ) = @_;
7052  ***      0                                  0      $val =~ s/[0-9A-Fa-f]{16,}|\d+/?/g;
7053  ***      0                                  0      return $val;
7054                                                  }
7055                                                  
7056                                                  sub handle_storage_cmd {
7057  ***      0                    0             0      my ( $event ) = @_;
7058                                                  
7059  ***      0      0                           0      if ( !$event->{res} ) {
7060  ***      0                                  0         MKDEBUG && _d('No result for event:', Dumper($event));
7061  ***      0                                  0         return;
7062                                                     }
7063                                                  
7064  ***      0      0                           0      $event->{'Memc_Not_Stored'} = $event->{res} eq 'NOT_STORED' ? 'Yes' : 'No';
7065  ***      0      0                           0      $event->{'Memc_Exists'}     = $event->{res} eq 'EXISTS'     ? 'Yes' : 'No';
7066                                                  
7067  ***      0                                  0      return $event;
7068                                                  }
7069                                                  
7070                                                  sub handle_retr_cmd {
7071  ***      0                    0             0      my ( $event ) = @_;
7072                                                  
7073  ***      0      0                           0      if ( !$event->{res} ) {
7074  ***      0                                  0         MKDEBUG && _d('No result for event:', Dumper($event));
7075  ***      0                                  0         return;
7076                                                     }
7077                                                  
7078  ***      0      0                           0      $event->{'Memc_error'} = $event->{res} eq 'INTERRUPTED' ? 'Yes' : 'No';
7079                                                  
7080  ***      0                                  0      return $event;
7081                                                  }
7082                                                  
7083                                                  
7084                                                  sub handle_delete {
7085  ***      0                    0             0      my ( $event ) = @_;
7086  ***      0                                  0      return $event;
7087                                                  }
7088                                                  
7089                                                  sub handle_incr_decr_cmd {
7090  ***      0                    0             0      my ( $event ) = @_;
7091  ***      0                                  0      return $event;
7092                                                  }
7093                                                  
7094                                                  sub _d {
7095  ***      0                    0             0      my ($package, undef, $line) = caller 0;
7096  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
7097  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
7098                                                          @_;
7099  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
7100                                                  }
7101                                                  
7102                                                  1;
7103                                                  
7104                                                  # ###########################################################################
7105                                                  # End MemcachedEvent package
7106                                                  # ###########################################################################
7107                                                  
7108                                                  # ###########################################################################
7109                                                  # BinaryLogParser package 5358
7110                                                  # ###########################################################################
7111                                                  package BinaryLogParser;
7112                                                  
7113           7                    7            54   use strict;
               7                                 17   
               7                                 39   
7114           7                    7            44   use warnings FATAL => 'all';
               7                                 16   
               7                                 39   
7115           7                    7            41   use English qw(-no_match_vars);
               7                                 18   
               7                                 34   
7116                                                  
7117           7                    7            58   use Data::Dumper;
               7                                 22   
               7                                 41   
7118                                                  $Data::Dumper::Indent    = 1;
7119                                                  $Data::Dumper::Sortkeys  = 1;
7120                                                  $Data::Dumper::Quotekeys = 0;
7121                                                  
7122  ***      7            50      7            49   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 23   
               7                                163   
7123                                                  
7124                                                  sub new {
7125           2                    2            16      my ( $class, %args ) = @_;
7126           2                                 15      my $self = {
7127                                                        delim     => undef,
7128                                                        delim_len => 0,
7129                                                     };
7130           2                                 20      return bless $self, $class;
7131                                                  }
7132                                                  
7133                                                  my $binlog_line_1 = qr/at (\d+)$/m;
7134                                                  my $binlog_line_2 = qr/^#(\d{6}\s+\d{1,2}:\d\d:\d\d)\s+server\s+id\s+(\d+)\s+end_log_pos\s+(\d+)\s+(\S+)\s*([^\n]*)$/m;
7135                                                  my $binlog_line_2_rest = qr/thread_id=(\d+)\s+exec_time=(\d+)\s+error_code=(\d+)/m;
7136                                                  
7137                                                  sub parse_event {
7138          17                   17           104      my ( $self, %args ) = @_;
7139          17                                 92      my @required_args = qw(next_event tell);
7140          17                                 61      foreach my $arg ( @required_args ) {
7141  ***     34     50                         166         die "I need a $arg argument" unless $args{$arg};
7142                                                     }
7143          17                                 82      my ($next_event, $tell) = @args{@required_args};
7144                                                  
7145          17                                107      local $INPUT_RECORD_SEPARATOR = ";\n#";
7146          17                                 62      my $pos_in_log = $tell->();
7147          17                                 46      my $stmt;
7148          17                                 91      my ($delim, $delim_len) = ($self->{delim}, $self->{delim_len});
7149                                                  
7150                                                     EVENT:
7151          17                                 91      while ( defined($stmt = $next_event->()) ) {
7152          18                                 71         my @properties = ('pos_in_log', $pos_in_log);
7153          18                                 60         my ($ts, $sid, $end, $type, $rest);
7154          18                                 62         $pos_in_log = $tell->();
7155          18                                149         $stmt =~ s/;\n#?\Z//;
7156                                                  
7157          18                                 46         my ( $got_offset, $got_hdr );
7158          18                                 49         my $pos = 0;
7159          18                                 61         my $len = length($stmt);
7160          18                                 47         my $found_arg = 0;
7161                                                        LINE:
7162          18                                131         while ( $stmt =~ m/^(.*)$/mg ) { # /g requires scalar match.
7163          74                                230            $pos     = pos($stmt);  # Be careful not to mess this up!
7164          74                                256            my $line = $1;          # Necessary for /g and pos() to work.
7165          74    100                         366            $line    =~ s/$delim// if $delim;
7166          74                                157            MKDEBUG && _d($line);
7167                                                  
7168          74    100                         646            if ( $line =~ m/^\/\*.+\*\/;/ ) {
7169           6                                 12               MKDEBUG && _d('Comment line');
7170           6                                 33               next LINE;
7171                                                           }
7172                                                   
7173          68    100                         258            if ( $line =~ m/^DELIMITER/m ) {
7174           3                                 20               my ( $del ) = $line =~ m/^DELIMITER (\S*)$/m;
7175           3    100                          13               if ( $del ) {
7176           2                                  9                  $self->{delim_len} = $delim_len = length $del;
7177           2                                 10                  $self->{delim}     = $delim     = quotemeta $del;
7178           2                                  5                  MKDEBUG && _d('delimiter:', $delim);
7179                                                              }
7180                                                              else {
7181           1                                  3                  MKDEBUG && _d('Delimiter reset to ;');
7182           1                                  4                  $self->{delim}     = $delim     = undef;
7183           1                                  5                  $self->{delim_len} = $delim_len = 0;
7184                                                              }
7185           3                                 16               next LINE;
7186                                                           }
7187                                                  
7188          65    100                        1567            next LINE if $line =~ m/End of log file/;
7189                                                  
7190          63    100    100                  766            if ( !$got_offset && (my ( $offset ) = $line =~ m/$binlog_line_1/m) ) {
                    100    100                        
                    100                               
7191          14                                 36               MKDEBUG && _d('Got the at offset line');
7192          14                                 56               push @properties, 'offset', $offset;
7193          14                                 96               $got_offset++;
7194                                                           }
7195                                                  
7196                                                           elsif ( !$got_hdr && $line =~ m/^#(\d{6}\s+\d{1,2}:\d\d:\d\d)/ ) {
7197          14                                193               ($ts, $sid, $end, $type, $rest) = $line =~ m/$binlog_line_2/m;
7198          14                                 47               MKDEBUG && _d('Got the header line; type:', $type, 'rest:', $rest);
7199          14                                 74               push @properties, 'cmd', 'Query', 'ts', $ts, 'server_id', $sid,
7200                                                                 'end_log_pos', $end;
7201          14                                 84               $got_hdr++;
7202                                                           }
7203                                                  
7204                                                           elsif ( $line =~ m/^(?:#|use |SET)/i ) {
7205                                                  
7206          20    100                         201               if ( my ( $db ) = $line =~ m/^use ([^;]+)/ ) {
                    100                               
7207           2                                  5                  MKDEBUG && _d("Got a default database:", $db);
7208           2                                 14                  push @properties, 'db', $db;
7209                                                              }
7210                                                  
7211                                                              elsif ( my ($setting) = $line =~ m/^SET\s+([^;]*)/ ) {
7212          17                                 39                  MKDEBUG && _d("Got some setting:", $setting);
7213          17                                239                  push @properties, map { s/\s+//; lc } split(/,|\s*=\s*/, $setting);
              50                                141   
              50                                245   
7214                                                              }
7215                                                  
7216                                                           }
7217                                                           else {
7218          15                                 35               MKDEBUG && _d("Got the query/arg line at pos", $pos);
7219          15                                 40               $found_arg++;
7220  ***     15    100     66                  159               if ( $got_offset && $got_hdr ) {
7221          13    100                          74                  if ( $type eq 'Xid' ) {
                    100                               
      ***            50                               
7222           3                                 20                     my ($xid) = $rest =~ m/(\d+)/;
7223           3                                 13                     push @properties, 'Xid', $xid;
7224                                                                 }
7225                                                                 elsif ( $type eq 'Query' ) {
7226           9                                106                     my ($i, $t, $c) = $rest =~ m/$binlog_line_2_rest/m;
7227           9                                 57                     push @properties, 'Thread_id', $i, 'Query_time', $t,
7228                                                                                      'error_code', $c;
7229                                                                 }
7230                                                                 elsif ( $type eq 'Start:' ) {
7231           1                                  6                     MKDEBUG && _d("Binlog start");
7232                                                                 }
7233                                                                 else {
7234  ***      0                                  0                     MKDEBUG && _d('Unknown event type:', $type);
7235  ***      0                                  0                     next EVENT;
7236                                                                 }
7237                                                              }
7238                                                              else {
7239           2                                  5                  MKDEBUG && _d("It's not a query/arg, it's just some SQL fluff");
7240           2                                 18                  push @properties, 'cmd', 'Query', 'ts', undef;
7241                                                              }
7242                                                  
7243          15    100                          70               my $delim_len = ($pos == length($stmt) ? $delim_len : 0);
7244          15                                 79               my $arg = substr($stmt, $pos - length($line) - $delim_len);
7245                                                  
7246          15    100                         106               $arg =~ s/$delim// if $delim; # Remove the delimiter.
7247                                                  
7248          15    100                         754               if ( $arg =~ m/^DELIMITER/m ) {
7249           1                                  7                  my ( $del ) = $arg =~ m/^DELIMITER (\S*)$/m;
7250  ***      1     50                           5                  if ( $del ) {
7251  ***      0                                  0                     $self->{delim_len} = $delim_len = length $del;
7252  ***      0                                  0                     $self->{delim}     = $delim     = quotemeta $del;
7253  ***      0                                  0                     MKDEBUG && _d('delimiter:', $delim);
7254                                                                 }
7255                                                                 else {
7256           1                                  3                     MKDEBUG && _d('Delimiter reset to ;');
7257           1                                  3                     $del       = ';';
7258           1                                  4                     $self->{delim}     = $delim     = undef;
7259           1                                  4                     $self->{delim_len} = $delim_len = 0;
7260                                                                 }
7261                                                  
7262           1                                  8                  $arg =~ s/^DELIMITER.*$//m;  # Remove DELIMITER from arg.
7263                                                              }
7264                                                  
7265          15                                 56               $arg =~ s/;$//gm;  # Ensure ending ; are gone.
7266          15                                104               $arg =~ s/\s+$//;  # Remove trailing spaces and newlines.
7267                                                  
7268          15                                 77               push @properties, 'arg', $arg, 'bytes', length($arg);
7269          15                                 60               last LINE;
7270                                                           }
7271                                                        } # LINE
7272                                                  
7273          18    100                          72         if ( $found_arg ) {
7274          15                                 32            MKDEBUG && _d('Properties of event:', Dumper(\@properties));
7275          15                                186            my $event = { @properties };
7276          15                                451            return $event;
7277                                                        }
7278                                                        else {
7279           3                                 15            MKDEBUG && _d('Event had no arg');
7280                                                        }
7281                                                     } # EVENT
7282                                                  
7283  ***      2     50                          13      $args{oktorun}->(0) if $args{oktorun};
7284           2                                 15      return;
7285                                                  }
7286                                                  
7287                                                  sub _d {
7288  ***      0                    0             0      my ($package, undef, $line) = caller 0;
7289  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
7290  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
7291                                                          @_;
7292  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
7293                                                  }
7294                                                  
7295                                                  1;
7296                                                  
7297                                                  # ###########################################################################
7298                                                  # End BinaryLogParser package
7299                                                  # ###########################################################################
7300                                                  
7301                                                  # ###########################################################################
7302                                                  # GeneralLogParser package 5359
7303                                                  # ###########################################################################
7304                                                  package GeneralLogParser;
7305                                                  
7306           7                    7            61   use strict;
               7                                 22   
               7                                 45   
7307           7                    7            43   use warnings FATAL => 'all';
               7                                 19   
               7                                 39   
7308           7                    7            49   use English qw(-no_match_vars);
               7                                 29   
               7                                 43   
7309                                                  
7310           7                    7            51   use Data::Dumper;
               7                                 19   
               7                                 39   
7311                                                  $Data::Dumper::Indent    = 1;
7312                                                  $Data::Dumper::Sortkeys  = 1;
7313                                                  $Data::Dumper::Quotekeys = 0;
7314                                                  
7315  ***      7            50      7            65   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 19   
               7                                115   
7316                                                  
7317                                                  sub new {
7318           1                    1             5      my ( $class ) = @_;
7319           1                                  6      my $self = {
7320                                                        pending => [],
7321                                                        db_for  => {},
7322                                                     };
7323           1                                 16      return bless $self, $class;
7324                                                  }
7325                                                  
7326                                                  my $genlog_line_1= qr{
7327                                                     \A
7328                                                     (?:(\d{6}\s\d{1,2}:\d\d:\d\d))? # Timestamp
7329                                                     \s+
7330                                                     (?:\s*(\d+))                        # Thread ID
7331                                                     \s
7332                                                     (\w+)                               # Command
7333                                                     \s+
7334                                                     (.*)                                # Argument
7335                                                     \Z
7336                                                  }xs;
7337                                                  
7338                                                  sub parse_event {
7339           8                    8            47      my ( $self, %args ) = @_;
7340           8                                 34      my @required_args = qw(next_event tell);
7341           8                                 29      foreach my $arg ( @required_args ) {
7342  ***     16     50                          74         die "I need a $arg argument" unless $args{$arg};
7343                                                     }
7344           8                                 34      my ($next_event, $tell) = @args{@required_args};
7345                                                  
7346           8                                 27      my $pending = $self->{pending};
7347           8                                 23      my $db_for  = $self->{db_for};
7348           8                                 20      my $line;
7349           8                                 25      my $pos_in_log = $tell->();
7350                                                     LINE:
7351           8           100                   60      while (
7352                                                           defined($line = shift @$pending)
7353                                                        or defined($line = $next_event->())
7354                                                     ) {
7355           7                                 14         MKDEBUG && _d($line);
7356           7                                 91         my ($ts, $thread_id, $cmd, $arg) = $line =~ m/$genlog_line_1/;
7357  ***      7     50     33                   59         if ( !($thread_id && $cmd) ) {
7358  ***      0                                  0            MKDEBUG && _d('Not start of general log event');
7359  ***      0                                  0            next;
7360                                                        }
7361           7                                 33         my @properties = ('pos_in_log', $pos_in_log, 'ts', $ts,
7362                                                           'Thread_id', $thread_id);
7363                                                  
7364           7                                 22         $pos_in_log = $tell->();
7365                                                  
7366           7                                 21         @$pending = ();
7367           7    100                          31         if ( $cmd eq 'Query' ) {
7368           2                                  6            my $done = 0;
7369           2                                  6            do {
7370           5                                 16               $line = $next_event->();
7371  ***      5     50                          18               if ( $line ) {
7372           5                                116                  ($ts, $thread_id, $cmd, undef) = $line =~ m/$genlog_line_1/;
7373  ***      5    100     66                   36                  if ( $thread_id && $cmd ) {
7374           2                                  8                     MKDEBUG && _d('Event done');
7375           2                                  7                     $done = 1;
7376           2                                 11                     push @$pending, $line;
7377                                                                 }
7378                                                                 else {
7379           3                                  6                     MKDEBUG && _d('More arg:', $line);
7380           3                                 16                     $arg .= $line;
7381                                                                 }
7382                                                              }
7383                                                              else {
7384  ***      0                                  0                  MKDEBUG && _d('No more lines');
7385  ***      0                                  0                  $done = 1;
7386                                                              }
7387                                                           } until ( $done );
7388                                                  
7389           2                                  7            chomp $arg;
7390           2                                  8            push @properties, 'cmd', 'Query', 'arg', $arg;
7391           2                                 12            push @properties, 'bytes', length($properties[-1]);
7392  ***      2     50                          13            push @properties, 'db', $db_for->{$thread_id} if $db_for->{$thread_id};
7393                                                        }
7394                                                        else {
7395           5                                 23            push @properties, 'cmd', 'Admin';
7396                                                  
7397           5    100                          24            if ( $cmd eq 'Connect' ) {
                    100                               
7398  ***      2     50                          10               if ( $arg =~ m/^Access denied/ ) {
7399  ***      0                                  0                  $cmd = $arg;
7400                                                              }
7401                                                              else {
7402           2                                 21                  my ($user, undef, $db) = $arg =~ /(\S+)/g;
7403           2                                  6                  my $host;
7404           2                                 14                  ($user, $host) = split(/@/, $user);
7405           2                                  4                  MKDEBUG && _d('Connect', $user, '@', $host, 'on', $db);
7406                                                  
7407  ***      2     50                          11                  push @properties, 'user', $user if $user;
7408  ***      2     50                           9                  push @properties, 'host', $host if $host;
7409           2    100                           9                  push @properties, 'db',   $db   if $db;
7410           2                                  8                  $db_for->{$thread_id} = $db;
7411                                                              }
7412                                                           }
7413                                                           elsif ( $cmd eq 'Init' ) {
7414           1                                  3               $cmd = 'Init DB';
7415           1                                  5               $arg =~ s/^DB\s+//;
7416           1                                  5               my ($db) = $arg =~ /(\S+)/;
7417           1                                  2               MKDEBUG && _d('Init DB:', $db);
7418  ***      1     50                           6               push @properties, 'db',   $db   if $db;
7419           1                                  3               $db_for->{$thread_id} = $db;
7420                                                           }
7421                                                  
7422           5                                 20            push @properties, 'arg', "administrator command: $cmd";
7423           5                                 19            push @properties, 'bytes', length($properties[-1]);
7424                                                        }
7425                                                  
7426           7                                 21         push @properties, 'Query_time', 0;
7427                                                  
7428           7                                 17         MKDEBUG && _d('Properties of event:', Dumper(\@properties));
7429           7                                 48         my $event = { @properties };
7430           7                                 46         return $event;
7431                                                     } # LINE
7432                                                  
7433           1                                  4      @{$self->{pending}} = ();
               1                                  5   
7434  ***      1     50                          11      $args{oktorun}->(0) if $args{oktorun};
7435           1                                  6      return;
7436                                                  }
7437                                                  
7438                                                  sub _d {
7439  ***      0                    0             0      my ($package, undef, $line) = caller 0;
7440  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
7441  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
7442                                                          @_;
7443  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
7444                                                  }
7445                                                  
7446                                                  1;
7447                                                  
7448                                                  # ###########################################################################
7449                                                  # End GeneralLogParser package
7450                                                  # ###########################################################################
7451                                                  
7452                                                  # ###########################################################################
7453                                                  # ProtocolParser package 5811
7454                                                  # ###########################################################################
7455                                                  package ProtocolParser;
7456                                                  
7457           7                    7            54   use strict;
               7                                 19   
               7                                 40   
7458           7                    7            45   use warnings FATAL => 'all';
               7                                 18   
               7                                 47   
7459           7                    7            41   use English qw(-no_match_vars);
               7                                 20   
               7                                 40   
7460                                                  
7461                                                  eval {
7462                                                     require IO::Uncompress::Inflate;
7463                                                     IO::Uncompress::Inflate->import(qw(inflate $InflateError));
7464                                                  };
7465                                                  
7466           7                    7            53   use Data::Dumper;
               7                                 19   
               7                                 40   
7467                                                  $Data::Dumper::Indent    = 1;
7468                                                  $Data::Dumper::Sortkeys  = 1;
7469                                                  $Data::Dumper::Quotekeys = 0;
7470                                                  
7471  ***      7            50      7            49   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 14   
               7                                112   
7472                                                  
7473                                                  sub new {
7474  ***      0                    0             0      my ( $class, %args ) = @_;
7475                                                  
7476  ***      0                                  0      my $self = {
7477                                                        server      => $args{server},
7478                                                        port        => $args{port},
7479                                                        sessions    => {},
7480                                                        o           => $args{o},
7481                                                     };
7482                                                  
7483  ***      0                                  0      return bless $self, $class;
7484                                                  }
7485                                                  
7486                                                  sub parse_event {
7487  ***      0                    0             0      my ( $self, %args ) = @_;
7488  ***      0                                  0      my @required_args = qw(event);
7489  ***      0                                  0      foreach my $arg ( @required_args ) {
7490  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
7491                                                     }
7492  ***      0                                  0      my $packet = @args{@required_args};
7493                                                  
7494  ***      0      0                           0      if ( $self->{buffer} ) {
7495  ***      0                                  0         my ($packet_from, $session) = $self->_get_session($packet);
7496  ***      0      0                           0         if ( $packet->{data_len} ) {
7497  ***      0      0                           0            if ( $packet_from eq 'client' ) {
7498  ***      0                                  0               push @{$session->{client_packets}}, $packet;
      ***      0                                  0   
7499  ***      0                                  0               MKDEBUG && _d('Saved client packet');
7500                                                           }
7501                                                           else {
7502  ***      0                                  0               push @{$session->{server_packets}}, $packet;
      ***      0                                  0   
7503  ***      0                                  0               MKDEBUG && _d('Saved server packet');
7504                                                           }
7505                                                        }
7506                                                  
7507  ***      0      0      0                    0         return unless ($packet_from eq 'client')
      ***                    0                        
7508                                                                      && ($packet->{fin} || $packet->{rst});
7509                                                  
7510  ***      0                                  0         my $event;
7511  ***      0                                  0         map {
7512  ***      0                                  0            $event = $self->_parse_packet($_, $args{misc});
7513  ***      0                                  0         } sort { $a->{seq} <=> $b->{seq} }
7514  ***      0                                  0         @{$session->{client_packets}};
7515                                                        
7516  ***      0                                  0         map {
7517  ***      0                                  0            $event = $self->_parse_packet($_, $args{misc});
7518  ***      0                                  0         } sort { $a->{seq} <=> $b->{seq} }
7519  ***      0                                  0         @{$session->{server_packets}};
7520                                                  
7521  ***      0                                  0         return $event;
7522                                                     }
7523                                                  
7524  ***      0      0                           0      if ( $packet->{data_len} == 0 ) {
7525  ***      0                                  0         MKDEBUG && _d('No TCP data');
7526  ***      0                                  0         return;
7527                                                     }
7528                                                  
7529  ***      0                                  0      return $self->_parse_packet($packet, $args{misc});
7530                                                  }
7531                                                  
7532                                                  sub _parse_packet {
7533  ***      0                    0             0      my ( $self, $packet, $misc ) = @_;
7534                                                  
7535  ***      0                                  0      my ($packet_from, $session) = $self->_get_session($packet);
7536  ***      0                                  0      MKDEBUG && _d('State:', $session->{state});
7537                                                  
7538  ***      0      0                           0      push @{$session->{raw_packets}}, $packet->{raw_packet}
      ***      0                                  0   
7539                                                        unless $misc->{recurse};
7540                                                  
7541  ***      0      0                           0      if ( $session->{buff} ) {
7542  ***      0                                  0         $session->{buff_left} -= $packet->{data_len};
7543  ***      0      0                           0         if ( $session->{buff_left} > 0 ) {
7544  ***      0                                  0            MKDEBUG && _d('Added data to buff; expecting', $session->{buff_left},
7545                                                              'more bytes');
7546  ***      0                                  0            return;
7547                                                        }
7548                                                  
7549  ***      0                                  0         MKDEBUG && _d('Got all data; buff left:', $session->{buff_left});
7550  ***      0                                  0         $packet->{data}       = $session->{buff} . $packet->{data};
7551  ***      0                                  0         $packet->{data_len}  += length $session->{buff};
7552  ***      0                                  0         $session->{buff}      = '';
7553  ***      0                                  0         $session->{buff_left} = 0;
7554                                                     }
7555                                                  
7556  ***      0      0                           0      $packet->{data} = pack('H*', $packet->{data}) unless $misc->{recurse};
7557  ***      0                                  0      my $event;
7558  ***      0      0                           0      if ( $packet_from eq 'server' ) {
      ***             0                               
7559  ***      0                                  0         $event = $self->_packet_from_server($packet, $session, $misc);
7560                                                     }
7561                                                     elsif ( $packet_from eq 'client' ) {
7562  ***      0                                  0         $event = $self->_packet_from_client($packet, $session, $misc);
7563                                                     }
7564                                                     else {
7565  ***      0                                  0         die 'Packet origin unknown';
7566                                                     }
7567  ***      0                                  0      MKDEBUG && _d('State:', $session->{state});
7568                                                  
7569  ***      0      0                           0      if ( $session->{out_of_order} ) {
7570  ***      0                                  0         MKDEBUG && _d('Session packets are out of order');
7571  ***      0                                  0         push @{$session->{packets}}, $packet;
      ***      0                                  0   
7572  ***      0      0      0                    0         $session->{ts_min}
7573                                                           = $packet->{ts} if $packet->{ts} lt ($session->{ts_min} || '');
7574  ***      0      0      0                    0         $session->{ts_max}
7575                                                           = $packet->{ts} if $packet->{ts} gt ($session->{ts_max} || '');
7576  ***      0      0                           0         if ( $session->{have_all_packets} ) {
7577  ***      0                                  0            MKDEBUG && _d('Have all packets; ordering and processing');
7578  ***      0                                  0            delete $session->{out_of_order};
7579  ***      0                                  0            delete $session->{have_all_packets};
7580  ***      0                                  0            map {
7581  ***      0                                  0               $event = $self->_parse_packet($_, { recurse => 1 });
7582  ***      0                                  0            } sort { $a->{seq} <=> $b->{seq} } @{$session->{packets}};
      ***      0                                  0   
7583                                                        }
7584                                                     }
7585                                                  
7586  ***      0                                  0      MKDEBUG && _d('Done with packet; event:', Dumper($event));
7587  ***      0                                  0      return $event;
7588                                                  }
7589                                                  
7590                                                  sub _get_session {
7591  ***      0                    0             0      my ( $self, $packet ) = @_;
7592                                                  
7593  ***      0                                  0      my $src_host = "$packet->{src_host}:$packet->{src_port}";
7594  ***      0                                  0      my $dst_host = "$packet->{dst_host}:$packet->{dst_port}";
7595                                                  
7596  ***      0      0                           0      if ( my $server = $self->{server} ) {  # Watch only the given server.
7597  ***      0                                  0         $server .= ":$self->{port}";
7598  ***      0      0      0                    0         if ( $src_host ne $server && $dst_host ne $server ) {
7599  ***      0                                  0            MKDEBUG && _d('Packet is not to or from', $server);
7600  ***      0                                  0            return;
7601                                                        }
7602                                                     }
7603                                                  
7604  ***      0                                  0      my $packet_from;
7605  ***      0                                  0      my $client;
7606  ***      0      0                           0      if ( $src_host =~ m/:$self->{port}$/ ) {
      ***             0                               
7607  ***      0                                  0         $packet_from = 'server';
7608  ***      0                                  0         $client      = $dst_host;
7609                                                     }
7610                                                     elsif ( $dst_host =~ m/:$self->{port}$/ ) {
7611  ***      0                                  0         $packet_from = 'client';
7612  ***      0                                  0         $client      = $src_host;
7613                                                     }
7614                                                     else {
7615  ***      0                                  0         warn 'Packet is not to or from server: ', Dumper($packet);
7616  ***      0                                  0         return;
7617                                                     }
7618  ***      0                                  0      MKDEBUG && _d('Client:', $client);
7619                                                  
7620  ***      0      0                           0      if ( !exists $self->{sessions}->{$client} ) {
7621  ***      0                                  0         MKDEBUG && _d('New session');
7622  ***      0                                  0         $self->{sessions}->{$client} = {
7623                                                           client      => $client,
7624                                                           state       => undef,
7625                                                           raw_packets => [],
7626                                                        };
7627                                                     };
7628  ***      0                                  0      my $session = $self->{sessions}->{$client};
7629                                                  
7630  ***      0                                  0      return $packet_from, $session;
7631                                                  }
7632                                                  
7633                                                  sub _packet_from_server {
7634  ***      0                    0             0      die "Don't call parent class _packet_from_server()";
7635                                                  }
7636                                                  
7637                                                  sub _packet_from_client {
7638  ***      0                    0             0      die "Don't call parent class _packet_from_client()";
7639                                                  }
7640                                                  
7641                                                  sub make_event {
7642  ***      0                    0             0      my ( $self, $session, $packet ) = @_;
7643  ***      0      0                           0      die "Event has no attributes" unless scalar keys %{$session->{attribs}};
      ***      0                                  0   
7644  ***      0      0                           0      die "Query has no arg attribute" unless $session->{attribs}->{arg};
7645  ***      0             0                    0      my $start_request = $session->{start_request} || 0;
7646  ***      0             0                    0      my $start_reply   = $session->{start_reply}   || 0;
7647  ***      0             0                    0      my $end_reply     = $session->{end_reply}     || 0;
7648  ***      0                                  0      MKDEBUG && _d('Request start:', $start_request,
7649                                                        'reply start:', $start_reply, 'reply end:', $end_reply);
7650  ***      0                                  0      my $event = {
7651                                                        Query_time    => $self->timestamp_diff($start_request, $start_reply),
7652                                                        Transmit_time => $self->timestamp_diff($start_reply, $end_reply),
7653                                                     };
7654  ***      0                                  0      @{$event}{keys %{$session->{attribs}}} = values %{$session->{attribs}};
      ***      0                                  0   
      ***      0                                  0   
      ***      0                                  0   
7655  ***      0                                  0      return $event;
7656                                                  }
7657                                                  
7658                                                  sub _get_errors_fh {
7659  ***      0                    0             0      my ( $self ) = @_;
7660  ***      0                                  0      my $errors_fh = $self->{errors_fh};
7661  ***      0      0                           0      return $errors_fh if $errors_fh;
7662                                                  
7663  ***      0                                  0      my $o = $self->{o};
7664  ***      0      0      0                    0      if ( $o && $o->has('tcpdump-errors') && $o->got('tcpdump-errors') ) {
      ***                    0                        
7665  ***      0                                  0         my $errors_file = $o->get('tcpdump-errors');
7666  ***      0                                  0         MKDEBUG && _d('tcpdump-errors file:', $errors_file);
7667  ***      0      0                           0         open $errors_fh, '>>', $errors_file
7668                                                           or die "Cannot open tcpdump-errors file $errors_file: $OS_ERROR";
7669                                                     }
7670                                                  
7671  ***      0                                  0      $self->{errors_fh} = $errors_fh;
7672  ***      0                                  0      return $errors_fh;
7673                                                  }
7674                                                  
7675                                                  sub fail_session {
7676  ***      0                    0             0      my ( $self, $session, $reason ) = @_;
7677  ***      0                                  0      my $errors_fh = $self->_get_errors_fh();
7678  ***      0      0                           0      if ( $errors_fh ) {
7679  ***      0                                  0         $session->{reason_for_failure} = $reason;
7680  ***      0                                  0         my $session_dump = '# ' . Dumper($session);
7681  ***      0                                  0         chomp $session_dump;
7682  ***      0                                  0         $session_dump =~ s/\n/\n# /g;
7683  ***      0                                  0         print $errors_fh "$session_dump\n";
7684                                                        {
7685  ***      0                                  0            local $LIST_SEPARATOR = "\n";
      ***      0                                  0   
7686  ***      0                                  0            print $errors_fh "@{$session->{raw_packets}}";
      ***      0                                  0   
7687  ***      0                                  0            print $errors_fh "\n";
7688                                                        }
7689                                                     }
7690  ***      0                                  0      MKDEBUG && _d('Failed session', $session->{client}, 'because', $reason);
7691  ***      0                                  0      delete $self->{sessions}->{$session->{client}};
7692  ***      0                                  0      return;
7693                                                  }
7694                                                  
7695                                                  sub timestamp_diff {
7696  ***      0                    0             0      my ( $self, $start, $end ) = @_;
7697  ***      0      0      0                    0      return 0 unless $start && $end;
7698  ***      0                                  0      my $sd = substr($start, 0, 11, '');
7699  ***      0                                  0      my $ed = substr($end,   0, 11, '');
7700  ***      0                                  0      my ( $sh, $sm, $ss ) = split(/:/, $start);
7701  ***      0                                  0      my ( $eh, $em, $es ) = split(/:/, $end);
7702  ***      0                                  0      my $esecs = ($eh * 3600 + $em * 60 + $es);
7703  ***      0                                  0      my $ssecs = ($sh * 3600 + $sm * 60 + $ss);
7704  ***      0      0                           0      if ( $sd eq $ed ) {
7705  ***      0                                  0         return sprintf '%.6f', $esecs - $ssecs;
7706                                                     }
7707                                                     else { # Assume only one day boundary has been crossed, no DST, etc
7708  ***      0                                  0         return sprintf '%.6f', ( 86_400 - $ssecs ) + $esecs;
7709                                                     }
7710                                                  }
7711                                                  
7712                                                  sub uncompress_data {
7713  ***      0                    0             0      my ( $self, $data, $len ) = @_;
7714  ***      0      0                           0      die "I need data" unless $data;
7715  ***      0      0                           0      die "I need a len argument" unless $len;
7716  ***      0      0                           0      die "I need a scalar reference to data" unless ref $data eq 'SCALAR';
7717  ***      0                                  0      MKDEBUG && _d('Uncompressing data');
7718  ***      0                                  0      our $InflateError;
7719                                                  
7720  ***      0                                  0      my $comp_bin_data = pack('H*', $$data);
7721                                                  
7722  ***      0                                  0      my $uncomp_bin_data = '';
7723  ***      0      0                           0      my $z = new IO::Uncompress::Inflate(
7724                                                        \$comp_bin_data
7725                                                     ) or die "IO::Uncompress::Inflate failed: $InflateError";
7726  ***      0      0                           0      my $status = $z->read(\$uncomp_bin_data, $len)
7727                                                        or die "IO::Uncompress::Inflate failed: $InflateError";
7728                                                  
7729  ***      0                                  0      my $uncomp_data = unpack('H*', $uncomp_bin_data);
7730                                                  
7731  ***      0                                  0      return \$uncomp_data;
7732                                                  }
7733                                                  
7734                                                  sub _d {
7735  ***      0                    0             0      my ($package, undef, $line) = caller 0;
7736  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
7737  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
7738                                                          @_;
7739  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
7740                                                  }
7741                                                  
7742                                                  1;
7743                                                  
7744                                                  # ###########################################################################
7745                                                  # End ProtocolParser package
7746                                                  # ###########################################################################
7747                                                  
7748                                                  # ###########################################################################
7749                                                  # HTTPProtocolParser package 5811
7750                                                  # ###########################################################################
7751                                                  package HTTPProtocolParser;
7752           7                    7            60   use base 'ProtocolParser';
               7                                 24   
               7                                 75   
7753                                                  
7754           7                    7            47   use strict;
               7                                 20   
               7                                 40   
7755           7                    7            42   use warnings FATAL => 'all';
               7                                 19   
               7                                 43   
7756           7                    7            48   use English qw(-no_match_vars);
               7                                 19   
               7                                 42   
7757                                                  
7758           7                    7            52   use Data::Dumper;
               7                                 34   
               7                                 41   
7759                                                  $Data::Dumper::Indent    = 1;
7760                                                  $Data::Dumper::Sortkeys  = 1;
7761                                                  $Data::Dumper::Quotekeys = 0;
7762                                                  
7763  ***      7            50      7            51   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 14   
               7                                110   
7764                                                  
7765                                                  sub new {
7766  ***      0                    0             0      my ( $class, %args ) = @_;
7767  ***      0                                  0      my $self = $class->SUPER::new(
7768                                                        %args,
7769                                                        port => 80,
7770                                                     );
7771  ***      0                                  0      return $self;
7772                                                  }
7773                                                  
7774                                                  sub _packet_from_server {
7775  ***      0                    0             0      my ( $self, $packet, $session, $misc ) = @_;
7776  ***      0      0                           0      die "I need a packet"  unless $packet;
7777  ***      0      0                           0      die "I need a session" unless $session;
7778                                                  
7779  ***      0                                  0      MKDEBUG && _d('Packet is from server; client state:', $session->{state}); 
7780                                                  
7781  ***      0      0                           0      if ( !$session->{state} ) {
7782  ***      0                                  0         MKDEBUG && _d('Ignoring mid-stream server response');
7783  ***      0                                  0         return;
7784                                                     }
7785                                                  
7786  ***      0      0                           0      if ( $session->{out_of_order} ) {
7787  ***      0                                  0         my ($line1, $content);
7788  ***      0      0                           0         if ( !$session->{have_header} ) {
7789  ***      0                                  0            ($line1, $content) = $self->_parse_header(
7790                                                              $session, $packet->{data}, $packet->{data_len});
7791                                                        }
7792  ***      0      0                           0         if ( $line1 ) {
7793  ***      0                                  0            $session->{have_header} = 1;
7794  ***      0                                  0            $packet->{content_len}  = length $content;
7795  ***      0                                  0            MKDEBUG && _d('Got out of order header with',
7796                                                              $packet->{content_len}, 'bytes of content');
7797                                                        }
7798  ***      0             0                    0         my $have_len = $packet->{content_len} || $packet->{data_len};
7799  ***      0                                  0         map { $have_len += $_->{data_len} }
      ***      0                                  0   
7800  ***      0                                  0            @{$session->{packets}};
7801  ***      0      0      0                    0         $session->{have_all_packets}
7802                                                           = 1 if $session->{attribs}->{bytes}
7803                                                                  && $have_len >= $session->{attribs}->{bytes};
7804  ***      0                                  0         MKDEBUG && _d('Have', $have_len, 'of', $session->{attribs}->{bytes});
7805  ***      0                                  0         return;
7806                                                     }
7807                                                  
7808  ***      0      0                           0      if ( $session->{state} eq 'awaiting reply' ) {
      ***             0                               
7809                                                  
7810  ***      0      0                           0         $session->{start_reply} = $packet->{ts} unless $session->{start_reply};
7811                                                  
7812  ***      0                                  0         my ($line1, $content) = $self->_parse_header($session, $packet->{data},
7813                                                              $packet->{data_len});
7814                                                  
7815  ***      0      0                           0         if ( !$line1 ) {
7816  ***      0                                  0            $session->{out_of_order}     = 1;  # alert parent
7817  ***      0                                  0            $session->{have_all_packets} = 0;
7818  ***      0                                  0            return;
7819                                                        }
7820                                                  
7821  ***      0                                  0         my ($version, $code, $phrase) = $line1 =~ m/(\S+)/g;
7822  ***      0                                  0         $session->{attribs}->{Status_code} = $code;
7823  ***      0                                  0         MKDEBUG && _d('Status code for last', $session->{attribs}->{arg},
7824                                                           'request:', $session->{attribs}->{Status_code});
7825                                                  
7826  ***      0      0                           0         my $content_len = $content ? length $content : 0;
7827  ***      0                                  0         MKDEBUG && _d('Got', $content_len, 'bytes of content');
7828  ***      0      0      0                    0         if ( $session->{attribs}->{bytes}
7829                                                             && $content_len < $session->{attribs}->{bytes} ) {
7830  ***      0                                  0            $session->{data_len}  = $session->{attribs}->{bytes};
7831  ***      0                                  0            $session->{buff}      = $content;
7832  ***      0                                  0            $session->{buff_left} = $session->{attribs}->{bytes} - $content_len;
7833  ***      0                                  0            MKDEBUG && _d('Contents not complete,', $session->{buff_left},
7834                                                              'bytes left');
7835  ***      0                                  0            $session->{state} = 'recving content';
7836  ***      0                                  0            return;
7837                                                        }
7838                                                     }
7839                                                     elsif ( $session->{state} eq 'recving content' ) {
7840  ***      0      0                           0         if ( $session->{buff} ) {
7841  ***      0                                  0            MKDEBUG && _d('Receiving content,', $session->{buff_left},
7842                                                              'bytes left');
7843  ***      0                                  0            return;
7844                                                        }
7845  ***      0                                  0         MKDEBUG && _d('Contents received');
7846                                                     }
7847                                                     else {
7848  ***      0                                  0         warn "Server response in unknown state"; 
7849  ***      0                                  0         return;
7850                                                     }
7851                                                  
7852  ***      0                                  0      MKDEBUG && _d('Creating event, deleting session');
7853  ***      0             0                    0      $session->{end_reply} = $session->{ts_max} || $packet->{ts};
7854  ***      0                                  0      my $event = $self->make_event($session, $packet);
7855  ***      0                                  0      delete $self->{sessions}->{$session->{client}}; # http is stateless!
7856  ***      0                                  0      return $event;
7857                                                  }
7858                                                  
7859                                                  sub _packet_from_client {
7860  ***      0                    0             0      my ( $self, $packet, $session, $misc ) = @_;
7861  ***      0      0                           0      die "I need a packet"  unless $packet;
7862  ***      0      0                           0      die "I need a session" unless $session;
7863                                                  
7864  ***      0                                  0      MKDEBUG && _d('Packet is from client; state:', $session->{state});
7865                                                  
7866  ***      0                                  0      my $event;
7867  ***      0      0      0                    0      if ( ($session->{state} || '') =~ m/awaiting / ) {
7868  ***      0                                  0         MKDEBUG && _d('More client headers:', $packet->{data});
7869  ***      0                                  0         return;
7870                                                     }
7871                                                  
7872  ***      0      0                           0      if ( !$session->{state} ) {
7873  ***      0                                  0         $session->{state} = 'awaiting reply';
7874  ***      0                                  0         my ($line1, undef) = $self->_parse_header($session, $packet->{data}, $packet->{data_len});
7875  ***      0                                  0         my ($request, $page, $version) = $line1 =~ m/(\S+)/g;
7876  ***      0      0      0                    0         if ( !$request || !$page ) {
7877  ***      0                                  0            MKDEBUG && _d("Didn't get a request or page:", $request, $page);
7878  ***      0                                  0            return;
7879                                                        }
7880  ***      0                                  0         $request = lc $request;
7881  ***      0             0                    0         my $vh   = $session->{attribs}->{Virtual_host} || '';
7882  ***      0                                  0         my $arg = "$request $vh$page";
7883  ***      0                                  0         MKDEBUG && _d('arg:', $arg);
7884                                                  
7885  ***      0      0      0                    0         if ( $request eq 'get' || $request eq 'post' ) {
7886  ***      0                                  0            @{$session->{attribs}}{qw(arg)} = ($arg);
      ***      0                                  0   
7887                                                        }
7888                                                        else {
7889  ***      0                                  0            MKDEBUG && _d("Don't know how to handle a", $request, "request");
7890  ***      0                                  0            return;
7891                                                        }
7892                                                  
7893  ***      0                                  0         $session->{start_request}         = $packet->{ts};
7894  ***      0                                  0         $session->{attribs}->{host}       = $packet->{src_host};
7895  ***      0                                  0         $session->{attribs}->{pos_in_log} = $packet->{pos_in_log};
7896  ***      0                                  0         $session->{attribs}->{ts}         = $packet->{ts};
7897                                                     }
7898                                                     else {
7899  ***      0                                  0         die "Probably multiple GETs from client before a server response?"; 
7900                                                     }
7901                                                  
7902  ***      0                                  0      return $event;
7903                                                  }
7904                                                  
7905                                                  sub _parse_header {
7906  ***      0                    0             0      my ( $self, $session, $data, $len, $no_recurse ) = @_;
7907  ***      0      0                           0      die "I need data" unless $data;
7908  ***      0                                  0      my ($header, $content)    = split(/\r\n\r\n/, $data);
7909  ***      0                                  0      my ($line1, $header_vals) = $header  =~ m/\A(\S+ \S+ .+?)\r\n(.+)?/s;
7910  ***      0                                  0      MKDEBUG && _d('HTTP header:', $line1);
7911  ***      0      0                           0      return unless $line1;
7912                                                  
7913  ***      0      0                           0      if ( !$header_vals ) {
7914  ***      0                                  0         MKDEBUG && _d('No header vals');
7915  ***      0                                  0         return $line1, undef;
7916                                                     }
7917  ***      0                                  0      my @headers;
7918  ***      0                                  0      foreach my $val ( split(/\r\n/, $header_vals) ) {
7919  ***      0      0                           0         last unless $val;
7920  ***      0                                  0         MKDEBUG && _d('HTTP header:', $val);
7921  ***      0      0                           0         if ( $val =~ m/^Content-Length/i ) {
7922  ***      0                                  0            ($session->{attribs}->{bytes}) = $val =~ /: (\d+)/;
7923  ***      0                                  0            MKDEBUG && _d('Saved Content-Length:', $session->{attribs}->{bytes});
7924                                                        }
7925  ***      0      0                           0         if ( $val =~ m/Content-Encoding/i ) {
7926  ***      0                                  0            ($session->{compressed}) = $val =~ /: (\w+)/;
7927  ***      0                                  0            MKDEBUG && _d('Saved Content-Encoding:', $session->{compressed});
7928                                                        }
7929  ***      0      0                           0         if ( $val =~ m/^Host/i ) {
7930  ***      0                                  0            ($session->{attribs}->{Virtual_host}) = $val =~ /: (\S+)/;
7931  ***      0                                  0            MKDEBUG && _d('Saved Host:', ($session->{attribs}->{Virtual_host}));
7932                                                        }
7933                                                     }
7934  ***      0                                  0      return $line1, $content;
7935                                                  }
7936                                                  
7937                                                  sub _d {
7938  ***      0                    0             0      my ($package, undef, $line) = caller 0;
7939  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
7940  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
7941                                                          @_;
7942  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
7943                                                  }
7944                                                  
7945                                                  1;
7946                                                  
7947                                                  # ###########################################################################
7948                                                  # End HTTPProtocolParser package
7949                                                  # ###########################################################################
7950                                                  
7951                                                  # ###########################################################################
7952                                                  # ExecutionThrottler package 5266
7953                                                  # ###########################################################################
7954                                                  package ExecutionThrottler;
7955                                                  
7956           7                    7            64   use strict;
               7                                 48   
               7                                 60   
7957           7                    7            49   use warnings FATAL => 'all';
               7                                 23   
               7                                 45   
7958           7                    7            46   use English qw(-no_match_vars);
               7                                 16   
               7                                 40   
7959                                                  
7960           7                    7            58   use List::Util qw(sum min max);
               7                                 23   
               7                                 47   
7961           7                    7            51   use Time::HiRes qw(time);
               7                                 20   
               7                                 50   
7962           7                    7            47   use Data::Dumper;
               7                                 16   
               7                                 43   
7963                                                  $Data::Dumper::Indent    = 1;
7964                                                  $Data::Dumper::Sortkeys  = 1;
7965                                                  $Data::Dumper::Quotekeys = 0;
7966                                                  
7967  ***      7            50      7            46   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 18   
               7                                123   
7968                                                  
7969                                                  sub new {
7970  ***      0                    0             0      my ( $class, %args ) = @_;
7971  ***      0                                  0      my @required_args = qw(rate_max get_rate check_int step);
7972  ***      0                                  0      foreach my $arg ( @required_args ) {
7973  ***      0      0                           0         die "I need a $arg argument" unless defined $args{$arg};
7974                                                     }
7975  ***      0                                  0      my $self = {
7976                                                        step       => 0.05,  # default
7977                                                        %args, 
7978                                                        rate_ok    => undef,
7979                                                        last_check => undef,
7980                                                        stats      => {
7981                                                           rate_avg     => 0,
7982                                                           rate_samples => [],
7983                                                        },
7984                                                        int_rates  => [],
7985                                                        skip_prob  => 0.0,
7986                                                     };
7987                                                  
7988  ***      0                                  0      return bless $self, $class;
7989                                                  }
7990                                                  
7991                                                  sub throttle {
7992  ***      0                    0             0      my ( $self, %args ) = @_;
7993  ***      0             0                    0      my $time = $args{misc}->{time} || time;
7994  ***      0      0                           0      if ( $self->_time_to_check($time) ) {
7995  ***      0                                  0         my $rate_avg = (sum(@{$self->{int_rates}})   || 0)
      ***      0                                  0   
7996  ***      0             0                    0                      / (scalar @{$self->{int_rates}} || 1);
      ***                    0                        
7997  ***      0                                  0         my $running_avg = $self->_save_rate_avg($rate_avg);
7998  ***      0                                  0         MKDEBUG && _d('Average rate for last interval:', $rate_avg);
7999                                                  
8000  ***      0      0                           0         if ( $args{stats} ) {
8001  ***      0                                  0            $args{stats}->{throttle_checked_rate}++;
8002  ***      0                                  0            $args{stats}->{throttle_rate_avg} = sprintf '%.2f', $running_avg;
8003                                                        }
8004                                                  
8005  ***      0                                  0         @{$self->{int_rates}} = ();
      ***      0                                  0   
8006                                                  
8007  ***      0      0                           0         if ( $rate_avg > $self->{rate_max} ) {
8008  ***      0                                  0            $self->{skip_prob} += $self->{step};
8009  ***      0      0                           0            $self->{skip_prob}  = 1.0 if $self->{skip_prob} > 1.0;
8010  ***      0                                  0            MKDEBUG && _d('Rate max exceeded');
8011  ***      0      0                           0            $args{stats}->{throttle_rate_max_exceeded}++ if $args{stats};
8012                                                        }
8013                                                        else {
8014  ***      0                                  0            $self->{skip_prob} -= $self->{step};
8015  ***      0      0                           0            $self->{skip_prob} = 0.0 if $self->{skip_prob} < 0.0;
8016  ***      0      0                           0            $args{stats}->{throttle_rate_ok}++ if $args{stats};
8017                                                        }
8018                                                  
8019  ***      0                                  0         MKDEBUG && _d('Skip probability:', $self->{skip_prob});
8020  ***      0                                  0         $self->{last_check} = $time;
8021                                                     }
8022                                                     else {
8023  ***      0                                  0         my $current_rate = $self->{get_rate}->();
8024  ***      0                                  0         push @{$self->{int_rates}}, $current_rate;
      ***      0                                  0   
8025  ***      0      0                           0         if ( $args{stats} ) {
8026  ***      0             0                    0            $args{stats}->{throttle_rate_min} = min(
8027                                                              ($args{stats}->{throttle_rate_min} || ()), $current_rate);
8028  ***      0             0                    0            $args{stats}->{throttle_rate_max} = max(
8029                                                              ($args{stats}->{throttle_rate_max} || ()), $current_rate);
8030                                                        }
8031  ***      0                                  0         MKDEBUG && _d('Current rate:', $current_rate);
8032                                                     } 
8033                                                  
8034  ***      0      0                           0      if ( $args{event} ) {
8035  ***      0      0                           0         $args{event}->{Skip_exec} = $self->{skip_prob} <= rand() ? 'No' : 'Yes';
8036                                                     }
8037                                                  
8038  ***      0                                  0      return $args{event};
8039                                                  }
8040                                                  
8041                                                  sub _time_to_check {
8042  ***      0                    0             0      my ( $self, $time ) = @_;
8043  ***      0      0                           0      if ( !$self->{last_check} ) {
8044  ***      0                                  0         $self->{last_check} = $time;
8045  ***      0                                  0         return 0;
8046                                                     }
8047  ***      0      0                           0      return $time - $self->{last_check} >= $self->{check_int} ? 1 : 0;
8048                                                  }
8049                                                  
8050                                                  sub rate_avg {
8051  ***      0                    0             0      my ( $self ) = @_;
8052  ***      0             0                    0      return $self->{stats}->{rate_avg} || 0;
8053                                                  }
8054                                                  
8055                                                  sub skip_probability {
8056  ***      0                    0             0      my ( $self ) = @_;
8057  ***      0                                  0      return $self->{skip_prob};
8058                                                  }
8059                                                  
8060                                                  sub _save_rate_avg {
8061  ***      0                    0             0      my ( $self, $rate ) = @_;
8062  ***      0                                  0      my $samples  = $self->{stats}->{rate_samples};
8063  ***      0                                  0      push @$samples, $rate;
8064  ***      0      0                           0      shift @$samples if @$samples > 1_000;
8065  ***      0                                  0      $self->{stats}->{rate_avg} = sum(@$samples) / (scalar @$samples);
8066  ***      0             0                    0      return $self->{stats}->{rate_avg} || 0;
8067                                                  }
8068                                                  
8069                                                  sub _d {
8070  ***      0                    0             0      my ($package, undef, $line) = caller 0;
8071  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
8072  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
8073                                                          @_;
8074  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
8075                                                  }
8076                                                  
8077                                                  1;
8078                                                  
8079                                                  # ###########################################################################
8080                                                  # End ExecutionThrottler package
8081                                                  # ###########################################################################
8082                                                  
8083                                                  # ###########################################################################
8084                                                  # This is a combination of modules and programs in one -- a runnable module.
8085                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
8086                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
8087                                                  #
8088                                                  # Check at the end of this package for the call to main() which actually runs
8089                                                  # the program.
8090                                                  # ###########################################################################
8091                                                  package mk_query_digest;
8092                                                  
8093           7                    7            54   use English qw(-no_match_vars);
               7                                 19   
               7                                 43   
8094           7                    7            76   use Time::Local qw(timelocal);
               7                                 20   
               7                                 41   
8095           7                    7            45   use Time::HiRes qw(time usleep);
               7                                 16   
               7                                 41   
8096           7                    7            48   use List::Util qw(max);
               7                                 27   
               7                                 37   
8097           7                    7            44   use POSIX qw(signal_h);
               7                                 17   
               7                                 48   
8098           7                    7            50   use Data::Dumper;
               7                                 19   
               7                                 40   
8099                                                  $Data::Dumper::Indent = 1;
8100                                                  $OUTPUT_AUTOFLUSH     = 1;
8101                                                  
8102                                                  Transformers->import(qw(shorten micro_t percentage_of ts make_checksum
8103                                                     any_unix_timestamp));
8104                                                  
8105  ***      7            50      7            51   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               7                                 19   
               7                                108   
8106                                                  
8107           7                    7            95   use sigtrap 'handler', \&sig_int, 'normal-signals';
               7                                 21   
               7                                130   
8108                                                  
8109                                                  # Global variables.  Only really essential variables should be here.
8110                                                  my $oktorun = 1;
8111                                                  my $dp = new DSNParser (
8112                                                     { key => 'D', copy => 1, desc => 'Database that contains the query review table' },
8113                                                     { key => 't', desc => 'Table to use as the query review table' } );
8114                                                  my $q  = new Quoter();
8115                                                  my $qp = new QueryParser();
8116                                                  my $qr = new QueryRewriter(QueryParser=>$qp);
8117                                                  my $ex_dbh;  # For --execute
8118                                                  my $ep_dbh;  # For --explain
8119                                                  my $ps_dbh;  # For Processlist
8120                                                  my $aux_dbh; # For --aux-dsn (--since/--until "MySQL expression")
8121                                                  
8122                                                  sub main {
8123          54                   54         91192      @ARGV = @_;  # set global ARGV for this package
8124                                                  
8125                                                     # ##########################################################################
8126                                                     # Get configuration information.
8127                                                     # ##########################################################################
8128          54                               1479      my $o = new OptionParser(
8129                                                        strict      => 0,
8130                                                        dp          => $dp,
8131                                                        prompt      => '[OPTION...] [FILE]',
8132                                                        description => q{parses and analyzes MySQL log files.  With no }
8133                                                                     . q{FILE, or when FILE is -, read standard input.},
8134                                                     );
8135          54                                446      $o->get_specs();
8136          54                                634      $o->get_opts();
8137                                                  
8138          54                                335      $dp->prop('set-vars', $o->get('set-vars'));
8139                                                  
8140                                                     # Frequently used options.
8141          54                                262      my $review_dsn = $o->get('review'); 
8142          54                                202      my @groupby    = @{$o->get('group-by')};
              54                                254   
8143          54                                250      my @orderby;
8144  ***     54    100     66                  241      if ( (grep { $_ eq 'genlog' || $_ eq 'GeneralLogParser' } @{$o->get('type')})
              54    100                        1077   
              54                                261   
8145                                                          && !$o->got('order-by') ) {
8146           1                                  4         @orderby = 'Query_time:cnt';
8147                                                     }
8148                                                     else { 
8149          53                                164         @orderby = @{$o->get('order-by')};
              53                                273   
8150                                                     }
8151                                                  
8152  ***     54     50                         338      if ( !$o->get('help') ) {
8153  ***     54     50      0                  372         if ( $review_dsn
      ***                   33                        
8154                                                             && (!defined $review_dsn->{D} || !defined $review_dsn->{t}) ) {
8155  ***      0                                  0            $o->save_error('The --review DSN requires a D (database) and t'
8156                                                              . ' (table) part specifying the query review table');
8157                                                        }
8158  ***     54     50      0                  244         if ( $o->get('mirror')
      ***                   33                        
8159                                                             && (!$o->get('execute') || !$o->get('processlist')) ) {
8160  ***      0                                  0            $o->save_error('--mirror requires --execute and --processlist');
8161                                                        }
8162  ***     54     50     33                  246         if ( $o->get('outliers')
              54                                838   
8163          54                                250            && grep { $_ !~ m/^\w+:[0-9.]+(?::[0-9.]+)?$/ } @{$o->get('outliers')}
8164                                                        ) {
8165  ***      0                                  0            $o->save_error('--outliers requires two or three colon-separated fields');
8166                                                        }
8167  ***     54     50                         263         if ( $o->get('execute-throttle') ) {
8168  ***      0                                  0            my ($rate_max, $int, $step) = @{$o->get('execute-throttle')};
      ***      0                                  0   
8169  ***      0      0      0                    0            $o->save_error("--execute-throttle max time must be between 1 and 100")
      ***                    0                        
8170                                                              unless $rate_max && $rate_max > 0 && $rate_max <= 100;
8171  ***      0      0                           0            $o->save_error("No check interval value for --execute-throttle")
8172                                                              unless $int;
8173  ***      0      0                           0            $o->save_error("--execute-throttle check interval must be an integer")
8174                                                              if $int =~ m/[^\d]/;
8175  ***      0      0      0                    0            $o->save_error("--execute-throttle step must be between 1 and 100")
      ***                    0                        
8176                                                              if $step && ($step < 1 || $step > 100);
8177                                                        }
8178                                                     }
8179                                                  
8180                                                     # Set an orderby for each groupby; use the default orderby if there
8181                                                     # are more groupby than orderby attribs.
8182          54                                339      my $default_orderby = $o->get_defaults()->{'order-by'};
8183          54                                590      foreach my $i ( 0..$#groupby ) {
8184          55           100                  482         $orderby[$i] ||= $default_orderby;
8185                                                     }
8186          54                                445      $o->set('order-by', \@orderby);
8187                                                  
8188          54                                399      $o->usage_or_errors();
8189                                                  
8190                                                     # ########################################################################
8191                                                     # Set up for --explain
8192                                                     # ########################################################################
8193          54    100                         298      if ( my $ep_dsn = $o->get('explain') ) {
8194           3                                 41         $ep_dbh = get_cxn(
8195                                                           for          => '--explain',
8196                                                           dsn          => $ep_dsn,
8197                                                           OptionParser => $o,
8198                                                           DSNParser    => $dp,
8199                                                           opts         => { AutoCommit => 1 },
8200                                                        );
8201           3                                 23         $ep_dbh->{InactiveDestroy}  = 1;  # Don't die on fork().
8202                                                     }
8203                                                  
8204                                                     # ########################################################################
8205                                                     # Set up for --review and --review-history.
8206                                                     # ########################################################################
8207          54                                191      my $qv;      # QueryReview
8208          54                                147      my $qv_dbh;  # For QueryReview
8209          54                                169      my $qv_dbh2; # For QueryReview and --review-history
8210  ***     54     50                         232      if ( $review_dsn ) {
8211  ***      0                                  0         my $tp  = new TableParser(Quoter => $q);
8212  ***      0                                  0         my $du  = new MySQLDump();
8213  ***      0                                  0         $qv_dbh = get_cxn(
8214                                                           for          => '--review',
8215                                                           dsn          => $review_dsn,
8216                                                           OptionParser => $o,
8217                                                           DSNParser    => $dp,
8218                                                           opts         => { AutoCommit => 1 },
8219                                                        );
8220  ***      0                                  0         $qv_dbh->{InactiveDestroy}  = 1;  # Don't die on fork().
8221  ***      0                                  0         my @db_tbl = @{$review_dsn}{qw(D t)};
      ***      0                                  0   
8222  ***      0                                  0         my $db_tbl = $q->quote(@db_tbl);
8223                                                  
8224                                                        # Create the review table if desired
8225  ***      0      0                           0         if ( $o->get('create-review-table') ) {
8226  ***      0                                  0            my $sql = $o->read_para_after(
8227                                                              __FILE__, qr/MAGIC_create_review/);
8228  ***      0                                  0            $sql =~ s/query_review/IF NOT EXISTS $db_tbl/;
8229  ***      0                                  0            MKDEBUG && _d($sql);
8230  ***      0                                  0            $qv_dbh->do($sql);
8231                                                        }
8232                                                  
8233                                                        # Check for existence and the permissions to insert into the
8234                                                        # table.
8235  ***      0      0                           0         if ( !$tp->check_table(
8236                                                              dbh       => $qv_dbh,
8237                                                              db        => $db_tbl[0],
8238                                                              tbl       => $db_tbl[1],
8239                                                              all_privs => 1) )
8240                                                        {
8241  ***      0                                  0            die "The query review table $db_tbl "
8242                                                              . "does not exist or you do not have INSERT privileges";
8243                                                        }
8244                                                  
8245                                                        # Set up the new QueryReview object.
8246  ***      0                                  0         my $struct = $tp->parse($du->get_create_table($qv_dbh, $q, @db_tbl));
8247  ***      0                                  0         $qv = new QueryReview(
8248                                                           dbh         => $qv_dbh,
8249                                                           db_tbl      => $db_tbl,
8250                                                           tbl_struct  => $struct,
8251                                                           quoter      => $q,
8252                                                        );
8253                                                  
8254                                                        # Set up the review-history table
8255  ***      0      0                           0         if ( my $review_history_dsn = $o->get('review-history') ) {
8256  ***      0                                  0            $qv_dbh2 = get_cxn(
8257                                                              for          => '--review-history',
8258                                                              dsn          => $review_history_dsn,
8259                                                              OptionParser => $o,
8260                                                              DSNParser    => $dp,
8261                                                              opts         => { AutoCommit => 1 },
8262                                                           );
8263  ***      0                                  0            $qv_dbh2->{InactiveDestroy}  = 1;  # Don't die on fork().
8264  ***      0                                  0            my @hdb_tbl = @{$o->get('review-history')}{qw(D t)};
      ***      0                                  0   
8265  ***      0                                  0            my $hdb_tbl = $q->quote(@hdb_tbl);
8266                                                  
8267                                                           # Create the review-history table if desired
8268  ***      0      0                           0            if ( $o->get('create-review-history-table') ) {
8269  ***      0                                  0               my $sql = $o->read_para_after(
8270                                                                 __FILE__, qr/MAGIC_create_review_history/);
8271  ***      0                                  0               $sql =~ s/query_review_history/IF NOT EXISTS $hdb_tbl/;
8272  ***      0                                  0               MKDEBUG && _d($sql);
8273  ***      0                                  0               $qv_dbh2->do($sql);
8274                                                           }
8275                                                  
8276                                                           # Check for existence and the permissions to insert into the
8277                                                           # table.
8278  ***      0      0                           0            if ( !$tp->check_table(
8279                                                                 dbh       => $qv_dbh2,
8280                                                                 db        => $hdb_tbl[0],
8281                                                                 tbl       => $hdb_tbl[1],
8282                                                                 all_privs => 1) )
8283                                                           {
8284  ***      0                                  0               die "The query review history table $hdb_tbl "
8285                                                                 . "does not exist or you do not have INSERT privileges";
8286                                                           }
8287                                                  
8288                                                           # Inspect for MAGIC_history_cols.  Add them to the --select list
8289                                                           # only if an explicit --select list was given.  Otherwise, leave
8290                                                           # --select undef which will cause EventAggregator to aggregate every
8291                                                           # attribute available which will include the history columns.
8292                                                           # If no --select list was given and we make one by adding the history
8293                                                           # columsn to it, then EventAggregator will only aggregate the
8294                                                           # history columns and nothing else--we don't want this.
8295  ***      0                                  0            my $tbl = $tp->parse($du->get_create_table($qv_dbh2, $q, @hdb_tbl));
8296  ***      0                                  0            my $pat = $o->read_para_after(__FILE__, qr/MAGIC_history_cols/);
8297  ***      0                                  0            $pat    =~ s/\s+//g;
8298  ***      0                                  0            $pat    = qr/^(.*?)_($pat)$/;
8299                                                           # Get original --select values.
8300  ***      0                                  0            my %select = map { $_ => 1 } @{$o->get('select')};
      ***      0                                  0   
      ***      0                                  0   
8301  ***      0                                  0            foreach my $col ( @{$tbl->{cols}} ) {
      ***      0                                  0   
8302  ***      0                                  0               my ( $attr, $metric ) = $col =~ m/$pat/;
8303  ***      0      0      0                    0               next unless $attr && $metric;
8304  ***      0      0                           0               $attr = ucfirst $attr if $attr =~ m/_/; # TableParser lowercases
8305                                                              # Add history table values to original select values.
8306  ***      0                                  0               $select{$attr}++;
8307                                                           }
8308                                                  
8309  ***      0      0                           0            if ( $o->got('select') ) {
8310                                                              # Re-set --select with its original values plus the history
8311                                                              # table values.
8312  ***      0                                  0               $o->set('select', [keys %select]);
8313                                                              MKDEBUG && _d("--select after parsing --review-history table:", 
8314  ***      0                                  0                  @{$o->get('select')});
8315                                                           }
8316                                                  
8317                                                           # And tell the QueryReview that it has more work to do.
8318                                                           $qv->set_history_options(
8319  ***      0                                  0               table      => $hdb_tbl,
8320                                                              dbh        => $qv_dbh2,
8321                                                              tbl_struct => $tbl,
8322                                                              col_pat    => $pat,
8323                                                           );
8324                                                        }
8325                                                     }
8326                                                     
8327                                                     # ########################################################################
8328                                                     # Set up an array of callbacks to filter and transform events.  The first
8329                                                     # one should add the fingerprint to the event (except if we're parsing
8330                                                     # tcpdump output; see below).  After that, callbacks can do anything, as
8331                                                     # long as they return the event (failing to return the event terminates
8332                                                     # the chain).
8333                                                     # ########################################################################
8334          54                                234      my @callbacks;
8335          54                                147      my %callback_names;
8336          54                                162      my %prof;  # pipeline profile
8337          54                                149      my %stats; # general stats
8338          54                                230      my $misc = {};
8339  ***     54     50                         279      if ( my $ps_dsn = $o->get('processlist') ) {
8340  ***      0                                  0         my $pl = new Processlist();
8341  ***      0                                  0         my ( $sth, $cxn );
8342  ***      0                                  0         my $cur_server = 'processlist';
8343  ***      0                                  0         my $cur_time   = 0;
8344                                                  
8345  ***      0      0                           0         if ( $o->get('ask-pass') ) {
8346  ***      0                                  0            $ps_dsn->{p} = OptionParser::prompt_noecho("Enter password for "
8347                                                              . "--processlist: ");
8348  ***      0                                  0            $o->get('processlist', $ps_dsn);
8349                                                        }
8350                                                  
8351                                                        $misc = {
8352                                                           time  => 0,
8353                                                           etime => 0,
8354                                                           code  => sub {
8355  ***      0                    0             0               my $time = $misc->{time} = time();
8356  ***      0                                  0               my $err;
8357  ***      0             0                    0               do {
8358  ***      0                                  0                  eval { $sth->execute; };
      ***      0                                  0   
8359  ***      0                                  0                  $err = $EVAL_ERROR;
8360  ***      0      0                           0                  if ( $err ) { # Try to reconnect when there's an error.
8361  ***      0                                  0                     @{$misc}{qw(time etime)} = (0, 0);
      ***      0                                  0   
8362  ***      0                                  0                     eval {
8363  ***      0                                  0                        ($cur_server, $ps_dbh) = find_role(
8364                                                                          OptionParser => $o,
8365                                                                          DSNParser    => $dp,
8366                                                                          dbh          => $ps_dbh,
8367                                                                          current      => $cur_server,
8368                                                                          read_only    => 0,
8369                                                                          comment      => 'for --processlist'
8370                                                                       );
8371  ***      0                                  0                        $cur_time = time();
8372  ***      0                                  0                        $sth      = $ps_dbh->prepare('SHOW FULL PROCESSLIST');
8373  ***      0                                  0                        $cxn      = $ps_dbh->{mysql_thread_id};
8374  ***      0                                  0                        $sth->execute();
8375                                                                    };
8376  ***      0                                  0                     $err = $EVAL_ERROR;
8377  ***      0      0                           0                     if ( $err ) {
8378  ***      0                                  0                        print STDERR $err;
8379  ***      0                                  0                        sleep 1;
8380                                                                    }
8381                                                                 }
8382                                                              } until ( $sth && !$err );
8383  ***      0      0      0                    0               if ( $o->get('mirror')
8384                                                                   && time() - $cur_time > $o->get('mirror')) {
8385  ***      0                                  0                  ($cur_server, $ps_dbh) = find_role(
8386                                                                    OptionParser => $o,
8387                                                                    DSNParser    => $dp,
8388                                                                    dbh          => $ps_dbh,
8389                                                                    current      => $cur_server,
8390                                                                    read_only    => 0,
8391                                                                    comment      => 'for --processlist'
8392                                                                 );
8393  ***      0                                  0                  $cur_time = time();
8394                                                              }
8395  ***      0                                  0               $misc->{etime} = time() - $time;
8396  ***      0                                  0               [ grep { $_->[0] != $cxn } @{ $sth->fetchall_arrayref(); } ];
      ***      0                                  0   
      ***      0                                  0   
8397                                                           },
8398  ***      0                                  0         };
8399                                                  
8400                                                        push @callbacks, sub {
8401  ***      0                    0             0            my ( $event, %args ) = @_;
8402  ***      0                                  0            return $pl->parse_event(%args);
8403  ***      0                                  0         };
8404  ***      0                                  0         $callback_names{$callbacks[-1]} = ref $pl;
8405  ***      0                                  0         MKDEBUG && _d('Added Processlist module to callbacks');
8406                                                     }
8407                                                     else {
8408          54                               1094         my %alias_for = (
8409                                                           slowlog   => ['SlowLogParser'],
8410                                                           binlog    => ['BinaryLogParser'],
8411                                                           genlog    => ['GeneralLogParser'],
8412                                                           tcpdump   => ['TcpdumpParser','MySQLProtocolParser'],
8413                                                           memcached => ['TcpdumpParser','MemcachedProtocolParser',
8414                                                                         'MemcachedEvent'],
8415                                                           http      => ['TcpdumpParser','HTTPProtocolParser'],
8416                                                        );
8417          54                                270         my $type = $o->get('type');
8418  ***     54     50                         364         $type    = $alias_for{$type->[0]} if $alias_for{$type->[0]};
8419                                                  
8420          54                                172         my ($server, $port);
8421          54    100                         243         if ( my $watch_server = $o->get('watch-server') ) {
8422                                                           # This should match all combinations of HOST and PORT except
8423                                                           # "host-name.port" because "host.mysql" could be either
8424                                                           # host "host" and port "mysql" or just host "host.mysql"
8425                                                           # (e.g. if someone added "127.1 host.mysql" to etc/hosts).
8426                                                           # So host-name* requires a colon between it and a port.
8427           9                                102            ($server, $port) = $watch_server
8428                                                                 =~ m/^((?:\d+\.\d+\.\d+\.\d+|[\w\.\-]+\w))(?:[\:\.](\S+))?/;
8429           9                                 38            MKDEBUG && _d('Watch server', $server, 'port', $port);
8430                                                        }
8431                                                  
8432          54                                236         foreach my $module ( @$type ) {
8433          66                                177            my $parser;
8434          66                                220            eval {
8435          66                               1263               $parser = $module->new(
8436                                                                 server => $server,
8437                                                                 port   => $port,
8438                                                                 o      => $o,
8439                                                              );
8440                                                           };
8441  ***     66     50                         296            if ( $EVAL_ERROR ) {
8442  ***      0                                  0               die "Failed to load $module module: $EVAL_ERROR";
8443                                                           }
8444                                                           push @callbacks, sub {
8445         588                  588          5369               my ( $event, %args ) = @_;
8446         588                               4672               return $parser->parse_event(%args);
8447          66                                805            };
8448          66                                420            $callback_names{$callbacks[-1]} = ref $parser;
8449          66                                430            MKDEBUG && _d('Added', $module, 'module to callbacks');
8450                                                        }
8451                                                     }
8452                                                  
8453                                                     # Filter early for --since and --until.
8454          54                                164      my $past_since;
8455          54                                152      my $at_until;
8456                                                     # If --since or --until is a MySQL expression, then any_unix_timestamp()
8457                                                     # will need this callback to execute the expression.  We don't know what
8458                                                     # type of time value the user gave, so we'll create the callback in any case.
8459  ***     54     50     33                  248      if ( $o->get('since') || $o->get('until') ) {
8460  ***      0      0                           0         if ( my $aux_dsn = $o->get('aux-dsn') ) {
8461  ***      0                                  0            $aux_dbh = get_cxn(
8462                                                              for          => '--aux',
8463                                                              dsn          => $aux_dsn,
8464                                                              OptionParser => $o,
8465                                                              DSNParser    => $dp,
8466                                                              opts         => { AutoCommit => 1 }
8467                                                           );
8468  ***      0                                  0            $aux_dbh->{InactiveDestroy}  = 1;  # Don't die on fork().
8469                                                        }
8470  ***      0             0                    0         $aux_dbh ||= $qv_dbh || $qv_dbh2 || $ex_dbh || $ps_dbh || $ep_dbh;
      ***                    0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
8471  ***      0                                  0         MKDEBUG && _d('aux dbh:', $aux_dbh);
8472                                                     }
8473                                                     my $time_callback = sub {
8474  ***      0                    0             0         my ( $exp ) = @_;
8475  ***      0      0                           0         return unless $aux_dbh;
8476  ***      0                                  0         my $sql = "SELECT UNIX_TIMESTAMP($exp)";
8477  ***      0                                  0         MKDEBUG && _d($sql);
8478  ***      0                                  0         return $aux_dbh->selectall_arrayref($sql)->[0]->[0];
8479          54                                556      };
8480  ***     54     50                         259      if ( $o->get('since') ) {
8481  ***      0                                  0         my $since = any_unix_timestamp($o->get('since'), $time_callback);
8482  ***      0      0                           0         die "Invalid --since value" unless $since;
8483                                                        push @callbacks, sub {
8484  ***      0                    0             0            my ( $event ) = @_;
8485  ***      0                                  0            MKDEBUG && _d('callback: --since');
8486  ***      0      0                           0            if ( $past_since ) {
8487  ***      0                                  0               MKDEBUG && _d('Already past --since');
8488  ***      0                                  0               return $event;
8489                                                           }
8490  ***      0      0                           0            if ( $event->{ts} ) {
8491  ***      0                                  0               my $ts = any_unix_timestamp($event->{ts}, $time_callback);
8492  ***      0      0      0                    0               if ( ($ts || 0) >= $since ) {
8493  ***      0                                  0                  MKDEBUG && _d('Event is at or past --since');
8494  ***      0                                  0                  $past_since = 1;
8495  ***      0                                  0                  return $event;
8496                                                              }
8497                                                              else {
8498  ***      0                                  0                  MKDEBUG && _d('Event is before --since');
8499                                                              }
8500                                                           }
8501  ***      0                                  0            return;
8502  ***      0                                  0         };
8503  ***      0                                  0         $callback_names{$callbacks[-1]} = 'since';
8504                                                     }
8505  ***     54     50                         236      if ( $o->get('until') ) {
8506  ***      0                                  0         my $until = any_unix_timestamp($o->get('until'), $time_callback);
8507  ***      0      0                           0         die "Invalid --until value" unless $until;
8508                                                        push @callbacks, sub {
8509  ***      0                    0             0            my ( $event ) = @_;
8510  ***      0                                  0            MKDEBUG && _d('callback: --until');
8511  ***      0      0                           0            if ( $at_until ) {
8512  ***      0                                  0               MKDEBUG && _d('Already past --until');
8513  ***      0                                  0               return;
8514                                                           }
8515  ***      0      0                           0            if ( $event->{ts} ) {
8516  ***      0                                  0               my $ts = any_unix_timestamp($event->{ts}, $time_callback);
8517  ***      0      0      0                    0               if ( ($ts || 0) >= $until ) {
8518  ***      0                                  0                  MKDEBUG && _d('Event at or after --until');
8519  ***      0                                  0                  $at_until = 1;
8520  ***      0                                  0                  return;
8521                                                              }
8522                                                              else {
8523  ***      0                                  0                  MKDEBUG && _d('Event is before --until');
8524                                                              }
8525                                                           }
8526  ***      0                                  0            return $event;
8527  ***      0                                  0         };
8528  ***      0                                  0         $callback_names{$callbacks[-1]} = 'until';
8529                                                     }
8530                                                  
8531          54    100                         222      if ( grep { $_ eq 'fingerprint' } @groupby ) {
              55                                361   
8532                                                        push @callbacks, sub {
8533         346                  346          2706            my ( $event ) = @_;
8534         346                               1394            MKDEBUG && _d('callback: fingerprint');
8535                                                           # Skip events which do not have the groupby attribute.
8536         346                               1957            my $groupby_val = $event->{arg};
8537  ***    346     50                        1522            return unless $groupby_val;
8538         346                               2322            $event->{fingerprint} = $qr->fingerprint($groupby_val);
8539         346                               1208            return $event;
8540          47                                521         };
8541          47                                270         $callback_names{$callbacks[-1]} = 'fingerprint';
8542                                                     }
8543                                                  
8544                                                     # Make subs which map attrib aliases to their primary attrib.
8545          54                                172      foreach my $alt_attrib ( @{$o->get('attribute-aliases')} ) {
              54                                258   
8546          54                                562         push @callbacks, make_alt_attrib($alt_attrib);
8547          54                                393         $callback_names{$callbacks[-1]} = 'attribute aliases';
8548                                                     }
8549                                                  
8550                                                     # Carry attribs forward for --inherit-attributes.
8551          54                                232      my $prev_vals = {};
8552          54                                264      my $inherit_attrib_sub = make_inherit_attribs(
8553                                                        $o->get('inherit-attributes'),
8554                                                        $prev_vals
8555                                                     );
8556  ***     54     50                         294      push @callbacks, $inherit_attrib_sub if $inherit_attrib_sub;
8557          54                                298      $callback_names{$callbacks[-1]} = 'inherit attributes';
8558                                                  
8559          54    100                         219      if ( grep { $_ eq 'tables' } @groupby ) {
              55                                298   
8560                                                        push @callbacks, sub {
8561           2                    2            11            my ( $event ) = @_;
8562           2                                  6            MKDEBUG && _d('callback: tables');
8563           2                                  8            my $group_by_val = $event->{arg};
8564  ***      2     50                          10            return 0 unless defined $group_by_val;
8565           2                                 23            $event->{tables} = [
8566                                                              map {
8567                                                                 # Canonicalize and add the db name in front
8568           2                                 18                  $_ =~ s/`//g;
8569  ***      2    100     33                   26                  if ($_ !~ m/\./ && (my $db = $event->{db} || $event->{Schema})) {
      ***                   66                        
8570           1                                  4                     $_ = "$db.$_";
8571                                                                 }
8572           2                                 14                  $_;
8573                                                              }
8574                                                              $qp->get_tables($group_by_val)
8575                                                           ];
8576           2                                  9            return $event;
8577           1                                 14         };
8578           1                                  8         $callback_names{$callbacks[-1]} = 'tables';
8579                                                     }
8580                                                  
8581          54                                191      my %distill_args;
8582  ***     54     50     33                  264      if ( $o->get('type') eq 'memcached' || $o->get('type') eq 'http' ) {
8583  ***      0                                  0         $distill_args{generic} = 1;
8584  ***      0      0                           0         if ( $o->get('type') eq 'http' ) {
8585                                                           # Remove stuff after url.
8586                                                           $distill_args{trf} = sub {
8587  ***      0                    0             0               my ( $query ) = @_;
8588  ***      0                                  0               $query =~ s/(\S+ \S+?)(?:[?;].+)/$1/;
8589  ***      0                                  0               return $query;
8590  ***      0                                  0            };
8591                                                        }
8592                                                     }
8593          54    100                         214      if ( grep { $_ eq 'distill' } @groupby ) {
              55                                333   
8594                                                        push @callbacks, sub {
8595          11                   11            78            my ( $event ) = @_;
8596          11                                 39            MKDEBUG && _d('callback: distill');
8597          11                                 54            my $group_by_val = $event->{arg};
8598  ***     11     50                          63            return 0 unless defined $group_by_val;
8599          11                                114            $event->{distill} = $qr->distill($group_by_val, %distill_args);
8600          11                                 41            MKDEBUG && !$event->{distill} && _d('Cannot distill', $event->{arg});
8601          11                                 52            return $event;
8602           3                                 36         };
8603           3                                 22         $callback_names{$callbacks[-1]} = 'distill';
8604                                                     }
8605                                                  
8606                                                     # Filter after special attributes, like fingerprint, tables,
8607                                                     # distill, etc., have been created.
8608          54    100                         233      if ( $o->get('filter') ) {
8609           1                                  4         my $filter = $o->get('filter');
8610  ***      1     50     33                   23         if ( -f $filter && -r $filter ) {
8611  ***      0                                  0            MKDEBUG && _d('Reading file', $filter, 'for --filter code');
8612  ***      0      0                           0            open my $fh, "<", $filter or die "Cannot open $filter: $OS_ERROR";
8613  ***      0                                  0            $filter = do { local $/ = undef; <$fh> };
      ***      0                                  0   
      ***      0                                  0   
8614  ***      0                                  0            close $fh;
8615                                                        }
8616                                                        else {
8617           1                                 10            $filter = "( $filter )";  # issue 565
8618                                                        }
8619           1                                  8         my $code   = "sub { MKDEBUG && _d('callback: filter');  my(\$event) = shift; $filter && return \$event; };";
8620           1                                  5         MKDEBUG && _d('--filter code:', $code);
8621  ***      1     50                         114         my $sub = eval $code
8622                                                           or die "Error compiling --filter code: $code\n$EVAL_ERROR";
8623           1                                  5         push @callbacks, $sub;
8624           1                                  6         $callback_names{$callbacks[-1]} = 'filter';
8625                                                     }
8626                                                  
8627          54    100                         277      if ( $o->get('zero-admin') ) {
8628                                                        push @callbacks, sub {
8629         360                  360          2087            my ( $event ) = @_;
8630         360                               1169            MKDEBUG && _d('callback: zero admin');
8631  ***    360    100     66                 3788            if ( $event->{arg} && $event->{arg} =~ m/^# administrator/ ) {
8632          11                                 52               $event->{Rows_sent}     = 0;
8633          11                                 60               $event->{Rows_read}     = 0;
8634          11                                 43               $event->{Rows_examined} = 0;
8635                                                           }
8636         360                               1196            return $event;
8637          53                                613         };
8638          53                                338         $callback_names{$callbacks[-1]} = 'zero admin';
8639                                                     }
8640                                                  
8641  ***     54     50                         319      if ( $o->got('sample') ) {
8642  ***      0                                  0         my $group_by_val = $groupby[0];
8643  ***      0                                  0         my $num_samples  = $o->get('sample');
8644  ***      0      0                           0         if ( $group_by_val ) {
8645  ***      0                                  0            my %seen;
8646                                                           push @callbacks, sub {
8647  ***      0                    0             0               my ($event) = @_;
8648  ***      0                                  0               MKDEBUG && _d('callback: sample');
8649  ***      0      0                           0               if ( ++$seen{$event->{$group_by_val}} <= $num_samples ) {
8650  ***      0                                  0                  MKDEBUG && _d("--sample permits event",
8651                                                                    $event->{$group_by_val});
8652  ***      0                                  0                  return $event;
8653                                                              }
8654  ***      0                                  0               MKDEBUG && _d("--sample rejects event", $event->{$group_by_val});
8655  ***      0                                  0               return;
8656  ***      0                                  0            };
8657  ***      0                                  0            $callback_names{$callbacks[-1]} = 'sample';
8658                                                        }
8659                                                     }
8660                                                  
8661  ***     54     50                         248      if ( $o->get('print') ) {
8662  ***      0                                  0         my $w = new SlowLogWriter();
8663                                                        push @callbacks, sub {
8664  ***      0                    0             0            my ( $event ) = @_;
8665  ***      0                                  0            MKDEBUG && _d('callback: print');
8666  ***      0                                  0            $w->write(*STDOUT, $event);
8667  ***      0                                  0            return $event;
8668  ***      0                                  0         };
8669  ***      0                                  0         $callback_names{$callbacks[-1]} = 'print';
8670                                                     }
8671                                                  
8672          54                                168      my $et;
8673  ***     54     50                         243      if ( my $et_args = $o->get('execute-throttle') ) {
8674                                                        # These were check earlier; no need to check them again.
8675  ***      0                                  0         my ($rate_max, $int, $step) = @{$o->get('execute-throttle')};
      ***      0                                  0   
8676  ***      0             0                    0         $step ||= 5;
8677  ***      0                                  0         $step  /= 100;  # step specified as percent but $et expect 0.1=10%, etc.
8678  ***      0                                  0         MKDEBUG && _d('Execute throttle:', $rate_max, $int, $step);
8679                                                  
8680                                                        my $get_rate = sub {
8681  ***      0             0      0             0            return percentage_of(
      ***                    0                        
8682                                                              $prof{callback}->{'execute'}->{time} || 0,
8683                                                              $prof{total}->{time}                 || 0,
8684                                                           );
8685  ***      0                                  0         };
8686                                                  
8687  ***      0                                  0         $et = new ExecutionThrottler(
8688                                                           rate_max  => $rate_max,
8689                                                           get_rate  => $get_rate,
8690                                                           check_int => $int,
8691                                                           step      => $step,
8692                                                        );
8693                                                        push @callbacks, sub {
8694  ***      0                    0             0            my ( $event, %args ) = @_;
8695  ***      0                                  0            MKDEBUG && _d('callback: throttle');
8696  ***      0                                  0            return $et->throttle(%args);
8697  ***      0                                  0         };
8698  ***      0                                  0         $callback_names{$callbacks[-1]} = 'execute throttle';
8699                                                     }
8700                                                  
8701          54    100                         309      if ( my $ex_dsn = $o->get('execute') ) {
8702  ***      2     50                          13         if ( $o->get('ask-pass') ) {
8703  ***      0                                  0            $ex_dsn->{p} = OptionParser::prompt_noecho("Enter password for "
8704                                                              . "--execute: ");
8705  ***      0                                  0            $o->set('execute', $ex_dsn);
8706                                                        }
8707                                                  
8708           2                                  9         my $cur_server = 'execute';
8709           2                                 20         ($cur_server, $ex_dbh) = find_role(
8710                                                           OptionParser => $o,
8711                                                           DSNParser    => $dp,
8712                                                           dbh          => $ex_dbh,
8713                                                           current      => $cur_server,
8714                                                           read_only    => 1,
8715                                                           comment      => 'for --execute'
8716                                                        );
8717           2                                 96         my $cur_time = time();
8718           2                                  7         my $curdb;
8719           2                                 11         my $default_db = $o->get('execute')->{D};
8720           2                                  8         MKDEBUG && _d('Default db:', $default_db);
8721                                                        push @callbacks, sub {
8722           2                    2            14            my ( $event ) = @_;
8723           2                                  7            MKDEBUG && _d('callback: execute');
8724           2                                 12            $event->{Exec_orig_time} = $event->{Query_time};
8725  ***      2     50     50                   29            if ( ($event->{Skip_exec} || '') eq 'Yes' ) {
8726  ***      0                                  0               MKDEBUG && _d('Not executing event because of --execute-throttle');
8727                                                              # Zero Query_time to 'Exec time' will show the real time
8728                                                              # spent executing queries.
8729  ***      0                                  0               $event->{Query_time} = 0;
8730  ***      0                                  0               $stats{execute_skipped}++;
8731  ***      0                                  0               return $event;
8732                                                           }
8733           2                                 11            $stats{execute_executed}++;
8734  ***      2            66                   25            my $db = $event->{db} || $default_db;
8735           2                                  7            eval {
8736  ***      2    100     33                   31               if ( $db && (!$curdb || $db ne $curdb) ) {
      ***                   66                        
8737           1                                141                  $ex_dbh->do("USE $db");
8738           1                                  4                  $curdb = $db;
8739                                                              } 
8740           2                                 17               my $start = time();
8741           2                                509               $ex_dbh->do($event->{arg});
8742           1                                 11               my $end = time();
8743           1                                  6               $event->{Query_time} = $end - $start;
8744           1                                 10               $event->{Exec_diff_time}
8745                                                                 = $event->{Query_time} - $event->{Exec_orig_time};
8746  ***      1     50     33                    7               if ( $o->get('mirror') && $end - $cur_time > $o->get('mirror') ) {
8747  ***      0                                  0                  ($cur_server, $ex_dbh) = find_role(
8748                                                                    OptionParser => $o,
8749                                                                    DSNParser    => $dp,
8750                                                                    dbh          => $ex_dbh,
8751                                                                    current      => $cur_server,
8752                                                                    read_only    => 1,
8753                                                                    comment      => 'for --execute'
8754                                                                 );
8755  ***      0                                  0                  $cur_time = $end;
8756                                                              }
8757                                                           };
8758           2    100                          19            if ( $EVAL_ERROR ) {
8759           1                                  4               MKDEBUG && _d($EVAL_ERROR);
8760           1                                  7               $stats{execute_error}++;
8761                                                              # Don't try to re-execute the statement.  Just skip it.
8762  ***      1     50                           9               if ( $EVAL_ERROR =~ m/server has gone away/ ) {
8763  ***      0                                  0                  print STDERR $EVAL_ERROR;
8764  ***      0                                  0                  eval {
8765  ***      0                                  0                     ($cur_server, $ex_dbh) = find_role(
8766                                                                       OptionParser => $o,
8767                                                                       DSNParser    => $dp,
8768                                                                       dbh          => $ex_dbh,
8769                                                                       current      => $cur_server,
8770                                                                       read_only    => 1,
8771                                                                       comment      => 'for --execute'
8772                                                                    );
8773  ***      0                                  0                     $cur_time = time();
8774                                                                 };
8775  ***      0      0                           0                  if ( $EVAL_ERROR ) {
8776  ***      0                                  0                     print STDERR $EVAL_ERROR;
8777  ***      0                                  0                     sleep 1;
8778                                                                 }
8779  ***      0                                  0                  return 0;
8780                                                              }
8781  ***      1     50                           8               if ( $EVAL_ERROR =~ m/No database/ ) {
8782           1                                  7                  $stats{execute_no_database}++;
8783                                                              }
8784                                                           }
8785           2                                  9            return $event;
8786           2                                 58         };
8787           2                                 20         $callback_names{$callbacks[-1]} = 'execute';
8788                                                     }
8789                                                  
8790                                                     # Finally, add aggregator obj for each groupby attrib to the callbacks.
8791                                                     # These aggregating objs should be the last callbacks.
8792          54                                177      my @ea;  # EventAggregators
8793          54                                209      my @tl;  # EventTimeline (aggregators)
8794          54                                410      foreach my $i ( 0..$#groupby  ) {
8795          55                                263         my $groupby = $groupby[$i];
8796                                                  
8797                                                        # This shouldn't happen.
8798  ***     55     50                         278         die "No --order-by value for --group-by $groupby" unless $orderby[$i];
8799                                                  
8800          55                                466         my ( $orderby_attrib, $orderby_func ) = split(/:/, $orderby[$i]);
8801                                                  
8802           1                                 11         my %attributes = map {
8803           1                                 24            my ($name, @alt) = split(/:/, $_);
8804           1                                 11            $name => [$name, @alt];
8805                                                        }
8806          55                                254         grep { $_ !~ m/^$groupby\b/ }
8807          55                                207         @{$o->get('select')};
8808                                                  
8809                                                        # Create an EventAggregator for this groupby attrib and
8810                                                        # add it to callbacks.
8811          55                                423         my $ea = new EventAggregator(
8812                                                           groupby           => $groupby,
8813                                                           attributes        => { %attributes },
8814                                                           worst             => $orderby_attrib,
8815                                                           attrib_limit      => $o->get('attribute-value-limit'),
8816                                                           ignore_attributes => $o->get('ignore-attributes'),
8817                                                           unroll_limit      => $o->get('check-attributes-limit'),
8818                                                           type_for => {
8819                                                              val          => 'string',
8820                                                              key_print    => 'string',
8821                                                              Status_code  => 'string',
8822                                                              Statement_id => 'string',
8823                                                              Error_no     => 'string',
8824                                                           },
8825                                                        );
8826          55                                350         push @ea, $ea;
8827                                                        push @callbacks, sub {
8828         368                  368          1919            my ( $event ) = @_;
8829         368                               2312            $ea->aggregate($event);
8830         368                               1469            return $event;
8831          55                                519         };
8832          55                                356         $callback_names{$callbacks[-1]} = "aggregate $groupby";
8833                                                  
8834                                                        # If user wants a timeline report, too, then create an EventTimeline
8835                                                        # aggregator for this groupby attrib and add it to the callbacks, too.
8836          55    100                         257         if ( $o->get('timeline') ) {
8837           1                                 23            my $tl = new EventTimeline(
8838                                                              groupby    => [$groupby],
8839                                                              attributes => [qw(Query_time ts)],
8840                                                           );
8841           1                                  8            push @tl, $tl;
8842                                                           push @callbacks, sub {
8843           8                    8            52               my ( $event ) = @_;
8844           8                                 65               $tl->aggregate($event);
8845           8                                 35               return $event;
8846           1                                 11            };
8847           1                                 10            $callback_names{$callbacks[-1]} = "timeline $groupby";
8848                                                        }
8849                                                     }
8850                                                  
8851  ***     54     50                         373      if ( $o->get('processlist') ) {
8852                                                        push @callbacks, sub {
8853  ***      0                    0             0            MKDEBUG && _d('callback: interval sleep');
8854  ***      0                                  0            usleep($o->get('interval') * 1_000_000);
8855  ***      0                                  0            return @_;
8856  ***      0                                  0         };
8857  ***      0                                  0         $callback_names{$callbacks[-1]} = 'interval sleep';
8858                                                     }
8859                                                  
8860                                                     # ########################################################################
8861                                                     # Daemonize now that everything is setup and ready to work.
8862                                                     # ########################################################################
8863          54                                159      my $daemon;
8864  ***     54     50                         231      if ( $o->get('daemonize') ) {
      ***            50                               
8865  ***      0                                  0         $daemon = new Daemon(o=>$o);
8866  ***      0                                  0         $daemon->daemonize();
8867  ***      0                                  0         MKDEBUG && _d('I am a daemon now');
8868                                                     }
8869                                                     elsif ( $o->get('pid') ) {
8870                                                        # We're not daemoninzing, it just handles PID stuff.
8871  ***      0                                  0         $daemon = new Daemon(o=>$o);
8872  ***      0                                  0         $daemon->make_PID_file();
8873                                                     }
8874                                                  
8875                                                     # ##########################################################################
8876                                                     # Parse the input.
8877                                                     # ##########################################################################
8878          54    100                         260      if ( my $patterns = $o->get('embedded-attributes') ) {
8879           1                                 34         $misc->{embed}   = qr/$patterns->[0]/o;
8880           1                                 27         $misc->{capture} = qr/$patterns->[1]/o;
8881           1                                  6         MKDEBUG && _d('Patterns for embedded attributes:', $misc->{embed},
8882                                                              $misc->{capture});
8883                                                     }
8884                                                     
8885  ***     54     50                         282      if ( @ARGV == 0 ) {
8886  ***      0                                  0         push @ARGV, '-'; # Magical STDIN filename.
8887                                                     }
8888                                                  
8889                                                     # Create callback to read next event.  Some inputs, like Processlist,
8890                                                     # may use something else but most use this.
8891          54                                164      my $fh;
8892          54                                155      my $next_event;
8893  ***     54     50                         236      if ( my $read_time = $o->get('read-timeout') ) {
8894  ***      0                    0             0         $next_event = sub { return read_timeout($fh, $read_time); };
      ***      0                                  0   
8895                                                     }
8896                                                     else {
8897          54                  495           544         $next_event = sub { return <$fh>; };
             495                              10085   
8898                                                     }
8899          54                  822           341      my $tell = sub { return tell $fh; };
             822                               3680   
8900                                                  
8901          54                                504      my $start = time();
8902  ***     54            50                  237      my $end   = $start + ($o->get('run-time') || 0); # When we should exit
8903          54                                190      my $now   = $start;
8904          54                                172      my $iters = 0;
8905                                                     ITERATION:
8906  ***     54            66                  475      while (  # Quit if instructed to, or if iterations are exceeded.
      ***                   66                        
8907                                                        $oktorun
8908                                                        && (!$o->get('iterations') || $iters++ < $o->get('iterations') )
8909                                                     ) {
8910                                                  
8911  ***     54     50                         269         if ( $o->get('print-iterations') ) {
8912  ***      0                                  0            my $iter_start = time;
8913  ***      0                                  0            MKDEBUG && _d('Iteration', $iters, 'started at', ts($iter_start));
8914  ***      0                                  0            print "\n# Iteration $iters started at ", ts($iter_start), "\n";
8915                                                        }
8916                                                  
8917                                                        EVENT:
8918  ***     54            33                  777         while (                                 # Quit if:
      ***                   33                        
8919                                                           $oktorun                             # instructed to quit
8920                                                           && ($start == $end || $now < $end) ) # or time is exceeded
8921                                                        {
8922         541    100                        2479            if ( !$fh ) {
8923         108                                450               my $file = shift @ARGV;
8924         108    100                         498               if ( !$file ) {
8925          54                                165                  MKDEBUG && _d('No more files to parse');
8926          54                                186                  last EVENT;
8927                                                              }
8928                                                  
8929  ***     54     50                         252               if ( $file eq '-' ) {
8930  ***      0                                  0                  $fh = *STDIN;
8931  ***      0                                  0                  MKDEBUG && _d('Reading STDIN');
8932                                                              }
8933                                                              else {
8934  ***     54     50                        2907                  if ( !open $fh, "<", $file ) {
8935  ***      0                                  0                     $fh = undef;
8936  ***      0                                  0                     warn "Cannot open $file: $OS_ERROR\n";
8937  ***      0                                  0                     next EVENT;
8938                                                                 }
8939          54                                149                  MKDEBUG && _d('Reading', $file);
8940                                                  
8941                                                                 # Reset these var in case we read two logs out of order by time.
8942          54                                187                  $past_since = 0;
8943          54                                204                  $at_until   = 0;
8944                                                              }
8945                                                           }
8946                                                  
8947         487                               1498            eval {
8948                                                              # Run events through the pipeline.  The first pipeline process
8949                                                              # is usually responsible for getting the next event.  The pipeline
8950                                                              # stops if a process does not return the event.  This main loop
8951                                                              # stops if a process sets oktorun to false; it usually does this
8952                                                              # when there are no more events, but it may do it for other reasons.
8953                                                              # Some inputs are infinite streams of events, like the proclist,
8954                                                              # so oktorun is never set to false and it's the user's job to tell
8955                                                              # us when to stop.
8956         487                               1767               my $event       = {};
8957         487                               1713               my $more_events = 1;
8958         487                   54          3157               my $oktorun_sub = sub { $more_events = $_[0]; };
              54                                184   
8959         487                               1885               foreach my $callback ( @callbacks ) {
8960  ***   2433     50                        8581                  last unless $oktorun;  # the global oktorun var
8961        2433                              11342                  my $start = time;
8962        2433                              14559                  $event = $callback->(
8963                                                                    $event,  # for backwards compatibility
8964                                                                    event      => $event,  # new interface
8965                                                                    next_event => $next_event,
8966                                                                    tell       => $tell,
8967                                                                    oktorun    => $oktorun_sub,
8968                                                                    misc       => $misc,
8969                                                                    stats      => \%stats,
8970                                                                 );
8971        2433                              13961                  my $end  = time;
8972        2433                               7762                  my $t    = $end - $start;
8973  ***   2433            33                12644                  my $name = $callback_names{$callback} || $callback;
8974        2433                              11280                  $prof{callback}->{$name}->{time} += $t;
8975        2433                               9370                  $prof{callback}->{$name}->{count}++;
8976        2433                               8777                  $prof{total}->{time} += $t;
8977        2433                               7986                  $prof{total}->{count}++;
8978        2433    100                       11099                  last unless $event;
8979                                                              }
8980         487    100                        3852               if ( !$more_events ) {
8981          54                                138                  MKDEBUG && _d('No more events');
8982  ***     54     50                         967                  close $fh if $fh;
8983          54                                300                  $fh = undef;
8984                                                              }
8985                                                           };
8986  ***    487     50                        1958            if ( $EVAL_ERROR ) {
8987  ***      0                                  0               _d($EVAL_ERROR);
8988  ***      0                                  0               $stats{pipeline_error}++;
8989                                                  
8990                                                              # Don't ignore failure to open a file, else we'll get
8991                                                              # "tell() on closed filehandle" errors.
8992  ***      0      0                           0               last EVENT if $EVAL_ERROR =~ m/Cannot open/;
8993                                                  
8994  ***      0      0                           0               last EVENT unless $o->get('continue-on-error');
8995                                                           }
8996         487                               6708            $now = time();
8997                                                        }  # EVENT
8998                                                  
8999                                                        # ######################################################################
9000                                                        # Done parsing events, now do something with the aggregated query
9001                                                        # results for each class (i.e. each groupby), probably --report them,
9002                                                        # or maybe just save them for --review.
9003                                                        # ######################################################################
9004  ***     54            50                  418         my $label_width = $ENV{LABEL_WIDTH} || 'auto';
9005          54                               1059         my $qrf         = new QueryReportFormatter(label_width => $label_width);
9006          54                                448         my @select      = ( $ea[0]->get_attributes() );
9007          54                                212         MKDEBUG && _d('attribs for reports:', @select);
9008                                                  
9009                                                        # First, and only once, print the global report analysis header.
9010          54    100    100                  393         if ( $o->get('report') && $o->get('report-format')->{header} ) {
9011  ***      7     50                          33            print $qrf->header() if $o->get('report-format')->{rusage};
9012                                                  
9013                                                           # It doesn't matter which ea we use here because they will all have
9014                                                           # the same attributes; they only differ in how they were grouped.
9015           7                                 28            my $ea = $ea[0];
9016  ***      7     50                          41            if ( !$ea->events_processed() ) {
9017  ***      0                                  0               print "# No events processed.\n";
9018                                                           }
9019                                                           else {
9020           7                                 67               my ( $orderby_attrib, $orderby_func ) = split(/:/, $orderby[0]);
9021           7                                 44               $orderby_attrib = check_orderby_attrib($orderby_attrib, $ea, $o);
9022          94                                421               print $qrf->global_report(
9023                                                                 $ea,
9024           7                                 34                  select => [ grep { $_ !~ m/^(?:user|db|pos_in_log)$/ } @select ],
9025                                                                 worst  => $orderby_attrib,
9026                                                                 no_zero_bool => !$o->get('zero-bool'),
9027                                                              );
9028                                                           }
9029                                                        }
9030                                                  
9031                                                        # #####################################################################
9032                                                        # Do the reports for each groupby/class.
9033                                                        # #####################################################################
9034          54                                521         for my $i ( 0..$#groupby ) {
9035          55                                242            my $groupby = $groupby[$i];
9036          55                                210            my $ea      = $ea[$i];
9037          55                                550            my ( $orderby_attrib, $orderby_func ) = split(/:/, $orderby[$i]);
9038          55                                332            $orderby_attrib = check_orderby_attrib($orderby_attrib, $ea, $o);
9039          55                                158            MKDEBUG && _d('Doing reports for groupby', $groupby, 'orderby',
9040                                                              $orderby_attrib, $orderby_func);
9041                                                  
9042                                                           # We don't report on all queries, just the worst, i.e. the top
9043                                                           # however many.
9044          55           100                  252            my $limit = $o->get('limit')->[$i] || '95%:20';
9045          55                                187            my ($total, $count);
9046          55    100                         608            if ( $limit =~ m/^\d+$/ ) {
9047          50                                218               $count = $limit;
9048                                                           }
9049                                                           else {
9050                                                              # It's a percentage, so grab as many as needed to get to
9051                                                              # that % of the file.
9052           5                                 51               ($total, $count) = $limit =~ m/(\d+)/g;
9053           5           100                   29               $total *= ($ea->results->{globals}->{$orderby_attrib}->{sum} || 0)
9054                                                                      / 100;
9055                                                           }
9056  ***     55            50                  594            my %top_spec = (
9057                                                              attrib  => $orderby_attrib,
9058                                                              orderby => $orderby_func || 'cnt',
9059                                                              total   => $total,
9060                                                              count   => $count,
9061                                                           );
9062          55    100                         230            if ( $o->get('outliers')->[$i] ) {
9063          54                                267               @top_spec{qw(ol_attrib ol_limit ol_freq)}
9064                                                                 = split(/:/, $o->get('outliers')->[$i]);
9065                                                           }
9066                                                           # The queries that will be reported.
9067          55                                679            my @worst = $ea->top_events(%top_spec);
9068                                                  
9069          55                                269            my $expected_range = $o->get('expected-range');
9070  ***     55            66                  760            my $explain_why
      ***                   66                        
9071                                                              = $expected_range
9072                                                              && (@worst < $expected_range->[0] || @worst > $expected_range->[1]);
9073                                                   
9074          55                                155            my @table_access;
9075          55                                145            my @profiles;
9076          55                                170            my $total_r = 0;
9077          55                                148            my @prepared;       # prepared statements
9078          55                                146            my %seen_prepared;  # report each PREP-EXEC pair once
9079                                                  
9080                                                           # Print a header for this groupby/class if we're doing the standard
9081                                                           # query report and there's more than one class or there's one class
9082                                                           # but it's not the normal class grouped by fingerprint.
9083          55    100    100                  236            if ( $o->get('report')
                           100                        
                           100                        
9084                                                                && $o->get('report-format')->{query_report}
9085                                                                && (@groupby > 1 || $groupby ne 'fingerprint') )
9086                                                           {
9087           8                                110               print "\n# ", ( '#' x 72 ), "\n";
9088           8                                 51               print "# Report grouped by $groupby\n";
9089           8                                 34               print '# ', ( '#' x 72 ), "\n";
9090                                                           }
9091                                                  
9092                                                           # ##################################################################
9093                                                           # Do the reports for each query in this groupby/class.
9094                                                           # ##################################################################
9095                                                           ITEM:
9096          55                                336            foreach my $rank ( 1 .. @worst ) {
9097         121                                716               my $item          = $worst[$rank - 1]->[0];
9098         121                                625               my $stats         = $ea->results->{classes}->{$item};
9099         121                                602               my $sample        = $ea->results->{samples}->{$item};
9100  ***    121            50                 1112               my $samp_query    = $sample->{arg} || '';
9101                                                  
9102                                                              # ###############################################################
9103                                                              # Save the profile for this item.  It's printed later, maybe.
9104                                                              # ###############################################################
9105         121    100                        1697               my %profile = (
                    100                               
9106                                                                 rank   => $rank,
9107                                                                 r      => $stats->{Query_time}->{sum},
9108                                                                 cnt    => $stats->{Query_time}->{cnt},
9109                                                                 sample => $groupby eq 'fingerprint' ? $qr->distill($samp_query,
9110                                                                                                                    %distill_args)
9111                                                                                                     : $item,
9112                                                                 id     => $groupby eq 'fingerprint' ? make_checksum($item)
9113                                                                                                     : '',
9114                                                              );
9115         121                                563               $total_r += $profile{r};
9116         121                                583               push @profiles, \%profile;
9117                                                  
9118                                                              # ###############################################################
9119                                                              # Saved prepared statement values.
9120                                                              # ###############################################################
9121  ***    121    100     66                  888               if ( $stats->{Statement_id} && $item =~ m/^(?:prepare|execute) / ) {
9122                                                                 # Each PREPARE (probably) has some EXECUTE and each EXECUTE
9123                                                                 # (should) have some PREPARE.  But these are only the top N
9124                                                                 # events so we can get here a PREPARE but not its EXECUTE or
9125                                                                 # vice-versa.  The prepared statements report requires both
9126                                                                 # so this code gets the missing pair from the ea stats.
9127          12                                 47                  my ($prep_stmt, $prep, $prep_r, $prep_cnt);
9128          12                                 39                  my ($exec_stmt, $exec, $exec_r, $exec_cnt);
9129          12    100                          67                  if ( $item =~ m/^prepare / ) {
9130           6                                 20                     $prep_stmt           = $item;
9131           6                                 29                     ($exec_stmt = $item) =~ s/^prepare /execute /;
9132                                                                 }
9133                                                                 else {
9134           6                                 60                     ($prep_stmt = $item) =~ s/^execute /prepare /;
9135           6                                 23                     $exec_stmt           = $item;
9136                                                                 }
9137                                                  
9138                                                                 # If both the PREPARE and EXECUTE are in the top N, then
9139                                                                 # only report the pair once.
9140          12    100                          87                  if ( !$seen_prepared{$prep_stmt}++ ) {
9141           6                                 28                     $exec     = $ea->results->{classes}->{$exec_stmt};
9142           6                                 37                     $exec_r   = $exec->{Query_time}->{sum};
9143           6                                 28                     $exec_cnt = $exec->{Query_time}->{cnt};
9144                                                  
9145           6                                 24                     $prep     = $ea->results->{classes}->{$prep_stmt};
9146           6                                 32                     $prep_r   = $prep->{Query_time}->{sum};
9147           6                                 17                     $prep_cnt = scalar keys %{$prep->{Statement_id}->{unq}},
               6                                 91   
9148                                                  
9149                                                                    push @prepared, {
9150                                                                       prep_r    => $prep_r, 
9151                                                                       prep_cnt  => $prep_cnt,
9152                                                                       exec_r    => $exec_r,
9153                                                                       exec_cnt  => $exec_cnt,
9154                                                                       %profile,    # reuse profile for rank, id and sample
9155                                                                    };
9156                                                                 }
9157                                                              }
9158                                                  
9159                                                              # ###############################################################
9160                                                              # Prepare for --review and --review-history.
9161                                                              # ###############################################################
9162         121                                397               my $review_vals;
9163         121                                338               my %history;
9164  ***    121     50                         496               if ( $qv ) {
9165  ***      0                                  0                  $review_vals = $qv->get_review_info($item);
9166  ***      0      0      0                    0                  if ( $review_vals->{reviewed_by} && !$o->get('report-all') ) {
9167                                                                    # This item has already been reviewed, skip it.  But before
9168                                                                    # doing so, save the history if necessary.
9169  ***      0      0                           0                     if ( $o->get('review-history') ) {
9170  ***      0             0                    0                        $qv->set_review_history(
9171                                                                          $item, $sample->{arg} || '', %history);
9172                                                                    }
9173  ***      0                                  0                     next ITEM;
9174                                                                 }
9175                                                  
9176  ***      0      0                           0                  if ( $o->get('review-history') ) {
9177  ***      0                                  0                     foreach my $attrib ( @select ) {
9178  ***      0                                  0                        $history{$attrib} = $ea->metrics(
9179                                                                          attrib => $attrib,
9180                                                                          where  => $item,
9181                                                                       );
9182                                                                    }
9183                                                                 }
9184                                                              }
9185                                                  
9186                                                              # ###############################################################
9187                                                              # Get tables for either --for-explain or --table-access.
9188                                                              # ###############################################################
9189           1                                  6               my ($default_db) = $sample->{db}       ? $sample->{db}
9190         121    100                         884                                : $stats->{db}->{unq} ? keys %{$stats->{db}->{unq}}
                    100                               
9191                                                                               :                       undef;
9192         121                                392               my @tables;
9193  ***    121     50     33                  566               if ( $o->get('for-explain') || $o->get('table-access') ){
9194         121                                800                  @tables = extract_tables($samp_query, $default_db);
9195         121    100                         544                  push @table_access, $samp_query if $o->get('table-access');
9196                                                              }
9197                                                  
9198                                                              # ###############################################################
9199                                                              # Print the standard query analysis report.
9200                                                              # ###############################################################
9201         121    100    100                  531               if ( $o->get('report')
9202                                                                   && $o->get('report-format')->{query_report} ) {
9203         106                                657                  print "\n";
9204        1481                               6144                  print $qrf->event_report(
9205                                                                    $ea,
9206         106    100                         502                     select => [ grep { $_ !~ m/^(?:pos_in_log)$/ } @select ],
9207                                                                    where  => $item,
9208                                                                    rank   => $rank,
9209                                                                    worst  => $orderby_attrib,
9210                                                                    reason => $explain_why ? $worst[$rank - 1]->[1] : '',
9211                                                                    no_zero_bool => !$o->get('zero-bool'),
9212                                                                 );
9213         106                               1212                  print $qrf->chart_distro(
9214                                                                    $ea,
9215                                                                    attribute  => $orderby_attrib,
9216                                                                    where      => $item,
9217                                                                 );
9218                                                  
9219  ***    106     50                         590                  if ( $qv ) {
9220                                                                    # Print the review information that is already in the table
9221                                                                    # before putting anything new into the table.
9222  ***      0                                  0                     print "# Review information\n";
9223  ***      0                                  0                     foreach my $col ( $qv->review_cols() ) {
9224  ***      0                                  0                        my $val = $review_vals->{$col};
9225  ***      0      0      0                    0                        if ( !$val || $val ne '0000-00-00 00:00:00' ) { # issue 202
9226  ***      0      0                           0                           printf "# %13s: %-s\n", $col, ($val ? $val : '');
9227                                                                       }
9228                                                                    }
9229                                                                 }
9230                                                  
9231         106    100                         568               if ( $groupby eq 'fingerprint' ) {
9232                                                                 # Shorten it if necessary (issue 216 and 292).
9233  ***     96     50                         620                  $samp_query = $qr->shorten($samp_query, $o->get('shorten'))
9234                                                                    if $o->get('shorten');
9235                                                              }
9236                                                                 # Print the query fingerprint.
9237  ***    106     50     66                  892                  if ( $groupby eq 'fingerprint' && $o->get('fingerprints') ) {
9238  ***      0                                  0                     print "# Fingerprint\n#    $item\n";
9239                                                                 }
9240                                                  
9241         106    100                         457                  if ( $groupby eq 'fingerprint' ) {
9242  ***     96     50                         394                     print_tables(@tables) if $o->get('for-explain');
9243          96    100                         783                     if ( $item =~ m/^(?:[\(\s]*select|insert|replace)/ ) {
9244          41    100                         287                        if ( $item =~ m/^(?:insert|replace)/ ) { # No EXPLAIN
9245          15                                136                           print $samp_query, "\\G\n";
9246                                                                       }
9247                                                                       else {
9248          26                                133                           print "# EXPLAIN\n$samp_query\\G\n"; 
9249          26                                171                           print_explain($ep_dbh, $samp_query, $default_db);
9250                                                                       }
9251                                                                    }
9252                                                                    else {
9253          55                                254                        print "$samp_query\\G\n"; 
9254          55                                338                        my $converted = $qr->convert_to_select($samp_query);
9255  ***     55    100     33                  256                        if ( $o->get('for-explain')
      ***                   66                        
9256                                                                            && $converted
9257                                                                            && $converted =~ m/^[\(\s]*select/i ) {
9258                                                                          # It converted OK to a SELECT
9259          27                                 92                           print "# Converted for EXPLAIN\n# EXPLAIN\n";
9260          27                                134                           print "$converted\\G\n";
9261                                                                       }
9262                                                                    }
9263                                                                 }
9264                                                                 else {
9265          10    100                          79                     if ( $groupby eq 'tables' ) {
9266           1                                  6                        my ( $db, $tbl ) = $q->split_unquote($item);
9267           1                                  8                        print_tables([$db, $tbl]);
9268                                                                    }
9269          10                                 45                     print $item, "\n"; 
9270                                                                 }
9271                                                              } # Print standard query analysis report
9272                                                  
9273                                                              # ###############################################################
9274                                                              # Update --review and --review-history.
9275                                                              # ###############################################################
9276  ***    121     50                         958               if ( $qv ) {
9277  ***      0             0                    0                  $qv->set_review_info(
9278                                                                    fingerprint => $item,
9279                                                                    sample      => $sample->{arg} || '',
9280                                                                    first_seen  => $stats->{ts}->{min},
9281                                                                    last_seen   => $stats->{ts}->{max}
9282                                                                 );
9283  ***      0      0                           0                  if ( $o->get('review-history') ) {
9284  ***      0             0                    0                     $qv->set_review_history(
9285                                                                       $item, $sample->{arg} || '', %history);
9286                                                                 }
9287                                                              }
9288                                                           } # Each worst ITEM
9289                                                  
9290                                                           # ##################################################################
9291                                                           # Print per-class reports.
9292                                                           # ##################################################################
9293                                                  
9294                                                           # Print timeline.
9295          55    100                         309            if ( $o->get('timeline') ) {
9296           1                                  4               my $tl = $tl[$i];
9297           1                   11             6               $tl->report($tl->results(), sub { print @_ });
              11                                 55   
9298                                                           }
9299                                                  
9300                                                           # Print table access.
9301          55    100                         262            if ( $o->get('table-access') ) {
9302           2                                  6               my @subqueries;
9303                                                              map {
9304           2                                  8                  eval {
               5                                 14   
9305           5                                 31                     push @subqueries, $qp->split($_);
9306                                                                 };
9307  ***      5     50                          26                  if ( $EVAL_ERROR ) {
9308  ***      0                                  0                     MKDEBUG && _d($EVAL_ERROR);
9309  ***      0                                  0                     warn "Cannot get table access for query $_";
9310                                                                 }
9311                                                              } @table_access; 
9312                                                  
9313           2                                  6               my %seen;
9314  ***      2     50                           9               print "\n" if $o->get('report');
9315           2                                  8               foreach my $subquery ( @subqueries ) {
9316           5                                 28                  my $rw = $qp->query_type($subquery, $qr)->{rw};
9317  ***      5     50                          25                  next unless $rw;
9318           5                                 18                  my @tables = $qp->get_tables($subquery);
9319  ***      5     50                          22                  next unless scalar @tables;
9320           5                                 16                  foreach my $db_tbl ( @tables ) {
9321           5    100                          29                     next if $seen{$db_tbl}++; # Unique-ify for issue 337.
9322           4                                 15                     my ($db, $tbl) = $q->split_unquote($db_tbl);
9323  ***      4     50                          17                     $db            = $db ? "`$db`."  : '';
9324           4                                 40                     print "$rw $db`$tbl`\n";
9325                                                                 }
9326                                                              }
9327                                                           }
9328                                                  
9329                                                           # Print profile (issue 381).
9330          55    100    100                  251            if ( $o->get('report') && $o->get('report-format')->{profile} ) {
9331           9                                129               my $report = new ReportFormatter(
9332                                                                 line_width       => 74,
9333                                                                 long_last_column => 1,
9334                                                              );
9335           9                                 54               $report->set_title('Profile');
9336           9                                160               $report->set_columns(
9337                                                                 { name => 'Rank',          right_justify => 1, },
9338                                                                 { name => 'Query ID',                          },
9339                                                                 { name => 'Response time', right_justify => 1, },
9340                                                                 { name => 'Calls',         right_justify => 1, },
9341                                                                 { name => 'R/Call',        right_justify => 1, },
9342                                                                 { name => 'Item',                              },
9343                                                              );
9344                                                  
9345           9                                 28               foreach my $item ( sort { $a->{rank} <=> $b->{rank} } @profiles ) {
              35                                141   
9346          29                                305                  my $rt  = sprintf('%10.4f', $item->{r});
9347          29           100                  301                  my $rtp = sprintf('%4.1f%%', $item->{r} / ($total_r || 1) * 100);
9348          29                                199                  my $rc  = sprintf('%8.4f', $item->{r} / $item->{cnt});
9349          29                                265                  $report->add_line(
9350                                                                    $item->{rank},
9351                                                                    "0x$item->{id}",
9352                                                                    "$rt $rtp",
9353                                                                    $item->{cnt},
9354                                                                    $rc,
9355                                                                    $item->{sample},
9356                                                                 );
9357                                                              }
9358           9                                 72               print "\n" . $report->get_report();
9359                                                           }
9360                                                  
9361                                                           # Print prepared statements (issue 740).
9362          55    100    100                  266            if ( $o->get('report') && $o->get('report-format')->{prepared}
                           100                        
9363                                                                && scalar @prepared ) {
9364           1                                  5               my $report = new ReportFormatter(
9365                                                                 line_width       => 74,
9366                                                                 long_last_column => 1,
9367                                                              );
9368           1                                  5               $report->set_title('Prepared statements');
9369           1                                 14               $report->set_columns(
9370                                                                 { name => 'Rank',          right_justify => 1, },
9371                                                                 { name => 'Query ID',                          },
9372                                                                 { name => 'PREP',          right_justify => 1, },
9373                                                                 { name => 'PREP Response', right_justify => 1, },
9374                                                                 { name => 'EXEC',          right_justify => 1, },
9375                                                                 { name => 'EXEC Response', right_justify => 1, },
9376                                                                 { name => 'Item',                              },
9377                                                              );
9378                                                  
9379           1                                  8               foreach my $item ( sort { $a->{rank} <=> $b->{rank} } @prepared ) {
      ***      0                                  0   
9380           1                                 11                  my $exec_rt   = sprintf('%10.4f', $item->{exec_r});
9381  ***      1            50                   11                  my $exec_rtp  = sprintf('%4.1f%%', $item->{exec_r} / ($total_r || 1) * 100);
9382           1                                  7                  my $prep_rt   = sprintf('%10.4f', $item->{prep_r});
9383  ***      1            50                    9                  my $prep_rtp  = sprintf('%4.1f%%', $item->{prep_r} / ($total_r || 1) * 100);
9384                                                  
9385  ***      1            50                   47                  $report->add_line(
      ***                   50                        
9386                                                                    $item->{rank},
9387                                                                    "0x$item->{id}",
9388                                                                    $item->{prep_cnt} || 0,
9389                                                                    "$prep_rt $prep_rtp",
9390                                                                    $item->{exec_cnt} || 0,
9391                                                                    "$exec_rt $exec_rtp",
9392                                                                    $item->{sample},
9393                                                                 );
9394                                                              }
9395           1                                  8               print "\n" . $report->get_report();
9396                                                           }
9397                                                        } # Each groupby
9398                                                  
9399                                                  
9400                                                        # Reset the start/end/now times so the next iteration will run for the
9401                                                        # same amount of time.
9402          54                                438         $start = time();
9403  ***     54            50                  256         $end   = $start + ($o->get('run-time') || 0); # When we should exit
9404          54                                200         $now   = $start;
9405                                                  
9406          54                                277         foreach my $ea ( @ea, @tl ) {
9407          56                                479            $ea->reset_aggregated_data();
9408                                                        }
9409                                                  
9410  ***     54     50                         378         if ( $o->get('pipeline-profile') ) {
9411  ***      0                                  0            my $report = new ReportFormatter(
9412                                                              line_width => 74,
9413                                                           );
9414  ***      0                                  0            $report->set_columns(
9415                                                              { name => 'Process'                   },
9416                                                              { name => 'Time',  right_justify => 1 },
9417                                                              { name => 'Count', right_justify => 1 },
9418                                                           );
9419  ***      0                                  0            $report->set_title('Pipeline profile');
9420  ***      0                                  0            foreach my $callback ( @callbacks ) {
9421  ***      0             0                    0               my $name = $callback_names{$callback} || $callback;
9422  ***      0             0                    0               my $t    = $prof{callback}->{$name}->{time} || 0;
9423  ***      0             0                    0               my $tp   = sprintf('%.2f %4.1f%%', $t,
9424                                                                             $t / ($prof{total}->{time} || 1) * 100);
9425  ***      0             0                    0               $report->add_line($name, $tp,
9426                                                                 $prof{callback}->{$name}->{count} || 0);
9427                                                              
9428                                                              # Reset profile for next iteration.
9429  ***      0                                  0               map { $prof{callback}->{$name}->{$_} = 0 }
      ***      0                                  0   
9430  ***      0                                  0                  keys %{$prof{callback}->{$name}};
9431                                                           }
9432  ***      0                                  0            map { $prof{total}->{$_} = 0 } keys %{$prof{total}};
      ***      0                                  0   
      ***      0                                  0   
9433                                                  
9434  ***      0                                  0            print "\n" . $report->get_report();
9435                                                        }
9436                                                  
9437          54    100                        1308         if ( $o->get('statistics') ) {
9438  ***      2     50                          12            if ( keys %stats ) {
9439           2                                 26               my $report = new ReportFormatter(
9440                                                                 line_width => 74,
9441                                                              );
9442           2                                 23               $report->set_columns(
9443                                                                 { name => 'Statistic',                    },
9444                                                                 { name => 'Value',     right_justify => 1 },
9445                                                              );
9446           2                                 14               foreach my $stat ( sort keys %stats ) {
9447  ***      4            50                   28                  $report->add_line($stat, $stats{$stat} || 0);
9448                                                  
9449                                                                 # Reset stats for next iteration.
9450           4                                 14                  $stats{$stat} = 0;
9451                                                              }
9452           2                                 15               print "\n" . $report->get_report();
9453                                                           }
9454                                                           else {
9455  ***      0                                  0               print "\n# No statistics values.\n";
9456                                                           }
9457                                                        }
9458                                                     } # ITERATION
9459                                                  
9460                                                     # Disconnect all open $dbh's
9461                                                     map {
9462           5                                 39         $dp->disconnect($_);
             324                               1029   
9463           5                                 22         MKDEBUG && _d('Disconnected dbh', $_);
9464                                                     }
9465          54                                314      grep { $_ }
9466                                                     ($qv_dbh, $qv_dbh2, $ex_dbh, $ps_dbh, $ep_dbh, $aux_dbh);
9467                                                  
9468          54                              50972      return 0;
9469                                                  } # End main().
9470                                                  
9471                                                  # ############################################################################
9472                                                  # Subroutines.
9473                                                  # ############################################################################
9474                                                  sub extract_tables {
9475         121                  121          1337      my ( $query, $default_db ) = @_;
9476         121                                328      MKDEBUG && _d('Extracting tables');
9477         121                                327      my @tables;
9478         121                                358      my %seen;
9479         121                                601      foreach my $db_tbl ( $qp->get_tables($query) ) {
9480  ***     89     50                         356         next unless $db_tbl;
9481          89    100                         538         next if $seen{$db_tbl}++; # Unique-ify for issue 337.
9482          86                                593         my ( $db, $tbl ) = $q->split_unquote($db_tbl);
9483          86           100                  751         push @tables, [ $db || $default_db, $tbl ];
9484                                                     }
9485         121                                616      return @tables;
9486                                                  }
9487                                                  
9488                                                  # Gets a default database and a list of arrayrefs of [db, tbl] to print out
9489                                                  sub print_tables {
9490          97                   97           437      my ( @tables ) = @_;
9491          97    100                         443      return unless @tables;
9492          63                                257      print "# Tables\n";
9493          63                                302      foreach my $db_tbl ( @tables ) {
9494          70                                366         my ( $db, $tbl ) = @$db_tbl;
9495          70    100                         490         print '#    SHOW TABLE STATUS',
9496                                                           ($db ? " FROM `$db`" : ''), " LIKE '$tbl'\\G\n";
9497         140                                647         print "#    SHOW CREATE TABLE ",
9498          70                                313            $q->quote(grep { $_ } @$db_tbl), "\\G\n";
9499                                                     }
9500          63                                209      return;
9501                                                  }
9502                                                  
9503                                                  sub print_explain {
9504          26                   26           142      my ( $dbh, $query, $db ) = @_;
9505  ***     26    100     66                  186      return unless $dbh && $query;
9506           3                                 11      eval {
9507  ***      3     50                          24         if ( !$qp->has_derived_table($query) ) {
9508  ***      3     50                          12            if ( $db ) {
9509           3                                 14               $dbh->do("USE " . $q->quote($db));
9510                                                           }
9511           3                                 10            my $sth = $dbh->prepare("EXPLAIN /*!50100 PARTITIONS */ $query");
9512           3                                585            $sth->execute();
9513           2                                  9            my $i = 1;
9514           2                                 58            while ( my @row = $sth->fetchrow_array() ) {
9515           2                                 24               print "# *************************** ", $i++,
9516                                                                 ". row ***************************\n";
9517           2                                 19               foreach my $j ( 0 .. $#row ) {
9518          20    100                         139                  printf "# %13s: %s\n", $sth->{NAME}->[$j],
9519                                                                    defined $row[$j] ? $row[$j] : 'NULL';
9520                                                              }
9521                                                           }
9522                                                        }
9523                                                     };
9524           3    100                         120      if ( $EVAL_ERROR ) {
9525           1                                  3         MKDEBUG && _d("Problem explaining", $query, $EVAL_ERROR);
9526           1                                 10         print "# EXPLAIN failed: $EVAL_ERROR";
9527                                                     }
9528                                                  }
9529                                                  
9530                                                  # Pass in the currently open $dbh (if any), where $current points to ('execute'
9531                                                  # or 'processlist') and whether you want to be connected to the read_only
9532                                                  # server.  Get back which server you're looking at, and the $dbh.  Assumes that
9533                                                  # one of the servers is ALWAYS read only and the other is ALWAYS not!  If
9534                                                  # there's some transition period where this isn't true, maybe both will end up
9535                                                  # pointing to the same place, but that should resolve shortly.
9536                                                  # The magic switching functionality only works if --mirror is given!  Otherwise
9537                                                  # it just returns the correct $dbh.  $comment is some descriptive text for
9538                                                  # debuggin, like 'for --execute'.
9539                                                  sub find_role { 
9540           2                    2            37      my ( %args ) = @_;
9541           2                                 11      my $o         = $args{OptionParser};
9542           2                                  8      my $dp        = $args{DSNParser};
9543           2                                 10      my $dbh       = $args{dbh};
9544           2                                  8      my $current   = $args{current};
9545           2                                 11      my $read_only = $args{read_only};
9546           2                                  9      my $comment   = $args{comment};
9547                                                  
9548  ***      2     50     66                   64      if ( !$dbh || !$dbh->ping ) {
9549           2                                  5         MKDEBUG && _d('Getting a dbh from', $current, $comment);
9550           2                                 14         $dbh = $dp->get_dbh(
9551                                                           $dp->get_cxn_params($o->get($current)), {AutoCommit => 1});
9552           2                                 19         $dbh->{InactiveDestroy}  = 1;  # Don't die on fork().
9553                                                     }
9554  ***      2     50                          20      if ( $o->get('mirror') ) {
9555  ***      0                                  0         my ( $is_read_only ) = $dbh->selectrow_array('SELECT @@global.read_only');
9556  ***      0                                  0         MKDEBUG && _d("read_only on", $current, $comment, ':',
9557                                                                      $is_read_only, '(want', $read_only, ')');
9558  ***      0      0                           0         if ( $is_read_only != $read_only ) {
9559  ***      0      0                           0            $current = $current eq 'execute' ? 'processlist' : 'execute';
9560  ***      0                                  0            MKDEBUG && _d("read_only wrong", $comment, "getting a dbh from", $current);
9561  ***      0                                  0            $dbh = $dp->get_dbh(
9562                                                              $dp->get_cxn_params($o->get($current)), {AutoCommit => 1});
9563  ***      0                                  0            $dbh->{InactiveDestroy}  = 1;  # Don't die on fork().
9564                                                        }
9565                                                     }
9566           2                                 24      return ($current, $dbh);
9567                                                  }
9568                                                  
9569                                                  # Catches signals so we can exit gracefully.
9570                                                  sub sig_int {
9571  ***      0                    0             0      my ( $signal ) = @_;
9572  ***      0      0                           0      if ( $oktorun ) {
9573  ***      0                                  0         print STDERR "# Caught SIG$signal.\n";
9574  ***      0                                  0         $oktorun = 0;
9575                                                     }
9576                                                     else {
9577  ***      0                                  0         print STDERR "# Exiting on SIG$signal.\n";
9578  ***      0                                  0         exit(1);
9579                                                     }
9580                                                  }
9581                                                  
9582                                                  sub make_alt_attrib {
9583          54                   54           358      my ( $alt_attrib ) = @_;
9584          54                                497      my @alts   = split('\|', $alt_attrib);
9585          54                                213      my $attrib = shift @alts;
9586          54                                148      MKDEBUG && _d('Primary attrib:', $attrib, 'aliases:', @alts);
9587          54                                166      my @lines;
9588          54                                342      push @lines,
9589                                                        'sub { my ( $event ) = @_; ',
9590                                                        'MKDEBUG && _d("callback: alt attrib");',
9591                                                        "if ( exists \$event->{'$attrib'} ) { ",
9592          54                                607         (map { "delete \$event->{'$_'}; "; } @alts),
9593                                                        'return $event; }',     
9594                                                        # Primary attrib doesn't exist; look for alts
9595                                                        (map {
9596          54                                335            "if ( exists \$event->{'$_'} ) { "
9597                                                           . "\$event->{'$attrib'} = \$event->{'$_'}; "
9598                                                           . "delete \$event->{'$_'}; "
9599                                                           . 'return $event; }';
9600                                                        } @alts),
9601                                                        'return $event; }';
9602          54                                170      MKDEBUG && _d('attrib alias sub for', $attrib, ':', @lines);
9603          54                               9004      my $sub = eval join("\n", @lines);
9604  ***     54     50                         298      die if $EVAL_ERROR;
9605          54                                285      return $sub;
9606                                                  }
9607                                                  
9608                                                  sub make_inherit_attribs {
9609          54                   54           243      my ( $attribs, $prev ) = @_;
9610          54                                165      my @lines;
9611         108                                934      push @lines,
9612                                                        'sub { my ( $event ) = @_; ',
9613                                                        'MKDEBUG && _d("callback: inherit attribs");',
9614                                                        (map {
9615          54                                240            "if ( defined \$event->{'$_'} ) { \$prev->{'$_'} = \$event->{'$_'} } else { \$event->{'$_'} = \$prev->{'$_'}; }"
9616                                                         } @$attribs),
9617                                                        'return $event; }';
9618          54                                148      MKDEBUG && _d('inherit attribs sub:', @lines);
9619          54                               6180      my $sub = eval join("\n", @lines);
9620  ***     54     50                         294      die if $EVAL_ERROR;
9621          54                                358      return $sub;
9622                                                  }
9623                                                  
9624                                                  # Checks that the orderby attrib exists in the ea, returns the default
9625                                                  # orderby attrib if not.
9626                                                  sub check_orderby_attrib {
9627          62                   62           331      my ( $orderby_attrib, $ea, $o ) = @_;
9628                                                  
9629          62    100    100                  333      if ( !$ea->type_for($orderby_attrib) && $orderby_attrib ne 'Query_time' ) {
9630           1                                  6         my $default_orderby = $o->get_defaults()->{'order-by'};
9631                                                  
9632                                                        # Print the notice only if the query report is being printed, too.
9633  ***      1     50                           5         if ( $o->get('report-format')->{query_report} ) {
9634           1                                 18            print "--order-by attribute $orderby_attrib doesn't exist, "
9635                                                              . "using $default_orderby\n";
9636                                                        }
9637                                                  
9638                                                        # Fall back to the default orderby attrib.
9639           1                                  8         ( $orderby_attrib, undef ) = split(/:/, $default_orderby);
9640                                                     }
9641                                                  
9642          62                                178      MKDEBUG && _d('orderby attrib:', $orderby_attrib);
9643          62                                255      return $orderby_attrib;
9644                                                  }
9645                                                  
9646                                                  # Read the fh and timeout after t seconds.
9647                                                  sub read_timeout {
9648  ***      0                    0             0      my ( $fh, $t ) = @_;
9649  ***      0      0                           0      return unless $fh;
9650  ***      0             0                    0      $t ||= 0;  # will reset alarm and cause read to wait forever
9651                                                  
9652                                                     # Set the SIGALRM handler.
9653  ***      0                                  0      my $mask   = POSIX::SigSet->new(&POSIX::SIGALRM);
9654                                                     my $action = POSIX::SigAction->new(
9655                                                        sub {
9656                                                           # This sub is called when a SIGALRM is received.
9657  ***      0                    0             0            die 'read timeout';
9658                                                        },
9659  ***      0                                  0         $mask,
9660                                                     );
9661  ***      0                                  0      my $oldaction = POSIX::SigAction->new();
9662  ***      0                                  0      sigaction(&POSIX::SIGALRM, $action, $oldaction);
9663                                                  
9664  ***      0                                  0      my $res;
9665  ***      0                                  0      eval {
9666  ***      0                                  0         alarm $t;
9667  ***      0                                  0         $res = <$fh>;
9668  ***      0                                  0         alarm 0;
9669                                                     };
9670  ***      0      0                           0      if ( $EVAL_ERROR ) {
9671  ***      0                                  0         MKDEBUG && _d('Read error:', $EVAL_ERROR);
9672  ***      0      0                           0         die $EVAL_ERROR unless $EVAL_ERROR =~ m/read timeout/;
9673  ***      0                                  0         $oktorun = 0;
9674  ***      0                                  0         $res     = undef;  # res is a blank string after a timeout
9675                                                     }
9676  ***      0                                  0      return $res;
9677                                                  }
9678                                                  
9679                                                  sub get_cxn {
9680           3                    3            41      my ( %args ) = @_;
9681           3                                 18      my @required_args = qw(dsn OptionParser DSNParser);
9682           3                                 18      foreach my $arg ( @required_args ) {
9683  ***      9     50                          59         die "I need a $arg argument" unless $args{$arg};
9684                                                     }
9685           3                                 19      my ($dsn, $o, $dp) = @args{@required_args};
9686                                                  
9687  ***      3     50                          19      if ( $o->get('ask-pass') ) {
9688  ***      0      0                           0         $dsn->{p} = OptionParser::prompt_noecho("Enter password "
9689                                                           . ($args{for} ? "for $args{for}: " : ": "));
9690                                                     }
9691                                                  
9692           3                                 23      my $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), $args{opts});
9693           3                                 13      MKDEBUG && _d('Connected dbh', $dbh);
9694           3                                 31      return $dbh;
9695                                                  }
9696                                                  
9697                                                  sub _d {
9698  ***      0                    0                    my ($package, undef, $line) = caller 0;
9699  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
9700  ***      0                                              map { defined $_ ? $_ : 'undef' }
9701                                                          @_;
9702  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
9703                                                  }
9704                                                  
9705                                                  # ############################################################################
9706                                                  # Run the program.
9707                                                  # ############################################################################
9708                                                  if ( !caller ) { exit main(@ARGV); }
9709                                                  
9710                                                  1; # Because this is a module as well as a script.
9711                                                  
9712                                                  # #############################################################################
9713                                                  # Documentation.
9714                                                  # #############################################################################
9715                                                  
9716                                                  =pod
9717                                                  
9718                                                  =head1 NAME
9719                                                  
9720                                                  mk-query-digest - Parses logs and more.  Analyze, transform, filter, review and
9721                                                  report on queries.
9722                                                  
9723                                                  =head1 SYNOPSIS
9724                                                  
9725                                                  Analyze and report on a slow log:
9726                                                  
9727                                                   mk-query-digest /path/to/slow.log
9728                                                  
9729                                                  Review a slow log, saving results to the test.query_review table in a MySQL
9730                                                  server running on host1.  See L<"--review"> for more on reviewing queries:
9731                                                  
9732                                                   mk-query-digest --review h=host1,D=test,t=query_review /path/to/slow.log
9733                                                  
9734                                                  Watch a server's SHOW FULL PROCESSLIST and analyze the queries as if they were
9735                                                  from a slow query log:
9736                                                  
9737                                                   mk-query-digest --processlist h=host1
9738                                                  
9739                                                  Watch a server's SHOW FULL PROCESSLIST, filter out everything but SELECT
9740                                                  queries, and replay the queries against another server, then use the timings
9741                                                  from replaying them to analyze their performance:
9742                                                  
9743                                                   mk-query-digest --processlist h=host1 --execute h=another_server \
9744                                                     --filter '$event->{fingerprint} =~ m/^select/'
9745                                                  
9746                                                  =head1 RISKS
9747                                                  
9748                                                  The following section is included to inform users about the potential risks,
9749                                                  whether known or unknown, of using this tool.  The two main categories of risks
9750                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
9751                                                  tools) and those created by bugs.
9752                                                  
9753                                                  By default mk-query-digest merely collects and aggregates data from the files
9754                                                  specified.  It is designed to be as efficient as possible, but depending on the
9755                                                  input you give it, it can use a lot of CPU and memory.  Practically speaking, it
9756                                                  is safe to run even on production systems, but you might want to monitor it
9757                                                  until you are satisfied that the input you give it does not cause undue load.
9758                                                  
9759                                                  Various options will cause mk-query-digest to insert data into tables, execute
9760                                                  SQL queries, and so on.  These include the L<"--execute"> option and
9761                                                  L<"--review">.
9762                                                  
9763                                                  At the time of this release, we know of no bugs that could cause serious harm to
9764                                                  users.
9765                                                  
9766                                                  The authoritative source for updated information is always the online issue
9767                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
9768                                                  see a list of such issues at the following URL:
9769                                                  L<http://www.maatkit.org/bugs/mk-query-digest>.
9770                                                  
9771                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
9772                                                  
9773                                                  =head1 DESCRIPTION
9774                                                  
9775                                                  This tool was formerly known as mk-log-parser.
9776                                                  
9777                                                  C<mk-query-digest> is a framework for doing things with events from a query
9778                                                  source such as the slow query log or PROCESSLIST.  By default it acts as a very
9779                                                  sophisticated log analysis tool.  You can group and sort queries in many
9780                                                  different ways simultaneously and find the most expensive queries, or create a
9781                                                  timeline of queries in the log, for example.  It can also do a "query review,"
9782                                                  which means to save a sample of each type of query into a MySQL table so you can
9783                                                  easily see whether you've reviewed and analyzed a query before.  The benefit of
9784                                                  this is that you can keep track of changes to your server's queries and avoid
9785                                                  repeated work.  You can also save other information with the queries, such as
9786                                                  comments, issue numbers in your ticketing system, and so on.
9787                                                  
9788                                                  Note that this is a work in *very* active progress and you should expect
9789                                                  incompatible changes in the future.
9790                                                  
9791                                                  =head1 ATTRIBUTES
9792                                                  
9793                                                  mk-query-digest works on events, which are a collection of key/value pairs
9794                                                  called attributes.  You'll recognize most of the attributes right away:
9795                                                  Query_time, Lock_time, and so on.  You can just look at a slow log and see them.
9796                                                  However, there are some that don't exist in the slow log, and slow logs
9797                                                  may actually include different kinds of attributes (for example, you may have a
9798                                                  server with the Percona patches).
9799                                                  
9800                                                  For a full list of attributes, see
9801                                                  L<http://code.google.com/p/maatkit/wiki/EventAttributes>.
9802                                                  
9803                                                  =head2 memcached
9804                                                  
9805                                                  memcached events have additional attributes related to the memcached protocol:
9806                                                  cmd, key, res (result) and val.  Also, boolean attributes are created for
9807                                                  the various commands, misses and errors: Memc_CMD where CMD is a memcached
9808                                                  command (get, set, delete, etc.), Memc_error and Memc_miss.
9809                                                  
9810                                                  These attributes are no different from slow log attributes, so you can use them
9811                                                  with L<"--[no]report">, L<"--group-by">, in a L<"--filter">, etc.
9812                                                  
9813                                                  These attributes and more are documented at
9814                                                  L<http://code.google.com/p/maatkit/wiki/EventAttributes>.
9815                                                  
9816                                                  =head1 OUTPUT
9817                                                  
9818                                                  The default output is a query analysis report.  The L<"--[no]report"> option
9819                                                  controls whether or not this report is printed.  Sometimes you may wish to
9820                                                  parse all the queries but suppress the report, for example when using
9821                                                  L<"--print"> or L<"--review">.
9822                                                  
9823                                                  There is one paragraph for each class of query analyzed.  A "class" of queries
9824                                                  all have the same value for the L<"--group-by"> attribute which is
9825                                                  "fingerprint" by default.  (See L<"ATTRIBUTES">.)  A fingerprint is an
9826                                                  abstracted version of the query text with literals removed, whitespace
9827                                                  collapsed, and so forth.  The report is formatted so it's easy to paste into
9828                                                  emails without wrapping, and all non-query lines begin with a comment, so you
9829                                                  can save it to a .sql file and open it in your favorite syntax-highlighting
9830                                                  text editor.  There is a response-time profile at the very end.
9831                                                  
9832                                                  The report begins with one paragraph about the entire analysis run.  The
9833                                                  information is very similar to what you'll see for each class of queries in the
9834                                                  log, but it doesn't have some information that would be too expensive to keep
9835                                                  globally for the analysis.  It also has some statistics about the code's
9836                                                  excution itself, such as the CPU and memory usage.
9837                                                  
9838                                                  Following this, each query then appears in a paragraph.  Here's a sample,
9839                                                  slightly reformatted so 'perldoc' will not wrap lines in a terminal.  The
9840                                                  following will all be one paragraph, but we'll break it up for commentary.
9841                                                  
9842                                                   # Query 2: 0.01 QPS, 0.02x conc, ID 0xFDEA8D2993C9CAF3 at byte 160665
9843                                                  
9844                                                  This line identifies the sequential number of the query in the sort order
9845                                                  specified by L<"--order-by">.  Then there's the queries per second, and the
9846                                                  approximate concurrency for this query (calculated as a function of the timespan
9847                                                  and total Query_time).  Next there's a query ID.  This ID is a hex version of
9848                                                  the query's checksum in the database, if you're using L<"--review">.  You can
9849                                                  select the reviewed query's details from the database with a query like C<SELECT
9850                                                  .... WHERE checksum=0xFDEA8D2993C9CAF3>.
9851                                                  
9852                                                  Finally, in case you want to find a sample of the query in the log file, there's
9853                                                  the byte offset where you can look.  (This is not always accurate, due to some
9854                                                  silly anomalies in the slow-log format, but it's usually right.)  The position
9855                                                  refers to the worst sample, which we'll see more about below.
9856                                                  
9857                                                  Next is the table of metrics about this class of queries.
9858                                                  
9859                                                   #           pct   total    min    max     avg     95%  stddev  median
9860                                                   # Count       0       2
9861                                                   # Exec time  13   1105s   552s   554s    553s    554s      2s    553s
9862                                                   # Lock time   0   216us   99us  117us   108us   117us    12us   108us
9863                                                   # Rows sent  20   6.26M  3.13M  3.13M   3.13M   3.13M   12.73   3.13M
9864                                                   # Rows exam   0   6.26M  3.13M  3.13M   3.13M   3.13M   12.73   3.13M
9865                                                  
9866                                                  The first line is column headers for the table.  The percentage is the percent
9867                                                  of the total for the whole analysis run, and the total is the actual value of
9868                                                  the specified metric.  For example, in this case we can see that the query
9869                                                  executed 2 times, which is 13% of the total number of queries in the file.  The
9870                                                  min, max and avg columns are self-explanatory.  The 95% column shows the 95th
9871                                                  percentile; 95% of the values are less than or equal to this value.  The
9872                                                  standard deviation shows you how tightly grouped the values are.  The standard
9873                                                  deviation and median are both calculated from the 95th percentile, discarding
9874                                                  the extremely large values.
9875                                                  
9876                                                  The stddev, median and 95th percentile statistics are approximate.  Exact
9877                                                  statistics require keeping every value seen, sorting, and doing some
9878                                                  calculations on them.  This uses a lot of memory.  To avoid this, we keep 1000
9879                                                  buckets, each of them 5% bigger than the one before, ranging from .000001 up to
9880                                                  a very big number.  When we see a value we increment the bucket into which it
9881                                                  falls.  Thus we have fixed memory per class of queries.  The drawback is the
9882                                                  imprecision, which typically falls in the 5 percent range.
9883                                                  
9884                                                  Next we have statistics on the users, databases and time range for the query.
9885                                                  
9886                                                   # Users       1   user1
9887                                                   # Databases   2     db1(1), db2(1)
9888                                                   # Time range 2008-11-26 04:55:18 to 2008-11-27 00:15:15
9889                                                  
9890                                                  The users and databases are shown as a count of distinct values, followed by the
9891                                                  values.  If there's only one, it's shown alone; if there are many, we show each
9892                                                  of the most frequent ones, followed by the number of times it appears.
9893                                                  
9894                                                   # Query_time distribution
9895                                                   #   1us
9896                                                   #  10us
9897                                                   # 100us
9898                                                   #   1ms
9899                                                   #  10ms
9900                                                   # 100ms
9901                                                   #    1s
9902                                                   #  10s+  #############################################################
9903                                                  
9904                                                  The execution times show a logarithmic chart of time clustering.  Each query
9905                                                  goes into one of the "buckets" and is counted up.  The buckets are powers of
9906                                                  ten.  The first bucket is all values in the "single microsecond range" -- that
9907                                                  is, less than 10us.  The second is "tens of microseconds," which is from 10us
9908                                                  up to (but not including) 100us; and so on.
9909                                                  
9910                                                   # Tables
9911                                                   #    SHOW TABLE STATUS LIKE 'table1'\G
9912                                                   #    SHOW CREATE TABLE `table1`\G
9913                                                   # EXPLAIN
9914                                                   SELECT * FROM table1\G
9915                                                  
9916                                                  This section is a convenience: if you're trying to optimize the queries you see
9917                                                  in the slow log, you probably want to examine the table structure and size.
9918                                                  These are copy-and-paste-ready commands to do that.
9919                                                  
9920                                                  Finally, we see a sample of the queries in this class of query.  This is not a
9921                                                  random sample.  It is the query that performed the worst, according to the sort
9922                                                  order given by L<"--order-by">.  You will normally see a commented C<# EXPLAIN>
9923                                                  line just before it, so you can copy-paste the query to examine its EXPLAIN
9924                                                  plan. But for non-SELECT queries that isn't possible to do, so the tool tries to
9925                                                  transform the query into a roughly equivalent SELECT query, and adds that below.
9926                                                  
9927                                                  If you want to find this sample event in the log, use the offset mentioned
9928                                                  above, and something like the following:
9929                                                  
9930                                                    tail -c +<offset> /path/to/file | head
9931                                                  
9932                                                  The final bit of output is the response-time profile over the events.  This is a
9933                                                  summarized view of what we've already seen.  Here is a sample:
9934                                                  
9935                                                    # Rank Query ID           Response time    Calls   R/Call     Item
9936                                                    # ==== ================== ================ ======= ========== ====
9937                                                    #    1 0x31DA25F95494CA95     0.1494 99.9%       1   0.149435 SHOW
9938                                                    #    2 0x3AEAAD0E15D725B5     0.0001  0.1%       2   0.000041 SET
9939                                                    #    3 0x813031B8BBC3B329     0.0000  0.0%       1   0.000015 COMMIT
9940                                                  
9941                                                  The columns should be fairly self-explanatory: rank, query ID, response time sum
9942                                                  and percentage of total; number of calls and response time per call; and the
9943                                                  distilled query (see L<"distill"> for more detail on this).
9944                                                  
9945                                                  =head1 QUERY REVIEWS
9946                                                  
9947                                                  A "query review" is the process of storing all the query fingerprints analyzed.
9948                                                  This has several benefits:
9949                                                  
9950                                                  =over
9951                                                  
9952                                                  =item *
9953                                                  
9954                                                  You can add meta-data to classes of queries, such as marking them for follow-up,
9955                                                  adding notes to queries, or marking them with an issue ID for your issue
9956                                                  tracking system.
9957                                                  
9958                                                  =item *
9959                                                  
9960                                                  You can refer to the stored values on subsequent runs so you'll know whether
9961                                                  you've seen a query before.  This can help you cut down on duplicated work.
9962                                                  
9963                                                  =item *
9964                                                  
9965                                                  You can store historical data such as the row count, query times, and generally
9966                                                  anything you can see in the report.
9967                                                  
9968                                                  =back
9969                                                  
9970                                                  To use this feature, you run mk-query-digest with the L<"--review"> option.  It
9971                                                  will store the fingerprints and other information into the table you specify.
9972                                                  Next time you run it with the same option, it will do the following:
9973                                                  
9974                                                  =over
9975                                                  
9976                                                  =item *
9977                                                  
9978                                                  It won't show you queries you've already reviewed.  A query is considered to be
9979                                                  already reviewed if you've set a value for the C<reviewed_by> column.  (If you
9980                                                  want to see queries you've already reviewed, use the L<"--report-all"> option.)
9981                                                  
9982                                                  =item *
9983                                                  
9984                                                  Queries that you've reviewed, and don't appear in the output, will cause gaps in
9985                                                  the query number sequence in the first line of each paragraph.  And the value
9986                                                  you've specified for L<"--limit"> will still be honored.  So if you've reviewed all
9987                                                  queries in the top 10 and you ask for the top 10, you won't see anything in the
9988                                                  output.
9989                                                  
9990                                                  =item *
9991                                                  
9992                                                  If you want to see the queries you've already reviewed, you can specify
9993                                                  L<"--report-all">.  Then you'll see the normal analysis output, but you'll also see
9994                                                  the information from the review table, just below the execution time graph.  For
9995                                                  example,
9996                                                  
9997                                                    # Review information
9998                                                    #      comments: really bad IN() subquery, fix soon!
9999                                                    #    first_seen: 2008-12-01 11:48:57
10000                                                   #   jira_ticket: 1933
10001                                                   #     last_seen: 2008-12-18 11:49:07
10002                                                   #      priority: high
10003                                                   #   reviewed_by: xaprb
10004                                                   #   reviewed_on: 2008-12-18 15:03:11
10005                                                 
10006                                                 You can see how useful this meta-data is -- as you analyze your queries, you get
10007                                                 your comments integrated right into the report.
10008                                                 
10009                                                 If you add the L<"--review-history"> option, it will also store information into
10010                                                 a separate database table, so you can keep historical trending information on
10011                                                 classes of queries.
10012                                                 
10013                                                 =back
10014                                                 
10015                                                 =head1 FINGERPRINTS
10016                                                 
10017                                                 A query fingerprint is the abstracted form of a query, which makes it possible
10018                                                 to group similar queries together.  Abstracting a query removes literal values,
10019                                                 normalizes whitespace, and so on.  For example, these two queries:
10020                                                 
10021                                                   SELECT name, password FROM user WHERE id='12823';
10022                                                   select name,   password from user
10023                                                      where id=5;
10024                                                 
10025                                                 Both of those queries will fingerprint to
10026                                                 
10027                                                   select name, password from user where id=?
10028                                                 
10029                                                 Once the query's fingerprint is known, we can then talk about a query as though
10030                                                 it represents all similar queries.
10031                                                 
10032                                                 What C<mk-query-digest> does is analogous to a GROUP BY statement in SQL.
10033                                                 If your command-line looks like this,
10034                                                 
10035                                                   mk-query-digest /path/to/slow.log --select Rows_read,Rows_sent \
10036                                                       --group-by fingerprint --order-by Query_time:sum --limit 10
10037                                                 
10038                                                 The corresponding pseudo-SQL looks like this:
10039                                                 
10040                                                   SELECT WORST(query BY Query_time), SUM(Query_time), ...
10041                                                   FROM /path/to/slow.log
10042                                                   GROUP BY FINGERPRINT(query)
10043                                                   ORDER BY SUM(Query_time) DESC
10044                                                   LIMIT 10
10045                                                 
10046                                                 You can also use the value C<distill>, which is a kind of super-fingerprint.
10047                                                 See L<"--group-by"> for more.
10048                                                 
10049                                                 =head2 memcached
10050                                                 
10051                                                 If parsing memcached input (L<"--type"> memcached), the fingerprint is an
10052                                                 abstracted version of the command and key, with placeholders removed.
10053                                                 For example, "get user_123_preferences" fingerprints to
10054                                                 "get user_?_preferences".
10055                                                 
10056                                                 There is also a "key_print" which a fingerprinted version of the key.  For
10057                                                 the example above, its key_print is "user_?_preferences".
10058                                                 
10059                                                 =head1 OPTIONS
10060                                                 
10061                                                 DSN values in L<"--review-history"> default to values in L<"--review"> if COPY
10062                                                 is yes.
10063                                                 
10064                                                 =over
10065                                                 
10066                                                 =item --ask-pass
10067                                                 
10068                                                 Prompt for a password when connecting to MySQL.
10069                                                 
10070                                                 =item --attribute-aliases
10071                                                 
10072                                                 type: array; default: db|Schema
10073                                                 
10074                                                 List of attribute|alias,etc.
10075                                                 
10076                                                 Certain attributes have multiple names, like db and Schema.  If an event does
10077                                                 not have the priamry attribute, mk-query-digest looks for an alias attribute.
10078                                                 If it finds an alias, it creates the primary attribute with the alias
10079                                                 attribute's value and removes the alias attribute.
10080                                                 
10081                                                 If the event has the primary attribute, all alias attributes are deleted.
10082                                                 
10083                                                 This helps to simplify event attributes so that, for example, there will not
10084                                                 be report lines for both db and Schema.
10085                                                 
10086                                                 =item --attribute-value-limit
10087                                                 
10088                                                 type: int; default: 4294967296
10089                                                 
10090                                                 A sanity limit for attribute values.
10091                                                 
10092                                                 This option deals with bugs in slow-logging functionality that causes large
10093                                                 values for attributes.  If the attribute's value is bigger than this, the
10094                                                 last-seen value for that class of query is used instead.
10095                                                 
10096                                                 =item --aux-dsn
10097                                                 
10098                                                 type: DSN
10099                                                 
10100                                                 Auxiliary DSN used for special options.
10101                                                 
10102                                                 The following options may require a DSN even when only parsing a slow log file:
10103                                                 
10104                                                   * L<"--since">
10105                                                   * L<"--until">
10106                                                 
10107                                                 See each option for why it might require a DSN.
10108                                                 
10109                                                 =item --charset
10110                                                 
10111                                                 short form: -A; type: string
10112                                                 
10113                                                 Default character set.  If the value is utf8, sets Perl's binmode on
10114                                                 STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
10115                                                 runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
10116                                                 binmode on STDOUT without the utf8 layer, and runs SET NAMES after
10117                                                 connecting to MySQL.
10118                                                 
10119                                                 =item --check-attributes-limit
10120                                                 
10121                                                 type: int; default: 1000
10122                                                 
10123                                                 Stop checking for new attributes after this many events.
10124                                                 
10125                                                 For better speed, mk-query-digest stops checking events for new attributes
10126                                                 after a certain number of events.  Any new attributes after this number
10127                                                 will be ignored and will not be reported.
10128                                                 
10129                                                 One special case is new attributes for pre-existing query classes
10130                                                 (see L<"--group-by"> about query classes).  New attributes will not be added
10131                                                 to pre-existing query classes even if the attributes are detected before the
10132                                                 L<"--check-attributes-limit"> limit.
10133                                                 
10134                                                 =item --config
10135                                                 
10136                                                 type: Array
10137                                                 
10138                                                 Read this comma-separated list of config files; if specified, this must be the
10139                                                 first option on the command line.
10140                                                 
10141                                                 =item --[no]continue-on-error
10142                                                 
10143                                                 default: yes
10144                                                 
10145                                                 Continue parsing even if there is an error.
10146                                                 
10147                                                 =item --create-review-history-table
10148                                                 
10149                                                 Create the L<"--review-history"> table if it does not exist.
10150                                                 
10151                                                 This option causes the table specified by L<"--review-history"> to be created
10152                                                 with the default structure shown in the documentation for that option.
10153                                                 
10154                                                 =item --create-review-table
10155                                                 
10156                                                 Create the L<"--review"> table if it does not exist.
10157                                                 
10158                                                 This option causes the table specified by L<"--review"> to be created with the
10159                                                 default structure shown in the documentation for that option.
10160                                                 
10161                                                 =item --daemonize
10162                                                 
10163                                                 Fork to the background and detach from the shell.  POSIX
10164                                                 operating systems only.
10165                                                 
10166                                                 =item --defaults-file
10167                                                 
10168                                                 short form: -F; type: string
10169                                                 
10170                                                 Only read mysql options from the given file.  You must give an absolute pathname.
10171                                                 
10172                                                 =item --embedded-attributes
10173                                                 
10174                                                 type: array
10175                                                 
10176                                                 Two Perl regex patterns to capture pseudo-attributes embedded in queries.
10177                                                 
10178                                                 Embedded attributes might be special attribute-value pairs that you've hidden
10179                                                 in comments.  The first regex should match the entire set of attributes (in
10180                                                 case there are multiple).  The second regex should match and capture
10181                                                 attribute-value pairs from the first regex.
10182                                                 
10183                                                 For example, suppose your query looks like the following:
10184                                                 
10185                                                   SELECT * from users -- file: /login.php, line: 493;
10186                                                 
10187                                                 You might run mk-query-digest with the following option:
10188                                                 
10189                                                   mk-query-digest --embedded-attributes ' -- .*','(\w+): ([^\,]+)'
10190                                                 
10191                                                 The first regular expression captures the whole comment:
10192                                                 
10193                                                   " -- file: /login.php, line: 493;"
10194                                                 
10195                                                 The second one splits it into attribute-value pairs and adds them to the event:
10196                                                 
10197                                                    ATTRIBUTE  VALUE
10198                                                    =========  ==========
10199                                                    file       /login.php
10200                                                    line       493
10201                                                 
10202                                                 B<NOTE>: All commas in the regex patterns must be escaped with \ otherwise
10203                                                 the pattern will break.
10204                                                 
10205                                                 =item --execute
10206                                                 
10207                                                 type: DSN
10208                                                 
10209                                                 Execute queries on this DSN.
10210                                                 
10211                                                 Adds a callback into the chain, after filters but before the reports.  Events
10212                                                 are executed on this DSN.  If they are successful, the time they take to execute
10213                                                 overwrites the event's Query_time attribute.  If unsuccessful, the callback
10214                                                 returns false and terminates the chain.
10215                                                 
10216                                                 If the connection fails, mk-query-digest tries to reconnect once per second.
10217                                                 
10218                                                 See also L<"--mirror"> and L<"--execute-throttle">.
10219                                                 
10220                                                 =item --execute-throttle
10221                                                 
10222                                                 type: array
10223                                                 
10224                                                 Throttle values for L<"--execute">.
10225                                                 
10226                                                 By default L<"--execute"> runs without any limitations or concerns for the
10227                                                 amount of time that it takes to execute the events.  The L<"--execute-throttle">
10228                                                 allows you to limit the amount of time spent doing L<"--execute"> relative
10229                                                 to the other processes that handle events.  This works by marking some events
10230                                                 with a C<Skip_exec> attribute when L<"--execute"> begins to take too much time.
10231                                                 L<"--execute"> will not execute an event if this attribute is true.  This
10232                                                 indirectly decreases the time spent doing L<"--execute">.
10233                                                 
10234                                                 The L<"--execute-throttle"> option takes at least two comma-separated values:
10235                                                 max allowed L<"--execute"> time as a percentage and a check interval time.  An
10236                                                 optional third value is a percentage step for increasing and decreasing the
10237                                                 probability that an event will be marked C<Skip_exec> true.  5 (percent) is
10238                                                 the default step.
10239                                                 
10240                                                 For example: L<"--execute-throttle"> C<70,60,10>.  This will limit
10241                                                 L<"--execute"> to 70% of total event processing time, checked every minute
10242                                                 (60 seconds) and probability stepped up and down by 10%.  When L<"--execute">
10243                                                 exceeds 70%, the probability that events will be marked C<Skip_exec> true
10244                                                 increases by 10%. L<"--execute"> time is checked again after another minute.
10245                                                 If it's still above 70%, then the probability will increase another 10%.
10246                                                 Or, if it's dropped below 70%, then the probability will decrease by 10%.
10247                                                 
10248                                                 =item --expected-range
10249                                                 
10250                                                 type: array; default: 5,10
10251                                                 
10252                                                 Explain items when there are more or fewer than expected.
10253                                                 
10254                                                 Defines the number of items expected to be seen in the report given by
10255                                                 L<"--[no]report">, as controlled by L<"--limit"> and L<"--outliers">.  If
10256                                                 there  are more or fewer items in the report, each one will explain why it was
10257                                                 included.
10258                                                 
10259                                                 =item --explain
10260                                                 
10261                                                 type: DSN
10262                                                 
10263                                                 Run EXPLAIN for the sample query with this DSN and print results.
10264                                                 
10265                                                 This works only when L<"--group-by"> includes fingerprint.  It causes
10266                                                 mk-query-digest to run EXPLAIN and include the output into the report.  For
10267                                                 safety, queries that appear to have a subquery that EXPLAIN will execute won't
10268                                                 be EXPLAINed.  Those are typically "derived table" queries of the form
10269                                                 
10270                                                   select ... from ( select .... ) der;
10271                                                 
10272                                                 =item --filter
10273                                                 
10274                                                 type: string
10275                                                 
10276                                                 Discard events for which this Perl code doesn't return true.
10277                                                 
10278                                                 This option is a string of Perl code or a file containing Perl code that gets
10279                                                 compiled into a subroutine with one argument: $event.  This is a hashref.
10280                                                 If the given value is a readable file, then mk-query-digest reads the entire
10281                                                 file and uses its contents as the code.  The file should not contain
10282                                                 a shebang (#!/usr/bin/perl) line.
10283                                                 
10284                                                 If the code returns true, the chain of callbacks continues; otherwise it ends.
10285                                                 The code is the last statement in the subroutine other than C<return $event>. 
10286                                                 The subroutine template is:
10287                                                 
10288                                                   sub { $event = shift; filter && return $event; }
10289                                                 
10290                                                 Filters given on the command line are wrapped inside parentheses like like
10291                                                 C<( filter )>.  For complex, multi-line filters, you must put the code inside
10292                                                 a file so it will not be wrapped inside parentheses.  Either way, the filter
10293                                                 must produce syntactically valid code given the template.  For example, an
10294                                                 if-else branch given on the command line would not be valid:
10295                                                 
10296                                                   --filter 'if () { } else { }'  # WRONG
10297                                                 
10298                                                 Since it's given on the command line, the if-else branch would be wrapped inside
10299                                                 parentheses which is not syntactically valid.  So to accomplish something more
10300                                                 complex like this would require putting the code in a file, for example
10301                                                 filter.txt:
10302                                                 
10303                                                   my $event_ok; if (...) { $event_ok=1; } else { $event_ok=0; } $event_ok
10304                                                 
10305                                                 Then specify C<--filter filter.txt> to read the code from filter.txt.
10306                                                 
10307                                                 If the filter code won't compile, mk-query-digest will die with an error.
10308                                                 If the filter code does compile, an error may still occur at runtime if the
10309                                                 code tries to do something wrong (like pattern match an undefined value).
10310                                                 mk-query-digest does not provide any safeguards so code carefully!
10311                                                 
10312                                                 An example filter that discards everything but SELECT statements:
10313                                                 
10314                                                   --filter '$event->{arg} =~ m/^select/i'
10315                                                 
10316                                                 This is compiled into a subroutine like the following:
10317                                                 
10318                                                   sub { $event = shift; ( $event->{arg} =~ m/^select/i ) && return $event; }
10319                                                 
10320                                                 It is permissible for the code to have side effects (to alter $event).
10321                                                 
10322                                                 You can find an explanation of the structure of $event at
10323                                                 L<http://code.google.com/p/maatkit/wiki/EventAttributes>.
10324                                                 
10325                                                 Here are more examples of filter code:
10326                                                 
10327                                                 =over
10328                                                 
10329                                                 =item Host/IP matches domain.com
10330                                                 
10331                                                 --filter '($event->{host} || $event->{ip} || "") =~ m/domain.com/'
10332                                                 
10333                                                 Sometimes MySQL logs the host where the IP is expected.  Therefore, we
10334                                                 check both.
10335                                                 
10336                                                 =item User matches john
10337                                                 
10338                                                 --filter '($event->{user} || "") =~ m/john/'
10339                                                 
10340                                                 =item More than 1 warning
10341                                                 
10342                                                 --filter '($event->{Warning_count} || 0) > 1'
10343                                                 
10344                                                 =item Query does full table scan or full join
10345                                                 
10346                                                 --filter '(($event->{Full_scan} || "") eq "Yes") || (($event->{Full_join} || "") eq "Yes")'
10347                                                 
10348                                                 =item Query was not served from query cache
10349                                                 
10350                                                 --filter '($event->{QC_Hit} || "") eq "No"'
10351                                                 
10352                                                 =item Query is 1 MB or larger
10353                                                 
10354                                                 --filter '$event->{bytes} >= 1_048_576'
10355                                                 
10356                                                 =back
10357                                                 
10358                                                 =item --fingerprints
10359                                                 
10360                                                 Add query fingerprints to the standard query analysis report.  This is mostly
10361                                                 useful for debugging purposes.
10362                                                 
10363                                                 =item --[no]for-explain
10364                                                 
10365                                                 default: yes
10366                                                 
10367                                                 Print extra information to make analysis easy.
10368                                                 
10369                                                 This option adds code snippets to make it easy to run SHOW CREATE TABLE and SHOW
10370                                                 TABLE STATUS for the query's tables.  It also rewrites non-SELECT queries into a
10371                                                 SELECT that might be helpful for determining the non-SELECT statement's index
10372                                                 usage.
10373                                                 
10374                                                 =item --group-by
10375                                                 
10376                                                 type: Array; default: fingerprint
10377                                                 
10378                                                 Which attribute of the events to group by.
10379                                                 
10380                                                 In general, you can group queries into classes based on any attribute of the
10381                                                 query, such as C<user> or C<db>, which will by default show you which users
10382                                                 and which databases get the most C<Query_time>.  The default attribute,
10383                                                 C<fingerprint>, groups similar, abstracted queries into classes; see below
10384                                                 and see also L<"FINGERPRINTS">.
10385                                                 
10386                                                 A report is printed for each L<"--group-by"> value (unless C<--no-report> is
10387                                                 given).  Therefore, C<--group-by user,db> means "report on queries with the
10388                                                 same user and report on queries with the same db"--it does not mean "report
10389                                                 on queries with the same user and db."  See also L<"OUTPUT">.
10390                                                 
10391                                                 Every value must have a corresponding value in the same position in
10392                                                 L<"--order-by">.  However, adding values to L<"--group-by"> will automatically
10393                                                 add values to L<"--order-by">, for your convenience.
10394                                                 
10395                                                 There are several magical values that cause some extra data mining to happen
10396                                                 before the grouping takes place:
10397                                                 
10398                                                 =over
10399                                                 
10400                                                 =item fingerprint
10401                                                 
10402                                                 This causes events to be fingerprinted to abstract queries into
10403                                                 a canonical form, which is then used to group events together into a class.
10404                                                 See L<"FINGERPRINTS"> for more about fingerprinting.
10405                                                 
10406                                                 =item tables
10407                                                 
10408                                                 This causes events to be inspected for what appear to be tables, and
10409                                                 then aggregated by that.  Note that a query that contains two or more tables
10410                                                 will be counted as many times as there are tables; so a join against two tables
10411                                                 will count the Query_time against both tables.
10412                                                 
10413                                                 =item distill
10414                                                 
10415                                                 This is a sort of super-fingerprint that collapses queries down
10416                                                 into a suggestion of what they do, such as C<INSERT SELECT table1 table2>.
10417                                                 
10418                                                 =back
10419                                                 
10420                                                 If parsing memcached input (L<"--type"> memcached), there are other
10421                                                 attributes which you can group by: key_print (see memcached section in
10422                                                 L<"FINGERPRINTS">), cmd, key, res and val (see memcached section in
10423                                                 L<"ATTRIBUTES">).
10424                                                 
10425                                                 =item --help
10426                                                 
10427                                                 Show help and exit.
10428                                                 
10429                                                 =item --host
10430                                                 
10431                                                 short form: -h; type: string
10432                                                 
10433                                                 Connect to host.
10434                                                 
10435                                                 =item --ignore-attributes
10436                                                 
10437                                                 type: array; default: arg, cmd, insert_id, ip, port, Thread_id, timestamp, exptime, flags, key, res, val, server_id, offset, end_log_pos, Xid
10438                                                 
10439                                                 Do not aggregate these attributes when auto-detecting L<"--select">.
10440                                                 
10441                                                 If you do not specify L<"--select"> then mk-query-digest auto-detects and
10442                                                 aggregates every attribute that it finds in the slow log.  Some attributes,
10443                                                 however, should not be aggregated.  This option allows you to specify a list
10444                                                 of attributes to ignore.  This only works when no explicit L<"--select"> is
10445                                                 given.
10446                                                 
10447                                                 =item --inherit-attributes
10448                                                 
10449                                                 type: array; default: db,ts
10450                                                 
10451                                                 If missing, inherit these attributes from the last event that had them.
10452                                                 
10453                                                 This option sets which attributes are inherited or carried forward to events
10454                                                 which do not have them.  For example, if one event has the db attribute equal
10455                                                 to "foo", but the next event doesn't have the db attribute, then it inherits
10456                                                 "foo" for its db attribute.
10457                                                 
10458                                                 Inheritance is usually desirable, but in some cases it might confuse things.
10459                                                 If a query inherits a database that it doesn't actually use, then this could
10460                                                 confuse L<"--execute">.
10461                                                 
10462                                                 =item --interval
10463                                                 
10464                                                 type: float; default: .1
10465                                                 
10466                                                 How frequently to poll the processlist, in seconds.
10467                                                 
10468                                                 =item --iterations
10469                                                 
10470                                                 type: int; default: 1
10471                                                 
10472                                                 How many times to iterate through the collect-and-report cycle.  If 0, iterate
10473                                                 to infinity.  See also L<"--run-time">.
10474                                                 
10475                                                 =item --limit
10476                                                 
10477                                                 type: Array; default: 95%:20
10478                                                 
10479                                                 Limit output to the given percentage or count.
10480                                                 
10481                                                 If the argument is an integer, report only the top N worst queries.  If the
10482                                                 argument is an integer followed by the C<%> sign, report that percentage of the
10483                                                 worst queries.  If the percentage is followed by a colon and another integer,
10484                                                 report the top percentage or the number specified by that integer, whichever
10485                                                 comes first.
10486                                                 
10487                                                 The value is actually a comma-separated array of values, one for each item in
10488                                                 L<"--group-by">.  If you don't specify a value for any of those items, the
10489                                                 default is the top 95%.
10490                                                 
10491                                                 See also L<"--outliers">.
10492                                                 
10493                                                 =item --log
10494                                                 
10495                                                 type: string
10496                                                 
10497                                                 Print all output to this file when daemonized.
10498                                                 
10499                                                 =item --mirror
10500                                                 
10501                                                 type: float
10502                                                 
10503                                                 How often to check whether connections should be moved, depending on
10504                                                 C<read_only>.  Requires L<"--processlist"> and L<"--execute">.
10505                                                 
10506                                                 This option causes mk-query-digest to check every N seconds whether it is reading
10507                                                 from a read-write server and executing against a read-only server, which is a
10508                                                 sensible way to set up two servers if you're doing something like master-master
10509                                                 replication.  The L<http://code.google.com/p/mysql-master-master/> master-master
10510                                                 toolkit does this. The aim is to keep the passive server ready for failover,
10511                                                 which is impossible without putting it under a realistic workload.
10512                                                 
10513                                                 =item --order-by
10514                                                 
10515                                                 type: Array; default: Query_time:sum
10516                                                 
10517                                                 Sort events by this attribute and aggregate function.
10518                                                 
10519                                                 This is a comma-separated list of order-by expressions, one for each
10520                                                 L<"--group-by"> attribute.  The default C<Query_time:sum> is used for
10521                                                 L<"--group-by"> attributes without explicitly given L<"--order-by"> attributes
10522                                                 (that is, if you specify more L<"--group-by"> attributes than corresponding
10523                                                 L<"--order-by"> attributes).  The syntax is C<attribute:aggregate>.  See
10524                                                 L<"ATTRIBUTES"> for valid attributes.  Valid aggregates are:
10525                                                 
10526                                                    Aggregate Meaning
10527                                                    ========= ============================
10528                                                    sum       Sum/total attribute value
10529                                                    min       Minimum attribute value
10530                                                    max       Maximum attribute value
10531                                                    cnt       Frequency/count of the query
10532                                                 
10533                                                 For example, the default C<Query_time:sum> means that queries in the
10534                                                 query analysis report will be ordered (sorted) by their total query execution
10535                                                 time ("Exec time").  C<Query_time:max> orders the queries by their
10536                                                 maximum query execution time, so the query with the single largest
10537                                                 C<Query_time> will be list first.  C<cnt> refers more to the frequency
10538                                                 of the query as a whole, how often it appears; "Count" is its corresponding
10539                                                 line in the query analysis report.  So any attribute and C<cnt> should yield
10540                                                 the same report wherein queries are sorted by the number of times they
10541                                                 appear.
10542                                                 
10543                                                 When parsing general logs (L<"--type"> C<genlog>), the default L<"--order-by">
10544                                                 becomes C<Query_time:cnt>.  General logs do not report query times so only
10545                                                 the C<cnt> aggregate makes sense because all query times are zero.
10546                                                 
10547                                                 If you specify an attribute that doesn't exist in the events, then
10548                                                 mk-query-digest falls back to the default C<Query_time:sum> and prints a notice
10549                                                 at the beginning of the report for each query class.
10550                                                 
10551                                                 =item --outliers
10552                                                 
10553                                                 type: array; default: Query_time:1:10
10554                                                 
10555                                                 Report outliers by attribute:percentile:count.
10556                                                 
10557                                                 The syntax of this option is a comma-separated list of colon-delimited strings.
10558                                                 The first field is the attribute by which an outlier is defined.  The second is
10559                                                 a number that is compared to the attribute's 95th percentile.  The third is
10560                                                 optional, and is compared to the attribute's cnt aggregate.  Queries that pass
10561                                                 this specification are added to the report, regardless of any limits you
10562                                                 specified in L<"--limit">.
10563                                                 
10564                                                 For example, to report queries whose 95th percentile Query_time is at least 60
10565                                                 seconds and which are seen at least 5 times, use the following argument:
10566                                                 
10567                                                   --outliers Query_time:60:5
10568                                                 
10569                                                 You can specify an --outliers option for each value in L<"--group-by">.
10570                                                 
10571                                                 =item --password
10572                                                 
10573                                                 short form: -p; type: string
10574                                                 
10575                                                 Password to use when connecting.
10576                                                 
10577                                                 =item --pid
10578                                                 
10579                                                 type: string
10580                                                 
10581                                                 Create the given PID file when daemonized.  The file contains the process
10582                                                 ID of the daemonized instance.  The PID file is removed when the
10583                                                 daemonized instance exits.  The program checks for the existence of the
10584                                                 PID file when starting; if it exists and the process with the matching PID
10585                                                 exists, the program exits.
10586                                                 
10587                                                 =item --pipeline-profile
10588                                                 
10589                                                 Print a profile of the pipeline processes.
10590                                                 
10591                                                 =item --port
10592                                                 
10593                                                 short form: -P; type: int
10594                                                 
10595                                                 Port number to use for connection.
10596                                                 
10597                                                 =item --print
10598                                                 
10599                                                 Print log events to STDOUT in standard slow-query-log format.
10600                                                 
10601                                                 =item --print-iterations
10602                                                 
10603                                                 Print the start time for each L<"--iterations">.
10604                                                 
10605                                                 This option causes a line like the following to be printed at the start
10606                                                 of each L<"--iterations"> report:
10607                                                 
10608                                                   # Iteration 2 started at 2009-11-24T14:39:48.345780 
10609                                                 
10610                                                 This line will print even if C<--no-report> is specified.  If C<--iterations 0>
10611                                                 is specified, each iteration number will be C<0>.
10612                                                 
10613                                                 =item --processlist
10614                                                 
10615                                                 type: DSN
10616                                                 
10617                                                 Poll this DSN's processlist for queries, with L<"--interval"> sleep between.
10618                                                 
10619                                                 If the connection fails, mk-query-digest tries to reopen it once per second. See
10620                                                 also L<"--mirror">.
10621                                                 
10622                                                 =item --read-timeout
10623                                                 
10624                                                 type: time; default: 0
10625                                                 
10626                                                 Wait this long for an event from the input; 0 to wait forever.
10627                                                 
10628                                                 This option sets the maximum time to wait for an event from the input.  It
10629                                                 applies to all types of input except L<"--processlist">.  If an
10630                                                 event is not received after the specified time, the script stops reading the
10631                                                 input and prints its reports.  If L<"--iterations"> is 0 or greater than
10632                                                 1, the next iteration will begin, else the script will exit.
10633                                                 
10634                                                 This option requires the Perl POSIX module.
10635                                                 
10636                                                 =item --[no]report
10637                                                 
10638                                                 default: yes
10639                                                 
10640                                                 Print out reports on the aggregate results from L<"--group-by">.
10641                                                 
10642                                                 This is the standard slow-log analysis functionality.  See L<"OUTPUT"> for the
10643                                                 description of what this does and what the results look like.
10644                                                 
10645                                                 =item --report-all
10646                                                 
10647                                                 Include all queries, even if they have already been reviewed.
10648                                                 
10649                                                 =item --report-format
10650                                                 
10651                                                 type: Hash; default: rusage,header,query_report,profile,prepared
10652                                                 
10653                                                 Print these elements in the query analysis report.  Valid element names are
10654                                                 rusage, header, query_report, profile and prepared.  The rusage is information
10655                                                 about CPU times and memory usage.  The header is information about the entire
10656                                                 analysis run.  The query_report is detailed information on each query in the
10657                                                 report.  The profile is a compact table of queries for an at-a-glance view of
10658                                                 the report. Order does not matter; you cannot use this parameter to influence
10659                                                 the order of items in the report, only the presence or absence of items.
10660                                                 The prepared report listed prepared statements, the number of times each
10661                                                 was prepared and executed.  It only prints if there were prepared statements.
10662                                                 
10663                                                 See L<"OUTPUT"> for more information on the various parts of the query report.
10664                                                 
10665                                                 =item --review
10666                                                 
10667                                                 type: DSN
10668                                                 
10669                                                 Store a sample of each class of query in this DSN.
10670                                                 
10671                                                 The argument specifies a table to store all unique query fingerprints in.  The
10672                                                 table must have at least the following columns.  You can add more columns for
10673                                                 your own special purposes, but they won't be used by mk-query-digest.  The
10674                                                 following CREATE TABLE definition is also used for L<"--create-review-table">.
10675                                                 MAGIC_create_review:
10676                                                 
10677                                                   CREATE TABLE query_review (
10678                                                      checksum     BIGINT UNSIGNED NOT NULL PRIMARY KEY,
10679                                                      fingerprint  TEXT NOT NULL,
10680                                                      sample       TEXT NOT NULL,
10681                                                      first_seen   DATETIME,
10682                                                      last_seen    DATETIME,
10683                                                      reviewed_by  VARCHAR(20),
10684                                                      reviewed_on  DATETIME,
10685                                                      comments     TEXT
10686                                                   )
10687                                                 
10688                                                 The columns are as follows:
10689                                                 
10690                                                   COLUMN       MEANING
10691                                                   ===========  ===============
10692                                                   checksum     A 64-bit checksum of the query fingerprint
10693                                                   fingerprint  The abstracted version of the query; its primary key
10694                                                   sample       The query text of a sample of the class of queries
10695                                                   first_seen   The smallest timestamp of this class of queries
10696                                                   last_seen    The largest timestamp of this class of queries
10697                                                   reviewed_by  Initially NULL; if set, query is skipped thereafter
10698                                                   reviewed_on  Initially NULL; not assigned any special meaning
10699                                                   comments     Initially NULL; not assigned any special meaning
10700                                                 
10701                                                 Note that the C<fingerprint> column is the true primary key for a class of
10702                                                 queries.  The C<checksum> is just a cryptographic hash of this value, which
10703                                                 provides a shorter value that is very likely to also be unique.
10704                                                 
10705                                                 After parsing and aggregating events, your table should contain a row for each
10706                                                 fingerprint.  This option depends on C<--group-by fingerprint> (which is the
10707                                                 default).  It will not work otherwise.
10708                                                 
10709                                                 =item --review-history
10710                                                 
10711                                                 type: DSN
10712                                                 
10713                                                 The table in which to store historical values for review trend analysis.
10714                                                 
10715                                                 Each time you review queries with L<"--review">, mk-query-digest will save
10716                                                 information into this table so you can see how classes of queries have changed
10717                                                 over time.
10718                                                 
10719                                                 This DSN inherits unspecified values from L<"--review">.  It should mention a
10720                                                 table in which to store statistics about each class of queries.  mk-query-digest
10721                                                 verifies the existence of the table, and your privileges to insert, delete and
10722                                                 update on that table.
10723                                                 
10724                                                 mk-query-digest then inspects the columns in the table.  The table must have at
10725                                                 least the following columns:
10726                                                 
10727                                                   CREATE TABLE query_review_history (
10728                                                     checksum     BIGINT UNSIGNED NOT NULL,
10729                                                     sample       TEXT NOT NULL
10730                                                   );
10731                                                 
10732                                                 Any columns not mentioned above are inspected to see if they follow a certain
10733                                                 naming convention.  The column is special if the name ends with an underscore
10734                                                 followed by any of these MAGIC_history_cols values:
10735                                                 
10736                                                   pct|avt|cnt|sum|min|max|pct_95|stddev|median|rank
10737                                                 
10738                                                 If the column ends with one of those values, then the prefix is interpreted as
10739                                                 the event attribute to store in that column, and the suffix is interpreted as
10740                                                 the metric to be stored.  For example, a column named Query_time_min will be
10741                                                 used to store the minimum Query_time for the class of events.  The presence of
10742                                                 this column will also add Query_time to the L<"--select"> list.
10743                                                 
10744                                                 The table should also have a primary key, but that is up to you, depending on
10745                                                 how you want to store the historical data.  We suggest adding ts_min and ts_max
10746                                                 columns and making them part of the primary key along with the checksum.  But
10747                                                 you could also just add a ts_min column and make it a DATE type, so you'd get
10748                                                 one row per class of queries per day.
10749                                                 
10750                                                 The default table structure follows.  The following MAGIC_create_review_history
10751                                                 table definition is used for L<"--create-review-history-table">:
10752                                                 
10753                                                  CREATE TABLE query_review_history (
10754                                                    checksum             BIGINT UNSIGNED NOT NULL,
10755                                                    sample               TEXT NOT NULL,
10756                                                    ts_min               DATETIME,
10757                                                    ts_max               DATETIME,
10758                                                    ts_cnt               FLOAT,
10759                                                    Query_time_sum       FLOAT,
10760                                                    Query_time_min       FLOAT,
10761                                                    Query_time_max       FLOAT,
10762                                                    Query_time_pct_95    FLOAT,
10763                                                    Query_time_stddev    FLOAT,
10764                                                    Query_time_median    FLOAT,
10765                                                    Lock_time_sum        FLOAT,
10766                                                    Lock_time_min        FLOAT,
10767                                                    Lock_time_max        FLOAT,
10768                                                    Lock_time_pct_95     FLOAT,
10769                                                    Lock_time_stddev     FLOAT,
10770                                                    Lock_time_median     FLOAT,
10771                                                    Rows_sent_sum        FLOAT,
10772                                                    Rows_sent_min        FLOAT,
10773                                                    Rows_sent_max        FLOAT,
10774                                                    Rows_sent_pct_95     FLOAT,
10775                                                    Rows_sent_stddev     FLOAT,
10776                                                    Rows_sent_median     FLOAT,
10777                                                    Rows_examined_sum    FLOAT,
10778                                                    Rows_examined_min    FLOAT,
10779                                                    Rows_examined_max    FLOAT,
10780                                                    Rows_examined_pct_95 FLOAT,
10781                                                    Rows_examined_stddev FLOAT,
10782                                                    Rows_examined_median FLOAT,
10783                                                    PRIMARY KEY(checksum, ts_min, ts_max)
10784                                                  );
10785                                                 
10786                                                 Note that we store the count (cnt) for the ts attribute only; it will be
10787                                                 redundant to store this for other attributes.
10788                                                 
10789                                                 =item --run-time
10790                                                 
10791                                                 type: time
10792                                                 
10793                                                 How long to run before exiting.  The default is to run forever (you can
10794                                                 interrupt with CTRL-C).  See also L<"--iterations">.
10795                                                 
10796                                                 =item --sample
10797                                                 
10798                                                 type: int
10799                                                 
10800                                                 Filter out all but the first N occurrences of each query.  The queries are
10801                                                 filtered on the first value in L<"--group-by">, so by default, this will filter
10802                                                 by query fingerprint.  For example, C<--sample 2> will permit two sample queries
10803                                                 for each fingerprint.  Useful in conjunction with L<"--print"> to print out the
10804                                                 queries.  You probably want to set C<--no-report> to avoid the overhead of
10805                                                 aggregating and reporting if you're just using this to print out samples of
10806                                                 queries.  A complete example:
10807                                                 
10808                                                   mk-query-digest --sample 2 --no-report --print slow.log
10809                                                 
10810                                                 =item --select
10811                                                 
10812                                                 type: Array
10813                                                 
10814                                                 Compute aggregate statistics for these attributes.
10815                                                 
10816                                                 By default mk-query-digest auto-detects, aggregates and prints metrics for
10817                                                 every query attribute that it finds in the slow query log.  This option
10818                                                 specifies a list of only the attributes that you want.  You can specify an
10819                                                 alternative attribute with a colon.  For example, C<db:Schema> uses db if it's
10820                                                 available, and Schema if it's not.
10821                                                 
10822                                                 Previously, mk-query-digest only aggregated these attributes:
10823                                                 
10824                                                   Query_time,Lock_time,Rows_sent,Rows_examined,user,db:Schema,ts
10825                                                 
10826                                                 Attributes specified in the L<"--review-history"> table will always be selected 
10827                                                 even if you do not specify L<"--select">.
10828                                                 
10829                                                 See also L<"--ignore-attributes"> and L<"ATTRIBUTES">.
10830                                                 
10831                                                 =item --set-vars
10832                                                 
10833                                                 type: string; default: wait_timeout=10000
10834                                                 
10835                                                 Set these MySQL variables.  Immediately after connecting to MySQL, this
10836                                                 string will be appended to SET and executed.
10837                                                 
10838                                                 =item --shorten
10839                                                 
10840                                                 type: int; default: 1024
10841                                                 
10842                                                 Shorten long statements in reports.
10843                                                 
10844                                                 Shortens long statements, replacing the omitted portion with a C</*... omitted
10845                                                 ...*/> comment.  This applies only to the output in reports, not to information
10846                                                 stored for L<"--review"> or other places.  It prevents a large statement from
10847                                                 causing difficulty in a report.  The argument is the preferred length of the
10848                                                 shortened statement.  Not all statements can be shortened, but very large INSERT
10849                                                 and similar statements often can; and so can IN() lists, although only the first
10850                                                 such list in the statement will be shortened.
10851                                                 
10852                                                 If it shortens something beyond recognition, you can find the original statement
10853                                                 in the log, at the offset shown in the report header (see L<"OUTPUT">).
10854                                                 
10855                                                 =item --since
10856                                                 
10857                                                 type: string
10858                                                 
10859                                                 Parse only queries newer than this value (parse queries since this date).
10860                                                 
10861                                                 This option allows you to ignore queries older than a certain value and parse
10862                                                 only those queries which are more recent than the value.  The value can be
10863                                                 several types:
10864                                                 
10865                                                   * Simple time value N with optional suffix: N[shmd], where
10866                                                     s=seconds, h=hours, m=minutes, d=days (default s if no suffix
10867                                                     given); this is like saying "since N[shmd] ago"
10868                                                   * Full date with optional hours:minutes:seconds: YYYY-MM-DD [HH:MM::SS]
10869                                                   * Short, MySQL-style date: YYMMDD [HH:MM:SS]
10870                                                   * Any time expression evaluated by MySQL: C<CURRENT_DATE - INTERVAL 7 DAY>
10871                                                 
10872                                                 If you give a MySQL time expression, then you must also specifiy a DSN
10873                                                 so that mk-query-digest can connect to MySQL to evalue the expression.  If you
10874                                                 specify L<"--execute">, L<"--explain">, L<"--processlist">, L<"--review">
10875                                                 or L<"--review-history">, then one of these DSNs will be used automatically.
10876                                                 Otherwise, you must specify an L<"--aux-dsn"> or mk-query-digest will die
10877                                                 saying that the value is invalid.
10878                                                 
10879                                                 The MySQL time expression is warpped inside a query like
10880                                                 "SELECT UNIX_TIMESTAMP(<expression>)", so be sure that the expression is
10881                                                 valid inside this query.  For example, do not use UNIX_TIMESTAMP() because
10882                                                 UNIX_TIMESTAMP(UNIX_TIMESTAMP()) returns 0.
10883                                                 
10884                                                 Events are assumed to be in chronological--older events at the beginning of
10885                                                 the log and newer events at the end of the log.  L<"--since"> is strict: it
10886                                                 ignores all queries until one is found that is new enough.  Therefore, if
10887                                                 the query events are not consistently timestamped, some may be ignored which
10888                                                 are actually new enough.
10889                                                 
10890                                                 See also L<"--until">.
10891                                                 
10892                                                 =item --socket
10893                                                 
10894                                                 short form: -S; type: string
10895                                                 
10896                                                 Socket file to use for connection.
10897                                                 
10898                                                 =item --statistics
10899                                                 
10900                                                 Print statistics.
10901                                                 
10902                                                 =item --table-access
10903                                                 
10904                                                 Print a table access report.
10905                                                 
10906                                                 The table access report shows which tables are accessed by all the queries
10907                                                 and if the access is a read or write.  The report looks like:
10908                                                 
10909                                                   write `baz`.`tbl`
10910                                                   read `baz`.`new_tbl`
10911                                                   write `baz`.`tbl3`
10912                                                   write `db6`.`tbl6`
10913                                                 
10914                                                 If you pipe the output to L<sort>, the read and write tables will be grouped
10915                                                 together and sorted alphabetically:
10916                                                 
10917                                                   read `baz`.`new_tbl`
10918                                                   write `baz`.`tbl`
10919                                                   write `baz`.`tbl3`
10920                                                   write `db6`.`tbl6`
10921                                                 
10922                                                 =item --tcpdump-errors
10923                                                 
10924                                                 type: string
10925                                                 
10926                                                 Write the tcpdump data to this file on error.  If mk-query-digest doesn't
10927                                                 parse the stream correctly for some reason, the session's packets since the
10928                                                 last query event will be written out to create a usable test case.  If this
10929                                                 happens, mk-query-digest will not raise an error; it will just discard the
10930                                                 session's saved state and permit the tool to continue working.  See L<"tcpdump">
10931                                                 for more information about parsing tcpdump output.
10932                                                 
10933                                                 =item --timeline
10934                                                 
10935                                                 Show a timeline of events.
10936                                                 
10937                                                 This option makes mk-query-digest print another kind of report: a timeline of
10938                                                 the events.  Each query is still grouped and aggregate into classes according to
10939                                                 L<"--group-by">, but then they are printed in chronological order.  The timeline
10940                                                 report prints out the timestamp, interval, count and value of each classes.
10941                                                 
10942                                                 If all you want is the timeline report, then specifiy C<--no-report> to
10943                                                 suppress the default query analysis report.  Otherwise, the timeline report
10944                                                 will be printed at the end before the response-time profile
10945                                                 (see L<"--report-format"> and L<"OUTPUT">).
10946                                                 
10947                                                 For example, this:
10948                                                 
10949                                                   mk-query-digest /path/to/log --group-by distill --timeline
10950                                                 
10951                                                 will print something like:
10952                                                 
10953                                                   # ########################################################################
10954                                                   # distill report
10955                                                   # ########################################################################
10956                                                   # 2009-07-25 11:19:27 1+00:00:01   2 SELECT foo
10957                                                   # 2009-07-27 11:19:30      00:01   2 SELECT bar
10958                                                   # 2009-07-27 11:30:00 1+06:30:00   2 SELECT foo
10959                                                 
10960                                                 =item --type
10961                                                 
10962                                                 type: Array
10963                                                 
10964                                                 The type of input to parse (default slowlog).  The permitted types are
10965                                                 
10966                                                 =over
10967                                                 
10968                                                 =item binlog
10969                                                 
10970                                                 Parse a binary log file.
10971                                                 
10972                                                 =item genlog
10973                                                 
10974                                                 Parse a MySQL general log file.  General logs lack a lot of L<"ATTRIBUTES">,
10975                                                 notably C<Query_time>.  The default L<"--order-by"> for general logs
10976                                                 changes to C<Query_time:cnt>.
10977                                                 
10978                                                 =item http
10979                                                 
10980                                                 Parse HTTP traffic from tcpdump.
10981                                                 
10982                                                 =item slowlog
10983                                                 
10984                                                 Parse a log file in any variation of MySQL slow-log format.
10985                                                 
10986                                                 =item tcpdump
10987                                                 
10988                                                 Inspect network packets and decode the MySQL client protocol, extracting queries
10989                                                 and responses from it.
10990                                                 
10991                                                 mk-query-digest does not actually watch the network (i.e. it does NOT "sniff
10992                                                 packets").  Instead, it's just parsing the output of tcpdump.  You are
10993                                                 responsible for generating this output; mk-query-digest does not do it for you.
10994                                                 Then you send this to mk-query-digest as you would any log file: as files on the
10995                                                 command line or to STDIN.
10996                                                 
10997                                                 The parser expects the input to be formatted with the following options: C<-x -n
10998                                                 -q -tttt>.  For example, if you want to capture output from your local machine,
10999                                                 you can do something like
11000                                                 
11001                                                   tcpdump -i eth0 port 3306 -s 65535 -c 1000 -x -n -q -tttt > mysql.tcp.txt
11002                                                   mk-query-digest --type tcpdump mysql.tcp.txt
11003                                                 
11004                                                 The other tcpdump parameters, such as -s, -c, and -i, are up to you.  Just make
11005                                                 sure the output looks like this:
11006                                                 
11007                                                   2009-04-12 09:50:16.804849 IP 127.0.0.1.42167 > 127.0.0.1.3306: tcp 37
11008                                                       0x0000:  4508 0059 6eb2 4000 4006 cde2 7f00 0001
11009                                                       0x0010:  ....
11010                                                 
11011                                                 Remember tcpdump has a handy -c option to stop after it captures some number of
11012                                                 packets!  That's very useful for testing your tcpdump command.  Note that
11013                                                 tcpdump can't capture traffic on a Unix socket.  Read
11014                                                 L<http://bugs.mysql.com/bug.php?id=31577> if you're confused about this.
11015                                                 
11016                                                 All MySQL servers running on port 3306 are automatically detected in the
11017                                                 tcpdump output.  Therefore, if the tcpdump out contains packets from
11018                                                 multiple servers on port 3306 (for example, 10.0.0.1:3306, 10.0.0.2:3306,
11019                                                 etc.), all packets/queries from all these servers will be analyzed
11020                                                 together as if they were one server.
11021                                                 
11022                                                 If you're analyzing traffic for a MySQL server that is not running on port
11023                                                 3306, see L<"--watch-server">.
11024                                                 
11025                                                 Also note that mk-query-digest may fail to report the database for queries
11026                                                 when parsing tcpdump output.  The database is discovered only in the initial
11027                                                 connect events for a new client or when <USE db> is executed.  If the tcpdump
11028                                                 output contains neither of these, then mk-query-digest cannot discover the
11029                                                 database.
11030                                                 
11031                                                 The MySQL client protocol implementation is not complete; server-side prepared
11032                                                 statements are not yet supported, and naturally, SSL-encrypted traffic cannot be
11033                                                 inspected and decoded.
11034                                                 
11035                                                 =item memcached
11036                                                 
11037                                                 Similar to tcpdump, but the expected input is memcached packets
11038                                                 instead of MySQL packets.  For example:
11039                                                 
11040                                                   tcpdump -i eth0 port 11211 -s 65535 -x -n -q -tttt > memcached.tcp.txt
11041                                                   mk-query-digest --type memcached memcached.tcp.txt
11042                                                 
11043                                                 memcached uses port 11211 by default.
11044                                                 
11045                                                 =back
11046                                                 
11047                                                 =item --until
11048                                                 
11049                                                 type: string
11050                                                 
11051                                                 Parse only queries older than this value (parse queries until this date).
11052                                                 
11053                                                 This option allows you to ignore queries newer than a certain value and parse
11054                                                 only those queries which are older than the value.  The value can be one of
11055                                                 the same types listed for L<"--since">.
11056                                                 
11057                                                 Unlike L<"--since">, L<"--until"> is not strict: all queries are parsed until
11058                                                 one has a timestamp that is equal to or greater than L<"--until">.  Then
11059                                                 all subsequent queries are ignored.
11060                                                 
11061                                                 =item --user
11062                                                 
11063                                                 short form: -u; type: string
11064                                                 
11065                                                 User for login if not current user.
11066                                                 
11067                                                 =item --version
11068                                                 
11069                                                 Show version and exit.
11070                                                 
11071                                                 =item --watch-server
11072                                                 
11073                                                 type: string
11074                                                 
11075                                                 This option tells mk-query-digest which server IP address and port (like
11076                                                 "10.0.0.1:3306") to watch when parsing tcpdump (for L<"--type"> tcpdump and
11077                                                 memcached); all other servers are ignored.  If you don't specify it,
11078                                                 mk-query-digest watches all servers by looking for any IP address using port
11079                                                 3306 or "mysql".  If you're watching a server with a non-standard port, this
11080                                                 won't work, so you must specify the IP address and port to watch.
11081                                                 
11082                                                 If you want to watch a mix of servers, some running on standard port 3306
11083                                                 and some running on non-standard ports, you need to create separate
11084                                                 tcpdump outputs for the non-stanard port servers and then specify this
11085                                                 option for each.  At present mk-query-digest cannot auto-detect servers on
11086                                                 port 3306 and also be told to watch a server on a non-standard port.
11087                                                 
11088                                                 =item --[no]zero-admin
11089                                                 
11090                                                 default: yes
11091                                                 
11092                                                 Zero out the Rows_XXX properties for administrator command events.
11093                                                 
11094                                                 =item --zero-bool
11095                                                 
11096                                                 Print 0% boolean values in report.
11097                                                 
11098                                                 =back
11099                                                 
11100                                                 =head1 DOWNLOADING
11101                                                 
11102                                                 You can download Maatkit from Google Code at
11103                                                 L<http://code.google.com/p/maatkit/>, or you can get any of the tools
11104                                                 easily with a command like the following:
11105                                                 
11106                                                    wget http://www.maatkit.org/get/toolname
11107                                                    or
11108                                                    wget http://www.maatkit.org/trunk/toolname
11109                                                 
11110                                                 Where C<toolname> can be replaced with the name (or fragment of a name) of any
11111                                                 of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
11112                                                 needed.  The first URL gets the latest released version of the tool, and the
11113                                                 second gets the latest trunk code from Subversion.
11114                                                 
11115                                                 =head1 ENVIRONMENT
11116                                                 
11117                                                 The environment variable C<MKDEBUG> enables verbose debugging output in all of
11118                                                 the Maatkit tools:
11119                                                 
11120                                                    MKDEBUG=1 mk-....
11121                                                 
11122                                                 =head1 SYSTEM REQUIREMENTS
11123                                                 
11124                                                 You need Perl and some core packages that ought to be installed in any
11125                                                 reasonably new version of Perl.
11126                                                 
11127                                                 =head1 BUGS
11128                                                 
11129                                                 For list of known bugs see L<http://www.maatkit.org/bugs/mk-query-digest>.
11130                                                 
11131                                                 Please use Google Code Issues and Groups to report bugs or request support:
11132                                                 L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
11133                                                 discuss Maatkit.
11134                                                 
11135                                                 Please include the complete command-line used to reproduce the problem you are
11136                                                 seeing, the version of all MySQL servers involved, the complete output of the
11137                                                 tool when run with L<"--version">, and if possible, debugging output produced by
11138                                                 running with the C<MKDEBUG=1> environment variable.
11139                                                 
11140                                                 =head1 COPYRIGHT, LICENSE AND WARRANTY
11141                                                 
11142                                                 This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
11143                                                 Feedback and improvements are welcome.
11144                                                 
11145                                                 THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
11146                                                 WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
11147                                                 MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
11148                                                 
11149                                                 This program is free software; you can redistribute it and/or modify it under
11150                                                 the terms of the GNU General Public License as published by the Free Software
11151                                                 Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
11152                                                 systems, you can issue `man perlgpl' or `man perlartistic' to read these
11153                                                 licenses.
11154                                                 
11155                                                 You should have received a copy of the GNU General Public License along with
11156                                                 this program; if not, write to the Free Software Foundation, Inc., 59 Temple
11157                                                 Place, Suite 330, Boston, MA  02111-1307  USA.
11158                                                 
11159                                                 =head1 AUTHOR
11160                                                 
11161                                                 Baron Schwartz, Daniel Nichter
11162                                                 
11163                                                 =head1 ABOUT MAATKIT
11164                                                 
11165                                                 This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
11166                                                 was created by Baron Schwartz; Baron and Daniel Nichter are the primary
11167                                                 code contributors.  Both are employed by Percona.  Financial support for
11168                                                 Maatkit development is primarily provided by Percona and its clients. 
11169                                                 
11170                                                 =head1 VERSION
11171                                                 
11172                                                 This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5819 $.
11173                                                 
11174                                                 =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
101          100     54     26   if (@_ > 2)
110          100      5      7   if (not $dsn)
122   ***     50     29      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
134   ***     50      0     61   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
140          100     32     29   if (not defined $final_props{$key})
147   ***     50      0     29   unless exists $opts{$key}
150   ***     50      0      7   if (my $required = $self->prop('required'))
152   ***      0      0      0   unless $final_props{$key}
161   ***     50      0      5   unless ref $o eq 'OptionParser'
164          100     35     10   if $o->has($_)
174   ***      0      0      0   unless ref $dsn
175   ***      0      0      0   $_ eq 'p' ? :
176   ***      0      0      0   if defined $$dsn{$_}
189   ***      0      0      0   $opts{$key}{'copy'} ? :
203   ***     50      0      7   if ($driver eq 'Pg') { }
235   ***     50      0      7   $cxn_string =~ /charset=utf8/ ? :
244   ***     50      0      7   if (not $have_dbi)
263   ***     50      7      0   if ($cxn_string =~ /mysql/i)
271   ***     50      0      7   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
276   ***      0      0      0   if ($charset eq 'utf8') { }
277   ***      0      0      0   unless binmode STDOUT, ':utf8'
281   ***      0      0      0   unless binmode STDOUT
285          100      5      2   if ($self->prop('set-vars'))
292   ***     50      0      7   if (not $dbh and $EVAL_ERROR)
294   ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
307   ***      0      0      0   if (not $tries)
329   ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
346   ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
356   ***      0      0      0   unless $dsn_1
357   ***      0      0      0   unless $dsn_2
361   ***      0      0      0   if ($args{'overwrite'}) { }
362   ***      0      0      0   defined $$dsn_1{$key} ? :
365   ***      0      0      0   defined $$dsn_2{$key} ? :
374   ***      0      0      0   defined $_ ? :
413   ***      0      0      0   unless defined $val
414   ***      0      0      0   if $val eq ''
416   ***      0      0      0   if (not defined $is_numeric)
417   ***      0      0      0   $val =~ /^0|\D/ ? :
420   ***      0      0      0   if $is_numeric
430          100     40     51   if (not $tbl)
439   ***      0      0      0   unless $like
478   ***     50      0     54   unless $args{$arg}
484   ***     50     54      0   exists $args{'strict'} ? :
527   ***     50      0     54   unless open my $fh, '<', $file
547          100  66798     54   unless $para =~ /^=head1 OPTIONS/
552          100     54     54   if $para =~ /^=over/
560   ***     50      0     54   unless $para
563          100   3402     54   if (my($option) = $para =~ /^=item --(.*)/)
570          100   2592    810   if ($para =~ /: /) { }
574   ***     50      0   3834   unless $attributes{$attrib}
578          100    378   2214   if ($attribs{'short form'})
594   ***     50      0   3402   if $para =~ /^=item/
596          100    216   3186   if (my($base_option) = $option =~ /^\[no\](.*)/)
601          100    378   3024   $attribs{'short form'} ? :
             100    216   3186   $attribs{'negatable'} ? :
      ***     50      0   3402   $attribs{'cumulative'} ? :
             100   2376   1026   $attribs{'type'} ? :
             100   1026   2376   $attribs{'default'} ? :
      ***     50      0   3402   $attribs{'group'} ? :
613   ***     50      0  12636   unless $para
616          100     54  12582   if ($para =~ /^=head1/)
620          100   3402   9180   if $para =~ /^=item --/
624   ***     50      0     54   unless @specs
635          100   3402     54   if (ref $opt) { }
640   ***     50      0   3402   if (not $long)
645   ***     50      0   3402   if exists $$self{'opts'}{$long}
648   ***     50      0   3402   if (length $long == 1)
653          100    378   3024   if ($short) { }
654   ***     50      0    378   if exists $$self{'short_opts'}{$short}
663          100    216   3186   $$opt{'spec'} =~ /!/ ? :
664   ***     50      0   3402   $$opt{'spec'} =~ /\+/ ? :
665   ***     50      0   3402   $$opt{'desc'} =~ /required/ ? :
677   ***     50      0   3402   if ($type and $type eq 'd' and not $$self{'dp'})
682          100   1188   2214   if $type and $type =~ /[HhAadzm]/
684          100   1080   2322   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
685   ***     50   1080      0   defined $def ? :
689          100     54   3348   if ($long eq 'config')
693   ***     50      0   3402   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
706   ***     50      0     54   if ($opt =~ /mutually exclusive|one and only one/)
711   ***     50      0     54   if ($opt =~ /at least one|one and only one/)
716   ***     50     54      0   if ($opt =~ /default to/)
721   ***     50      0     54   if ($opt =~ /restricted to option groups/)
731   ***     50      0     54   unless $rule_ok
748   ***     50      0    108   unless exists $$self{'opts'}{$long}
772   ***      0      0      0   unless exists $$self{'opts'}{$long}
792   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50    170      0   exists $$self{'opts'}{$opt} ? :
797   ***     50      0    170   if ($$opt{'is_cumulative'}) { }
812   ***     50      0   2268   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100   1134   2268   exists $$self{'defaults'}{$long} ? :
821   ***     50      0     54   if (@ARGV and $ARGV[0] eq '--config')
825   ***     50     54      0   if ($self->has('config'))
831   ***     50    216      0   if ($EVAL_ERROR)
832   ***     50      0    216   $self->got('config') ? :
847   ***     50      0     54   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
850   ***     50      0     54   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
851   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
857   ***     50      0     54   if (@ARGV and $$self{'strict'})
863   ***      0      0      0   if (@set > 1)
874   ***      0      0      0   if (@set == 0)
884          100    159   3243   if ($$opt{'got'}) { }
      ***     50      0   3243   elsif ($$opt{'is_required'}) { }
885   ***     50      0    159   if (exists $$self{'disables'}{$long})
892   ***     50      0    159   if (exists $$self{'allowed_groups'}{$long})
904   ***      0      0      0   if $restricted_opt eq $long
905   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
910   ***      0      0      0   if (@restricted_opts)
912   ***      0      0      0   if (@restricted_opts == 1) { }
941          100   1026   2376   unless $opt and $$opt{'type'}
944   ***     50      0   2376   if ($val and $$opt{'type'} eq 'm') { }
             100      5   2371   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0   2371   elsif ($val and $$opt{'type'} eq 'z') { }
             100     54   2317   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100    595   1722   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
947   ***      0      0      0   if (not $suffix)
953   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
954   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
969   ***     50      0      5   if ($from_key)
980   ***      0      0      0   if (defined $num) { }
981   ***      0      0      0   if ($factor)
1008         100     35   4344   length $opt == 1 ? :
1009  ***     50      0   4379   unless $long and exists $$self{'opts'}{$long}
1016  ***     50      0    271   length $opt == 1 ? :
1017  ***     50      0    271   unless $long and exists $$self{'opts'}{$long}
1024         100     45     54   length $opt == 1 ? :
1025         100     89     10   defined $long ? :
1030  ***     50      0     54   length $opt == 1 ? :
1031  ***     50      0     54   unless $long and exists $$self{'opts'}{$long}
1058  ***      0      0      0   unless $ENV{'DONT_BREAK_LINES'}
1066  ***     50      0     54   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0     54   elsif (scalar @{$$self{'errors'};}) { }
1067  ***      0      0      0   unless print $self->print_usage
1071  ***      0      0      0   unless print $self->print_errors
1080  ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
1089  ***      0      0      0   unless $$self{'got_opts'}
1092  ***      0      0      0   $$_{'is_negatable'} ? :
1096  ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
1112  ***      0      0      0   $group eq 'default' ? :
1118  ***      0      0      0   $$opt{'is_negatable'} ? :
1121  ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
1130  ***      0      0      0   if ($short) { }
1139  ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
1143  ***      0      0      0   if ($$self{'dp'})
1151  ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
1163  ***      0      0      0   if ref $_[0] eq 'OptionParser'
1166  ***      0      0      0   unless print $prompt
1174  ***      0      0      0   unless print "\n"
1177  ***      0      0      0   if ($EVAL_ERROR)
1199  ***     50    216      0   unless open my $fh, '<', $filename
1207  ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
1210  ***      0      0      0   if ($line eq '--')
1215  ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
1233  ***      0      0      0   unless open my $fh, '<', $file
1237  ***      0      0      0   unless $para =~ /^=pod$/m
1241  ***      0      0      0   unless $para =~ /$regex/
1246  ***      0      0      0   unless close $fh
1260  ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
1279  ***      0      0      0   unless open my $fh, '<', $file
1285  ***      0      0      0   unless $para =~ /^=head1 $section/o
1289  ***      0      0      0   if ($subsection)
1291  ***      0      0      0   unless $para =~ /^=head2 $subsection/o
1298  ***      0      0      0   $subsection ? :
      ***      0      0      0   if $subsection ? $para =~ /^=head[12]/ : $para =~ /^=head1/
1299  ***      0      0      0   if $para =~ /=head/
1302  ***      0      0      0   if ($trf)
1304  ***      0      0      0   unless $para
1314  ***      0      0      0   defined $_ ? :
1363  ***     50      0   1295   defined $args{'p_ms'} ? :
1364  ***     50      0   1295   defined $args{'p_s'} ? :
1367         100      6   1289   if $t < 0
1369         100     94   1201   if $t =~ /e/
1373         100    430    865   if ($t > 0 and $t <= 0.000999) { }
             100    192    673   elsif ($t >= 0.001 and $t <= 0.999999) { }
             100    181    492   elsif ($t >= 1) { }
1394  ***     50      0    722   $p ? :
1401  ***      0      0      0   unless $secs
1403  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
1408  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
1427  ***      0      0      0   unless defined $val
1431  ***      0      0      0   if ($suffix =~ /[smhd]/) { }
1432  ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1437  ***      0      0      0   if $prefix and $prefix eq '-'
1447         100     18   3467   defined $args{'p'} ? :
1448         100    258   3227   defined $args{'d'} ? :
1455         100    305   3180   $num =~ /\./ || $n ? :
1464  ***      0      0      0   $gmt ? :
1470  ***      0      0      0   if (my($us) = $time =~ /(\.\d+)$/)
1480  ***     50    250      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^$mysql_ts$/)
1483         100     62    188   defined $f ? :
             100     62    188   defined $f ? :
1492         100     30      8   if (my($y, $m, $d, $h, $i, $s, $us) = $val =~ /^$proper_ts$/)
1493  ***     50      0     30   $gmt ? :
1496         100      4     26   if (defined $us)
1508  ***      0      0      0   if (my($n, $suffix) = $val =~ /^$n_ts$/) { }
      ***      0      0      0   elsif ($val =~ /^\d{9,}/) { }
      ***      0      0      0   elsif (my($ymd, $hms) = $val =~ /^(\d{6})(?:\s+(\d+:\d+:\d+))?/) { }
      ***      0      0      0   elsif (($ymd, $hms) = $val =~ /^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) { }
1509  ***      0      0      0   $suffix eq 'd' ? :
      ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1523  ***      0      0      0   unless $hms
1528  ***      0      0      0   unless $hms
1533  ***      0      0      0   if $callback and ref $callback eq 'CODE'
1549  ***      0      0      0   defined $_ ? :
1601  ***     50      0    115   unless $query
1604  ***     50      0    115   if ($query =~ /$vlc_rf/i)
1621         100     94      2   unless $query =~ /IN\s*\(\s*(?!select)/i
1647  ***      0      0      0   unless @vals > 20
1659  ***     50      0    346   if $query =~ m[\ASELECT /\*!40001 SQL_NO_CACHE \*/ \* FROM `]
1661  ***     50      0    346   if $query =~ m[/\*\w+\.\w+:[0-9]/[0-9]\*/]
1663         100     11    335   if $query =~ /\A# administrator command: /
1665  ***     50      0    335   if $query =~ /\A\s*(call\s+\S+)\(/i
1667         100      8    327   if (my($beginning) = $query =~ /\A((?:INSERT|REPLACE)(?: IGNORE)?\s+INTO.+?VALUES\s*\(.*?\))\s*,\s*\(/is)
1673  ***     50      0    335   if $query =~ s/\Ause \S+\Z/use ?/i
1701  ***     50      0    120   if $query =~ /\A\s*call\s+(\S+)\(/i
1702  ***     50      0    120   if $query =~ /\A\s*use\s+/
1703  ***     50      0    120   if $query =~ /\A\s*UNLOCK TABLES/i
1704  ***     50      0    120   if $query =~ /\A\s*xa\s+(\S+)/i
1706         100      5    115   if ($query =~ /\A# administrator command:/)
1714         100      4    111   if ($query =~ /\A\s*SHOW\s+/i)
1732         100      2    109   if ($dds)
1734  ***     50      2      0   if $obj
1739  ***     50      2      0   $obj ? :
1756  ***     50      0    111   unless $qp
1764         100      2    109   if $table
1777  ***     50      0    115   if ($args{'generic'}) { }
1779  ***      0      0      0   unless $cmd
1780  ***      0      0      0   $arg ? :
1785         100      4    111   if ($verbs and $verbs =~ /^SHOW/) { }
1800  ***     50      0    115   if ($args{'trf'})
1809  ***     50      0     55   unless $query
1837         100     41     14   unless $query =~ s/
                 \A.*?
                 update\s+(.*?)
                 \s+set\b(.*?)
                 (?:\s*where\b(.*?))?
                 (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
                 \Z
              /__update_to_select($1, $2, $3, $4);/eisx or $query =~ s/
                    \A.*?
                    (?:insert(?:\s+ignore)?|replace)\s+
                    .*?\binto\b(.*?)\(([^\)]+)\)\s*
                    values?\s*(\(.*?\))\s*
                    (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
                    \Z
                 /__insert_to_select($1, $2, $3);/eisx or $query =~ s/
                    \A.*?
                    (?:insert(?:\s+ignore)?|replace)\s+
                    (?:.*?\binto)\b(.*?)\s*
                    set?\s*\b(.*?)\s*
                    (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
                    \Z
                 /__insert_to_select_with_set($1, $2);/eisx
1851  ***      0      0      0   $1 =~ /\*/ ? :
1860  ***     50      0      1   if ($join =~ /\bjoin\b/)
1874  ***      0      0      0   if (@cols == @vals) { }
1891         100      8      6   $where ? :
      ***     50      0     14   $limit ? :
1898  ***      0      0      0   unless $query
1899  ***      0      0      0   $query =~ /\A\s*select/i ? :
1906  ***      0      0      0   defined $_ ? :
1962  ***      0      0      0   unless $args{$arg}
1967  ***      0      0      0   unless $code
1970  ***      0      0      0   if ($$self{'curr_rows'}) { }
1976  ***      0      0      0   if ($rows and scalar @$rows) { }
1993  ***      0      0      0   if (not $curr and @curr)
1997  ***      0      0      0   if (not $prev and @prev)
2001  ***      0      0      0   if ($curr or $prev)
2002  ***      0      0      0   if ($curr and $prev and $$curr[0] == $$prev[0]) { }
      ***      0      0      0   elsif (not $curr or $curr and $prev and $$curr[0] > $$prev[0]) { }
2004  ***      0      0      0   $$curr[5] =~ /\D/ ? :
2006  ***      0      0      0   if ($$prev[7])
2007  ***      0      0      0   if (not $$curr[7] or $$prev[7] ne $$curr[7]) { }
      ***      0      0      0   elsif (defined $$curr[5] and $$curr[5] < $$prev[5]) { }
      ***      0      0      0   elsif ($$curr[7] and defined $$curr[5] and $$misc{'time'} - $$curr[5] - $$prev[8] - $$prev[9] - $$misc{'etime'} > $fudge) { }
2022  ***      0      0      0   if ($is_new)
2026  ***      0      0      0   if ($$curr[7])
2027  ***      0      0      0   if ($$prev[7] and not $is_new) { }
2048  ***      0      0      0   if ($$curr[7] and defined $$curr[5])
2060  ***      0      0      0   scalar @curr ? :
2069  ***      0      0      0   if ($$row[5] < $time - $$row[10])
2103  ***      0      0      0   if ($find_spec{'busy_time'} and ($$query{'Command'} || '') eq 'Query')
2104  ***      0      0      0   if ($$query{'Time'} < $find_spec{'busy_time'})
2112  ***      0      0      0   if ($find_spec{'idle_time'} and ($$query{'Command'} || '') eq 'Sleep')
2113  ***      0      0      0   if ($$query{'Time'} < $find_spec{'idle_time'})
2124  ***      0      0      0   if (defined $find_spec{'ignore'}{$property} and $self->$filter($query, $find_spec{'ignore'}{$property}))
2129  ***      0      0      0   if (defined $find_spec{'match'}{$property})
2130  ***      0      0      0   if (not $self->$filter($query, $find_spec{'match'}{$property}))
2138  ***      0      0      0   if ($matched)
2146  ***      0      0      0   if (@matches and $find_spec{'only_oldest'})
2198  ***      0      0      0   defined $_ ? :
2235  ***     50      0    226   unless $args{$arg}
2243  ***     50      0    101   if $raw_packet =~ /^$/
2244         100     89     12   if $pos_in_log
2247         100     89     12   unless $raw_packet =~ /\A20/
2258  ***     50     12      0   if $args{'oktorun'}
2264  ***     50      0    101   unless $packet
2278  ***     50    101      0   length $data == 2 * $ip_plen ? :
2289         100     71      2   length $data > 10 ? :
             100     73     28   $data ? :
2315  ***     50      0    202   unless $port
2316         100     24    178   $port eq 'mysql' ? :
      ***     50      0    202   $port eq 'http' ? :
      ***     50      0    202   $port eq 'memcached' ? :
2324  ***      0      0      0   defined $_ ? :
2549  ***     50      0    101   unless $args{$arg}
2556         100     66     35   if (my $server = $$self{'server'})
2558  ***     50      0     66   if ($src_host ne $server and $dst_host ne $server)
2566         100     49     52   if ($src_host =~ /:$$self{'port'}$/) { }
      ***     50     52      0   elsif ($dst_host =~ /:$$self{'port'}$/) { }
2581         100     73     28   if ($$packet{'data_len'} >= 5)
2584         100     21     80   if (not exists $$self{'sessions'}{$client})
2585         100      2     19   if ($$packet{'syn'}) { }
             100     10      9   elsif ($packetno == 0) { }
2614  ***     50      0     92   if ($$packet{'syn'} and $$session{'n_queries'} > 0 || $$session{'state'})
2621         100     19     73   if ($$packet{'data_len'} == 0)
2627  ***     50      0     73   if ($$session{'compress'})
2628  ***      0      0      0   unless $self->uncompress_packet($packet, $session)
2631  ***     50      0     73   if ($$session{'buff'} and $packet_from eq 'client') { }
2646  ***     50      0     73   if ($EVAL_ERROR)
2655         100     35     38   if ($packet_from eq 'server') { }
      ***     50     38      0   elsif ($packet_from eq 'client') { }
2659  ***     50      0     38   if ($$session{'buff'}) { }
      ***     50      0     38   elsif ($$packet{'mysql_data_len'} > $$packet{'data_len'} - 4) { }
2660  ***      0      0      0   if ($$session{'buff_left'} <= 0) { }
2670  ***      0      0      0   if ($$session{'cmd'} and ($$session{'state'} || '') eq 'awaiting_reply')
2689  ***     50      0     38   if ($$session{'cmd'} and ($$session{'state'} || '') eq 'awaiting_reply')
2703         100      3     70   if ($$session{'closed'})
2713  ***     50      0     35   unless $packet
2714  ***     50      0     35   unless $session
2718  ***     50      0     35   if (($$session{'server_seq'} || '') eq $$packet{'seq'})
2730  ***     50      0     35   if (not $first_byte)
2735         100      2     33   if (not $$session{'state'}) { }
2736  ***     50      2      0   if ($first_byte eq '0a' and length $data >= 33 and $data =~ /00{13}/) { }
      ***      0      0      0   elsif ($$session{'buff'}) { }
2738  ***     50      0      2   if (not $handshake)
2745  ***     50      0      2   unless $$session{'ts'}
2758         100     11     22   if ($first_byte eq '00') { }
             100      1     21   elsif ($first_byte eq 'ff') { }
      ***     50      0     21   elsif ($first_byte eq 'fe' and $$packet{'mysql_data_len'} < 9) { }
2759         100      1     10   if (($$session{'state'} || '') eq 'client_auth') { }
      ***     50     10      0   elsif ($$session{'cmd'}) { }
2777  ***     50     10      0   if ($com eq '16') { }
2780  ***     50      0     10   if (not $ok)
2794  ***      0      0      0   if (not $ok)
2801  ***     50      0     10   if ($com eq '03' or $com eq '17' or $com eq '1a') { }
      ***     50     10      0   elsif ($com eq '16') { }
2833  ***     50      0      1   if (not $error)
2839  ***     50      1      0   if ($$session{'state'} eq 'client_auth') { }
      ***      0      0      0   elsif ($$session{'cmd'}) { }
2854  ***      0      0      0   if ($com eq '03' or $com eq '17') { }
2864  ***      0      0      0   $$error{'errno'} ? :
2878  ***      0      0      0   if ($$packet{'mysql_data_len'} == 1 and $$session{'state'} eq 'client_auth' and $$packet{'number'} == 2) { }
2892  ***     50     21      0   if ($$session{'cmd'}) { }
2897  ***     50     21      0   if ($com eq '03' or $com eq '17') { }
2907  ***     50     21      0   if ($$packet{'complete'})
2910  ***     50     21      0   if ($warning_count)
2913  ***     50      0     21   $flags & 16 ? :
2915         100      9     12   $flags & 32 ? :
2933  ***     50      0     38   unless $packet
2934  ***     50      0     38   unless $session
2938  ***     50      0     38   if (($$session{'client_seq'} || '') eq $$packet{'seq'})
2948         100      2     36   if (($$session{'state'} || '') eq 'server_handshake') { }
      ***     50      0     36   elsif (($$session{'state'} || '') eq 'client_auth_resend') { }
      ***     50      0     36   elsif (($$session{'state'} || '') eq 'awaiting_reply') { }
2951  ***     50      0      2   if (not $handshake)
2967  ***      0      0      0   $$session{'cmd'}{'arg'} ? :
2973  ***     50      0     36   if ($$packet{'number'} != 0)
2978         100     10     26   if (not defined $$session{'compress'})
2979  ***     50      0     10   unless $self->detect_compression($packet, $session)
2984  ***     50      0     36   if (not $com)
2989         100     12     24   if ($$com{'code'} eq '17') { }
      ***     50      0     24   elsif ($$com{'code'} eq '1a') { }
2992  ***     50      0     12   if (not $exec)
3002  ***      0      0      0   if (not $sth_id)
3019         100      2     34   if ($$com{'code'} eq '01') { }
             100      3     31   elsif ($$com{'code'} eq '19') { }
3034  ***     50      0      3   if (not $sth_id)
3060         100     10     28   if (not $$session{'thread_id'})
3066  ***     50      0     38   $$event{'No_good_index_used'} ? :
             100      9     29   $$event{'No_index_used'} ? :
3115  ***     50     38      0   if ($sd eq $ed) { }
3133  ***     50      5      0   $len ? :
3140  ***     50      0      5   unless $data
3146  ***     50      5      0   if ($first_byte <= 251) { }
      ***      0      0      0   elsif ($first_byte == 252) { }
      ***      0      0      0   elsif ($first_byte == 253) { }
      ***      0      0      0   elsif ($first_byte == 254) { }
3173  ***     50      0    351   if ($len)
3192  ***      0      0      0   if ($first_byte < 251) { }
      ***      0      0      0   elsif ($first_byte == 252) { }
      ***      0      0      0   elsif ($first_byte == 253) { }
      ***      0      0      0   elsif ($first_byte == 254) { }
3208  ***     50      0      1   unless $data
3210  ***     50      0      1   if (length $data < 16)
3216  ***     50      0      1   unless $marker eq '#'
3230  ***      0      0      0   unless $data
3232  ***      0      0      0   if (length $data < 12)
3254  ***     50      0     10   unless $data
3256  ***     50      0     10   if (length $data < 8)
3274  ***     50      0      2   unless $data
3299  ***     50      0      2   unless $data
3310  ***     50      0      2   if (not $buff_len)
3321         100      1      1   $db ? :
3332  ***     50      0     46   unless $data and $len
3338  ***     50      0     46   if (not $com)
3342         100     31     15   if ($code ne '17' and $code ne '19' and $code ne '1a')
3359  ***     50      0     12   unless $data and $sths
3362  ***     50      0     12   unless defined $sth_id
3365  ***     50      0     12   if (not $sth)
3377         100      4      8   if ($new_params) { }
3387  ***     50      0      8   if $data
3396         100      4      5   if ($null_bitmap & 2 ** $i) { }
3402  ***     50      5      0   if ($unpack_type{$types[$i]}) { }
3415         100      5      4   if $len
3428  ***     50      0      3   unless $data
3435  ***     50      0      4   unless $flags
3441         100     30     42   $flags_dec & $flagno ? :
3448  ***      0      0      0   unless $data
3449  ***      0      0      0   unless $len
3450  ***      0      0      0   unless ref $data eq 'SCALAR'
3457  ***      0      0      0   unless my $z = 'IO::Uncompress::Inflate'->new(\$comp_bin_data)
3460  ***      0      0      0   unless my $status = $z->read(\$uncomp_bin_data, $len)
3472  ***     50      0     10   if ($com and $$com{'code'} eq '00') { }
3477  ***      0      0      0   unless $self->uncompress_packet($packet, $session)
3489  ***      0      0      0   unless $packet
3490  ***      0      0      0   unless $session
3509  ***      0      0      0   if ($EVAL_ERROR)
3515  ***      0      0      0   if ($uncomp_data_len) { }
3520  ***      0      0      0   if ($EVAL_ERROR)
3537  ***     50      0     73   unless $packet
3555  ***      0      0      0   if $errors_fh
3558  ***      0      0      0   if ($o and $o->has('tcpdump-errors') and $o->got('tcpdump-errors'))
3561  ***      0      0      0   unless open $errors_fh, '>>', $errors_file
3573  ***      0      0      0   if ($errors_fh)
3599  ***      0      0      0   defined $_ ? :
3647  ***     50      0    698   unless $args{$arg}
3665         100      6    304   if ($stmt =~ s/$slow_log_hd_line//go)
3667         100      1      5   if (@chunks > 1)
3674         100    272     38   unless $stmt =~ /\A#/
3688         100   1440    297   if ($line =~ /^(?:#|use |SET (?:last_insert_id|insert_id|timestamp))/o) { }
3690         100     53   1387   if (not $got_ts and my($time) = $line =~ /$slow_log_ts_line/o) { }
             100    103   1284   elsif (not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o) { }
             100     10   1274   elsif (not $got_ac and $line =~ /^# (?:administrator command:.*)$/) { }
             100    988    286   elsif ($line =~ /^# +[A-Z][A-Za-z_]+: \S+/) { }
             100     39    247   elsif (not $got_db and my($db) = $line =~ /^use ([^;]+)/) { }
             100     20    227   elsif (not $got_set and my($setting) = $line =~ /^SET\s+([^;]*)/) { }
3694         100     16     37   if (not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o)
3737         100      3   1437   if (not $found_arg and $pos == $len)
3740  ***     50      3      0   if (defined(my $l = &$next_event())) { }
3757         100      1    296   if ($args{'misc'} and $args{'misc'}{'embed'} and my($e) = $arg =~ /($args{'misc'}{'embed'})/)
3772  ***     50     39      0   if $args{'oktorun'}
3778  ***      0      0      0   defined $_ ? :
3808  ***      0      0      0   if ($$event{'ts'})
3811  ***      0      0      0   if ($$event{'user'})
3815  ***      0      0      0   if ($$event{'ip'} and $$event{'port'})
3818  ***      0      0      0   if ($$event{'Thread_id'})
3822  ***      0      0      0   exists $$event{'QC_Hit'} ? :
3824  ***      0      0      0   unless $_
3829  ***      0      0      0   if ($percona_patched)
3830  ***      0      0      0   unless $_
3835  ***      0      0      0   if (exists $$event{'InnoDB_IO_r_ops'}) { }
3836  ***      0      0      0   unless $_
3847  ***      0      0      0   if ($$event{'db'})
3850  ***      0      0      0   if ($$event{'arg'} =~ /^administrator command/)
3860  ***      0      0      0   defined $_ ? :
3895  ***     50      0    110   unless $args{$arg}
3914  ***     50      0     55   unless $args{'type_for'}
3925         100     54      1   scalar keys %$attributes == 0 ? :
3948  ***     50      0    368   unless defined $group_by
3953  ***     50      0    368   if $$self{'unrolled_loops'}
3956  ***     50    368      0   if ($$self{'n_events'} <= $$self{'unroll_limit'}) { }
3958         100    366      2   if $$self{'detect_attribs'}
3963         100    157   5330   if (not exists $$event{$attrib})
3967  ***     50    157      0   unless $alt_attrib
3971         100     20   5310   ref $group_by ? :
3976         100   1153   4177   if (not $handler)
3985         100    473   4857   unless $handler
4008  ***      0      0      0   ref $group_by ? :
4023  ***      0      0      0   if (ref $group_by)
4033  ***      0      0      0   if $EVAL_ERROR
4060  ***     50      0   1153   unless defined $attrib
4063  ***     50      0   1153   if (ref $val eq 'ARRAY')
4067         100    473    680   unless defined $val
4070         100    115    164   $val =~ /^(?:Yes|No)$/ ? :
             100    383    279   $val =~ /^(?:\d+|$float_re)$/o ? :
             100     18    662   $self->type_for($attrib) ? :
4078         100    498    182   $type =~ /num|bool/ ? :
             100    297    383   $type =~ /bool|string/ ? :
             100    383    297   $type eq 'num' ? :
             100    115    565   $type eq 'bool' ? :
4093         100    115    565   if ($args{'trf'})
4099  ***     50   1360      0   if ($args{'min'})
4100         100    766    594   $type eq 'num' ? :
4106  ***     50   1360      0   if ($args{'max'})
4107         100    766    594   $type eq 'num' ? :
4113         100    996    364   if ($args{'sum'})
4116  ***     50   1360      0   if ($args{'cnt'})
4119         100    766    594   if ($args{'all'})
4128         100    297    383   if ($args{'unq'})
4131         100     53    627   if ($args{'wor'})
4132  ***     50     53      0   $type eq 'num' ? :
4141         100     54    626   if ($attrib eq 'Query_time')
4149         100    383    297   if ($args{'all'} and $type eq 'num' and $$self{'attrib_limit'})
4164  ***     50      0    680   $is_array ? :
      ***     50      0    680   $is_array ? :
4176  ***     50      0    680   $is_array ? :
      ***     50      0    680   $is_array ? :
4189  ***     50      0    680   if $EVAL_ERROR
4195         100   1948   3145   if $val < 1e-06
4197  ***     50      0   3145   $idx > 999 ? :
4202         100      7   6993   if $bucket == 0
4203  ***     50      0   6993   if $bucket < 0 or $bucket > 999
4210         100     99      7   if @buck_tens
4241  ***     50      0    646   unless defined $vals and @$vals and $$args{'cnt'}
4245         100    592     54   if ($n_vals == 1 or $$args{'max'} == $$args{'min'}) { }
             100     29     25   elsif ($n_vals == 2) { }
4247         100    272    320   $v > 0 ? :
4248  ***     50      0    558   $bucket < 0 ? :
             100     34    558   $bucket > 7 ? :
4258         100     46     12   $v && $v > 0 ? :
4259  ***     50      0     50   $bucket < 0 ? :
             100      8     50   $bucket > 7 ? :
4271         100      3     22   $n_vals >= 10 ? :
4289         100  24916     84   unless $val
4293         100     25     59   if not $bucket_95 and $sum_excl > $top_vals
4295         100     25     59   if (not $median and $total_left <= $mid)
4296         100     22      3   $cutoff % 2 || $val > 1 ? :
4306         100     23      2   $var > 0 ? :
4308  ***     50      0     25   $stddev > $maxstdev ? :
4325  ***      0      0      0   unless $args{$arg}
4334  ***      0      0      0   $global_cnt && $$store{'cnt'} ? :
      ***      0      0      0   $$store{'sum'} && $$store{'cnt'} ? :
4358         100    121     13   if (!$args{'total'} || $total < $args{'total'} and !$args{'count'} || $count < $args{'count'}) { }
      ***     50      0     13   elsif ($args{'ol_attrib'} and !$args{'ol_freq'} || $$classes{$groupby}{$args{'ol_attrib'}}{'cnt'} >= $args{'ol_freq'}) { }
4373  ***      0      0      0   if ($$stats{'pct_95'} >= $args{'ol_limit'})
4386  ***     50      0    366   unless $event
4389         100   1864   4977   if $_ ne $$self{'groupby'} and not exists $$self{'attributes'}{$_}
4419  ***     50    718      0   unless @attribs
4430  ***      0      0      0   if $EVAL_ERROR
4436  ***      0      0      0   defined $_ ? :
4472  ***      0      0      0   unless $args{$arg}
4484  ***     50      0     12   if ($$self{'line_width'} eq 'auto')
4485  ***      0      0      0   unless $have_term
4504  ***     50      0     65   unless defined $$col{'name'}
4505  ***     50      0     65   if ($$col{'fixed_wdith'} and $$col{'fixed_width'} < length $$col{'name'})
4509  ***     50      0     65   if ($$col{'min_width'} and $$col{'min_width'} < length $$col{'name'})
4528  ***     50      0     34   unless $$self{'n_cols'} == $n_vals
4534  ***     50    189      0   defined $vals[$i] ? :
4537  ***     50      0    189   if ($$col{'fixed_width'} and $width > $$col{'fixed_width'})
4540  ***     50      0    189   if ($$col{'max_width'} and $width > $$col{'max_width'})
4543  ***     50      0    189   if ($too_wide)
4544  ***      0      0      0   unless $$col{'truncate'}
4551  ***     50      0    189   if $$col{'trf'}
4563         100     10      2   if $$self{'long_last_column'}
4567         100     43     12   $$col{'right_justify'} ? :
4573         100     10      2   if ($$self{'long_last_column'})
4583         100     10      2   if $$self{'title'}
4586  ***     50     12      0   if ($$self{'underline_header'})
4594         100      3      9   if ($$self{'truncate_underline'} and 2 + $underline_len > $$self{'line_width'})
4619  ***      0      0      0   $$self{'column_errors'} eq 'die' ? :
4625  ***      0      0      0   defined $_ ? :
4671  ***     50      0     54   if (lc $label_width eq 'auto')
4677  ***      0      0      0   if ($w > 80)
4706  ***      0      0      0   if ($EVAL_ERROR)
4720         100      6      1   if ($global_cnt and $$stats{'globals'}{'ts'} and ($$stats{'globals'}{'ts'}{'max'} || '') gt ($$stats{'globals'}{'ts'}{'min'} || ''))
4749  ***     50      0     75   unless $attrib_type
4750  ***     50      0     75   unless exists $$stats{'globals'}{$attrib}
4751         100      7     68   if ($formatting_function{$attrib}) { }
4759         100     48     20   if ($attrib_type eq 'num') { }
             100      9     11   elsif ($attrib_type eq 'string') { }
      ***     50     11      0   elsif ($attrib_type eq 'bool') { }
4760         100      9     39   $attrib =~ /time$/ ? :
4768  ***     50    336      0   defined $_ ? :
4775         100      1     10   if ($$store{'sum'} > 0 or not $opts{'no_zero_bool'})
4784         100     48     11   unless $attrib_type eq 'bool'
4798  ***     50      0    106   unless $store
4805         100     13     93   if ($global_cnt and $$store{'ts'} and ($$store{'ts'}{'max'} || '') gt ($$store{'ts'}{'min'} || ''))
4818         100     96     10   $$ea{'groupby'} eq 'fingerprint' ? :
4829         100     74     32   if ($opts{'reason'})
4830  ***     50     74      0   $opts{'reason'} eq 'top' ? :
4843         100     60   1317   unless $attrib_type
4844         100    119   1198   unless exists $$store{$attrib}
4846         100      4   1194   unless scalar %$vals
4847         100     95   1099   if ($formatting_function{$attrib}) { }
4855         100    598    501   if ($attrib_type eq 'num') { }
             100    252    249   elsif ($attrib_type eq 'string') { }
      ***     50    249      0   elsif ($attrib_type eq 'bool') { }
4856         100    176    422   $attrib =~ /time$/ ? :
4863  ***     50   4186      0   defined $_ ? :
4874         100     17    232   if ($$vals{'sum'} > 0 or not $opts{'no_zero_bool'})
4884         100    850    249   unless $attrib_type eq 'bool'
4897  ***     50      0    106   unless defined $vals and scalar @$vals
4910         100     94    754   if $n_vals > $max_val
4917  ***     50      0    848   if $n_marks < 1 and $n_vals > 0
4918         100    102    746   $n_marks ? :
4929         100      7    106   if ($global)
4939         100     84    916   if ($val =~ /^InnoDB/)
4950         100     23    547   $val eq 'Error_no' ? :
             100     85    570   $val eq 'host' ? :
             100    113    655   $val eq 'Query_time' ? :
             100     68    768   $val eq 'db' ? :
             100     62    836   $val eq 'user' ? :
             100    102    898   $val eq 'ts' ? :
4962  ***     50    252      0   if (exists $$stats{'unq'}) { }
4964         100    244      8   if (1 == keys %$cnt_for)
4966  ***     50      0    244   if length $str > 44
4971         100     15      4   unless $$cnt_for{$b} <=> $$cnt_for{$a}
4976         100      1     20   if (length $str > 10) { }
4982  ***     50      0     21   if length($line) + length($print_str) > 47
4987  ***     50      0      8   if ($i < @top)
5015         100    714    738   if (exists $basic_attrib{$attrib}) { }
5019         100    471    267   if (($ea->type_for($attrib) || '') ne 'bool') { }
5038  ***      0      0      0   defined $_ ? :
5071  ***     50      0      2   unless $args{$arg}
5091         100      1      7   if (not $handler)
5095  ***     50      0      8   unless $handler
5112  ***     50      0      2   unless defined $val
5114  ***     50      0      1   $val =~ /^(?:Yes|No)$/ ? :
             100      1      1   $val =~ /^(?:\d+|$float_re)$/o ? :
5127  ***     50      0      2   if ($type eq 'bool')
5131         100      1      1   $type eq 'num' ? :
5136         100      1      1   $type eq 'num' ? :
5141         100      1      1   if ($type eq 'num')
5173  ***     50      0      1   if $EVAL_ERROR
5185  ***     50      8      0   if ($t = $$res[2]{'ts'} and $$t{'min'}) { }
5188  ***     50      0      8   if ($$t{'max'} and $$t{'max'} gt $$t{'min'}) { }
5206  ***      0      0      0   defined $_ ? :
5253  ***     50      0    239   unless $query
5257         100      4    235   if ($ddl_stmt)
5260         100      2      2   if ($query =~ /$ddl_stmt DATABASE\b/i)
5264  ***     50      0      2   if ($ddl_stmt =~ /CREATE/i and $query =~ /$ddl_stmt\b.+?\bSELECT\b/i)
5276         100      2    233   if ($query =~ /^\s*LOCK TABLES/i)
5292         100      2    177   if $tbls =~ /\ASELECT\b/i
5297  ***     50      0    183   if (not $tbl =~ /[a-zA-Z]/)
5317  ***      0      0      0   unless $query
5333  ***      0      0      0   if (not $tbl_refs)
5335  ***      0      0      0   $list ? :
5338  ***      0      0      0   if ($query =~ /^(?:INSERT|REPLACE)/i)
5360  ***      0      0      0   if ($tbl_ref =~ /^AS\s+\w+/i)
5362  ***      0      0      0   unless $list
5366  ***      0      0      0   if ($list) { }
5374  ***      0      0      0   if $db
5382  ***     50      0      5   unless $query
5391  ***     50      0      5   if (@split_statements == 1) { }
5398  ***     50      0      5   if ($statements[-2] and $statements[-2] =~ /on duplicate key\s+$/i)
5410  ***     50      0      5   unless $query
5420  ***      0      0      0   unless $query
5431  ***      0      0      0   if ($word =~ /^\(?SELECT\b/i) { }
5433  ***      0      0      0   if ($start_pos) { }
5451  ***      0      0      0   unless $sqno
5454  ***      0      0      0   if ($$sq{'done'})
5463  ***      0      0      0   if ($$sq{'lp'} + $lp - ($$sq{'rp'} + $rp) == 0)
5474  ***      0      0      0   unless $sq
5489         100      4      1   if ($type =~ /^SELECT\b/) { }
      ***     50      1      0   elsif ($type =~ /^$data_manip_stmts\b/ or $type =~ /^$data_def_stmts\b/) { }
5506  ***      0      0      0   unless $query
5509  ***      0      0      0   if ($query =~ /^SELECT/i) { }
      ***      0      0      0   elsif ($query =~ /^(?:INSERT|REPLACE)/i) { }
5532  ***      0      0      0   if ($cols_def)
5547  ***      0      0      0   unless $query
5566  ***      0      0      0   defined $_ ? :
5616  ***      0      0      0   unless defined $args{'cache'}
5624  ***      0      0      0   if ($what eq 'table') { }
      ***      0      0      0   elsif ($what eq 'triggers') { }
      ***      0      0      0   elsif ($what eq 'view') { }
5626  ***      0      0      0   unless $ddl
5627  ***      0      0      0   if ($$ddl[0] eq 'table') { }
5641  ***      0      0      0   if ($trgs and @$trgs) { }
5644  ***      0      0      0   if ($$trg{'sql_mode'})
5648  ***      0      0      0   if ($$trg{'definer'})
5680  ***      0      0      0   if (not $new)
5687  ***      0      0      0   if ($curr and $new and $curr eq $new)
5699  ***      0      0      0   if (not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl})
5712  ***      0      0      0   if ($EVAL_ERROR)
5722  ***      0      0      0   if ($key) { }
5738  ***      0      0      0   if (not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl})
5768  ***      0      0      0   if (not $$self{'cache'} or not $$self{'triggers'}{$db})
5781  ***      0      0      0   if ($sth->rows)
5794  ***      0      0      0   if ($tbl)
5802  ***      0      0      0   if (not $$self{'cache'} or not $$self{'databases'} or $like)
5805  ***      0      0      0   if ($like)
5813  ***      0      0      0   unless $like
5821  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_status'}{$db} or $like)
5824  ***      0      0      0   if ($like)
5839  ***      0      0      0   unless $like
5847  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_list'}{$db} or $like)
5850  ***      0      0      0   if ($like)
5858  ***      0      0      0   ($$_[1] || '') eq 'VIEW' ? :
5865  ***      0      0      0   unless $like
5873  ***      0      0      0   defined $_ ? :
5905  ***      0      0      0   unless $args{$arg}
5914  ***      0      0      0   unless $ddl
5915  ***      0      0      0   if (ref $ddl eq 'ARRAY')
5916  ***      0      0      0   if (lc $$ddl[0] eq 'table') { }
5926  ***      0      0      0   if (not $ddl =~ /CREATE (?:TEMPORARY )?TABLE `/)
5932  ***      0      0      0   if $name
5950  ***      0      0      0   unless $type
5952  ***      0      0      0   if ($type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/)
5956  ***      0      0      0   if (not $def =~ /NOT NULL/)
5960  ***      0      0      0   $def =~ /AUTO_INCREMENT/i ? :
5991  ***      0      0      0   unless ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
6005  ***      0      0      0   if ($index)
6008  ***      0      0      0   if (not $best)
6009  ***      0      0      0   if ($index) { }
6022  ***      0      0      0   unless $where
6028  ***      0      0      0   if ($$expl{'possible_keys'}) { }
6032  ***      0      0      0   if ($$expl{'key'})
6052  ***      0      0      0   unless $args{$arg}
6066  ***      0      0      0   if ($EVAL_ERROR)
6070  ***      0      0      0   if (not $$row[0] or $$row[0] ne $tbl)
6076  ***      0      0      0   unless $args{'all_privs'}
6083  ***      0      0      0   if ($EVAL_ERROR)
6087  ***      0      0      0   if (not scalar keys %$row)
6098  ***      0      0      0   $EVAL_ERROR ? :
6103  ***      0      0      0   if (not $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete)
6129  ***      0      0      0   if $key =~ /FOREIGN/
6134  ***      0      0      0   if (not $engine =~ /MEMORY|HEAP/)
6141  ***      0      0      0   if ($$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i)
6148  ***      0      0      0   $key =~ /PRIMARY|UNIQUE/ ? :
6172  ***      0      0      0   if ($engine =~ /InnoDB/i and not $clustered_key)
6174  ***      0      0      0   if ($$this_key{'name'} eq 'PRIMARY') { }
      ***      0      0      0   elsif ($$this_key{'is_unique'} and not $$this_key{'is_nullable'}) { }
6198  ***      0      0      0   if (not $parent =~ /\./ and $$opts{'database'})
6227  ***      0      0      0   if (($$tbl_struct{'engine'} || '') =~ /InnoDB/i) { }
6237  ***      0      0      0   unless $key_ddl =~ /,$/
6244  ***      0      0      0   if (@sec_indexes)
6261  ***      0      0      0   defined $_ ? :
6297  ***      0      0      0   unless $args{$arg}
6301  ***      0      0      0   unless $args{'tbl_struct'}{'is_col'}{$col}
6305  ***      0      0      0   defined $args{'ts_default'} ? :
6347  ***      0      0      0   unless $args{$arg}
6354  ***      0      0      0   unless $attr and $metric
6355  ***      0      0      0   if $attr =~ /_/
6362  ***      0      0      0   $_ eq 'ts_min' || $_ eq 'ts_max' ? :
6379  ***      0      0      0   unless defined $data{'ts'} and defined $data{'ts'}{$thing}
6392  ***      0      0      0   if ($review_vals and @$review_vals == 1)
6400  ***      0      0      0   $args{$_} ? :
6414  ***      0      0      0   defined $_ ? :
6442  ***      0      0      0   unless $args{$arg}
6445  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
6461  ***      0      0      0   unless defined(my $pid = fork)
6462  ***      0      0      0   if ($pid)
6469  ***      0      0      0   unless POSIX::setsid()
6470  ***      0      0      0   unless chdir '/'
6476  ***      0      0      0   if (-t STDIN)
6478  ***      0      0      0   unless open STDIN, '/dev/null'
6482  ***      0      0      0   if ($$self{'log_file'}) { }
6484  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
6488  ***      0      0      0   unless open STDERR, '>&STDOUT'
6492  ***      0      0      0   if (-t STDOUT)
6494  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
6497  ***      0      0      0   if (-t STDERR)
6499  ***      0      0      0   unless open STDERR, '>', '/dev/null'
6510  ***      0      0      0   $self ? :
6512  ***      0      0      0   if ($PID_file and -f $PID_file) { }
6515  ***      0      0      0   if $EVAL_ERROR
6517  ***      0      0      0   if ($pid) { }
6519  ***      0      0      0   if ($pid_is_alive) { }
6541  ***      0      0      0   if (exists $$self{'child'})
6553  ***      0      0      0   if (not $PID_file)
6560  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
6562  ***      0      0      0   unless print $PID_FH $PID
6564  ***      0      0      0   unless close $PID_FH
6573  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
6574  ***      0      0      0   unless unlink $$self{'PID_file'}
6586  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
6592  ***      0      0      0   defined $_ ? :
6636  ***      0      0      0   unless $args{$arg}
6643  ***      0      0      0   if (my $server = $$self{'server'})
6645  ***      0      0      0   if ($src_host ne $server and $dst_host ne $server)
6653  ***      0      0      0   if ($src_host =~ /:$$self{'port'}$/) { }
      ***      0      0      0   elsif ($dst_host =~ /:$$self{'port'}$/) { }
6667  ***      0      0      0   if (not exists $$self{'sessions'}{$client})
6677  ***      0      0      0   if ($$packet{'data_len'} == 0)
6686  ***      0      0      0   if ($packet_from eq 'server') { }
      ***      0      0      0   elsif ($packet_from eq 'client') { }
6702  ***      0      0      0   unless $packet
6703  ***      0      0      0   unless $session
6709  ***      0      0      0   if (not $$session{'state'})
6714  ***      0      0      0   if ($$session{'state'} eq 'awaiting reply') { }
6722  ***      0      0      0   if ($$session{'cmd'} eq 'incr' or $$session{'cmd'} eq 'decr') { }
      ***      0      0      0   elsif ($$session{'res'} eq 'VALUE') { }
      ***      0      0      0   elsif ($$session{'res'} eq 'END') { }
      ***      0      0      0   elsif (not $$session{'res'} =~ /STORED|DELETED|NOT_FOUND/) { }
6724  ***      0      0      0   if (not $$session{'res'} =~ /\D/)
6733  ***      0      0      0   unless defined $$session{'flags'}
6734  ***      0      0      0   unless defined $$session{'bytes'}
6735  ***      0      0      0   if ($rest and $bytes)
6737  ***      0      0      0   if (length $rest > $bytes) { }
6764  ***      0      0      0   if ($$session{'gathered'} >= $$session{'bytes'} + 2) { }
6787  ***      0      0      0   unless $packet
6788  ***      0      0      0   unless $session
6793  ***      0      0      0   if (($$session{'state'} || '') =~ /awaiting reply|partial recv/)
6805  ***      0      0      0   if (not $$session{'state'}) { }
6811  ***      0      0      0   if ($cmd eq 'set' or $cmd eq 'add' or $cmd eq 'replace') { }
      ***      0      0      0   elsif ($cmd eq 'get') { }
      ***      0      0      0   elsif ($cmd eq 'delete') { }
      ***      0      0      0   elsif ($cmd eq 'incr' or $cmd eq 'decr') { }
6817  ***      0      0      0   if ($val)
6824  ***      0      0      0   if ($val)
6847  ***      0      0      0   if ($val)
6848  ***      0      0      0   if ($$session{'bytes'} + 2 == length $val) { }
6860  ***      0      0      0   if ($$session{'gathered'} >= $$session{'bytes'} + 2) { }
6901  ***      0      0      0   if $errors_fh
6904  ***      0      0      0   if ($o and $o->has('tcpdump-errors') and $o->got('tcpdump-errors'))
6907  ***      0      0      0   unless open $errors_fh, '>>', $errors_file
6918  ***      0      0      0   if ($errors_fh)
6937  ***      0      0      0   defined $_ ? :
6951  ***      0      0      0   if ($sd eq $ed) { }
7016  ***      0      0      0   unless $event
7018  ***      0      0      0   if (not $$event{'cmd'} or not $$event{'key'})
7023  ***      0      0      0   if (not $cmds{$$event{'cmd'}})
7036  ***      0      0      0   if ($$event{'res'}) { }
7037  ***      0      0      0   if $$event{'res'} eq 'NOT_FOUND'
7043  ***      0      0      0   if ($cmd_handler_for{$$event{'cmd'}})
7059  ***      0      0      0   if (not $$event{'res'})
7064  ***      0      0      0   $$event{'res'} eq 'NOT_STORED' ? :
7065  ***      0      0      0   $$event{'res'} eq 'EXISTS' ? :
7073  ***      0      0      0   if (not $$event{'res'})
7078  ***      0      0      0   $$event{'res'} eq 'INTERRUPTED' ? :
7096  ***      0      0      0   defined $_ ? :
7141  ***     50      0     34   unless $args{$arg}
7165         100     64     10   if $delim
7168         100      6     68   if ($line =~ m[^/\*.+\*/;])
7173         100      3     65   if ($line =~ /^DELIMITER/m)
7175         100      2      1   if ($del) { }
7188         100      2     63   if $line =~ /End of log file/
7190         100     14     49   if (not $got_offset and my($offset) = $line =~ /$binlog_line_1/m) { }
             100     14     35   elsif (not $got_hdr and $line =~ /^#(\d{6}\s+\d{1,2}:\d\d:\d\d)/) { }
             100     20     15   elsif ($line =~ /^(?:#|use |SET)/i) { }
7206         100      2     18   if (my($db) = $line =~ /^use ([^;]+)/) { }
             100     17      1   elsif (my($setting) = $line =~ /^SET\s+([^;]*)/) { }
7220         100     13      2   if ($got_offset and $got_hdr) { }
7221         100      3     10   if ($type eq 'Xid') { }
             100      9      1   elsif ($type eq 'Query') { }
      ***     50      1      0   elsif ($type eq 'Start:') { }
7243         100      5     10   $pos == length $stmt ? :
7246         100     13      2   if $delim
7248         100      1     14   if ($arg =~ /^DELIMITER/m)
7250  ***     50      0      1   if ($del) { }
7273         100     15      3   if ($found_arg) { }
7283  ***     50      2      0   if $args{'oktorun'}
7289  ***      0      0      0   defined $_ ? :
7342  ***     50      0     16   unless $args{$arg}
7357  ***     50      0      7   if (not $thread_id && $cmd)
7367         100      2      5   if ($cmd eq 'Query') { }
7371  ***     50      5      0   if ($line) { }
7373         100      2      3   if ($thread_id and $cmd) { }
7392  ***     50      2      0   if $$db_for{$thread_id}
7397         100      2      3   if ($cmd eq 'Connect') { }
             100      1      2   elsif ($cmd eq 'Init') { }
7398  ***     50      0      2   if ($arg =~ /^Access denied/) { }
7407  ***     50      2      0   if $user
7408  ***     50      2      0   if $host
7409         100      1      1   if $db
7418  ***     50      1      0   if $db
7434  ***     50      1      0   if $args{'oktorun'}
7440  ***      0      0      0   defined $_ ? :
7490  ***      0      0      0   unless $args{$arg}
7494  ***      0      0      0   if ($$self{'buffer'})
7496  ***      0      0      0   if ($$packet{'data_len'})
7497  ***      0      0      0   if ($packet_from eq 'client') { }
7507  ***      0      0      0   unless $packet_from eq 'client' and $$packet{'fin'} || $$packet{'rst'}
7524  ***      0      0      0   if ($$packet{'data_len'} == 0)
7538  ***      0      0      0   unless $$misc{'recurse'}
7541  ***      0      0      0   if ($$session{'buff'})
7543  ***      0      0      0   if ($$session{'buff_left'} > 0)
7556  ***      0      0      0   unless $$misc{'recurse'}
7558  ***      0      0      0   if ($packet_from eq 'server') { }
      ***      0      0      0   elsif ($packet_from eq 'client') { }
7569  ***      0      0      0   if ($$session{'out_of_order'})
7572  ***      0      0      0   if $$packet{'ts'} lt ($$session{'ts_min'} || '')
7574  ***      0      0      0   if $$packet{'ts'} gt ($$session{'ts_max'} || '')
7576  ***      0      0      0   if ($$session{'have_all_packets'})
7596  ***      0      0      0   if (my $server = $$self{'server'})
7598  ***      0      0      0   if ($src_host ne $server and $dst_host ne $server)
7606  ***      0      0      0   if ($src_host =~ /:$$self{'port'}$/) { }
      ***      0      0      0   elsif ($dst_host =~ /:$$self{'port'}$/) { }
7620  ***      0      0      0   if (not exists $$self{'sessions'}{$client})
7643  ***      0      0      0   unless scalar keys %{$$session{'attribs'};}
7644  ***      0      0      0   unless $$session{'attribs'}{'arg'}
7661  ***      0      0      0   if $errors_fh
7664  ***      0      0      0   if ($o and $o->has('tcpdump-errors') and $o->got('tcpdump-errors'))
7667  ***      0      0      0   unless open $errors_fh, '>>', $errors_file
7678  ***      0      0      0   if ($errors_fh)
7697  ***      0      0      0   unless $start and $end
7704  ***      0      0      0   if ($sd eq $ed) { }
7714  ***      0      0      0   unless $data
7715  ***      0      0      0   unless $len
7716  ***      0      0      0   unless ref $data eq 'SCALAR'
7723  ***      0      0      0   unless my $z = 'IO::Uncompress::Inflate'->new(\$comp_bin_data)
7726  ***      0      0      0   unless my $status = $z->read(\$uncomp_bin_data, $len)
7736  ***      0      0      0   defined $_ ? :
7776  ***      0      0      0   unless $packet
7777  ***      0      0      0   unless $session
7781  ***      0      0      0   if (not $$session{'state'})
7786  ***      0      0      0   if ($$session{'out_of_order'})
7788  ***      0      0      0   if (not $$session{'have_header'})
7792  ***      0      0      0   if ($line1)
7801  ***      0      0      0   if $$session{'attribs'}{'bytes'} and $have_len >= $$session{'attribs'}{'bytes'}
7808  ***      0      0      0   if ($$session{'state'} eq 'awaiting reply') { }
      ***      0      0      0   elsif ($$session{'state'} eq 'recving content') { }
7810  ***      0      0      0   unless $$session{'start_reply'}
7815  ***      0      0      0   if (not $line1)
7826  ***      0      0      0   $content ? :
7828  ***      0      0      0   if ($$session{'attribs'}{'bytes'} and $content_len < $$session{'attribs'}{'bytes'})
7840  ***      0      0      0   if ($$session{'buff'})
7861  ***      0      0      0   unless $packet
7862  ***      0      0      0   unless $session
7867  ***      0      0      0   if (($$session{'state'} || '') =~ /awaiting /)
7872  ***      0      0      0   if (not $$session{'state'}) { }
7876  ***      0      0      0   if (not $request or not $page)
7885  ***      0      0      0   if ($request eq 'get' or $request eq 'post') { }
7907  ***      0      0      0   unless $data
7911  ***      0      0      0   unless $line1
7913  ***      0      0      0   if (not $header_vals)
7919  ***      0      0      0   unless $val
7921  ***      0      0      0   if ($val =~ /^Content-Length/i)
7925  ***      0      0      0   if ($val =~ /Content-Encoding/i)
7929  ***      0      0      0   if ($val =~ /^Host/i)
7939  ***      0      0      0   defined $_ ? :
7973  ***      0      0      0   unless defined $args{$arg}
7994  ***      0      0      0   if ($self->_time_to_check($time)) { }
8000  ***      0      0      0   if ($args{'stats'})
8007  ***      0      0      0   if ($rate_avg > $$self{'rate_max'}) { }
8009  ***      0      0      0   if $$self{'skip_prob'} > 1
8011  ***      0      0      0   if $args{'stats'}
8015  ***      0      0      0   if $$self{'skip_prob'} < 0
8016  ***      0      0      0   if $args{'stats'}
8025  ***      0      0      0   if ($args{'stats'})
8034  ***      0      0      0   if ($args{'event'})
8035  ***      0      0      0   $$self{'skip_prob'} <= rand() ? :
8043  ***      0      0      0   if (not $$self{'last_check'})
8047  ***      0      0      0   $time - $$self{'last_check'} >= $$self{'check_int'} ? :
8064  ***      0      0      0   if @$samples > 1000
8071  ***      0      0      0   defined $_ ? :
8144         100     53      1   unless $_ eq 'genlog'
             100      1     53   if (grep {$_ eq 'GeneralLogParser' unless $_ eq 'genlog';} @{$o->get('type');} and not $o->got('order-by')) { }
8152  ***     50     54      0   if (not $o->get('help'))
8153  ***     50      0     54   if ($review_dsn and !defined($$review_dsn{'D'}) || !defined($$review_dsn{'t'}))
8158  ***     50      0     54   if ($o->get('mirror') and !$o->get('execute') || !$o->get('processlist'))
8162  ***     50      0     54   if ($o->get('outliers') and grep {not $_ =~ /^\w+:[0-9.]+(?::[0-9.]+)?$/;} @{$o->get('outliers');})
8167  ***     50      0     54   if ($o->get('execute-throttle'))
8169  ***      0      0      0   unless $rate_max and $rate_max > 0 and $rate_max <= 100
8171  ***      0      0      0   unless $int
8173  ***      0      0      0   if $int =~ /[^\d]/
8175  ***      0      0      0   if $step and $step < 1 || $step > 100
8193         100      3     51   if (my $ep_dsn = $o->get('explain'))
8210  ***     50      0     54   if ($review_dsn)
8225  ***      0      0      0   if ($o->get('create-review-table'))
8235  ***      0      0      0   if (not $tp->check_table('dbh', $qv_dbh, 'db', $db_tbl[0], 'tbl', $db_tbl[1], 'all_privs', 1))
8255  ***      0      0      0   if (my $review_history_dsn = $o->get('review-history'))
8268  ***      0      0      0   if ($o->get('create-review-history-table'))
8278  ***      0      0      0   if (not $tp->check_table('dbh', $qv_dbh2, 'db', $hdb_tbl[0], 'tbl', $hdb_tbl[1], 'all_privs', 1))
8303  ***      0      0      0   unless $attr and $metric
8304  ***      0      0      0   if $attr =~ /_/
8309  ***      0      0      0   if ($o->got('select'))
8339  ***     50      0     54   if (my $ps_dsn = $o->get('processlist')) { }
8345  ***      0      0      0   if ($o->get('ask-pass'))
8360  ***      0      0      0   if ($err)
8377  ***      0      0      0   if ($err)
8383  ***      0      0      0   if ($o->get('mirror') and time - $cur_time > $o->get('mirror'))
8418  ***     50     54      0   if $alias_for{$$type[0]}
8421         100      9     45   if (my $watch_server = $o->get('watch-server'))
8441  ***     50      0     66   if ($EVAL_ERROR)
8459  ***     50      0     54   if ($o->get('since') or $o->get('until'))
8460  ***      0      0      0   if (my $aux_dsn = $o->get('aux-dsn'))
8475  ***      0      0      0   unless $aux_dbh
8480  ***     50      0     54   if ($o->get('since'))
8482  ***      0      0      0   unless $since
8486  ***      0      0      0   if ($past_since)
8490  ***      0      0      0   if ($$event{'ts'})
8492  ***      0      0      0   if (($ts || 0) >= $since) { }
8505  ***     50      0     54   if ($o->get('until'))
8507  ***      0      0      0   unless $until
8511  ***      0      0      0   if ($at_until)
8515  ***      0      0      0   if ($$event{'ts'})
8517  ***      0      0      0   if (($ts || 0) >= $until) { }
8531         100     47      7   if (grep {$_ eq 'fingerprint';} @groupby)
8537  ***     50      0    346   unless $groupby_val
8556  ***     50     54      0   if $inherit_attrib_sub
8559         100      1     53   if (grep {$_ eq 'tables';} @groupby)
8564  ***     50      0      2   unless defined $group_by_val
8569         100      1      1   if (not $_ =~ /\./ and my $db = $$event{'db'} || $$event{'Schema'})
8582  ***     50      0     54   if ($o->get('type') eq 'memcached' or $o->get('type') eq 'http')
8584  ***      0      0      0   if ($o->get('type') eq 'http')
8593         100      3     51   if (grep {$_ eq 'distill';} @groupby)
8598  ***     50      0     11   unless defined $group_by_val
8608         100      1     53   if ($o->get('filter'))
8610  ***     50      0      1   if (-f $filter and -r $filter) { }
8612  ***      0      0      0   unless open my $fh, '<', $filter
8621  ***     50      0      1   unless my $sub = eval $code
8627         100     53      1   if ($o->get('zero-admin'))
8631         100     11    349   if ($$event{'arg'} and $$event{'arg'} =~ /^# administrator/)
8641  ***     50      0     54   if ($o->got('sample'))
8644  ***      0      0      0   if ($group_by_val)
8649  ***      0      0      0   if (++$seen{$$event{$group_by_val}} <= $num_samples)
8661  ***     50      0     54   if ($o->get('print'))
8673  ***     50      0     54   if (my $et_args = $o->get('execute-throttle'))
8701         100      2     52   if (my $ex_dsn = $o->get('execute'))
8702  ***     50      0      2   if ($o->get('ask-pass'))
8725  ***     50      0      2   if (($$event{'Skip_exec'} || '') eq 'Yes')
8736         100      1      1   if ($db and !$curdb || $db ne $curdb)
8746  ***     50      0      1   if ($o->get('mirror') and $end - $cur_time > $o->get('mirror'))
8758         100      1      1   if ($EVAL_ERROR)
8762  ***     50      0      1   if ($EVAL_ERROR =~ /server has gone away/)
8775  ***      0      0      0   if ($EVAL_ERROR)
8781  ***     50      1      0   if ($EVAL_ERROR =~ /No database/)
8798  ***     50      0     55   unless $orderby[$i]
8836         100      1     54   if ($o->get('timeline'))
8851  ***     50      0     54   if ($o->get('processlist'))
8864  ***     50      0     54   if ($o->get('daemonize')) { }
      ***     50      0     54   elsif ($o->get('pid')) { }
8878         100      1     53   if (my $patterns = $o->get('embedded-attributes'))
8885  ***     50      0     54   if (@ARGV == 0)
8893  ***     50      0     54   if (my $read_time = $o->get('read-timeout')) { }
8911  ***     50      0     54   if ($o->get('print-iterations'))
8922         100    108    433   if (not $fh)
8924         100     54     54   if (not $file)
8929  ***     50      0     54   if ($file eq '-') { }
8934  ***     50      0     54   if (not open $fh, '<', $file)
8960  ***     50      0   2433   unless $oktorun
8978         100    124   2309   unless $event
8980         100     54    433   if (not $more_events)
8982  ***     50     54      0   if $fh
8986  ***     50      0    487   if ($EVAL_ERROR)
8992  ***      0      0      0   if $EVAL_ERROR =~ /Cannot open/
8994  ***      0      0      0   unless $o->get('continue-on-error')
9010         100      7     47   if ($o->get('report') and $o->get('report-format')->{'header'})
9011  ***     50      0      7   if $o->get('report-format')->{'rusage'}
9016  ***     50      0      7   if (not $ea->events_processed) { }
9046         100     50      5   if ($limit =~ /^\d+$/) { }
9062         100     54      1   if ($o->get('outliers')->[$i])
9083         100      8     47   if ($o->get('report') and $o->get('report-format')->{'query_report'} and @groupby > 1 || $groupby ne 'fingerprint')
9105         100    104     17   $groupby eq 'fingerprint' ? :
             100    104     17   $groupby eq 'fingerprint' ? :
9121         100     12    109   if ($$stats{'Statement_id'} and $item =~ /^(?:prepare|execute) /)
9129         100      6      6   if ($item =~ /^prepare /) { }
9140         100      6      6   if (not $seen_prepared{$prep_stmt}++)
9164  ***     50      0    121   if ($qv)
9166  ***      0      0      0   if ($$review_vals{'reviewed_by'} and not $o->get('report-all'))
9169  ***      0      0      0   if ($o->get('review-history'))
9176  ***      0      0      0   if ($o->get('review-history'))
9190         100      1     39   $$stats{'db'}{'unq'} ? :
             100     81     40   $$sample{'db'} ? :
9193  ***     50    121      0   if ($o->get('for-explain') or $o->get('table-access'))
9195         100      5    116   if $o->get('table-access')
9201         100    106     15   if ($o->get('report') and $o->get('report-format')->{'query_report'})
9206         100     74     32   $explain_why ? :
9219  ***     50      0    106   if ($qv)
9225  ***      0      0      0   if (not $val or $val ne '0000-00-00 00:00:00')
9226  ***      0      0      0   $val ? :
9231         100     96     10   if ($groupby eq 'fingerprint')
9233  ***     50     96      0   if $o->get('shorten')
9237  ***     50      0    106   if ($groupby eq 'fingerprint' and $o->get('fingerprints'))
9241         100     96     10   if ($groupby eq 'fingerprint') { }
9242  ***     50     96      0   if $o->get('for-explain')
9243         100     41     55   if ($item =~ /^(?:[\(\s]*select|insert|replace)/) { }
9244         100     15     26   if ($item =~ /^(?:insert|replace)/) { }
9255         100     27     28   if ($o->get('for-explain') and $converted and $converted =~ /^[\(\s]*select/i)
9265         100      1      9   if ($groupby eq 'tables')
9276  ***     50      0    121   if ($qv)
9283  ***      0      0      0   if ($o->get('review-history'))
9295         100      1     54   if ($o->get('timeline'))
9301         100      2     53   if ($o->get('table-access'))
9307  ***     50      0      5   if ($EVAL_ERROR)
9314  ***     50      0      2   if $o->get('report')
9317  ***     50      0      5   unless $rw
9319  ***     50      0      5   unless scalar @tables
9321         100      1      4   if $seen{$db_tbl}++
9323  ***     50      0      4   $db ? :
9330         100      9     46   if ($o->get('report') and $o->get('report-format')->{'profile'})
9362         100      1     54   if ($o->get('report') and $o->get('report-format')->{'prepared'} and scalar @prepared)
9410  ***     50      0     54   if ($o->get('pipeline-profile'))
9437         100      2     52   if ($o->get('statistics'))
9438  ***     50      2      0   if (keys %stats) { }
9480  ***     50      0     89   unless $db_tbl
9481         100      3     86   if $seen{$db_tbl}++
9491         100     34     63   unless @tables
9495         100     60     10   $db ? :
9505         100     23      3   unless $dbh and $query
9507  ***     50      3      0   if (not $qp->has_derived_table($query))
9508  ***     50      3      0   if ($db)
9518         100     14      6   defined $row[$j] ? :
9524         100      1      2   if ($EVAL_ERROR)
9548  ***     50      2      0   if (not $dbh or not $dbh->ping)
9554  ***     50      0      2   if ($o->get('mirror'))
9558  ***      0      0      0   if ($is_read_only != $read_only)
9559  ***      0      0      0   $current eq 'execute' ? :
9572  ***      0      0      0   if ($oktorun) { }
9604  ***     50      0     54   if $EVAL_ERROR
9620  ***     50      0     54   if $EVAL_ERROR
9629         100      1     61   if (not $ea->type_for($orderby_attrib) and $orderby_attrib ne 'Query_time')
9633  ***     50      1      0   if ($o->get('report-format')->{'query_report'})
9649  ***      0      0      0   unless $fh
9670  ***      0      0      0   if ($EVAL_ERROR)
9672  ***      0      0      0   unless $EVAL_ERROR =~ /read timeout/
9683  ***     50      0      9   unless $args{$arg}
9687  ***     50      0      3   if ($o->get('ask-pass'))
9688  ***      0      0      0   $args{'for'} ? :
9699  ***      0      0      0   defined $_ ? :


Conditions
----------

and 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
1976  ***      0      0      0   $rows and scalar @$rows
4897  ***     50      0    106   defined $vals and scalar @$vals
9362         100     54      1   $o->get('report') and $o->get('report-format')->{'prepared'} and scalar @prepared

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
134   ***     66     29     32      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33     61      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
256   ***     66      7      0      7   not $dbh and $tries--
292   ***     33      7      0      0   not $dbh and $EVAL_ERROR
677          100   1026   2052    324   $type and $type eq 'd'
      ***     66   3078    324      0   $type and $type eq 'd' and not $$self{'dp'}
682          100   1026   1188   1188   $type and $type =~ /[HhAadzm]/
821   ***     33      0     54      0   @ARGV and $ARGV[0] eq '--config'
850   ***     33      0     54      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
857   ***     33      0     54      0   @ARGV and $$self{'strict'}
941   ***     66      0   1026   2376   $opt and $$opt{'type'}
944   ***     66   1441    935      0   $val and $$opt{'type'} eq 'm'
             100   1441    930      5   $val and $$opt{'type'} eq 'd'
      ***     66   1441    930      0   $val and $$opt{'type'} eq 'z'
      ***     66   1441    876      0   defined $val and $$opt{'type'} eq 'h'
             100   1388    334    271   defined $val and $$opt{'type'} eq 'a'
1009  ***     33      0      0   4379   $long and exists $$self{'opts'}{$long}
1017  ***     33      0      0    271   $long and exists $$self{'opts'}{$long}
1031  ***     33      0      0     54   $long and exists $$self{'opts'}{$long}
1121  ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
1215  ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1373         100    492    373    430   $t > 0 and $t <= 0.000999
             100    492    181    192   $t >= 0.001 and $t <= 0.999999
1437  ***      0      0      0      0   $prefix and $prefix eq '-'
1451  ***     66   3485      0     56   $num >= $d and $n < @units - 1
1533  ***      0      0      0      0   $callback and ref $callback eq 'CODE'
1625  ***     33      0      2      0   $length > 0 and $query_length > $length
      ***     33      2      0      0   $length > 0 and $query_length > $length and $query_length < ($last_length || $query_length + 1)
1785         100      8    103      4   $verbs and $verbs =~ /^SHOW/
1993  ***      0      0      0      0   not $curr and @curr
1997  ***      0      0      0      0   not $prev and @prev
2002  ***      0      0      0      0   $curr and $prev
      ***      0      0      0      0   $curr and $prev and $$curr[0] == $$prev[0]
      ***      0      0      0      0   $curr and $prev
      ***      0      0      0      0   $curr and $prev and $$curr[0] > $$prev[0]
2007  ***      0      0      0      0   defined $$curr[5] and $$curr[5] < $$prev[5]
      ***      0      0      0      0   $$curr[7] and defined $$curr[5]
      ***      0      0      0      0   $$curr[7] and defined $$curr[5] and $$misc{'time'} - $$curr[5] - $$prev[8] - $$prev[9] - $$misc{'etime'} > $fudge
2027  ***      0      0      0      0   $$prev[7] and not $is_new
2048  ***      0      0      0      0   $$curr[7] and defined $$curr[5]
2103  ***      0      0      0      0   $find_spec{'busy_time'} and ($$query{'Command'} || '') eq 'Query'
2112  ***      0      0      0      0   $find_spec{'idle_time'} and ($$query{'Command'} || '') eq 'Sleep'
2124  ***      0      0      0      0   defined $find_spec{'ignore'}{$property} and $self->$filter($query, $find_spec{'ignore'}{$property})
2146  ***      0      0      0      0   @matches and $find_spec{'only_oldest'}
2157  ***      0      0      0      0   defined $property && defined $$query{'Id'}
      ***      0      0      0      0   defined $property && defined $$query{'Id'} && $$query{'Id'} == $property
2162  ***      0      0      0      0   defined $property && defined $$query{'User'}
      ***      0      0      0      0   defined $property && defined $$query{'User'} && $$query{'User'} =~ /$property/
2168  ***      0      0      0      0   defined $property && defined $$query{'Host'}
      ***      0      0      0      0   defined $property && defined $$query{'Host'} && $$query{'Host'} =~ /$property/
2174  ***      0      0      0      0   defined $property && defined $$query{'db'}
      ***      0      0      0      0   defined $property && defined $$query{'db'} && $$query{'db'} =~ /$property/
2180  ***      0      0      0      0   defined $property && defined $$query{'State'}
      ***      0      0      0      0   defined $property && defined $$query{'State'} && $$query{'State'} =~ /$property/
2186  ***      0      0      0      0   defined $property && defined $$query{'Command'}
      ***      0      0      0      0   defined $property && defined $$query{'Command'} && $$query{'Command'} =~ /$property/
2192  ***      0      0      0      0   defined $property && defined $$query{'Info'}
      ***      0      0      0      0   defined $property && defined $$query{'Info'} && $$query{'Info'} =~ /$property/
2558  ***     66     31     35      0   $src_host ne $server and $dst_host ne $server
2614  ***     66     88      4      0   $$packet{'syn'} and $$session{'n_queries'} > 0 || $$session{'state'}
2631  ***     33     73      0      0   $$session{'buff'} and $packet_from eq 'client'
2670  ***      0      0      0      0   $$session{'cmd'} and ($$session{'state'} || '') eq 'awaiting_reply'
2689  ***     33     38      0      0   $$session{'cmd'} and ($$session{'state'} || '') eq 'awaiting_reply'
2736  ***     33      0      0      2   $first_byte eq '0a' and length $data >= 33
      ***     33      0      0      2   $first_byte eq '0a' and length $data >= 33 and $data =~ /00{13}/
2758  ***     33     21      0      0   $first_byte eq 'fe' and $$packet{'mysql_data_len'} < 9
2878  ***      0      0      0      0   $$packet{'mysql_data_len'} == 1 and $$session{'state'} eq 'client_auth'
      ***      0      0      0      0   $$packet{'mysql_data_len'} == 1 and $$session{'state'} eq 'client_auth' and $$packet{'number'} == 2
3332  ***     33      0      0     46   $data and $len
3342         100     12      3     31   $code ne '17' and $code ne '19'
      ***     66     15      0     31   $code ne '17' and $code ne '19' and $code ne '1a'
3359  ***     33      0      0     12   $data and $sths
3472  ***     33      0     10      0   $com and $$com{'code'} eq '00'
3558  ***      0      0      0      0   $o and $o->has('tcpdump-errors')
      ***      0      0      0      0   $o and $o->has('tcpdump-errors') and $o->got('tcpdump-errors')
3690         100    201   1186     53   not $got_ts and my($time) = $line =~ /$slow_log_ts_line/o
             100    516    768    103   not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o
      ***     66      0   1274     10   not $got_ac and $line =~ /^# (?:administrator command:.*)$/
             100      5    242     39   not $got_db and my($db) = $line =~ /^use ([^;]+)/
      ***     66      0    227     20   not $got_set and my($setting) = $line =~ /^SET\s+([^;]*)/
3694  ***     66      0     37     16   not $got_uh and my($user, $host, $ip) = $line =~ /$slow_log_uh_line/o
3737         100     10   1427      3   not $found_arg and $pos == $len
3757  ***     66      0    296      1   $args{'misc'} and $args{'misc'}{'embed'}
      ***     66    296      0      1   $args{'misc'} and $args{'misc'}{'embed'} and my($e) = $arg =~ /($args{'misc'}{'embed'})/
3815  ***      0      0      0      0   $$event{'ip'} and $$event{'port'}
4149  ***     66    297      0    383   $args{'all'} and $type eq 'num'
      ***     66    297      0    383   $args{'all'} and $type eq 'num' and $$self{'attrib_limit'}
4241  ***     33      0      0    646   defined $vals and @$vals
      ***     33      0      0    646   defined $vals and @$vals and $$args{'cnt'}
4258         100      6      6     46   $v && $v > 0
4293         100     57      2     25   not $bucket_95 and $sum_excl > $top_vals
4295         100     31     28     25   not $median and $total_left <= $mid
4334  ***      0      0      0      0   $global_cnt && $$store{'cnt'}
      ***      0      0      0      0   $$store{'sum'} && $$store{'cnt'}
4358         100      1     12    121   !$args{'total'} || $total < $args{'total'} and !$args{'count'} || $count < $args{'count'}
      ***     66      1     12      0   $args{'ol_attrib'} and !$args{'ol_freq'} || $$classes{$groupby}{$args{'ol_attrib'}}{'cnt'} >= $args{'ol_freq'}
4389         100    366   4611   1864   $_ ne $$self{'groupby'} and not exists $$self{'attributes'}{$_}
4505  ***     33     65      0      0   $$col{'fixed_wdith'} and $$col{'fixed_width'} < length $$col{'name'}
4509  ***     33     65      0      0   $$col{'min_width'} and $$col{'min_width'} < length $$col{'name'}
4537  ***     33    189      0      0   $$col{'fixed_width'} and $width > $$col{'fixed_width'}
4540  ***     33    189      0      0   $$col{'max_width'} and $width > $$col{'max_width'}
4594  ***     66      0      9      3   $$self{'truncate_underline'} and 2 + $underline_len > $$self{'line_width'}
4678  ***      0      0      0      0   $label_width < 15 and --$w >= 80
4720  ***     33      0      0      7   $global_cnt and $$stats{'globals'}{'ts'}
      ***     66      0      1      6   $global_cnt and $$stats{'globals'}{'ts'} and ($$stats{'globals'}{'ts'}{'max'} || '') gt ($$stats{'globals'}{'ts'}{'min'} || '')
4805  ***     66      0      2    104   $global_cnt and $$store{'ts'}
             100      2     91     13   $global_cnt and $$store{'ts'} and ($$store{'ts'}{'max'} || '') gt ($$store{'ts'}{'min'} || '')
4917  ***     66    102    746      0   $n_marks < 1 and $n_vals > 0
5185  ***     33      0      0      8   $t = $$res[2]{'ts'} and $$t{'min'}
5188  ***     33      0      8      0   $$t{'max'} and $$t{'max'} gt $$t{'min'}
5264  ***     33      0      2      0   $ddl_stmt =~ /CREATE/i and $query =~ /$ddl_stmt\b.+?\bSELECT\b/i
5398  ***     33      5      0      0   $statements[-2] and $statements[-2] =~ /on duplicate key\s+$/i
5641  ***      0      0      0      0   $trgs and @$trgs
5687  ***      0      0      0      0   $curr and $new
      ***      0      0      0      0   $curr and $new and $curr eq $new
6103  ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete
6141  ***      0      0      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000'
      ***      0      0      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i
6172  ***      0      0      0      0   $engine =~ /InnoDB/i and not $clustered_key
6174  ***      0      0      0      0   $$this_key{'is_unique'} and not $$this_key{'is_nullable'}
6198  ***      0      0      0      0   not $parent =~ /\./ and $$opts{'database'}
6354  ***      0      0      0      0   $attr and $metric
6379  ***      0      0      0      0   defined $data{'ts'} and defined $data{'ts'}{$thing}
6392  ***      0      0      0      0   $review_vals and @$review_vals == 1
6512  ***      0      0      0      0   $PID_file and -f $PID_file
6573  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
6645  ***      0      0      0      0   $src_host ne $server and $dst_host ne $server
6735  ***      0      0      0      0   $rest and $bytes
6904  ***      0      0      0      0   $o and $o->has('tcpdump-errors')
      ***      0      0      0      0   $o and $o->has('tcpdump-errors') and $o->got('tcpdump-errors')
7190         100     47      2     14   not $got_offset and my($offset) = $line =~ /$binlog_line_1/m
             100     33      2     14   not $got_hdr and $line =~ /^#(\d{6}\s+\d{1,2}:\d\d:\d\d)/
7220  ***     66      2      0     13   $got_offset and $got_hdr
7357  ***     33      0      0      7   $thread_id && $cmd
7373  ***     66      3      0      2   $thread_id and $cmd
7507  ***      0      0      0      0   $packet_from eq 'client' and $$packet{'fin'} || $$packet{'rst'}
7598  ***      0      0      0      0   $src_host ne $server and $dst_host ne $server
7664  ***      0      0      0      0   $o and $o->has('tcpdump-errors')
      ***      0      0      0      0   $o and $o->has('tcpdump-errors') and $o->got('tcpdump-errors')
7697  ***      0      0      0      0   $start and $end
7801  ***      0      0      0      0   $$session{'attribs'}{'bytes'} and $have_len >= $$session{'attribs'}{'bytes'}
7828  ***      0      0      0      0   $$session{'attribs'}{'bytes'} and $content_len < $$session{'attribs'}{'bytes'}
8144  ***     66     53      0      1   grep {$_ eq 'GeneralLogParser' unless $_ eq 'genlog';} @{$o->get('type');} and not $o->got('order-by')
8153  ***     33     54      0      0   $review_dsn and !defined($$review_dsn{'D'}) || !defined($$review_dsn{'t'})
8158  ***     33     54      0      0   $o->get('mirror') and !$o->get('execute') || !$o->get('processlist')
8162  ***     33      0     54      0   $o->get('outliers') and grep {not $_ =~ /^\w+:[0-9.]+(?::[0-9.]+)?$/;} @{$o->get('outliers');}
8169  ***      0      0      0      0   $rate_max and $rate_max > 0
      ***      0      0      0      0   $rate_max and $rate_max > 0 and $rate_max <= 100
8175  ***      0      0      0      0   $step and $step < 1 || $step > 100
8303  ***      0      0      0      0   $attr and $metric
8357  ***      0      0      0      0   $sth and not $err
8383  ***      0      0      0      0   $o->get('mirror') and time - $cur_time > $o->get('mirror')
8569  ***     66      1      0      1   not $_ =~ /\./ and my $db = $$event{'db'} || $$event{'Schema'}
8610  ***     33      1      0      0   -f $filter and -r $filter
8631  ***     66      0    349     11   $$event{'arg'} and $$event{'arg'} =~ /^# administrator/
8736  ***     66      1      0      1   $db and !$curdb || $db ne $curdb
8746  ***     33      1      0      0   $o->get('mirror') and $end - $cur_time > $o->get('mirror')
8906  ***     66      0     54     54   $oktorun and !$o->get('iterations') || $iters++ < $o->get('iterations')
8918  ***     33      0      0    541   $oktorun and $start == $end || $now < $end
9010         100      3     44      7   $o->get('report') and $o->get('report-format')->{'header'}
9070  ***     66      0      7     48   $expected_range && (@worst < $$expected_range[0] || @worst > $$expected_range[1])
9083         100      3      1     51   $o->get('report') and $o->get('report-format')->{'query_report'}
             100      4     43      8   $o->get('report') and $o->get('report-format')->{'query_report'} and @groupby > 1 || $groupby ne 'fingerprint'
9121  ***     66    109      0     12   $$stats{'Statement_id'} and $item =~ /^(?:prepare|execute) /
9166  ***      0      0      0      0   $$review_vals{'reviewed_by'} and not $o->get('report-all')
9201         100     12      3    106   $o->get('report') and $o->get('report-format')->{'query_report'}
9237  ***     66     10     96      0   $groupby eq 'fingerprint' and $o->get('fingerprints')
9255  ***     33      0      0     55   $o->get('for-explain') and $converted
      ***     66      0     28     27   $o->get('for-explain') and $converted and $converted =~ /^[\(\s]*select/i
9330         100      3     43      9   $o->get('report') and $o->get('report-format')->{'profile'}
9362         100      3     51      1   $o->get('report') and $o->get('report-format')->{'prepared'}
9505  ***     66     23      0      3   $dbh and $query
9629         100     60      1      1   not $ea->type_for($orderby_attrib) and $orderby_attrib ne 'Query_time'

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
44    ***     50      0      7   $ENV{'MKDEBUG'} || 0
115          100      5      2   $prev ||= {}
116   ***     50      0      7   $defaults ||= {}
189   ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
202   ***     50      0      7   $self->prop('dbidriver') || ''
206   ***      0      0      0   $$info{'D'} || ''
212          100      1      6   $$info{'D'} || ''
234   ***     50      7      0   $opts ||= {}
329   ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
345   ***      0      0      0   $level ||= 0
346   ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
395   ***     50      0      7   $ENV{'MKDEBUG'} || 0
462   ***     50      0      7   $ENV{'MKDEBUG'} || 0
481   ***     50     54      0   $program_name ||= $PROGRAM_NAME
482   ***     50     54      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
484   ***     50     54      0   $args{'prompt'} || '<options>'
      ***     50     54      0   $args{'dp'} || undef
526   ***     50      0     54   $file ||= '/home/daniel/dev/maatkit/mk-query-digest/mk-query-digest'
667   ***     50   3402      0   $$opt{'group'} ||= 'default'
949   ***      0      0      0   $s || 's'
958   ***      0      0      0   $prefix || ''
986   ***      0      0      0   $pre || ''
993   ***     50     54      0   $val || ''
996          100    542     53   $val || ''
1054  ***      0      0      0   $$self{'description'} || ''
1123  ***      0      0      0   $s ||= 's'
1149  ***      0      0      0   $$opt{'type'} || ''
1278  ***      0      0      0   $file ||= '/home/daniel/dev/maatkit/mk-query-digest/mk-query-digest'
1338  ***     50      0      7   $ENV{'MKDEBUG'} || 0
1393  ***     50      0    722   $args{'p'} || 0
1395         100    472    250   $of ||= 1
1400  ***      0      0      0   $secs ||= 0
1430  ***      0      0      0   $suffix || $default_suffix || 's'
1571  ***     50      0      7   $ENV{'MKDEBUG'} || 0
1932  ***     50      0      7   $ENV{'MKDEBUG'} || 0
1985  ***      0      0      0   $$self{'prev_rows'} ||= []
1986  ***      0      0      0   $$self{'new_rows'} ||= []
2103  ***      0      0      0   $$query{'Command'} || ''
2112  ***      0      0      0   $$query{'Command'} || ''
2223  ***     50      0      7   $ENV{'MKDEBUG'} || 0
2370  ***     50      0      7   $ENV{'MKDEBUG'} || 0
2533         100      8      4   $args{'port'} || '3306'
2670  ***      0      0      0   $$session{'state'} || ''
2689  ***      0      0      0   $$session{'state'} || ''
2718         100     23     12   $$session{'server_seq'} || ''
2759  ***     50     11      0   $$session{'state'} || ''
2938         100     26     12   $$session{'client_seq'} || ''
2948         100      2     36   $$session{'state'} || ''
      ***     50      0     36   $$session{'state'} || ''
      ***     50      0     36   $$session{'state'} || ''
3066         100      1     37   $$event{'Error_no'} || 'none'
      ***     50      0     38   $$event{'Rows_affected'} || 0
      ***     50      0     38   $$event{'Warning_count'} || 0
3369         100      4      8   int(($$sth{'num_params'} + 7) / 8) || 1
3621  ***     50      0      7   $ENV{'MKDEBUG'} || 0
3799  ***     50      0      7   $ENV{'MKDEBUG'} || 0
3897  ***     50     55      0   $args{'attributes'} || {}
3925  ***     50     55      0   $args{'unroll_limit'} || 1000
3972         100   3501   1829   $$self{'result_classes'}{$val}{$attrib} ||= {}
3973         100   4612    718   $$self{'result_globals'}{$attrib} ||= {}
3986         100   4719    138   $$samples{$val} ||= $event
4246         100    342    250   $$args{'max'} || 0
4261  ***     50     29      0   $$args{'max'} || 0
4262         100     23      6   $$args{'min'} || 0
4307  ***     50     25      0   $$args{'max'} || 0
             100     23      2   $$args{'min'} || 0
4461  ***     50      0      7   $ENV{'MKDEBUG'} || 0
4513  ***     50      0     65   $$col{'truncate_mark'} ||= '...'
4514  ***     50      0     65   $$col{'type'} ||= 's'
4515  ***     50      0     65   $$col{'fixed_width'} || 0
      ***     33      0     65   0
4516  ***     50      0     65   $$col{'fixed_width'} || 0
      ***     33      0     65   0
4567  ***     50     55      0   $$col{'max_width'} || $$col{'max_val_width'} || ''
      ***     50     55      0   $$col{'type'} || 's'
4576  ***     50     12      0   $$self{'line_prefix'} || ''
4670  ***     50     54      0   $args{'label_width'} || 9
4700  ***      0      0      0   $rss || 0
      ***      0      0      0   $vsz || 0
4717  ***     50      7      0   $$stats{'globals'}{$opts{'worst'}}{'cnt'} || 0
4720  ***     50      7      0   $$stats{'globals'}{'ts'}{'max'} || ''
      ***     50      7      0   $$stats{'globals'}{'ts'}{'min'} || ''
4738         100      5      2   $qps || 0
             100      3      4   $conc || 0
4805         100     95      9   $$store{'ts'}{'max'} || ''
             100     95      9   $$store{'ts'}{'min'} || ''
4818  ***     50    106      0   $opts{'rank'} || 0
             100     10     96   $qps || 0
             100      8     98   $conc || 0
             100     78     28   $$sample{'pos_in_log'} || 0
4916         100    744    104   $vals_per_mark || 1
4956  ***     50     18      0   $$stats{'sum'} || 0
5019  ***     50    738      0   $ea->type_for($attrib) || ''
5063  ***     50      0      7   $ENV{'MKDEBUG'} || 0
5227  ***     50      0      7   $ENV{'MKDEBUG'} || 0
5460  ***      0      0      0   $word =~ tr/(// || 0
5461  ***      0      0      0   $word =~ tr/)// || 0
5588  ***     50      0      7   $ENV{'MKDEBUG'} || 0
5858  ***      0      0      0   $$_[1] || ''
5898  ***     50      0      7   $ENV{'MKDEBUG'} || 0
6117  ***      0      0      0   $engine || undef
6140  ***      0      0      0   $type || $special || 'BTREE'
6227  ***      0      0      0   $$tbl_struct{'engine'} || ''
6229  ***      0      0      0   $clustered_key ||= ''
6287  ***     50      0      7   $ENV{'MKDEBUG'} || 0
6437  ***     50      0      7   $ENV{'MKDEBUG'} || 0
6618  ***     50      0      7   $ENV{'MKDEBUG'} || 0
6623  ***      0      0      0   $args{'port'} || '11211'
6793  ***      0      0      0   $$session{'state'} || ''
6882  ***      0      0      0   $$session{'val'} || ''
      ***      0      0      0   $$session{'flags'} || 0
      ***      0      0      0   $$session{'exptime'} || 0
      ***      0      0      0   $$session{'bytes'} || 0
6980  ***     50      0      7   $ENV{'MKDEBUG'} || 0
7122  ***     50      0      7   $ENV{'MKDEBUG'} || 0
7315  ***     50      0      7   $ENV{'MKDEBUG'} || 0
7471  ***     50      0      7   $ENV{'MKDEBUG'} || 0
7572  ***      0      0      0   $$session{'ts_min'} || ''
7574  ***      0      0      0   $$session{'ts_max'} || ''
7645  ***      0      0      0   $$session{'start_request'} || 0
7646  ***      0      0      0   $$session{'start_reply'} || 0
7647  ***      0      0      0   $$session{'end_reply'} || 0
7763  ***     50      0      7   $ENV{'MKDEBUG'} || 0
7867  ***      0      0      0   $$session{'state'} || ''
7881  ***      0      0      0   $$session{'attribs'}{'Virtual_host'} || ''
7967  ***     50      0      7   $ENV{'MKDEBUG'} || 0
7996  ***      0      0      0   sum(@{$$self{'int_rates'};}) || 0
      ***      0      0      0   scalar @{$$self{'int_rates'};} || 1
8052  ***      0      0      0   $$self{'stats'}{'rate_avg'} || 0
8066  ***      0      0      0   $$self{'stats'}{'rate_avg'} || 0
8105  ***     50      0      7   $ENV{'MKDEBUG'} || 0
8184         100     54      1   $orderby[$i] ||= $default_orderby
8492  ***      0      0      0   $ts || 0
8517  ***      0      0      0   $ts || 0
8676  ***      0      0      0   $step ||= 5
8681  ***      0      0      0   $prof{'callback'}{'execute'}{'time'} || 0
      ***      0      0      0   $prof{'total'}{'time'} || 0
8725  ***     50      0      2   $$event{'Skip_exec'} || ''
8902  ***     50      0     54   $o->get('run-time') || 0
9004  ***     50     54      0   $ENV{'LABEL_WIDTH'} || 'auto'
9044         100     54      1   $o->get('limit')->[$i] || '95%:20'
9053         100      3      2   $ea->results->{'globals'}{$orderby_attrib}{'sum'} || 0
9056  ***     50     55      0   $orderby_func || 'cnt'
9100  ***     50    121      0   $$sample{'arg'} || ''
9170  ***      0      0      0   $$sample{'arg'} || ''
9277  ***      0      0      0   $$sample{'arg'} || ''
9284  ***      0      0      0   $$sample{'arg'} || ''
9347         100     19     10   $total_r || 1
9381  ***     50      1      0   $total_r || 1
9383  ***     50      1      0   $total_r || 1
9385  ***     50      1      0   $$item{'prep_cnt'} || 0
      ***     50      1      0   $$item{'exec_cnt'} || 0
9403  ***     50      0     54   $o->get('run-time') || 0
9422  ***      0      0      0   $prof{'callback'}{$name}{'time'} || 0
9423  ***      0      0      0   $prof{'total'}{'time'} || 1
9425  ***      0      0      0   $prof{'callback'}{$name}{'count'} || 0
9447  ***     50      4      0   $stats{$stat} || 0
9650  ***      0      0      0   $t ||= 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
225   ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
226   ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
227   ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
228   ***      0      0      0      0   $$dsn{'u'} ||= $user
229   ***      0      0      0      0   $$dsn{'D'} ||= $db
482   ***     33     54      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***     33     54      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
944   ***     66     54      0   2317   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
             100    324    271   1722   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1403  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
1430  ***      0      0      0      0   $suffix || $default_suffix
1455  ***     66    305      0   3180   $num =~ /\./ || $n
1625  ***      0      0      0      0   $last_length || $query_length + 1
1755  ***     33      0    111      0   $args{'QueryParser'} || $$self{'QueryParser'}
1837  ***     66     14      0     41   $query =~ s/
                 \A.*?
                 update\s+(.*?)
                 \s+set\b(.*?)
                 (?:\s*where\b(.*?))?
                 (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
                 \Z
              /__update_to_select($1, $2, $3, $4);/eisx or $query =~ s/
                    \A.*?
                    (?:insert(?:\s+ignore)?|replace)\s+
                    .*?\binto\b(.*?)\(([^\)]+)\)\s*
                    values?\s*(\(.*?\))\s*
                    (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
                    \Z
                 /__insert_to_select($1, $2, $3);/eisx
      ***     66     14      0     41   $query =~ s/
                 \A.*?
                 update\s+(.*?)
                 \s+set\b(.*?)
                 (?:\s*where\b(.*?))?
                 (limit\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
                 \Z
              /__update_to_select($1, $2, $3, $4);/eisx or $query =~ s/
                    \A.*?
                    (?:insert(?:\s+ignore)?|replace)\s+
                    .*?\binto\b(.*?)\(([^\)]+)\)\s*
                    values?\s*(\(.*?\))\s*
                    (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
                    \Z
                 /__insert_to_select($1, $2, $3);/eisx or $query =~ s/
                    \A.*?
                    (?:insert(?:\s+ignore)?|replace)\s+
                    (?:.*?\binto)\b(.*?)\s*
                    set?\s*\b(.*?)\s*
                    (?:\blimit\b|on\s*duplicate\s*key.*)?\s*
                    \Z
                 /__insert_to_select_with_set($1, $2);/eisx
2001  ***      0      0      0      0   $curr or $prev
2002  ***      0      0      0      0   not $curr or $curr and $prev and $$curr[0] > $$prev[0]
2007  ***      0      0      0      0   not $$curr[7] or $$prev[7] ne $$curr[7]
2614  ***     33      0      0      4   $$session{'n_queries'} > 0 || $$session{'state'}
2681  ***      0      0      0      0   $$session{'buff_left'} ||= $$packet{'mysql_data_len'} - ($$packet{'data_len'} - 4)
2801  ***     33      0      0     10   $com eq '03' or $com eq '17'
      ***     33      0      0     10   $com eq '03' or $com eq '17' or $com eq '1a'
2854  ***      0      0      0      0   $com eq '03' or $com eq '17'
2897  ***     66      9     12      0   $com eq '03' or $com eq '17'
3658         100      1    309     39   defined($stmt = shift @$pending) or defined($stmt = &$next_event())
4203  ***     33      0      0   6993   $bucket < 0 or $bucket > 999
4245         100    473    119     54   $n_vals == 1 or $$args{'max'} == $$args{'min'}
4296         100     17      5      3   $cutoff % 2 || $val > 1
4358         100    122     11      1   !$args{'total'} || $total < $args{'total'}
      ***     66      0    121     12   !$args{'count'} || $count < $args{'count'}
      ***     33      0      0     12   !$args{'ol_freq'} || $$classes{$groupby}{$args{'ol_attrib'}}{'cnt'} >= $args{'ol_freq'}
4567  ***     33      0     55      0   $$col{'max_width'} || $$col{'max_val_width'}
4775  ***     66      1      0     10   $$store{'sum'} > 0 or not $opts{'no_zero_bool'}
4874  ***     66     17      0    232   $$vals{'sum'} > 0 or not $opts{'no_zero_bool'}
5373  ***      0      0      0      0   $alias or $tbl
5489  ***     33      1      0      0   $type =~ /^$data_manip_stmts\b/ or $type =~ /^$data_def_stmts\b/
5699  ***      0      0      0      0   not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl}
5738  ***      0      0      0      0   not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl}
5768  ***      0      0      0      0   not $$self{'cache'} or not $$self{'triggers'}{$db}
5802  ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'} or $like
5821  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db} or $like
5835  ***      0      0      0      0   $tbl{'type'} || $tbl{'comment'}
      ***      0      0      0      0   $tbl{'engine'} ||= $tbl{'type'} || $tbl{'comment'}
5847  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db} or $like
5991  ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'}
      ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
6070  ***      0      0      0      0   not $$row[0] or $$row[0] ne $tbl
6091  ***      0      0      0      0   $$row{'privileges'} || $$row{'Privileges'}
6140  ***      0      0      0      0   $type || $special
6362  ***      0      0      0      0   $_ eq 'ts_min' || $_ eq 'ts_max'
6586  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
6722  ***      0      0      0      0   $$session{'cmd'} eq 'incr' or $$session{'cmd'} eq 'decr'
6811  ***      0      0      0      0   $cmd eq 'set' or $cmd eq 'add'
      ***      0      0      0      0   $cmd eq 'set' or $cmd eq 'add' or $cmd eq 'replace'
      ***      0      0      0      0   $cmd eq 'incr' or $cmd eq 'decr'
7018  ***      0      0      0      0   not $$event{'cmd'} or not $$event{'key'}
7351         100      2      5      1   defined($line = shift @$pending) or defined($line = &$next_event())
7507  ***      0      0      0      0   $$packet{'fin'} || $$packet{'rst'}
7798  ***      0      0      0      0   $$packet{'content_len'} || $$packet{'data_len'}
7853  ***      0      0      0      0   $$session{'ts_max'} || $$packet{'ts'}
7876  ***      0      0      0      0   not $request or not $page
7885  ***      0      0      0      0   $request eq 'get' or $request eq 'post'
7993  ***      0      0      0      0   $args{'misc'}{'time'} || time
8026  ***      0      0      0      0   $args{'stats'}{'throttle_rate_min'} || ()
8028  ***      0      0      0      0   $args{'stats'}{'throttle_rate_max'} || ()
8153  ***      0      0      0      0   !defined($$review_dsn{'D'}) || !defined($$review_dsn{'t'})
8158  ***      0      0      0      0   !$o->get('execute') || !$o->get('processlist')
8175  ***      0      0      0      0   $step < 1 || $step > 100
8459  ***     33      0      0     54   $o->get('since') or $o->get('until')
8470  ***      0      0      0      0   $qv_dbh || $qv_dbh2
      ***      0      0      0      0   $qv_dbh || $qv_dbh2 || $ex_dbh
      ***      0      0      0      0   $qv_dbh || $qv_dbh2 || $ex_dbh || $ps_dbh
      ***      0      0      0      0   $qv_dbh || $qv_dbh2 || $ex_dbh || $ps_dbh || $ep_dbh
      ***      0      0      0      0   $aux_dbh ||= $qv_dbh || $qv_dbh2 || $ex_dbh || $ps_dbh || $ep_dbh
8569  ***     33      1      0      0   $$event{'db'} || $$event{'Schema'}
8582  ***     33      0      0     54   $o->get('type') eq 'memcached' or $o->get('type') eq 'http'
8734  ***     66      0      1      1   $$event{'db'} || $default_db
8736  ***     33      1      0      0   !$curdb || $db ne $curdb
8906  ***     66      0     54     54   !$o->get('iterations') || $iters++ < $o->get('iterations')
8918  ***     33    541      0      0   $start == $end || $now < $end
8973  ***     33   2433      0      0   $callback_names{$callback} || $callback
9070  ***     66     48      0      7   @worst < $$expected_range[0] || @worst > $$expected_range[1]
9083         100      2      6     43   @groupby > 1 || $groupby ne 'fingerprint'
9193  ***     33    121      0      0   $o->get('for-explain') or $o->get('table-access')
9225  ***      0      0      0      0   not $val or $val ne '0000-00-00 00:00:00'
9421  ***      0      0      0      0   $callback_names{$callback} || $callback
9483         100     50     22     14   $db || $default_db
9548  ***     66      1      1      0   not $dbh or not $dbh->ping


Covered Subroutines
-------------------

Subroutine                         Count Location                                                     
---------------------------------- ----- -------------------------------------------------------------
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1332
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1333
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1334
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1335
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1336
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1338
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1564
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1565
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1569
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1571
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1923
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1924
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1925
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1927
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1932
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1945
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:20  
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:21  
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2216
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2217
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2218
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2219
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2223
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2342
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2343
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2344
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2351
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2370
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2403
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2486
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:32  
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:33  
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:34  
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:35  
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3616
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3617
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3618
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3619
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3621
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3795
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3796
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3797
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3799
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3877
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3878
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3879
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3881
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3882
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3883
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3884
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3885
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3886
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:391 
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:392 
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:393 
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:395 
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:44  
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4453
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4454
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4455
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4456
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4461
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4463
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:455 
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:456 
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:458 
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:459 
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:460 
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:462 
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4644
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4645
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4646
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4652
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4653
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4654
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5058
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5059
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5060
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5063
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5064
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5065
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5066
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5223
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5224
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5225
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5227
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5583
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5584
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5586
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5588
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5890
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5891
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5892
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5893
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5898
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6280
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6281
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6282
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6285
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6287
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6431
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6432
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6434
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6435
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6437
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6609
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6610
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6611
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6613
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6618
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6971
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6972
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6973
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6975
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6980
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7113
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7114
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7115
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7117
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7122
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7306
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7307
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7308
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7310
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7315
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7457
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7458
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7459
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7466
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7471
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7752
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7754
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7755
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7756
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7758
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7763
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7956
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7957
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7958
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7960
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7961
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7962
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7967
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8093
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8094
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8095
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8096
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8097
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8098
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8105
BEGIN                                  7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8107
__ANON__                             157 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4419
__ANON__                             588 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8445
__ANON__                             170 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:845 
__ANON__                             346 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8533
__ANON__                               2 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8561
__ANON__                              11 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8595
__ANON__                             360 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8629
__ANON__                               2 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8722
__ANON__                             368 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8828
__ANON__                               8 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8843
__ANON__                             495 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8897
__ANON__                             822 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8899
__ANON__                              54 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8958
__ANON__                              11 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:9297
__delete_to_select                     1 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1859
__distill_tables                     111 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1754
__update_to_select                    14 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1890
_delete_buff                          38 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3592
_get_participants                     54 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:745 
_make_event                           38 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3054
_packet_from_client                   38 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2932
_packet_from_server                   35 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2712
_parse_packet                        101 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2263
_parse_specs                          54 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:631 
_pod_to_specs                         54 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:525 
_read_config_file                    216 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1198
_set_option                          170 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:791 
_validate_type                      3402 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:940 
add_line                              34 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4526
add_new_attributes                   366 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4385
aggregate                            368 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3945
aggregate                              8 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5089
bucket_idx                          5093 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4194
bucket_value                        7000 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4201
buckets_of                           106 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4210
calculate_statistical_metrics        646 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4233
chart_distro                         106 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4893
check_orderby_attrib                  62 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:9627
clean_query                            5 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5409
convert_to_select                     55 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1808
decode_len                             5 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3139
detect_compression                    10 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3469
disconnect                             5 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:338 
distill                              115 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1775
distill_verbs                        120 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1699
event_report                         106 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4793
events_processed                       7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4411
extract_tables                       121 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:9475
find_role                              2 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:9540
fingerprint                          346 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1657
format_bool_attrib                    18 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4954
format_string_list                   252 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4961
get                                 4379 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1007
get_attributes                        54 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4406
get_cxn                                3 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:9680
get_cxn_params                         7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:199 
get_dbh                                7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:233 
get_defaults                          55 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:781 
get_defaults_files                    54 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:520 
get_opts                              54 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:808 
get_report                            12 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4560
get_specs                             54 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:513 
get_sth_id                             3 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3427
get_tables                           239 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5252
global_report                          7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4713
got                                  271 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1015
has                                   99 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1023
has_derived_table                      3 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5309
main                                  54 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8123
make_alt_attrib                      718 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4416
make_alt_attrib                       54 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:9583
make_checksum                        210 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1541
make_handler                        1153 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4059
make_handler                           1 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5105
make_header                          113 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4926
make_inherit_attribs                  54 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:9609
make_label                          1000 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4937
micro_t                             1295 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1362
new                                    7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1594
new                                   12 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2226
new                                   12 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2531
new                                   39 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3624
new                                   55 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3893
new                                    7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:398 
new                                   12 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4469
new                                   54 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4668
new                                    9 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:47  
new                                   54 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:476 
new                                    1 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5069
new                                    7 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5247
new                                    2 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7125
new                                    1 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7318
parse                                 12 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:109 
parse_client_handshake_packet          2 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3298
parse_com_packet                      46 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3331
parse_error_packet                     1 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3207
parse_event                          113 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2232
parse_event                          101 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2546
parse_event                          349 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3644
parse_event                           17 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7138
parse_event                            8 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7339
parse_execute_packet                  12 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3358
parse_flags                            4 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3434
parse_ok_prepared_statement_packet    10 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3253
parse_options                          5 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:160 
parse_server_handshake_packet          2 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3273
parse_timestamp                      250 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1479
percentage_of                        722 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1392
port_number                          202 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2314
print_explain                         26 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:9504
print_tables                          97 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:9490
prop                                  80 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:100 
query_type                             5 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5486
quote                                 73 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:403 
remove_mysql_header                   73 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3536
report                                 1 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5178
reset_aggregated_data                 55 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3931
reset_aggregated_data                  1 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5084
results                              478 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4040
results                                1 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5100
set                                   54 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1029
set_columns                           12 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4501
set_title                             10 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4495
shorten                             3485 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1446
shorten                               96 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1611
sort_attribs                         113 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4998
split                                  5 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5381
split_unquote                         91 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:427 
strip_comments                       115 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1600
tcp_timestamp                         38 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3102
timestamp_diff                        38 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3108
to_num                               351 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3172
to_string                             39 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3124
top_events                            55 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4347
type_for                            2950 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4054
unix_timestamp                        38 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1491
unpack_string                          5 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3129
usage_or_errors                       54 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1065

Uncovered Subroutines
---------------------

Subroutine                         Count Location                                                     
---------------------------------- ----- -------------------------------------------------------------
DESTROY                                0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6585
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8355
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8401
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8474
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8484
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8509
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8587
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8647
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8664
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8681
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8694
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8853
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8894
__ANON__                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:9657
__insert_to_select                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1867
__insert_to_select_with_set            0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1884
__shorten                              0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1645
_column_error                          0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4617
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1313
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1548
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1905
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2197
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2323
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3598
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:373 
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3777
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3859
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4435
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4624
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5037
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5205
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5565
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5872
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6260
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6413
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6591
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6936
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7095
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7288
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7439
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7735
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7938
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8070
_d                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:9698
_find_match_Command                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2185
_find_match_Host                       0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2167
_find_match_Id                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2156
_find_match_Info                       0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2191
_find_match_State                      0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2179
_find_match_User                       0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2161
_find_match_db                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2173
_get_errors_fh                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3553
_get_errors_fh                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6899
_get_errors_fh                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7659
_get_rows                              0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2088
_get_session                           0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7591
_make_PID_file                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6550
_make_unrolled_loops                   0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4000
_packet_from_client                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6786
_packet_from_client                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7638
_packet_from_client                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7860
_packet_from_server                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6701
_packet_from_server                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7634
_packet_from_server                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7775
_parse_header                          0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7906
_parse_packet                          0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7533
_remove_PID_file                       0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6572
_save_rate_avg                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8061
_time_to_check                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8042
_truncate                              0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4610
_use_db                                0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5679
any_unix_timestamp                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1506
as_string                              0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:173 
attributes                             0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4049
check_PID_file                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6509
check_table                            0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6049
clone                                  0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1251
convert_select_list                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1850
copy                                   0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:355 
daemonize                              0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6458
descr                                  0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1053
dump                                   0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5622
errors                                 0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1043
fail_session                           0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3570
fail_session                           0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6916
fail_session                           0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7676
fill_in_dsn                            0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:221 
find                                   0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2095
find_best_index                        0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6003
find_possible_keys                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6021
fingerprint                            0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7051
get_aliases                            0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5316
get_columns                            0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5504
get_columns                            0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5736
get_create_table                       0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5698
get_databases                          0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5801
get_engine                             0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6114
get_fks                                0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6188
get_groups                             0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:786 
get_hostname                           0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:328 
get_keys                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6121
get_lcb                                0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3190
get_review_info                        0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6389
get_table_list                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5846
get_table_status                       0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5820
get_tmp_table                          0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5756
get_triggers                           0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5767
handle_delete                          0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7085
handle_incr_decr_cmd                   0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7090
handle_retr_cmd                        0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7071
handle_storage_cmd                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7057
header                                 0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4692
literal_like                           0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:438 
make_PID_file                          0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6540
make_event                             0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:2067
make_event                             0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6881
make_event                             0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7642
metrics                                0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:4323
new                                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1948
new                                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3802
new                                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5615
new                                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5902
new                                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6295
new                                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6440
new                                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6621
new                                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7008
new                                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7474
new                                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7766
new                                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7970
opts                                   0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:757 
parse                                  0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5546
parse                                  0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5913
parse_event                            0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1959
parse_event                            0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6633
parse_event                            0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7014
parse_event                            0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7487
parse_ok_packet                        0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3229
parse_section                          0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1274
print_active_handles                   0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:344 
print_errors                           0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1078
print_usage                            0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1088
prompt                                 0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1048
prompt_noecho                          0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1163
quote_val                              0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:411 
rate_avg                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8051
read_para_after                        0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1232
read_timeout                           0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:9648
remove_auto_increment                  0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6217
remove_secondary_indexes               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6223
review_cols                            0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6408
save_error                             0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1038
secs_to_time                           0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1399
set_defaults                           0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:769 
set_history_options                    0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6345
set_review_history                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6377
set_review_info                        0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6399
short_opts                             0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:763 
sig_int                                0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:9571
skip_probability                       0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:8056
sort_indexes                           0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5984
split_subquery                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:5419
throttle                               0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7992
time_to_secs                           0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1426
timestamp_diff                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:6944
timestamp_diff                         0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7696
to_double                              0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3185
ts                                     0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1463
uncompress_data                        0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3447
uncompress_data                        0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:7713
uncompress_packet                      0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3488
usage                                  0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:182 
wrap_in_derived                        0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:1897
write                                  0 /home/daniel/dev/maatkit/mk-query-digest/mk-query-digest:3807


