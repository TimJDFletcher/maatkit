---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...logger/mk-fk-error-logger   43.9   28.4   32.1   56.2    n/a  100.0   39.0
Total                          43.9   28.4   32.1   56.2    n/a  100.0   39.0
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          mk-fk-error-logger.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Wed Jul 29 17:49:27 2009
Finish:       Wed Jul 29 17:49:30 2009

/home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This is mk-deadlock-logger, a program that extracts and saves a summary of
4                                                     # the last deadlock recorded in MySQL.
5                                                     #
6                                                     # This program is copyright 2007-@CURRENTYEAR@ Percona Inc.
7                                                     # Feedback and improvements are welcome.
8                                                     #
9                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
10                                                    # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
11                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
12                                                    #
13                                                    # This program is free software; you can redistribute it and/or modify it under
14                                                    # the terms of the GNU General Public License as published by the Free Software
15                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
16                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
17                                                    # licenses.
18                                                    #
19                                                    # You should have received a copy of the GNU General Public License along with
20                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
21                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
22                                                    
23             1                    1             8   use strict;
               1                                  3   
               1                                 10   
24             1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                111   
25                                                    
26                                                    our $VERSION = '@VERSION@';
27                                                    our $DISTRIB = '@DISTRIB@';
28                                                    our $SVN_REV = sprintf("%d", (q$Revision: 4247 $ =~ m/(\d+)/g, 0));
29                                                    
30                                                    # ###########################################################################
31                                                    # OptionParser package 4245
32                                                    # ###########################################################################
33                                                    package OptionParser;
34                                                    
35             1                    1             6   use strict;
               1                                  2   
               1                                  4   
36             1                    1             5   use warnings FATAL => 'all';
               1                                  7   
               1                                  4   
37                                                    
38             1                    1            10   use Getopt::Long;
               1                                  4   
               1                                  7   
39             1                    1             7   use List::Util qw(max);
               1                                  3   
               1                                 11   
40             1                    1             7   use English qw(-no_match_vars);
               1                                  2   
               1                                  9   
41                                                    
42             1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  8   
43                                                    
44                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
45                                                    
46                                                    my %attributes = (
47                                                       'type'       => 1,
48                                                       'short form' => 1,
49                                                       'group'      => 1,
50                                                       'default'    => 1,
51                                                       'cumulative' => 1,
52                                                       'negatable'  => 1,
53                                                    );
54                                                    
55                                                    sub new {
56             4                    4            46      my ( $class, %args ) = @_;
57             4                                 19      foreach my $arg ( qw(description) ) {
58    ***      4     50                          30         die "I need a $arg argument" unless $args{$arg};
59                                                       }
60             4                                 54      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
61    ***      4            50                   17      $program_name ||= $PROGRAM_NAME;
62    ***      4            33                   38      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                   33                        
      ***                   50                        
63                                                    
64    ***      4     50     50                  148      my $self = {
      ***                   50                        
65                                                          description    => $args{description},
66                                                          prompt         => $args{prompt} || '<options>',
67                                                          strict         => (exists $args{strict} ? $args{strict} : 1),
68                                                          dp             => $args{dp}     || undef,
69                                                          program_name   => $program_name,
70                                                          opts           => {},
71                                                          got_opts       => 0,
72                                                          short_opts     => {},
73                                                          defaults       => {},
74                                                          groups         => {},
75                                                          allowed_groups => {},
76                                                          errors         => [],
77                                                          rules          => [],  # desc of rules for --help
78                                                          mutex          => [],  # rule: opts are mutually exclusive
79                                                          atleast1       => [],  # rule: at least one opt is required
80                                                          disables       => {},  # rule: opt disables other opts 
81                                                          defaults_to    => {},  # rule: opt defaults to value of other opt
82                                                          default_files  => [
83                                                             "/etc/maatkit/maatkit.conf",
84                                                             "/etc/maatkit/$program_name.conf",
85                                                             "$home/.maatkit.conf",
86                                                             "$home/.$program_name.conf",
87                                                          ],
88                                                       };
89             4                                 45      return bless $self, $class;
90                                                    }
91                                                    
92                                                    sub get_specs {
93             4                    4            15      my ( $self, $file ) = @_;
94             4                                 24      my @specs = $self->_pod_to_specs($file);
95             4                                 62      $self->_parse_specs(@specs);
96             4                                 13      return;
97                                                    }
98                                                    
99                                                    sub get_defaults_files {
100            4                    4            13      my ( $self ) = @_;
101            4                                 11      return @{$self->{default_files}};
               4                                 37   
102                                                   }
103                                                   
104                                                   sub _pod_to_specs {
105            4                    4            16      my ( $self, $file ) = @_;
106   ***      4            50                   21      $file ||= __FILE__;
107   ***      4     50                         121      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
108                                                   
109            4                                 63      my %types = (
110                                                         string => 's', # standard Getopt type
111                                                         'int'  => 'i', # standard Getopt type
112                                                         float  => 'f', # standard Getopt type
113                                                         Hash   => 'H', # hash, formed from a comma-separated list
114                                                         hash   => 'h', # hash as above, but only if a value is given
115                                                         Array  => 'A', # array, similar to Hash
116                                                         array  => 'a', # array, similar to hash
117                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
118                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
119                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
120                                                      );
121            4                                 13      my @specs = ();
122            4                                 11      my @rules = ();
123            4                                 10      my $para;
124                                                   
125            4                                 26      local $INPUT_RECORD_SEPARATOR = '';
126            4                                 97      while ( $para = <$fh> ) {
127         1020    100                        6325         next unless $para =~ m/^=head1 OPTIONS/;
128            4                                 13         last;
129                                                      }
130                                                   
131            4                                103      while ( $para = <$fh> ) {
132   ***      4     50                          22         last if $para =~ m/^=over/;
133   ***      0                                  0         chomp $para;
134   ***      0                                  0         $para =~ s/\s+/ /g;
135   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
136   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
137   ***      0                                  0         push @rules, $para;
138                                                      }
139                                                   
140   ***      4     50                          17      die 'POD has no OPTIONS section' unless $para;
141                                                   
142            4                                 11      do {
143           80    100                         498         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
144           76                                202            chomp $para;
145           76                                158            MKDEBUG && _d($para);
146           76                                168            my %attribs;
147                                                   
148           76                                274            $para = <$fh>; # read next paragraph, possibly attributes
149                                                   
150           76    100                         275            if ( $para =~ m/: / ) { # attributes
151           56                                254               $para =~ s/\s+\Z//g;
152           92                                417               %attribs = map {
153           56                                257                     my ( $attrib, $val) = split(/: /, $_);
154   ***     92     50                         373                     die "Unrecognized attribute for --$option: $attrib"
155                                                                        unless $attributes{$attrib};
156           92                                439                     ($attrib, $val);
157                                                                  } split(/; /, $para);
158           56    100                         248               if ( $attribs{'short form'} ) {
159           28                                123                  $attribs{'short form'} =~ s/-//;
160                                                               }
161           56                                255               $para = <$fh>; # read next paragraph, probably short help desc
162                                                            }
163                                                            else {
164           20                                 50               MKDEBUG && _d('Option has no attributes');
165                                                            }
166                                                   
167           76                                489            $para =~ s/\s+\Z//g;
168           76                                491            $para =~ s/\s+/ /g;
169           76                                308            $para =~ s/$POD_link_re/$1/go;
170                                                   
171           76                                278            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
172           76                                161            MKDEBUG && _d('Short help:', $para);
173                                                   
174   ***     76     50                         288            die "No description after option spec $option" if $para =~ m/^=item/;
175                                                   
176   ***     76     50                         316            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
177   ***      0                                  0               $option = $base_option;
178   ***      0                                  0               $attribs{'negatable'} = 1;
179                                                            }
180                                                   
181           76    100                        1182            push @specs, {
      ***            50                               
      ***            50                               
                    100                               
                    100                               
      ***            50                               
182                                                               spec  => $option
183                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
184                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
185                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
186                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
187                                                               desc  => $para
188                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
189                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
190                                                            };
191                                                         }
192           80                                436         while ( $para = <$fh> ) {
193   ***    100     50                         393            last unless $para;
194                                                   
195                                                   
196          100    100                         373            if ( $para =~ m/^=head1/ ) {
197            4                                 13               $para = undef; # Can't 'last' out of a do {} block.
198            4                                 23               last;
199                                                            }
200           96    100                         583            last if $para =~ m/^=item --/;
201                                                         }
202                                                      } while ( $para );
203                                                   
204   ***      4     50                          15      die 'No valid specs in POD OPTIONS' unless @specs;
205                                                   
206            4                                 43      close $fh;
207            4                                 13      return @specs, @rules;
208                                                   }
209                                                   
210                                                   sub _parse_specs {
211            4                    4            25      my ( $self, @specs ) = @_;
212            4                                 13      my %disables; # special rule that requires deferred checking
213                                                   
214            4                                 16      foreach my $opt ( @specs ) {
215   ***     76     50                         252         if ( ref $opt ) { # It's an option spec, not a rule.
216                                                            MKDEBUG && _d('Parsing opt spec:',
217           76                                154               map { ($_, '=>', $opt->{$_}) } keys %$opt);
218                                                   
219           76                                481            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
220   ***     76     50                         300            if ( !$long ) {
221   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
222                                                            }
223           76                                255            $opt->{long} = $long;
224                                                   
225   ***     76     50                         325            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
226           76                                321            $self->{opts}->{$long} = $opt;
227                                                   
228   ***     76     50                         277            if ( length $long == 1 ) {
229   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
230   ***      0                                  0               $self->{short_opts}->{$long} = $long;
231                                                            }
232                                                   
233           76    100                         231            if ( $short ) {
234   ***     28     50                         117               die "Duplicate short option -$short"
235                                                                  if exists $self->{short_opts}->{$short};
236           28                                106               $self->{short_opts}->{$short} = $long;
237           28                                 91               $opt->{short} = $short;
238                                                            }
239                                                            else {
240           48                                157               $opt->{short} = undef;
241                                                            }
242                                                   
243   ***     76     50                         374            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
244   ***     76     50                         356            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
245   ***     76     50                         390            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
246                                                   
247   ***     76            50                  286            $opt->{group} ||= 'default';
248           76                                344            $self->{groups}->{ $opt->{group} }->{$long} = 1;
249                                                   
250           76                                225            $opt->{value} = undef;
251           76                                233            $opt->{got}   = 0;
252                                                   
253           76                                371            my ( $type ) = $opt->{spec} =~ m/=(.)/;
254           76                                256            $opt->{type} = $type;
255           76                                160            MKDEBUG && _d($long, 'type:', $type);
256                                                   
257   ***     76     50    100                  619            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                   66                        
258   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
259                                                                  . "was given when this OptionParser object was created";
260                                                            }
261                                                   
262           76    100    100                  576            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
263                                                   
264           76    100                         392            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
265   ***      4     50                          18               if ( $opt->{is_negatable} ) {
266   ***      0      0                           0                  $def = $def eq 'yes' ? 1
      ***             0                               
267                                                                       : $def eq 'no'  ? 0
268                                                                       : $def;
269                                                               }
270   ***      4     50                          21               $self->{defaults}->{$long} = defined $def ? $def : 1;
271            4                                  8               MKDEBUG && _d($long, 'default:', $def);
272                                                            }
273                                                   
274           76    100                         279            if ( $long eq 'config' ) {
275            4                                 22               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
276                                                            }
277                                                   
278   ***     76     50                         355            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
279   ***      0                                  0               $disables{$long} = $dis;
280   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
281                                                            }
282                                                   
283           76                                349            $self->{opts}->{$long} = $opt;
284                                                         }
285                                                         else { # It's an option rule, not a spec.
286   ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
287   ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
288   ***      0                                  0            my @participants = $self->_get_participants($opt);
289   ***      0                                  0            my $rule_ok = 0;
290                                                   
291   ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
292   ***      0                                  0               $rule_ok = 1;
293   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
294   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
295                                                            }
296   ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
297   ***      0                                  0               $rule_ok = 1;
298   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
299   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
300                                                            }
301   ***      0      0                           0            if ( $opt =~ m/default to/ ) {
302   ***      0                                  0               $rule_ok = 1;
303   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
304   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
305                                                            }
306   ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
307   ***      0                                  0               $rule_ok = 1;
308   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
309   ***      0                                  0               my @groups = split(',', $groups);
310   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
311   ***      0                                  0                  s/\s+//;
312   ***      0                                  0                  $_ => 1;
313                                                               } @groups;
314                                                            }
315                                                   
316   ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
317                                                         }
318                                                      }
319                                                   
320            4                                 24      foreach my $long ( keys %disables ) {
321   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
322   ***      0                                  0         $self->{disables}->{$long} = \@participants;
323   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
324                                                      }
325                                                   
326            4                                 18      return; 
327                                                   }
328                                                   
329                                                   sub _get_participants {
330   ***      0                    0             0      my ( $self, $str ) = @_;
331   ***      0                                  0      my @participants;
332   ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
333   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
334                                                            unless exists $self->{opts}->{$long};
335   ***      0                                  0         push @participants, $long;
336                                                      }
337   ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
338   ***      0                                  0      return @participants;
339                                                   }
340                                                   
341                                                   sub opts {
342   ***      0                    0             0      my ( $self ) = @_;
343   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
344   ***      0                                  0      return %opts;
345                                                   }
346                                                   
347                                                   sub opt_values {
348   ***      0                    0             0      my ( $self ) = @_;
349   ***      0      0                           0      my %opts = map {
350   ***      0                                  0         my $opt = $self->{opts}->{$_}->{short} ? $self->{opts}->{$_}->{short}
351                                                                 : $_;
352   ***      0                                  0         $opt => $self->{opts}->{$_}->{value}
353   ***      0                                  0      } keys %{$self->{opts}};
354   ***      0                                  0      return %opts;
355                                                   }
356                                                   
357                                                   sub short_opts {
358   ***      0                    0             0      my ( $self ) = @_;
359   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
360   ***      0                                  0      return %short_opts;
361                                                   }
362                                                   
363                                                   sub set_defaults {
364   ***      0                    0             0      my ( $self, %defaults ) = @_;
365   ***      0                                  0      $self->{defaults} = {};
366   ***      0                                  0      foreach my $long ( keys %defaults ) {
367   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
368                                                            unless exists $self->{opts}->{$long};
369   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
370   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
371                                                      }
372   ***      0                                  0      return;
373                                                   }
374                                                   
375                                                   sub get_defaults {
376   ***      0                    0             0      my ( $self ) = @_;
377   ***      0                                  0      return $self->{defaults};
378                                                   }
379                                                   
380                                                   sub get_groups {
381   ***      0                    0             0      my ( $self ) = @_;
382   ***      0                                  0      return $self->{groups};
383                                                   }
384                                                   
385                                                   sub _set_option {
386            3                    3            15      my ( $self, $opt, $val ) = @_;
387   ***      3      0                           7      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
388                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
389                                                               : die "Getopt::Long gave a nonexistent option: $opt";
390                                                   
391            3                                  7      $opt = $self->{opts}->{$long};
392   ***      3     50                          16      if ( $opt->{is_cumulative} ) {
393   ***      0                                  0         $opt->{value}++;
394                                                      }
395                                                      else {
396            3                                 15         $opt->{value} = $val;
397                                                      }
398            3                                 10      $opt->{got} = 1;
399            3                                 12      MKDEBUG && _d('Got option', $long, '=', $val);
400                                                   }
401                                                   
402                                                   sub get_opts {
403            4                    4            14      my ( $self ) = @_; 
404                                                   
405            4                                 12      foreach my $long ( keys %{$self->{opts}} ) {
               4                                 35   
406           76                                287         $self->{opts}->{$long}->{got} = 0;
407   ***     76     50                         567         $self->{opts}->{$long}->{value}
                    100                               
408                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
409                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
410                                                            : undef;
411                                                      }
412            4                                 18      $self->{got_opts} = 0;
413                                                   
414            4                                 16      $self->{errors} = [];
415                                                   
416   ***      4     50     33                   47      if ( @ARGV && $ARGV[0] eq "--config" ) {
417   ***      0                                  0         shift @ARGV;
418   ***      0                                  0         $self->_set_option('config', shift @ARGV);
419                                                      }
420   ***      4     50                          27      if ( $self->has('config') ) {
421            4                                 12         my @extra_args;
422            4                                 27         foreach my $filename ( split(',', $self->get('config')) ) {
423           16                                 51            eval {
424           16                                 75               push @ARGV, $self->_read_config_file($filename);
425                                                            };
426   ***     16     50                          75            if ( $EVAL_ERROR ) {
427   ***     16     50                          63               if ( $self->got('config') ) {
428   ***      0                                  0                  die $EVAL_ERROR;
429                                                               }
430                                                               elsif ( MKDEBUG ) {
431                                                                  _d($EVAL_ERROR);
432                                                               }
433                                                            }
434                                                         }
435            4                                 23         unshift @ARGV, @extra_args;
436                                                      }
437                                                   
438            4                                 32      Getopt::Long::Configure('no_ignore_case', 'bundling');
439                                                      GetOptions(
440           72                    3           440         map    { $_->{spec} => sub { $self->_set_option(@_); } }
               3                                 22   
              76                                279   
441            4                                 23         grep   { $_->{long} ne 'config' } # --config is handled specially above.
442   ***      4     50                          14         values %{$self->{opts}}
443                                                      ) or $self->save_error('Error parsing options');
444                                                   
445   ***      4     50     33                  153      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
446   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
447                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
448                                                               or die "Cannot print: $OS_ERROR";
449   ***      0                                  0         exit 0;
450                                                      }
451                                                   
452   ***      4     50     33                   36      if ( @ARGV && $self->{strict} ) {
453   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
454                                                      }
455                                                   
456            4                                 12      foreach my $mutex ( @{$self->{mutex}} ) {
               4                                 25   
457   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
458   ***      0      0                           0         if ( @set > 1 ) {
459   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
460   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
461                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
462                                                                    . ' are mutually exclusive.';
463   ***      0                                  0            $self->save_error($err);
464                                                         }
465                                                      }
466                                                   
467            4                                 11      foreach my $required ( @{$self->{atleast1}} ) {
               4                                 21   
468   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
469   ***      0      0                           0         if ( @set == 0 ) {
470   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
471   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
472                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
473   ***      0                                  0            $self->save_error("Specify at least one of $err");
474                                                         }
475                                                      }
476                                                   
477            4                                 11      foreach my $long ( keys %{$self->{opts}} ) {
               4                                 32   
478           76                                273         my $opt = $self->{opts}->{$long};
479           76    100                         398         if ( $opt->{got} ) {
      ***            50                               
480   ***      3     50                          16            if ( exists $self->{disables}->{$long} ) {
481   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
482   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
483   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
484                                                                  'because', $long,'disables them');
485                                                            }
486                                                   
487   ***      3     50                          20            if ( exists $self->{allowed_groups}->{$long} ) {
488                                                   
489   ***      0                                  0               my @restricted_groups = grep {
490   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
491   ***      0                                  0               } keys %{$self->{groups}};
492                                                   
493   ***      0                                  0               my @restricted_opts;
494   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
495   ***      0                                  0                  RESTRICTED_OPT:
496   ***      0                                  0                  foreach my $restricted_opt (
497                                                                     keys %{$self->{groups}->{$restricted_group}} )
498                                                                  {
499   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
500   ***      0      0                           0                     push @restricted_opts, $restricted_opt
501                                                                        if $self->{opts}->{$restricted_opt}->{got};
502                                                                  }
503                                                               }
504                                                   
505   ***      0      0                           0               if ( @restricted_opts ) {
506   ***      0                                  0                  my $err;
507   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
508   ***      0                                  0                     $err = "--$restricted_opts[0]";
509                                                                  }
510                                                                  else {
511   ***      0                                  0                     $err = join(', ',
512   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
513   ***      0                                  0                               grep { $_ } 
514                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
515                                                                            )
516                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
517                                                                  }
518   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
519                                                               }
520                                                            }
521                                                   
522                                                         }
523                                                         elsif ( $opt->{is_required} ) { 
524   ***      0                                  0            $self->save_error("Required option --$long must be specified");
525                                                         }
526                                                   
527           76                                283         $self->_validate_type($opt);
528                                                      }
529                                                   
530            4                                 22      $self->{got_opts} = 1;
531            4                                 13      return;
532                                                   }
533                                                   
534                                                   sub _validate_type {
535           76                   76           261      my ( $self, $opt ) = @_;
536   ***     76    100     66                  647      return unless $opt && $opt->{type};
537           56                                171      my $val = $opt->{value};
538                                                   
539   ***     56     50     66                 1210      if ( $val && $opt->{type} eq 'm' ) {
                    100    100                        
      ***            50     66                        
      ***            50     66                        
      ***           100     33                        
      ***                   66                        
      ***                   66                        
540   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
541   ***      0                                  0         my ( $num, $suffix ) = $val =~ m/(\d+)([a-z])?$/;
542   ***      0      0                           0         if ( !$suffix ) {
543   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
544   ***      0             0                    0            $suffix = $s || 's';
545   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
546                                                               $opt->{long}, '(value:', $val, ')');
547                                                         }
548   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
549   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
550                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
551                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
552                                                                 :                  $num * 86400;   # Days
553   ***      0                                  0            $opt->{value} = $val;
554   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
555                                                         }
556                                                         else {
557   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
558                                                         }
559                                                      }
560                                                      elsif ( $val && $opt->{type} eq 'd' ) {
561            3                                  7         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
562            3                                 15         my $from_key = $self->{defaults_to}->{ $opt->{long} };
563            3                                 11         my $default = {};
564   ***      3     50                          21         if ( $from_key ) {
565   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
566   ***      0                                  0            $default = $self->{dp}->parse(
567                                                               $self->{dp}->as_string($self->{opts}->{$from_key}->{value}) );
568                                                         }
569            3                                 26         $opt->{value} = $self->{dp}->parse($val, $default);
570                                                      }
571                                                      elsif ( $val && $opt->{type} eq 'z' ) {
572   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
573   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
574   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
575   ***      0      0                           0         if ( defined $num ) {
576   ***      0      0                           0            if ( $factor ) {
577   ***      0                                  0               $num *= $factor_for{$factor};
578   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
579                                                                  'to num', $num, '* factor', $factor);
580                                                            }
581   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
582                                                         }
583                                                         else {
584   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
585                                                         }
586                                                      }
587                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
588   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
589                                                      }
590                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
591   ***      4            50                   61         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
592                                                      }
593                                                      else {
594           49                                113         MKDEBUG && _d('Nothing to validate for option',
595                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
596                                                      }
597                                                   
598           56                                190      return;
599                                                   }
600                                                   
601                                                   sub get {
602           63                   63           243      my ( $self, $opt ) = @_;
603           63    100                         309      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
604   ***     63     50     33                  600      die "Option $opt does not exist"
605                                                         unless $long && exists $self->{opts}->{$long};
606           63                                479      return $self->{opts}->{$long}->{value};
607                                                   }
608                                                   
609                                                   sub got {
610           20                   20            87      my ( $self, $opt ) = @_;
611   ***     20     50                          86      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
612   ***     20     50     33                  188      die "Option $opt does not exist"
613                                                         unless $long && exists $self->{opts}->{$long};
614           20                                148      return $self->{opts}->{$long}->{got};
615                                                   }
616                                                   
617                                                   sub has {
618           40                   40           154      my ( $self, $opt ) = @_;
619           40    100                         225      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
620           40    100                         317      return defined $long ? exists $self->{opts}->{$long} : 0;
621                                                   }
622                                                   
623                                                   sub set {
624   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
625   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
626   ***      0      0      0                    0      die "Option $opt does not exist"
627                                                         unless $long && exists $self->{opts}->{$long};
628   ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
629   ***      0                                  0      return;
630                                                   }
631                                                   
632                                                   sub save_error {
633   ***      0                    0             0      my ( $self, $error ) = @_;
634   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
635                                                   }
636                                                   
637                                                   sub errors {
638   ***      0                    0             0      my ( $self ) = @_;
639   ***      0                                  0      return $self->{errors};
640                                                   }
641                                                   
642                                                   sub prompt {
643   ***      0                    0             0      my ( $self ) = @_;
644   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
645                                                   }
646                                                   
647                                                   sub descr {
648   ***      0                    0             0      my ( $self ) = @_;
649   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
650                                                                 . "  For more details, please use the --help option, "
651                                                                 . "or try 'perldoc $PROGRAM_NAME' "
652                                                                 . "for complete documentation.";
653   ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
654   ***      0                                  0      $descr =~ s/ +$//mg;
655   ***      0                                  0      return $descr;
656                                                   }
657                                                   
658                                                   sub usage_or_errors {
659            4                    4            16      my ( $self ) = @_;
660   ***      4     50                          24      if ( $self->{opts}->{help}->{got} ) {
      ***      4     50                          21   
661   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
662   ***      0                                  0         exit 0;
663                                                      }
664                                                      elsif ( scalar @{$self->{errors}} ) {
665   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
666   ***      0                                  0         exit 0;
667                                                      }
668            4                                 11      return;
669                                                   }
670                                                   
671                                                   sub print_errors {
672   ***      0                    0             0      my ( $self ) = @_;
673   ***      0                                  0      my $usage = $self->prompt() . "\n";
674   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
675   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
676                                                                 . "\n";
677                                                      }
678   ***      0                                  0      return $usage . "\n" . $self->descr();
679                                                   }
680                                                   
681                                                   sub print_usage {
682   ***      0                    0             0      my ( $self ) = @_;
683   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
684   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
685                                                   
686   ***      0      0                           0      my $maxl = max(
687   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
688                                                         @opts);
689                                                   
690   ***      0      0                           0      my $maxs = max(0,
691   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
692   ***      0                                  0         values %{$self->{short_opts}});
693                                                   
694   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
695   ***      0                                  0      my $rcol = 80 - $lcol - 6;
696   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
697                                                   
698   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
699                                                   
700   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
701                                                   
702   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
703   ***      0                                  0      push @groups, 'default';
704                                                   
705   ***      0                                  0      foreach my $group ( reverse @groups ) {
706   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
707   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
708   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
709                                                            grep { $_->{group} eq $group }
710                                                            @opts )
711                                                         {
712   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
713   ***      0                                  0            my $short = $opt->{short};
714   ***      0                                  0            my $desc  = $opt->{desc};
715   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
716   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
717   ***      0             0                    0               $s    ||= 's';
718   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
719   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
720                                                                      . "d=days; if no suffix, $s is used.";
721                                                            }
722   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
723   ***      0                                  0            $desc =~ s/ +$//mg;
724   ***      0      0                           0            if ( $short ) {
725   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
726                                                            }
727                                                            else {
728   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
729                                                            }
730                                                         }
731                                                      }
732                                                   
733   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
734   ***      0                                  0         $usage .= "\nRules:\n\n";
735   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
736                                                      }
737   ***      0      0                           0      if ( $self->{dp} ) {
738   ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
739                                                      }
740   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
741   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
742   ***      0                                  0         my $val   = $opt->{value};
743   ***      0             0                    0         my $type  = $opt->{type} || '';
744   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
745   ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
746                                                                   : !defined $val             ? '(No value)'
747                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
748                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
749                                                                   : $type =~ m/A|a/           ? join(',', @$val)
750                                                                   :                             $val;
751   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
752                                                      }
753   ***      0                                  0      return $usage;
754                                                   }
755                                                   
756                                                   sub prompt_noecho {
757   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
758   ***      0                                  0      my ( $prompt ) = @_;
759   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
760   ***      0      0                           0      print $prompt
761                                                         or die "Cannot print: $OS_ERROR";
762   ***      0                                  0      my $response;
763   ***      0                                  0      eval {
764   ***      0                                  0         require Term::ReadKey;
765   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
766   ***      0                                  0         chomp($response = <STDIN>);
767   ***      0                                  0         Term::ReadKey::ReadMode('normal');
768   ***      0      0                           0         print "\n"
769                                                            or die "Cannot print: $OS_ERROR";
770                                                      };
771   ***      0      0                           0      if ( $EVAL_ERROR ) {
772   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
773                                                      }
774   ***      0                                  0      return $response;
775                                                   }
776                                                   
777                                                   if ( MKDEBUG ) {
778                                                      print '# ', $^X, ' ', $], "\n";
779                                                      my $uname = `uname -a`;
780                                                      if ( $uname ) {
781                                                         $uname =~ s/\s+/ /g;
782                                                         print "# $uname\n";
783                                                      }
784                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
785                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
786                                                         ($main::SVN_REV || ''), __LINE__);
787                                                      print('# Arguments: ',
788                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
789                                                   }
790                                                   
791                                                   sub _read_config_file {
792           16                   16            66      my ( $self, $filename ) = @_;
793   ***     16     50                          39      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
794   ***      0                                  0      my @args;
795   ***      0                                  0      my $prefix = '--';
796   ***      0                                  0      my $parse  = 1;
797                                                   
798                                                      LINE:
799   ***      0                                  0      while ( my $line = <$fh> ) {
800   ***      0                                  0         chomp $line;
801   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
802   ***      0                                  0         $line =~ s/\s+#.*$//g;
803   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
804   ***      0      0                           0         if ( $line eq '--' ) {
805   ***      0                                  0            $prefix = '';
806   ***      0                                  0            $parse  = 0;
807   ***      0                                  0            next LINE;
808                                                         }
809   ***      0      0      0                    0         if ( $parse
      ***             0                               
810                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
811                                                         ) {
812   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
813                                                         }
814                                                         elsif ( $line =~ m/./ ) {
815   ***      0                                  0            push @args, $line;
816                                                         }
817                                                         else {
818   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
819                                                         }
820                                                      }
821   ***      0                                  0      close $fh;
822   ***      0                                  0      return @args;
823                                                   }
824                                                   
825                                                   sub read_para_after {
826   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
827   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
828   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
829   ***      0                                  0      my $para;
830   ***      0                                  0      while ( $para = <$fh> ) {
831   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
832   ***      0                                  0         last;
833                                                      }
834   ***      0                                  0      while ( $para = <$fh> ) {
835   ***      0      0                           0         next unless $para =~ m/$regex/;
836   ***      0                                  0         last;
837                                                      }
838   ***      0                                  0      $para = <$fh>;
839   ***      0                                  0      chomp($para);
840   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
841   ***      0                                  0      return $para;
842                                                   }
843                                                   
844                                                   sub clone {
845   ***      0                    0             0      my ( $self ) = @_;
846                                                   
847   ***      0                                  0      my %clone = map {
848   ***      0                                  0         my $hashref  = $self->{$_};
849   ***      0                                  0         my $val_copy = {};
850   ***      0                                  0         foreach my $key ( keys %$hashref ) {
851   ***      0                                  0            my $ref = ref $hashref->{$key};
852   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
853   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
854   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
855                                                                              : $hashref->{$key};
856                                                         }
857   ***      0                                  0         $_ => $val_copy;
858                                                      } qw(opts short_opts defaults);
859                                                   
860   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
861   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
862                                                      }
863                                                   
864   ***      0                                  0      return bless \%clone;     
865                                                   }
866                                                   
867                                                   sub _d {
868   ***      0                    0             0      my ($package, undef, $line) = caller 0;
869   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
870   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
871                                                           @_;
872   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
873                                                   }
874                                                   
875                                                   1;
876                                                   
877                                                   # ###########################################################################
878                                                   # End OptionParser package
879                                                   # ###########################################################################
880                                                   
881                                                   # ###########################################################################
882                                                   # Quoter package 3186
883                                                   # ###########################################################################
884            1                    1            11   use strict;
               1                                  3   
               1                                  7   
885            1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                 11   
886                                                   
887                                                   package Quoter;
888                                                   
889            1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  6   
890                                                   
891            1                    1             9   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  3   
               1                                  9   
892                                                   
893                                                   sub new {
894            4                    4            19      my ( $class ) = @_;
895            4                                 33      bless {}, $class;
896                                                   }
897                                                   
898                                                   sub quote {
899            6                    6            30      my ( $self, @vals ) = @_;
900            6                                 25      foreach my $val ( @vals ) {
901            6                                 27         $val =~ s/`/``/g;
902                                                      }
903            6                                 23      return join('.', map { '`' . $_ . '`' } @vals);
               6                                 46   
904                                                   }
905                                                   
906                                                   sub quote_val {
907   ***      0                    0             0      my ( $self, @vals ) = @_;
908                                                      return join(', ',
909                                                         map {
910   ***      0      0                           0            if ( defined $_ ) {
      ***      0                                  0   
911   ***      0                                  0               $_ =~ s/(['\\])/\\$1/g;
912   ***      0      0      0                    0               $_ eq '' || $_ =~ m/^0|\D/ ? "'$_'" : $_;
913                                                            }
914                                                            else {
915   ***      0                                  0               'NULL';
916                                                            }
917                                                         } @vals
918                                                      );
919                                                   }
920                                                   
921                                                   sub split_unquote {
922   ***      0                    0             0      my ( $self, $db_tbl, $default_db ) = @_;
923   ***      0                                  0      $db_tbl =~ s/`//g;
924   ***      0                                  0      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
925   ***      0      0                           0      if ( !$tbl ) {
926   ***      0                                  0         $tbl = $db;
927   ***      0                                  0         $db  = $default_db;
928                                                      }
929   ***      0                                  0      return ($db, $tbl);
930                                                   }
931                                                   
932                                                   1;
933                                                   
934                                                   # ###########################################################################
935                                                   # End Quoter package
936                                                   # ###########################################################################
937                                                   
938                                                   # ###########################################################################
939                                                   # DSNParser package 4103
940                                                   # ###########################################################################
941            1                    1             7   use strict;
               1                                  3   
               1                                  5   
942            1                    1             5   use warnings FATAL => 'all';
               1                                  3   
               1                                  5   
943                                                   
944                                                   package DSNParser;
945                                                   
946            1                    1            15   use DBI;
               1                                  5   
               1                                 10   
947            1                    1             7   use Data::Dumper;
               1                                  2   
               1                                  9   
948                                                   $Data::Dumper::Indent    = 0;
949                                                   $Data::Dumper::Quotekeys = 0;
950            1                    1             6   use English qw(-no_match_vars);
               1                                  3   
               1                                  9   
951                                                   
952            1                    1             9   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                 12   
953                                                   
954                                                   sub new {
955            5                    5            48      my ( $class, @opts ) = @_;
956            5                                200      my $self = {
957                                                         opts => {
958                                                            A => {
959                                                               desc => 'Default character set',
960                                                               dsn  => 'charset',
961                                                               copy => 1,
962                                                            },
963                                                            D => {
964                                                               desc => 'Database to use',
965                                                               dsn  => 'database',
966                                                               copy => 1,
967                                                            },
968                                                            F => {
969                                                               desc => 'Only read default options from the given file',
970                                                               dsn  => 'mysql_read_default_file',
971                                                               copy => 1,
972                                                            },
973                                                            h => {
974                                                               desc => 'Connect to host',
975                                                               dsn  => 'host',
976                                                               copy => 1,
977                                                            },
978                                                            p => {
979                                                               desc => 'Password to use when connecting',
980                                                               dsn  => 'password',
981                                                               copy => 1,
982                                                            },
983                                                            P => {
984                                                               desc => 'Port number to use for connection',
985                                                               dsn  => 'port',
986                                                               copy => 1,
987                                                            },
988                                                            S => {
989                                                               desc => 'Socket file to use for connection',
990                                                               dsn  => 'mysql_socket',
991                                                               copy => 1,
992                                                            },
993                                                            u => {
994                                                               desc => 'User for login if not current user',
995                                                               dsn  => 'user',
996                                                               copy => 1,
997                                                            },
998                                                         },
999                                                      };
1000           5                                 27      foreach my $opt ( @opts ) {
1001           4                                 13         MKDEBUG && _d('Adding extra property', $opt->{key});
1002           4                                 46         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
1003                                                     }
1004           5                                 42      return bless $self, $class;
1005                                                  }
1006                                                  
1007                                                  sub prop {
1008          24                   24           115      my ( $self, $prop, $value ) = @_;
1009  ***     24     50                         119      if ( @_ > 2 ) {
1010  ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
1011  ***      0                                  0         $self->{$prop} = $value;
1012                                                     }
1013          24                                179      return $self->{$prop};
1014                                                  }
1015                                                  
1016                                                  sub parse {
1017          12                   12            64      my ( $self, $dsn, $prev, $defaults ) = @_;
1018          12    100                          54      if ( !$dsn ) {
1019           4                                  9         MKDEBUG && _d('No DSN to parse');
1020           4                                 18         return;
1021                                                     }
1022           8                                 19      MKDEBUG && _d('Parsing', $dsn);
1023           8           100                   37      $prev     ||= {};
1024  ***      8            50                   37      $defaults ||= {};
1025           8                                 23      my %given_props;
1026           8                                 20      my %final_props;
1027           8                                 22      my %opts = %{$self->{opts}};
               8                                 97   
1028                                                  
1029           8                                 63      foreach my $dsn_part ( split(/,/, $dsn) ) {
1030  ***     22     50                         179         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1031          22                                103            $given_props{$prop_key} = $prop_val;
1032                                                        }
1033                                                        else {
1034  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1035  ***      0                                  0            $given_props{h} = $dsn_part;
1036                                                        }
1037                                                     }
1038                                                  
1039           8                                 42      foreach my $key ( keys %opts ) {
1040          71                                157         MKDEBUG && _d('Finding value for', $key);
1041          71                                250         $final_props{$key} = $given_props{$key};
1042  ***     71     50     66                  607         if (   !defined $final_props{$key}
      ***                   33                        
1043                                                             && defined $prev->{$key} && $opts{$key}->{copy} )
1044                                                        {
1045  ***      0                                  0            $final_props{$key} = $prev->{$key};
1046  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1047                                                        }
1048          71    100                         506         if ( !defined $final_props{$key} ) {
1049          49                                153            $final_props{$key} = $defaults->{$key};
1050          49                                133            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1051                                                        }
1052                                                     }
1053                                                  
1054           8                                 43      foreach my $key ( keys %given_props ) {
1055  ***     22     50                          99         die "Unrecognized DSN part '$key' in '$dsn'\n"
1056                                                           unless exists $opts{$key};
1057                                                     }
1058  ***      8     50                          42      if ( (my $required = $self->prop('required')) ) {
1059  ***      0                                  0         foreach my $key ( keys %$required ) {
1060  ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1061                                                        }
1062                                                     }
1063                                                  
1064           8                                 58      return \%final_props;
1065                                                  }
1066                                                  
1067                                                  sub parse_options {
1068           4                    4            16      my ( $self, $o ) = @_;
1069  ***      4     50                          26      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1070  ***      0                                  0      my $dsn_string
1071                                                        = join(',',
1072          36    100                         131             map  { "$_=".$o->get($_); }
1073           4                                 27             grep { $o->has($_) && $o->get($_) }
1074           4                                 14             keys %{$self->{opts}}
1075                                                          );
1076           4                                 15      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1077           4                                 20      return $self->parse($dsn_string);
1078                                                  }
1079                                                  
1080                                                  sub as_string {
1081  ***      0                    0             0      my ( $self, $dsn ) = @_;
1082  ***      0      0                           0      return $dsn unless ref $dsn;
1083  ***      0      0                           0      return join(',',
1084  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1085  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1086                                                        sort keys %$dsn );
1087                                                  }
1088                                                  
1089                                                  sub usage {
1090  ***      0                    0             0      my ( $self ) = @_;
1091  ***      0                                  0      my $usage
1092                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1093                                                        . "  KEY  COPY  MEANING\n"
1094                                                        . "  ===  ====  =============================================\n";
1095  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1096  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1097  ***      0      0      0                    0         $usage .= "  $key    "
1098                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1099                                                               .  ($opts{$key}->{desc} || '[No description]')
1100                                                               . "\n";
1101                                                     }
1102  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1103  ***      0                                  0      return $usage;
1104                                                  }
1105                                                  
1106                                                  sub get_cxn_params {
1107           8                    8            38      my ( $self, $info ) = @_;
1108           8                                 22      my $dsn;
1109           8                                 22      my %opts = %{$self->{opts}};
               8                                 81   
1110  ***      8            50                   53      my $driver = $self->prop('dbidriver') || '';
1111  ***      8     50                          35      if ( $driver eq 'Pg' ) {
1112  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1113  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1114  ***      0             0                    0                        grep { defined $info->{$_} }
1115                                                                       qw(h P));
1116                                                     }
1117                                                     else {
1118          16                                108         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1119          40                                152            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1120           8           100                   87                        grep { defined $info->{$_} }
1121                                                                       qw(F h P S A))
1122                                                           . ';mysql_read_default_group=client';
1123                                                     }
1124           8                                 26      MKDEBUG && _d($dsn);
1125           8                                 80      return ($dsn, $info->{u}, $info->{p});
1126                                                  }
1127                                                  
1128                                                  sub fill_in_dsn {
1129  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1130  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1131  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1132  ***      0                                  0      $user =~ s/@.*//;
1133  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1134  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1135  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1136  ***      0             0                    0      $dsn->{u} ||= $user;
1137  ***      0             0                    0      $dsn->{D} ||= $db;
1138                                                  }
1139                                                  
1140                                                  sub get_dbh {
1141           8                    8            46      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1142  ***      8            50                   38      $opts ||= {};
1143  ***      8     50                          84      my $defaults = {
1144                                                        AutoCommit         => 0,
1145                                                        RaiseError         => 1,
1146                                                        PrintError         => 0,
1147                                                        ShowErrorStatement => 1,
1148                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1149                                                     };
1150           8                                 41      @{$defaults}{ keys %$opts } = values %$opts;
               8                                 32   
1151                                                  
1152           8                                 23      my $dbh;
1153           8                                 24      my $tries = 2;
1154  ***      8            66                   94      while ( !$dbh && $tries-- ) {
1155                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1156           8                                 23            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1157                                                  
1158           8                                 26         eval {
1159           8                                 75            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1160                                                  
1161  ***      8     50                          79            if ( $cxn_string =~ m/mysql/i ) {
1162           8                                 25               my $sql;
1163                                                  
1164           8                                 35               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1165                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1166           8                                 20               MKDEBUG && _d($dbh, ':', $sql);
1167           8                                821               $dbh->do($sql);
1168                                                  
1169  ***      8     50                          69               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1170  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1171  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1172  ***      0                                  0                  $dbh->do($sql);
1173  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1174  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1175  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1176                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1177                                                                 }
1178                                                                 else {
1179  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1180                                                                 }
1181                                                              }
1182                                                  
1183  ***      8     50                          52               if ( $self->prop('setvars') ) {
1184  ***      0                                  0                  $sql = "SET " . $self->prop('setvars');
1185  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1186  ***      0                                  0                  $dbh->do($sql);
1187                                                              }
1188                                                           }
1189                                                        };
1190  ***      8     50     33                   71         if ( !$dbh && $EVAL_ERROR ) {
1191  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1192  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
1193  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1194  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1195                                                           }
1196  ***      0      0                           0            if ( !$tries ) {
1197  ***      0                                  0               die $EVAL_ERROR;
1198                                                           }
1199                                                        }
1200                                                     }
1201                                                  
1202           8                                 18      MKDEBUG && _d('DBH info: ',
1203                                                        $dbh,
1204                                                        Dumper($dbh->selectrow_hashref(
1205                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1206                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1207                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1208                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1209                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1210                                                        '$DBI::VERSION:',        $DBI::VERSION,
1211                                                     );
1212                                                  
1213           8                                 43      return $dbh;
1214                                                  }
1215                                                  
1216                                                  sub get_hostname {
1217  ***      0                    0             0      my ( $self, $dbh ) = @_;
1218  ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1219  ***      0                                  0         return $host;
1220                                                     }
1221  ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
1222                                                        'SELECT /*!50038 @@hostname, */ 1');
1223  ***      0                                  0      return $hostname;
1224                                                  }
1225                                                  
1226                                                  sub disconnect {
1227  ***      0                    0             0      my ( $self, $dbh ) = @_;
1228  ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
1229  ***      0                                  0      $dbh->disconnect;
1230                                                  }
1231                                                  
1232                                                  sub print_active_handles {
1233  ***      0                    0             0      my ( $self, $thing, $level ) = @_;
1234  ***      0             0                    0      $level ||= 0;
1235  ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1236                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1237                                                        or die "Cannot print: $OS_ERROR";
1238  ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
1239  ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
1240                                                     }
1241                                                  }
1242                                                  
1243                                                  sub copy {
1244           3                    3            17      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1245  ***      3     50                          13      die 'I need a dsn_1 argument' unless $dsn_1;
1246  ***      3     50                          16      die 'I need a dsn_2 argument' unless $dsn_2;
1247          27                                 73      my %new_dsn = map {
1248           3                                 17         my $key = $_;
1249          27                                 69         my $val;
1250  ***     27     50                          96         if ( $args{overwrite} ) {
1251  ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1252                                                        }
1253                                                        else {
1254          27    100                         129            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1255                                                        }
1256          27                                122         $key => $val;
1257           3                                 15      } keys %{$self->{opts}};
1258           3                                 21      return \%new_dsn;
1259                                                  }
1260                                                  
1261                                                  sub _d {
1262  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1263  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1264  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1265                                                          @_;
1266  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1267                                                  }
1268                                                  
1269                                                  1;
1270                                                  
1271                                                  # ###########################################################################
1272                                                  # End DSNParser package
1273                                                  # ###########################################################################
1274                                                  
1275                                                  # ###########################################################################
1276                                                  # Daemon package 3976
1277                                                  # ###########################################################################
1278                                                  
1279                                                  package Daemon;
1280                                                  
1281           1                    1             9   use strict;
               1                                  3   
               1                                  9   
1282           1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                 11   
1283                                                  
1284           1                    1            12   use POSIX qw(setsid);
               1                                  4   
               1                                  6   
1285           1                    1             8   use English qw(-no_match_vars);
               1                                  3   
               1                                  8   
1286                                                  
1287           1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  9   
1288                                                  
1289                                                  sub new {
1290  ***      0                    0             0      my ( $class, %args ) = @_;
1291  ***      0                                  0      foreach my $arg ( qw(o) ) {
1292  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1293                                                     }
1294  ***      0                                  0      my $o = $args{o};
1295  ***      0      0                           0      my $self = {
      ***             0                               
1296                                                        o        => $o,
1297                                                        log_file => $o->has('log') ? $o->get('log') : undef,
1298                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
1299                                                     };
1300                                                  
1301  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
1302                                                  
1303  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
1304  ***      0                                  0      return bless $self, $class;
1305                                                  }
1306                                                  
1307                                                  sub daemonize {
1308  ***      0                    0             0      my ( $self ) = @_;
1309                                                  
1310  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
1311  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
1312  ***      0      0                           0      if ( $pid ) {
1313  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
1314  ***      0                                  0         exit;
1315                                                     }
1316                                                  
1317  ***      0                                  0      $self->{child} = 1;
1318                                                  
1319  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
1320  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
1321                                                  
1322  ***      0                                  0      $self->_make_PID_file();
1323                                                  
1324  ***      0      0                           0      if ( -t STDIN ) {
1325  ***      0                                  0         close STDIN;
1326  ***      0      0                           0         open  STDIN, '/dev/null'
1327                                                           or die "Cannot reopen STDIN to /dev/null";
1328                                                     }
1329                                                  
1330  ***      0      0                           0      if ( $self->{log_file} ) {
1331  ***      0                                  0         close STDOUT;
1332  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
1333                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
1334                                                  
1335  ***      0                                  0         close STDERR;
1336  ***      0      0                           0         open  STDERR, ">&STDOUT"
1337                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR";
1338                                                     }
1339                                                  
1340  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
1341  ***      0                                  0      return;
1342                                                  }
1343                                                  
1344                                                  sub check_PID_file {
1345  ***      0                    0             0      my ( $self, $file ) = @_;
1346  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
1347  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
1348  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
1349  ***      0                                  0         my $pid;
1350  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
1351  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
1352  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
1353  ***      0      0                           0         if ( $pid ) {
1354  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
1355  ***      0      0                           0            if ( $pid_is_alive ) {
1356  ***      0                                  0               die "The PID file $PID_file already exists "
1357                                                                 . " and the PID that it contains, $pid, is running";
1358                                                           }
1359                                                           else {
1360  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
1361                                                                 . "contains, $pid, is not running";
1362                                                           }
1363                                                        }
1364                                                        else {
1365  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
1366                                                              . "contain a PID";
1367                                                        }
1368                                                     }
1369                                                     else {
1370  ***      0                                  0         MKDEBUG && _d('No PID file');
1371                                                     }
1372  ***      0                                  0      return;
1373                                                  }
1374                                                  
1375                                                  sub make_PID_file {
1376  ***      0                    0             0      my ( $self ) = @_;
1377  ***      0      0                           0      if ( exists $self->{child} ) {
1378  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
1379                                                     }
1380  ***      0                                  0      $self->_make_PID_file();
1381  ***      0                                  0      $self->{rm_PID_file} = 1;
1382  ***      0                                  0      return;
1383                                                  }
1384                                                  
1385                                                  sub _make_PID_file {
1386  ***      0                    0             0      my ( $self ) = @_;
1387                                                  
1388  ***      0                                  0      my $PID_file = $self->{PID_file};
1389  ***      0      0                           0      if ( !$PID_file ) {
1390  ***      0                                  0         MKDEBUG && _d('No PID file to create');
1391  ***      0                                  0         return;
1392                                                     }
1393                                                  
1394  ***      0                                  0      $self->check_PID_file();
1395                                                  
1396  ***      0      0                           0      open my $PID_FH, '>', $PID_file
1397                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
1398  ***      0      0                           0      print $PID_FH $PID
1399                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
1400  ***      0      0                           0      close $PID_FH
1401                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
1402                                                  
1403  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
1404  ***      0                                  0      return;
1405                                                  }
1406                                                  
1407                                                  sub _remove_PID_file {
1408  ***      0                    0             0      my ( $self ) = @_;
1409  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
1410  ***      0      0                           0         unlink $self->{PID_file}
1411                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
1412  ***      0                                  0         MKDEBUG && _d('Removed PID file');
1413                                                     }
1414                                                     else {
1415  ***      0                                  0         MKDEBUG && _d('No PID to remove');
1416                                                     }
1417  ***      0                                  0      return;
1418                                                  }
1419                                                  
1420                                                  sub DESTROY {
1421  ***      0                    0             0      my ( $self ) = @_;
1422  ***      0      0      0                    0      $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
1423  ***      0                                  0      return;
1424                                                  }
1425                                                  
1426                                                  sub _d {
1427  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1428  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1429  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1430                                                          @_;
1431  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1432                                                  }
1433                                                  
1434                                                  1;
1435                                                  
1436                                                  # ###########################################################################
1437                                                  # End Daemon package
1438                                                  # ###########################################################################
1439                                                  
1440                                                  # ###########################################################################
1441                                                  # Transformers package 4294
1442                                                  # ###########################################################################
1443                                                  
1444                                                  # Transformers - Common transformation and beautification subroutines
1445                                                  package Transformers;
1446                                                  
1447           1                    1             7   use strict;
               1                                  3   
               1                                  6   
1448           1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  6   
1449           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  5   
1450           1                    1            15   use Time::Local qw(timelocal);
               1                                  3   
               1                                  9   
1451           1                    1             7   use Digest::MD5 qw(md5_hex);
               1                                  2   
               1                                  7   
1452                                                  
1453           1                    1             7   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                  7   
1454                                                  
1455                                                  require Exporter;
1456                                                  our @ISA         = qw(Exporter);
1457                                                  our %EXPORT_TAGS = ();
1458                                                  our @EXPORT      = ();
1459                                                  our @EXPORT_OK   = qw(
1460                                                     micro_t
1461                                                     percentage_of
1462                                                     secs_to_time
1463                                                     shorten
1464                                                     ts
1465                                                     parse_timestamp
1466                                                     unix_timestamp
1467                                                     any_unix_timestamp
1468                                                     make_checksum
1469                                                  );
1470                                                  
1471                                                  our $mysql_ts  = qr/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?/;
1472                                                  our $proper_ts = qr/(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(?:\.\d+)?/;
1473                                                  our $n_ts      = qr/(\d)([shmd]?)/;
1474                                                  
1475                                                  sub micro_t {
1476  ***      0                    0             0      my ( $t, %args ) = @_;
1477  ***      0      0                           0      my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
1478  ***      0      0                           0      my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
1479  ***      0                                  0      my $f;
1480                                                  
1481  ***      0      0                           0      $t = 0 if $t < 0;
1482                                                  
1483                                                     # "Remove" scientific notation so the regex below does not make
1484                                                     # 6.123456e+18 into 6.123456.
1485  ***      0      0                           0      $t = sprintf('%.17f', $t) if $t =~ /e/;
1486                                                  
1487                                                     # Truncate after 6 decimal places to avoid 0.9999997 becoming 1
1488                                                     # because sprintf() rounds.
1489  ***      0                                  0      $t =~ s/\.(\d{1,6})\d*/\.$1/;
1490                                                  
1491  ***      0      0      0                    0      if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
1492  ***      0                                  0         $f = ($t * 1000000) . 'us';
1493                                                     }
1494                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
1495  ***      0                                  0         $f = sprintf("%.${p_ms}f", $t * 1000);
1496  ***      0                                  0         $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
1497                                                     }
1498                                                     elsif ($t >= 1) {
1499  ***      0                                  0         $f = sprintf("%.${p_s}f", $t);
1500  ***      0                                  0         $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
1501                                                     }
1502                                                     else {
1503  ***      0                                  0         $f = 0;  # $t should = 0 at this point
1504                                                     }
1505                                                  
1506  ***      0                                  0      return $f;
1507                                                  }
1508                                                  
1509                                                  # Returns what percentage $is of $of.
1510                                                  sub percentage_of {
1511  ***      0                    0             0      my ( $is, $of, %args ) = @_;
1512  ***      0             0                    0      my $p   = $args{p} || 0; # float precision
1513  ***      0      0                           0      my $fmt = $p ? "%.${p}f" : "%d";
1514  ***      0             0                    0      return sprintf $fmt, ($is * 100) / ($of ||= 1);
1515                                                  }
1516                                                  
1517                                                  sub secs_to_time {
1518  ***      0                    0             0      my ( $secs, $fmt ) = @_;
1519  ***      0             0                    0      $secs ||= 0;
1520  ***      0      0                           0      return '00:00' unless $secs;
1521                                                  
1522                                                     # Decide what format to use, if not given
1523  ***      0      0      0                    0      $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
1524                                                            : $secs >= 3_600  ? 'h'
1525                                                            :                   'm';
1526                                                  
1527                                                     return
1528  ***      0      0                           0         $fmt eq 'd' ? sprintf(
      ***             0                               
1529                                                           "%d+%02d:%02d:%02d",
1530                                                           int($secs / 86_400),
1531                                                           int(($secs % 86_400) / 3_600),
1532                                                           int(($secs % 3_600) / 60),
1533                                                           $secs % 60)
1534                                                        : $fmt eq 'h' ? sprintf(
1535                                                           "%02d:%02d:%02d",
1536                                                           int(($secs % 86_400) / 3_600),
1537                                                           int(($secs % 3_600) / 60),
1538                                                           $secs % 60)
1539                                                        : sprintf(
1540                                                           "%02d:%02d",
1541                                                           int(($secs % 3_600) / 60),
1542                                                           $secs % 60);
1543                                                  }
1544                                                  
1545                                                  sub shorten {
1546  ***      0                    0             0      my ( $num, %args ) = @_;
1547  ***      0      0                           0      my $p = defined $args{p} ? $args{p} : 2;     # float precision
1548  ***      0      0                           0      my $d = defined $args{d} ? $args{d} : 1_024; # divisor
1549  ***      0                                  0      my $n = 0;
1550  ***      0                                  0      my @units = ('', qw(k M G T P E Z Y));
1551  ***      0             0                    0      while ( $num >= $d && $n < @units - 1 ) {
1552  ***      0                                  0         $num /= $d;
1553  ***      0                                  0         ++$n;
1554                                                     }
1555  ***      0      0      0                    0      return sprintf(
1556                                                        $num =~ m/\./ || $n
1557                                                           ? "%.${p}f%s"
1558                                                           : '%d',
1559                                                        $num, $units[$n]);
1560                                                  }
1561                                                  
1562                                                  sub ts {
1563  ***      0                    0             0      my ( $time ) = @_;
1564  ***      0                                  0      my ( $sec, $min, $hour, $mday, $mon, $year )
1565                                                        = localtime($time);
1566  ***      0                                  0      $mon  += 1;
1567  ***      0                                  0      $year += 1900;
1568  ***      0                                  0      return sprintf("%d-%02d-%02dT%02d:%02d:%02d",
1569                                                        $year, $mon, $mday, $hour, $min, $sec);
1570                                                  }
1571                                                  
1572                                                  # Turns MySQL's 071015 21:43:52 into a properly formatted timestamp.  Also
1573                                                  # handles a timestamp with fractions after it.
1574                                                  sub parse_timestamp {
1575           3                    3            13      my ( $val ) = @_;
1576  ***      3     50                          90      if ( my($y, $m, $d, $h, $i, $s, $f)
1577                                                           = $val =~ m/^$mysql_ts$/ )
1578                                                     {
1579  ***      3     50                         882         return sprintf "%d-%02d-%02d %02d:%02d:"
      ***            50                               
1580                                                                       . (defined $f ? '%02.6f' : '%02d'),
1581                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
1582                                                     }
1583  ***      0                                  0      return $val;
1584                                                  }
1585                                                  
1586                                                  # Turns a properly formatted timestamp like 2007-10-15 01:43:52
1587                                                  # into an int (seconds since epoch).  Optional microseconds are ignored.
1588                                                  sub unix_timestamp {
1589  ***      0                    0             0      my ( $val ) = @_;
1590  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s)
1591                                                       = $val =~ m/^$proper_ts$/ )
1592                                                     {
1593  ***      0                                  0         return timelocal($s, $i, $h, $d, $m - 1, $y);
1594                                                     }
1595  ***      0                                  0      return $val;
1596                                                  }
1597                                                  
1598                                                  # Turns several different types of timestamps into a unix timestamp.
1599                                                  # Each type is auto-detected.  Supported types are:
1600                                                  #   * N[shdm]                Now - N[shdm]
1601                                                  #   * 071015 21:43:52        MySQL slow log timestamp
1602                                                  #   * 2009-07-01 [3:43:01]   Proper timestamp with options HH:MM:SS
1603                                                  #   * NOW()                  A MySQL time express
1604                                                  # For the last type, the callback arg is required.  It is passed the
1605                                                  # given value/expression and is expected to return a single value
1606                                                  # (the result of the expression).
1607                                                  sub any_unix_timestamp {
1608  ***      0                    0             0      my ( $val, $callback ) = @_;
1609                                                  
1610  ***      0      0                           0      if ( my ($n, $suffix) = $val =~ m/^$n_ts$/ ) {
      ***             0                               
      ***             0                               
1611  ***      0      0                           0         $n = $suffix eq 's' ? $n            # Seconds
      ***             0                               
      ***             0                               
      ***             0                               
1612                                                           : $suffix eq 'm' ? $n * 60       # Minutes
1613                                                           : $suffix eq 'h' ? $n * 3600     # Hours
1614                                                           : $suffix eq 'd' ? $n * 86400    # Days
1615                                                           :                  $n;           # default: Seconds
1616  ***      0                                  0         MKDEBUG && _d('ts is now - N[shmd]:', $n);
1617  ***      0                                  0         return time - $n;
1618                                                     }
1619                                                     elsif ( $val =~ m/^$mysql_ts$/ ) {
1620  ***      0                                  0         MKDEBUG && d('ts is MySQL slow log timestamp');
1621  ***      0                                  0         return unix_timestamp(parse_timestamp($val));
1622                                                     }
1623                                                     elsif ( $val =~ /^$proper_ts$/ ) {
1624  ***      0                                  0         MKDEBUG && _d('ts is properly formatted timestamp');
1625  ***      0                                  0         return unix_timestamp($val);
1626                                                     }
1627                                                     else {
1628  ***      0                                  0         MKDEBUG && _d('ts is MySQL expression');
1629  ***      0      0      0                    0         return $callback->($val) if $callback && ref $callback eq 'CODE';
1630                                                     }
1631                                                  
1632  ***      0                                  0      MKDEBUG && _d('Unknown ts type:', $val);
1633  ***      0                                  0      return;
1634                                                  }
1635                                                  
1636                                                  # Returns the rightmost 64 bits of an MD5 checksum of the value.
1637                                                  sub make_checksum {
1638  ***      0                    0             0      my ( $val ) = @_;
1639  ***      0                                  0      my $checksum = uc substr(md5_hex($val), -16);
1640  ***      0                                  0      MKDEBUG && _d($checksum, 'checksum for', $val);
1641  ***      0                                  0      return $checksum;
1642                                                  }
1643                                                  
1644                                                  sub _d {
1645  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1646  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1647  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1648                                                          @_;
1649  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1650                                                  }
1651                                                  
1652                                                  1;
1653                                                  
1654                                                  # ###########################################################################
1655                                                  # End Transformers package
1656                                                  # ###########################################################################
1657                                                  
1658                                                  # ###########################################################################
1659                                                  # This is a combination of modules and programs in one -- a runnable module.
1660                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
1661                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
1662                                                  #
1663                                                  # Check at the end of this package for the call to main() which actually runs
1664                                                  # the program.
1665                                                  # ###########################################################################
1666                                                  package mk_fk_error_logger;
1667                                                  
1668           1                    1             9   use English qw(-no_match_vars);
               1                                  3   
               1                                  8   
1669           1                    1            13   use sigtrap qw(handler finish untrapped normal-signals);
               1                                  3   
               1                                  8   
1670                                                  
1671           1                    1             6   use constant MKDEBUG => $ENV{MKDEBUG};
               1                                  2   
               1                                 13   
1672                                                  
1673                                                  Transformers->import(qw(parse_timestamp));
1674                                                  
1675                                                  my $oktorun;
1676                                                  
1677                                                  sub main {
1678           4                    4           213      @ARGV = @_;  # set global ARGV for this package
1679                                                  
1680                                                     # ########################################################################
1681                                                     # Get configuration information.
1682                                                     # ########################################################################
1683           4                                 74      my $dp = new DSNParser(
1684                                                        {
1685                                                           key => 't',
1686                                                           copy => 1,
1687                                                           desc => 'Table in which to store foreign key errors'
1688                                                        },
1689                                                     );
1690                                                  
1691           4                                 59      my $o = new OptionParser(
1692                                                        strict      => 0,
1693                                                        description => q{extracts and saves information about the most }
1694                                                                     . q{recent foreign key errors in a MySQL server.},
1695                                                        prompt      => '[OPTION]... SOURCE_DSN',
1696                                                        dp          => $dp,
1697                                                     );
1698                                                  
1699           4                                 21      $o->get_specs();
1700           4                                 29      $o->get_opts();
1701                                                  
1702           4                                 26      my $src_dsn = $dp->parse_options($o);
1703           4                                 10      MKDEBUG && _d('Got source host from opts:', $src_dsn ? 'yes' : 'no');
1704  ***      4     50                          18      if ( @ARGV ) {
1705           4                                 11         MKDEBUG && _d('Source host DSN:', $ARGV[0]);
1706           4                                 17         $src_dsn = $dp->parse(shift @ARGV);
1707                                                     }
1708                                                  
1709           4                                 21      my $dst_dsn = $o->get('dest');
1710  ***      4    100     66                   41      if ( $src_dsn && $dst_dsn ) {
1711                                                        # If dest DSN only has D and t, this will copy h, P, S, etc.
1712                                                        # from the source DSN.
1713           3                                 20         $dst_dsn = $dp->copy($src_dsn, $dst_dsn);
1714                                                     }
1715                                                  
1716  ***      4     50                          18      if ( !$o->get('help') ) {
1717  ***      4     50                          19         if ( !$src_dsn ) {
1718  ***      0                                  0            $o->save_error('Missing or invalid source host');
1719                                                        }
1720  ***      4     50     66                   34         if ( $dst_dsn && !$dst_dsn->{D} ) {
1721  ***      0                                  0            $o->save_error('Destination DSN requires database (D)');
1722                                                        }
1723  ***      4     50     66                   31         if ( $dst_dsn && !$dst_dsn->{t} ) {
1724  ***      0                                  0            $o->save_error('Destination DSN requires table (t)');
1725                                                        }
1726                                                     }
1727                                                  
1728           4                                 25      $o->usage_or_errors();
1729                                                  
1730                                                     # ########################################################################
1731                                                     # Make common modules.
1732                                                     # ########################################################################
1733           4                                 48      my $q = new Quoter();
1734           4                                 29      my %modules = (
1735                                                        o  => $o,
1736                                                        dp => $dp,
1737                                                        q  => $q,
1738                                                     );
1739                                                  
1740                                                     # ########################################################################
1741                                                     # Start working.
1742                                                     # ########################################################################
1743           4                                 43      my $dbh   = get_cxn($src_dsn, 1, %modules);
1744           4                                 21      my $start = time();
1745  ***      4            50                   26      my $end   = $start + ($o->get('run-time') || 0); # When we should exit
1746           4                                 12      my $now   = $start;
1747           4                                 10      my $dst_dbh;
1748           4                                 11      my $ins_sth;
1749                                                  
1750                                                     # Since the user might not have specified a hostname for the connection,
1751                                                     # try to extract it from the $dbh
1752  ***      4     50                          22      if ( !$src_dsn->{h} ) {
1753  ***      0                                  0         ($src_dsn->{h}) = $dbh->{mysql_hostinfo} =~ m/(\w+) via/;
1754  ***      0                                  0         MKDEBUG && _d('Got source host from dbh:', $src_dsn->{h});
1755                                                     }
1756                                                  
1757           4    100                          25      if ( $dst_dsn ) {
1758           6                                 32         my $db_tbl =  join('.',
1759           6                                 23               map  {  $q->quote($_) }
1760           3                                 20               grep { $_ }
1761                                                              ( $dst_dsn->{D}, $dst_dsn->{t} ));
1762           3                                 19         $dst_dbh = get_cxn($dst_dsn, 0, %modules);
1763           3                                  9         $ins_sth  = $dst_dbh->prepare("INSERT IGNORE INTO $db_tbl VALUES (?, ?)");
1764                                                     }
1765                                                  
1766                                                     # Daemonize only after (potentially) asking for passwords for --ask-pass.
1767           4                                 19      my $daemon;
1768  ***      4     50                          24      if ( $o->get('daemonize') ) {
1769  ***      0                                  0         $daemon = new Daemon(o=>$o);
1770  ***      0                                  0         $daemon->daemonize();
1771  ***      0                                  0         MKDEBUG && _d('I am a daemon now');
1772                                                     }
1773                                                  
1774           4                                 12      $oktorun = 1;
1775  ***      4            33                   43      while (                            # Quit if:
      ***                   66                        
1776                                                        ($start == $end || $now < $end) # time is exceeded
1777                                                        && $oktorun                     # or instructed to quit
1778                                                        )
1779                                                     {
1780           4                                  9         my $text = $dbh->selectrow_hashref("SHOW INNODB STATUS")->{Status};
1781           4                                 54         my ($ts, $fk_error) = get_fk_error($text);
1782                                                  
1783                                                        # Save and/or print the foreign key error.
1784           4    100                          29         $ins_sth->execute(parse_timestamp($ts), $fk_error) if $ins_sth;
1785  ***      4    100     66                   37         print "$ts $fk_error\n\n" if $o->get('print') || !$o->got('dest');
1786                                                  
1787                                                        # If there's an --interval argument, run forever or till specified.
1788                                                        # Otherwise just run once.
1789  ***      4     50                          17         if ( $o->get('interval') ) {
1790  ***      0                                  0            sleep($o->get('interval'));
1791  ***      0                                  0            $now = time();
1792                                                        }
1793                                                        else {
1794           4                                 62            $oktorun = 0;
1795                                                        }
1796                                                     }
1797                                                  
1798           4                                656      return 0;
1799                                                  }
1800                                                  
1801                                                  # ############################################################################
1802                                                  # Subroutines
1803                                                  # ############################################################################
1804                                                  
1805                                                  sub get_fk_error {
1806           9                    9            98      my ( $text ) = @_;
1807                                                  
1808                                                     # Quick check if text even has a foreign key error.
1809  ***      9     50                          60      return unless $text =~ m/LATEST FOREIGN KEY ERROR/;
1810                                                  
1811           9                                 60      my $idb_ts = qr/(\d{6} .\d:\d\d:\d\d)/;    # InnoDB timestamp
1812                                                  
1813           9                                223      my ($ts, $fke) = $text =~ m/LATEST FOREIGN KEY ERROR.+?$idb_ts\s*(.+?)---/ms;
1814  ***      9     50                          63      chomp $fke if $fke;
1815                                                  
1816           9                                 19      MKDEBUG && _d($ts, $fke);
1817           9                                 75      return $ts, $fke;
1818                                                  }
1819                                                  
1820                                                  # Catches signals so the program can exit gracefully.
1821                                                  sub finish {
1822  ***      0                    0             0      my ($signal) = @_;
1823  ***      0                                  0      print STDERR "Exiting on SIG$signal.\n";
1824  ***      0                                  0      $oktorun = 0;
1825                                                  }
1826                                                  
1827                                                  sub get_cxn {
1828           7                    7            42      my ( $dsn, $ac, %args ) = @_;
1829           7                                 26      my $o  = $args{o};
1830           7                                 22      my $dp = $args{dp};
1831                                                  
1832  ***      7     50                          28      if ( $o->get('ask-pass') ) {
1833  ***      0                                  0         $dsn->{p} = OptionParser::prompt_noecho("Enter password: "); 
1834                                                     }
1835           7                                 44      my $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), {AutoCommit => $ac});
1836           7                                 45      $dbh->{InactiveDestroy} = 1; # Because of forking.
1837           7                                 55      return $dbh;
1838                                                  }
1839                                                  
1840                                                  sub _d {
1841  ***      0                    0                    my ($package, undef, $line) = caller 0;
1842  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1843  ***      0                                              map { defined $_ ? $_ : 'undef' }
1844                                                          @_;
1845  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1846                                                  }
1847                                                  
1848                                                  # ############################################################################
1849                                                  # Run the program.
1850                                                  # ############################################################################
1851                                                  if ( !caller ) { exit main(@ARGV); }
1852                                                  
1853                                                  1; # Because this is a module as well as a script.
1854                                                  
1855                                                  # ############################################################################
1856                                                  # Documentation
1857                                                  # ############################################################################
1858                                                  =pod
1859                                                  
1860                                                  =head1 NAME
1861                                                  
1862                                                  mk-fk-error-logger - Extract and log MySQL foreign key errors.
1863                                                  
1864                                                  =head1 SYNOPSIS
1865                                                  
1866                                                  Print foreign key errors on host1:
1867                                                  
1868                                                     mk-fk-error-logger h=host1
1869                                                  
1870                                                  Save foreign key errors on host1 to db.foreign_key_errors table on host2:
1871                                                  
1872                                                    mk-fk-error-logger h=host1 --dest h=host1,D=db,t=foreign_key_errors
1873                                                  
1874                                                  =head1 DESCRIPTION
1875                                                  
1876                                                  mk-fk-error-logger prints or saves the foreign key errors text from
1877                                                  C<SHOW INNODB STATUS>.  The errors are not parsed or interpreted in any
1878                                                  way.  Foreign key errors are uniquely identified by their timestamp.
1879                                                  Only new (more recent) errors are printed or saved.
1880                                                  
1881                                                  =head1 OUTPUT
1882                                                  
1883                                                  If L<"--print"> is given or no L<"--dest"> is given, then mk-fk-error-logger
1884                                                  prints the foreign key error text to STDOUT exactly as it appeared in
1885                                                  C<SHOW INNODB STATUS>.
1886                                                  
1887                                                  =head1 OPTIONS
1888                                                  
1889                                                  =over
1890                                                  
1891                                                  =item --ask-pass
1892                                                  
1893                                                  Prompt for a password when connecting to MySQL.
1894                                                  
1895                                                  =item --charset
1896                                                  
1897                                                  short form: -A; type: string
1898                                                  
1899                                                  Default character set.  If the value is utf8, sets Perl's binmode on
1900                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and runs SET
1901                                                  NAMES UTF8 after connecting to MySQL.  Any other value sets binmode on STDOUT
1902                                                  without the utf8 layer, and runs SET NAMES after connecting to MySQL.
1903                                                  
1904                                                  =item --config
1905                                                  
1906                                                  type: Array
1907                                                  
1908                                                  Read this comma-separated list of config files; if specified, this must be the
1909                                                  first option on the command line.
1910                                                  
1911                                                  =item --daemonize
1912                                                  
1913                                                  Fork to the background and detach from the shell.  POSIX operating systems only.
1914                                                  
1915                                                  =item --defaults-file
1916                                                  
1917                                                  short form: -F; type: string
1918                                                  
1919                                                  Only read mysql options from the given file.  You must give an absolute
1920                                                  pathname.
1921                                                  
1922                                                  =item --dest
1923                                                  
1924                                                  type: DSN
1925                                                  
1926                                                  DSN for where to store foreign key errors; specify at least a database (D) and table (t).
1927                                                  
1928                                                  Missing values are filled in with the same values from the source host, so you
1929                                                  can usually omit most parts of this argument if you're storing foreign key
1930                                                  errors on the same server on which they happen.
1931                                                  
1932                                                  The following table is suggested:
1933                                                  
1934                                                   CREATE TABLE foreign_key_errors (
1935                                                     ts datetime NOT NULL,
1936                                                     error text NOT NULL,
1937                                                     PRIMARY KEY (ts),
1938                                                   )
1939                                                  
1940                                                  The only information saved is the timestamp and the foreign key error text.
1941                                                  
1942                                                  =item --help
1943                                                  
1944                                                  Show help and exit.
1945                                                  
1946                                                  =item --host
1947                                                  
1948                                                  short form: -h; type: string
1949                                                  
1950                                                  Connect to host.
1951                                                  
1952                                                  =item --interval
1953                                                  
1954                                                  type: time; default: 0
1955                                                  
1956                                                  How often to check for foreign key errors.
1957                                                  
1958                                                  =item --log
1959                                                  
1960                                                  type: string
1961                                                  
1962                                                  Print all output to this file when daemonized.
1963                                                  
1964                                                  =item --password
1965                                                  
1966                                                  short form: -p; type: string
1967                                                  
1968                                                  Password to use when connecting.
1969                                                  
1970                                                  =item --pid
1971                                                  
1972                                                  type: string
1973                                                  
1974                                                  Create the given PID file when daemonized.  The file contains the process ID of
1975                                                  the daemonized instance.  The PID file is removed when the daemonized instance
1976                                                  exits.  The program checks for the existence of the PID file when starting; if
1977                                                  it exists and the process with the matching PID exists, the program exits.
1978                                                  
1979                                                  =item --port
1980                                                  
1981                                                  short form: -P; type: int
1982                                                  
1983                                                  Port number to use for connection.
1984                                                  
1985                                                  =item --print
1986                                                  
1987                                                  Print results on standard output.  See L<"OUTPUT"> for more.
1988                                                  
1989                                                  =item --run-time
1990                                                  
1991                                                  type: time
1992                                                  
1993                                                  How long to run before exiting.
1994                                                  
1995                                                  =item --set-vars
1996                                                  
1997                                                  type: string; default: wait_timeout=10000
1998                                                  
1999                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this string
2000                                                  will be appended to SET and executed.
2001                                                  
2002                                                  =item --socket
2003                                                  
2004                                                  short form: -S; type: string
2005                                                  
2006                                                  Socket file to use for connection.
2007                                                  
2008                                                  =item --user
2009                                                  
2010                                                  short form: -u; type: string
2011                                                  
2012                                                  User for login if not current user.
2013                                                  
2014                                                  =item --version
2015                                                  
2016                                                  Show version and exit.
2017                                                  
2018                                                  =back
2019                                                  
2020                                                  =head1 DOWNLOADING
2021                                                  
2022                                                  You can download Maatkit from Google Code at
2023                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
2024                                                  easily with a command like the following:
2025                                                  
2026                                                     wget http://www.maatkit.org/get/toolname
2027                                                     or
2028                                                     wget http://www.maatkit.org/trunk/toolname
2029                                                  
2030                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
2031                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
2032                                                  needed.  The first URL gets the latest released version of the tool, and the
2033                                                  second gets the latest trunk code from Subversion.
2034                                                  
2035                                                  =head1 ENVIRONMENT
2036                                                  
2037                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
2038                                                  the Maatkit tools:
2039                                                  
2040                                                     MKDEBUG=1 mk-....
2041                                                  
2042                                                  =head1 SYSTEM REQUIREMENTS
2043                                                  
2044                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
2045                                                  installed in any reasonably new version of Perl.
2046                                                  
2047                                                  =head1 BUGS
2048                                                  
2049                                                  Please use Google Code Issues and Groups to report bugs or request support:
2050                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
2051                                                  discuss Maatkit.
2052                                                  
2053                                                  Please include the complete command-line used to reproduce the problem you are
2054                                                  seeing, the version of all MySQL servers involved, the complete output of the
2055                                                  tool when run with L<"--version">, and if possible, debugging output produced by
2056                                                  running with the C<MKDEBUG=1> environment variable.
2057                                                  
2058                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
2059                                                  
2060                                                  This program is copyright 2009-@CURRENTYEAR@ Percona Inc.
2061                                                  Feedback and improvements are welcome.
2062                                                  
2063                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
2064                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
2065                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
2066                                                  
2067                                                  This program is free software; you can redistribute it and/or modify it under
2068                                                  the terms of the GNU General Public License as published by the Free Software
2069                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
2070                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
2071                                                  licenses.
2072                                                  
2073                                                  You should have received a copy of the GNU General Public License along with
2074                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
2075                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
2076                                                  
2077                                                  =head1 AUTHOR
2078                                                  
2079                                                  Daniel Nichter
2080                                                  
2081                                                  =head1 VERSION
2082                                                  
2083                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 4247 $.
2084                                                  
2085                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
58    ***     50      0      4   unless $args{$arg}
64    ***     50      4      0   exists $args{'strict'} ? :
107   ***     50      0      4   unless open my $fh, '<', $file
127          100   1016      4   unless $para =~ /^=head1 OPTIONS/
132   ***     50      4      0   if $para =~ /^=over/
140   ***     50      0      4   unless $para
143          100     76      4   if (my($option) = $para =~ /^=item --(.*)/)
150          100     56     20   if ($para =~ /: /) { }
154   ***     50      0     92   unless $attributes{$attrib}
158          100     28     28   if ($attribs{'short form'})
174   ***     50      0     76   if $para =~ /^=item/
176   ***     50      0     76   if (my($base_option) = $option =~ /^\[no\](.*)/)
181          100     28     48   $attribs{'short form'} ? :
      ***     50      0     76   $attribs{'negatable'} ? :
      ***     50      0     76   $attribs{'cumulative'} ? :
             100     56     20   $attribs{'type'} ? :
             100      4     72   $attribs{'default'} ? :
      ***     50      0     76   $attribs{'group'} ? :
193   ***     50      0    100   unless $para
196          100      4     96   if ($para =~ /^=head1/)
200          100     76     20   if $para =~ /^=item --/
204   ***     50      0      4   unless @specs
215   ***     50     76      0   if (ref $opt) { }
220   ***     50      0     76   if (not $long)
225   ***     50      0     76   if exists $$self{'opts'}{$long}
228   ***     50      0     76   if (length $long == 1)
233          100     28     48   if ($short) { }
234   ***     50      0     28   if exists $$self{'short_opts'}{$short}
243   ***     50      0     76   $$opt{'spec'} =~ /!/ ? :
244   ***     50      0     76   $$opt{'spec'} =~ /\+/ ? :
245   ***     50      0     76   $$opt{'desc'} =~ /required/ ? :
257   ***     50      0     76   if ($type and $type eq 'd' and not $$self{'dp'})
262          100     16     60   if $type and $type =~ /[HhAadzm]/
264          100      4     72   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
265   ***     50      0      4   if ($$opt{'is_negatable'})
266   ***      0      0      0   $def eq 'no' ? :
      ***      0      0      0   $def eq 'yes' ? :
270   ***     50      4      0   defined $def ? :
274          100      4     72   if ($long eq 'config')
278   ***     50      0     76   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
291   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
296   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
301   ***      0      0      0   if ($opt =~ /default to/)
306   ***      0      0      0   if ($opt =~ /restricted to option groups/)
316   ***      0      0      0   unless $rule_ok
333   ***      0      0      0   unless exists $$self{'opts'}{$long}
349   ***      0      0      0   $$self{'opts'}{$_}{'short'} ? :
367   ***      0      0      0   unless exists $$self{'opts'}{$long}
387   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50      3      0   exists $$self{'opts'}{$opt} ? :
392   ***     50      0      3   if ($$opt{'is_cumulative'}) { }
407   ***     50      0     68   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100      8     68   exists $$self{'defaults'}{$long} ? :
416   ***     50      0      4   if (@ARGV and $ARGV[0] eq '--config')
420   ***     50      4      0   if ($self->has('config'))
426   ***     50     16      0   if ($EVAL_ERROR)
427   ***     50      0     16   $self->got('config') ? :
442   ***     50      0      4   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
445   ***     50      0      4   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
446   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
452   ***     50      0      4   if (@ARGV and $$self{'strict'})
458   ***      0      0      0   if (@set > 1)
469   ***      0      0      0   if (@set == 0)
479          100      3     73   if ($$opt{'got'}) { }
      ***     50      0     73   elsif ($$opt{'is_required'}) { }
480   ***     50      0      3   if (exists $$self{'disables'}{$long})
487   ***     50      0      3   if (exists $$self{'allowed_groups'}{$long})
499   ***      0      0      0   if $restricted_opt eq $long
500   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
505   ***      0      0      0   if (@restricted_opts)
507   ***      0      0      0   if (@restricted_opts == 1) { }
536          100     20     56   unless $opt and $$opt{'type'}
539   ***     50      0     56   if ($val and $$opt{'type'} eq 'm') { }
             100      3     53   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0     53   elsif ($val and $$opt{'type'} eq 'z') { }
      ***     50      0     53   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100      4     49   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
542   ***      0      0      0   if (not $suffix)
548   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
549   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
564   ***     50      0      3   if ($from_key)
575   ***      0      0      0   if (defined $num) { }
576   ***      0      0      0   if ($factor)
603          100     28     35   length $opt == 1 ? :
604   ***     50      0     63   unless $long and exists $$self{'opts'}{$long}
611   ***     50      0     20   length $opt == 1 ? :
612   ***     50      0     20   unless $long and exists $$self{'opts'}{$long}
619          100     36      4   length $opt == 1 ? :
620          100     32      8   defined $long ? :
625   ***      0      0      0   length $opt == 1 ? :
626   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
660   ***     50      0      4   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0      4   elsif (scalar @{$$self{'errors'};}) { }
661   ***      0      0      0   unless print $self->print_usage
665   ***      0      0      0   unless print $self->print_errors
674   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
683   ***      0      0      0   unless $$self{'got_opts'}
686   ***      0      0      0   $$_{'is_negatable'} ? :
690   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
706   ***      0      0      0   $group eq 'default' ? :
712   ***      0      0      0   $$opt{'is_negatable'} ? :
715   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
724   ***      0      0      0   if ($short) { }
733   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
737   ***      0      0      0   if ($$self{'dp'})
745   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
757   ***      0      0      0   if ref $_[0] eq 'OptionParser'
760   ***      0      0      0   unless print $prompt
768   ***      0      0      0   unless print "\n"
771   ***      0      0      0   if ($EVAL_ERROR)
793   ***     50     16      0   unless open my $fh, '<', $filename
801   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
804   ***      0      0      0   if ($line eq '--')
809   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
827   ***      0      0      0   unless open my $fh, '<', $file
831   ***      0      0      0   unless $para =~ /^=pod$/m
835   ***      0      0      0   unless $para =~ /$regex/
840   ***      0      0      0   unless close $fh
854   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
869   ***      0      0      0   defined $_ ? :
910   ***      0      0      0   if (defined $_) { }
912   ***      0      0      0   $_ eq '' || $_ =~ /^0|\D/ ? :
925   ***      0      0      0   if (not $tbl)
1009  ***     50      0     24   if (@_ > 2)
1018         100      4      8   if (not $dsn)
1030  ***     50     22      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1042  ***     50      0     71   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1048         100     49     22   if (not defined $final_props{$key})
1055  ***     50      0     22   unless exists $opts{$key}
1058  ***     50      0      8   if (my $required = $self->prop('required'))
1060  ***      0      0      0   unless $final_props{$key}
1069  ***     50      0      4   unless ref $o eq 'OptionParser'
1072         100     28      8   if $o->has($_)
1082  ***      0      0      0   unless ref $dsn
1083  ***      0      0      0   $_ eq 'p' ? :
1084  ***      0      0      0   if defined $$dsn{$_}
1097  ***      0      0      0   $opts{$key}{'copy'} ? :
1111  ***     50      0      8   if ($driver eq 'Pg') { }
1143  ***     50      0      8   $cxn_string =~ /charset=utf8/ ? :
1161  ***     50      8      0   if ($cxn_string =~ /mysql/i)
1169  ***     50      0      8   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1174  ***      0      0      0   if ($charset eq 'utf8') { }
1175  ***      0      0      0   unless binmode STDOUT, ':utf8'
1179  ***      0      0      0   unless binmode STDOUT
1183  ***     50      0      8   if ($self->prop('setvars'))
1190  ***     50      0      8   if (not $dbh and $EVAL_ERROR)
1192  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/)
1196  ***      0      0      0   if (not $tries)
1218  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1235  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1245  ***     50      0      3   unless $dsn_1
1246  ***     50      0      3   unless $dsn_2
1250  ***     50      0     27   if ($args{'overwrite'}) { }
1251  ***      0      0      0   defined $$dsn_1{$key} ? :
1254         100     12     15   defined $$dsn_2{$key} ? :
1263  ***      0      0      0   defined $_ ? :
1292  ***      0      0      0   unless $args{$arg}
1295  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
1311  ***      0      0      0   unless defined(my $pid = fork)
1312  ***      0      0      0   if ($pid)
1319  ***      0      0      0   unless POSIX::setsid()
1320  ***      0      0      0   unless chdir '/'
1324  ***      0      0      0   if (-t STDIN)
1326  ***      0      0      0   unless open STDIN, '/dev/null'
1330  ***      0      0      0   if ($$self{'log_file'})
1332  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
1336  ***      0      0      0   unless open STDERR, '>&STDOUT'
1346  ***      0      0      0   $self ? :
1348  ***      0      0      0   if ($PID_file and -f $PID_file) { }
1351  ***      0      0      0   if $EVAL_ERROR
1353  ***      0      0      0   if ($pid) { }
1355  ***      0      0      0   if ($pid_is_alive) { }
1377  ***      0      0      0   if (exists $$self{'child'})
1389  ***      0      0      0   if (not $PID_file)
1396  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
1398  ***      0      0      0   unless print $PID_FH $PID
1400  ***      0      0      0   unless close $PID_FH
1409  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
1410  ***      0      0      0   unless unlink $$self{'PID_file'}
1422  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
1428  ***      0      0      0   defined $_ ? :
1477  ***      0      0      0   defined $args{'p_ms'} ? :
1478  ***      0      0      0   defined $args{'p_s'} ? :
1481  ***      0      0      0   if $t < 0
1485  ***      0      0      0   if $t =~ /e/
1491  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
1513  ***      0      0      0   $p ? :
1520  ***      0      0      0   unless $secs
1523  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
1528  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
1547  ***      0      0      0   defined $args{'p'} ? :
1548  ***      0      0      0   defined $args{'d'} ? :
1555  ***      0      0      0   $num =~ /\./ || $n ? :
1576  ***     50      3      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^$mysql_ts$/)
1579  ***     50      0      3   defined $f ? :
      ***     50      0      3   defined $f ? :
1590  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s) = $val =~ /^$proper_ts$/)
1610  ***      0      0      0   if (my($n, $suffix) = $val =~ /^$n_ts$/) { }
      ***      0      0      0   elsif ($val =~ /^$mysql_ts$/) { }
      ***      0      0      0   elsif ($val =~ /^$proper_ts$/) { }
1611  ***      0      0      0   $suffix eq 'd' ? :
      ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1629  ***      0      0      0   if $callback and ref $callback eq 'CODE'
1646  ***      0      0      0   defined $_ ? :
1704  ***     50      4      0   if (@ARGV)
1710         100      3      1   if ($src_dsn and $dst_dsn)
1716  ***     50      4      0   if (not $o->get('help'))
1717  ***     50      0      4   if (not $src_dsn)
1720  ***     50      0      4   if ($dst_dsn and not $$dst_dsn{'D'})
1723  ***     50      0      4   if ($dst_dsn and not $$dst_dsn{'t'})
1752  ***     50      0      4   if (not $$src_dsn{'h'})
1757         100      3      1   if ($dst_dsn)
1768  ***     50      0      4   if ($o->get('daemonize'))
1784         100      3      1   if $ins_sth
1785         100      1      3   if $o->get('print') or not $o->got('dest')
1789  ***     50      0      4   if ($o->get('interval')) { }
1809  ***     50      0      9   unless $text =~ /LATEST FOREIGN KEY ERROR/
1814  ***     50      9      0   if $fke
1832  ***     50      0      7   if ($o->get('ask-pass'))
1842  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
257          100     20     52      4   $type and $type eq 'd'
      ***     66     72      4      0   $type and $type eq 'd' and not $$self{'dp'}
262          100     20     40     16   $type and $type =~ /[HhAadzm]/
416   ***     33      0      4      0   @ARGV and $ARGV[0] eq '--config'
445   ***     33      0      4      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
452   ***     33      0      4      0   @ARGV and $$self{'strict'}
536   ***     66      0     20     56   $opt and $$opt{'type'}
539   ***     66     45     11      0   $val and $$opt{'type'} eq 'm'
             100     45      8      3   $val and $$opt{'type'} eq 'd'
      ***     66     45      8      0   $val and $$opt{'type'} eq 'z'
      ***     66     45      8      0   defined $val and $$opt{'type'} eq 'h'
      ***     66     45      4      0   defined $val and $$opt{'type'} eq 'a'
604   ***     33      0      0     63   $long and exists $$self{'opts'}{$long}
612   ***     33      0      0     20   $long and exists $$self{'opts'}{$long}
626   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
715   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
809   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1042  ***     66     22     49      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33     71      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1154  ***     66      8      0      8   not $dbh and $tries--
1190  ***     33      8      0      0   not $dbh and $EVAL_ERROR
1348  ***      0      0      0      0   $PID_file and -f $PID_file
1409  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
1491  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
1551  ***      0      0      0      0   $num >= $d and $n < @units - 1
1629  ***      0      0      0      0   $callback and ref $callback eq 'CODE'
1710  ***     66      0      1      3   $src_dsn and $dst_dsn
1720  ***     66      1      3      0   $dst_dsn and not $$dst_dsn{'D'}
1723  ***     66      1      3      0   $dst_dsn and not $$dst_dsn{'t'}
1775  ***     66      0      4      4   $start == $end || $now < $end and $oktorun

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
61    ***     50      4      0   $program_name ||= $PROGRAM_NAME
62    ***     50      4      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
64    ***     50      4      0   $args{'prompt'} || '<options>'
      ***     50      4      0   $args{'dp'} || undef
106   ***     50      0      4   $file ||= '../mk-fk-error-logger'
247   ***     50     76      0   $$opt{'group'} ||= 'default'
544   ***      0      0      0   $s || 's'
581   ***      0      0      0   $pre || ''
588   ***      0      0      0   $val || ''
591   ***     50      4      0   $val || ''
649   ***      0      0      0   $$self{'description'} || ''
717   ***      0      0      0   $s ||= 's'
743   ***      0      0      0   $$opt{'type'} || ''
1023         100      3      5   $prev ||= {}
1024  ***     50      0      8   $defaults ||= {}
1097  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1110  ***     50      0      8   $self->prop('dbidriver') || ''
1114  ***      0      0      0   $$info{'D'} || ''
1120         100      3      5   $$info{'D'} || ''
1142  ***     50      8      0   $opts ||= {}
1218  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1234  ***      0      0      0   $level ||= 0
1235  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1512  ***      0      0      0   $args{'p'} || 0
1514  ***      0      0      0   $of ||= 1
1519  ***      0      0      0   $secs ||= 0
1745  ***     50      0      4   $o->get('run-time') || 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
62    ***     33      4      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***     33      4      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
539   ***     33      0      0     53   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***     66      4      0     49   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
912   ***      0      0      0      0   $_ eq '' || $_ =~ /^0|\D/
1133  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1134  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1135  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1136  ***      0      0      0      0   $$dsn{'u'} ||= $user
1137  ***      0      0      0      0   $$dsn{'D'} ||= $db
1422  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
1523  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
1555  ***      0      0      0      0   $num =~ /\./ || $n
1775  ***     33      8      0      0   $start == $end || $now < $end
1785  ***     66      0      1      3   $o->get('print') or not $o->got('dest')


Covered Subroutines
-------------------

Subroutine           Count Location                                                           
-------------------- ----- -------------------------------------------------------------------
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1281
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1282
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1284
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1285
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1287
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1447
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1448
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1449
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1450
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1451
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1453
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1668
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1669
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1671
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:23  
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:24  
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:35  
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:36  
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:38  
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:39  
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:40  
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:42  
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:884 
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:885 
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:889 
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:891 
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:941 
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:942 
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:946 
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:947 
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:950 
BEGIN                    1 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:952 
__ANON__                 3 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:440 
_parse_specs             4 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:211 
_pod_to_specs            4 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:105 
_read_config_file       16 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:792 
_set_option              3 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:386 
_validate_type          76 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:535 
copy                     3 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1244
get                     63 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:602 
get_cxn                  7 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1828
get_cxn_params           8 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1107
get_dbh                  8 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1141
get_defaults_files       4 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:100 
get_fk_error             9 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1806
get_opts                 4 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:403 
get_specs                4 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:93  
got                     20 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:610 
has                     40 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:618 
main                     4 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1678
new                      4 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:56  
new                      4 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:894 
new                      5 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:955 
parse                   12 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1017
parse_options            4 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1068
parse_timestamp          3 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1575
prop                    24 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1008
quote                    6 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:899 
usage_or_errors          4 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:659 

Uncovered Subroutines
---------------------

Subroutine           Count Location                                                           
-------------------- ----- -------------------------------------------------------------------
DESTROY                  0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1421
_d                       0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1262
_d                       0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1427
_d                       0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1645
_d                       0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1841
_d                       0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:868 
_get_participants        0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:330 
_make_PID_file           0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1386
_remove_PID_file         0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1408
any_unix_timestamp       0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1608
as_string                0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1081
check_PID_file           0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1345
clone                    0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:845 
daemonize                0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1308
descr                    0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:648 
disconnect               0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1227
errors                   0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:638 
fill_in_dsn              0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1129
finish                   0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1822
get_defaults             0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:376 
get_groups               0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:381 
get_hostname             0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1217
make_PID_file            0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1376
make_checksum            0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1638
micro_t                  0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1476
new                      0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1290
opt_values               0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:348 
opts                     0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:342 
percentage_of            0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1511
print_active_handles     0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1233
print_errors             0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:672 
print_usage              0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:682 
prompt                   0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:643 
prompt_noecho            0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:757 
quote_val                0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:907 
read_para_after          0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:826 
save_error               0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:633 
secs_to_time             0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1518
set                      0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:624 
set_defaults             0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:364 
short_opts               0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:358 
shorten                  0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1546
split_unquote            0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:922 
ts                       0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1563
unix_timestamp           0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1589
usage                    0 /home/daniel/dev/maatkit/mk-fk-error-logger/mk-fk-error-logger:1090


