---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...rofiler/mk-query-profiler   14.2    3.2    7.1   33.3    n/a    0.4   11.2
mk-query-profiler.t           100.0   50.0   33.3  100.0    n/a   99.6   89.8
Total                          17.9    3.6    7.9   38.5    n/a  100.0   13.9
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:30:42 2010
Finish:       Thu Jan 28 22:30:42 2010

Run:          ./mk-query-profiler.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:30:44 2010
Finish:       Thu Jan 28 22:30:44 2010

/home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This is mk-query-profiler, a program to analyze MySQL workload.
4                                                     # 
5                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
6                                                     # Feedback and improvements are welcome.
7                                                     #
8                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
9                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
10                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
11                                                    #
12                                                    # This program is free software; you can redistribute it and/or modify it under
13                                                    # the terms of the GNU General Public License as published by the Free Software
14                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
15                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
16                                                    # licenses.
17                                                    #
18                                                    # You should have received a copy of the GNU General Public License along with
19                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
20                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
21                                                    
22             1                    1             8   use strict;
               1                                  2   
               1                                 11   
23             1                    1             7   use warnings FATAL => 'all';
               1                                  2   
               1                                  8   
24                                                    
25                                                    our $VERSION = '@VERSION@';
26                                                    our $DISTRIB = '@DISTRIB@';
27                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5425 $ =~ m/(\d+)/g, 0));
28                                                    
29                                                    # ###########################################################################
30                                                    # OptionParser package 5266
31                                                    # ###########################################################################
32                                                    package OptionParser;
33                                                    
34             1                    1             6   use strict;
               1                                  4   
               1                                  5   
35             1                    1             7   use warnings FATAL => 'all';
               1                                  3   
               1                                  5   
36                                                    
37             1                    1            11   use Getopt::Long;
               1                                  4   
               1                                  9   
38             1                    1             9   use List::Util qw(max);
               1                                  2   
               1                                 12   
39             1                    1             7   use English qw(-no_match_vars);
               1                                  2   
               1                                  7   
40                                                    
41    ***      1            50      1            13   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 20   
42                                                    
43                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
44                                                    
45                                                    my %attributes = (
46                                                       'type'       => 1,
47                                                       'short form' => 1,
48                                                       'group'      => 1,
49                                                       'default'    => 1,
50                                                       'cumulative' => 1,
51                                                       'negatable'  => 1,
52                                                    );
53                                                    
54                                                    sub new {
55    ***      0                    0             0      my ( $class, %args ) = @_;
56    ***      0                                  0      foreach my $arg ( qw(description) ) {
57    ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
58                                                       }
59    ***      0                                  0      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
60    ***      0             0                    0      $program_name ||= $PROGRAM_NAME;
61    ***      0             0                    0      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                    0                        
      ***                    0                        
62                                                    
63    ***      0      0      0                    0      my $self = {
      ***                    0                        
64                                                          description    => $args{description},
65                                                          prompt         => $args{prompt} || '<options>',
66                                                          strict         => (exists $args{strict} ? $args{strict} : 1),
67                                                          dp             => $args{dp}     || undef,
68                                                          program_name   => $program_name,
69                                                          opts           => {},
70                                                          got_opts       => 0,
71                                                          short_opts     => {},
72                                                          defaults       => {},
73                                                          groups         => {},
74                                                          allowed_groups => {},
75                                                          errors         => [],
76                                                          rules          => [],  # desc of rules for --help
77                                                          mutex          => [],  # rule: opts are mutually exclusive
78                                                          atleast1       => [],  # rule: at least one opt is required
79                                                          disables       => {},  # rule: opt disables other opts 
80                                                          defaults_to    => {},  # rule: opt defaults to value of other opt
81                                                          default_files  => [
82                                                             "/etc/maatkit/maatkit.conf",
83                                                             "/etc/maatkit/$program_name.conf",
84                                                             "$home/.maatkit.conf",
85                                                             "$home/.$program_name.conf",
86                                                          ],
87                                                       };
88    ***      0                                  0      return bless $self, $class;
89                                                    }
90                                                    
91                                                    sub get_specs {
92    ***      0                    0             0      my ( $self, $file ) = @_;
93    ***      0                                  0      my @specs = $self->_pod_to_specs($file);
94    ***      0                                  0      $self->_parse_specs(@specs);
95    ***      0                                  0      return;
96                                                    }
97                                                    
98                                                    sub get_defaults_files {
99    ***      0                    0             0      my ( $self ) = @_;
100   ***      0                                  0      return @{$self->{default_files}};
      ***      0                                  0   
101                                                   }
102                                                   
103                                                   sub _pod_to_specs {
104   ***      0                    0             0      my ( $self, $file ) = @_;
105   ***      0             0                    0      $file ||= __FILE__;
106   ***      0      0                           0      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
107                                                   
108   ***      0                                  0      my %types = (
109                                                         string => 's', # standard Getopt type
110                                                         'int'  => 'i', # standard Getopt type
111                                                         float  => 'f', # standard Getopt type
112                                                         Hash   => 'H', # hash, formed from a comma-separated list
113                                                         hash   => 'h', # hash as above, but only if a value is given
114                                                         Array  => 'A', # array, similar to Hash
115                                                         array  => 'a', # array, similar to hash
116                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
117                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
118                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
119                                                      );
120   ***      0                                  0      my @specs = ();
121   ***      0                                  0      my @rules = ();
122   ***      0                                  0      my $para;
123                                                   
124   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
125   ***      0                                  0      while ( $para = <$fh> ) {
126   ***      0      0                           0         next unless $para =~ m/^=head1 OPTIONS/;
127   ***      0                                  0         last;
128                                                      }
129                                                   
130   ***      0                                  0      while ( $para = <$fh> ) {
131   ***      0      0                           0         last if $para =~ m/^=over/;
132   ***      0                                  0         chomp $para;
133   ***      0                                  0         $para =~ s/\s+/ /g;
134   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
135   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
136   ***      0                                  0         push @rules, $para;
137                                                      }
138                                                   
139   ***      0      0                           0      die 'POD has no OPTIONS section' unless $para;
140                                                   
141   ***      0                                  0      do {
142   ***      0      0                           0         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
143   ***      0                                  0            chomp $para;
144   ***      0                                  0            MKDEBUG && _d($para);
145   ***      0                                  0            my %attribs;
146                                                   
147   ***      0                                  0            $para = <$fh>; # read next paragraph, possibly attributes
148                                                   
149   ***      0      0                           0            if ( $para =~ m/: / ) { # attributes
150   ***      0                                  0               $para =~ s/\s+\Z//g;
151   ***      0                                  0               %attribs = map {
152   ***      0                                  0                     my ( $attrib, $val) = split(/: /, $_);
153   ***      0      0                           0                     die "Unrecognized attribute for --$option: $attrib"
154                                                                        unless $attributes{$attrib};
155   ***      0                                  0                     ($attrib, $val);
156                                                                  } split(/; /, $para);
157   ***      0      0                           0               if ( $attribs{'short form'} ) {
158   ***      0                                  0                  $attribs{'short form'} =~ s/-//;
159                                                               }
160   ***      0                                  0               $para = <$fh>; # read next paragraph, probably short help desc
161                                                            }
162                                                            else {
163   ***      0                                  0               MKDEBUG && _d('Option has no attributes');
164                                                            }
165                                                   
166   ***      0                                  0            $para =~ s/\s+\Z//g;
167   ***      0                                  0            $para =~ s/\s+/ /g;
168   ***      0                                  0            $para =~ s/$POD_link_re/$1/go;
169                                                   
170   ***      0                                  0            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
171   ***      0                                  0            MKDEBUG && _d('Short help:', $para);
172                                                   
173   ***      0      0                           0            die "No description after option spec $option" if $para =~ m/^=item/;
174                                                   
175   ***      0      0                           0            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
176   ***      0                                  0               $option = $base_option;
177   ***      0                                  0               $attribs{'negatable'} = 1;
178                                                            }
179                                                   
180   ***      0      0                           0            push @specs, {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
181                                                               spec  => $option
182                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
183                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
184                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
185                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
186                                                               desc  => $para
187                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
188                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
189                                                            };
190                                                         }
191   ***      0                                  0         while ( $para = <$fh> ) {
192   ***      0      0                           0            last unless $para;
193                                                   
194                                                   
195   ***      0      0                           0            if ( $para =~ m/^=head1/ ) {
196   ***      0                                  0               $para = undef; # Can't 'last' out of a do {} block.
197   ***      0                                  0               last;
198                                                            }
199   ***      0      0                           0            last if $para =~ m/^=item --/;
200                                                         }
201                                                      } while ( $para );
202                                                   
203   ***      0      0                           0      die 'No valid specs in POD OPTIONS' unless @specs;
204                                                   
205   ***      0                                  0      close $fh;
206   ***      0                                  0      return @specs, @rules;
207                                                   }
208                                                   
209                                                   sub _parse_specs {
210   ***      0                    0             0      my ( $self, @specs ) = @_;
211   ***      0                                  0      my %disables; # special rule that requires deferred checking
212                                                   
213   ***      0                                  0      foreach my $opt ( @specs ) {
214   ***      0      0                           0         if ( ref $opt ) { # It's an option spec, not a rule.
215                                                            MKDEBUG && _d('Parsing opt spec:',
216   ***      0                                  0               map { ($_, '=>', $opt->{$_}) } keys %$opt);
217                                                   
218   ***      0                                  0            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
219   ***      0      0                           0            if ( !$long ) {
220   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
221                                                            }
222   ***      0                                  0            $opt->{long} = $long;
223                                                   
224   ***      0      0                           0            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
225   ***      0                                  0            $self->{opts}->{$long} = $opt;
226                                                   
227   ***      0      0                           0            if ( length $long == 1 ) {
228   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
229   ***      0                                  0               $self->{short_opts}->{$long} = $long;
230                                                            }
231                                                   
232   ***      0      0                           0            if ( $short ) {
233   ***      0      0                           0               die "Duplicate short option -$short"
234                                                                  if exists $self->{short_opts}->{$short};
235   ***      0                                  0               $self->{short_opts}->{$short} = $long;
236   ***      0                                  0               $opt->{short} = $short;
237                                                            }
238                                                            else {
239   ***      0                                  0               $opt->{short} = undef;
240                                                            }
241                                                   
242   ***      0      0                           0            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
243   ***      0      0                           0            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
244   ***      0      0                           0            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
245                                                   
246   ***      0             0                    0            $opt->{group} ||= 'default';
247   ***      0                                  0            $self->{groups}->{ $opt->{group} }->{$long} = 1;
248                                                   
249   ***      0                                  0            $opt->{value} = undef;
250   ***      0                                  0            $opt->{got}   = 0;
251                                                   
252   ***      0                                  0            my ( $type ) = $opt->{spec} =~ m/=(.)/;
253   ***      0                                  0            $opt->{type} = $type;
254   ***      0                                  0            MKDEBUG && _d($long, 'type:', $type);
255                                                   
256   ***      0      0      0                    0            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                    0                        
257   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
258                                                                  . "was given when this OptionParser object was created";
259                                                            }
260                                                   
261   ***      0      0      0                    0            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
262                                                   
263   ***      0      0                           0            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
264   ***      0      0                           0               $self->{defaults}->{$long} = defined $def ? $def : 1;
265   ***      0                                  0               MKDEBUG && _d($long, 'default:', $def);
266                                                            }
267                                                   
268   ***      0      0                           0            if ( $long eq 'config' ) {
269   ***      0                                  0               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
270                                                            }
271                                                   
272   ***      0      0                           0            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
273   ***      0                                  0               $disables{$long} = $dis;
274   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
275                                                            }
276                                                   
277   ***      0                                  0            $self->{opts}->{$long} = $opt;
278                                                         }
279                                                         else { # It's an option rule, not a spec.
280   ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
281   ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
282   ***      0                                  0            my @participants = $self->_get_participants($opt);
283   ***      0                                  0            my $rule_ok = 0;
284                                                   
285   ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
286   ***      0                                  0               $rule_ok = 1;
287   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
288   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
289                                                            }
290   ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
291   ***      0                                  0               $rule_ok = 1;
292   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
293   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
294                                                            }
295   ***      0      0                           0            if ( $opt =~ m/default to/ ) {
296   ***      0                                  0               $rule_ok = 1;
297   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
298   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
299                                                            }
300   ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
301   ***      0                                  0               $rule_ok = 1;
302   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
303   ***      0                                  0               my @groups = split(',', $groups);
304   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
305   ***      0                                  0                  s/\s+//;
306   ***      0                                  0                  $_ => 1;
307                                                               } @groups;
308                                                            }
309                                                   
310   ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
311                                                         }
312                                                      }
313                                                   
314   ***      0                                  0      foreach my $long ( keys %disables ) {
315   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
316   ***      0                                  0         $self->{disables}->{$long} = \@participants;
317   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
318                                                      }
319                                                   
320   ***      0                                  0      return; 
321                                                   }
322                                                   
323                                                   sub _get_participants {
324   ***      0                    0             0      my ( $self, $str ) = @_;
325   ***      0                                  0      my @participants;
326   ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
327   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
328                                                            unless exists $self->{opts}->{$long};
329   ***      0                                  0         push @participants, $long;
330                                                      }
331   ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
332   ***      0                                  0      return @participants;
333                                                   }
334                                                   
335                                                   sub opts {
336   ***      0                    0             0      my ( $self ) = @_;
337   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
338   ***      0                                  0      return %opts;
339                                                   }
340                                                   
341                                                   sub short_opts {
342   ***      0                    0             0      my ( $self ) = @_;
343   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
344   ***      0                                  0      return %short_opts;
345                                                   }
346                                                   
347                                                   sub set_defaults {
348   ***      0                    0             0      my ( $self, %defaults ) = @_;
349   ***      0                                  0      $self->{defaults} = {};
350   ***      0                                  0      foreach my $long ( keys %defaults ) {
351   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
352                                                            unless exists $self->{opts}->{$long};
353   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
354   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
355                                                      }
356   ***      0                                  0      return;
357                                                   }
358                                                   
359                                                   sub get_defaults {
360   ***      0                    0             0      my ( $self ) = @_;
361   ***      0                                  0      return $self->{defaults};
362                                                   }
363                                                   
364                                                   sub get_groups {
365   ***      0                    0             0      my ( $self ) = @_;
366   ***      0                                  0      return $self->{groups};
367                                                   }
368                                                   
369                                                   sub _set_option {
370   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
371   ***      0      0                           0      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***             0                               
372                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
373                                                               : die "Getopt::Long gave a nonexistent option: $opt";
374                                                   
375   ***      0                                  0      $opt = $self->{opts}->{$long};
376   ***      0      0                           0      if ( $opt->{is_cumulative} ) {
377   ***      0                                  0         $opt->{value}++;
378                                                      }
379                                                      else {
380   ***      0                                  0         $opt->{value} = $val;
381                                                      }
382   ***      0                                  0      $opt->{got} = 1;
383   ***      0                                  0      MKDEBUG && _d('Got option', $long, '=', $val);
384                                                   }
385                                                   
386                                                   sub get_opts {
387   ***      0                    0             0      my ( $self ) = @_; 
388                                                   
389   ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
390   ***      0                                  0         $self->{opts}->{$long}->{got} = 0;
391   ***      0      0                           0         $self->{opts}->{$long}->{value}
      ***             0                               
392                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
393                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
394                                                            : undef;
395                                                      }
396   ***      0                                  0      $self->{got_opts} = 0;
397                                                   
398   ***      0                                  0      $self->{errors} = [];
399                                                   
400   ***      0      0      0                    0      if ( @ARGV && $ARGV[0] eq "--config" ) {
401   ***      0                                  0         shift @ARGV;
402   ***      0                                  0         $self->_set_option('config', shift @ARGV);
403                                                      }
404   ***      0      0                           0      if ( $self->has('config') ) {
405   ***      0                                  0         my @extra_args;
406   ***      0                                  0         foreach my $filename ( split(',', $self->get('config')) ) {
407   ***      0                                  0            eval {
408   ***      0                                  0               push @extra_args, $self->_read_config_file($filename);
409                                                            };
410   ***      0      0                           0            if ( $EVAL_ERROR ) {
411   ***      0      0                           0               if ( $self->got('config') ) {
412   ***      0                                  0                  die $EVAL_ERROR;
413                                                               }
414                                                               elsif ( MKDEBUG ) {
415                                                                  _d($EVAL_ERROR);
416                                                               }
417                                                            }
418                                                         }
419   ***      0                                  0         unshift @ARGV, @extra_args;
420                                                      }
421                                                   
422   ***      0                                  0      Getopt::Long::Configure('no_ignore_case', 'bundling');
423                                                      GetOptions(
424   ***      0                    0             0         map    { $_->{spec} => sub { $self->_set_option(@_); } }
      ***      0                                  0   
      ***      0                                  0   
425   ***      0                                  0         grep   { $_->{long} ne 'config' } # --config is handled specially above.
426   ***      0      0                           0         values %{$self->{opts}}
427                                                      ) or $self->save_error('Error parsing options');
428                                                   
429   ***      0      0      0                    0      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
430   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
431                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
432                                                               or die "Cannot print: $OS_ERROR";
433   ***      0                                  0         exit 0;
434                                                      }
435                                                   
436   ***      0      0      0                    0      if ( @ARGV && $self->{strict} ) {
437   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
438                                                      }
439                                                   
440   ***      0                                  0      foreach my $mutex ( @{$self->{mutex}} ) {
      ***      0                                  0   
441   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
442   ***      0      0                           0         if ( @set > 1 ) {
443   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
444   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
445                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
446                                                                    . ' are mutually exclusive.';
447   ***      0                                  0            $self->save_error($err);
448                                                         }
449                                                      }
450                                                   
451   ***      0                                  0      foreach my $required ( @{$self->{atleast1}} ) {
      ***      0                                  0   
452   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
453   ***      0      0                           0         if ( @set == 0 ) {
454   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
455   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
456                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
457   ***      0                                  0            $self->save_error("Specify at least one of $err");
458                                                         }
459                                                      }
460                                                   
461   ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
462   ***      0                                  0         my $opt = $self->{opts}->{$long};
463   ***      0      0                           0         if ( $opt->{got} ) {
      ***             0                               
464   ***      0      0                           0            if ( exists $self->{disables}->{$long} ) {
465   ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
466   ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
467   ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
468                                                                  'because', $long,'disables them');
469                                                            }
470                                                   
471   ***      0      0                           0            if ( exists $self->{allowed_groups}->{$long} ) {
472                                                   
473   ***      0                                  0               my @restricted_groups = grep {
474   ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
475   ***      0                                  0               } keys %{$self->{groups}};
476                                                   
477   ***      0                                  0               my @restricted_opts;
478   ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
479   ***      0                                  0                  RESTRICTED_OPT:
480   ***      0                                  0                  foreach my $restricted_opt (
481                                                                     keys %{$self->{groups}->{$restricted_group}} )
482                                                                  {
483   ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
484   ***      0      0                           0                     push @restricted_opts, $restricted_opt
485                                                                        if $self->{opts}->{$restricted_opt}->{got};
486                                                                  }
487                                                               }
488                                                   
489   ***      0      0                           0               if ( @restricted_opts ) {
490   ***      0                                  0                  my $err;
491   ***      0      0                           0                  if ( @restricted_opts == 1 ) {
492   ***      0                                  0                     $err = "--$restricted_opts[0]";
493                                                                  }
494                                                                  else {
495   ***      0                                  0                     $err = join(', ',
496   ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
497   ***      0                                  0                               grep { $_ } 
498                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
499                                                                            )
500                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
501                                                                  }
502   ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
503                                                               }
504                                                            }
505                                                   
506                                                         }
507                                                         elsif ( $opt->{is_required} ) { 
508   ***      0                                  0            $self->save_error("Required option --$long must be specified");
509                                                         }
510                                                   
511   ***      0                                  0         $self->_validate_type($opt);
512                                                      }
513                                                   
514   ***      0                                  0      $self->{got_opts} = 1;
515   ***      0                                  0      return;
516                                                   }
517                                                   
518                                                   sub _validate_type {
519   ***      0                    0             0      my ( $self, $opt ) = @_;
520   ***      0      0      0                    0      return unless $opt && $opt->{type};
521   ***      0                                  0      my $val = $opt->{value};
522                                                   
523   ***      0      0      0                    0      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
      ***                    0                        
524   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
525   ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
526   ***      0      0                           0         if ( !$suffix ) {
527   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
528   ***      0             0                    0            $suffix = $s || 's';
529   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
530                                                               $opt->{long}, '(value:', $val, ')');
531                                                         }
532   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
533   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
534                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
535                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
536                                                                 :                  $num * 86400;   # Days
537   ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
538   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
539                                                         }
540                                                         else {
541   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
542                                                         }
543                                                      }
544                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
545   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
546   ***      0                                  0         my $prev = {};
547   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
548   ***      0      0                           0         if ( $from_key ) {
549   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
550   ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
551                                                         }
552   ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
553   ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
554                                                      }
555                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
556   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
557   ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
558   ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
559   ***      0      0                           0         if ( defined $num ) {
560   ***      0      0                           0            if ( $factor ) {
561   ***      0                                  0               $num *= $factor_for{$factor};
562   ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
563                                                                  'to num', $num, '* factor', $factor);
564                                                            }
565   ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
566                                                         }
567                                                         else {
568   ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
569                                                         }
570                                                      }
571                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
572   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
573                                                      }
574                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
575   ***      0             0                    0         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
576                                                      }
577                                                      else {
578   ***      0                                  0         MKDEBUG && _d('Nothing to validate for option',
579                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
580                                                      }
581                                                   
582   ***      0                                  0      return;
583                                                   }
584                                                   
585                                                   sub get {
586   ***      0                    0             0      my ( $self, $opt ) = @_;
587   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
588   ***      0      0      0                    0      die "Option $opt does not exist"
589                                                         unless $long && exists $self->{opts}->{$long};
590   ***      0                                  0      return $self->{opts}->{$long}->{value};
591                                                   }
592                                                   
593                                                   sub got {
594   ***      0                    0             0      my ( $self, $opt ) = @_;
595   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
596   ***      0      0      0                    0      die "Option $opt does not exist"
597                                                         unless $long && exists $self->{opts}->{$long};
598   ***      0                                  0      return $self->{opts}->{$long}->{got};
599                                                   }
600                                                   
601                                                   sub has {
602   ***      0                    0             0      my ( $self, $opt ) = @_;
603   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
604   ***      0      0                           0      return defined $long ? exists $self->{opts}->{$long} : 0;
605                                                   }
606                                                   
607                                                   sub set {
608   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
609   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
610   ***      0      0      0                    0      die "Option $opt does not exist"
611                                                         unless $long && exists $self->{opts}->{$long};
612   ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
613   ***      0                                  0      return;
614                                                   }
615                                                   
616                                                   sub save_error {
617   ***      0                    0             0      my ( $self, $error ) = @_;
618   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
619                                                   }
620                                                   
621                                                   sub errors {
622   ***      0                    0             0      my ( $self ) = @_;
623   ***      0                                  0      return $self->{errors};
624                                                   }
625                                                   
626                                                   sub prompt {
627   ***      0                    0             0      my ( $self ) = @_;
628   ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
629                                                   }
630                                                   
631                                                   sub descr {
632   ***      0                    0             0      my ( $self ) = @_;
633   ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
634                                                                 . "  For more details, please use the --help option, "
635                                                                 . "or try 'perldoc $PROGRAM_NAME' "
636                                                                 . "for complete documentation.";
637   ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
638   ***      0                                  0      $descr =~ s/ +$//mg;
639   ***      0                                  0      return $descr;
640                                                   }
641                                                   
642                                                   sub usage_or_errors {
643   ***      0                    0             0      my ( $self ) = @_;
644   ***      0      0                           0      if ( $self->{opts}->{help}->{got} ) {
      ***      0      0                           0   
645   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
646   ***      0                                  0         exit 0;
647                                                      }
648                                                      elsif ( scalar @{$self->{errors}} ) {
649   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
650   ***      0                                  0         exit 0;
651                                                      }
652   ***      0                                  0      return;
653                                                   }
654                                                   
655                                                   sub print_errors {
656   ***      0                    0             0      my ( $self ) = @_;
657   ***      0                                  0      my $usage = $self->prompt() . "\n";
658   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
659   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
660                                                                 . "\n";
661                                                      }
662   ***      0                                  0      return $usage . "\n" . $self->descr();
663                                                   }
664                                                   
665                                                   sub print_usage {
666   ***      0                    0             0      my ( $self ) = @_;
667   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
668   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
669                                                   
670   ***      0      0                           0      my $maxl = max(
671   ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
672                                                         @opts);
673                                                   
674   ***      0      0                           0      my $maxs = max(0,
675   ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
676   ***      0                                  0         values %{$self->{short_opts}});
677                                                   
678   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
679   ***      0                                  0      my $rcol = 80 - $lcol - 6;
680   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
681                                                   
682   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
683                                                   
684   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
685                                                   
686   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
687   ***      0                                  0      push @groups, 'default';
688                                                   
689   ***      0                                  0      foreach my $group ( reverse @groups ) {
690   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
691   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
692   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
693                                                            grep { $_->{group} eq $group }
694                                                            @opts )
695                                                         {
696   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
697   ***      0                                  0            my $short = $opt->{short};
698   ***      0                                  0            my $desc  = $opt->{desc};
699   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
700   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
701   ***      0             0                    0               $s    ||= 's';
702   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
703   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
704                                                                      . "d=days; if no suffix, $s is used.";
705                                                            }
706   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
707   ***      0                                  0            $desc =~ s/ +$//mg;
708   ***      0      0                           0            if ( $short ) {
709   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
710                                                            }
711                                                            else {
712   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
713                                                            }
714                                                         }
715                                                      }
716                                                   
717   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
718   ***      0                                  0         $usage .= "\nRules:\n\n";
719   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
720                                                      }
721   ***      0      0                           0      if ( $self->{dp} ) {
722   ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
723                                                      }
724   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
725   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
726   ***      0                                  0         my $val   = $opt->{value};
727   ***      0             0                    0         my $type  = $opt->{type} || '';
728   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
729   ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
730                                                                   : !defined $val             ? '(No value)'
731                                                                   : $type eq 'd'              ? $self->{dp}->as_string($val)
732                                                                   : $type =~ m/H|h/           ? join(',', sort keys %$val)
733                                                                   : $type =~ m/A|a/           ? join(',', @$val)
734                                                                   :                             $val;
735   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
736                                                      }
737   ***      0                                  0      return $usage;
738                                                   }
739                                                   
740                                                   sub prompt_noecho {
741   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
742   ***      0                                  0      my ( $prompt ) = @_;
743   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
744   ***      0      0                           0      print $prompt
745                                                         or die "Cannot print: $OS_ERROR";
746   ***      0                                  0      my $response;
747   ***      0                                  0      eval {
748   ***      0                                  0         require Term::ReadKey;
749   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
750   ***      0                                  0         chomp($response = <STDIN>);
751   ***      0                                  0         Term::ReadKey::ReadMode('normal');
752   ***      0      0                           0         print "\n"
753                                                            or die "Cannot print: $OS_ERROR";
754                                                      };
755   ***      0      0                           0      if ( $EVAL_ERROR ) {
756   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
757                                                      }
758   ***      0                                  0      return $response;
759                                                   }
760                                                   
761                                                   if ( MKDEBUG ) {
762                                                      print '# ', $^X, ' ', $], "\n";
763                                                      my $uname = `uname -a`;
764                                                      if ( $uname ) {
765                                                         $uname =~ s/\s+/ /g;
766                                                         print "# $uname\n";
767                                                      }
768                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
769                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
770                                                         ($main::SVN_REV || ''), __LINE__);
771                                                      print('# Arguments: ',
772                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
773                                                   }
774                                                   
775                                                   sub _read_config_file {
776   ***      0                    0             0      my ( $self, $filename ) = @_;
777   ***      0      0                           0      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
778   ***      0                                  0      my @args;
779   ***      0                                  0      my $prefix = '--';
780   ***      0                                  0      my $parse  = 1;
781                                                   
782                                                      LINE:
783   ***      0                                  0      while ( my $line = <$fh> ) {
784   ***      0                                  0         chomp $line;
785   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
786   ***      0                                  0         $line =~ s/\s+#.*$//g;
787   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
788   ***      0      0                           0         if ( $line eq '--' ) {
789   ***      0                                  0            $prefix = '';
790   ***      0                                  0            $parse  = 0;
791   ***      0                                  0            next LINE;
792                                                         }
793   ***      0      0      0                    0         if ( $parse
      ***             0                               
794                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
795                                                         ) {
796   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
797                                                         }
798                                                         elsif ( $line =~ m/./ ) {
799   ***      0                                  0            push @args, $line;
800                                                         }
801                                                         else {
802   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
803                                                         }
804                                                      }
805   ***      0                                  0      close $fh;
806   ***      0                                  0      return @args;
807                                                   }
808                                                   
809                                                   sub read_para_after {
810   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
811   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
812   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
813   ***      0                                  0      my $para;
814   ***      0                                  0      while ( $para = <$fh> ) {
815   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
816   ***      0                                  0         last;
817                                                      }
818   ***      0                                  0      while ( $para = <$fh> ) {
819   ***      0      0                           0         next unless $para =~ m/$regex/;
820   ***      0                                  0         last;
821                                                      }
822   ***      0                                  0      $para = <$fh>;
823   ***      0                                  0      chomp($para);
824   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
825   ***      0                                  0      return $para;
826                                                   }
827                                                   
828                                                   sub clone {
829   ***      0                    0             0      my ( $self ) = @_;
830                                                   
831   ***      0                                  0      my %clone = map {
832   ***      0                                  0         my $hashref  = $self->{$_};
833   ***      0                                  0         my $val_copy = {};
834   ***      0                                  0         foreach my $key ( keys %$hashref ) {
835   ***      0                                  0            my $ref = ref $hashref->{$key};
836   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
837   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
838   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
839                                                                              : $hashref->{$key};
840                                                         }
841   ***      0                                  0         $_ => $val_copy;
842                                                      } qw(opts short_opts defaults);
843                                                   
844   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
845   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
846                                                      }
847                                                   
848   ***      0                                  0      return bless \%clone;     
849                                                   }
850                                                   
851                                                   sub _d {
852   ***      0                    0             0      my ($package, undef, $line) = caller 0;
853   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
854   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
855                                                           @_;
856   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
857                                                   }
858                                                   
859                                                   1;
860                                                   
861                                                   # ###########################################################################
862                                                   # End OptionParser package
863                                                   # ###########################################################################
864                                                   
865                                                   # ###########################################################################
866                                                   # DSNParser package 5266
867                                                   # ###########################################################################
868                                                   package DSNParser;
869                                                   
870            1                    1            13   use strict;
               1                                  4   
               1                                  9   
871            1                    1             7   use warnings FATAL => 'all';
               1                                  2   
               1                                  9   
872            1                    1             6   use English qw(-no_match_vars);
               1                                  4   
               1                                  8   
873            1                    1            12   use Data::Dumper;
               1                                  3   
               1                                 19   
874                                                   $Data::Dumper::Indent    = 0;
875                                                   $Data::Dumper::Quotekeys = 0;
876                                                   
877                                                   eval {
878                                                      require DBI;
879                                                   };
880                                                   my $have_dbi = $EVAL_ERROR ? 0 : 1;
881                                                   
882   ***      1            50      1             9   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 20   
883                                                   
884                                                   sub new {
885            1                    1             5      my ( $class, @opts ) = @_;
886            1                                 25      my $self = {
887                                                         opts => {
888                                                            A => {
889                                                               desc => 'Default character set',
890                                                               dsn  => 'charset',
891                                                               copy => 1,
892                                                            },
893                                                            D => {
894                                                               desc => 'Database to use',
895                                                               dsn  => 'database',
896                                                               copy => 1,
897                                                            },
898                                                            F => {
899                                                               desc => 'Only read default options from the given file',
900                                                               dsn  => 'mysql_read_default_file',
901                                                               copy => 1,
902                                                            },
903                                                            h => {
904                                                               desc => 'Connect to host',
905                                                               dsn  => 'host',
906                                                               copy => 1,
907                                                            },
908                                                            p => {
909                                                               desc => 'Password to use when connecting',
910                                                               dsn  => 'password',
911                                                               copy => 1,
912                                                            },
913                                                            P => {
914                                                               desc => 'Port number to use for connection',
915                                                               dsn  => 'port',
916                                                               copy => 1,
917                                                            },
918                                                            S => {
919                                                               desc => 'Socket file to use for connection',
920                                                               dsn  => 'mysql_socket',
921                                                               copy => 1,
922                                                            },
923                                                            u => {
924                                                               desc => 'User for login if not current user',
925                                                               dsn  => 'user',
926                                                               copy => 1,
927                                                            },
928                                                         },
929                                                      };
930            1                                  5      foreach my $opt ( @opts ) {
931   ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
932   ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
933                                                      }
934            1                                 12      return bless $self, $class;
935                                                   }
936                                                   
937                                                   sub prop {
938            3                    3            15      my ( $self, $prop, $value ) = @_;
939   ***      3     50                          17      if ( @_ > 2 ) {
940   ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
941   ***      0                                  0         $self->{$prop} = $value;
942                                                      }
943            3                                 23      return $self->{$prop};
944                                                   }
945                                                   
946                                                   sub parse {
947            1                    1            45      my ( $self, $dsn, $prev, $defaults ) = @_;
948   ***      1     50                           5      if ( !$dsn ) {
949   ***      0                                  0         MKDEBUG && _d('No DSN to parse');
950   ***      0                                  0         return;
951                                                      }
952            1                                  2      MKDEBUG && _d('Parsing', $dsn);
953   ***      1            50                    4      $prev     ||= {};
954   ***      1            50                    5      $defaults ||= {};
955            1                                 50      my %given_props;
956            1                                  2      my %final_props;
957            1                                  3      my %opts = %{$self->{opts}};
               1                                  8   
958                                                   
959            1                                  9      foreach my $dsn_part ( split(/,/, $dsn) ) {
960   ***      4     50                          37         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
961            4                                 19            $given_props{$prop_key} = $prop_val;
962                                                         }
963                                                         else {
964   ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
965   ***      0                                  0            $given_props{h} = $dsn_part;
966                                                         }
967                                                      }
968                                                   
969            1                                  5      foreach my $key ( keys %opts ) {
970            8                                 18         MKDEBUG && _d('Finding value for', $key);
971            8                                 24         $final_props{$key} = $given_props{$key};
972   ***      8     50     66                   63         if (   !defined $final_props{$key}
      ***                   33                        
973                                                              && defined $prev->{$key} && $opts{$key}->{copy} )
974                                                         {
975   ***      0                                  0            $final_props{$key} = $prev->{$key};
976   ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
977                                                         }
978            8    100                          33         if ( !defined $final_props{$key} ) {
979            4                                 14            $final_props{$key} = $defaults->{$key};
980            4                                 10            MKDEBUG && _d('Copying value for', $key, 'from defaults');
981                                                         }
982                                                      }
983                                                   
984            1                                  5      foreach my $key ( keys %given_props ) {
985   ***      4     50                          17         die "Unrecognized DSN part '$key' in '$dsn'\n"
986                                                            unless exists $opts{$key};
987                                                      }
988   ***      1     50                           5      if ( (my $required = $self->prop('required')) ) {
989   ***      0                                  0         foreach my $key ( keys %$required ) {
990   ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
991                                                         }
992                                                      }
993                                                   
994            1                                  6      return \%final_props;
995                                                   }
996                                                   
997                                                   sub parse_options {
998   ***      0                    0             0      my ( $self, $o ) = @_;
999   ***      0      0                           0      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1000  ***      0                                  0      my $dsn_string
1001                                                        = join(',',
1002  ***      0      0                           0             map  { "$_=".$o->get($_); }
1003  ***      0                                  0             grep { $o->has($_) && $o->get($_) }
1004  ***      0                                  0             keys %{$self->{opts}}
1005                                                          );
1006  ***      0                                  0      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1007  ***      0                                  0      return $self->parse($dsn_string);
1008                                                  }
1009                                                  
1010                                                  sub as_string {
1011  ***      0                    0             0      my ( $self, $dsn ) = @_;
1012  ***      0      0                           0      return $dsn unless ref $dsn;
1013  ***      0      0                           0      return join(',',
1014  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1015  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1016                                                        sort keys %$dsn );
1017                                                  }
1018                                                  
1019                                                  sub usage {
1020  ***      0                    0             0      my ( $self ) = @_;
1021  ***      0                                  0      my $usage
1022                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1023                                                        . "  KEY  COPY  MEANING\n"
1024                                                        . "  ===  ====  =============================================\n";
1025  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1026  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1027  ***      0      0      0                    0         $usage .= "  $key    "
1028                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1029                                                               .  ($opts{$key}->{desc} || '[No description]')
1030                                                               . "\n";
1031                                                     }
1032  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1033  ***      0                                  0      return $usage;
1034                                                  }
1035                                                  
1036                                                  sub get_cxn_params {
1037           1                    1            14      my ( $self, $info ) = @_;
1038           1                                  3      my $dsn;
1039           1                                  3      my %opts = %{$self->{opts}};
               1                                  8   
1040  ***      1            50                    5      my $driver = $self->prop('dbidriver') || '';
1041  ***      1     50                           5      if ( $driver eq 'Pg' ) {
1042  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1043  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1044  ***      0             0                    0                        grep { defined $info->{$_} }
1045                                                                       qw(h P));
1046                                                     }
1047                                                     else {
1048           2                                 14         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1049           5                                 19            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1050  ***      1            50                   12                        grep { defined $info->{$_} }
1051                                                                       qw(F h P S A))
1052                                                           . ';mysql_read_default_group=client';
1053                                                     }
1054           1                                  4      MKDEBUG && _d($dsn);
1055           1                                 10      return ($dsn, $info->{u}, $info->{p});
1056                                                  }
1057                                                  
1058                                                  sub fill_in_dsn {
1059  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1060  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1061  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1062  ***      0                                  0      $user =~ s/@.*//;
1063  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1064  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1065  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1066  ***      0             0                    0      $dsn->{u} ||= $user;
1067  ***      0             0                    0      $dsn->{D} ||= $db;
1068                                                  }
1069                                                  
1070                                                  sub get_dbh {
1071           1                    1             6      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1072  ***      1            50                    5      $opts ||= {};
1073  ***      1     50                          10      my $defaults = {
1074                                                        AutoCommit         => 0,
1075                                                        RaiseError         => 1,
1076                                                        PrintError         => 0,
1077                                                        ShowErrorStatement => 1,
1078                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1079                                                     };
1080           1                                  5      @{$defaults}{ keys %$opts } = values %$opts;
               1                                  4   
1081                                                  
1082  ***      1     50                           4      if ( !$have_dbi ) {
1083  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1084                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1085                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1086                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1087                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1088                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1089                                                  
1090                                                     }
1091                                                  
1092           1                                  3      my $dbh;
1093           1                                  4      my $tries = 2;
1094  ***      1            66                   10      while ( !$dbh && $tries-- ) {
1095                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1096           1                                  3            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1097                                                  
1098           1                                  3         eval {
1099           1                                  6            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1100                                                  
1101  ***      1     50                          16            if ( $cxn_string =~ m/mysql/i ) {
1102           1                                  3               my $sql;
1103                                                  
1104           1                                  4               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1105                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1106           1                                  4               MKDEBUG && _d($dbh, ':', $sql);
1107           1                                137               $dbh->do($sql);
1108                                                  
1109  ***      1     50                          12               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1110  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1111  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1112  ***      0                                  0                  $dbh->do($sql);
1113  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1114  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1115  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1116                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1117                                                                 }
1118                                                                 else {
1119  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1120                                                                 }
1121                                                              }
1122                                                  
1123  ***      1     50                           8               if ( $self->prop('set-vars') ) {
1124  ***      0                                  0                  $sql = "SET " . $self->prop('set-vars');
1125  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1126  ***      0                                  0                  $dbh->do($sql);
1127                                                              }
1128                                                           }
1129                                                        };
1130  ***      1     50     33                   13         if ( !$dbh && $EVAL_ERROR ) {
1131  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1132  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1133  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1134  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1135                                                           }
1136                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1137  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1138                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1139                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1140                                                                 . "DBD::mysql is not installed, try:\n"
1141                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1142                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1143                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1144                                                           }
1145  ***      0      0                           0            if ( !$tries ) {
1146  ***      0                                  0               die $EVAL_ERROR;
1147                                                           }
1148                                                        }
1149                                                     }
1150                                                  
1151           1                                  3      MKDEBUG && _d('DBH info: ',
1152                                                        $dbh,
1153                                                        Dumper($dbh->selectrow_hashref(
1154                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1155                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1156                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1157                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1158                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1159                                                        '$DBI::VERSION:',        $DBI::VERSION,
1160                                                     );
1161                                                  
1162           1                                  8      return $dbh;
1163                                                  }
1164                                                  
1165                                                  sub get_hostname {
1166  ***      0                    0                    my ( $self, $dbh ) = @_;
1167  ***      0      0      0                           if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1168  ***      0                                            return $host;
1169                                                     }
1170  ***      0                                         my ( $hostname, $one ) = $dbh->selectrow_array(
1171                                                        'SELECT /*!50038 @@hostname, */ 1');
1172  ***      0                                         return $hostname;
1173                                                  }
1174                                                  
1175                                                  sub disconnect {
1176  ***      0                    0                    my ( $self, $dbh ) = @_;
1177  ***      0                                         MKDEBUG && $self->print_active_handles($dbh);
1178  ***      0                                         $dbh->disconnect;
1179                                                  }
1180                                                  
1181                                                  sub print_active_handles {
1182  ***      0                    0                    my ( $self, $thing, $level ) = @_;
1183  ***      0             0                           $level ||= 0;
1184  ***      0      0      0                           printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1185                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1186                                                        or die "Cannot print: $OS_ERROR";
1187  ***      0                                         foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                      
      ***      0                                      
1188  ***      0                                            $self->print_active_handles( $handle, $level + 1 );
1189                                                     }
1190                                                  }
1191                                                  
1192                                                  sub copy {
1193  ***      0                    0                    my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1194  ***      0      0                                  die 'I need a dsn_1 argument' unless $dsn_1;
1195  ***      0      0                                  die 'I need a dsn_2 argument' unless $dsn_2;
1196  ***      0                                         my %new_dsn = map {
1197  ***      0                                            my $key = $_;
1198  ***      0                                            my $val;
1199  ***      0      0                                     if ( $args{overwrite} ) {
1200  ***      0      0                                        $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1201                                                        }
1202                                                        else {
1203  ***      0      0                                        $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1204                                                        }
1205  ***      0                                            $key => $val;
1206  ***      0                                         } keys %{$self->{opts}};
1207  ***      0                                         return \%new_dsn;
1208                                                  }
1209                                                  
1210                                                  sub _d {
1211  ***      0                    0                    my ($package, undef, $line) = caller 0;
1212  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1213  ***      0                                              map { defined $_ ? $_ : 'undef' }
1214                                                          @_;
1215  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1216                                                  }
1217                                                  
1218                                                  1;
1219                                                  
1220                                                  # ###########################################################################
1221                                                  # End DSNParser package
1222                                                  # ###########################################################################
1223                                                  
1224                                                  # ###########################################################################
1225                                                  # Daemon package 5266
1226                                                  # ###########################################################################
1227                                                  
1228                                                  package Daemon;
1229                                                  
1230           1                    1            16   use strict;
               1                                  3   
               1                                  9   
1231           1                    1             7   use warnings FATAL => 'all';
               1                                  7   
               1                                  8   
1232                                                  
1233           1                    1             7   use POSIX qw(setsid);
               1                                  2   
               1                                  7   
1234           1                    1            14   use English qw(-no_match_vars);
               1                                  3   
               1                                  7   
1235                                                  
1236  ***      1            50      1            14   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  4   
               1                                 23   
1237                                                  
1238                                                  sub new {
1239  ***      0                    0                    my ( $class, %args ) = @_;
1240  ***      0                                         foreach my $arg ( qw(o) ) {
1241  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
1242                                                     }
1243  ***      0                                         my $o = $args{o};
1244  ***      0      0                                  my $self = {
      ***             0                               
1245                                                        o        => $o,
1246                                                        log_file => $o->has('log') ? $o->get('log') : undef,
1247                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
1248                                                     };
1249                                                  
1250  ***      0                                         check_PID_file(undef, $self->{PID_file});
1251                                                  
1252  ***      0                                         MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
1253  ***      0                                         return bless $self, $class;
1254                                                  }
1255                                                  
1256                                                  sub daemonize {
1257  ***      0                    0                    my ( $self ) = @_;
1258                                                  
1259  ***      0                                         MKDEBUG && _d('About to fork and daemonize');
1260  ***      0      0                                  defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
1261  ***      0      0                                  if ( $pid ) {
1262  ***      0                                            MKDEBUG && _d('I am the parent and now I die');
1263  ***      0                                            exit;
1264                                                     }
1265                                                  
1266  ***      0                                         $self->{child} = 1;
1267                                                  
1268  ***      0      0                                  POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
1269  ***      0      0                                  chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
1270                                                  
1271  ***      0                                         $self->_make_PID_file();
1272                                                  
1273  ***      0                                         $OUTPUT_AUTOFLUSH = 1;
1274                                                  
1275  ***      0      0                                  if ( -t STDIN ) {
1276  ***      0                                            close STDIN;
1277  ***      0      0                                     open  STDIN, '/dev/null'
1278                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
1279                                                     }
1280                                                  
1281  ***      0      0                                  if ( $self->{log_file} ) {
1282  ***      0                                            close STDOUT;
1283  ***      0      0                                     open  STDOUT, '>>', $self->{log_file}
1284                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
1285                                                  
1286  ***      0                                            close STDERR;
1287  ***      0      0                                     open  STDERR, ">&STDOUT"
1288                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
1289                                                     }
1290                                                     else {
1291  ***      0      0                                     if ( -t STDOUT ) {
1292  ***      0                                               close STDOUT;
1293  ***      0      0                                        open  STDOUT, '>', '/dev/null'
1294                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
1295                                                        }
1296  ***      0      0                                     if ( -t STDERR ) {
1297  ***      0                                               close STDERR;
1298  ***      0      0                                        open  STDERR, '>', '/dev/null'
1299                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
1300                                                        }
1301                                                     }
1302                                                  
1303  ***      0                                         MKDEBUG && _d('I am the child and now I live daemonized');
1304  ***      0                                         return;
1305                                                  }
1306                                                  
1307                                                  sub check_PID_file {
1308  ***      0                    0                    my ( $self, $file ) = @_;
1309  ***      0      0                                  my $PID_file = $self ? $self->{PID_file} : $file;
1310  ***      0                                         MKDEBUG && _d('Checking PID file', $PID_file);
1311  ***      0      0      0                           if ( $PID_file && -f $PID_file ) {
1312  ***      0                                            my $pid;
1313  ***      0                                            eval { chomp($pid = `cat $PID_file`); };
      ***      0                                      
1314  ***      0      0                                     die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
1315  ***      0                                            MKDEBUG && _d('PID file exists; it contains PID', $pid);
1316  ***      0      0                                     if ( $pid ) {
1317  ***      0                                               my $pid_is_alive = kill 0, $pid;
1318  ***      0      0                                        if ( $pid_is_alive ) {
1319  ***      0                                                  die "The PID file $PID_file already exists "
1320                                                                 . " and the PID that it contains, $pid, is running";
1321                                                           }
1322                                                           else {
1323  ***      0                                                  warn "Overwriting PID file $PID_file because the PID that it "
1324                                                                 . "contains, $pid, is not running";
1325                                                           }
1326                                                        }
1327                                                        else {
1328  ***      0                                               die "The PID file $PID_file already exists but it does not "
1329                                                              . "contain a PID";
1330                                                        }
1331                                                     }
1332                                                     else {
1333  ***      0                                            MKDEBUG && _d('No PID file');
1334                                                     }
1335  ***      0                                         return;
1336                                                  }
1337                                                  
1338                                                  sub make_PID_file {
1339  ***      0                    0                    my ( $self ) = @_;
1340  ***      0      0                                  if ( exists $self->{child} ) {
1341  ***      0                                            die "Do not call Daemon::make_PID_file() for daemonized scripts";
1342                                                     }
1343  ***      0                                         $self->_make_PID_file();
1344  ***      0                                         $self->{rm_PID_file} = 1;
1345  ***      0                                         return;
1346                                                  }
1347                                                  
1348                                                  sub _make_PID_file {
1349  ***      0                    0                    my ( $self ) = @_;
1350                                                  
1351  ***      0                                         my $PID_file = $self->{PID_file};
1352  ***      0      0                                  if ( !$PID_file ) {
1353  ***      0                                            MKDEBUG && _d('No PID file to create');
1354  ***      0                                            return;
1355                                                     }
1356                                                  
1357  ***      0                                         $self->check_PID_file();
1358                                                  
1359  ***      0      0                                  open my $PID_FH, '>', $PID_file
1360                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
1361  ***      0      0                                  print $PID_FH $PID
1362                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
1363  ***      0      0                                  close $PID_FH
1364                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
1365                                                  
1366  ***      0                                         MKDEBUG && _d('Created PID file:', $self->{PID_file});
1367  ***      0                                         return;
1368                                                  }
1369                                                  
1370                                                  sub _remove_PID_file {
1371  ***      0                    0                    my ( $self ) = @_;
1372  ***      0      0      0                           if ( $self->{PID_file} && -f $self->{PID_file} ) {
1373  ***      0      0                                     unlink $self->{PID_file}
1374                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
1375  ***      0                                            MKDEBUG && _d('Removed PID file');
1376                                                     }
1377                                                     else {
1378  ***      0                                            MKDEBUG && _d('No PID to remove');
1379                                                     }
1380  ***      0                                         return;
1381                                                  }
1382                                                  
1383                                                  sub DESTROY {
1384  ***      0                    0                    my ( $self ) = @_;
1385  ***      0      0      0                           $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
1386  ***      0                                         return;
1387                                                  }
1388                                                  
1389                                                  sub _d {
1390  ***      0                    0                    my ($package, undef, $line) = caller 0;
1391  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1392  ***      0                                              map { defined $_ ? $_ : 'undef' }
1393                                                          @_;
1394  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1395                                                  }
1396                                                  
1397                                                  1;
1398                                                  
1399                                                  # ###########################################################################
1400                                                  # End Daemon package
1401                                                  # ###########################################################################
1402                                                  
1403                                                  # ###########################################################################
1404                                                  # This is a combination of modules and programs in one -- a runnable module.
1405                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
1406                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
1407                                                  #
1408                                                  # Check at the end of this package for the call to main() which actually runs
1409                                                  # the program.
1410                                                  # ###########################################################################
1411                                                  package mk_query_profiler;
1412                                                  
1413           1                    1            65   use English qw(-no_match_vars);
               1                                  3   
               1                                  9   
1414           1                    1            12   use List::Util qw(sum min max first);
               1                                  3   
               1                                  8   
1415           1                    1           292   use Time::HiRes qw(time);
               1                                  4   
               1                                  9   
1416                                                  
1417                                                  $OUTPUT_AUTOFLUSH = 1;
1418                                                  
1419  ***      1            50      1             7   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 19   
1420           1                    1             6   use constant MAX_ULONG => 4294967295; # 2^32-1
               1                                  2   
               1                                  5   
1421                                                  
1422                                                  # Globals that'll get set by subroutines.  Used in formats, which is why they
1423                                                  # must be global.
1424                                                  my $ch                 = {};
1425                                                  my $qcost              = 0;
1426                                                  my $qcost_total        = 0;
1427                                                  my $qtime_total        = 0;
1428                                                  my $bytes_in_total     = 0;
1429                                                  my $bytes_out_total    = 0;
1430                                                  my $which_query        = 0;
1431                                                  my $query_time         = 0;
1432                                                  my $query_text         = '';
1433                                                  my $qcache_inval       = 0;
1434                                                  my $qcache_inval_total = 0;
1435                                                  my $hdr_type           = '';
1436                                                  
1437                                                  # Every status variable this script cares about
1438                                                  my @important_vars = qw(
1439                                                     Bytes_received Bytes_sent
1440                                                     Com_commit Com_delete Com_delete_multi Com_insert Com_insert_select
1441                                                     Com_replace Com_replace_select Com_select Com_update Com_update_multi
1442                                                     Created_tmp_disk_tables Created_tmp_files Created_tmp_tables Handler_commit
1443                                                     Handler_delete Handler_read_first Handler_read_key Handler_read_next
1444                                                     Handler_read_prev Handler_read_rnd Handler_read_rnd_next Handler_update
1445                                                     Handler_write Innodb_buffer_pool_pages_flushed
1446                                                     Innodb_buffer_pool_read_ahead_rnd Innodb_buffer_pool_read_ahead_seq
1447                                                     Innodb_buffer_pool_read_requests Innodb_buffer_pool_reads
1448                                                     Innodb_buffer_pool_wait_free Innodb_buffer_pool_write_requests
1449                                                     Innodb_data_fsyncs Innodb_data_read Innodb_data_reads Innodb_data_writes
1450                                                     Innodb_data_written Innodb_dblwr_pages_written Innodb_dblwr_writes
1451                                                     Innodb_log_waits Innodb_log_write_requests Innodb_log_writes
1452                                                     Innodb_os_log_fsyncs Innodb_os_log_written Innodb_pages_created
1453                                                     Innodb_pages_read Innodb_pages_written Innodb_row_lock_time
1454                                                     Innodb_row_lock_waits Innodb_rows_deleted Innodb_rows_inserted
1455                                                     Innodb_rows_read Innodb_rows_updated Key_read_requests Key_reads
1456                                                     Key_write_requests Key_writes Last_query_cost Qcache_hits Qcache_inserts
1457                                                     Qcache_lowmem_prunes Qcache_queries_in_cache Questions Select_full_join
1458                                                     Select_full_range_join Select_range Select_range_check Select_scan
1459                                                     Sort_merge_passes Sort_range Sort_rows Sort_scan Table_locks_immediate
1460                                                  );
1461                                                  
1462                                                  # Status variables that may decrease (if monotonically increasing variables
1463                                                  # decrease, it means they wrapped over the max size of a ulong).
1464                                                  my %non_monotonic_vars = (
1465                                                     Qcache_queries_in_cache => 1,
1466                                                     Last_query_cost         => 1,
1467                                                  );
1468                                                  
1469                                                  sub main {
1470  ***      0                    0                    @ARGV = @_;  # set global ARGV for this package
1471                                                  
1472                                                     # ########################################################################
1473                                                     # Get configuration information.
1474                                                     # ########################################################################
1475  ***      0                                         my $dp = new DSNParser();
1476  ***      0                                         my $o  = new OptionParser(
1477                                                        strict      => 0,
1478                                                        prompt      => '<options> [FILE]...',
1479                                                        description =>
1480                                                           q{reads and executes queries, and prints statistics about }
1481                                                           . q{MySQL server load.  Connection options are read from MySQL }
1482                                                           . q{option files.  If FILE is given, queries are read and }
1483                                                           . q{executed from the file(s).  With no FILE, or when FILE is -, }
1484                                                           . q{read standard input.  If --external is specified, lines in }
1485                                                           . q{FILE are executed by the shell.  You must specify - if no }
1486                                                           . q{FILE and you want --external to read and execute from }
1487                                                           . q{standard input.  Queries in FILE must be terminated with a }
1488                                                           . q{semicolon and separated by a blank line.},
1489                                                     );
1490  ***      0                                         $o->get_specs();
1491  ***      0                                         $o->get_opts();
1492                                                  
1493  ***      0                                         $dp->prop('set-vars', $o->get('set-vars'));
1494                                                  
1495  ***      0                                         $o->set('verbose', min(2, $o->get('verbose')));
1496                                                  
1497  ***      0                                         $o->usage_or_errors();
1498                                                  
1499                                                     # ########################################################################
1500                                                     # If --pid, check it first since we'll die if it already exits.
1501                                                     # ########################################################################
1502  ***      0                                         my $daemon;
1503  ***      0      0                                  if ( $o->get('pid') ) {
1504                                                        # We're not daemoninzing, it just handles PID stuff.  Keep $daemon
1505                                                        # in the the scope of main() because when it's destroyed it automatically
1506                                                        # removes the PID file.
1507  ***      0                                            $daemon = new Daemon(o=>$o);
1508  ***      0                                            $daemon->make_PID_file();
1509                                                     }
1510                                                  
1511                                                     # Connect to the database
1512  ***      0      0                                  if ( $o->get('ask-pass') ) {
1513  ***      0                                            $o->set('p', OptionParser::prompt_noecho("Enter password: "));
1514                                                     }
1515  ***      0                                         my $dsn = $dp->parse_options($o);
1516  ***      0                                         my $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), { AutoCommit => 1, });
1517                                                  
1518  ***      0                                         my $variables = get_variables($dbh);
1519                                                  
1520  ***      0      0      0                           my $have_innodb
1521                                                        = $o->get('innodb') && $variables->{have_innodb} eq 'YES' ? 1 : 0;
1522                                                  
1523                                                     # SESSION status and InnoDB status values.
1524  ***      0             0                           my $have_session
1525                                                        = $o->get('session') && version_ge($dbh, '5.0.2'); 
1526                                                  
1527                                                     # InnoDB row lock status.
1528  ***      0             0                           my $have_rowlock = version_ge($dbh, '5.0.3') && $have_innodb; 
1529                                                  
1530                                                     # Last query cost according to optimizer.
1531  ***      0             0                           my $have_last = version_ge($dbh, '5.0.1') && !$o->get('external');    
1532                                                  
1533                                                     # Configure the query cache
1534  ***      0                                         my $have_qcache = 0;
1535  ***      0      0                                  if ( $variables->{query_cache_size} ) {
1536  ***      0      0      0                              if ( $o->get('allow-cache') || $o->get('external') ) {
1537  ***      0                                               $have_qcache = 1;
1538                                                        }
1539                                                        else {
1540  ***      0                                               $dbh->do("SET SESSION query_cache_type = OFF");
1541                                                        }
1542                                                     }
1543                                                  
1544                                                     # Depending on the level of verbosity and the server version, summary and
1545                                                     # separate printouts will include different formats.
1546  ***      0      0                                  my $formats_for = {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
1547                                                        0 => [
1548                                                           $have_last    ? qw( OPT_COST ) : qw(),
1549                                                                           qw( TBL_IDX ),
1550                                                           $have_qcache  ? qw( QCACHE )   : qw(),
1551                                                        ],
1552                                                        1 => [
1553                                                           $have_last    ? qw( OPT_COST )       : qw(),
1554                                                                           qw( TBL_IDX ),
1555                                                           $have_qcache  ? qw( QCACHE )         : qw(),
1556                                                           $have_innodb  ? qw( ROW_OPS_INNODB ) : qw( ROW_OPS ),
1557                                                        ],
1558                                                        2 => [
1559                                                           $have_last    ? qw( OPT_COST )                         : qw(),
1560                                                                           qw( TBL_IDX ),
1561                                                           $have_qcache  ? qw( QCACHE )                           : qw(),
1562                                                           $have_innodb  ? qw( ROW_OPS_INNODB )                   : qw( ROW_OPS ),
1563                                                           $have_rowlock ? qw( ROW_LOCKS )                        : qw(),
1564                                                           $have_innodb  ? qw( IO_OPS IO_INNODB INNODB_DATA_OPS ) : qw( IO_OPS ),
1565                                                        ],
1566                                                     };
1567                                                  
1568                                                     # ########################################################################
1569                                                     # Get a baseline for how much SHOW STATUS costs.
1570                                                     # ########################################################################
1571                                                  
1572                                                     # SESSION status variables this script cares about.
1573                                                     my @session_vars
1574  ***      0      0                                     = $have_session
1575                                                        ? qw(
1576                                                           Bytes_received Bytes_sent Com_commit Com_delete Com_delete_multi
1577                                                           Com_insert Com_insert_select Com_replace Com_replace_select
1578                                                           Com_select Com_update Com_update_multi Created_tmp_disk_tables
1579                                                           Created_tmp_tables Handler_commit Handler_delete
1580                                                           Handler_read_first Handler_read_key Handler_read_next Handler_read_prev
1581                                                           Handler_read_rnd Handler_read_rnd_next Handler_update Handler_write
1582                                                           Last_query_cost Select_full_join Select_full_range_join Select_range
1583                                                           Select_range_check Select_scan Sort_merge_passes Sort_range Sort_rows
1584                                                           Sort_scan
1585                                                           )
1586                                                        : qw();
1587                                                  
1588                                                     # Throwaway to prime caches after FLUSH
1589  ***      0                                         get_status_info($o, $dbh, $have_session); 
1590  ***      0                                         my $status_0 = get_status_info($o, $dbh, $have_session);
1591  ***      0                                         my $status_1 = get_status_info($o, $dbh, $have_session);
1592                                                  
1593  ***      0                                         my $base = $o->get('calibrate')
1594  ***      0                                            ? ( { map { $_ => $status_1->{$_} - $status_0->{$_} } @important_vars } )
1595  ***      0      0                                     : ( { map { $_ => 0 } @important_vars } );
1596                                                  
1597  ***      0      0                                  if ( $o->get('verify') ) {
1598  ***      0                                            my $base_2 = $o->get('calibrate') ? $base
1599  ***      0      0                                                : ( { map { $_ => $status_1->{$_} - $status_0->{$_} } @important_vars } );
1600                                                  
1601  ***      0                                            sleep(1);
1602  ***      0                                            my $status_2 = get_status_info($o, $dbh, $have_session);
1603  ***      0                                            my $base_3
1604  ***      0                                               = { map { $_ => $status_2->{$_} - $status_1->{$_} } @session_vars };
1605  ***      0                                            foreach my $key ( @session_vars ) {
1606  ***      0      0                                        if ( $base_3->{$key} != $base_2->{$key} ) {
1607  ***      0                                                  print "Cost of observation changed: $key $base_3->{$key} $base_2->{$key}\n";
1608                                                           }
1609                                                        }
1610                                                     }
1611                                                  
1612                                                     # ########################################################################
1613                                                     # The main work happens now.
1614                                                     # ########################################################################
1615                                                  
1616                                                     # Get a baseline status.
1617  ***      0                                         my $sql_status_0 = get_status_info($o, $dbh, $have_session);
1618  ***      0                                         my @queries;
1619                                                  
1620                                                     # ########################################################################
1621                                                     # Do the profiling.
1622                                                     # ########################################################################
1623  ***      0                                         my $have_flushed_tables = 0;
1624                                                  
1625  ***      0      0                                  if ( $o->get('external') ) { # An external process will issue queries
1626  ***      0      0                                     if ( !@ARGV ) { # Don't read files or STDIN
1627  ***      0                                               flush_tables($o, $dbh, $have_flushed_tables++);
1628  ***      0                                               my $start = time();
1629  ***      0                                               print "Press <ENTER> when the external program is finished";
1630  ***      0                                               <STDIN>;
1631  ***      0                                               my $end = time();
1632                                                           # Hack the @queries variable by stuffing the external program's
1633                                                           # data in as a hash reference just as though it had been a query
1634                                                           # in a file.
1635  ***      0                                               push @queries, {
1636                                                              text   => '[External program]',
1637                                                              start  => $start,
1638                                                              end    => $end,
1639                                                              status => get_status_info($o, $dbh, $have_session),
1640                                                           };
1641                                                        }
1642                                                        else {
1643  ***      0                                               while ( my $line = <> ) { # Read from STDIN, or files named on cmdline
1644  ***      0                                                  chomp $line;
1645  ***      0      0                                           next unless $line;
1646                                                  
1647  ***      0                                                  flush_tables($o, $dbh, $have_flushed_tables++);
1648  ***      0                                                  my $start = time();
1649  ***      0                                                  print `$line`;
1650  ***      0                                                  my $end = time();
1651  ***      0                                                  push @queries, {
1652                                                                 text   => $line,
1653                                                                 start  => $start,
1654                                                                 end    => $end,
1655                                                                 status => get_status_info($o, $dbh, $have_session),
1656                                                              };
1657                                                           }
1658                                                        }
1659                                                     }
1660                                                     else {
1661  ***      0                                            local $INPUT_RECORD_SEPARATOR = ''; # read a paragraph at a time
1662  ***      0                                            while ( my $line = <> ) { # Read from STDIN, or files named on cmdline
1663  ***      0                                               chomp $line;
1664  ***      0      0                                        next unless $line;
1665  ***      0                                               $line =~ s/;\s*\z//xms; # Remove trailing whitespace/semicolon
1666                                                  
1667  ***      0                                               flush_tables($o, $dbh, $have_flushed_tables++);
1668  ***      0                                               my $query = {
1669                                                              text  => $line,
1670                                                              start => time(),
1671                                                           };
1672                                                           # It appears to me that this actually fetches all the data over the
1673                                                           # wire, which is what I want for purposes of counting bytes in and
1674                                                           # bytes out.
1675  ***      0                                               $dbh->do( $line );
1676  ***      0                                               $query->{end}    = time();
1677  ***      0                                               $query->{status} = get_status_info($o, $dbh, $have_session);
1678  ***      0                                               push @queries, $query;
1679                                                        }
1680                                                     }
1681                                                  
1682                                                     # ########################################################################
1683                                                     # Tab-separated output for a spreadsheet.
1684                                                     # ########################################################################
1685  ***      0      0                                  if ( $o->get('tab') ) {
1686                                                  
1687                                                        # Get a list of all the SHOW STATUS measurements.
1688  ***      0                                            my @statuses = (
1689                                                           $sql_status_0,
1690  ***      0                                               ( map { $_->{status} } @queries ),
1691                                                           get_status_info($o, $dbh, $have_session),
1692                                                        );
1693                                                  
1694                                                        # Decide which variables to output.  If verbosity is 0, output only those
1695                                                        # whose values are non-zero across the board.  If verbosity is greater,
1696                                                        # output everything.
1697  ***      0                                            my @variables = sort keys %$sql_status_0;
1698  ***      0      0                                     if ( !$o->get('verbose') ) {
1699  ***      0                                               @variables = grep {
1700                                                              # Discover whether there is a true value in any set.  A 'true'
1701                                                              # value is one where the value isn't the same as the value for
1702                                                              # the same key in the previous set.  The first (before) and last
1703                                                              # (calibrate) set are excluded.
1704  ***      0                                                  my $var = $_;
1705                                                              first { # first() terminates early, unlike grep()
1706  ***      0      0      0      0                                defined $statuses[$_]->{$var}
1707                                                                 && defined $statuses[$_ - 1]->{$var}
1708                                                                 && $statuses[$_]->{$var} != $statuses[$_ - 1]->{$var}
1709  ***      0                                                  } ( 1 .. $#statuses - 1 );
1710                                                           } @variables;
1711                                                        }
1712                                                  
1713                                                        # Print headers.
1714                                                        print
1715  ***      0                                               join("\t",
1716                                                              'Variable_name',
1717                                                              'Before',
1718  ***      0                                                  ( map { "After$_" } ( 1 ..  $#statuses - 1 ) ),
1719                                                              'Calibration',
1720                                                           ),
1721                                                           "\n";
1722                                                  
1723                                                        # Print each variable in tab-separated values.
1724  ***      0                                            foreach my $key ( @variables ) {
1725  ***      0      0                                        print
1726                                                              join("\t", $key,
1727  ***      0                                                     map { defined($_->{$key}) ? $_->{$key} : '' } @statuses),
1728                                                              "\n";
1729                                                        }
1730                                                     }
1731                                                  
1732                                                     # ########################################################################
1733                                                     # Tabular layout for human readability.
1734                                                     # ########################################################################
1735                                                     else {
1736                                                        # Print the separate results and accumulate global totals.
1737  ***      0                                            foreach my $i ( 0 .. $#queries ) {
1738  ***      0                                               my $query     = $queries[$i];
1739  ***      0      0                                        my $before    = $i ? $queries[ $i - 1 ]->{status} : $sql_status_0;
1740  ***      0                                               my $after     = $query->{status};
1741                                                  
1742                                                           # Accumulate some globals
1743  ***      0                                               $qcost_total += $after->{Last_query_cost};
1744  ***      0                                               $qtime_total += $query->{end} - $query->{start};
1745  ***      0                                               $which_query = $i + 1;
1746  ***      0                                               $query_time  = $query->{end} - $query->{start};
1747  ***      0                                               $ch          = get_changes($base, $before, $after, 1);
1748                                                  
1749                                                           # Accumulate query cache invalidations
1750  ***      0      0      0                                 $qcache_inval
      ***                    0                        
1751                                                              = ($ch->{Qcache_inserts} > 0 && $ch->{Qcache_queries_in_cache} == 0)
1752                                                                 || $ch->{Qcache_queries_in_cache} < 0
1753                                                              ? -$ch->{Qcache_queries_in_cache} - $ch->{Qcache_lowmem_prunes}
1754                                                              : 0;
1755  ***      0                                               $qcache_inval_total += $qcache_inval;
1756  ***      0                                               $bytes_in_total     += $ch->{Bytes_received};
1757  ***      0                                               $bytes_out_total    += $ch->{Bytes_sent};
1758                                                  
1759                                                           # Print separate stats
1760  ***      0      0      0                                 if ( $o->get('separate') && @queries > 1
      ***                    0                        
      ***                    0                        
1761                                                                && (!$o->get('only') || $o->get('only')->{ $i + 1 } )) {
1762  ***      0                                                  $qcost        = $after->{Last_query_cost};
1763  ***      0                                                  ( $query_text = $query->{text} ) =~ s/\s+/ /g;
1764  ***      0      0                                           $FORMAT_NAME  = $o->get('external') ? 'SUMMARY'  : 'QUERY';
1765  ***      0      0                                           $hdr_type     = $o->get('external') ? 'EXTERNAL' : 'QUERY';
1766  ***      0                                                  write;
1767  ***      0                                                  foreach my $format_name ( @{$formats_for->{$o->get('verbose')}}) {
      ***      0                                      
1768  ***      0                                                     $FORMAT_NAME = $format_name;
1769  ***      0                                                     write;
1770                                                              }
1771                                                           }
1772                                                        }
1773                                                  
1774                                                        # Print summary stats
1775  ***      0                                            $ch           = get_changes($base, $sql_status_0, $queries[-1]->{status}, scalar(@queries) );
1776  ***      0                                            $qcache_inval = $qcache_inval_total;
1777  ***      0                                            $qcost        = $qcost_total;
1778  ***      0                                            $FORMAT_NAME  = "SUMMARY";
1779  ***      0                                            write;
1780  ***      0                                            foreach my $format_name ( @{$formats_for->{$o->get('verbose')}}) {
      ***      0                                      
1781  ***      0                                               $FORMAT_NAME = $format_name;
1782  ***      0                                               write;
1783                                                        }
1784  ***      0      0                                     if ( !$have_session ) {
1785  ***      0      0                                        if ( $queries[-1]->{status}->{Questions} - $sql_status_0->{Questions}
1786                                                              > (@queries * 2) + 1 ) {
1787  ***      0                                                  print STDERR "WARNING: Something else accessed the database at "
1788                                                                 . "the same time you were trying to profile this batch!  These "
1789                                                                 . "numbers are not correct!\n";
1790                                                           }
1791                                                           else {
1792  ***      0                                                  print STDERR "WARNING: These statistics could be wrong if "
1793                                                                 . "anything else was accessing the database at the same time.\n";
1794                                                           }
1795                                                        }
1796                                                     }
1797                                                  
1798  ***      0                                         $dbh->disconnect();
1799                                                  
1800  ***      0                                         return 0;
1801                                                  }
1802                                                  
1803                                                  # ############################################################################
1804                                                  # Subroutines
1805                                                  # ############################################################################
1806                                                  
1807                                                  sub flush_tables {
1808  ***      0                    0                    my ($o, $dbh, $have_flushed) = @_;
1809  ***      0      0      0                           return if !$o->get('flush')
      ***                    0                        
1810                                                        || ( $o->get('flush') == 1 && $have_flushed );
1811  ***      0                                         eval { $dbh->do("FLUSH TABLES") };
      ***      0                                      
1812  ***      0      0                                  if ( $EVAL_ERROR ) {
1813  ***      0                                            print STDERR "Warning: can't FLUSH TABLES because $EVAL_ERROR\n";
1814                                                     }
1815                                                  }
1816                                                  
1817                                                  sub get_changes {
1818  ***      0                    0                    my ( $base, $before, $after, $num_base ) = @_;
1819  ***      0             0                           $num_base ||= 1;
1820  ***      0             0                           return { map {
1821  ***      0                                            $after->{$_}  ||= 0;
1822  ***      0             0                              $before->{$_} ||= 0;
1823  ***      0                                            my $val = $after->{$_} - $before->{$_} - ( $num_base * $base->{$_} );
1824  ***      0      0      0                              if ( $val < 0 && !defined($non_monotonic_vars{$_}) ) {
1825                                                           # Handle when a ulong wraps over the 32-bit boundary
1826  ***      0                                               $val += MAX_ULONG;
1827                                                        }
1828  ***      0                                            $_ => $val;
1829                                                     } @important_vars };
1830                                                  }
1831                                                  
1832                                                  sub get_status_info {
1833  ***      0                    0                    my ( $o, $dbh, $have_session ) = @_;
1834  ***      0      0                                  my $res = $dbh->selectall_arrayref(
      ***             0                               
1835                                                        $have_session
1836                                                           ? ($o->get('external') ? 'SHOW GLOBAL STATUS' : 'SHOW SESSION STATUS')
1837                                                           : 'SHOW STATUS' );
1838  ***      0                                         my %result = map { @{$_} } @$res;
      ***      0                                      
      ***      0                                      
1839  ***      0             0                           return { map { $_ => $result{$_} || 0 } @important_vars };
      ***      0                                      
1840                                                  }
1841                                                  
1842                                                  sub get_variables {
1843  ***      0                    0                    my $dbh = shift;
1844  ***      0                                         my $res = $dbh->selectall_arrayref('SHOW VARIABLES');
1845  ***      0                                         return { map { @{$_} } @$res };
      ***      0                                      
      ***      0                                      
1846                                                  }
1847                                                  
1848                                                  # Compares versions like 5.0.27 and 4.1.15-standard-log
1849                                                  sub version_ge {
1850  ***      0                    0                    my ( $dbh, $target ) = @_;
1851  ***      0                                         my $version = sprintf('%03d%03d%03d', $dbh->{mysql_serverinfo} =~ m/(\d+)/g);
1852  ***      0                                         return $version ge sprintf('%03d%03d%03d', $target =~ m/(\d+)/g);
1853                                                  }
1854                                                  
1855                                                  sub get_file {
1856  ***      0                    0                    my $filename = shift;
1857  ***      0      0                                  open my $file, "<", "$filename" or die "Can't open $filename: $OS_ERROR";
1858  ***      0                                         my $file_contents = do { local $INPUT_RECORD_SEPARATOR; <$file>; };
      ***      0                                      
      ***      0                                      
1859  ***      0                                         close $file;
1860  ***      0                                         return $file_contents;
1861                                                  }
1862                                                  
1863                                                  # ############################################################################
1864                                                  # Formats
1865                                                  # ############################################################################
1866                                                  
1867                                                  format SUMMARY =
1868                                                  
1869                                                  +----------------------------------------------------------+
1870                                                  | @||||||||||||||||||||||||||||||||||||||||||||||||||||||| |
1871                                                  sprintf("$hdr_type %d (%.4f sec)", $which_query, $query_time)
1872                                                  +----------------------------------------------------------+
1873                                                  
1874                                                  __ Overall stats _______________________ Value _____________
1875                                                     Total elapsed time              @##########.###
1876                                                  $qtime_total
1877                                                     Questions                       @##########
1878                                                  $ch->{Questions}
1879                                                       COMMIT                        @##########
1880                                                  $ch->{Com_commit}
1881                                                       DELETE                        @##########
1882                                                  $ch->{Com_delete}
1883                                                       DELETE MULTI                  @##########
1884                                                  $ch->{Com_delete_multi}
1885                                                       INSERT                        @##########
1886                                                  $ch->{Com_insert}
1887                                                       INSERT SELECT                 @##########
1888                                                  $ch->{Com_insert_select}
1889                                                       REPLACE                       @##########
1890                                                  $ch->{Com_replace}
1891                                                       REPLACE SELECT                @##########
1892                                                  $ch->{Com_replace_select}
1893                                                       SELECT                        @##########
1894                                                  $ch->{Com_select}
1895                                                       UPDATE                        @##########
1896                                                  $ch->{Com_update}
1897                                                       UPDATE MULTI                  @##########
1898                                                  $ch->{Com_update_multi}
1899                                                     Data into server                @##########
1900                                                  $bytes_in_total
1901                                                     Data out of server              @##########
1902                                                  $bytes_out_total
1903                                                  .
1904                                                  
1905                                                  format TBL_IDX =
1906                                                  
1907                                                  __ Table and index accesses ____________ Value _____________
1908                                                     Table locks acquired            @##########
1909                                                  $ch->{Table_locks_immediate}
1910                                                     Table scans                     @##########
1911                                                  $ch->{Select_scan} + $ch->{Select_full_join}
1912                                                       Join                          @##########
1913                                                  $ch->{Select_full_join}
1914                                                     Index range scans               @##########
1915                                                  {
1916                                                     $ch->{Select_range} + $ch->{Select_full_range_join}
1917                                                     + $ch->{Select_range_check}
1918                                                  }
1919                                                       Join without check            @##########
1920                                                  $ch->{Select_full_range_join}
1921                                                       Join with check               @##########
1922                                                  $ch->{Select_range_check}
1923                                                     Rows sorted                     @##########
1924                                                  $ch->{Sort_rows}
1925                                                       Range sorts                   @##########
1926                                                  $ch->{Sort_range}
1927                                                       Merge passes                  @##########
1928                                                  $ch->{Sort_merge_passes}
1929                                                       Table scans                   @##########
1930                                                  $ch->{Sort_scan}
1931                                                       Potential filesorts           @##########
1932                                                  min($ch->{Sort_scan}, $ch->{Created_tmp_tables})
1933                                                  .
1934                                                  
1935                                                  format QCACHE =
1936                                                     Query cache
1937                                                       Hits                          @##########
1938                                                  $ch->{Qcache_hits}
1939                                                       Inserts                       @##########
1940                                                  $ch->{Qcache_inserts}
1941                                                       Invalidations                 @##########
1942                                                  $qcache_inval
1943                                                  .
1944                                                  
1945                                                  format ROW_OPS_INNODB =
1946                                                  
1947                                                  __ Row operations ____________________ Handler ______ InnoDB
1948                                                     Reads                           @##########   @##########
1949                                                  {
1950                                                     $ch->{Handler_read_rnd}
1951                                                     + $ch->{Handler_read_rnd_next}
1952                                                     + $ch->{Handler_read_key}
1953                                                     + $ch->{Handler_read_first}
1954                                                     + $ch->{Handler_read_next}
1955                                                     + $ch->{Handler_read_prev},
1956                                                     $ch->{Innodb_rows_read} || 0
1957                                                  }
1958                                                       Fixed pos (might be sort)     @##########
1959                                                  $ch->{Handler_read_rnd}
1960                                                       Next row (table scan)         @##########
1961                                                  $ch->{Handler_read_rnd_next}
1962                                                       Bookmark lookup               @##########
1963                                                  $ch->{Handler_read_key}
1964                                                       First in index (full scan?)   @##########
1965                                                  $ch->{Handler_read_first}
1966                                                       Next in index                 @##########
1967                                                  $ch->{Handler_read_next}
1968                                                       Prev in index                 @##########
1969                                                  $ch->{Handler_read_prev}
1970                                                     Writes
1971                                                       Delete                        @##########   @##########
1972                                                  $ch->{Handler_delete}, $ch->{Innodb_rows_deleted}
1973                                                       Update                        @##########   @##########
1974                                                  $ch->{Handler_update}, $ch->{Innodb_rows_updated}
1975                                                       Insert                        @##########   @##########
1976                                                  $ch->{Handler_write}, $ch->{Innodb_rows_inserted}
1977                                                       Commit                        @##########
1978                                                  $ch->{Handler_commit}
1979                                                  .
1980                                                  
1981                                                  format ROW_OPS =
1982                                                  
1983                                                  __ Row operations ____________________ Handler _____________
1984                                                     Reads                           @##########
1985                                                  {
1986                                                     $ch->{Handler_read_rnd}
1987                                                     + $ch->{Handler_read_rnd_next}
1988                                                     + $ch->{Handler_read_key}
1989                                                     + $ch->{Handler_read_first}
1990                                                     + $ch->{Handler_read_next}
1991                                                     + $ch->{Handler_read_prev}
1992                                                  }
1993                                                       Fixed pos (might be sort)     @##########
1994                                                  $ch->{Handler_read_rnd}
1995                                                       Next row (table scan)         @##########
1996                                                  $ch->{Handler_read_rnd_next}
1997                                                       Bookmark lookup               @##########
1998                                                  $ch->{Handler_read_key}
1999                                                       First in index (full scan?)   @##########
2000                                                  $ch->{Handler_read_first}
2001                                                       Next in index                 @##########
2002                                                  $ch->{Handler_read_next}
2003                                                       Prev in index                 @##########
2004                                                  $ch->{Handler_read_prev}
2005                                                     Writes
2006                                                       Delete                        @##########
2007                                                  $ch->{Handler_delete}
2008                                                       Update                        @##########
2009                                                  $ch->{Handler_update}
2010                                                       Insert                        @##########
2011                                                  $ch->{Handler_write}
2012                                                       Commit                        @##########
2013                                                  $ch->{Handler_commit}
2014                                                  .
2015                                                  
2016                                                  format ROW_LOCKS =
2017                                                     InnoDB row locks
2018                                                       Number of locks waited for                  @##########
2019                                                  $ch->{Innodb_row_lock_waits}
2020                                                       Total ms spent acquiring locks              @##########
2021                                                  $ch->{Innodb_row_lock_time}
2022                                                  .
2023                                                  
2024                                                  format IO_OPS =
2025                                                  
2026                                                  __ I/O Operations _____________________ Memory ________ Disk
2027                                                     Key cache
2028                                                       Key reads                     @##########    @#########
2029                                                  $ch->{Key_read_requests}, $ch->{Key_reads}
2030                                                       Key writes                    @##########    @#########
2031                                                  $ch->{Key_write_requests}, $ch->{Key_writes}
2032                                                     Temp tables                     @##########    @#########
2033                                                  $ch->{Created_tmp_tables}, $ch->{Created_tmp_disk_tables}
2034                                                     Temp files                                     @#########
2035                                                  $ch->{Created_tmp_files}
2036                                                  .
2037                                                  
2038                                                  format IO_INNODB =
2039                                                     InnoDB buffer pool
2040                                                       Reads                         @##########    @#########
2041                                                  $ch->{Innodb_buffer_pool_read_requests}, $ch->{Innodb_buffer_pool_reads}
2042                                                       Random read-aheads            @##########
2043                                                  $ch->{Innodb_buffer_pool_read_ahead_rnd}
2044                                                       Sequential read-aheads        @##########
2045                                                  $ch->{Innodb_buffer_pool_read_ahead_seq}
2046                                                       Write requests                @##########    @#########
2047                                                  $ch->{Innodb_buffer_pool_write_requests}, $ch->{Innodb_buffer_pool_pages_flushed}
2048                                                       Reads/creates blocked by flushes             @#########
2049                                                  $ch->{Innodb_buffer_pool_wait_free}
2050                                                     InnoDB log operations
2051                                                       Log writes                    @##########    @#########
2052                                                  $ch->{Innodb_log_write_requests}, $ch->{Innodb_log_writes}
2053                                                       Log writes blocked by flushes                @#########
2054                                                  $ch->{Innodb_log_waits}
2055                                                  .
2056                                                  
2057                                                  format INNODB_DATA_OPS =
2058                                                  
2059                                                  __ InnoDB Data Operations ____ Pages _____ Ops _______ Bytes
2060                                                     Reads                   @######## @########    @#########
2061                                                  $ch->{Innodb_pages_read}, $ch->{Innodb_data_reads}, $ch->{Innodb_data_read}
2062                                                     Writes                  @######## @########    @#########
2063                                                  $ch->{Innodb_pages_written}, $ch->{Innodb_data_writes}, $ch->{Innodb_data_written}
2064                                                     Doublewrites            @######## @########
2065                                                  $ch->{Innodb_dblwr_pages_written}, $ch->{Innodb_dblwr_writes}
2066                                                     Creates                 @########
2067                                                  $ch->{Innodb_pages_created}
2068                                                     Fsyncs                            @########
2069                                                  $ch->{Innodb_data_fsyncs}
2070                                                     OS fsyncs                         @########    @#########
2071                                                  $ch->{Innodb_os_log_fsyncs}, $ch->{Innodb_os_log_written}
2072                                                  .
2073                                                  
2074                                                  format QUERY =
2075                                                  
2076                                                  +----------------------------------------------------------+
2077                                                  | @||||||||||||||||||||||||||||||||||||||||||||||||||||||| |
2078                                                  sprintf("QUERY %d (%.4f sec)", $which_query, $query_time)
2079                                                  +----------------------------------------------------------+
2080                                                  ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<...
2081                                                  $query_text
2082                                                  
2083                                                  __ Overall stats _______________________ Value _____________
2084                                                     Elapsed time                    @##########.###
2085                                                  $query_time
2086                                                     Data into server                @##########
2087                                                  $ch->{Bytes_received}
2088                                                     Data out of server              @##########
2089                                                  $ch->{Bytes_sent}
2090                                                  .
2091                                                  
2092                                                  format OPT_COST =
2093                                                     Optimizer cost                  @##########.###
2094                                                  $qcost
2095                                                  .
2096                                                  
2097                                                  # ############################################################################
2098                                                  # Run the program.
2099                                                  # ############################################################################
2100                                                  if ( !caller ) { exit main(@ARGV); }
2101                                                  
2102                                                  1; # Because this is a module as well as a script.
2103                                                  
2104                                                  # ############################################################################
2105                                                  # Documentation
2106                                                  # ############################################################################
2107                                                  
2108                                                  =pod
2109                                                  
2110                                                  =head1 NAME
2111                                                  
2112                                                  mk-query-profiler - Execute SQL statements and print statistics, or measure
2113                                                  activity caused by other processes.
2114                                                  
2115                                                  =head1 SYNOPSIS
2116                                                  
2117                                                  mk-query-profiler can profile the (semicolon-terminated, blank-line
2118                                                  separated) queries in a file:
2119                                                  
2120                                                     mk-query-profiler queries.sql
2121                                                     cat queries.sql | mk-query-profiler
2122                                                     mk-query-profiler -vv queries.sql
2123                                                     mk-query-profiler -v --separate --only 2,5,6 queries.sql
2124                                                     mk-query-profiler --tab queries.sql > results.csv
2125                                                  
2126                                                  It can also just observe what happens in the server:
2127                                                  
2128                                                     mk-query-profiler --external
2129                                                  
2130                                                  Or it can run shell commands from a file and measure the result:
2131                                                  
2132                                                     mk-query-profiler --external commands.txt
2133                                                     mk-query-profiler --external - < commands.txt
2134                                                  
2135                                                  Read L<"HOW TO INTERPRET"> to learn what it all means.
2136                                                  
2137                                                  =head1 RISKS
2138                                                  
2139                                                  The following section is included to inform users about the potential risks,
2140                                                  whether known or unknown, of using this tool.  The two main categories of risks
2141                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
2142                                                  tools) and those created by bugs.
2143                                                  
2144                                                  mk-query-profiler is generally read-only and very low risk.  It will execute FLUSH TABLES if you specify L<"--flush">.
2145                                                  
2146                                                  At the time of this release, we know of no bugs that could cause serious harm to
2147                                                  users.
2148                                                  
2149                                                  The authoritative source for updated information is always the online issue
2150                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
2151                                                  see a list of such issues at the following URL:
2152                                                  L<http://www.maatkit.org/bugs/mk-query-profiler>.
2153                                                  
2154                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
2155                                                  
2156                                                  =head1 DESCRIPTION
2157                                                  
2158                                                  mk-query-profiler reads a file containing one or more SQL statements or shell
2159                                                  commands, executes them, and analyzes the output of SHOW STATUS afterwards.
2160                                                  It then prints statistics about how the batch performed.  For example, it can
2161                                                  show how many table scans the batch caused, how many page reads, how many
2162                                                  temporary tables, and so forth.
2163                                                  
2164                                                  All command-line arguments are optional, but you must either specify a file
2165                                                  containing the batch to profile as the last argument, or specify that you're
2166                                                  profiling an external program with the L<"--external"> option, or provide
2167                                                  input to STDIN.
2168                                                  
2169                                                  If the file contains multiple statements, they must be separated by blank
2170                                                  lines.  If you don't do that, mk-query-profiler won't be able to split the
2171                                                  file into individual queries, and MySQL will complain about syntax errors.
2172                                                  
2173                                                  If the MySQL server version is before 5.0.2, you should make sure the server
2174                                                  is completely unused before trying to profile a batch.  Prior to this version,
2175                                                  SHOW STATUS showed only global status variables, so other queries will
2176                                                  interfere and produce false results.  mk-query-profiler will try to detect
2177                                                  if anything did interfere, but there can be no guarantees.
2178                                                  
2179                                                  Prior to MySQL 5.0.2, InnoDB status variables are not available, and prior to
2180                                                  version 5.0.3, InnoDB row lock status variables are not available.
2181                                                  mk-query-profiler will omit any output related to these variables if they're not
2182                                                  available.
2183                                                  
2184                                                  For more information about SHOW STATUS, read the relevant section of the MySQL
2185                                                  manual at
2186                                                  L<http://dev.mysql.com/doc/en/server-status-variables.html>
2187                                                  
2188                                                  =head1 HOW TO INTERPRET
2189                                                  
2190                                                  =head2 TAB-SEPARATED OUTPUT
2191                                                  
2192                                                  If you specify L<"--tab">, you will get the raw output of SHOW STATUS in
2193                                                  tab-separated format, convenient for opening with a spreadsheet.  This is not
2194                                                  the default output, but it's so much easier to describe that I'll cover it
2195                                                  first.
2196                                                  
2197                                                  =over
2198                                                  
2199                                                  =item *
2200                                                  
2201                                                  Most of the command-line options for controlling verbosity and such are
2202                                                  ignored in --tab mode.
2203                                                  
2204                                                  =item *
2205                                                  
2206                                                  The variable names you see in MySQL, such as 'Com_select', are kept --
2207                                                  there are no euphimisms, so you have to know your MySQL variables.
2208                                                  
2209                                                  =item *
2210                                                  
2211                                                  The columns are Variable_name, Before, After1...AfterN, Calibration.
2212                                                  The Variable_name column is just what it sounds like.  Before is the result
2213                                                  from the first run of SHOW STATUS.  After1, After2, etc are the results of
2214                                                  running SHOW STATUS after each query in the batch.  Finally, the last column
2215                                                  is the result of running SHOW STATUS just after the last AfterN column, so you
2216                                                  can see how much work SHOW STATUS itself causes.
2217                                                  
2218                                                  =item *
2219                                                  
2220                                                  If you specify L<"--verbose">, output includes every variable
2221                                                  mk-query-profiler measures.  If not (default) it only includes variables where
2222                                                  there was some difference from one column to the next.
2223                                                  
2224                                                  =back
2225                                                  
2226                                                  =head2 NORMAL OUTPUT
2227                                                  
2228                                                  If you don't specify --tab, you'll get a report formatted for human
2229                                                  readability.  This is the default output format.
2230                                                  
2231                                                  mk-query-profiler can output a lot of information, as you've seen if you
2232                                                  ran the examples in the L<"SYNOPSIS">.  What does it all mean?
2233                                                  
2234                                                  First, there are two basic groups of information you might see: per-query and
2235                                                  summary.  If your batch contains only one query, these will be the same and
2236                                                  you'll only see the summary.  You can recognize the difference by looking for
2237                                                  centered, all-caps, boxed-in section headers.  Externally profiled commands will
2238                                                  have EXTERNAL, individually profiled queries will have QUERY, and summary will
2239                                                  say SUMMARY.
2240                                                  
2241                                                  Next, the information in each section is grouped into subsections, headed by
2242                                                  an underlined title.  Each of these sections has varying information in it.
2243                                                  Which sections you see depends on command-line arguments and your MySQL
2244                                                  version.  I'll explain each section briefly.  If you really want to know where
2245                                                  the numbers come from, read
2246                                                  L<http://dev.mysql.com/doc/en/server-status-variables.html>.
2247                                                  
2248                                                  You need to understand which numbers are insulated from other queries and
2249                                                  which are not.  This depends on your MySQL version.  Version 5.0.2 introduced
2250                                                  the concept of session status variables, so you can see information about only
2251                                                  your own connection.  However, many variables aren't session-ized, so when you
2252                                                  have MySQL 5.0.2 or greater, you will actually see a mix of session and global
2253                                                  variables.  That means other queries happening at the same time will pollute
2254                                                  some of your results.  If you have MySQL versions older than 5.0.2, you won't
2255                                                  have ANY connection-specific stats, so your results will be polluted by other
2256                                                  queries no matter what.  Because of the mixture of session and global
2257                                                  variables, by far the best way to profile is on a completely quiet server
2258                                                  where nothing else is interfering with your results.
2259                                                  
2260                                                  While explaining the results in the sections that follow, I'll refer to a
2261                                                  value as "protected" if it comes from a session-specific variable and can be
2262                                                  relied upon to be accurate even on a busy server.  Just keep in mind, if
2263                                                  you're not using MySQL 5.0.2 or newer, your results will be inaccurate unless
2264                                                  you're running against a totally quiet server, even if I label it as
2265                                                  "protected."
2266                                                  
2267                                                  =head2 Overall stats
2268                                                  
2269                                                  This section shows the overall elapsed time for the query, as measured by
2270                                                  Perl, and the optimizer cost as reported by MySQL.
2271                                                  
2272                                                  If you're viewing separate query statistics, this is all you'll see.  If
2273                                                  you're looking at a summary, you'll also see a breakdown of the questions the
2274                                                  queries asked the server.
2275                                                  
2276                                                  The execution time is not totally reliable, as it includes network round-trip
2277                                                  time, Perl's own execution time, and so on.  However, on a low-latency
2278                                                  network, this should be fairly negligible, giving you a reasonable measure of
2279                                                  the query's time, especially for queries longer than a few tenths of a second.
2280                                                  
2281                                                  The optimizer cost comes from the Last_query_cost variable, and is protected
2282                                                  from other connections in MySQL 5.0.7 and greater.  It is not available before
2283                                                  5.0.1.
2284                                                  
2285                                                  The total number of questions is not protected, but the breakdown of
2286                                                  individual question types is, because it comes from the Com_ status variables.
2287                                                  
2288                                                  =head2 Table and index accesses
2289                                                  
2290                                                  This section shows you information about the batch's table and index-level
2291                                                  operations (as opposed to row-level operations, which will be in the next
2292                                                  section).  The "Table locks acquired" and "Temp files" values are unprotected,
2293                                                  but everything else in this section is protected.
2294                                                  
2295                                                  The "Potential filesorts" value is calculated as the number of times a query had
2296                                                  both a scan sort (Sort_scan) and created a temporary table (Created_tmp_tables).
2297                                                  There is no Sort_filesort or similar status value, so it's a best guess at
2298                                                  whether a query did a filesort.  It should be fairly accurate.
2299                                                  
2300                                                  If you specified L<"--allow-cache">, you'll see statistics on the query cache.
2301                                                  These are unprotected.
2302                                                  
2303                                                  =head2 Row operations
2304                                                  
2305                                                  These values are all about the row-level operations your batch caused.  For
2306                                                  example, how many rows were inserted, updated, or deleted.  You'll also see
2307                                                  row-level index access statistics, such as how many times the query sought and
2308                                                  read the next entry in an index.
2309                                                  
2310                                                  Depending on your MySQL version, you'll either see one or two columns of
2311                                                  information in this section.  The one headed "Handler" is all from the
2312                                                  Handler_ variables, and those statistics are protected.  If your MySQL version
2313                                                  supports it, you'll also see a column headed "InnoDB," which is unprotected.
2314                                                  
2315                                                  =head2 I/O Operations
2316                                                  
2317                                                  This section gives information on I/O operations your batch caused, both in
2318                                                  memory and on disk.  Unless you have MySQL 5.0.2 or greater, you'll only see
2319                                                  information on the key cache.  Otherwise, you'll see a lot of information on
2320                                                  InnoDB's I/O operations as well, such as how many times the query was able to
2321                                                  satisfy a read from the buffer pool and how many times it had to go to the
2322                                                  disk.
2323                                                  
2324                                                  None of the information in this section is protected.
2325                                                  
2326                                                  =head2 InnoDB Data Operations
2327                                                  
2328                                                  This section only appears when you're querying MySQL 5.0.2 or newer.  None of
2329                                                  the information is protected.  You'll see statistics about how many pages were
2330                                                  affected, how many operations took place, and how many bytes were affected.
2331                                                  
2332                                                  =head1 OPTIONS
2333                                                  
2334                                                  =over
2335                                                  
2336                                                  =item --allow-cache
2337                                                  
2338                                                  Let MySQL query cache cache the queries executed.
2339                                                  
2340                                                  By default this is disabled.  When enabled, cache profiling information is added
2341                                                  to the printout.  See L<http://dev.mysql.com/doc/en/query-cache.html> for more
2342                                                  information about the query cache.
2343                                                  
2344                                                  =item --ask-pass
2345                                                  
2346                                                  Prompt for a password when connecting to MySQL.
2347                                                  
2348                                                  =item --[no]calibrate
2349                                                  
2350                                                  default: yes
2351                                                  
2352                                                  Try to compensate for C<SHOW STATUS>.
2353                                                  
2354                                                  Measure and compensate for the "cost of observation" caused by running SHOW
2355                                                  STATUS.  Only works reliably on a quiet server; on a busy server, other
2356                                                  processes can cause the calibration to be wrong.
2357                                                  
2358                                                  =item --charset
2359                                                  
2360                                                  short form: -A; type: string
2361                                                  
2362                                                  Default character set.  If the value is utf8, sets Perl's binmode on
2363                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
2364                                                  runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
2365                                                  binmode on STDOUT without the utf8 layer, and runs SET NAMES after
2366                                                  connecting to MySQL.
2367                                                  
2368                                                  =item --config
2369                                                  
2370                                                  type: Array
2371                                                  
2372                                                  Read this comma-separated list of config files; if specified, this must be the
2373                                                  first option on the command line.
2374                                                  
2375                                                  =item --database
2376                                                  
2377                                                  short form: -D; type: string
2378                                                  
2379                                                  Database to use for connection.
2380                                                  
2381                                                  =item --defaults-file
2382                                                  
2383                                                  short form: -F; type: string
2384                                                  
2385                                                  Only read mysql options from the given file.  You must give an absolute
2386                                                  pathname.
2387                                                  
2388                                                  =item --external
2389                                                  
2390                                                  Calibrate, then pause while an external program runs.
2391                                                  
2392                                                  This is typically useful while you run an external program.  When you press
2393                                                  [enter] mk-query-profiler will stop sleeping and take another measurement, then
2394                                                  print statistics as usual.
2395                                                  
2396                                                  When there is a filename on the command line, mk-query-profiler executes
2397                                                  each line in the file as a shell command.  If you give - as the filename,
2398                                                  mk-query-profiler reads from STDIN.
2399                                                  
2400                                                  Output from shell commands is printed to STDOUT and terminated with __BEGIN__,
2401                                                  after which mk-query-profiler prints its own output.
2402                                                  
2403                                                  =item --flush
2404                                                  
2405                                                  cumulative: yes
2406                                                  
2407                                                  Flush tables.  Specify twice to do between every query.
2408                                                  
2409                                                  Calls FLUSH TABLES before profiling.  If you are executing queries from a
2410                                                  batch file, specifying --flush twice will cause mk-query-profiler to call
2411                                                  FLUSH TABLES between every query, not just once at the beginning.  Default is
2412                                                  not to flush at all. See L<http://dev.mysql.com/doc/en/flush.html> for more
2413                                                  information.
2414                                                  
2415                                                  =item --help
2416                                                  
2417                                                  Show help and exit.
2418                                                  
2419                                                  =item --host
2420                                                  
2421                                                  short form: -h; type: string
2422                                                  
2423                                                  Connect to host.
2424                                                  
2425                                                  =item --[no]innodb
2426                                                  
2427                                                  default: yes
2428                                                  
2429                                                  Show InnoDB statistics.
2430                                                  
2431                                                  =item --only
2432                                                  
2433                                                  type: hash
2434                                                  
2435                                                  Only show statistics for this comma-separated list of queries or commands.
2436                                                  
2437                                                  =item --password
2438                                                  
2439                                                  short form: -p; type: string
2440                                                  
2441                                                  Password to use when connecting.
2442                                                  
2443                                                  =item --pid
2444                                                  
2445                                                  type: string
2446                                                  
2447                                                  Create the given PID file.  The file contains the process ID of the script.
2448                                                  The PID file is removed when the script exits.  Before starting, the script
2449                                                  checks if the PID file already exists.  If it does not, then the script creates
2450                                                  and writes its own PID to it.  If it does, then the script checks the following:
2451                                                  if the file contains a PID and a process is running with that PID, then
2452                                                  the script dies; or, if there is no process running with that PID, then the
2453                                                  script overwrites the file with its own PID and starts; else, if the file
2454                                                  contains no PID, then the script dies.
2455                                                  
2456                                                  =item --port
2457                                                  
2458                                                  short form: -P; type: int
2459                                                  
2460                                                  Port number to use for connection.
2461                                                  
2462                                                  =item --separate
2463                                                  
2464                                                  Print stats separately for each query.
2465                                                  
2466                                                  The default is to show only the summary of the entire batch.  See also
2467                                                  L<"--verbose">.
2468                                                  
2469                                                  =item --[no]session
2470                                                  
2471                                                  default: yes
2472                                                  
2473                                                  Use session C<SHOW STATUS> and C<SHOW VARIABLES>.
2474                                                  
2475                                                  Disabled if the server version doesn't support it.
2476                                                  
2477                                                  =item --set-vars
2478                                                  
2479                                                  type: string; default: wait_timeout=10000
2480                                                  
2481                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this string
2482                                                  will be appended to SET and executed.
2483                                                  
2484                                                  =item --socket
2485                                                  
2486                                                  short form: -S; type: string
2487                                                  
2488                                                  Socket file to use for connection.
2489                                                  
2490                                                  =item --tab
2491                                                  
2492                                                  Print tab-separated values instead of whitespace-aligned columns.
2493                                                  
2494                                                  =item --user
2495                                                  
2496                                                  short form: -u; type: string
2497                                                  
2498                                                  User for login if not current user.
2499                                                  
2500                                                  =item --verbose
2501                                                  
2502                                                  short form: -v; cumulative: yes; default: 0
2503                                                  
2504                                                  Verbosity; specify multiple times for more detailed output.
2505                                                  
2506                                                  When L<"--tab"> is given, prints variables that don't change.  Otherwise
2507                                                  increasing the level of verbosity includes extra sections in the output.
2508                                                  
2509                                                  =item --verify
2510                                                  
2511                                                  Verify nothing else is accessing the server.
2512                                                  
2513                                                  This is a weak verification; it simply calibrates twice (see
2514                                                  L<"--[no]calibrate">) and verifies that the cost of observation remains
2515                                                  constant.
2516                                                  
2517                                                  =item --version
2518                                                  
2519                                                  Show version and exit.
2520                                                  
2521                                                  =back
2522                                                  
2523                                                  =head1 DOWNLOADING
2524                                                  
2525                                                  You can download Maatkit from Google Code at
2526                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
2527                                                  easily with a command like the following:
2528                                                  
2529                                                     wget http://www.maatkit.org/get/toolname
2530                                                     or
2531                                                     wget http://www.maatkit.org/trunk/toolname
2532                                                  
2533                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
2534                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
2535                                                  needed.  The first URL gets the latest released version of the tool, and the
2536                                                  second gets the latest trunk code from Subversion.
2537                                                  
2538                                                  =head1 ENVIRONMENT
2539                                                  
2540                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
2541                                                  the Maatkit tools:
2542                                                  
2543                                                     MKDEBUG=1 mk-....
2544                                                  
2545                                                  =head1 SYSTEM REQUIREMENTS
2546                                                  
2547                                                  You need Perl, DBI, DBD::mysql, and some core modules.
2548                                                  
2549                                                  =head1 BUGS
2550                                                  
2551                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-query-profiler>.
2552                                                  
2553                                                  Please use Google Code Issues and Groups to report bugs or request support:
2554                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
2555                                                  discuss Maatkit.
2556                                                  
2557                                                  Please include the complete command-line used to reproduce the problem you are
2558                                                  seeing, the version of all MySQL servers involved, the complete output of the
2559                                                  tool when run with L<"--version">, and if possible, debugging output produced by
2560                                                  running with the C<MKDEBUG=1> environment variable.
2561                                                  
2562                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
2563                                                  
2564                                                  This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
2565                                                  Feedback and improvements are welcome.
2566                                                  
2567                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
2568                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
2569                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
2570                                                  
2571                                                  This program is free software; you can redistribute it and/or modify it under
2572                                                  the terms of the GNU General Public License as published by the Free Software
2573                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
2574                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
2575                                                  licenses.
2576                                                  
2577                                                  You should have received a copy of the GNU General Public License along with
2578                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
2579                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
2580                                                  
2581                                                  =head1 SEE ALSO
2582                                                  
2583                                                  See also L<mk-profile-compact>.
2584                                                  
2585                                                  =head1 AUTHOR
2586                                                  
2587                                                  Baron Schwartz
2588                                                  
2589                                                  =head1 ABOUT MAATKIT
2590                                                  
2591                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
2592                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
2593                                                  code contributors.  Both are employed by Percona.  Financial support for
2594                                                  Maatkit development is primarily provided by Percona and its clients. 
2595                                                  
2596                                                  =head1 ACKNOWLEDGEMENTS
2597                                                  
2598                                                  I was inspired by the wonderful mysqlreport utility available at
2599                                                  L<http://www.hackmysql.com/>.
2600                                                  
2601                                                  Other contributors: Bart van Bragt.
2602                                                  
2603                                                  Thanks to all who have helped.
2604                                                  
2605                                                  =head1 VERSION
2606                                                  
2607                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5425 $.
2608                                                  
2609                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
57    ***      0      0      0   unless $args{$arg}
63    ***      0      0      0   exists $args{'strict'} ? :
106   ***      0      0      0   unless open my $fh, '<', $file
126   ***      0      0      0   unless $para =~ /^=head1 OPTIONS/
131   ***      0      0      0   if $para =~ /^=over/
139   ***      0      0      0   unless $para
142   ***      0      0      0   if (my($option) = $para =~ /^=item --(.*)/)
149   ***      0      0      0   if ($para =~ /: /) { }
153   ***      0      0      0   unless $attributes{$attrib}
157   ***      0      0      0   if ($attribs{'short form'})
173   ***      0      0      0   if $para =~ /^=item/
175   ***      0      0      0   if (my($base_option) = $option =~ /^\[no\](.*)/)
180   ***      0      0      0   $attribs{'short form'} ? :
      ***      0      0      0   $attribs{'negatable'} ? :
      ***      0      0      0   $attribs{'cumulative'} ? :
      ***      0      0      0   $attribs{'type'} ? :
      ***      0      0      0   $attribs{'default'} ? :
      ***      0      0      0   $attribs{'group'} ? :
192   ***      0      0      0   unless $para
195   ***      0      0      0   if ($para =~ /^=head1/)
199   ***      0      0      0   if $para =~ /^=item --/
203   ***      0      0      0   unless @specs
214   ***      0      0      0   if (ref $opt) { }
219   ***      0      0      0   if (not $long)
224   ***      0      0      0   if exists $$self{'opts'}{$long}
227   ***      0      0      0   if (length $long == 1)
232   ***      0      0      0   if ($short) { }
233   ***      0      0      0   if exists $$self{'short_opts'}{$short}
242   ***      0      0      0   $$opt{'spec'} =~ /!/ ? :
243   ***      0      0      0   $$opt{'spec'} =~ /\+/ ? :
244   ***      0      0      0   $$opt{'desc'} =~ /required/ ? :
256   ***      0      0      0   if ($type and $type eq 'd' and not $$self{'dp'})
261   ***      0      0      0   if $type and $type =~ /[HhAadzm]/
263   ***      0      0      0   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
264   ***      0      0      0   defined $def ? :
268   ***      0      0      0   if ($long eq 'config')
272   ***      0      0      0   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
285   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
290   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
295   ***      0      0      0   if ($opt =~ /default to/)
300   ***      0      0      0   if ($opt =~ /restricted to option groups/)
310   ***      0      0      0   unless $rule_ok
327   ***      0      0      0   unless exists $$self{'opts'}{$long}
351   ***      0      0      0   unless exists $$self{'opts'}{$long}
371   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***      0      0      0   exists $$self{'opts'}{$opt} ? :
376   ***      0      0      0   if ($$opt{'is_cumulative'}) { }
391   ***      0      0      0   $$self{'opts'}{$long}{'is_cumulative'} ? :
      ***      0      0      0   exists $$self{'defaults'}{$long} ? :
400   ***      0      0      0   if (@ARGV and $ARGV[0] eq '--config')
404   ***      0      0      0   if ($self->has('config'))
410   ***      0      0      0   if ($EVAL_ERROR)
411   ***      0      0      0   $self->got('config') ? :
426   ***      0      0      0   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
429   ***      0      0      0   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
430   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
436   ***      0      0      0   if (@ARGV and $$self{'strict'})
442   ***      0      0      0   if (@set > 1)
453   ***      0      0      0   if (@set == 0)
463   ***      0      0      0   if ($$opt{'got'}) { }
      ***      0      0      0   elsif ($$opt{'is_required'}) { }
464   ***      0      0      0   if (exists $$self{'disables'}{$long})
471   ***      0      0      0   if (exists $$self{'allowed_groups'}{$long})
483   ***      0      0      0   if $restricted_opt eq $long
484   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
489   ***      0      0      0   if (@restricted_opts)
491   ***      0      0      0   if (@restricted_opts == 1) { }
520   ***      0      0      0   unless $opt and $$opt{'type'}
523   ***      0      0      0   if ($val and $$opt{'type'} eq 'm') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'd') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'z') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
526   ***      0      0      0   if (not $suffix)
532   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
533   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
548   ***      0      0      0   if ($from_key)
559   ***      0      0      0   if (defined $num) { }
560   ***      0      0      0   if ($factor)
587   ***      0      0      0   length $opt == 1 ? :
588   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
595   ***      0      0      0   length $opt == 1 ? :
596   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
603   ***      0      0      0   length $opt == 1 ? :
604   ***      0      0      0   defined $long ? :
609   ***      0      0      0   length $opt == 1 ? :
610   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
644   ***      0      0      0   if ($$self{'opts'}{'help'}{'got'}) { }
      ***      0      0      0   elsif (scalar @{$$self{'errors'};}) { }
645   ***      0      0      0   unless print $self->print_usage
649   ***      0      0      0   unless print $self->print_errors
658   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
667   ***      0      0      0   unless $$self{'got_opts'}
670   ***      0      0      0   $$_{'is_negatable'} ? :
674   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
690   ***      0      0      0   $group eq 'default' ? :
696   ***      0      0      0   $$opt{'is_negatable'} ? :
699   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
708   ***      0      0      0   if ($short) { }
717   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
721   ***      0      0      0   if ($$self{'dp'})
729   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
741   ***      0      0      0   if ref $_[0] eq 'OptionParser'
744   ***      0      0      0   unless print $prompt
752   ***      0      0      0   unless print "\n"
755   ***      0      0      0   if ($EVAL_ERROR)
777   ***      0      0      0   unless open my $fh, '<', $filename
785   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
788   ***      0      0      0   if ($line eq '--')
793   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
811   ***      0      0      0   unless open my $fh, '<', $file
815   ***      0      0      0   unless $para =~ /^=pod$/m
819   ***      0      0      0   unless $para =~ /$regex/
824   ***      0      0      0   unless close $fh
838   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
853   ***      0      0      0   defined $_ ? :
939   ***     50      0      3   if (@_ > 2)
948   ***     50      0      1   if (not $dsn)
960   ***     50      4      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
972   ***     50      0      8   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
978          100      4      4   if (not defined $final_props{$key})
985   ***     50      0      4   unless exists $opts{$key}
988   ***     50      0      1   if (my $required = $self->prop('required'))
990   ***      0      0      0   unless $final_props{$key}
999   ***      0      0      0   unless ref $o eq 'OptionParser'
1002  ***      0      0      0   if $o->has($_)
1012  ***      0      0      0   unless ref $dsn
1013  ***      0      0      0   $_ eq 'p' ? :
1014  ***      0      0      0   if defined $$dsn{$_}
1027  ***      0      0      0   $opts{$key}{'copy'} ? :
1041  ***     50      0      1   if ($driver eq 'Pg') { }
1073  ***     50      0      1   $cxn_string =~ /charset=utf8/ ? :
1082  ***     50      0      1   if (not $have_dbi)
1101  ***     50      1      0   if ($cxn_string =~ /mysql/i)
1109  ***     50      0      1   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1114  ***      0      0      0   if ($charset eq 'utf8') { }
1115  ***      0      0      0   unless binmode STDOUT, ':utf8'
1119  ***      0      0      0   unless binmode STDOUT
1123  ***     50      0      1   if ($self->prop('set-vars'))
1130  ***     50      0      1   if (not $dbh and $EVAL_ERROR)
1132  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1145  ***      0      0      0   if (not $tries)
1167  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1184  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1194  ***      0      0      0   unless $dsn_1
1195  ***      0      0      0   unless $dsn_2
1199  ***      0      0      0   if ($args{'overwrite'}) { }
1200  ***      0      0      0   defined $$dsn_1{$key} ? :
1203  ***      0      0      0   defined $$dsn_2{$key} ? :
1212  ***      0      0      0   defined $_ ? :
1241  ***      0      0      0   unless $args{$arg}
1244  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
1260  ***      0      0      0   unless defined(my $pid = fork)
1261  ***      0      0      0   if ($pid)
1268  ***      0      0      0   unless POSIX::setsid()
1269  ***      0      0      0   unless chdir '/'
1275  ***      0      0      0   if (-t STDIN)
1277  ***      0      0      0   unless open STDIN, '/dev/null'
1281  ***      0      0      0   if ($$self{'log_file'}) { }
1283  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
1287  ***      0      0      0   unless open STDERR, '>&STDOUT'
1291  ***      0      0      0   if (-t STDOUT)
1293  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
1296  ***      0      0      0   if (-t STDERR)
1298  ***      0      0      0   unless open STDERR, '>', '/dev/null'
1309  ***      0      0      0   $self ? :
1311  ***      0      0      0   if ($PID_file and -f $PID_file) { }
1314  ***      0      0      0   if $EVAL_ERROR
1316  ***      0      0      0   if ($pid) { }
1318  ***      0      0      0   if ($pid_is_alive) { }
1340  ***      0      0      0   if (exists $$self{'child'})
1352  ***      0      0      0   if (not $PID_file)
1359  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
1361  ***      0      0      0   unless print $PID_FH $PID
1363  ***      0      0      0   unless close $PID_FH
1372  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
1373  ***      0      0      0   unless unlink $$self{'PID_file'}
1385  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
1391  ***      0      0      0   defined $_ ? :
1503  ***      0      0      0   if ($o->get('pid'))
1512  ***      0      0      0   if ($o->get('ask-pass'))
1520  ***      0      0      0   $o->get('innodb') && $$variables{'have_innodb'} eq 'YES' ? :
1535  ***      0      0      0   if ($$variables{'query_cache_size'})
1536  ***      0      0      0   if ($o->get('allow-cache') or $o->get('external')) { }
1546  ***      0      0      0   $have_last ? :
      ***      0      0      0   $have_qcache ? :
      ***      0      0      0   $have_last ? :
      ***      0      0      0   $have_qcache ? :
      ***      0      0      0   $have_innodb ? :
      ***      0      0      0   $have_last ? :
      ***      0      0      0   $have_qcache ? :
      ***      0      0      0   $have_innodb ? :
      ***      0      0      0   $have_rowlock ? :
      ***      0      0      0   $have_innodb ? :
1574  ***      0      0      0   $have_session ? :
1595  ***      0      0      0   $o->get('calibrate') ? :
1597  ***      0      0      0   if ($o->get('verify'))
1599  ***      0      0      0   $o->get('calibrate') ? :
1606  ***      0      0      0   if ($$base_3{$key} != $$base_2{$key})
1625  ***      0      0      0   if ($o->get('external')) { }
1626  ***      0      0      0   if (not @ARGV) { }
1645  ***      0      0      0   unless $line
1664  ***      0      0      0   unless $line
1685  ***      0      0      0   if ($o->get('tab')) { }
1698  ***      0      0      0   if (not $o->get('verbose'))
1706  ***      0      0      0   if defined $statuses[$_]{$var} and defined $statuses[$_ - 1]{$var}
1725  ***      0      0      0   defined $$_{$key} ? :
1739  ***      0      0      0   $i ? :
1750  ***      0      0      0   $$ch{'Qcache_inserts'} > 0 && $$ch{'Qcache_queries_in_cache'} == 0 || $$ch{'Qcache_queries_in_cache'} < 0 ? :
1760  ***      0      0      0   if ($o->get('separate') and @queries > 1 and !$o->get('only') || $o->get('only')->{$i + 1})
1764  ***      0      0      0   $o->get('external') ? :
1765  ***      0      0      0   $o->get('external') ? :
1784  ***      0      0      0   if (not $have_session)
1785  ***      0      0      0   if ($queries[-1]{'status'}{'Questions'} - $$sql_status_0{'Questions'} > @queries * 2 + 1) { }
1809  ***      0      0      0   if not $o->get('flush') or $o->get('flush') == 1 and $have_flushed
1812  ***      0      0      0   if ($EVAL_ERROR)
1824  ***      0      0      0   if ($val < 0 and not defined $non_monotonic_vars{$_})
1834  ***      0      0      0   $o->get('external') ? :
      ***      0      0      0   $have_session ? :
1857  ***      0      0      0   unless open my $file, '<', "$filename"


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
256   ***      0      0      0      0   $type and $type eq 'd'
      ***      0      0      0      0   $type and $type eq 'd' and not $$self{'dp'}
261   ***      0      0      0      0   $type and $type =~ /[HhAadzm]/
400   ***      0      0      0      0   @ARGV and $ARGV[0] eq '--config'
429   ***      0      0      0      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
436   ***      0      0      0      0   @ARGV and $$self{'strict'}
520   ***      0      0      0      0   $opt and $$opt{'type'}
523   ***      0      0      0      0   $val and $$opt{'type'} eq 'm'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'd'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'z'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'a'
588   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
596   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
610   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
699   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
793   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
972   ***     66      4      4      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33      8      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1094  ***     66      1      0      1   not $dbh and $tries--
1130  ***     33      1      0      0   not $dbh and $EVAL_ERROR
1311  ***      0      0      0      0   $PID_file and -f $PID_file
1372  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
1520  ***      0      0      0      0   $o->get('innodb') && $$variables{'have_innodb'} eq 'YES'
1524  ***      0      0      0      0   $o->get('session') && version_ge($dbh, '5.0.2')
1528  ***      0      0      0      0   version_ge($dbh, '5.0.3') && $have_innodb
1531  ***      0      0      0      0   version_ge($dbh, '5.0.1') && !$o->get('external')
1706  ***      0      0      0      0   defined $statuses[$_]{$var} and defined $statuses[$_ - 1]{$var}
1750  ***      0      0      0      0   $$ch{'Qcache_inserts'} > 0 && $$ch{'Qcache_queries_in_cache'} == 0
1760  ***      0      0      0      0   $o->get('separate') and @queries > 1
      ***      0      0      0      0   $o->get('separate') and @queries > 1 and !$o->get('only') || $o->get('only')->{$i + 1}
1809  ***      0      0      0      0   $o->get('flush') == 1 and $have_flushed
1824  ***      0      0      0      0   $val < 0 and not defined $non_monotonic_vars{$_}

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
41    ***     50      0      1   $ENV{'MKDEBUG'} || 0
61    ***      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
63    ***      0      0      0   $args{'prompt'} || '<options>'
      ***      0      0      0   $args{'dp'} || undef
105   ***      0      0      0   $file ||= '/home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler'
246   ***      0      0      0   $$opt{'group'} ||= 'default'
528   ***      0      0      0   $s || 's'
537   ***      0      0      0   $prefix || ''
565   ***      0      0      0   $pre || ''
572   ***      0      0      0   $val || ''
575   ***      0      0      0   $val || ''
633   ***      0      0      0   $$self{'description'} || ''
701   ***      0      0      0   $s ||= 's'
727   ***      0      0      0   $$opt{'type'} || ''
882   ***     50      0      1   $ENV{'MKDEBUG'} || 0
953   ***     50      0      1   $prev ||= {}
954   ***     50      0      1   $defaults ||= {}
1027  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1040  ***     50      0      1   $self->prop('dbidriver') || ''
1044  ***      0      0      0   $$info{'D'} || ''
1050  ***     50      0      1   $$info{'D'} || ''
1072  ***     50      1      0   $opts ||= {}
1167  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1183  ***      0      0      0   $level ||= 0
1184  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1236  ***     50      0      1   $ENV{'MKDEBUG'} || 0
1419  ***     50      0      1   $ENV{'MKDEBUG'} || 0
1819  ***      0      0      0   $num_base ||= 1
1820  ***      0      0      0   $$after{$_} ||= 0
1822  ***      0      0      0   $$before{$_} ||= 0
1839  ***      0      0      0   $result{$_} || 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
60    ***      0      0      0      0   $program_name ||= $PROGRAM_NAME
61    ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
523   ***      0      0      0      0   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1063  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1064  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1065  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1066  ***      0      0      0      0   $$dsn{'u'} ||= $user
1067  ***      0      0      0      0   $$dsn{'D'} ||= $db
1385  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
1536  ***      0      0      0      0   $o->get('allow-cache') or $o->get('external')
1750  ***      0      0      0      0   $$ch{'Qcache_inserts'} > 0 && $$ch{'Qcache_queries_in_cache'} == 0 || $$ch{'Qcache_queries_in_cache'} < 0
1760  ***      0      0      0      0   !$o->get('only') || $o->get('only')->{$i + 1}
1809  ***      0      0      0      0   not $o->get('flush') or $o->get('flush') == 1 and $have_flushed


Covered Subroutines
-------------------

Subroutine           Count Location                                                         
-------------------- ----- -----------------------------------------------------------------
BEGIN                    1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1230
BEGIN                    1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1231
BEGIN                    1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1233
BEGIN                    1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1234
BEGIN                    1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1236
BEGIN                    1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1413
BEGIN                    1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1414
BEGIN                    1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1415
BEGIN                    1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1419
BEGIN                    1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1420
BEGIN                    1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:22  
BEGIN                    1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:23  
BEGIN                    1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:34  
BEGIN                    1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:35  
BEGIN                    1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:37  
BEGIN                    1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:38  
BEGIN                    1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:39  
BEGIN                    1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:41  
BEGIN                    1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:870 
BEGIN                    1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:871 
BEGIN                    1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:872 
BEGIN                    1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:873 
BEGIN                    1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:882 
get_cxn_params           1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1037
get_dbh                  1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1071
new                      1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:885 
parse                    1 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:947 
prop                     3 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:938 

Uncovered Subroutines
---------------------

Subroutine           Count Location                                                         
-------------------- ----- -----------------------------------------------------------------
DESTROY                  0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1384
__ANON__                 0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1706
__ANON__                 0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:424 
_d                       0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1211
_d                       0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1390
_d                       0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:852 
_get_participants        0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:324 
_make_PID_file           0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1349
_parse_specs             0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:210 
_pod_to_specs            0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:104 
_read_config_file        0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:776 
_remove_PID_file         0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1371
_set_option              0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:370 
_validate_type           0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:519 
as_string                0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1011
check_PID_file           0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1308
clone                    0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:829 
copy                     0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1193
daemonize                0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1257
descr                    0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:632 
disconnect               0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1176
errors                   0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:622 
fill_in_dsn              0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1059
flush_tables             0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1808
get                      0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:586 
get_changes              0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1818
get_defaults             0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:360 
get_defaults_files       0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:99  
get_file                 0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1856
get_groups               0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:365 
get_hostname             0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1166
get_opts                 0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:387 
get_specs                0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:92  
get_status_info          0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1833
get_variables            0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1843
got                      0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:594 
has                      0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:602 
main                     0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1470
make_PID_file            0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1339
new                      0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1239
new                      0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:55  
opts                     0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:336 
parse_options            0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:998 
print_active_handles     0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1182
print_errors             0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:656 
print_usage              0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:666 
prompt                   0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:627 
prompt_noecho            0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:741 
read_para_after          0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:810 
save_error               0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:617 
set                      0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:608 
set_defaults             0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:348 
short_opts               0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:342 
usage                    0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1020
usage_or_errors          0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:643 
version_ge               0 /home/daniel/dev/maatkit/mk-query-profiler/mk-query-profiler:1850


mk-query-profiler.t

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     BEGIN {
4     ***      1     50     33      1            35      die "The MAATKIT_TRUNK environment variable is not set.  See http://code.google.com/p/maatkit/wiki/Testing"
5                                                           unless $ENV{MAATKIT_TRUNK} && -d $ENV{MAATKIT_TRUNK};
6              1                                  8      unshift @INC, "$ENV{MAATKIT_TRUNK}/common";
7                                                     };
8                                                     
9              1                    1            14   use strict;
               1                                  2   
               1                                  6   
10             1                    1             7   use warnings FATAL => 'all';
               1                                  2   
               1                                  8   
11             1                    1            15   use English qw(-no_match_vars);
               1                                  3   
               1                                 10   
12             1                    1            22   use Test::More tests => 4;
               1                                  3   
               1                                 14   
13                                                    
14             1                    1            16   use MaatkitTest;
               1                                  3   
               1                                 17   
15             1                    1            11   use Sandbox;
               1                                  4   
               1                                 18   
16             1                                 29   require "$trunk/mk-query-profiler/mk-query-profiler";
17                                                    
18             1                                 11   my $dp = new DSNParser();
19             1                                 10   my $sb = new Sandbox(basedir => '/tmp', DSNParser => $dp);
20             1                                 60   my $dbh = $sb->get_dbh_for('master');
21                                                    
22             1                                 22   my $cnf = '/tmp/12345/my.sandbox.cnf';
23             1                                  8   my $cmd = "$trunk/mk-query-profiler/mk-query-profiler -F $cnf ";
24             1                                  8   my $mysql = $sb->_use_for('master');
25                                                    
26             1                                 24   my $output;
27                                                    
28             1                                  2   SKIP: {
29             1                                  4      skip 'Sandbox master does not have the sakila database', 3
30    ***      1     50     33                    9         unless $dbh && @{$dbh->selectcol_arrayref('SHOW DATABASES LIKE "sakila"')};
31                                                    
32             1                             153314      $output = `echo "select * from sakila.film" | $cmd`;
33             1                                 72      like(
34                                                          $output,
35                                                          qr{Questions\s+1},
36                                                          'It lives with input on STDIN',
37                                                       );
38                                                    
39             1                             148108      $output = `$cmd -vvv --innodb $trunk/mk-query-profiler/t/sample.sql`;
40             1                                 60      like(
41                                                          $output,
42                                                          qr{Temp files\s+0},
43                                                          'It lives with verbosity, InnoDB, and a file input',
44                                                       );
45             1                                 22      like(
46                                                          $output,
47                                                          qr{Handler _+ InnoDB},
48                                                          'I found InnoDB stats',
49                                                       );
50                                                    
51             1                                 26      $sb->wipe_clean($dbh);
52                                                    }
53                                                    
54                                                    # #########################################################################
55                                                    # Issue 391: Add --pid option to all scripts
56                                                    # #########################################################################
57             1                               4802   `touch /tmp/mk-script.pid`;
58             1                             108149   $output = `$cmd -vvv --innodb sample.sql --pid /tmp/mk-script.pid 2>&1`;
59             1                                 60   like(
60                                                       $output,
61                                                       qr{PID file /tmp/mk-script.pid already exists},
62                                                       'Dies if PID file already exists (issue 391)'
63                                                    );
64             1                               4561   `rm -rf /tmp/mk-script.pid`;
65                                                    
66             1                                 10   exit;


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
4     ***     50      0      1   unless $ENV{'MAATKIT_TRUNK'} and -d $ENV{'MAATKIT_TRUNK'}
30    ***     50      0      1   unless $dbh and @{$dbh->selectcol_arrayref('SHOW DATABASES LIKE "sakila"');}


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
4     ***     33      0      0      1   $ENV{'MAATKIT_TRUNK'} and -d $ENV{'MAATKIT_TRUNK'}
30    ***     33      0      0      1   $dbh and @{$dbh->selectcol_arrayref('SHOW DATABASES LIKE "sakila"');}


Covered Subroutines
-------------------

Subroutine Count Location              
---------- ----- ----------------------
BEGIN          1 mk-query-profiler.t:10
BEGIN          1 mk-query-profiler.t:11
BEGIN          1 mk-query-profiler.t:12
BEGIN          1 mk-query-profiler.t:14
BEGIN          1 mk-query-profiler.t:15
BEGIN          1 mk-query-profiler.t:4 
BEGIN          1 mk-query-profiler.t:9 


