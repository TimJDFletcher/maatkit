---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...v/maatkit/mk-find/mk-find   12.2    2.5    5.9   32.1    n/a    0.1   10.1
mk-find.t                      98.6   50.0   33.3  100.0    n/a   99.9   93.3
Total                          16.4    2.9    6.2   35.5    n/a  100.0   12.9
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:22:17 2010
Finish:       Thu Jan 28 22:22:17 2010

Run:          ./mk-find.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:22:18 2010
Finish:       Thu Jan 28 22:22:21 2010

/home/daniel/dev/maatkit/mk-find/mk-find

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This is mk-find, a program that searches for MySQL tables and takes actions
4                                                     # like GNU find.
5                                                     #
6                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
7                                                     # Feedback and improvements are welcome.
8                                                     #
9                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
10                                                    # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
11                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
12                                                    #
13                                                    # This program is free software; you can redistribute it and/or modify it under
14                                                    # the terms of the GNU General Public License as published by the Free Software
15                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
16                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
17                                                    # licenses.
18                                                    #
19                                                    # You should have received a copy of the GNU General Public License along with
20                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
21                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
22                                                    
23             1                    1            10   use strict;
               1                                  3   
               1                                 11   
24             1                    1            14   use warnings FATAL => 'all';
               1                                  2   
               1                                  6   
25                                                    
26                                                    our $VERSION = '@VERSION@';
27                                                    our $DISTRIB = '@DISTRIB@';
28                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5425 $ =~ m/(\d+)/g, 0));
29                                                    
30                                                    # ###########################################################################
31                                                    # DSNParser package 5266
32                                                    # ###########################################################################
33                                                    package DSNParser;
34                                                    
35             1                    1             7   use strict;
               1                                  2   
               1                                  4   
36             1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  5   
37             1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  7   
38             1                    1             7   use Data::Dumper;
               1                                  2   
               1                                  8   
39                                                    $Data::Dumper::Indent    = 0;
40                                                    $Data::Dumper::Quotekeys = 0;
41                                                    
42                                                    eval {
43                                                       require DBI;
44                                                    };
45                                                    my $have_dbi = $EVAL_ERROR ? 0 : 1;
46                                                    
47    ***      1            50      1             7   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 37   
48                                                    
49                                                    sub new {
50             1                    1             6      my ( $class, @opts ) = @_;
51             1                                 60      my $self = {
52                                                          opts => {
53                                                             A => {
54                                                                desc => 'Default character set',
55                                                                dsn  => 'charset',
56                                                                copy => 1,
57                                                             },
58                                                             D => {
59                                                                desc => 'Database to use',
60                                                                dsn  => 'database',
61                                                                copy => 1,
62                                                             },
63                                                             F => {
64                                                                desc => 'Only read default options from the given file',
65                                                                dsn  => 'mysql_read_default_file',
66                                                                copy => 1,
67                                                             },
68                                                             h => {
69                                                                desc => 'Connect to host',
70                                                                dsn  => 'host',
71                                                                copy => 1,
72                                                             },
73                                                             p => {
74                                                                desc => 'Password to use when connecting',
75                                                                dsn  => 'password',
76                                                                copy => 1,
77                                                             },
78                                                             P => {
79                                                                desc => 'Port number to use for connection',
80                                                                dsn  => 'port',
81                                                                copy => 1,
82                                                             },
83                                                             S => {
84                                                                desc => 'Socket file to use for connection',
85                                                                dsn  => 'mysql_socket',
86                                                                copy => 1,
87                                                             },
88                                                             u => {
89                                                                desc => 'User for login if not current user',
90                                                                dsn  => 'user',
91                                                                copy => 1,
92                                                             },
93                                                          },
94                                                       };
95             1                                  5      foreach my $opt ( @opts ) {
96    ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
97    ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
98                                                       }
99             1                                 15      return bless $self, $class;
100                                                   }
101                                                   
102                                                   sub prop {
103            3                    3            15      my ( $self, $prop, $value ) = @_;
104   ***      3     50                          15      if ( @_ > 2 ) {
105   ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
106   ***      0                                  0         $self->{$prop} = $value;
107                                                      }
108            3                                 23      return $self->{$prop};
109                                                   }
110                                                   
111                                                   sub parse {
112            1                    1            43      my ( $self, $dsn, $prev, $defaults ) = @_;
113   ***      1     50                           6      if ( !$dsn ) {
114   ***      0                                  0         MKDEBUG && _d('No DSN to parse');
115   ***      0                                  0         return;
116                                                      }
117            1                                  3      MKDEBUG && _d('Parsing', $dsn);
118   ***      1            50                    4      $prev     ||= {};
119   ***      1            50                    4      $defaults ||= {};
120            1                                  3      my %given_props;
121            1                                 21      my %final_props;
122            1                                  3      my %opts = %{$self->{opts}};
               1                                  9   
123                                                   
124            1                                  8      foreach my $dsn_part ( split(/,/, $dsn) ) {
125   ***      4     50                          34         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
126            4                                 16            $given_props{$prop_key} = $prop_val;
127                                                         }
128                                                         else {
129   ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
130   ***      0                                  0            $given_props{h} = $dsn_part;
131                                                         }
132                                                      }
133                                                   
134            1                                  6      foreach my $key ( keys %opts ) {
135            8                                 18         MKDEBUG && _d('Finding value for', $key);
136            8                                 25         $final_props{$key} = $given_props{$key};
137   ***      8     50     66                   63         if (   !defined $final_props{$key}
      ***                   33                        
138                                                              && defined $prev->{$key} && $opts{$key}->{copy} )
139                                                         {
140   ***      0                                  0            $final_props{$key} = $prev->{$key};
141   ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
142                                                         }
143            8    100                          34         if ( !defined $final_props{$key} ) {
144            4                                 12            $final_props{$key} = $defaults->{$key};
145            4                                 11            MKDEBUG && _d('Copying value for', $key, 'from defaults');
146                                                         }
147                                                      }
148                                                   
149            1                                  5      foreach my $key ( keys %given_props ) {
150   ***      4     50                          17         die "Unrecognized DSN part '$key' in '$dsn'\n"
151                                                            unless exists $opts{$key};
152                                                      }
153   ***      1     50                           6      if ( (my $required = $self->prop('required')) ) {
154   ***      0                                  0         foreach my $key ( keys %$required ) {
155   ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
156                                                         }
157                                                      }
158                                                   
159            1                                  7      return \%final_props;
160                                                   }
161                                                   
162                                                   sub parse_options {
163   ***      0                    0             0      my ( $self, $o ) = @_;
164   ***      0      0                           0      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
165   ***      0                                  0      my $dsn_string
166                                                         = join(',',
167   ***      0      0                           0             map  { "$_=".$o->get($_); }
168   ***      0                                  0             grep { $o->has($_) && $o->get($_) }
169   ***      0                                  0             keys %{$self->{opts}}
170                                                           );
171   ***      0                                  0      MKDEBUG && _d('DSN string made from options:', $dsn_string);
172   ***      0                                  0      return $self->parse($dsn_string);
173                                                   }
174                                                   
175                                                   sub as_string {
176   ***      0                    0             0      my ( $self, $dsn ) = @_;
177   ***      0      0                           0      return $dsn unless ref $dsn;
178   ***      0      0                           0      return join(',',
179   ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
180   ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
181                                                         sort keys %$dsn );
182                                                   }
183                                                   
184                                                   sub usage {
185   ***      0                    0             0      my ( $self ) = @_;
186   ***      0                                  0      my $usage
187                                                         = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
188                                                         . "  KEY  COPY  MEANING\n"
189                                                         . "  ===  ====  =============================================\n";
190   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
191   ***      0                                  0      foreach my $key ( sort keys %opts ) {
192   ***      0      0      0                    0         $usage .= "  $key    "
193                                                                .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
194                                                                .  ($opts{$key}->{desc} || '[No description]')
195                                                                . "\n";
196                                                      }
197   ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
198   ***      0                                  0      return $usage;
199                                                   }
200                                                   
201                                                   sub get_cxn_params {
202            1                    1            14      my ( $self, $info ) = @_;
203            1                                  2      my $dsn;
204            1                                  3      my %opts = %{$self->{opts}};
               1                                  9   
205   ***      1            50                    5      my $driver = $self->prop('dbidriver') || '';
206   ***      1     50                           5      if ( $driver eq 'Pg' ) {
207   ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
208   ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
209   ***      0             0                    0                        grep { defined $info->{$_} }
210                                                                        qw(h P));
211                                                      }
212                                                      else {
213            2                                 15         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
214            5                                 18            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
215   ***      1            50                   12                        grep { defined $info->{$_} }
216                                                                        qw(F h P S A))
217                                                            . ';mysql_read_default_group=client';
218                                                      }
219            1                                  3      MKDEBUG && _d($dsn);
220            1                                  9      return ($dsn, $info->{u}, $info->{p});
221                                                   }
222                                                   
223                                                   sub fill_in_dsn {
224   ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
225   ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
226   ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
227   ***      0                                  0      $user =~ s/@.*//;
228   ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
229   ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
230   ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
231   ***      0             0                    0      $dsn->{u} ||= $user;
232   ***      0             0                    0      $dsn->{D} ||= $db;
233                                                   }
234                                                   
235                                                   sub get_dbh {
236            1                    1             6      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
237   ***      1            50                    5      $opts ||= {};
238   ***      1     50                          10      my $defaults = {
239                                                         AutoCommit         => 0,
240                                                         RaiseError         => 1,
241                                                         PrintError         => 0,
242                                                         ShowErrorStatement => 1,
243                                                         mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
244                                                      };
245            1                                  5      @{$defaults}{ keys %$opts } = values %$opts;
               1                                  4   
246                                                   
247   ***      1     50                           5      if ( !$have_dbi ) {
248   ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
249                                                            . "installed or not found.  Run 'perl -MDBI' to see the directories "
250                                                            . "that Perl searches for DBI.  If DBI is not installed, try:\n"
251                                                            . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
252                                                            . "  RHEL/CentOS    yum install perl-DBI\n"
253                                                            . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
254                                                   
255                                                      }
256                                                   
257            1                                  5      my $dbh;
258            1                                  3      my $tries = 2;
259   ***      1            66                   11      while ( !$dbh && $tries-- ) {
260                                                         MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
261            1                                  2            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
262                                                   
263            1                                  3         eval {
264            1                                  7            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
265                                                   
266   ***      1     50                          12            if ( $cxn_string =~ m/mysql/i ) {
267            1                                  7               my $sql;
268                                                   
269            1                                  3               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
270                                                                    . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
271            1                                  3               MKDEBUG && _d($dbh, ':', $sql);
272            1                                124               $dbh->do($sql);
273                                                   
274   ***      1     50                           9               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
275   ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
276   ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
277   ***      0                                  0                  $dbh->do($sql);
278   ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
279   ***      0      0                           0                  if ( $charset eq 'utf8' ) {
280   ***      0      0                           0                     binmode(STDOUT, ':utf8')
281                                                                        or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
282                                                                  }
283                                                                  else {
284   ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
285                                                                  }
286                                                               }
287                                                   
288   ***      1     50                           6               if ( $self->prop('set-vars') ) {
289   ***      0                                  0                  $sql = "SET " . $self->prop('set-vars');
290   ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
291   ***      0                                  0                  $dbh->do($sql);
292                                                               }
293                                                            }
294                                                         };
295   ***      1     50     33                   11         if ( !$dbh && $EVAL_ERROR ) {
296   ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
297   ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
298   ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
299   ***      0                                  0               delete $defaults->{mysql_enable_utf8};
300                                                            }
301                                                            elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
302   ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
303                                                                  . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
304                                                                  . "the directories that Perl searches for DBD::mysql.  If "
305                                                                  . "DBD::mysql is not installed, try:\n"
306                                                                  . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
307                                                                  . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
308                                                                  . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
309                                                            }
310   ***      0      0                           0            if ( !$tries ) {
311   ***      0                                  0               die $EVAL_ERROR;
312                                                            }
313                                                         }
314                                                      }
315                                                   
316            1                                  4      MKDEBUG && _d('DBH info: ',
317                                                         $dbh,
318                                                         Dumper($dbh->selectrow_hashref(
319                                                            'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
320                                                         'Connection info:',      $dbh->{mysql_hostinfo},
321                                                         'Character set info:',   Dumper($dbh->selectall_arrayref(
322                                                                        'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
323                                                         '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
324                                                         '$DBI::VERSION:',        $DBI::VERSION,
325                                                      );
326                                                   
327            1                                  7      return $dbh;
328                                                   }
329                                                   
330                                                   sub get_hostname {
331   ***      0                    0                    my ( $self, $dbh ) = @_;
332   ***      0      0      0                           if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
333   ***      0                                            return $host;
334                                                      }
335   ***      0                                         my ( $hostname, $one ) = $dbh->selectrow_array(
336                                                         'SELECT /*!50038 @@hostname, */ 1');
337   ***      0                                         return $hostname;
338                                                   }
339                                                   
340                                                   sub disconnect {
341   ***      0                    0                    my ( $self, $dbh ) = @_;
342   ***      0                                         MKDEBUG && $self->print_active_handles($dbh);
343   ***      0                                         $dbh->disconnect;
344                                                   }
345                                                   
346                                                   sub print_active_handles {
347   ***      0                    0                    my ( $self, $thing, $level ) = @_;
348   ***      0             0                           $level ||= 0;
349   ***      0      0      0                           printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
350                                                         $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
351                                                         or die "Cannot print: $OS_ERROR";
352   ***      0                                         foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                      
      ***      0                                      
353   ***      0                                            $self->print_active_handles( $handle, $level + 1 );
354                                                      }
355                                                   }
356                                                   
357                                                   sub copy {
358   ***      0                    0                    my ( $self, $dsn_1, $dsn_2, %args ) = @_;
359   ***      0      0                                  die 'I need a dsn_1 argument' unless $dsn_1;
360   ***      0      0                                  die 'I need a dsn_2 argument' unless $dsn_2;
361   ***      0                                         my %new_dsn = map {
362   ***      0                                            my $key = $_;
363   ***      0                                            my $val;
364   ***      0      0                                     if ( $args{overwrite} ) {
365   ***      0      0                                        $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
366                                                         }
367                                                         else {
368   ***      0      0                                        $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
369                                                         }
370   ***      0                                            $key => $val;
371   ***      0                                         } keys %{$self->{opts}};
372   ***      0                                         return \%new_dsn;
373                                                   }
374                                                   
375                                                   sub _d {
376   ***      0                    0                    my ($package, undef, $line) = caller 0;
377   ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
378   ***      0                                              map { defined $_ ? $_ : 'undef' }
379                                                           @_;
380   ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
381                                                   }
382                                                   
383                                                   1;
384                                                   
385                                                   # ###########################################################################
386                                                   # End DSNParser package
387                                                   # ###########################################################################
388                                                   
389                                                   # ###########################################################################
390                                                   # OptionParser package 5266
391                                                   # ###########################################################################
392                                                   package OptionParser;
393                                                   
394            1                    1             8   use strict;
               1                                  2   
               1                                  7   
395            1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  5   
396                                                   
397            1                    1            10   use Getopt::Long;
               1                                  3   
               1                                  7   
398            1                    1             7   use List::Util qw(max);
               1                                  2   
               1                                 14   
399            1                    1             6   use English qw(-no_match_vars);
               1                                  4   
               1                                 14   
400                                                   
401   ***      1            50      1             7   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 14   
402                                                   
403                                                   my $POD_link_re = '[LC]<"?([^">]+)"?>';
404                                                   
405                                                   my %attributes = (
406                                                      'type'       => 1,
407                                                      'short form' => 1,
408                                                      'group'      => 1,
409                                                      'default'    => 1,
410                                                      'cumulative' => 1,
411                                                      'negatable'  => 1,
412                                                   );
413                                                   
414                                                   sub new {
415   ***      0                    0                    my ( $class, %args ) = @_;
416   ***      0                                         foreach my $arg ( qw(description) ) {
417   ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
418                                                      }
419   ***      0                                         my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
420   ***      0             0                           $program_name ||= $PROGRAM_NAME;
421   ***      0             0                           my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                    0                        
      ***                    0                        
422                                                   
423   ***      0      0      0                           my $self = {
      ***                    0                        
424                                                         description    => $args{description},
425                                                         prompt         => $args{prompt} || '<options>',
426                                                         strict         => (exists $args{strict} ? $args{strict} : 1),
427                                                         dp             => $args{dp}     || undef,
428                                                         program_name   => $program_name,
429                                                         opts           => {},
430                                                         got_opts       => 0,
431                                                         short_opts     => {},
432                                                         defaults       => {},
433                                                         groups         => {},
434                                                         allowed_groups => {},
435                                                         errors         => [],
436                                                         rules          => [],  # desc of rules for --help
437                                                         mutex          => [],  # rule: opts are mutually exclusive
438                                                         atleast1       => [],  # rule: at least one opt is required
439                                                         disables       => {},  # rule: opt disables other opts 
440                                                         defaults_to    => {},  # rule: opt defaults to value of other opt
441                                                         default_files  => [
442                                                            "/etc/maatkit/maatkit.conf",
443                                                            "/etc/maatkit/$program_name.conf",
444                                                            "$home/.maatkit.conf",
445                                                            "$home/.$program_name.conf",
446                                                         ],
447                                                      };
448   ***      0                                         return bless $self, $class;
449                                                   }
450                                                   
451                                                   sub get_specs {
452   ***      0                    0                    my ( $self, $file ) = @_;
453   ***      0                                         my @specs = $self->_pod_to_specs($file);
454   ***      0                                         $self->_parse_specs(@specs);
455   ***      0                                         return;
456                                                   }
457                                                   
458                                                   sub get_defaults_files {
459   ***      0                    0                    my ( $self ) = @_;
460   ***      0                                         return @{$self->{default_files}};
      ***      0                                      
461                                                   }
462                                                   
463                                                   sub _pod_to_specs {
464   ***      0                    0                    my ( $self, $file ) = @_;
465   ***      0             0                           $file ||= __FILE__;
466   ***      0      0                                  open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
467                                                   
468   ***      0                                         my %types = (
469                                                         string => 's', # standard Getopt type
470                                                         'int'  => 'i', # standard Getopt type
471                                                         float  => 'f', # standard Getopt type
472                                                         Hash   => 'H', # hash, formed from a comma-separated list
473                                                         hash   => 'h', # hash as above, but only if a value is given
474                                                         Array  => 'A', # array, similar to Hash
475                                                         array  => 'a', # array, similar to hash
476                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
477                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
478                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
479                                                      );
480   ***      0                                         my @specs = ();
481   ***      0                                         my @rules = ();
482   ***      0                                         my $para;
483                                                   
484   ***      0                                         local $INPUT_RECORD_SEPARATOR = '';
485   ***      0                                         while ( $para = <$fh> ) {
486   ***      0      0                                     next unless $para =~ m/^=head1 OPTIONS/;
487   ***      0                                            last;
488                                                      }
489                                                   
490   ***      0                                         while ( $para = <$fh> ) {
491   ***      0      0                                     last if $para =~ m/^=over/;
492   ***      0                                            chomp $para;
493   ***      0                                            $para =~ s/\s+/ /g;
494   ***      0                                            $para =~ s/$POD_link_re/$1/go;
495   ***      0                                            MKDEBUG && _d('Option rule:', $para);
496   ***      0                                            push @rules, $para;
497                                                      }
498                                                   
499   ***      0      0                                  die 'POD has no OPTIONS section' unless $para;
500                                                   
501   ***      0                                         do {
502   ***      0      0                                     if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
503   ***      0                                               chomp $para;
504   ***      0                                               MKDEBUG && _d($para);
505   ***      0                                               my %attribs;
506                                                   
507   ***      0                                               $para = <$fh>; # read next paragraph, possibly attributes
508                                                   
509   ***      0      0                                        if ( $para =~ m/: / ) { # attributes
510   ***      0                                                  $para =~ s/\s+\Z//g;
511   ***      0                                                  %attribs = map {
512   ***      0                                                        my ( $attrib, $val) = split(/: /, $_);
513   ***      0      0                                                 die "Unrecognized attribute for --$option: $attrib"
514                                                                        unless $attributes{$attrib};
515   ***      0                                                        ($attrib, $val);
516                                                                  } split(/; /, $para);
517   ***      0      0                                           if ( $attribs{'short form'} ) {
518   ***      0                                                     $attribs{'short form'} =~ s/-//;
519                                                               }
520   ***      0                                                  $para = <$fh>; # read next paragraph, probably short help desc
521                                                            }
522                                                            else {
523   ***      0                                                  MKDEBUG && _d('Option has no attributes');
524                                                            }
525                                                   
526   ***      0                                               $para =~ s/\s+\Z//g;
527   ***      0                                               $para =~ s/\s+/ /g;
528   ***      0                                               $para =~ s/$POD_link_re/$1/go;
529                                                   
530   ***      0                                               $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
531   ***      0                                               MKDEBUG && _d('Short help:', $para);
532                                                   
533   ***      0      0                                        die "No description after option spec $option" if $para =~ m/^=item/;
534                                                   
535   ***      0      0                                        if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
536   ***      0                                                  $option = $base_option;
537   ***      0                                                  $attribs{'negatable'} = 1;
538                                                            }
539                                                   
540   ***      0      0                                        push @specs, {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
541                                                               spec  => $option
542                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
543                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
544                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
545                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
546                                                               desc  => $para
547                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
548                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
549                                                            };
550                                                         }
551   ***      0                                            while ( $para = <$fh> ) {
552   ***      0      0                                        last unless $para;
553                                                   
554                                                   
555   ***      0      0                                        if ( $para =~ m/^=head1/ ) {
556   ***      0                                                  $para = undef; # Can't 'last' out of a do {} block.
557   ***      0                                                  last;
558                                                            }
559   ***      0      0                                        last if $para =~ m/^=item --/;
560                                                         }
561                                                      } while ( $para );
562                                                   
563   ***      0      0                                  die 'No valid specs in POD OPTIONS' unless @specs;
564                                                   
565   ***      0                                         close $fh;
566   ***      0                                         return @specs, @rules;
567                                                   }
568                                                   
569                                                   sub _parse_specs {
570   ***      0                    0                    my ( $self, @specs ) = @_;
571   ***      0                                         my %disables; # special rule that requires deferred checking
572                                                   
573   ***      0                                         foreach my $opt ( @specs ) {
574   ***      0      0                                     if ( ref $opt ) { # It's an option spec, not a rule.
575                                                            MKDEBUG && _d('Parsing opt spec:',
576   ***      0                                                  map { ($_, '=>', $opt->{$_}) } keys %$opt);
577                                                   
578   ***      0                                               my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
579   ***      0      0                                        if ( !$long ) {
580   ***      0                                                  die "Cannot parse long option from spec $opt->{spec}";
581                                                            }
582   ***      0                                               $opt->{long} = $long;
583                                                   
584   ***      0      0                                        die "Duplicate long option --$long" if exists $self->{opts}->{$long};
585   ***      0                                               $self->{opts}->{$long} = $opt;
586                                                   
587   ***      0      0                                        if ( length $long == 1 ) {
588   ***      0                                                  MKDEBUG && _d('Long opt', $long, 'looks like short opt');
589   ***      0                                                  $self->{short_opts}->{$long} = $long;
590                                                            }
591                                                   
592   ***      0      0                                        if ( $short ) {
593   ***      0      0                                           die "Duplicate short option -$short"
594                                                                  if exists $self->{short_opts}->{$short};
595   ***      0                                                  $self->{short_opts}->{$short} = $long;
596   ***      0                                                  $opt->{short} = $short;
597                                                            }
598                                                            else {
599   ***      0                                                  $opt->{short} = undef;
600                                                            }
601                                                   
602   ***      0      0                                        $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
603   ***      0      0                                        $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
604   ***      0      0                                        $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
605                                                   
606   ***      0             0                                 $opt->{group} ||= 'default';
607   ***      0                                               $self->{groups}->{ $opt->{group} }->{$long} = 1;
608                                                   
609   ***      0                                               $opt->{value} = undef;
610   ***      0                                               $opt->{got}   = 0;
611                                                   
612   ***      0                                               my ( $type ) = $opt->{spec} =~ m/=(.)/;
613   ***      0                                               $opt->{type} = $type;
614   ***      0                                               MKDEBUG && _d($long, 'type:', $type);
615                                                   
616   ***      0      0      0                                 if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                    0                        
617   ***      0                                                  die "$opt->{long} is type DSN (d) but no dp argument "
618                                                                  . "was given when this OptionParser object was created";
619                                                            }
620                                                   
621   ***      0      0      0                                 $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
622                                                   
623   ***      0      0                                        if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
624   ***      0      0                                           $self->{defaults}->{$long} = defined $def ? $def : 1;
625   ***      0                                                  MKDEBUG && _d($long, 'default:', $def);
626                                                            }
627                                                   
628   ***      0      0                                        if ( $long eq 'config' ) {
629   ***      0                                                  $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
630                                                            }
631                                                   
632   ***      0      0                                        if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
633   ***      0                                                  $disables{$long} = $dis;
634   ***      0                                                  MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
635                                                            }
636                                                   
637   ***      0                                               $self->{opts}->{$long} = $opt;
638                                                         }
639                                                         else { # It's an option rule, not a spec.
640   ***      0                                               MKDEBUG && _d('Parsing rule:', $opt); 
641   ***      0                                               push @{$self->{rules}}, $opt;
      ***      0                                      
642   ***      0                                               my @participants = $self->_get_participants($opt);
643   ***      0                                               my $rule_ok = 0;
644                                                   
645   ***      0      0                                        if ( $opt =~ m/mutually exclusive|one and only one/ ) {
646   ***      0                                                  $rule_ok = 1;
647   ***      0                                                  push @{$self->{mutex}}, \@participants;
      ***      0                                      
648   ***      0                                                  MKDEBUG && _d(@participants, 'are mutually exclusive');
649                                                            }
650   ***      0      0                                        if ( $opt =~ m/at least one|one and only one/ ) {
651   ***      0                                                  $rule_ok = 1;
652   ***      0                                                  push @{$self->{atleast1}}, \@participants;
      ***      0                                      
653   ***      0                                                  MKDEBUG && _d(@participants, 'require at least one');
654                                                            }
655   ***      0      0                                        if ( $opt =~ m/default to/ ) {
656   ***      0                                                  $rule_ok = 1;
657   ***      0                                                  $self->{defaults_to}->{$participants[0]} = $participants[1];
658   ***      0                                                  MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
659                                                            }
660   ***      0      0                                        if ( $opt =~ m/restricted to option groups/ ) {
661   ***      0                                                  $rule_ok = 1;
662   ***      0                                                  my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
663   ***      0                                                  my @groups = split(',', $groups);
664   ***      0                                                  %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                      
665   ***      0                                                     s/\s+//;
666   ***      0                                                     $_ => 1;
667                                                               } @groups;
668                                                            }
669                                                   
670   ***      0      0                                        die "Unrecognized option rule: $opt" unless $rule_ok;
671                                                         }
672                                                      }
673                                                   
674   ***      0                                         foreach my $long ( keys %disables ) {
675   ***      0                                            my @participants = $self->_get_participants($disables{$long});
676   ***      0                                            $self->{disables}->{$long} = \@participants;
677   ***      0                                            MKDEBUG && _d('Option', $long, 'disables', @participants);
678                                                      }
679                                                   
680   ***      0                                         return; 
681                                                   }
682                                                   
683                                                   sub _get_participants {
684   ***      0                    0                    my ( $self, $str ) = @_;
685   ***      0                                         my @participants;
686   ***      0                                         foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
687   ***      0      0                                     die "Option --$long does not exist while processing rule $str"
688                                                            unless exists $self->{opts}->{$long};
689   ***      0                                            push @participants, $long;
690                                                      }
691   ***      0                                         MKDEBUG && _d('Participants for', $str, ':', @participants);
692   ***      0                                         return @participants;
693                                                   }
694                                                   
695                                                   sub opts {
696   ***      0                    0                    my ( $self ) = @_;
697   ***      0                                         my %opts = %{$self->{opts}};
      ***      0                                      
698   ***      0                                         return %opts;
699                                                   }
700                                                   
701                                                   sub short_opts {
702   ***      0                    0                    my ( $self ) = @_;
703   ***      0                                         my %short_opts = %{$self->{short_opts}};
      ***      0                                      
704   ***      0                                         return %short_opts;
705                                                   }
706                                                   
707                                                   sub set_defaults {
708   ***      0                    0                    my ( $self, %defaults ) = @_;
709   ***      0                                         $self->{defaults} = {};
710   ***      0                                         foreach my $long ( keys %defaults ) {
711   ***      0      0                                     die "Cannot set default for nonexistent option $long"
712                                                            unless exists $self->{opts}->{$long};
713   ***      0                                            $self->{defaults}->{$long} = $defaults{$long};
714   ***      0                                            MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
715                                                      }
716   ***      0                                         return;
717                                                   }
718                                                   
719                                                   sub get_defaults {
720   ***      0                    0                    my ( $self ) = @_;
721   ***      0                                         return $self->{defaults};
722                                                   }
723                                                   
724                                                   sub get_groups {
725   ***      0                    0                    my ( $self ) = @_;
726   ***      0                                         return $self->{groups};
727                                                   }
728                                                   
729                                                   sub _set_option {
730   ***      0                    0                    my ( $self, $opt, $val ) = @_;
731   ***      0      0                                  my $long = exists $self->{opts}->{$opt}       ? $opt
      ***             0                               
732                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
733                                                               : die "Getopt::Long gave a nonexistent option: $opt";
734                                                   
735   ***      0                                         $opt = $self->{opts}->{$long};
736   ***      0      0                                  if ( $opt->{is_cumulative} ) {
737   ***      0                                            $opt->{value}++;
738                                                      }
739                                                      else {
740   ***      0                                            $opt->{value} = $val;
741                                                      }
742   ***      0                                         $opt->{got} = 1;
743   ***      0                                         MKDEBUG && _d('Got option', $long, '=', $val);
744                                                   }
745                                                   
746                                                   sub get_opts {
747   ***      0                    0                    my ( $self ) = @_; 
748                                                   
749   ***      0                                         foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                      
750   ***      0                                            $self->{opts}->{$long}->{got} = 0;
751   ***      0      0                                     $self->{opts}->{$long}->{value}
      ***             0                               
752                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
753                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
754                                                            : undef;
755                                                      }
756   ***      0                                         $self->{got_opts} = 0;
757                                                   
758   ***      0                                         $self->{errors} = [];
759                                                   
760   ***      0      0      0                           if ( @ARGV && $ARGV[0] eq "--config" ) {
761   ***      0                                            shift @ARGV;
762   ***      0                                            $self->_set_option('config', shift @ARGV);
763                                                      }
764   ***      0      0                                  if ( $self->has('config') ) {
765   ***      0                                            my @extra_args;
766   ***      0                                            foreach my $filename ( split(',', $self->get('config')) ) {
767   ***      0                                               eval {
768   ***      0                                                  push @extra_args, $self->_read_config_file($filename);
769                                                            };
770   ***      0      0                                        if ( $EVAL_ERROR ) {
771   ***      0      0                                           if ( $self->got('config') ) {
772   ***      0                                                     die $EVAL_ERROR;
773                                                               }
774                                                               elsif ( MKDEBUG ) {
775                                                                  _d($EVAL_ERROR);
776                                                               }
777                                                            }
778                                                         }
779   ***      0                                            unshift @ARGV, @extra_args;
780                                                      }
781                                                   
782   ***      0                                         Getopt::Long::Configure('no_ignore_case', 'bundling');
783                                                      GetOptions(
784   ***      0                    0                       map    { $_->{spec} => sub { $self->_set_option(@_); } }
      ***      0                                      
      ***      0                                      
785   ***      0                                            grep   { $_->{long} ne 'config' } # --config is handled specially above.
786   ***      0      0                                     values %{$self->{opts}}
787                                                      ) or $self->save_error('Error parsing options');
788                                                   
789   ***      0      0      0                           if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
790   ***      0      0                                     printf("%s  Ver %s Distrib %s Changeset %s\n",
791                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
792                                                               or die "Cannot print: $OS_ERROR";
793   ***      0                                            exit 0;
794                                                      }
795                                                   
796   ***      0      0      0                           if ( @ARGV && $self->{strict} ) {
797   ***      0                                            $self->save_error("Unrecognized command-line options @ARGV");
798                                                      }
799                                                   
800   ***      0                                         foreach my $mutex ( @{$self->{mutex}} ) {
      ***      0                                      
801   ***      0                                            my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                      
802   ***      0      0                                     if ( @set > 1 ) {
803   ***      0                                               my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                      
804   ***      0                                                            @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
805                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
806                                                                    . ' are mutually exclusive.';
807   ***      0                                               $self->save_error($err);
808                                                         }
809                                                      }
810                                                   
811   ***      0                                         foreach my $required ( @{$self->{atleast1}} ) {
      ***      0                                      
812   ***      0                                            my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                      
813   ***      0      0                                     if ( @set == 0 ) {
814   ***      0                                               my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                      
815   ***      0                                                            @{$required}[ 0 .. scalar(@$required) - 2] )
816                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
817   ***      0                                               $self->save_error("Specify at least one of $err");
818                                                         }
819                                                      }
820                                                   
821   ***      0                                         foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                      
822   ***      0                                            my $opt = $self->{opts}->{$long};
823   ***      0      0                                     if ( $opt->{got} ) {
      ***             0                               
824   ***      0      0                                        if ( exists $self->{disables}->{$long} ) {
825   ***      0                                                  my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                      
826   ***      0                                                  map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                      
827   ***      0                                                  MKDEBUG && _d('Unset options', @disable_opts,
828                                                                  'because', $long,'disables them');
829                                                            }
830                                                   
831   ***      0      0                                        if ( exists $self->{allowed_groups}->{$long} ) {
832                                                   
833   ***      0                                                  my @restricted_groups = grep {
834   ***      0                                                     !exists $self->{allowed_groups}->{$long}->{$_}
835   ***      0                                                  } keys %{$self->{groups}};
836                                                   
837   ***      0                                                  my @restricted_opts;
838   ***      0                                                  foreach my $restricted_group ( @restricted_groups ) {
839   ***      0                                                     RESTRICTED_OPT:
840   ***      0                                                     foreach my $restricted_opt (
841                                                                     keys %{$self->{groups}->{$restricted_group}} )
842                                                                  {
843   ***      0      0                                                 next RESTRICTED_OPT if $restricted_opt eq $long;
844   ***      0      0                                                 push @restricted_opts, $restricted_opt
845                                                                        if $self->{opts}->{$restricted_opt}->{got};
846                                                                  }
847                                                               }
848                                                   
849   ***      0      0                                           if ( @restricted_opts ) {
850   ***      0                                                     my $err;
851   ***      0      0                                              if ( @restricted_opts == 1 ) {
852   ***      0                                                        $err = "--$restricted_opts[0]";
853                                                                  }
854                                                                  else {
855   ***      0                                                        $err = join(', ',
856   ***      0                                                                  map { "--$self->{opts}->{$_}->{long}" }
857   ***      0                                                                  grep { $_ } 
858                                                                               @restricted_opts[0..scalar(@restricted_opts) - 2]
859                                                                            )
860                                                                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
861                                                                  }
862   ***      0                                                     $self->save_error("--$long is not allowed with $err");
863                                                               }
864                                                            }
865                                                   
866                                                         }
867                                                         elsif ( $opt->{is_required} ) { 
868   ***      0                                               $self->save_error("Required option --$long must be specified");
869                                                         }
870                                                   
871   ***      0                                            $self->_validate_type($opt);
872                                                      }
873                                                   
874   ***      0                                         $self->{got_opts} = 1;
875   ***      0                                         return;
876                                                   }
877                                                   
878                                                   sub _validate_type {
879   ***      0                    0                    my ( $self, $opt ) = @_;
880   ***      0      0      0                           return unless $opt && $opt->{type};
881   ***      0                                         my $val = $opt->{value};
882                                                   
883   ***      0      0      0                           if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
      ***                    0                        
884   ***      0                                            MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
885   ***      0                                            my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
886   ***      0      0                                     if ( !$suffix ) {
887   ***      0                                               my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
888   ***      0             0                                 $suffix = $s || 's';
889   ***      0                                               MKDEBUG && _d('No suffix given; using', $suffix, 'for',
890                                                               $opt->{long}, '(value:', $val, ')');
891                                                         }
892   ***      0      0                                     if ( $suffix =~ m/[smhd]/ ) {
893   ***      0      0                                        $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
894                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
895                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
896                                                                 :                  $num * 86400;   # Days
897   ***      0             0                                 $opt->{value} = ($prefix || '') . $val;
898   ***      0                                               MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
899                                                         }
900                                                         else {
901   ***      0                                               $self->save_error("Invalid time suffix for --$opt->{long}");
902                                                         }
903                                                      }
904                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
905   ***      0                                            MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
906   ***      0                                            my $prev = {};
907   ***      0                                            my $from_key = $self->{defaults_to}->{ $opt->{long} };
908   ***      0      0                                     if ( $from_key ) {
909   ***      0                                               MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
910   ***      0                                               $prev = $self->{opts}->{$from_key}->{value};
911                                                         }
912   ***      0                                            my $defaults = $self->{dp}->parse_options($self);
913   ***      0                                            $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
914                                                      }
915                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
916   ***      0                                            MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
917   ***      0                                            my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
918   ***      0                                            my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
919   ***      0      0                                     if ( defined $num ) {
920   ***      0      0                                        if ( $factor ) {
921   ***      0                                                  $num *= $factor_for{$factor};
922   ***      0                                                  MKDEBUG && _d('Setting option', $opt->{y},
923                                                                  'to num', $num, '* factor', $factor);
924                                                            }
925   ***      0             0                                 $opt->{value} = ($pre || '') . $num;
926                                                         }
927                                                         else {
928   ***      0                                               $self->save_error("Invalid size for --$opt->{long}");
929                                                         }
930                                                      }
931                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
932   ***      0             0                              $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                      
933                                                      }
934                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
935   ***      0             0                              $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
936                                                      }
937                                                      else {
938   ***      0                                            MKDEBUG && _d('Nothing to validate for option',
939                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
940                                                      }
941                                                   
942   ***      0                                         return;
943                                                   }
944                                                   
945                                                   sub get {
946   ***      0                    0                    my ( $self, $opt ) = @_;
947   ***      0      0                                  my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
948   ***      0      0      0                           die "Option $opt does not exist"
949                                                         unless $long && exists $self->{opts}->{$long};
950   ***      0                                         return $self->{opts}->{$long}->{value};
951                                                   }
952                                                   
953                                                   sub got {
954   ***      0                    0                    my ( $self, $opt ) = @_;
955   ***      0      0                                  my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
956   ***      0      0      0                           die "Option $opt does not exist"
957                                                         unless $long && exists $self->{opts}->{$long};
958   ***      0                                         return $self->{opts}->{$long}->{got};
959                                                   }
960                                                   
961                                                   sub has {
962   ***      0                    0                    my ( $self, $opt ) = @_;
963   ***      0      0                                  my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
964   ***      0      0                                  return defined $long ? exists $self->{opts}->{$long} : 0;
965                                                   }
966                                                   
967                                                   sub set {
968   ***      0                    0                    my ( $self, $opt, $val ) = @_;
969   ***      0      0                                  my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
970   ***      0      0      0                           die "Option $opt does not exist"
971                                                         unless $long && exists $self->{opts}->{$long};
972   ***      0                                         $self->{opts}->{$long}->{value} = $val;
973   ***      0                                         return;
974                                                   }
975                                                   
976                                                   sub save_error {
977   ***      0                    0                    my ( $self, $error ) = @_;
978   ***      0                                         push @{$self->{errors}}, $error;
      ***      0                                      
979                                                   }
980                                                   
981                                                   sub errors {
982   ***      0                    0                    my ( $self ) = @_;
983   ***      0                                         return $self->{errors};
984                                                   }
985                                                   
986                                                   sub prompt {
987   ***      0                    0                    my ( $self ) = @_;
988   ***      0                                         return "Usage: $PROGRAM_NAME $self->{prompt}\n";
989                                                   }
990                                                   
991                                                   sub descr {
992   ***      0                    0                    my ( $self ) = @_;
993   ***      0             0                           my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
994                                                                 . "  For more details, please use the --help option, "
995                                                                 . "or try 'perldoc $PROGRAM_NAME' "
996                                                                 . "for complete documentation.";
997   ***      0                                         $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
998   ***      0                                         $descr =~ s/ +$//mg;
999   ***      0                                         return $descr;
1000                                                  }
1001                                                  
1002                                                  sub usage_or_errors {
1003  ***      0                    0                    my ( $self ) = @_;
1004  ***      0      0                                  if ( $self->{opts}->{help}->{got} ) {
      ***      0      0                               
1005  ***      0      0                                     print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
1006  ***      0                                            exit 0;
1007                                                     }
1008                                                     elsif ( scalar @{$self->{errors}} ) {
1009  ***      0      0                                     print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
1010  ***      0                                            exit 0;
1011                                                     }
1012  ***      0                                         return;
1013                                                  }
1014                                                  
1015                                                  sub print_errors {
1016  ***      0                    0                    my ( $self ) = @_;
1017  ***      0                                         my $usage = $self->prompt() . "\n";
1018  ***      0      0                                  if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                      
1019  ***      0                                            $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
1020                                                                . "\n";
1021                                                     }
1022  ***      0                                         return $usage . "\n" . $self->descr();
1023                                                  }
1024                                                  
1025                                                  sub print_usage {
1026  ***      0                    0                    my ( $self ) = @_;
1027  ***      0      0                                  die "Run get_opts() before print_usage()" unless $self->{got_opts};
1028  ***      0                                         my @opts = values %{$self->{opts}};
      ***      0                                      
1029                                                  
1030  ***      0      0                                  my $maxl = max(
1031  ***      0                                            map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
1032                                                        @opts);
1033                                                  
1034  ***      0      0                                  my $maxs = max(0,
1035  ***      0                                            map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
1036  ***      0                                            values %{$self->{short_opts}});
1037                                                  
1038  ***      0                                         my $lcol = max($maxl, ($maxs + 3));
1039  ***      0                                         my $rcol = 80 - $lcol - 6;
1040  ***      0                                         my $rpad = ' ' x ( 80 - $rcol );
1041                                                  
1042  ***      0                                         $maxs = max($lcol - 3, $maxs);
1043                                                  
1044  ***      0                                         my $usage = $self->descr() . "\n" . $self->prompt();
1045                                                  
1046  ***      0                                         my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                      
      ***      0                                      
1047  ***      0                                         push @groups, 'default';
1048                                                  
1049  ***      0                                         foreach my $group ( reverse @groups ) {
1050  ***      0      0                                     $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
1051  ***      0                                            foreach my $opt (
      ***      0                                      
1052  ***      0                                               sort { $a->{long} cmp $b->{long} }
1053                                                           grep { $_->{group} eq $group }
1054                                                           @opts )
1055                                                        {
1056  ***      0      0                                        my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
1057  ***      0                                               my $short = $opt->{short};
1058  ***      0                                               my $desc  = $opt->{desc};
1059  ***      0      0      0                                 if ( $opt->{type} && $opt->{type} eq 'm' ) {
1060  ***      0                                                  my ($s) = $desc =~ m/\(suffix (.)\)/;
1061  ***      0             0                                    $s    ||= 's';
1062  ***      0                                                  $desc =~ s/\s+\(suffix .\)//;
1063  ***      0                                                  $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
1064                                                                     . "d=days; if no suffix, $s is used.";
1065                                                           }
1066  ***      0                                               $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                      
1067  ***      0                                               $desc =~ s/ +$//mg;
1068  ***      0      0                                        if ( $short ) {
1069  ***      0                                                  $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
1070                                                           }
1071                                                           else {
1072  ***      0                                                  $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
1073                                                           }
1074                                                        }
1075                                                     }
1076                                                  
1077  ***      0      0                                  if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                      
1078  ***      0                                            $usage .= "\nRules:\n\n";
1079  ***      0                                            $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                      
1080                                                     }
1081  ***      0      0                                  if ( $self->{dp} ) {
1082  ***      0                                            $usage .= "\n" . $self->{dp}->usage();
1083                                                     }
1084  ***      0                                         $usage .= "\nOptions and values after processing arguments:\n\n";
1085  ***      0                                         foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                      
1086  ***      0                                            my $val   = $opt->{value};
1087  ***      0             0                              my $type  = $opt->{type} || '';
1088  ***      0                                            my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
1089  ***      0      0                                     $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
1090                                                                  : !defined $val             ? '(No value)'
1091                                                                  : $type eq 'd'              ? $self->{dp}->as_string($val)
1092                                                                  : $type =~ m/H|h/           ? join(',', sort keys %$val)
1093                                                                  : $type =~ m/A|a/           ? join(',', @$val)
1094                                                                  :                             $val;
1095  ***      0                                            $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
1096                                                     }
1097  ***      0                                         return $usage;
1098                                                  }
1099                                                  
1100                                                  sub prompt_noecho {
1101  ***      0      0             0                    shift @_ if ref $_[0] eq __PACKAGE__;
1102  ***      0                                         my ( $prompt ) = @_;
1103  ***      0                                         local $OUTPUT_AUTOFLUSH = 1;
1104  ***      0      0                                  print $prompt
1105                                                        or die "Cannot print: $OS_ERROR";
1106  ***      0                                         my $response;
1107  ***      0                                         eval {
1108  ***      0                                            require Term::ReadKey;
1109  ***      0                                            Term::ReadKey::ReadMode('noecho');
1110  ***      0                                            chomp($response = <STDIN>);
1111  ***      0                                            Term::ReadKey::ReadMode('normal');
1112  ***      0      0                                     print "\n"
1113                                                           or die "Cannot print: $OS_ERROR";
1114                                                     };
1115  ***      0      0                                  if ( $EVAL_ERROR ) {
1116  ***      0                                            die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
1117                                                     }
1118  ***      0                                         return $response;
1119                                                  }
1120                                                  
1121                                                  if ( MKDEBUG ) {
1122                                                     print '# ', $^X, ' ', $], "\n";
1123                                                     my $uname = `uname -a`;
1124                                                     if ( $uname ) {
1125                                                        $uname =~ s/\s+/ /g;
1126                                                        print "# $uname\n";
1127                                                     }
1128                                                     printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
1129                                                        $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
1130                                                        ($main::SVN_REV || ''), __LINE__);
1131                                                     print('# Arguments: ',
1132                                                        join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
1133                                                  }
1134                                                  
1135                                                  sub _read_config_file {
1136  ***      0                    0                    my ( $self, $filename ) = @_;
1137  ***      0      0                                  open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
1138  ***      0                                         my @args;
1139  ***      0                                         my $prefix = '--';
1140  ***      0                                         my $parse  = 1;
1141                                                  
1142                                                     LINE:
1143  ***      0                                         while ( my $line = <$fh> ) {
1144  ***      0                                            chomp $line;
1145  ***      0      0                                     next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
1146  ***      0                                            $line =~ s/\s+#.*$//g;
1147  ***      0                                            $line =~ s/^\s+|\s+$//g;
1148  ***      0      0                                     if ( $line eq '--' ) {
1149  ***      0                                               $prefix = '';
1150  ***      0                                               $parse  = 0;
1151  ***      0                                               next LINE;
1152                                                        }
1153  ***      0      0      0                              if ( $parse
      ***             0                               
1154                                                           && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
1155                                                        ) {
1156  ***      0                                               push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                      
1157                                                        }
1158                                                        elsif ( $line =~ m/./ ) {
1159  ***      0                                               push @args, $line;
1160                                                        }
1161                                                        else {
1162  ***      0                                               die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
1163                                                        }
1164                                                     }
1165  ***      0                                         close $fh;
1166  ***      0                                         return @args;
1167                                                  }
1168                                                  
1169                                                  sub read_para_after {
1170  ***      0                    0                    my ( $self, $file, $regex ) = @_;
1171  ***      0      0                                  open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
1172  ***      0                                         local $INPUT_RECORD_SEPARATOR = '';
1173  ***      0                                         my $para;
1174  ***      0                                         while ( $para = <$fh> ) {
1175  ***      0      0                                     next unless $para =~ m/^=pod$/m;
1176  ***      0                                            last;
1177                                                     }
1178  ***      0                                         while ( $para = <$fh> ) {
1179  ***      0      0                                     next unless $para =~ m/$regex/;
1180  ***      0                                            last;
1181                                                     }
1182  ***      0                                         $para = <$fh>;
1183  ***      0                                         chomp($para);
1184  ***      0      0                                  close $fh or die "Can't close $file: $OS_ERROR";
1185  ***      0                                         return $para;
1186                                                  }
1187                                                  
1188                                                  sub clone {
1189  ***      0                    0                    my ( $self ) = @_;
1190                                                  
1191  ***      0                                         my %clone = map {
1192  ***      0                                            my $hashref  = $self->{$_};
1193  ***      0                                            my $val_copy = {};
1194  ***      0                                            foreach my $key ( keys %$hashref ) {
1195  ***      0                                               my $ref = ref $hashref->{$key};
1196  ***      0                                               $val_copy->{$key} = !$ref           ? $hashref->{$key}
1197  ***      0                                                                 : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
1198  ***      0      0                                                          : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
1199                                                                             : $hashref->{$key};
1200                                                        }
1201  ***      0                                            $_ => $val_copy;
1202                                                     } qw(opts short_opts defaults);
1203                                                  
1204  ***      0                                         foreach my $scalar ( qw(got_opts) ) {
1205  ***      0                                            $clone{$scalar} = $self->{$scalar};
1206                                                     }
1207                                                  
1208  ***      0                                         return bless \%clone;     
1209                                                  }
1210                                                  
1211                                                  sub _d {
1212  ***      0                    0                    my ($package, undef, $line) = caller 0;
1213  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1214  ***      0                                              map { defined $_ ? $_ : 'undef' }
1215                                                          @_;
1216  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1217                                                  }
1218                                                  
1219                                                  1;
1220                                                  
1221                                                  # ###########################################################################
1222                                                  # End OptionParser package
1223                                                  # ###########################################################################
1224                                                  
1225                                                  # ###########################################################################
1226                                                  # Quoter package 5266
1227                                                  # ###########################################################################
1228           1                    1             9   use strict;
               1                                  4   
               1                                  7   
1229           1                    1             7   use warnings FATAL => 'all';
               1                                  3   
               1                                  6   
1230                                                  
1231                                                  package Quoter;
1232                                                  
1233           1                    1             5   use English qw(-no_match_vars);
               1                                  3   
               1                                  5   
1234                                                  
1235  ***      1            50      1             7   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 15   
1236                                                  
1237                                                  sub new {
1238  ***      0                    0                    my ( $class ) = @_;
1239  ***      0                                         bless {}, $class;
1240                                                  }
1241                                                  
1242                                                  sub quote {
1243  ***      0                    0                    my ( $self, @vals ) = @_;
1244  ***      0                                         foreach my $val ( @vals ) {
1245  ***      0                                            $val =~ s/`/``/g;
1246                                                     }
1247  ***      0                                         return join('.', map { '`' . $_ . '`' } @vals);
      ***      0                                      
1248                                                  }
1249                                                  
1250                                                  sub quote_val {
1251  ***      0                    0                    my ( $self, $val, $is_numeric ) = @_;
1252                                                  
1253  ***      0      0                                  return 'NULL' unless defined $val;  # undef = NULL
1254  ***      0      0                                  return "''" if $val eq '';          # blank string = ''
1255                                                  
1256  ***      0      0                                  if ( !defined $is_numeric ) {
1257  ***      0      0                                     $is_numeric = $val =~ m/^0|\D/ ? 0 : 1;
1258                                                     }
1259                                                  
1260  ***      0      0                                  return $val if $is_numeric;
1261                                                  
1262  ***      0                                         $val =~ s/(['\\])/\\$1/g;
1263  ***      0                                         return "'$val'";
1264                                                  }
1265                                                  
1266                                                  sub split_unquote {
1267  ***      0                    0                    my ( $self, $db_tbl, $default_db ) = @_;
1268  ***      0                                         $db_tbl =~ s/`//g;
1269  ***      0                                         my ( $db, $tbl ) = split(/[.]/, $db_tbl);
1270  ***      0      0                                  if ( !$tbl ) {
1271  ***      0                                            $tbl = $db;
1272  ***      0                                            $db  = $default_db;
1273                                                     }
1274  ***      0                                         return ($db, $tbl);
1275                                                  }
1276                                                  
1277                                                  sub literal_like {
1278  ***      0                    0                    my ( $self, $like ) = @_;
1279  ***      0      0                                  return unless $like;
1280  ***      0                                         $like =~ s/([%_])/\\$1/g;
1281  ***      0                                         return "'$like'";
1282                                                  }
1283                                                  
1284                                                  1;
1285                                                  
1286                                                  # ###########################################################################
1287                                                  # End Quoter package
1288                                                  # ###########################################################################
1289                                                  
1290                                                  # ###########################################################################
1291                                                  # VersionParser package 5266
1292                                                  # ###########################################################################
1293                                                  package VersionParser;
1294                                                  
1295           1                    1             8   use strict;
               1                                  3   
               1                                  7   
1296           1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  6   
1297                                                  
1298           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  5   
1299                                                  
1300  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 14   
1301                                                  
1302                                                  sub new {
1303  ***      0                    0                    my ( $class ) = @_;
1304  ***      0                                         bless {}, $class;
1305                                                  }
1306                                                  
1307                                                  sub parse {
1308  ***      0                    0                    my ( $self, $str ) = @_;
1309  ***      0                                         my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
1310  ***      0                                         MKDEBUG && _d($str, 'parses to', $result);
1311  ***      0                                         return $result;
1312                                                  }
1313                                                  
1314                                                  sub version_ge {
1315  ***      0                    0                    my ( $self, $dbh, $target ) = @_;
1316  ***      0      0                                  if ( !$self->{$dbh} ) {
1317  ***      0                                            $self->{$dbh} = $self->parse(
1318                                                           $dbh->selectrow_array('SELECT VERSION()'));
1319                                                     }
1320  ***      0      0                                  my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
1321  ***      0                                         MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
1322  ***      0                                         return $result;
1323                                                  }
1324                                                  
1325                                                  sub _d {
1326  ***      0                    0                    my ($package, undef, $line) = caller 0;
1327  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1328  ***      0                                              map { defined $_ ? $_ : 'undef' }
1329                                                          @_;
1330  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1331                                                  }
1332                                                  
1333                                                  1;
1334                                                  
1335                                                  # ###########################################################################
1336                                                  # End VersionParser package
1337                                                  # ###########################################################################
1338                                                  
1339                                                  # ###########################################################################
1340                                                  # TableParser package 5266
1341                                                  # ###########################################################################
1342                                                  package TableParser;
1343                                                  
1344           1                    1             7   use strict;
               1                                  3   
               1                                  9   
1345           1                    1             5   use warnings FATAL => 'all';
               1                                  2   
               1                                  6   
1346           1                    1             7   use English qw(-no_match_vars);
               1                                  2   
               1                                  5   
1347           1                    1             6   use Data::Dumper;
               1                                  2   
               1                                  6   
1348                                                  $Data::Dumper::Indent    = 1;
1349                                                  $Data::Dumper::Sortkeys  = 1;
1350                                                  $Data::Dumper::Quotekeys = 0;
1351                                                  
1352  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 13   
1353                                                  
1354                                                  
1355                                                  sub new {
1356  ***      0                    0                    my ( $class, %args ) = @_;
1357  ***      0                                         my @required_args = qw(Quoter);
1358  ***      0                                         foreach my $arg ( @required_args ) {
1359  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
1360                                                     }
1361  ***      0                                         my $self = { %args };
1362  ***      0                                         return bless $self, $class;
1363                                                  }
1364                                                  
1365                                                  
1366                                                  sub parse {
1367  ***      0                    0                    my ( $self, $ddl, $opts ) = @_;
1368  ***      0      0                                  return unless $ddl;
1369  ***      0      0                                  if ( ref $ddl eq 'ARRAY' ) {
1370  ***      0      0                                     if ( lc $ddl->[0] eq 'table' ) {
1371  ***      0                                               $ddl = $ddl->[1];
1372                                                        }
1373                                                        else {
1374                                                           return {
1375  ***      0                                                  engine => 'VIEW',
1376                                                           };
1377                                                        }
1378                                                     }
1379                                                  
1380  ***      0      0                                  if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
1381  ***      0                                            die "Cannot parse table definition; is ANSI quoting "
1382                                                           . "enabled or SQL_QUOTE_SHOW_CREATE disabled?";
1383                                                     }
1384                                                  
1385  ***      0                                         my ($name)     = $ddl =~ m/CREATE (?:TEMPORARY )?TABLE\s+(`.+?`)/;
1386  ***      0      0                                  (undef, $name) = $self->{Quoter}->split_unquote($name) if $name;
1387                                                  
1388  ***      0                                         $ddl =~ s/(`[^`]+`)/\L$1/g;
1389                                                  
1390  ***      0                                         my $engine = $self->get_engine($ddl);
1391                                                  
1392  ***      0                                         my @defs   = $ddl =~ m/^(\s+`.*?),?$/gm;
1393  ***      0                                         my @cols   = map { $_ =~ m/`([^`]+)`/ } @defs;
      ***      0                                      
1394  ***      0                                         MKDEBUG && _d('Columns:', join(', ', @cols));
1395                                                  
1396  ***      0                                         my %def_for;
1397  ***      0                                         @def_for{@cols} = @defs;
1398                                                  
1399  ***      0                                         my (@nums, @null);
1400  ***      0                                         my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
1401  ***      0                                         foreach my $col ( @cols ) {
1402  ***      0                                            my $def = $def_for{$col};
1403  ***      0                                            my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
1404  ***      0      0                                     die "Can't determine column type for $def" unless $type;
1405  ***      0                                            $type_for{$col} = $type;
1406  ***      0      0                                     if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
1407  ***      0                                               push @nums, $col;
1408  ***      0                                               $is_numeric{$col} = 1;
1409                                                        }
1410  ***      0      0                                     if ( $def !~ m/NOT NULL/ ) {
1411  ***      0                                               push @null, $col;
1412  ***      0                                               $is_nullable{$col} = 1;
1413                                                        }
1414  ***      0      0                                     $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
1415                                                     }
1416                                                  
1417  ***      0                                         my ($keys, $clustered_key) = $self->get_keys($ddl, $opts, \%is_nullable);
1418                                                  
1419                                                     return {
1420  ***      0                                            name           => $name,
1421                                                        cols           => \@cols,
1422  ***      0                                            col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
1423  ***      0                                            is_col         => { map { $_ => 1 } @cols },
1424                                                        null_cols      => \@null,
1425                                                        is_nullable    => \%is_nullable,
1426                                                        is_autoinc     => \%is_autoinc,
1427                                                        clustered_key  => $clustered_key,
1428                                                        keys           => $keys,
1429                                                        defs           => \%def_for,
1430                                                        numeric_cols   => \@nums,
1431                                                        is_numeric     => \%is_numeric,
1432                                                        engine         => $engine,
1433                                                        type_for       => \%type_for,
1434                                                     };
1435                                                  }
1436                                                  
1437                                                  sub sort_indexes {
1438  ***      0                    0                    my ( $self, $tbl ) = @_;
1439                                                  
1440                                                     my @indexes
1441  ***      0                                            = sort {
1442  ***      0                                               (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
1443                                                           || ( !$tbl->{keys}->{$a}->{is_unique} <=> !$tbl->{keys}->{$b}->{is_unique} )
1444                                                           || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
1445  ***      0      0      0                                 || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      ***      0             0                        
1446                                                        }
1447                                                        grep {
1448  ***      0                                               $tbl->{keys}->{$_}->{type} eq 'BTREE'
1449                                                        }
1450  ***      0                                            sort keys %{$tbl->{keys}};
1451                                                  
1452  ***      0                                         MKDEBUG && _d('Indexes sorted best-first:', join(', ', @indexes));
1453  ***      0                                         return @indexes;
1454                                                  }
1455                                                  
1456                                                  sub find_best_index {
1457  ***      0                    0                    my ( $self, $tbl, $index ) = @_;
1458  ***      0                                         my $best;
1459  ***      0      0                                  if ( $index ) {
1460  ***      0                                            ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
      ***      0                                      
      ***      0                                      
1461                                                     }
1462  ***      0      0                                  if ( !$best ) {
1463  ***      0      0                                     if ( $index ) {
1464  ***      0                                               die "Index '$index' does not exist in table";
1465                                                        }
1466                                                        else {
1467  ***      0                                               ($best) = $self->sort_indexes($tbl);
1468                                                        }
1469                                                     }
1470  ***      0                                         MKDEBUG && _d('Best index found is', $best);
1471  ***      0                                         return $best;
1472                                                  }
1473                                                  
1474                                                  sub find_possible_keys {
1475  ***      0                    0                    my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
1476  ***      0      0                                  return () unless $where;
1477  ***      0                                         my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
1478                                                        . ' WHERE ' . $where;
1479  ***      0                                         MKDEBUG && _d($sql);
1480  ***      0                                         my $expl = $dbh->selectrow_hashref($sql);
1481  ***      0                                         $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
      ***      0                                      
1482  ***      0      0                                  if ( $expl->{possible_keys} ) {
1483  ***      0                                            MKDEBUG && _d('possible_keys =', $expl->{possible_keys});
1484  ***      0                                            my @candidates = split(',', $expl->{possible_keys});
1485  ***      0                                            my %possible   = map { $_ => 1 } @candidates;
      ***      0                                      
1486  ***      0      0                                     if ( $expl->{key} ) {
1487  ***      0                                               MKDEBUG && _d('MySQL chose', $expl->{key});
1488  ***      0                                               unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
      ***      0                                      
1489  ***      0                                               MKDEBUG && _d('Before deduping:', join(', ', @candidates));
1490  ***      0                                               my %seen;
1491  ***      0                                               @candidates = grep { !$seen{$_}++ } @candidates;
      ***      0                                      
1492                                                        }
1493  ***      0                                            MKDEBUG && _d('Final list:', join(', ', @candidates));
1494  ***      0                                            return @candidates;
1495                                                     }
1496                                                     else {
1497  ***      0                                            MKDEBUG && _d('No keys in possible_keys');
1498  ***      0                                            return ();
1499                                                     }
1500                                                  }
1501                                                  
1502                                                  sub check_table {
1503  ***      0                    0                    my ( $self, %args ) = @_;
1504  ***      0                                         my @required_args = qw(dbh db tbl);
1505  ***      0                                         foreach my $arg ( @required_args ) {
1506  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
1507                                                     }
1508  ***      0                                         my ($dbh, $db, $tbl) = @args{@required_args};
1509  ***      0                                         my $q      = $self->{Quoter};
1510  ***      0                                         my $db_tbl = $q->quote($db, $tbl);
1511  ***      0                                         MKDEBUG && _d('Checking', $db_tbl);
1512                                                  
1513  ***      0                                         my $sql = "SHOW TABLES FROM " . $q->quote($db)
1514                                                             . ' LIKE ' . $q->literal_like($tbl);
1515  ***      0                                         MKDEBUG && _d($sql);
1516  ***      0                                         my $row;
1517  ***      0                                         eval {
1518  ***      0                                            $row = $dbh->selectrow_arrayref($sql);
1519                                                     };
1520  ***      0      0                                  if ( $EVAL_ERROR ) {
1521  ***      0                                            MKDEBUG && _d($EVAL_ERROR);
1522  ***      0                                            return 0;
1523                                                     }
1524  ***      0      0      0                           if ( !$row->[0] || $row->[0] ne $tbl ) {
1525  ***      0                                            MKDEBUG && _d('Table does not exist');
1526  ***      0                                            return 0;
1527                                                     }
1528                                                  
1529  ***      0                                         MKDEBUG && _d('Table exists; no privs to check');
1530  ***      0      0                                  return 1 unless $args{all_privs};
1531                                                  
1532  ***      0                                         $sql = "SHOW FULL COLUMNS FROM $db_tbl";
1533  ***      0                                         MKDEBUG && _d($sql);
1534  ***      0                                         eval {
1535  ***      0                                            $row = $dbh->selectrow_hashref($sql);
1536                                                     };
1537  ***      0      0                                  if ( $EVAL_ERROR ) {
1538  ***      0                                            MKDEBUG && _d($EVAL_ERROR);
1539  ***      0                                            return 0;
1540                                                     }
1541  ***      0      0                                  if ( !scalar keys %$row ) {
1542  ***      0                                            MKDEBUG && _d('Table has no columns:', Dumper($row));
1543  ***      0                                            return 0;
1544                                                     }
1545  ***      0             0                           my $privs = $row->{privileges} || $row->{Privileges};
1546                                                  
1547  ***      0                                         $sql = "DELETE FROM $db_tbl LIMIT 0";
1548  ***      0                                         MKDEBUG && _d($sql);
1549  ***      0                                         eval {
1550  ***      0                                            $dbh->do($sql);
1551                                                     };
1552  ***      0      0                                  my $can_delete = $EVAL_ERROR ? 0 : 1;
1553                                                  
1554  ***      0                                         MKDEBUG && _d('User privs on', $db_tbl, ':', $privs,
1555                                                        ($can_delete ? 'delete' : ''));
1556                                                  
1557  ***      0      0      0                           if ( !($privs =~ m/select/ && $privs =~ m/insert/ && $privs =~ m/update/
      ***                    0                        
      ***                    0                        
1558                                                            && $can_delete) ) {
1559  ***      0                                            MKDEBUG && _d('User does not have all privs');
1560  ***      0                                            return 0;
1561                                                     }
1562                                                  
1563  ***      0                                         MKDEBUG && _d('User has all privs');
1564  ***      0                                         return 1;
1565                                                  }
1566                                                  
1567                                                  sub get_engine {
1568  ***      0                    0                    my ( $self, $ddl, $opts ) = @_;
1569  ***      0                                         my ( $engine ) = $ddl =~ m/\).*?(?:ENGINE|TYPE)=(\w+)/;
1570  ***      0                                         MKDEBUG && _d('Storage engine:', $engine);
1571  ***      0             0                           return $engine || undef;
1572                                                  }
1573                                                  
1574                                                  sub get_keys {
1575  ***      0                    0                    my ( $self, $ddl, $opts, $is_nullable ) = @_;
1576  ***      0                                         my $engine        = $self->get_engine($ddl);
1577  ***      0                                         my $keys          = {};
1578  ***      0                                         my $clustered_key = undef;
1579                                                  
1580                                                     KEY:
1581  ***      0                                         foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {
1582                                                  
1583  ***      0      0                                     next KEY if $key =~ m/FOREIGN/;
1584                                                  
1585  ***      0                                            my $key_ddl = $key;
1586  ***      0                                            MKDEBUG && _d('Parsed key:', $key_ddl);
1587                                                  
1588  ***      0      0                                     if ( $engine !~ m/MEMORY|HEAP/ ) {
1589  ***      0                                               $key =~ s/USING HASH/USING BTREE/;
1590                                                        }
1591                                                  
1592  ***      0                                            my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
1593  ***      0                                            my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
1594  ***      0             0                              $type = $type || $special || 'BTREE';
      ***                    0                        
1595  ***      0      0      0                              if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
      ***                    0                        
1596                                                           && $engine =~ m/HEAP|MEMORY/i )
1597                                                        {
1598  ***      0                                               $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
1599                                                        }
1600                                                  
1601  ***      0                                            my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
1602  ***      0      0                                     my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
1603  ***      0                                            my @cols;
1604  ***      0                                            my @col_prefixes;
1605  ***      0                                            foreach my $col_def ( split(',', $cols) ) {
1606  ***      0                                               my ($name, $prefix) = $col_def =~ m/`([^`]+)`(?:\((\d+)\))?/;
1607  ***      0                                               push @cols, $name;
1608  ***      0                                               push @col_prefixes, $prefix;
1609                                                        }
1610  ***      0                                            $name =~ s/`//g;
1611                                                  
1612  ***      0                                            MKDEBUG && _d('Key', $name, 'cols:', join(', ', @cols));
1613                                                  
1614  ***      0                                            $keys->{$name} = {
1615                                                           name         => $name,
1616                                                           type         => $type,
1617                                                           colnames     => $cols,
1618                                                           cols         => \@cols,
1619                                                           col_prefixes => \@col_prefixes,
1620                                                           is_unique    => $unique,
1621  ***      0                                               is_nullable  => scalar(grep { $is_nullable->{$_} } @cols),
1622  ***      0                                               is_col       => { map { $_ => 1 } @cols },
1623                                                           ddl          => $key_ddl,
1624                                                        };
1625                                                  
1626  ***      0      0      0                              if ( $engine =~ m/InnoDB/i && !$clustered_key ) {
1627  ***      0                                               my $this_key = $keys->{$name};
1628  ***      0      0      0                                 if ( $this_key->{name} eq 'PRIMARY' ) {
      ***             0                               
1629  ***      0                                                  $clustered_key = 'PRIMARY';
1630                                                           }
1631                                                           elsif ( $this_key->{is_unique} && !$this_key->{is_nullable} ) {
1632  ***      0                                                  $clustered_key = $this_key->{name};
1633                                                           }
1634  ***      0                                               MKDEBUG && $clustered_key && _d('This key is the clustered key');
1635                                                        }
1636                                                     }
1637                                                  
1638  ***      0                                         return $keys, $clustered_key;
1639                                                  }
1640                                                  
1641                                                  sub get_fks {
1642  ***      0                    0                    my ( $self, $ddl, $opts ) = @_;
1643  ***      0                                         my $fks = {};
1644                                                  
1645  ***      0                                         foreach my $fk (
1646                                                        $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg )
1647                                                     {
1648  ***      0                                            my ( $name ) = $fk =~ m/CONSTRAINT `(.*?)`/;
1649  ***      0                                            my ( $cols ) = $fk =~ m/FOREIGN KEY \(([^\)]+)\)/;
1650  ***      0                                            my ( $parent, $parent_cols ) = $fk =~ m/REFERENCES (\S+) \(([^\)]+)\)/;
1651                                                  
1652  ***      0      0      0                              if ( $parent !~ m/\./ && $opts->{database} ) {
1653  ***      0                                               $parent = "`$opts->{database}`.$parent";
1654                                                        }
1655                                                  
1656  ***      0                                            $fks->{$name} = {
1657                                                           name           => $name,
1658                                                           colnames       => $cols,
1659  ***      0                                               cols           => [ map { s/[ `]+//g; $_; } split(',', $cols) ],
      ***      0                                      
1660                                                           parent_tbl     => $parent,
1661                                                           parent_colnames=> $parent_cols,
1662  ***      0                                               parent_cols    => [ map { s/[ `]+//g; $_; } split(',', $parent_cols) ],
      ***      0                                      
1663                                                           ddl            => $fk,
1664                                                        };
1665                                                     }
1666                                                  
1667  ***      0                                         return $fks;
1668                                                  }
1669                                                  
1670                                                  sub remove_auto_increment {
1671  ***      0                    0                    my ( $self, $ddl ) = @_;
1672  ***      0                                         $ddl =~ s/(^\).*?) AUTO_INCREMENT=\d+\b/$1/m;
1673  ***      0                                         return $ddl;
1674                                                  }
1675                                                  
1676                                                  sub remove_secondary_indexes {
1677  ***      0                    0                    my ( $self, $ddl ) = @_;
1678  ***      0                                         my $sec_indexes_ddl;
1679  ***      0                                         my $tbl_struct = $self->parse($ddl);
1680                                                  
1681  ***      0      0      0                           if ( ($tbl_struct->{engine} || '') =~ m/InnoDB/i ) {
1682  ***      0                                            my $clustered_key = $tbl_struct->{clustered_key};
1683  ***      0             0                              $clustered_key  ||= '';
1684                                                  
1685  ***      0                                            my @sec_indexes   = map {
1686  ***      0                                               my $key_def = $_->{ddl};
1687  ***      0                                               $key_def =~ s/([\(\)])/\\$1/g;
1688  ***      0                                               $ddl =~ s/\s+$key_def//;
1689  ***      0                                               "ADD $_->{ddl}";
1690                                                        }
1691  ***      0                                            grep { $_->{name} ne $clustered_key }
1692  ***      0                                            values %{$tbl_struct->{keys}};
1693  ***      0                                            MKDEBUG && _d('Secondary indexes:', Dumper(\@sec_indexes));
1694                                                  
1695  ***      0      0                                     if ( @sec_indexes ) {
1696  ***      0                                               $sec_indexes_ddl = join(' ', @sec_indexes);
1697  ***      0                                               $sec_indexes_ddl =~ s/,$//;
1698                                                        }
1699                                                  
1700  ***      0                                            $ddl =~ s/,(\n\) )/$1/s;
1701                                                     }
1702                                                     else {
1703  ***      0                                            MKDEBUG && _d('Not removing secondary indexes from',
1704                                                           $tbl_struct->{engine}, 'table');
1705                                                     }
1706                                                  
1707  ***      0                                         return $ddl, $sec_indexes_ddl, $tbl_struct;
1708                                                  }
1709                                                  
1710                                                  sub _d {
1711  ***      0                    0                    my ($package, undef, $line) = caller 0;
1712  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1713  ***      0                                              map { defined $_ ? $_ : 'undef' }
1714                                                          @_;
1715  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1716                                                  }
1717                                                  
1718                                                  1;
1719                                                  
1720                                                  # ###########################################################################
1721                                                  # End TableParser package
1722                                                  # ###########################################################################
1723                                                  
1724                                                  # ###########################################################################
1725                                                  # MySQLDump package 5266
1726                                                  # ###########################################################################
1727                                                  package MySQLDump;
1728                                                  
1729           1                    1             8   use strict;
               1                                  3   
               1                                  6   
1730           1                    1             5   use warnings FATAL => 'all';
               1                                  6   
               1                                  6   
1731                                                  
1732           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  6   
1733                                                  
1734  ***      1            50      1             7   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 17   
1735                                                  
1736                                                  ( our $before = <<'EOF') =~ s/^   //gm;
1737                                                     /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
1738                                                     /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
1739                                                     /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
1740                                                     /*!40101 SET NAMES utf8 */;
1741                                                     /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
1742                                                     /*!40103 SET TIME_ZONE='+00:00' */;
1743                                                     /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
1744                                                     /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
1745                                                     /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
1746                                                     /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
1747                                                  EOF
1748                                                  
1749                                                  ( our $after = <<'EOF') =~ s/^   //gm;
1750                                                     /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
1751                                                     /*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
1752                                                     /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
1753                                                     /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
1754                                                     /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
1755                                                     /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
1756                                                     /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
1757                                                     /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
1758                                                  EOF
1759                                                  
1760                                                  sub new {
1761  ***      0                    0                    my ( $class, %args ) = @_;
1762  ***      0      0                                  $args{cache} = 1 unless defined $args{cache};
1763  ***      0                                         my $self = bless \%args, $class;
1764  ***      0                                         return $self;
1765                                                  }
1766                                                  
1767                                                  sub dump {
1768  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $tbl, $what ) = @_;
1769                                                  
1770  ***      0      0                                  if ( $what eq 'table' ) {
      ***             0                               
      ***             0                               
1771  ***      0                                            my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
1772  ***      0      0                                     return unless $ddl;
1773  ***      0      0                                     if ( $ddl->[0] eq 'table' ) {
1774  ***      0                                               return $before
1775                                                              . 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
1776                                                              . $ddl->[1] . ";\n";
1777                                                        }
1778                                                        else {
1779  ***      0                                               return 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
1780                                                              . '/*!50001 DROP VIEW IF EXISTS '
1781                                                              . $quoter->quote($tbl) . "*/;\n/*!50001 "
1782                                                              . $self->get_tmp_table($dbh, $quoter, $db, $tbl) . "*/;\n";
1783                                                        }
1784                                                     }
1785                                                     elsif ( $what eq 'triggers' ) {
1786  ***      0                                            my $trgs = $self->get_triggers($dbh, $quoter, $db, $tbl);
1787  ***      0      0      0                              if ( $trgs && @$trgs ) {
1788  ***      0                                               my $result = $before . "\nDELIMITER ;;\n";
1789  ***      0                                               foreach my $trg ( @$trgs ) {
1790  ***      0      0                                           if ( $trg->{sql_mode} ) {
1791  ***      0                                                     $result .= qq{/*!50003 SET SESSION SQL_MODE='$trg->{sql_mode}' */;;\n};
1792                                                              }
1793  ***      0                                                  $result .= "/*!50003 CREATE */ ";
1794  ***      0      0                                           if ( $trg->{definer} ) {
1795  ***      0                                                     my ( $user, $host )
1796  ***      0                                                        = map { s/'/''/g; "'$_'"; }
      ***      0                                      
1797                                                                      split('@', $trg->{definer}, 2);
1798  ***      0                                                     $result .= "/*!50017 DEFINER=$user\@$host */ ";
1799                                                              }
1800  ***      0                                                  $result .= sprintf("/*!50003 TRIGGER %s %s %s ON %s\nFOR EACH ROW %s */;;\n\n",
1801                                                                 $quoter->quote($trg->{trigger}),
1802  ***      0                                                     @{$trg}{qw(timing event)},
1803                                                                 $quoter->quote($trg->{table}),
1804                                                                 $trg->{statement});
1805                                                           }
1806  ***      0                                               $result .= "DELIMITER ;\n\n/*!50003 SET SESSION SQL_MODE=\@OLD_SQL_MODE */;\n\n";
1807  ***      0                                               return $result;
1808                                                        }
1809                                                        else {
1810  ***      0                                               return undef;
1811                                                        }
1812                                                     }
1813                                                     elsif ( $what eq 'view' ) {
1814  ***      0                                            my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
1815  ***      0                                            return '/*!50001 DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
1816                                                           . '/*!50001 DROP VIEW IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
1817                                                           . '/*!50001 ' . $ddl->[1] . "*/;\n";
1818                                                     }
1819                                                     else {
1820  ***      0                                            die "You didn't say what to dump.";
1821                                                     }
1822                                                  }
1823                                                  
1824                                                  sub _use_db {
1825  ***      0                    0                    my ( $self, $dbh, $quoter, $new ) = @_;
1826  ***      0      0                                  if ( !$new ) {
1827  ***      0                                            MKDEBUG && _d('No new DB to use');
1828  ***      0                                            return;
1829                                                     }
1830  ***      0                                         my $sql = 'SELECT DATABASE()';
1831  ***      0                                         MKDEBUG && _d($sql);
1832  ***      0                                         my $curr = $dbh->selectrow_array($sql);
1833  ***      0      0      0                           if ( $curr && $new && $curr eq $new ) {
      ***                    0                        
1834  ***      0                                            MKDEBUG && _d('Current and new DB are the same');
1835  ***      0                                            return $curr;
1836                                                     }
1837  ***      0                                         $sql = 'USE ' . $quoter->quote($new);
1838  ***      0                                         MKDEBUG && _d($sql);
1839  ***      0                                         $dbh->do($sql);
1840  ***      0                                         return $curr;
1841                                                  }
1842                                                  
1843                                                  sub get_create_table {
1844  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
1845  ***      0      0      0                           if ( !$self->{cache} || !$self->{tables}->{$db}->{$tbl} ) {
1846  ***      0                                            my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
1847                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
1848                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
1849                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
1850  ***      0                                            MKDEBUG && _d($sql);
1851  ***      0                                            eval { $dbh->do($sql); };
      ***      0                                      
1852  ***      0                                            MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
1853  ***      0                                            my $curr_db = $self->_use_db($dbh, $quoter, $db);
1854  ***      0                                            $sql = "SHOW CREATE TABLE " . $quoter->quote($db, $tbl);
1855  ***      0                                            MKDEBUG && _d($sql);
1856  ***      0                                            my $href;
1857  ***      0                                            eval { $href = $dbh->selectrow_hashref($sql); };
      ***      0                                      
1858  ***      0      0                                     if ( $EVAL_ERROR ) {
1859  ***      0                                               warn "Failed to $sql.  The table may be damaged.\nError: $EVAL_ERROR";
1860  ***      0                                               return;
1861                                                        }
1862  ***      0                                            $self->_use_db($dbh, $quoter, $curr_db);
1863  ***      0                                            $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
1864                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
1865  ***      0                                            MKDEBUG && _d($sql);
1866  ***      0                                            $dbh->do($sql);
1867  ***      0                                            my ($key) = grep { m/create table/i } keys %$href;
      ***      0                                      
1868  ***      0      0                                     if ( $key ) {
1869  ***      0                                               MKDEBUG && _d('This table is a base table');
1870  ***      0                                               $self->{tables}->{$db}->{$tbl} = [ 'table', $href->{$key} ];
1871                                                        }
1872                                                        else {
1873  ***      0                                               MKDEBUG && _d('This table is a view');
1874  ***      0                                               ($key) = grep { m/create view/i } keys %$href;
      ***      0                                      
1875  ***      0                                               $self->{tables}->{$db}->{$tbl} = [ 'view', $href->{$key} ];
1876                                                        }
1877                                                     }
1878  ***      0                                         return $self->{tables}->{$db}->{$tbl};
1879                                                  }
1880                                                  
1881                                                  sub get_columns {
1882  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
1883  ***      0                                         MKDEBUG && _d('Get columns for', $db, $tbl);
1884  ***      0      0      0                           if ( !$self->{cache} || !$self->{columns}->{$db}->{$tbl} ) {
1885  ***      0                                            my $curr_db = $self->_use_db($dbh, $quoter, $db);
1886  ***      0                                            my $sql = "SHOW COLUMNS FROM " . $quoter->quote($db, $tbl);
1887  ***      0                                            MKDEBUG && _d($sql);
1888  ***      0                                            my $cols = $dbh->selectall_arrayref($sql, { Slice => {} });
1889  ***      0                                            $self->_use_db($dbh, $quoter, $curr_db);
1890  ***      0                                            $self->{columns}->{$db}->{$tbl} = [
1891                                                           map {
1892  ***      0                                                  my %row;
1893  ***      0                                                  @row{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                      
1894  ***      0                                                  \%row;
1895                                                           } @$cols
1896                                                        ];
1897                                                     }
1898  ***      0                                         return $self->{columns}->{$db}->{$tbl};
1899                                                  }
1900                                                  
1901                                                  sub get_tmp_table {
1902  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
1903  ***      0                                         my $result = 'CREATE TABLE ' . $quoter->quote($tbl) . " (\n";
1904  ***      0                                         $result .= join(",\n",
1905  ***      0                                            map { '  ' . $quoter->quote($_->{field}) . ' ' . $_->{type} }
1906  ***      0                                            @{$self->get_columns($dbh, $quoter, $db, $tbl)});
1907  ***      0                                         $result .= "\n)";
1908  ***      0                                         MKDEBUG && _d($result);
1909  ***      0                                         return $result;
1910                                                  }
1911                                                  
1912                                                  sub get_triggers {
1913  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
1914  ***      0      0      0                           if ( !$self->{cache} || !$self->{triggers}->{$db} ) {
1915  ***      0                                            $self->{triggers}->{$db} = {};
1916  ***      0                                            my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
1917                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
1918                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
1919                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
1920  ***      0                                            MKDEBUG && _d($sql);
1921  ***      0                                            eval { $dbh->do($sql); };
      ***      0                                      
1922  ***      0                                            MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
1923  ***      0                                            $sql = "SHOW TRIGGERS FROM " . $quoter->quote($db);
1924  ***      0                                            MKDEBUG && _d($sql);
1925  ***      0                                            my $sth = $dbh->prepare($sql);
1926  ***      0                                            $sth->execute();
1927  ***      0      0                                     if ( $sth->rows ) {
1928  ***      0                                               my $trgs = $sth->fetchall_arrayref({});
1929  ***      0                                               foreach my $trg (@$trgs) {
1930  ***      0                                                  my %trg;
1931  ***      0                                                  @trg{ map { lc $_ } keys %$trg } = values %$trg;
      ***      0                                      
1932  ***      0                                                  push @{ $self->{triggers}->{$db}->{ $trg{table} } }, \%trg;
      ***      0                                      
1933                                                           }
1934                                                        }
1935  ***      0                                            $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
1936                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
1937  ***      0                                            MKDEBUG && _d($sql);
1938  ***      0                                            $dbh->do($sql);
1939                                                     }
1940  ***      0      0                                  if ( $tbl ) {
1941  ***      0                                            return $self->{triggers}->{$db}->{$tbl};
1942                                                     }
1943  ***      0                                         return values %{$self->{triggers}->{$db}};
      ***      0                                      
1944                                                  }
1945                                                  
1946                                                  sub get_databases {
1947  ***      0                    0                    my ( $self, $dbh, $quoter, $like ) = @_;
1948  ***      0      0      0                           if ( !$self->{cache} || !$self->{databases} || $like ) {
      ***                    0                        
1949  ***      0                                            my $sql = 'SHOW DATABASES';
1950  ***      0                                            my @params;
1951  ***      0      0                                     if ( $like ) {
1952  ***      0                                               $sql .= ' LIKE ?';
1953  ***      0                                               push @params, $like;
1954                                                        }
1955  ***      0                                            my $sth = $dbh->prepare($sql);
1956  ***      0                                            MKDEBUG && _d($sql, @params);
1957  ***      0                                            $sth->execute( @params );
1958  ***      0                                            my @dbs = map { $_->[0] } @{$sth->fetchall_arrayref()};
      ***      0                                      
      ***      0                                      
1959  ***      0      0                                     $self->{databases} = \@dbs unless $like;
1960  ***      0                                            return @dbs;
1961                                                     }
1962  ***      0                                         return @{$self->{databases}};
      ***      0                                      
1963                                                  }
1964                                                  
1965                                                  sub get_table_status {
1966  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $like ) = @_;
1967  ***      0      0      0                           if ( !$self->{cache} || !$self->{table_status}->{$db} || $like ) {
      ***                    0                        
1968  ***      0                                            my $sql = "SHOW TABLE STATUS FROM " . $quoter->quote($db);
1969  ***      0                                            my @params;
1970  ***      0      0                                     if ( $like ) {
1971  ***      0                                               $sql .= ' LIKE ?';
1972  ***      0                                               push @params, $like;
1973                                                        }
1974  ***      0                                            MKDEBUG && _d($sql, @params);
1975  ***      0                                            my $sth = $dbh->prepare($sql);
1976  ***      0                                            $sth->execute(@params);
1977  ***      0                                            my @tables = @{$sth->fetchall_arrayref({})};
      ***      0                                      
1978  ***      0                                            @tables = map {
1979  ***      0                                               my %tbl; # Make a copy with lowercased keys
1980  ***      0                                               @tbl{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                      
1981  ***      0             0                                 $tbl{engine} ||= $tbl{type} || $tbl{comment};
      ***                    0                        
1982  ***      0                                               delete $tbl{type};
1983  ***      0                                               \%tbl;
1984                                                        } @tables;
1985  ***      0      0                                     $self->{table_status}->{$db} = \@tables unless $like;
1986  ***      0                                            return @tables;
1987                                                     }
1988  ***      0                                         return @{$self->{table_status}->{$db}};
      ***      0                                      
1989                                                  }
1990                                                  
1991                                                  sub get_table_list {
1992  ***      0                    0                    my ( $self, $dbh, $quoter, $db, $like ) = @_;
1993  ***      0      0      0                           if ( !$self->{cache} || !$self->{table_list}->{$db} || $like ) {
      ***                    0                        
1994  ***      0                                            my $sql = "SHOW /*!50002 FULL*/ TABLES FROM " . $quoter->quote($db);
1995  ***      0                                            my @params;
1996  ***      0      0                                     if ( $like ) {
1997  ***      0                                               $sql .= ' LIKE ?';
1998  ***      0                                               push @params, $like;
1999                                                        }
2000  ***      0                                            MKDEBUG && _d($sql, @params);
2001  ***      0                                            my $sth = $dbh->prepare($sql);
2002  ***      0                                            $sth->execute(@params);
2003  ***      0                                            my @tables = @{$sth->fetchall_arrayref()};
      ***      0                                      
2004  ***      0      0      0                              @tables = map {
2005  ***      0                                               my %tbl = (
2006                                                              name   => $_->[0],
2007                                                              engine => ($_->[1] || '') eq 'VIEW' ? 'VIEW' : '',
2008                                                           );
2009  ***      0                                               \%tbl;
2010                                                        } @tables;
2011  ***      0      0                                     $self->{table_list}->{$db} = \@tables unless $like;
2012  ***      0                                            return @tables;
2013                                                     }
2014  ***      0                                         return @{$self->{table_list}->{$db}};
      ***      0                                      
2015                                                  }
2016                                                  
2017                                                  sub _d {
2018  ***      0                    0                    my ($package, undef, $line) = caller 0;
2019  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2020  ***      0                                              map { defined $_ ? $_ : 'undef' }
2021                                                          @_;
2022  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2023                                                  }
2024                                                  
2025                                                  1;
2026                                                  
2027                                                  # ###########################################################################
2028                                                  # End MySQLDump package
2029                                                  # ###########################################################################
2030                                                  
2031                                                  # ###########################################################################
2032                                                  # Daemon package 5266
2033                                                  # ###########################################################################
2034                                                  
2035                                                  package Daemon;
2036                                                  
2037           1                    1             7   use strict;
               1                                  3   
               1                                242   
2038           1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  5   
2039                                                  
2040           1                    1             6   use POSIX qw(setsid);
               1                                  2   
               1                                  6   
2041           1                    1             5   use English qw(-no_match_vars);
               1                                  2   
               1                                  6   
2042                                                  
2043  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                 11   
               1                                 15   
2044                                                  
2045                                                  sub new {
2046  ***      0                    0                    my ( $class, %args ) = @_;
2047  ***      0                                         foreach my $arg ( qw(o) ) {
2048  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
2049                                                     }
2050  ***      0                                         my $o = $args{o};
2051  ***      0      0                                  my $self = {
      ***             0                               
2052                                                        o        => $o,
2053                                                        log_file => $o->has('log') ? $o->get('log') : undef,
2054                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
2055                                                     };
2056                                                  
2057  ***      0                                         check_PID_file(undef, $self->{PID_file});
2058                                                  
2059  ***      0                                         MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
2060  ***      0                                         return bless $self, $class;
2061                                                  }
2062                                                  
2063                                                  sub daemonize {
2064  ***      0                    0                    my ( $self ) = @_;
2065                                                  
2066  ***      0                                         MKDEBUG && _d('About to fork and daemonize');
2067  ***      0      0                                  defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
2068  ***      0      0                                  if ( $pid ) {
2069  ***      0                                            MKDEBUG && _d('I am the parent and now I die');
2070  ***      0                                            exit;
2071                                                     }
2072                                                  
2073  ***      0                                         $self->{child} = 1;
2074                                                  
2075  ***      0      0                                  POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
2076  ***      0      0                                  chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
2077                                                  
2078  ***      0                                         $self->_make_PID_file();
2079                                                  
2080  ***      0                                         $OUTPUT_AUTOFLUSH = 1;
2081                                                  
2082  ***      0      0                                  if ( -t STDIN ) {
2083  ***      0                                            close STDIN;
2084  ***      0      0                                     open  STDIN, '/dev/null'
2085                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
2086                                                     }
2087                                                  
2088  ***      0      0                                  if ( $self->{log_file} ) {
2089  ***      0                                            close STDOUT;
2090  ***      0      0                                     open  STDOUT, '>>', $self->{log_file}
2091                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
2092                                                  
2093  ***      0                                            close STDERR;
2094  ***      0      0                                     open  STDERR, ">&STDOUT"
2095                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
2096                                                     }
2097                                                     else {
2098  ***      0      0                                     if ( -t STDOUT ) {
2099  ***      0                                               close STDOUT;
2100  ***      0      0                                        open  STDOUT, '>', '/dev/null'
2101                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
2102                                                        }
2103  ***      0      0                                     if ( -t STDERR ) {
2104  ***      0                                               close STDERR;
2105  ***      0      0                                        open  STDERR, '>', '/dev/null'
2106                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
2107                                                        }
2108                                                     }
2109                                                  
2110  ***      0                                         MKDEBUG && _d('I am the child and now I live daemonized');
2111  ***      0                                         return;
2112                                                  }
2113                                                  
2114                                                  sub check_PID_file {
2115  ***      0                    0                    my ( $self, $file ) = @_;
2116  ***      0      0                                  my $PID_file = $self ? $self->{PID_file} : $file;
2117  ***      0                                         MKDEBUG && _d('Checking PID file', $PID_file);
2118  ***      0      0      0                           if ( $PID_file && -f $PID_file ) {
2119  ***      0                                            my $pid;
2120  ***      0                                            eval { chomp($pid = `cat $PID_file`); };
      ***      0                                      
2121  ***      0      0                                     die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
2122  ***      0                                            MKDEBUG && _d('PID file exists; it contains PID', $pid);
2123  ***      0      0                                     if ( $pid ) {
2124  ***      0                                               my $pid_is_alive = kill 0, $pid;
2125  ***      0      0                                        if ( $pid_is_alive ) {
2126  ***      0                                                  die "The PID file $PID_file already exists "
2127                                                                 . " and the PID that it contains, $pid, is running";
2128                                                           }
2129                                                           else {
2130  ***      0                                                  warn "Overwriting PID file $PID_file because the PID that it "
2131                                                                 . "contains, $pid, is not running";
2132                                                           }
2133                                                        }
2134                                                        else {
2135  ***      0                                               die "The PID file $PID_file already exists but it does not "
2136                                                              . "contain a PID";
2137                                                        }
2138                                                     }
2139                                                     else {
2140  ***      0                                            MKDEBUG && _d('No PID file');
2141                                                     }
2142  ***      0                                         return;
2143                                                  }
2144                                                  
2145                                                  sub make_PID_file {
2146  ***      0                    0                    my ( $self ) = @_;
2147  ***      0      0                                  if ( exists $self->{child} ) {
2148  ***      0                                            die "Do not call Daemon::make_PID_file() for daemonized scripts";
2149                                                     }
2150  ***      0                                         $self->_make_PID_file();
2151  ***      0                                         $self->{rm_PID_file} = 1;
2152  ***      0                                         return;
2153                                                  }
2154                                                  
2155                                                  sub _make_PID_file {
2156  ***      0                    0                    my ( $self ) = @_;
2157                                                  
2158  ***      0                                         my $PID_file = $self->{PID_file};
2159  ***      0      0                                  if ( !$PID_file ) {
2160  ***      0                                            MKDEBUG && _d('No PID file to create');
2161  ***      0                                            return;
2162                                                     }
2163                                                  
2164  ***      0                                         $self->check_PID_file();
2165                                                  
2166  ***      0      0                                  open my $PID_FH, '>', $PID_file
2167                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
2168  ***      0      0                                  print $PID_FH $PID
2169                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
2170  ***      0      0                                  close $PID_FH
2171                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
2172                                                  
2173  ***      0                                         MKDEBUG && _d('Created PID file:', $self->{PID_file});
2174  ***      0                                         return;
2175                                                  }
2176                                                  
2177                                                  sub _remove_PID_file {
2178  ***      0                    0                    my ( $self ) = @_;
2179  ***      0      0      0                           if ( $self->{PID_file} && -f $self->{PID_file} ) {
2180  ***      0      0                                     unlink $self->{PID_file}
2181                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
2182  ***      0                                            MKDEBUG && _d('Removed PID file');
2183                                                     }
2184                                                     else {
2185  ***      0                                            MKDEBUG && _d('No PID to remove');
2186                                                     }
2187  ***      0                                         return;
2188                                                  }
2189                                                  
2190                                                  sub DESTROY {
2191  ***      0                    0                    my ( $self ) = @_;
2192  ***      0      0      0                           $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
2193  ***      0                                         return;
2194                                                  }
2195                                                  
2196                                                  sub _d {
2197  ***      0                    0                    my ($package, undef, $line) = caller 0;
2198  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2199  ***      0                                              map { defined $_ ? $_ : 'undef' }
2200                                                          @_;
2201  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2202                                                  }
2203                                                  
2204                                                  1;
2205                                                  
2206                                                  # ###########################################################################
2207                                                  # End Daemon package
2208                                                  # ###########################################################################
2209                                                  
2210                                                  # ###########################################################################
2211                                                  # This is a combination of modules and programs in one -- a runnable module.
2212                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
2213                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
2214                                                  #
2215                                                  # Check at the end of this package for the call to main() which actually runs
2216                                                  # the program.
2217                                                  # ###########################################################################
2218                                                  package mk_find;
2219                                                  
2220           1                    1             7   use English qw(-no_match_vars);
               1                                  7   
               1                                  5   
2221                                                  
2222  ***      1            50      1             7   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 13   
2223                                                  
2224                                                  $OUTPUT_AUTOFLUSH = 1;
2225                                                  
2226                                                  # ############################################################################
2227                                                  # Lookup tables and global variables
2228                                                  # ############################################################################
2229                                                  my $o;            # OptionParser obj
2230                                                  my %fmt_for;      # Interpolated strings
2231                                                  my %time_for;     # Holds time constants for mmin, mtime etc
2232                                                  my %connections;  # Holds a list of thread IDs connected
2233                                                  my $server_id;    # Holds the server's @@SERVER_ID
2234                                                  my $dbh;          # This program's $dbh
2235                                                  my $exec_dbh;     # The $dbh to use for exec and exec-plus
2236                                                  my $tp;
2237                                                  my $du;
2238                                                  
2239                                                  # Functions to call while evaluating tests.
2240                                                  my %test_for = (
2241                                                     autoinc => sub {
2242                                                        my ( $table ) = @_;
2243                                                        return test_number($table, 'Auto_increment', $o->get('autoinc'));
2244                                                     },
2245                                                     avgrowlen => sub {
2246                                                        my ( $table ) = @_;
2247                                                        return test_number($table, 'Avg_row_length', $o->get('avgrowlen'));
2248                                                     },
2249                                                     checksum => sub {
2250                                                        my ( $table ) = @_;
2251                                                        return test_number($table, 'Checksum', $o->get('checksum'));
2252                                                     },
2253                                                     cmin => sub {
2254                                                        my ( $table ) = @_;
2255                                                        return test_date($table, 'Create_time', 'cmin');
2256                                                     },
2257                                                     collation => sub {
2258                                                        my ( $table ) = @_;
2259                                                        return test_regex($table, 'Collation', $o->get('collation'));
2260                                                     },
2261                                                     'column-name' => sub {
2262                                                        my ( $table ) = @_;
2263                                                        my $struct = $table->{struct};
2264                                                        return unless $struct;
2265                                                        my $test = $o->get('column-name');
2266                                                        if ( $o->get('case-insensitive') ) {
2267                                                           $test = "(?i)$test";
2268                                                        }
2269                                                        foreach my $col ( @{$struct->{cols}} ) {
2270                                                           return 1 if $col =~ m/$test/;
2271                                                        }
2272                                                        return 0;
2273                                                     },
2274                                                     comment => sub {
2275                                                        my ( $table ) = @_;
2276                                                        return test_regex($table, 'Comment', $o->get('comment'));
2277                                                     },
2278                                                     createopts => sub {
2279                                                        my ( $table ) = @_;
2280                                                        return test_regex($table, 'Create_options', $o->get('createopts'));
2281                                                     },
2282                                                     ctime => sub {
2283                                                        my ( $table ) = @_;
2284                                                        return test_date($table, 'Create_time', 'ctime');
2285                                                     },
2286                                                     datafree => sub {
2287                                                        my ( $table ) = @_;
2288                                                        return test_number($table, 'Data_free', $o->get('datafree'));
2289                                                     },
2290                                                     datasize => sub {
2291                                                        my ( $table ) = @_;
2292                                                        return test_number($table, 'Data_length', $o->get('datasize'));
2293                                                     },
2294                                                     dbregex => sub {
2295                                                        my ( $table ) = @_;
2296                                                        return test_regex($table, 'Database', $o->get('dbregex'));
2297                                                     },
2298                                                     empty => sub {
2299                                                        my ( $table ) = @_;
2300                                                        return test_number($table, 'Rows', '0');
2301                                                     },
2302                                                     engine => sub {
2303                                                        my ( $table ) = @_;
2304                                                        return test_regex($table, 'Engine', $o->get('engine'));
2305                                                     },
2306                                                     function => sub {
2307                                                        my ( $table ) = @_;
2308                                                        return unless $table->{stored_code} && $table->{stored_code} eq 'FUNCTION';
2309                                                        my $def = $table->{def};
2310                                                        return unless $def;
2311                                                        my $test = $o->get('function');
2312                                                        if ( $o->get('case-insensitive') ) {
2313                                                           $test = "(?i)$test";
2314                                                        }
2315                                                        return $def =~ m/$test/;
2316                                                     },
2317                                                     indexsize => sub {
2318                                                        my ( $table ) = @_;
2319                                                        return test_number($table, 'Index_length', $o->get('indexsize'));
2320                                                     },
2321                                                     kmin => sub {
2322                                                        my ( $table ) = @_;
2323                                                        return test_date($table, 'Check_time', 'kmin');
2324                                                     },
2325                                                     ktime => sub {
2326                                                        my ( $table ) = @_;
2327                                                        return test_date($table, 'Check_time', 'ktime');
2328                                                     },
2329                                                     mmin => sub {
2330                                                        my ( $table ) = @_;
2331                                                        return test_date($table, 'Update_time', 'mmin');
2332                                                     },
2333                                                     mtime => sub {
2334                                                        my ( $table ) = @_;
2335                                                        return test_date($table, 'Update_time', 'mtime');
2336                                                     },
2337                                                     'connection-id' => sub {
2338                                                        my ( $table ) = @_;
2339                                                        my $test = $o->get('case-insensitive') ? "(?i)".$o->get('connection-id')
2340                                                                 : $o->get('connection-id');
2341                                                        my ( $pid ) = $table->{Name} =~ m/$test/;
2342                                                        return $pid && !exists $connections{$pid};
2343                                                     },
2344                                                     procedure => sub {
2345                                                        my ( $table ) = @_;
2346                                                        return unless $table->{stored_code} && $table->{stored_code} eq 'PROCEDURE';
2347                                                        my $def = $table->{def};
2348                                                        return unless $def;
2349                                                        my $test = $o->get('procedure');
2350                                                        if ( $o->get('case-insensitive') ) {
2351                                                           $test = "(?i)$test";
2352                                                        }
2353                                                        return $def =~ m/$test/;
2354                                                     },
2355                                                     rows => sub {
2356                                                        my ( $table ) = @_;
2357                                                        return test_number($table, 'Rows', $o->get('rows'));
2358                                                     },
2359                                                     rowformat => sub {
2360                                                        my ( $table ) = @_;
2361                                                        return test_regex($table, 'Row_format', $o->get('rowformat'));
2362                                                     },
2363                                                     'server-id' => sub {
2364                                                        my ( $table ) = @_;
2365                                                        my $test = $o->get('case-insensitive') ? "(?i)".$o->get('server-id')
2366                                                                 : $o->get('server-id');
2367                                                        my ( $sid ) = $table->{Name} =~ m/$test/;
2368                                                        return $sid && $sid == $server_id;
2369                                                     },
2370                                                     tablesize => sub {
2371                                                        my ( $table ) = @_;
2372                                                        return test_number($table, 'Table_length', $o->get('tablesize'));
2373                                                     },
2374                                                     tblregex => sub {
2375                                                        my ( $table ) = @_;
2376                                                        return test_regex($table, 'Name', $o->get('tblregex'));
2377                                                     },
2378                                                     tblversion => sub {
2379                                                        my ( $table ) = @_;
2380                                                        return test_number($table, 'Version', $o->get('tblversion'));
2381                                                     },
2382                                                     trigger => sub {
2383                                                        my ( $table ) = @_;
2384                                                        return unless $table->{stored_code} && $table->{stored_code} eq 'TRIGGER';
2385                                                        my $def = $table->{def};
2386                                                        return unless $def;
2387                                                        my $test = $o->get('trigger');
2388                                                        if ( $o->get('case-insensitive') ) {
2389                                                           $test = "(?i)$test";
2390                                                        }
2391                                                        return $def =~ m/$test/;
2392                                                     },
2393                                                     'trigger-table' => sub {
2394                                                        my ( $table ) = @_;
2395                                                        return unless $table->{stored_code} && $table->{stored_code} eq 'TRIGGER';
2396                                                        my $test = $o->get('trigger-table');
2397                                                        if ( $o->get('case-insensitive') ) {
2398                                                           $test = "(?i)$test";
2399                                                        }
2400                                                        return $table->{trigger_table} =~ m/$test/;
2401                                                     },
2402                                                     view => sub {
2403                                                        my ( $table ) = @_;
2404                                                        my $view = $table->{view};
2405                                                        return unless $view;
2406                                                        my $test = $o->get('view');
2407                                                        if ( $o->get('case-insensitive') ) {
2408                                                           $test = "(?i)$test";
2409                                                        }
2410                                                        return $view =~ m/$test/;
2411                                                     },
2412                                                  );
2413                                                  
2414                                                  # Functions to call when doing actions
2415                                                  my %action_for = (
2416                                                     print => sub {
2417                                                        my ( $table ) = @_;
2418                                                        print "$table->{Database}.$table->{Name}\n";
2419                                                     },
2420                                                     exec => sub {
2421                                                        my ( $table ) = @_;
2422                                                        my $sql = sprintf($fmt_for{exec}->{str},
2423                                                           map { defined $_ ? $_ : '' }
2424                                                           @{$table}{@{$fmt_for{exec}->{arg_names}}});
2425                                                        MKDEBUG && _d($sql);
2426                                                        $exec_dbh->do($sql);
2427                                                     },
2428                                                     printf => sub {
2429                                                        my ( $table ) = @_;
2430                                                        printf($fmt_for{printf}->{str},
2431                                                           map { defined $_ ? $_ : '' }
2432                                                           @{$table}{@{$fmt_for{printf}->{arg_names}}});
2433                                                     },
2434                                                  );
2435                                                  
2436                                                  my %arg_for = (
2437                                                     a => 'Auto_increment',
2438                                                     A => 'Avg_row_length',
2439                                                     c => 'Checksum',
2440                                                     C => 'Create_time',
2441                                                     D => 'Database',
2442                                                     d => 'Data_length',
2443                                                     E => 'Engine',
2444                                                     F => 'Data_free',
2445                                                     f => 'Innodb_free',
2446                                                     I => 'Index_length',
2447                                                     K => 'Check_time',
2448                                                     L => 'Collation',
2449                                                     M => 'Max_data_length',
2450                                                     N => 'Name',
2451                                                     O => 'Comment',
2452                                                     P => 'Create_options',
2453                                                     R => 'Row_format',
2454                                                     S => 'Rows',
2455                                                     T => 'Table_length',
2456                                                     U => 'Update_time',
2457                                                     V => 'Version',
2458                                                  );
2459                                                  
2460                                                  my @table_struct_tests = qw(
2461                                                     column-name
2462                                                     view
2463                                                  );
2464                                                  
2465                                                  my @stored_code_tests = qw(
2466                                                     procedure
2467                                                     function
2468                                                     trigger
2469                                                  );
2470                                                  
2471                                                  sub main {
2472  ***      0                    0                    @ARGV = @_;  # set global ARGV for this package
2473                                                  
2474                                                     # ########################################################################
2475                                                     # Get configuration information.
2476                                                     # ########################################################################
2477  ***      0                                         my $q  = new Quoter();
2478  ***      0                                         my $dp = new DSNParser();
2479  ***      0                                            $o  = new OptionParser(
2480                                                        strict      => 0,
2481                                                        prompt      => '[option]... [database...]',
2482                                                        description => 'searches for MySQL tables and executes actions, like '
2483                                                                     . 'GNU find.  The default action is to print the database '
2484                                                                     . 'and table name.',
2485                                                     );
2486  ***      0                                         $o->get_specs();
2487  ***      0                                         $o->get_opts();
2488                                                  
2489                                                     # Make sure OptionParser understands that these options are used.
2490                                                     # cmin ctime empty kmin ktime mmin mtime exec printf 
2491                                                  
2492                                                     # Ensure there is a capture group.
2493  ***      0      0      0                           if ( $o->get('connection-id') && $o->get('connection-id') !~ m/\(\\d\+\)/ ) {
2494  ***      0                                            $o->save_error("--connection-id regex doesn't capture digits with (\\d+)");
2495                                                     }
2496                                                  
2497                                                     # Ensure there is a capture group.
2498  ***      0      0      0                           if ( $o->get('server-id') && $o->get('server-id') !~ m/\(\\d\+\)/ ) {
2499  ***      0                                            $o->save_error("--server-id regex doesn't capture digits with (\\d+)");
2500                                                     }
2501                                                  
2502  ***      0                                         $o->usage_or_errors();
2503                                                  
2504                                                     # Interpolate strings for printf and exec.  At the same time discover whether
2505                                                     # I must use SHOW TABLE STATUS (slower than SHOW TABLES) to fetch data.
2506  ***      0                                         my $showstat
2507  ***      0                                            = grep { $o->get($_) } qw( 
2508                                                           autoinc avgrowlen checksum cmin collation comment createopts ctime
2509                                                           datasize datafree empty engine indexsize kmin ktime mmin mtime rows
2510                                                           rowformat tablesize tblversion);
2511  ***      0                                         foreach my $thing (qw(exec printf)) {
2512  ***      0      0                                     next unless $o->get($thing);
2513  ***      0                                            my ($str, $arg_names) = interpolate($o->get($thing));
2514  ***      0                                            $fmt_for{$thing} = { str => $str, arg_names => $arg_names };
2515  ***      0      0                                     if ( grep { $_ !~ m/^(Database|Name)$/ } @$arg_names ) {
      ***      0                                      
2516  ***      0                                               $showstat = 1;
2517                                                        }
2518                                                     }
2519                                                  
2520                                                     # Discover if we need to parse SHOW CREATE TABLE.
2521  ***      0                                         my $need_table_struct = grep { $o->got($_); } @table_struct_tests;
      ***      0                                      
2522  ***      0                                         MKDEBUG && _d('Need table struct:', $need_table_struct);
2523  ***      0      0                                  if ( $need_table_struct ) {
2524  ***      0                                            $du = new MySQLDump();
2525  ***      0                                            $tp = new TableParser(Quoter => $q);
2526                                                     }
2527                                                  
2528                                                     # ########################################################################
2529                                                     # If --pid, check it first since we'll die if it already exits.
2530                                                     # ########################################################################
2531  ***      0                                         my $daemon;
2532  ***      0      0                                  if ( $o->get('pid') ) {
2533                                                        # We're not daemoninzing, it just handles PID stuff.  Keep $daemon
2534                                                        # in the the scope of main() because when it's destroyed it automatically
2535                                                        # removes the PID file.
2536  ***      0                                            $daemon = new Daemon(o=>$o);
2537  ***      0                                            $daemon->make_PID_file();
2538                                                     }
2539                                                  
2540                                                     # ########################################################################
2541                                                     # Get ready to do the main work.
2542                                                     # ########################################################################
2543                                                  
2544                                                     # Connect to the database.
2545  ***      0      0      0                           if ( !$o->get('password') && $o->get('ask-pass') ) {
2546  ***      0                                            $o->set('password', OptionParser::prompt_noecho("Enter password: "));
2547                                                     }
2548                                                  
2549  ***      0                                         $dp->prop('set-vars', $o->get('set-vars'));
2550  ***      0                                         my $dsn = $dp->parse_options($o);
2551  ***      0                                         $dbh    = $dp->get_dbh($dp->get_cxn_params($dsn), { AutoCommit => 1 } );
2552  ***      0      0                                  if ( $o->get('exec-dsn') ) {
2553  ***      0                                            my $exec_dsn = $dp->parse($o->get('exec-dsn'), $dsn);
2554  ***      0                                            $exec_dbh    = $dp->get_dbh($dp->get_cxn_params($exec_dsn),
2555                                                           { AutoCommit => 1 });
2556                                                     }
2557                                                     else {
2558  ***      0                                            $exec_dbh = $dbh;
2559                                                     }
2560                                                  
2561                                                     # If no other action was given, the default action is to print.
2562  ***      0      0                                  if ( !grep { $o->get($_) } qw( exec exec-plus print printf ) ) {
      ***      0                                      
2563  ***      0                                            $o->set('print', 1);
2564                                                     }
2565                                                  
2566                                                     # Figure out the time referred to by date/time options.
2567  ***      0                                         my $basetime;
2568  ***      0                                         foreach my $option (
      ***      0                                      
2569                                                        grep { defined $o->get($_) } qw(cmin ctime kmin ktime mmin mtime) )
2570                                                     {
2571                                                        # Initialize a consistent point in time.
2572  ***      0      0      0                              $basetime ||=
2573                                                           $dbh->selectcol_arrayref(
2574                                                              "SELECT " . ($o->get('day-start') ? 'CURRENT_DATE'
2575                                                                                                : 'CURRENT_TIMESTAMP')
2576                                                           )->[0];
2577                                                  
2578  ***      0                                            my ($val) = $o->get($option) =~ m/(\d+)/;
2579  ***      0      0                                     my $inter = $option =~ m/min/ ? 'MINUTE' : 'DAY';
2580  ***      0                                            my $query = "SELECT DATE_SUB('$basetime', INTERVAL $val $inter)";
2581  ***      0                                            $time_for{$option} = $dbh->selectcol_arrayref($query)->[0];
2582                                                     }
2583                                                  
2584                                                     # Fetch and save a list of processes currently running.
2585  ***      0      0                                  if ( $o->get('connection-id') ) {
2586                                                        # Ensure I have the PROCESS privilege.
2587  ***      0                                            my $proc =
2588  ***      0                                               grep { m/ALL PRIVILEGES.*?\*\.\*|PROCESS/ }
2589  ***      0                                               @{$dbh->selectcol_arrayref('SHOW GRANTS')};
2590  ***      0      0                                     if ( !$proc ) {
2591  ***      0                                               die "--connection-id requires the PROCESS privilege for safety.\n";
2592                                                        }
2593                                                     }
2594                                                  
2595  ***      0                                         ($server_id) = $dbh->selectrow_array('SELECT @@SERVER_ID');
2596                                                  
2597                                                     # Discover if we need to get stored code.  Need dbh to do this.
2598  ***      0                                         my $vp = new VersionParser();
2599  ***      0                                         my $need_stored_code = $vp->version_ge($dbh, '5.0.0');
2600  ***      0      0                                  $need_stored_code = grep { $o->got($_); } @stored_code_tests
      ***      0                                      
2601                                                        if $need_stored_code;
2602  ***      0                                         MKDEBUG && _d('Need stored code:', $need_stored_code);
2603                                                  
2604                                                     # ########################################################################
2605                                                     # Go do it.
2606                                                     # ########################################################################
2607  ***      0                                         my @databases = @ARGV             ? @ARGV
2608  ***      0                                                       : $o->get('dblike') ? @{$dbh->selectcol_arrayref('SHOW DATABASES LIKE ?', {}, $o->get('dblike'))}
2609  ***      0      0                                                :                     @{$dbh->selectcol_arrayref('SHOW DATABASES')};
      ***             0                               
2610                                                  
2611  ***      0                                         my @exec_plus;
2612                                                     DATABASE:
2613  ***      0                                         foreach my $database ( @databases ) {
2614  ***      0      0                                     next DATABASE if $database =~ m/^(?:information_schema|lost\+found)$/mi;
2615                                                  
2616  ***      0      0                                     my $sta = $showstat ? ' STATUS' : 'S';
2617  ***      0      0                                     my $sth = $o->get('tbllike')
2618                                                                ? $dbh->prepare("SHOW TABLE$sta FROM `$database` LIKE ?")
2619                                                                : $dbh->prepare("SHOW TABLE$sta FROM `$database`");
2620                                                  
2621  ***      0             0                              $sth->execute($o->get('tbllike') || ());
2622  ***      0                                            my @tables = @{$sth->fetchall_arrayref({})};
      ***      0                                      
2623                                                  
2624                                                        # Must re-fetch every time; there are too many ways things can go wrong
2625                                                        # otherwise (for example, the counter wraps over the unsigned int
2626                                                        # boundary).
2627  ***      0      0                                     if ( $o->get('connection-id') ) {
2628  ***      0                                               %connections = map { $_ => 1 }
      ***      0                                      
2629  ***      0                                                  @{$dbh->selectcol_arrayref('SHOW FULL PROCESSLIST')};
2630                                                        }
2631                                                  
2632                                                        # Make results uniform across MySQL versions, and generate additional
2633                                                        # properties.
2634  ***      0                                            foreach my $table ( @tables ) {
2635  ***      0      0                                        if ( $showstat ) {
2636  ***      0             0                                    my ($ib_free)            = $table->{Comment} && $table->{Comment} =~ m/InnoDB free: (\d+) kB/;
2637  ***      0             0                                    $table->{Engine}       ||= $table->{Type};
2638  ***      0             0                                    $table->{Table_length}   = ($table->{Index_length} || 0) + ($table->{Data_length} || 0);
      ***                    0                        
2639  ***      0      0                                           $table->{Innodb_free}    = $ib_free ? 1_024 * $ib_free : undef;
2640  ***      0                                                  delete $table->{Type};
2641                                                           }
2642                                                           else {
2643  ***      0                                                  my ($name) = values %$table;
2644  ***      0                                                  $table = { Name => $name };
2645                                                           }
2646  ***      0                                               $table->{Database} = $database;
2647                                                  
2648  ***      0      0                                        if ( $need_table_struct ) {
2649  ***      0                                                  MKDEBUG && _d('Getting table struct for',
2650                                                                 $database, '.', $table->{Name});
2651  ***      0                                                  my $ddl = $du->get_create_table($dbh,$q, $database, $table->{Name});
2652  ***      0      0                                           if ( $ddl->[0] eq 'table' ) {
      ***             0                               
2653  ***      0                                                     my $table_struct;
2654  ***      0                                                     eval { $table_struct = $tp->parse($ddl) };
      ***      0                                      
2655  ***      0      0                                              if ( $EVAL_ERROR ) {
2656  ***      0                                                        MKDEBUG && _d('Failed to parse table:', $EVAL_ERROR);
2657                                                                 }
2658  ***      0                                                     $table->{struct} = $table_struct;
2659                                                              }
2660                                                              elsif ( $ddl->[0] eq 'view' ) {
2661  ***      0                                                     $table->{view} = $ddl->[1];
2662                                                              }
2663                                                           }
2664                                                        }
2665                                                  
2666  ***      0      0                                     if ( $need_stored_code ) {
2667  ***      0                                               foreach my $type ( qw(PROCEDURE FUNCTION) ) {
2668  ***      0                                                  my $sql = "SELECT ROUTINE_NAME       AS name, "
2669                                                                      . "       ROUTINE_DEFINITION AS definition "
2670                                                                      . " FROM  INFORMATION_SCHEMA.ROUTINES "
2671                                                                      . " WHERE     ROUTINE_SCHEMA = '$database' "
2672                                                                      . "       AND ROUTINE_TYPE   = '$type'";
2673  ***      0                                                  MKDEBUG && _d($sql);
2674  ***      0                                                  my $codes = $dbh->selectall_arrayref($sql);
2675  ***      0                                                  foreach my $code ( @$codes ) {
2676  ***      0                                                     push @tables, {
2677                                                                    Database    => $database,
2678                                                                    Name        => "$type $code->[0]",
2679                                                                    stored_code => $type,
2680                                                                    def         => $code->[1],
2681                                                                 };
2682                                                              }
2683                                                           }
2684                                                  
2685  ***      0                                               my $sql = "SELECT TRIGGER_NAME       AS name, "
2686                                                                   . "       ACTION_STATEMENT   AS action, "
2687                                                                   . "       EVENT_OBJECT_TABLE AS `table`, "
2688                                                                   . "       EVENT_MANIPULATION AS type "
2689                                                                   . " FROM  INFORMATION_SCHEMA.TRIGGERS "
2690                                                                   . " WHERE EVENT_OBJECT_SCHEMA = '$database'";
2691  ***      0                                               MKDEBUG && _d($sql);
2692  ***      0                                               my $trigs = $dbh->selectall_arrayref($sql);
2693  ***      0                                               my $codes = $dbh->selectall_arrayref($sql);
2694  ***      0                                               foreach my $trig ( @$trigs ) {
2695  ***      0                                                  push @tables, {
2696                                                                 Database      => $database,
2697                                                                 Name          => "$trig->[3] TRIGGER $trig->[0] on $trig->[2]",
2698                                                                 trigger_table => $trig->[2],
2699                                                                 stored_code   => 'TRIGGER',
2700                                                                 def           => $trig->[1],
2701                                                              };
2702                                                           }
2703                                                        }
2704                                                  
2705                                                        # Apply the tests to find the matching tables.
2706  ***      0                                            @tables = grep {
2707  ***      0                                               my $table = $_;
2708  ***      0                                               my @tests = grep { $o->get($_) } keys %test_for;
      ***      0                                      
2709  ***      0      0                                        if ( @tests ) {
2710  ***      0      0                                           ($o->get('or') ? any($table, @tests) : all($table, @tests));
2711                                                           }
2712                                                           else {
2713  ***      0                                                  $table;  # No tests == all tables (issue 549).
2714                                                           }
2715                                                        } @tables;
2716                                                     
2717                                                        # Quote database and table names if desired.
2718  ***      0      0                                     if ( $o->get('quote') ) {
2719  ***      0                                               foreach my $table ( @tables ) {
2720  ***      0                                                  $table->{Database} = $q->quote($table->{Database});
2721  ***      0                                                  $table->{Name}     = $q->quote($table->{Name});
2722                                                           }
2723                                                        }
2724                                                  
2725  ***      0                                            foreach my $table ( @tables ) {
2726  ***      0                                               my @actions = grep { $o->get($_) } keys %action_for;
      ***      0                                      
2727  ***      0                                               foreach my $action ( @actions ) {
2728  ***      0                                                  $action_for{$action}->($table);
2729                                                           }
2730                                                        }
2731                                                  
2732  ***      0                                            push @exec_plus, @tables;
2733                                                     }
2734                                                  
2735                                                     # Handle exec-plus.
2736  ***      0      0                                  if ( $o->get('exec-plus') ) {
2737  ***      0                                            my $table_list = join(', ',map {"$_->{Database}.$_->{Name}"} @exec_plus);
      ***      0                                      
2738  ***      0                                            (my $sql = $o->get('exec-plus')) =~ s/%s/$table_list/g;
2739  ***      0                                            $exec_dbh->do($sql);
2740                                                     }
2741                                                  
2742  ***      0                                         return 0;
2743                                                  }
2744                                                  
2745                                                  # ############################################################################
2746                                                  # Subroutines
2747                                                  # ############################################################################
2748                                                  
2749                                                  # One test is true
2750                                                  sub any {
2751  ***      0                    0                    my ( $table, @tests ) = @_;
2752  ***      0                                         foreach my $test ( @tests ) {
2753  ***      0      0                                     return 1 if $test_for{$test}->($table);
2754                                                     }
2755  ***      0                                         return 0;
2756                                                  }
2757                                                  
2758                                                  # All tests are true
2759                                                  sub all {
2760  ***      0                    0                    my ( $table, @tests ) = @_;
2761  ***      0                                         foreach my $test ( @tests ) {
2762  ***      0      0                                     return 0 unless $test_for{$test}->($table);
2763                                                     }
2764  ***      0                                         return 1;
2765                                                  }
2766                                                  
2767                                                  # Checks the given property of the given table to see if it passes the test
2768                                                  sub test_number {
2769  ***      0                    0                    my ( $table, $prop, $test ) = @_;
2770  ***      0                                         my ($num) = $test =~ m/(\d+)/;
2771  ***      0             0                           return defined $table->{$prop} && (
      ***                    0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
2772                                                           ( $test =~ m/-/  && $table->{$prop} < $num )
2773                                                        || ( $test =~ m/\+/ && $table->{$prop} > $num )
2774                                                        || (                   $table->{$prop} == $num ));
2775                                                  }
2776                                                  
2777                                                  # Checks the given property of the given table to see if it passes the test
2778                                                  sub test_date {
2779  ***      0                    0                    my ( $table, $prop, $test ) = @_;
2780  ***      0             0                           return defined $table->{$prop} && (
      ***                    0                        
      ***                    0                        
      ***                    0                        
      ***                    0                        
2781                                                           ( $o->get($test) =~ m/-/  && $table->{$prop} gt $time_for{$test} )
2782                                                        || ( $o->get($test) =~ m/\+/ && $table->{$prop} lt $time_for{$test} )
2783                                                        || (                            $table->{$prop} eq $time_for{$test} ));
2784                                                  }
2785                                                  
2786                                                  # Checks the given property of the given table to see if it passes the test
2787                                                  sub test_regex {
2788  ***      0                    0                    my ( $table, $prop, $test ) = @_;
2789  ***      0      0                                  if ( $o->get('case-insensitive') ) {
2790  ***      0                                            $test = "(?i)$test";
2791                                                     }
2792  ***      0             0                           return defined $table->{$prop} && $table->{$prop} =~ m/$test/;
2793                                                  }
2794                                                  
2795                                                  # Does string-interpolation and stuff.  Returns the string and a list of the
2796                                                  # properties that go into the resulting placeholders.
2797                                                  sub interpolate {
2798  ***      0                    0                    my ( $str ) = @_;
2799  ***      0                                         my @arg_names;
2800                                                  
2801                                                     # Replace % directives
2802  ***      0      0      0                           $str =~ s/%(.)/(exists $arg_for{$1} && push @arg_names, $arg_for{$1} ) ? '\%s' : "$1"/xge;
      ***      0                                      
2803                                                  
2804                                                     # Get Perl to interpolate escape sequences
2805  ***      0                                         $str =~ s/(?<!\\)"/\\"/g;
2806  ***      0                                         $str = eval qq{"$str"};
2807  ***      0                                         return ( $str, \@arg_names );
2808                                                  }
2809                                                  
2810                                                  sub expand {
2811  ***      0                    0                    my ( $test ) = @_;
2812  ***      0                                         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
2813  ***      0                                         my ($pre, $num, $factor) = $test =~ m/([+-])?(\d+)([kMG])?/;
2814  ***      0      0                                  if ( $factor ) {
2815  ***      0                                            $num *= $factor_for{$factor};
2816                                                     }
2817  ***      0                                         return "$pre$num";
2818                                                  }
2819                                                  
2820                                                  sub _d {
2821  ***      0                    0                    my ($package, undef, $line) = caller 0;
2822  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2823  ***      0                                              map { defined $_ ? $_ : 'undef' }
2824                                                          @_;
2825  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2826                                                  }
2827                                                  
2828                                                  # ############################################################################
2829                                                  # Run the program.
2830                                                  # ############################################################################
2831                                                  if ( !caller ) { exit main(@ARGV); }
2832                                                  
2833                                                  1; # Because this is a module as well as a script.
2834                                                  
2835                                                  # ############################################################################
2836                                                  # Documentation
2837                                                  # ############################################################################
2838                                                  
2839                                                  =pod
2840                                                  
2841                                                  =head1 NAME
2842                                                  
2843                                                  mk-find - Find MySQL tables and execute actions, like GNU find.
2844                                                  
2845                                                  =head1 SYNOPSIS
2846                                                  
2847                                                  Find all tables created more than a day ago, which use the MyISAM engine, and
2848                                                  print their names:
2849                                                  
2850                                                    mk-find --ctime +1 --engine MyISAM
2851                                                  
2852                                                  Find InnoDB tables that haven't been updated in a month, and convert them to
2853                                                  MyISAM storage engine (data warehousing, anyone?):
2854                                                  
2855                                                    mk-find --mtime +30 --engine InnoDB --exec "ALTER TABLE %D.%N ENGINE=MyISAM"
2856                                                  
2857                                                  Find tables created by a process that no longer exists, following the
2858                                                  name_sid_pid naming convention, and remove them.
2859                                                  
2860                                                    mk-find --connection-id '\D_\d+_(\d+)$' --server-id '\D_(\d+)_\d+$' --exec-plus "DROP TABLE %s"
2861                                                  
2862                                                  Find empty tables in the test and junk databases, and delete them:
2863                                                  
2864                                                    mk-find --empty junk test --exec-plus "DROP TABLE %s"
2865                                                  
2866                                                  Find tables more than five gigabytes in total size:
2867                                                  
2868                                                    mk-find --tablesize +5G
2869                                                  
2870                                                  Find all tables and print their total data and index size, and sort largest
2871                                                  tables first (sort is a different program, by the way).
2872                                                  
2873                                                    mk-find --printf "%T\t%D.%N\n" | sort -rn
2874                                                  
2875                                                  As above, but this time, insert the data back into the database for posterity:
2876                                                  
2877                                                    mk-find --noquote --exec "INSERT INTO sysdata.tblsize(db, tbl, size) VALUES('%D', '%N', %T)"
2878                                                  
2879                                                  =head1 RISKS
2880                                                  
2881                                                  The following section is included to inform users about the potential risks,
2882                                                  whether known or unknown, of using this tool.  The two main categories of risks
2883                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
2884                                                  tools) and those created by bugs.
2885                                                  
2886                                                  mk-find only reads and prints information by default, but L<"--exec"> and
2887                                                  L<"--exec-plus"> can execute user-defined SQL.  You should be as careful with it
2888                                                  as you are with any command-line tool that can execute queries against your
2889                                                  database.
2890                                                  
2891                                                  At the time of this release, we know of no bugs that could cause serious harm to
2892                                                  users.
2893                                                  
2894                                                  The authoritative source for updated information is always the online issue
2895                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
2896                                                  see a list of such issues at the following URL:
2897                                                  L<http://www.maatkit.org/bugs/mk-find>.
2898                                                  
2899                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
2900                                                  
2901                                                  =head1 DESCRIPTION
2902                                                  
2903                                                  mk-find looks for MySQL tables that pass the tests you specify, and executes
2904                                                  the actions you specify.  The default action is to print the database and table
2905                                                  name to STDOUT.
2906                                                  
2907                                                  mk-find is simpler than GNU find.  It doesn't allow you to specify
2908                                                  complicated expressions on the command line.
2909                                                  
2910                                                  mk-find uses SHOW TABLES when possible, and SHOW TABLE STATUS when needed.
2911                                                  
2912                                                  =head1 OPTION TYPES
2913                                                  
2914                                                  There are three types of options: normal options, which determine some behavior
2915                                                  or setting; tests, which determine whether a table should be included in the
2916                                                  list of tables found; and actions, which do something to the tables mk-find
2917                                                  finds.
2918                                                  
2919                                                  mk-find uses standard Getopt::Long option parsing, so you should use double
2920                                                  dashes in front of long option names, unlike GNU find.
2921                                                  
2922                                                  =head1 OPTIONS
2923                                                  
2924                                                  =over
2925                                                  
2926                                                  =item --ask-pass
2927                                                  
2928                                                  Prompt for a password when connecting to MySQL.
2929                                                  
2930                                                  =item --case-insensitive
2931                                                  
2932                                                  Specifies that all regular expression searches are case-insensitive.
2933                                                  
2934                                                  =item --charset
2935                                                  
2936                                                  short form: -A; type: string
2937                                                  
2938                                                  Default character set.  If the value is utf8, sets Perl's binmode on
2939                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and runs SET
2940                                                  NAMES UTF8 after connecting to MySQL.  Any other value sets binmode on STDOUT
2941                                                  without the utf8 layer, and runs SET NAMES after connecting to MySQL.
2942                                                  
2943                                                  =item --config
2944                                                  
2945                                                  type: Array
2946                                                  
2947                                                  Read this comma-separated list of config files; if specified, this must be the
2948                                                  first option on the command line.
2949                                                  
2950                                                  =item --day-start
2951                                                  
2952                                                  Measure times (for L<"--mmin">, etc) from the beginning of today rather than
2953                                                  from the current time.
2954                                                  
2955                                                  =item --defaults-file
2956                                                  
2957                                                  short form: -F; type: string
2958                                                  
2959                                                  Only read mysql options from the given file.  You must give an absolute
2960                                                  pathname.
2961                                                  
2962                                                  =item --help
2963                                                  
2964                                                  Show help and exit.
2965                                                  
2966                                                  =item --host
2967                                                  
2968                                                  short form: -h; type: string
2969                                                  
2970                                                  Connect to host.
2971                                                  
2972                                                  =item --or
2973                                                  
2974                                                  Combine tests with OR, not AND.
2975                                                  
2976                                                  By default, tests are evaluated as though there were an AND between them.  This
2977                                                  option switches it to OR.
2978                                                  
2979                                                  Option parsing is not implemented by mk-find itself, so you cannot specify
2980                                                  complicated expressions with parentheses and mixtures of OR and AND.
2981                                                  
2982                                                  =item --password
2983                                                  
2984                                                  short form: -p; type: string
2985                                                  
2986                                                  Password to use when connecting.
2987                                                  
2988                                                  =item --pid
2989                                                  
2990                                                  type: string
2991                                                  
2992                                                  Create the given PID file.  The file contains the process ID of the script.
2993                                                  The PID file is removed when the script exits.  Before starting, the script
2994                                                  checks if the PID file already exists.  If it does not, then the script creates
2995                                                  and writes its own PID to it.  If it does, then the script checks the following:
2996                                                  if the file contains a PID and a process is running with that PID, then
2997                                                  the script dies; or, if there is no process running with that PID, then the
2998                                                  script overwrites the file with its own PID and starts; else, if the file
2999                                                  contains no PID, then the script dies.
3000                                                  
3001                                                  =item --port
3002                                                  
3003                                                  short form: -P; type: int
3004                                                  
3005                                                  Port number to use for connection.
3006                                                  
3007                                                  =item --[no]quote
3008                                                  
3009                                                  default: yes
3010                                                  
3011                                                  Quotes MySQL identifier names with MySQL's standard backtick character.
3012                                                  
3013                                                  Quoting happens after tests are run, and before actions are run.
3014                                                  
3015                                                  =item --set-vars
3016                                                  
3017                                                  type: string; default: wait_timeout=10000
3018                                                  
3019                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this string
3020                                                  will be appended to SET and executed.
3021                                                  
3022                                                  =item --socket
3023                                                  
3024                                                  short form: -S; type: string
3025                                                  
3026                                                  Socket file to use for connection.
3027                                                  
3028                                                  =item --user
3029                                                  
3030                                                  short form: -u; type: string
3031                                                  
3032                                                  User for login if not current user.
3033                                                  
3034                                                  =item --version
3035                                                  
3036                                                  Show version and exit.
3037                                                  
3038                                                  =back
3039                                                  
3040                                                  =head2 TESTS
3041                                                  
3042                                                  Most tests check some criterion against a column of SHOW TABLE STATUS output.
3043                                                  Numeric arguments can be specified as +n for greater than n, -n for less than n,
3044                                                  and n for exactly n.  All numeric options can take an optional suffix multiplier
3045                                                  of k, M or G (1_024, 1_048_576, and 1_073_741_824 respectively).  All patterns
3046                                                  are Perl regular expressions (see 'man perlre') unless specified as SQL LIKE
3047                                                  patterns.
3048                                                  
3049                                                  Dates and times are all measured relative to the same instant, when mk-find
3050                                                  first asks the database server what time it is.  All date and time manipulation
3051                                                  is done in SQL, so if you say to find tables modified 5 days ago, that
3052                                                  translates to SELECT DATE_SUB(CURRENT_TIMESTAMP, INTERVAL 5 DAY).  If you
3053                                                  specify L<"--day-start">, if course it's relative to CURRENT_DATE instead.
3054                                                  
3055                                                  However, table sizes and other metrics are not consistent at an instant in
3056                                                  time.  It can take some time for MySQL to process all the SHOW queries, and
3057                                                  mk-find can't do anything about that.  These measurements are as of the
3058                                                  time they're taken.
3059                                                  
3060                                                  If you need some test that's not in this list, file a bug report and I'll
3061                                                  enhance mk-find for you.  It's really easy.
3062                                                  
3063                                                  =over
3064                                                  
3065                                                  =item --autoinc
3066                                                  
3067                                                  type: string; group: Tests
3068                                                  
3069                                                  Table's next AUTO_INCREMENT is n.  This tests the Auto_increment column.
3070                                                  
3071                                                  =item --avgrowlen
3072                                                  
3073                                                  type: size; group: Tests
3074                                                  
3075                                                  Table avg row len is n bytes.  This tests the Avg_row_length column.
3076                                                  
3077                                                  =item --checksum
3078                                                  
3079                                                  type: string; group: Tests
3080                                                  
3081                                                  Table checksum is n.  This tests the Checksum column.
3082                                                  
3083                                                  =item --cmin
3084                                                  
3085                                                  type: size; group: Tests
3086                                                  
3087                                                  Table was created n minutes ago.  This tests the Create_time column.
3088                                                  
3089                                                  =item --collation
3090                                                  
3091                                                  type: string; group: Tests
3092                                                  
3093                                                  Table collation matches pattern.  This tests the Collation column.
3094                                                  
3095                                                  =item --column-name
3096                                                  
3097                                                  type: string; group: Tests
3098                                                  
3099                                                  A column name in the table matches pattern.
3100                                                  
3101                                                  =item --comment
3102                                                  
3103                                                  type: string; group: Tests
3104                                                  
3105                                                  Table comment matches pattern.  This tests the Comment column.
3106                                                  
3107                                                  =item --connection-id
3108                                                  
3109                                                  type: string; group: Tests
3110                                                  
3111                                                  Table name has nonexistent MySQL connection ID.  This tests the table name for
3112                                                  a pattern.  The argument to this test must be a Perl regular expression that
3113                                                  captures digits like this: (\d+).  If the table name matches the pattern,
3114                                                  these captured digits are taken to be the MySQL connection ID of some process.
3115                                                  If the connection doesn't exist according to SHOW FULL PROCESSLIST, the test
3116                                                  returns true.  If the connection ID is greater than mk-find's own
3117                                                  connection ID, the test returns false for safety.
3118                                                  
3119                                                  Why would you want to do this?  If you use MySQL statement-based replication,
3120                                                  you probably know the trouble temporary tables can cause.  You might choose to
3121                                                  work around this by creating real tables with unique names, instead of
3122                                                  temporary tables.  One way to do this is to append your connection ID to the
3123                                                  end of the table, thusly: scratch_table_12345.  This assures the table name is
3124                                                  unique and lets you have a way to find which connection it was associated
3125                                                  with.  And perhaps most importantly, if the connection no longer exists, you
3126                                                  can assume the connection died without cleaning up its tables, and this table
3127                                                  is a candidate for removal.
3128                                                  
3129                                                  This is how I manage scratch tables, and that's why I included this test in
3130                                                  mk-find.
3131                                                  
3132                                                  The argument I use to L<"--connection-id"> is "\D_(\d+)$".  That finds tables
3133                                                  with a series of numbers at the end, preceded by an underscore and some
3134                                                  non-number character (the latter criterion prevents me from examining tables
3135                                                  with a date at the end, which people tend to do: baron_scratch_2007_05_07 for
3136                                                  example).  It's better to keep the scratch tables separate of course.
3137                                                  
3138                                                  If you do this, make sure the user mk-find runs as has the PROCESS privilege!
3139                                                  Otherwise it will only see connections from the same user, and might think some
3140                                                  tables are ready to remove when they're still in use.  For safety, mk-find
3141                                                  checks this for you.
3142                                                  
3143                                                  See also L<"--server-id">.
3144                                                  
3145                                                  =item --createopts
3146                                                  
3147                                                  type: string; group: Tests
3148                                                  
3149                                                  Table create option matches pattern.  This tests the Create_options column.
3150                                                  
3151                                                  =item --ctime
3152                                                  
3153                                                  type: size; group: Tests
3154                                                  
3155                                                  Table was created n days ago.  This tests the Create_time column.
3156                                                  
3157                                                  =item --datafree
3158                                                  
3159                                                  type: size; group: Tests
3160                                                  
3161                                                  Table has n bytes of free space.  This tests the Data_free column.
3162                                                  
3163                                                  =item --datasize
3164                                                  
3165                                                  type: size; group: Tests
3166                                                  
3167                                                  Table data uses n bytes of space.  This tests the Data_length column.
3168                                                  
3169                                                  =item --dblike
3170                                                  
3171                                                  type: string; group: Tests
3172                                                  
3173                                                  Database name matches SQL LIKE pattern.
3174                                                  
3175                                                  =item --dbregex
3176                                                  
3177                                                  type: string; group: Tests
3178                                                  
3179                                                  Database name matches this pattern.
3180                                                  
3181                                                  =item --empty
3182                                                  
3183                                                  group: Tests
3184                                                  
3185                                                  Table has no rows.  This tests the Rows column.
3186                                                  
3187                                                  =item --engine
3188                                                  
3189                                                  type: string; group: Tests
3190                                                  
3191                                                  Table storage engine matches this pattern.  This tests the Engine column, or in
3192                                                  earlier versions of MySQL, the Type column.
3193                                                  
3194                                                  =item --function
3195                                                  
3196                                                  type: string; group: Tests
3197                                                  
3198                                                  Function definition matches pattern.
3199                                                  
3200                                                  =item --indexsize
3201                                                  
3202                                                  type: size; group: Tests
3203                                                  
3204                                                  Table indexes use n bytes of space.  This tests the Index_length column.
3205                                                  
3206                                                  =item --kmin
3207                                                  
3208                                                  type: size; group: Tests
3209                                                  
3210                                                  Table was checked n minutes ago.  This tests the Check_time column.
3211                                                  
3212                                                  =item --ktime
3213                                                  
3214                                                  type: size; group: Tests
3215                                                  
3216                                                  Table was checked n days ago.  This tests the Check_time column.
3217                                                  
3218                                                  =item --mmin
3219                                                  
3220                                                  type: size; group: Tests
3221                                                  
3222                                                  Table was last modified n minutes ago.  This tests the Update_time column.
3223                                                  
3224                                                  =item --mtime
3225                                                  
3226                                                  type: size; group: Tests
3227                                                  
3228                                                  Table was last modified n days ago.  This tests the Update_time column.
3229                                                  
3230                                                  =item --procedure
3231                                                  
3232                                                  type: string; group: Tests
3233                                                  
3234                                                  Procedure definition matches pattern.
3235                                                  
3236                                                  =item --rowformat
3237                                                  
3238                                                  type: string; group: Tests
3239                                                  
3240                                                  Table row format matches pattern.  This tests the Row_format column.
3241                                                  
3242                                                  =item --rows
3243                                                  
3244                                                  type: size; group: Tests
3245                                                  
3246                                                  Table has n rows.  This tests the Rows column.
3247                                                  
3248                                                  =item --server-id
3249                                                  
3250                                                  type: string; group: Tests
3251                                                  
3252                                                  Table name contains the server ID.  If you create temporary tables with the
3253                                                  naming convention explained in L<"--connection-id">, but also add the server ID of the
3254                                                  server on which the tables are created, then you can use this pattern match to
3255                                                  ensure tables are dropped only on the server they're created on.  This prevents
3256                                                  a table from being accidentally dropped on a slave while it's in use (provided
3257                                                  that your server IDs are all unique, which they should be for replication to
3258                                                  work).
3259                                                  
3260                                                  For example, on the master (server ID 22) you create a table called
3261                                                  scratch_table_22_12345.  If you see this table on the slave (server ID 23), you
3262                                                  might think it can be dropped safely if there's no such connection 12345.  But
3263                                                  if you also force the name to match the server ID with C<--server-id '\D_(\d+)_\d+$'>,
3264                                                  the table won't be dropped on the slave.
3265                                                  
3266                                                  =item --tablesize
3267                                                  
3268                                                  type: size; group: Tests
3269                                                  
3270                                                  Table uses n bytes of space.  This tests the sum of the Data_length and
3271                                                  Index_length columns.
3272                                                  
3273                                                  =item --tbllike
3274                                                  
3275                                                  type: string; group: Tests
3276                                                  
3277                                                  Table name matches SQL LIKE pattern.
3278                                                  
3279                                                  =item --tblregex
3280                                                  
3281                                                  type: string; group: Tests
3282                                                  
3283                                                  Table name matches this pattern.
3284                                                  
3285                                                  =item --tblversion
3286                                                  
3287                                                  type: size; group: Tests
3288                                                  
3289                                                  Table version is n.  This tests the Version column.
3290                                                  
3291                                                  =item --trigger
3292                                                  
3293                                                  type: string; group: Tests
3294                                                  
3295                                                  Trigger action statement matches pattern.
3296                                                  
3297                                                  =item --trigger-table
3298                                                  
3299                                                  type: string; group: Tests
3300                                                  
3301                                                  L<"--trigger"> is defined on table matching pattern.
3302                                                  
3303                                                  =item --view
3304                                                  
3305                                                  type: string; group: Tests
3306                                                  
3307                                                  CREATE VIEW matches this pattern.
3308                                                  
3309                                                  =back
3310                                                  
3311                                                  =head2 ACTIONS
3312                                                  
3313                                                  The L<"--exec-plus"> action happens after everything else, but otherwise actions
3314                                                  happen in an indeterminate order.  If you need determinism, file a bug report
3315                                                  and I'll add this feature.
3316                                                  
3317                                                  =over
3318                                                  
3319                                                  =item --exec
3320                                                  
3321                                                  type: string; group: Actions
3322                                                  
3323                                                  Execute this SQL with each item found.  The SQL can contain escapes and
3324                                                  formatting directives (see L<"--printf">).
3325                                                  
3326                                                  =item --exec-dsn
3327                                                  
3328                                                  type: string; group: Actions
3329                                                  
3330                                                  Specify a DSN in key-value format to use when executing SQL with L<"--exec"> and
3331                                                  L<"--exec-plus">.  Any values not specified are inherited from command-line
3332                                                  arguments.
3333                                                  
3334                                                  =item --exec-plus
3335                                                  
3336                                                  type: string; group: Actions
3337                                                  
3338                                                  Execute this SQL with all items at once.  This option is unlike L<"--exec">.  There
3339                                                  are no escaping or formatting directives; there is only one special placeholder
3340                                                  for the list of database and table names, %s.  The list of tables found will be
3341                                                  joined together with commas and substituted wherever you place %s.
3342                                                  
3343                                                  You might use this, for example, to drop all the tables you found:
3344                                                  
3345                                                     DROP TABLE %s
3346                                                  
3347                                                  This is sort of like GNU find's "-exec command {} +" syntax.  Only it's not
3348                                                  totally cryptic.  And it doesn't require me to write a command-line parser.
3349                                                  
3350                                                  =item --print
3351                                                  
3352                                                  group: Actions
3353                                                  
3354                                                  Print the database and table name, followed by a newline.  This is the default
3355                                                  action if no other action is specified.
3356                                                  
3357                                                  =item --printf
3358                                                  
3359                                                  type: string; group: Actions
3360                                                  
3361                                                  Print format on the standard output, interpreting '\' escapes and '%'
3362                                                  directives.  Escapes are backslashed characters, like \n and \t.  Perl
3363                                                  interprets these, so you can use any escapes Perl knows about.  Directives are
3364                                                  replaced by %s, and as of this writing, you can't add any special formatting
3365                                                  instructions, like field widths or alignment (though I'm musing over ways to do
3366                                                  that).
3367                                                  
3368                                                  Here is a list of the directives.  Note that most of them simply come from
3369                                                  columns of SHOW TABLE STATUS.  If the column is NULL or doesn't exist, you get
3370                                                  an empty string in the output.  A % character followed by any character not in
3371                                                  the following list is discarded (but the other character is printed).
3372                                                  
3373                                                     CHAR DATA SOURCE        NOTES
3374                                                     ---- ------------------ ------------------------------------------
3375                                                     a    Auto_increment
3376                                                     A    Avg_row_length
3377                                                     c    Checksum
3378                                                     C    Create_time
3379                                                     D    Database           The database name in which the table lives
3380                                                     d    Data_length
3381                                                     E    Engine             In older versions of MySQL, this is Type
3382                                                     F    Data_free
3383                                                     f    Innodb_free        Parsed from the Comment field
3384                                                     I    Index_length
3385                                                     K    Check_time
3386                                                     L    Collation
3387                                                     M    Max_data_length
3388                                                     N    Name
3389                                                     O    Comment
3390                                                     P    Create_options
3391                                                     R    Row_format
3392                                                     S    Rows
3393                                                     T    Table_length       Data_length+Index_length
3394                                                     U    Update_time
3395                                                     V    Version
3396                                                  
3397                                                  =back
3398                                                  
3399                                                  =head1 DOWNLOADING
3400                                                  
3401                                                  You can download Maatkit from Google Code at
3402                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
3403                                                  easily with a command like the following:
3404                                                  
3405                                                     wget http://www.maatkit.org/get/toolname
3406                                                     or
3407                                                     wget http://www.maatkit.org/trunk/toolname
3408                                                  
3409                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
3410                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
3411                                                  needed.  The first URL gets the latest released version of the tool, and the
3412                                                  second gets the latest trunk code from Subversion.
3413                                                  
3414                                                  =head1 ENVIRONMENT
3415                                                  
3416                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
3417                                                  the Maatkit tools:
3418                                                  
3419                                                     MKDEBUG=1 mk-....
3420                                                  
3421                                                  =head1 SYSTEM REQUIREMENTS
3422                                                  
3423                                                  You need the following Perl modules: DBI and DBD::mysql.
3424                                                  
3425                                                  =head1 BUGS
3426                                                  
3427                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-find>.
3428                                                  
3429                                                  Please use Google Code Issues and Groups to report bugs or request support:
3430                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
3431                                                  discuss Maatkit.
3432                                                  
3433                                                  Please include the complete command-line used to reproduce the problem you are
3434                                                  seeing, the version of all MySQL servers involved, the complete output of the
3435                                                  tool when run with L<"--version">, and if possible, debugging output produced by
3436                                                  running with the C<MKDEBUG=1> environment variable.
3437                                                  
3438                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
3439                                                  
3440                                                  This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
3441                                                  Feedback and improvements are welcome (see L<"BUGS">).
3442                                                  
3443                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
3444                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
3445                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
3446                                                  
3447                                                  This program is free software; you can redistribute it and/or modify it under
3448                                                  the terms of the GNU General Public License as published by the Free Software
3449                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
3450                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
3451                                                  licenses.
3452                                                  
3453                                                  You should have received a copy of the GNU General Public License along with
3454                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
3455                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
3456                                                  
3457                                                  =head1 AUTHOR
3458                                                  
3459                                                  Baron Schwartz
3460                                                  
3461                                                  =head1 ABOUT MAATKIT
3462                                                  
3463                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
3464                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
3465                                                  code contributors.  Both are employed by Percona.  Financial support for
3466                                                  Maatkit development is primarily provided by Percona and its clients. 
3467                                                  
3468                                                  =head1 VERSION
3469                                                  
3470                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5425 $.
3471                                                  
3472                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
104   ***     50      0      3   if (@_ > 2)
113   ***     50      0      1   if (not $dsn)
125   ***     50      4      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
137   ***     50      0      8   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
143          100      4      4   if (not defined $final_props{$key})
150   ***     50      0      4   unless exists $opts{$key}
153   ***     50      0      1   if (my $required = $self->prop('required'))
155   ***      0      0      0   unless $final_props{$key}
164   ***      0      0      0   unless ref $o eq 'OptionParser'
167   ***      0      0      0   if $o->has($_)
177   ***      0      0      0   unless ref $dsn
178   ***      0      0      0   $_ eq 'p' ? :
179   ***      0      0      0   if defined $$dsn{$_}
192   ***      0      0      0   $opts{$key}{'copy'} ? :
206   ***     50      0      1   if ($driver eq 'Pg') { }
238   ***     50      0      1   $cxn_string =~ /charset=utf8/ ? :
247   ***     50      0      1   if (not $have_dbi)
266   ***     50      1      0   if ($cxn_string =~ /mysql/i)
274   ***     50      0      1   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
279   ***      0      0      0   if ($charset eq 'utf8') { }
280   ***      0      0      0   unless binmode STDOUT, ':utf8'
284   ***      0      0      0   unless binmode STDOUT
288   ***     50      0      1   if ($self->prop('set-vars'))
295   ***     50      0      1   if (not $dbh and $EVAL_ERROR)
297   ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
310   ***      0      0      0   if (not $tries)
332   ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
349   ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
359   ***      0      0      0   unless $dsn_1
360   ***      0      0      0   unless $dsn_2
364   ***      0      0      0   if ($args{'overwrite'}) { }
365   ***      0      0      0   defined $$dsn_1{$key} ? :
368   ***      0      0      0   defined $$dsn_2{$key} ? :
377   ***      0      0      0   defined $_ ? :
417   ***      0      0      0   unless $args{$arg}
423   ***      0      0      0   exists $args{'strict'} ? :
466   ***      0      0      0   unless open my $fh, '<', $file
486   ***      0      0      0   unless $para =~ /^=head1 OPTIONS/
491   ***      0      0      0   if $para =~ /^=over/
499   ***      0      0      0   unless $para
502   ***      0      0      0   if (my($option) = $para =~ /^=item --(.*)/)
509   ***      0      0      0   if ($para =~ /: /) { }
513   ***      0      0      0   unless $attributes{$attrib}
517   ***      0      0      0   if ($attribs{'short form'})
533   ***      0      0      0   if $para =~ /^=item/
535   ***      0      0      0   if (my($base_option) = $option =~ /^\[no\](.*)/)
540   ***      0      0      0   $attribs{'short form'} ? :
      ***      0      0      0   $attribs{'negatable'} ? :
      ***      0      0      0   $attribs{'cumulative'} ? :
      ***      0      0      0   $attribs{'type'} ? :
      ***      0      0      0   $attribs{'default'} ? :
      ***      0      0      0   $attribs{'group'} ? :
552   ***      0      0      0   unless $para
555   ***      0      0      0   if ($para =~ /^=head1/)
559   ***      0      0      0   if $para =~ /^=item --/
563   ***      0      0      0   unless @specs
574   ***      0      0      0   if (ref $opt) { }
579   ***      0      0      0   if (not $long)
584   ***      0      0      0   if exists $$self{'opts'}{$long}
587   ***      0      0      0   if (length $long == 1)
592   ***      0      0      0   if ($short) { }
593   ***      0      0      0   if exists $$self{'short_opts'}{$short}
602   ***      0      0      0   $$opt{'spec'} =~ /!/ ? :
603   ***      0      0      0   $$opt{'spec'} =~ /\+/ ? :
604   ***      0      0      0   $$opt{'desc'} =~ /required/ ? :
616   ***      0      0      0   if ($type and $type eq 'd' and not $$self{'dp'})
621   ***      0      0      0   if $type and $type =~ /[HhAadzm]/
623   ***      0      0      0   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
624   ***      0      0      0   defined $def ? :
628   ***      0      0      0   if ($long eq 'config')
632   ***      0      0      0   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
645   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
650   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
655   ***      0      0      0   if ($opt =~ /default to/)
660   ***      0      0      0   if ($opt =~ /restricted to option groups/)
670   ***      0      0      0   unless $rule_ok
687   ***      0      0      0   unless exists $$self{'opts'}{$long}
711   ***      0      0      0   unless exists $$self{'opts'}{$long}
731   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***      0      0      0   exists $$self{'opts'}{$opt} ? :
736   ***      0      0      0   if ($$opt{'is_cumulative'}) { }
751   ***      0      0      0   $$self{'opts'}{$long}{'is_cumulative'} ? :
      ***      0      0      0   exists $$self{'defaults'}{$long} ? :
760   ***      0      0      0   if (@ARGV and $ARGV[0] eq '--config')
764   ***      0      0      0   if ($self->has('config'))
770   ***      0      0      0   if ($EVAL_ERROR)
771   ***      0      0      0   $self->got('config') ? :
786   ***      0      0      0   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
789   ***      0      0      0   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
790   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
796   ***      0      0      0   if (@ARGV and $$self{'strict'})
802   ***      0      0      0   if (@set > 1)
813   ***      0      0      0   if (@set == 0)
823   ***      0      0      0   if ($$opt{'got'}) { }
      ***      0      0      0   elsif ($$opt{'is_required'}) { }
824   ***      0      0      0   if (exists $$self{'disables'}{$long})
831   ***      0      0      0   if (exists $$self{'allowed_groups'}{$long})
843   ***      0      0      0   if $restricted_opt eq $long
844   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
849   ***      0      0      0   if (@restricted_opts)
851   ***      0      0      0   if (@restricted_opts == 1) { }
880   ***      0      0      0   unless $opt and $$opt{'type'}
883   ***      0      0      0   if ($val and $$opt{'type'} eq 'm') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'd') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'z') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
886   ***      0      0      0   if (not $suffix)
892   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
893   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
908   ***      0      0      0   if ($from_key)
919   ***      0      0      0   if (defined $num) { }
920   ***      0      0      0   if ($factor)
947   ***      0      0      0   length $opt == 1 ? :
948   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
955   ***      0      0      0   length $opt == 1 ? :
956   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
963   ***      0      0      0   length $opt == 1 ? :
964   ***      0      0      0   defined $long ? :
969   ***      0      0      0   length $opt == 1 ? :
970   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
1004  ***      0      0      0   if ($$self{'opts'}{'help'}{'got'}) { }
      ***      0      0      0   elsif (scalar @{$$self{'errors'};}) { }
1005  ***      0      0      0   unless print $self->print_usage
1009  ***      0      0      0   unless print $self->print_errors
1018  ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
1027  ***      0      0      0   unless $$self{'got_opts'}
1030  ***      0      0      0   $$_{'is_negatable'} ? :
1034  ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
1050  ***      0      0      0   $group eq 'default' ? :
1056  ***      0      0      0   $$opt{'is_negatable'} ? :
1059  ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
1068  ***      0      0      0   if ($short) { }
1077  ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
1081  ***      0      0      0   if ($$self{'dp'})
1089  ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
1101  ***      0      0      0   if ref $_[0] eq 'OptionParser'
1104  ***      0      0      0   unless print $prompt
1112  ***      0      0      0   unless print "\n"
1115  ***      0      0      0   if ($EVAL_ERROR)
1137  ***      0      0      0   unless open my $fh, '<', $filename
1145  ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
1148  ***      0      0      0   if ($line eq '--')
1153  ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
1171  ***      0      0      0   unless open my $fh, '<', $file
1175  ***      0      0      0   unless $para =~ /^=pod$/m
1179  ***      0      0      0   unless $para =~ /$regex/
1184  ***      0      0      0   unless close $fh
1198  ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
1213  ***      0      0      0   defined $_ ? :
1253  ***      0      0      0   unless defined $val
1254  ***      0      0      0   if $val eq ''
1256  ***      0      0      0   if (not defined $is_numeric)
1257  ***      0      0      0   $val =~ /^0|\D/ ? :
1260  ***      0      0      0   if $is_numeric
1270  ***      0      0      0   if (not $tbl)
1279  ***      0      0      0   unless $like
1316  ***      0      0      0   if (not $$self{$dbh})
1320  ***      0      0      0   $$self{$dbh} ge $self->parse($target) ? :
1327  ***      0      0      0   defined $_ ? :
1359  ***      0      0      0   unless $args{$arg}
1368  ***      0      0      0   unless $ddl
1369  ***      0      0      0   if (ref $ddl eq 'ARRAY')
1370  ***      0      0      0   if (lc $$ddl[0] eq 'table') { }
1380  ***      0      0      0   if (not $ddl =~ /CREATE (?:TEMPORARY )?TABLE `/)
1386  ***      0      0      0   if $name
1404  ***      0      0      0   unless $type
1406  ***      0      0      0   if ($type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/)
1410  ***      0      0      0   if (not $def =~ /NOT NULL/)
1414  ***      0      0      0   $def =~ /AUTO_INCREMENT/i ? :
1445  ***      0      0      0   unless ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
1459  ***      0      0      0   if ($index)
1462  ***      0      0      0   if (not $best)
1463  ***      0      0      0   if ($index) { }
1476  ***      0      0      0   unless $where
1482  ***      0      0      0   if ($$expl{'possible_keys'}) { }
1486  ***      0      0      0   if ($$expl{'key'})
1506  ***      0      0      0   unless $args{$arg}
1520  ***      0      0      0   if ($EVAL_ERROR)
1524  ***      0      0      0   if (not $$row[0] or $$row[0] ne $tbl)
1530  ***      0      0      0   unless $args{'all_privs'}
1537  ***      0      0      0   if ($EVAL_ERROR)
1541  ***      0      0      0   if (not scalar keys %$row)
1552  ***      0      0      0   $EVAL_ERROR ? :
1557  ***      0      0      0   if (not $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete)
1583  ***      0      0      0   if $key =~ /FOREIGN/
1588  ***      0      0      0   if (not $engine =~ /MEMORY|HEAP/)
1595  ***      0      0      0   if ($$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i)
1602  ***      0      0      0   $key =~ /PRIMARY|UNIQUE/ ? :
1626  ***      0      0      0   if ($engine =~ /InnoDB/i and not $clustered_key)
1628  ***      0      0      0   if ($$this_key{'name'} eq 'PRIMARY') { }
      ***      0      0      0   elsif ($$this_key{'is_unique'} and not $$this_key{'is_nullable'}) { }
1652  ***      0      0      0   if (not $parent =~ /\./ and $$opts{'database'})
1681  ***      0      0      0   if (($$tbl_struct{'engine'} || '') =~ /InnoDB/i) { }
1695  ***      0      0      0   if (@sec_indexes)
1712  ***      0      0      0   defined $_ ? :
1762  ***      0      0      0   unless defined $args{'cache'}
1770  ***      0      0      0   if ($what eq 'table') { }
      ***      0      0      0   elsif ($what eq 'triggers') { }
      ***      0      0      0   elsif ($what eq 'view') { }
1772  ***      0      0      0   unless $ddl
1773  ***      0      0      0   if ($$ddl[0] eq 'table') { }
1787  ***      0      0      0   if ($trgs and @$trgs) { }
1790  ***      0      0      0   if ($$trg{'sql_mode'})
1794  ***      0      0      0   if ($$trg{'definer'})
1826  ***      0      0      0   if (not $new)
1833  ***      0      0      0   if ($curr and $new and $curr eq $new)
1845  ***      0      0      0   if (not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl})
1858  ***      0      0      0   if ($EVAL_ERROR)
1868  ***      0      0      0   if ($key) { }
1884  ***      0      0      0   if (not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl})
1914  ***      0      0      0   if (not $$self{'cache'} or not $$self{'triggers'}{$db})
1927  ***      0      0      0   if ($sth->rows)
1940  ***      0      0      0   if ($tbl)
1948  ***      0      0      0   if (not $$self{'cache'} or not $$self{'databases'} or $like)
1951  ***      0      0      0   if ($like)
1959  ***      0      0      0   unless $like
1967  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_status'}{$db} or $like)
1970  ***      0      0      0   if ($like)
1985  ***      0      0      0   unless $like
1993  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_list'}{$db} or $like)
1996  ***      0      0      0   if ($like)
2004  ***      0      0      0   ($$_[1] || '') eq 'VIEW' ? :
2011  ***      0      0      0   unless $like
2019  ***      0      0      0   defined $_ ? :
2048  ***      0      0      0   unless $args{$arg}
2051  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
2067  ***      0      0      0   unless defined(my $pid = fork)
2068  ***      0      0      0   if ($pid)
2075  ***      0      0      0   unless POSIX::setsid()
2076  ***      0      0      0   unless chdir '/'
2082  ***      0      0      0   if (-t STDIN)
2084  ***      0      0      0   unless open STDIN, '/dev/null'
2088  ***      0      0      0   if ($$self{'log_file'}) { }
2090  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
2094  ***      0      0      0   unless open STDERR, '>&STDOUT'
2098  ***      0      0      0   if (-t STDOUT)
2100  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
2103  ***      0      0      0   if (-t STDERR)
2105  ***      0      0      0   unless open STDERR, '>', '/dev/null'
2116  ***      0      0      0   $self ? :
2118  ***      0      0      0   if ($PID_file and -f $PID_file) { }
2121  ***      0      0      0   if $EVAL_ERROR
2123  ***      0      0      0   if ($pid) { }
2125  ***      0      0      0   if ($pid_is_alive) { }
2147  ***      0      0      0   if (exists $$self{'child'})
2159  ***      0      0      0   if (not $PID_file)
2166  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
2168  ***      0      0      0   unless print $PID_FH $PID
2170  ***      0      0      0   unless close $PID_FH
2179  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
2180  ***      0      0      0   unless unlink $$self{'PID_file'}
2192  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
2198  ***      0      0      0   defined $_ ? :
2493  ***      0      0      0   if ($o->get('connection-id') and not $o->get('connection-id') =~ /\(\\d\+\)/)
2498  ***      0      0      0   if ($o->get('server-id') and not $o->get('server-id') =~ /\(\\d\+\)/)
2512  ***      0      0      0   unless $o->get($thing)
2515  ***      0      0      0   if (grep {not $_ =~ /^(Database|Name)$/;} @$arg_names)
2523  ***      0      0      0   if ($need_table_struct)
2532  ***      0      0      0   if ($o->get('pid'))
2545  ***      0      0      0   if (not $o->get('password') and $o->get('ask-pass'))
2552  ***      0      0      0   if ($o->get('exec-dsn')) { }
2562  ***      0      0      0   if (not grep {$o->get($_);} 'exec', 'exec-plus', 'print', 'printf')
2572  ***      0      0      0   $o->get('day-start') ? :
2579  ***      0      0      0   $option =~ /min/ ? :
2585  ***      0      0      0   if ($o->get('connection-id'))
2590  ***      0      0      0   if (not $proc)
2600  ***      0      0      0   if $need_stored_code
2609  ***      0      0      0   $o->get('dblike') ? :
      ***      0      0      0   @ARGV ? :
2614  ***      0      0      0   if $database =~ /^(?:information_schema|lost\+found)$/im
2616  ***      0      0      0   $showstat ? :
2617  ***      0      0      0   $o->get('tbllike') ? :
2627  ***      0      0      0   if ($o->get('connection-id'))
2635  ***      0      0      0   if ($showstat) { }
2639  ***      0      0      0   $ib_free ? :
2648  ***      0      0      0   if ($need_table_struct)
2652  ***      0      0      0   if ($$ddl[0] eq 'table') { }
      ***      0      0      0   elsif ($$ddl[0] eq 'view') { }
2655  ***      0      0      0   if ($EVAL_ERROR)
2666  ***      0      0      0   if ($need_stored_code)
2709  ***      0      0      0   if (@tests) { }
2710  ***      0      0      0   $o->get('or') ? :
2718  ***      0      0      0   if ($o->get('quote'))
2736  ***      0      0      0   if ($o->get('exec-plus'))
2753  ***      0      0      0   if $test_for{$test}($table)
2762  ***      0      0      0   unless $test_for{$test}($table)
2789  ***      0      0      0   if ($o->get('case-insensitive'))
2802  ***      0      0      0   exists $arg_for{$1} && push(@arg_names, $arg_for{$1}) ? :
2814  ***      0      0      0   if ($factor)
2822  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
137   ***     66      4      4      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33      8      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
259   ***     66      1      0      1   not $dbh and $tries--
295   ***     33      1      0      0   not $dbh and $EVAL_ERROR
616   ***      0      0      0      0   $type and $type eq 'd'
      ***      0      0      0      0   $type and $type eq 'd' and not $$self{'dp'}
621   ***      0      0      0      0   $type and $type =~ /[HhAadzm]/
760   ***      0      0      0      0   @ARGV and $ARGV[0] eq '--config'
789   ***      0      0      0      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
796   ***      0      0      0      0   @ARGV and $$self{'strict'}
880   ***      0      0      0      0   $opt and $$opt{'type'}
883   ***      0      0      0      0   $val and $$opt{'type'} eq 'm'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'd'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'z'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'a'
948   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
956   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
970   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
1059  ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
1153  ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1557  ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete
1595  ***      0      0      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000'
      ***      0      0      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i
1626  ***      0      0      0      0   $engine =~ /InnoDB/i and not $clustered_key
1628  ***      0      0      0      0   $$this_key{'is_unique'} and not $$this_key{'is_nullable'}
1652  ***      0      0      0      0   not $parent =~ /\./ and $$opts{'database'}
1787  ***      0      0      0      0   $trgs and @$trgs
1833  ***      0      0      0      0   $curr and $new
      ***      0      0      0      0   $curr and $new and $curr eq $new
2118  ***      0      0      0      0   $PID_file and -f $PID_file
2179  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
2493  ***      0      0      0      0   $o->get('connection-id') and not $o->get('connection-id') =~ /\(\\d\+\)/
2498  ***      0      0      0      0   $o->get('server-id') and not $o->get('server-id') =~ /\(\\d\+\)/
2545  ***      0      0      0      0   not $o->get('password') and $o->get('ask-pass')
2636  ***      0      0      0      0   $$table{'Comment'} && $$table{'Comment'} =~ /InnoDB free: (\d+) kB/
2771  ***      0      0      0      0   $test =~ /-/ && $$table{$prop} < $num
      ***      0      0      0      0   $test =~ /\+/ && $$table{$prop} > $num
      ***      0      0      0      0   defined $$table{$prop} && ($test =~ /-/ && $$table{$prop} < $num || $test =~ /\+/ && $$table{$prop} > $num || $$table{$prop} == $num)
2780  ***      0      0      0      0   $o->get($test) =~ /-/ && $$table{$prop} gt $time_for{$test}
      ***      0      0      0      0   $o->get($test) =~ /\+/ && $$table{$prop} lt $time_for{$test}
      ***      0      0      0      0   defined $$table{$prop} && ($o->get($test) =~ /-/ && $$table{$prop} gt $time_for{$test} || $o->get($test) =~ /\+/ && $$table{$prop} lt $time_for{$test} || $$table{$prop} eq $time_for{$test})
2792  ***      0      0      0      0   defined $$table{$prop} && $$table{$prop} =~ /$test/
2802  ***      0      0      0      0   exists $arg_for{$1} && push(@arg_names, $arg_for{$1})

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
47    ***     50      0      1   $ENV{'MKDEBUG'} || 0
118   ***     50      0      1   $prev ||= {}
119   ***     50      0      1   $defaults ||= {}
192   ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
205   ***     50      0      1   $self->prop('dbidriver') || ''
209   ***      0      0      0   $$info{'D'} || ''
215   ***     50      0      1   $$info{'D'} || ''
237   ***     50      1      0   $opts ||= {}
332   ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
348   ***      0      0      0   $level ||= 0
349   ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
401   ***     50      0      1   $ENV{'MKDEBUG'} || 0
421   ***      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
423   ***      0      0      0   $args{'prompt'} || '<options>'
      ***      0      0      0   $args{'dp'} || undef
465   ***      0      0      0   $file ||= '/home/daniel/dev/maatkit/mk-find/mk-find'
606   ***      0      0      0   $$opt{'group'} ||= 'default'
888   ***      0      0      0   $s || 's'
897   ***      0      0      0   $prefix || ''
925   ***      0      0      0   $pre || ''
932   ***      0      0      0   $val || ''
935   ***      0      0      0   $val || ''
993   ***      0      0      0   $$self{'description'} || ''
1061  ***      0      0      0   $s ||= 's'
1087  ***      0      0      0   $$opt{'type'} || ''
1235  ***     50      0      1   $ENV{'MKDEBUG'} || 0
1300  ***     50      0      1   $ENV{'MKDEBUG'} || 0
1352  ***     50      0      1   $ENV{'MKDEBUG'} || 0
1571  ***      0      0      0   $engine || undef
1594  ***      0      0      0   $type || $special || 'BTREE'
1681  ***      0      0      0   $$tbl_struct{'engine'} || ''
1683  ***      0      0      0   $clustered_key ||= ''
1734  ***     50      0      1   $ENV{'MKDEBUG'} || 0
2004  ***      0      0      0   $$_[1] || ''
2043  ***     50      0      1   $ENV{'MKDEBUG'} || 0
2222  ***     50      0      1   $ENV{'MKDEBUG'} || 0
2638  ***      0      0      0   $$table{'Index_length'} || 0
      ***      0      0      0   $$table{'Data_length'} || 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
228   ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
229   ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
230   ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
231   ***      0      0      0      0   $$dsn{'u'} ||= $user
232   ***      0      0      0      0   $$dsn{'D'} ||= $db
420   ***      0      0      0      0   $program_name ||= $PROGRAM_NAME
421   ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
883   ***      0      0      0      0   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1445  ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'}
      ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
1524  ***      0      0      0      0   not $$row[0] or $$row[0] ne $tbl
1545  ***      0      0      0      0   $$row{'privileges'} || $$row{'Privileges'}
1594  ***      0      0      0      0   $type || $special
1845  ***      0      0      0      0   not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl}
1884  ***      0      0      0      0   not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl}
1914  ***      0      0      0      0   not $$self{'cache'} or not $$self{'triggers'}{$db}
1948  ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'} or $like
1967  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db} or $like
1981  ***      0      0      0      0   $tbl{'type'} || $tbl{'comment'}
      ***      0      0      0      0   $tbl{'engine'} ||= $tbl{'type'} || $tbl{'comment'}
1993  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db} or $like
2192  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
2572  ***      0      0      0      0   $basetime ||= $dbh->selectcol_arrayref('SELECT ' . ($o->get('day-start') ? 'CURRENT_DATE' : 'CURRENT_TIMESTAMP'))->[0]
2621  ***      0      0      0      0   $o->get('tbllike') || ()
2637  ***      0      0      0      0   $$table{'Engine'} ||= $$table{'Type'}
2771  ***      0      0      0      0   $test =~ /-/ && $$table{$prop} < $num || $test =~ /\+/ && $$table{$prop} > $num
      ***      0      0      0      0   $test =~ /-/ && $$table{$prop} < $num || $test =~ /\+/ && $$table{$prop} > $num || $$table{$prop} == $num
2780  ***      0      0      0      0   $o->get($test) =~ /-/ && $$table{$prop} gt $time_for{$test} || $o->get($test) =~ /\+/ && $$table{$prop} lt $time_for{$test}
      ***      0      0      0      0   $o->get($test) =~ /-/ && $$table{$prop} gt $time_for{$test} || $o->get($test) =~ /\+/ && $$table{$prop} lt $time_for{$test} || $$table{$prop} eq $time_for{$test}


Covered Subroutines
-------------------

Subroutine               Count Location                                     
------------------------ ----- ---------------------------------------------
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:1228
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:1229
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:1233
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:1235
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:1295
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:1296
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:1298
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:1300
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:1344
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:1345
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:1346
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:1347
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:1352
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:1729
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:1730
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:1732
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:1734
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:2037
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:2038
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:2040
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:2041
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:2043
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:2220
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:2222
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:23  
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:24  
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:35  
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:36  
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:37  
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:38  
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:394 
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:395 
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:397 
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:398 
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:399 
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:401 
BEGIN                        1 /home/daniel/dev/maatkit/mk-find/mk-find:47  
get_cxn_params               1 /home/daniel/dev/maatkit/mk-find/mk-find:202 
get_dbh                      1 /home/daniel/dev/maatkit/mk-find/mk-find:236 
new                          1 /home/daniel/dev/maatkit/mk-find/mk-find:50  
parse                        1 /home/daniel/dev/maatkit/mk-find/mk-find:112 
prop                         3 /home/daniel/dev/maatkit/mk-find/mk-find:103 

Uncovered Subroutines
---------------------

Subroutine               Count Location                                     
------------------------ ----- ---------------------------------------------
DESTROY                      0 /home/daniel/dev/maatkit/mk-find/mk-find:2191
__ANON__                     0 /home/daniel/dev/maatkit/mk-find/mk-find:784 
_d                           0 /home/daniel/dev/maatkit/mk-find/mk-find:1212
_d                           0 /home/daniel/dev/maatkit/mk-find/mk-find:1326
_d                           0 /home/daniel/dev/maatkit/mk-find/mk-find:1711
_d                           0 /home/daniel/dev/maatkit/mk-find/mk-find:2018
_d                           0 /home/daniel/dev/maatkit/mk-find/mk-find:2197
_d                           0 /home/daniel/dev/maatkit/mk-find/mk-find:2821
_d                           0 /home/daniel/dev/maatkit/mk-find/mk-find:376 
_get_participants            0 /home/daniel/dev/maatkit/mk-find/mk-find:684 
_make_PID_file               0 /home/daniel/dev/maatkit/mk-find/mk-find:2156
_parse_specs                 0 /home/daniel/dev/maatkit/mk-find/mk-find:570 
_pod_to_specs                0 /home/daniel/dev/maatkit/mk-find/mk-find:464 
_read_config_file            0 /home/daniel/dev/maatkit/mk-find/mk-find:1136
_remove_PID_file             0 /home/daniel/dev/maatkit/mk-find/mk-find:2178
_set_option                  0 /home/daniel/dev/maatkit/mk-find/mk-find:730 
_use_db                      0 /home/daniel/dev/maatkit/mk-find/mk-find:1825
_validate_type               0 /home/daniel/dev/maatkit/mk-find/mk-find:879 
all                          0 /home/daniel/dev/maatkit/mk-find/mk-find:2760
any                          0 /home/daniel/dev/maatkit/mk-find/mk-find:2751
as_string                    0 /home/daniel/dev/maatkit/mk-find/mk-find:176 
check_PID_file               0 /home/daniel/dev/maatkit/mk-find/mk-find:2115
check_table                  0 /home/daniel/dev/maatkit/mk-find/mk-find:1503
clone                        0 /home/daniel/dev/maatkit/mk-find/mk-find:1189
copy                         0 /home/daniel/dev/maatkit/mk-find/mk-find:358 
daemonize                    0 /home/daniel/dev/maatkit/mk-find/mk-find:2064
descr                        0 /home/daniel/dev/maatkit/mk-find/mk-find:992 
disconnect                   0 /home/daniel/dev/maatkit/mk-find/mk-find:341 
dump                         0 /home/daniel/dev/maatkit/mk-find/mk-find:1768
errors                       0 /home/daniel/dev/maatkit/mk-find/mk-find:982 
expand                       0 /home/daniel/dev/maatkit/mk-find/mk-find:2811
fill_in_dsn                  0 /home/daniel/dev/maatkit/mk-find/mk-find:224 
find_best_index              0 /home/daniel/dev/maatkit/mk-find/mk-find:1457
find_possible_keys           0 /home/daniel/dev/maatkit/mk-find/mk-find:1475
get                          0 /home/daniel/dev/maatkit/mk-find/mk-find:946 
get_columns                  0 /home/daniel/dev/maatkit/mk-find/mk-find:1882
get_create_table             0 /home/daniel/dev/maatkit/mk-find/mk-find:1844
get_databases                0 /home/daniel/dev/maatkit/mk-find/mk-find:1947
get_defaults                 0 /home/daniel/dev/maatkit/mk-find/mk-find:720 
get_defaults_files           0 /home/daniel/dev/maatkit/mk-find/mk-find:459 
get_engine                   0 /home/daniel/dev/maatkit/mk-find/mk-find:1568
get_fks                      0 /home/daniel/dev/maatkit/mk-find/mk-find:1642
get_groups                   0 /home/daniel/dev/maatkit/mk-find/mk-find:725 
get_hostname                 0 /home/daniel/dev/maatkit/mk-find/mk-find:331 
get_keys                     0 /home/daniel/dev/maatkit/mk-find/mk-find:1575
get_opts                     0 /home/daniel/dev/maatkit/mk-find/mk-find:747 
get_specs                    0 /home/daniel/dev/maatkit/mk-find/mk-find:452 
get_table_list               0 /home/daniel/dev/maatkit/mk-find/mk-find:1992
get_table_status             0 /home/daniel/dev/maatkit/mk-find/mk-find:1966
get_tmp_table                0 /home/daniel/dev/maatkit/mk-find/mk-find:1902
get_triggers                 0 /home/daniel/dev/maatkit/mk-find/mk-find:1913
got                          0 /home/daniel/dev/maatkit/mk-find/mk-find:954 
has                          0 /home/daniel/dev/maatkit/mk-find/mk-find:962 
interpolate                  0 /home/daniel/dev/maatkit/mk-find/mk-find:2798
literal_like                 0 /home/daniel/dev/maatkit/mk-find/mk-find:1278
main                         0 /home/daniel/dev/maatkit/mk-find/mk-find:2472
make_PID_file                0 /home/daniel/dev/maatkit/mk-find/mk-find:2146
new                          0 /home/daniel/dev/maatkit/mk-find/mk-find:1238
new                          0 /home/daniel/dev/maatkit/mk-find/mk-find:1303
new                          0 /home/daniel/dev/maatkit/mk-find/mk-find:1356
new                          0 /home/daniel/dev/maatkit/mk-find/mk-find:1761
new                          0 /home/daniel/dev/maatkit/mk-find/mk-find:2046
new                          0 /home/daniel/dev/maatkit/mk-find/mk-find:415 
opts                         0 /home/daniel/dev/maatkit/mk-find/mk-find:696 
parse                        0 /home/daniel/dev/maatkit/mk-find/mk-find:1308
parse                        0 /home/daniel/dev/maatkit/mk-find/mk-find:1367
parse_options                0 /home/daniel/dev/maatkit/mk-find/mk-find:163 
print_active_handles         0 /home/daniel/dev/maatkit/mk-find/mk-find:347 
print_errors                 0 /home/daniel/dev/maatkit/mk-find/mk-find:1016
print_usage                  0 /home/daniel/dev/maatkit/mk-find/mk-find:1026
prompt                       0 /home/daniel/dev/maatkit/mk-find/mk-find:987 
prompt_noecho                0 /home/daniel/dev/maatkit/mk-find/mk-find:1101
quote                        0 /home/daniel/dev/maatkit/mk-find/mk-find:1243
quote_val                    0 /home/daniel/dev/maatkit/mk-find/mk-find:1251
read_para_after              0 /home/daniel/dev/maatkit/mk-find/mk-find:1170
remove_auto_increment        0 /home/daniel/dev/maatkit/mk-find/mk-find:1671
remove_secondary_indexes     0 /home/daniel/dev/maatkit/mk-find/mk-find:1677
save_error                   0 /home/daniel/dev/maatkit/mk-find/mk-find:977 
set                          0 /home/daniel/dev/maatkit/mk-find/mk-find:968 
set_defaults                 0 /home/daniel/dev/maatkit/mk-find/mk-find:708 
short_opts                   0 /home/daniel/dev/maatkit/mk-find/mk-find:702 
sort_indexes                 0 /home/daniel/dev/maatkit/mk-find/mk-find:1438
split_unquote                0 /home/daniel/dev/maatkit/mk-find/mk-find:1267
test_date                    0 /home/daniel/dev/maatkit/mk-find/mk-find:2779
test_number                  0 /home/daniel/dev/maatkit/mk-find/mk-find:2769
test_regex                   0 /home/daniel/dev/maatkit/mk-find/mk-find:2788
usage                        0 /home/daniel/dev/maatkit/mk-find/mk-find:185 
usage_or_errors              0 /home/daniel/dev/maatkit/mk-find/mk-find:1003
version_ge                   0 /home/daniel/dev/maatkit/mk-find/mk-find:1315


mk-find.t

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     BEGIN {
4     ***      1     50     33      1            32      die "The MAATKIT_TRUNK environment variable is not set.  See http://code.google.com/p/maatkit/wiki/Testing"
5                                                           unless $ENV{MAATKIT_TRUNK} && -d $ENV{MAATKIT_TRUNK};
6              1                                  7      unshift @INC, "$ENV{MAATKIT_TRUNK}/common";
7                                                     };
8                                                     
9              1                    1            12   use strict;
               1                                  2   
               1                                  6   
10             1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  5   
11             1                    1            10   use English qw(-no_match_vars);
               1                                  2   
               1                                  8   
12             1                    1            10   use Test::More;
               1                                  3   
               1                                  8   
13                                                    
14             1                    1            12   use MaatkitTest;
               1                                  3   
               1                                 10   
15             1                    1            12   use Sandbox;
               1                                  3   
               1                                 11   
16             1                                 25   require "$trunk/mk-find/mk-find";
17                                                    
18             1                                 11   my $dp = new DSNParser();
19             1                                 11   my $sb = new Sandbox(basedir => '/tmp', DSNParser => $dp);
20             1                                 61   my $dbh = $sb->get_dbh_for('master');
21                                                    
22    ***      1     50                          19   if ( !$dbh ) {
23    ***      0                                  0      plan skip_all => 'Cannot connect to sandbox master';
24                                                    }
25                                                    else {
26             1                                  7      plan tests => 18;
27                                                    }
28                                                    
29             1                                430   my $output;
30             1                                  4   my $cnf = '/tmp/12345/my.sandbox.cnf';
31             1                                  5   my $cmd = "$trunk/mk-find/mk-find -F $cnf ";
32                                                    
33             1                             115054   $output = `$cmd mysql --tblregex column`;
34             1                                 63   like($output, qr/`mysql`.`columns_priv`/, 'Found mysql.columns_priv');
35                                                    
36             1                             113467   $output = `$cmd mysql`;
37             1                                 59   like(
38                                                       $output,
39                                                       qr/`mysql`.`columns_priv`/,
40                                                       'Prints tables without any tests'
41                                                    );
42                                                    
43                                                    # These tests are going to be senstive to your sakila db.  Hopefully,
44                                                    # it matches mine which I tend to load fresh and not modify.  For example,
45                                                    # the next insert id for sakila.film is expected to be 1001.  If this
46                                                    # becomes an issue, I may commit my copy of the sakila db to Google Code.
47                                                    
48             1                                  3   SKIP: {
49             1                                532      skip 'Sandbox master does not have the sakila database', 15
50    ***      1     50                           4         unless @{$dbh->selectcol_arrayref('SHOW DATABASES LIKE "sakila"')};
51                                                    
52                                                       # ########################################################################
53                                                       # First, test actions: --exec*, print*, etc.
54                                                       # ########################################################################
55                                                    
56                                                       # POD says: "[--print] is the default action if no other action is
57                                                       # specified."
58             1                             137117      $output = `$cmd --autoinc 1001`;
59             1                                 47      is(
60                                                          $output,
61                                                          "`sakila`.`film`\n",
62                                                          '--print is default action'
63                                                       );
64                                                    
65                                                    
66                                                       # Test that explicit --print doesn't blow up. 
67             1                             170506      $output = `$cmd --autoinc 1001 --print`;
68             1                                 48      is(
69                                                          $output,
70                                                          "`sakila`.`film`\n",
71                                                          'Explicit --print',
72                                                       );
73                                                    
74             1                             160148      $output = `$cmd sakila  --column-name release_year --print`;
75             1                                 47      is(
76                                                          $output,
77                                                          "`sakila`.`film`\n",
78                                                          '--column-name'
79                                                       );
80                                                    
81                                                       # Test --view.
82             1                             164212      $output = `$cmd sakila  --view 'left join \`film_category\`'  --print`;
83             1                                 53      is(
84                                                          $output,
85                                                       "`sakila`.`actor_info`
86                                                    `sakila`.`film_list`
87                                                    `sakila`.`nicer_but_slower_film_list`\n",
88                                                          '--view that matches'
89                                                       );
90                                                    
91             1                             156400      $output = `$cmd sakila  --view blah  --print`;
92             1                                 45      is(
93                                                          $output,
94                                                          '',
95                                                          "--view that doesn't match"
96                                                       );
97                                                    
98                                                       # Test --procedure.
99             1                             141682      $output = `$cmd sakila  --procedure min_monthly_purchases  --print`;
100            1                                 46      is(
101                                                         $output,
102                                                         "`sakila`.`PROCEDURE rewards_report`\n",
103                                                         '--procedure that matches'
104                                                      );
105                                                   
106            1                             187629      $output = `$cmd sakila  --procedure blah  --print`;
107            1                                 43      is(
108                                                         $output,
109                                                         '',
110                                                         "--procedure that doesn't match"
111                                                      );
112                                                   
113                                                      # Test --function.
114            1                             120383      $output = `$cmd sakila  --function v_out --print`;
115            1                                 44      is(
116                                                         $output,
117                                                         "`sakila`.`FUNCTION inventory_in_stock`\n",
118                                                         '--function that matches'
119                                                      );
120                                                   
121            1                             121354      $output = `$cmd sakila  --function blah  --print`;
122            1                                 41      is(
123                                                         $output,
124                                                         '',
125                                                         "--function that doesn't match"
126                                                      );
127                                                   
128                                                      # Test --trigger without --trigger-table.
129            1                             125180      $output = `$cmd sakila  --trigger 'UPDATE film_text' --print`;
130            1                                 39      is(
131                                                         $output,
132                                                         "`sakila`.`UPDATE TRIGGER upd_film on film`\n",
133                                                         '--trigger that matches without --trigger-table'
134                                                      );
135                                                   
136            1                             169125      $output = `$cmd sakila  --trigger blah  --print`;
137            1                                112      is(
138                                                         $output,
139                                                         '',
140                                                         "--trigger that doesn't match without --trigger-table"
141                                                      );
142                                                   
143                                                      # Test --trigger with --trigger-table.
144            1                             164596      $output = `$cmd sakila  --trigger 'UPDATE film_text' --trigger-table film --print`;
145            1                                 39      is(
146                                                         $output,
147                                                         "`sakila`.`UPDATE TRIGGER upd_film on film`\n",
148                                                         '--trigger that matches with matching --trigger-table'
149                                                      );
150                                                   
151            1                             127001      $output = `$cmd sakila  --trigger blah --trigger-table film  --print`;
152            1                                 42      is(
153                                                         $output,
154                                                         '',
155                                                         "--trigger that doesn't match with matching --trigger-table"
156                                                      );
157                                                   
158            1                             140808      $output = `$cmd sakila  --trigger 'UPDATE film_text' --trigger-table foo --print`;
159            1                                 37      is(
160                                                         $output,
161                                                         '',
162                                                         '--trigger that matches with non-matching --trigger-table'
163                                                      );
164                                                   
165            1                             120135      $output = `$cmd sakila  --trigger blah --trigger-table foo --print`;
166            1                                 42      is(
167                                                         $output,
168                                                         '',
169                                                         "--trigger that doesn't match with non-matching --trigger-table"
170                                                      );
171                                                   };
172                                                   
173                                                   # #########################################################################
174                                                   # Issue 391: Add --pid option to all scripts
175                                                   # #########################################################################
176            1                               4005   `touch /tmp/mk-script.pid`;
177            1                              97236   $output = `$cmd mysql --pid /tmp/mk-script.pid 2>&1`;
178            1                                 49   like(
179                                                      $output,
180                                                      qr{PID file /tmp/mk-script.pid already exists},
181                                                      'Dies if PID file already exists (issue 391)'
182                                                   );
183            1                               3944   `rm -rf /tmp/mk-script.pid`;
184                                                   
185                                                   
186                                                   # #############################################################################
187                                                   # Done.
188                                                   # #############################################################################
189            1                                 45   $sb->wipe_clean($dbh);
190            1                                  4   exit;


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
4     ***     50      0      1   unless $ENV{'MAATKIT_TRUNK'} and -d $ENV{'MAATKIT_TRUNK'}
22    ***     50      0      1   if (not $dbh) { }
50    ***     50      0      1   unless @{$dbh->selectcol_arrayref('SHOW DATABASES LIKE "sakila"');}


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
4     ***     33      0      0      1   $ENV{'MAATKIT_TRUNK'} and -d $ENV{'MAATKIT_TRUNK'}


Covered Subroutines
-------------------

Subroutine Count Location    
---------- ----- ------------
BEGIN          1 mk-find.t:10
BEGIN          1 mk-find.t:11
BEGIN          1 mk-find.t:12
BEGIN          1 mk-find.t:14
BEGIN          1 mk-find.t:15
BEGIN          1 mk-find.t:4 
BEGIN          1 mk-find.t:9 


