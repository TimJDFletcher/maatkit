---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...mk-heartbeat/mk-heartbeat   12.4    2.4    5.9   30.6    n/a  100.0    9.9
Total                          12.4    2.4    5.9   30.6    n/a  100.0    9.9
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:22:24 2010
Finish:       Thu Jan 28 22:22:24 2010

Run:          ./101_basics.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:22:25 2010
Finish:       Thu Jan 28 22:22:40 2010

Run:          ./102_standard_options.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu Jan 28 22:22:43 2010
Finish:       Thu Jan 28 22:22:43 2010

/home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This is mk-heartbeat, a script to measure replication delay.
4                                                     #
5                                                     # This program is copyright 2007-@CURRENTYEAR@ Percona Inc.
6                                                     # and copyright 2006 Proven Scaling LLC and Six Apart Ltd.
7                                                     # Feedback and improvements are welcome.
8                                                     #
9                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
10                                                    # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
11                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
12                                                    #
13                                                    # This program is free software; you can redistribute it and/or modify it
14                                                    # under the terms of the GNU General Public License as published by the Free
15                                                    # Software Foundation, version 2; OR the Perl Artistic License.  On UNIX and
16                                                    # similar systems, you can issue `man perlgpl' or `man perlartistic' to read
17                                                    # these licenses.
18                                                    #
19                                                    # You should have received a copy of the GNU General Public License along with
20                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
21                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
22                                                    
23             2                    2            15   use strict;
               2                                  6   
               2                                 17   
24             2                    2            21   use warnings FATAL => 'all';
               2                                  4   
               2                                 15   
25                                                    
26                                                    our $VERSION = '@VERSION@';
27                                                    our $DISTRIB = '@DISTRIB@';
28                                                    our $SVN_REV = sprintf("%d", (q$Revision: 5425 $ =~ m/(\d+)/g, 0));
29                                                    
30                                                    # ###########################################################################
31                                                    # MasterSlave package 5362
32                                                    # ###########################################################################
33             2                    2            14   use strict;
               2                                  5   
               2                                  8   
34             2                    2            15   use warnings FATAL => 'all';
               2                                  9   
               2                                 10   
35                                                    
36                                                    package MasterSlave;
37                                                    
38             2                    2            13   use English qw(-no_match_vars);
               2                                  5   
               2                                 14   
39             2                    2            15   use List::Util qw(min max);
               2                                  4   
               2                                 24   
40             2                    2           128   use Data::Dumper;
               2                                  5   
               2                                 14   
41                                                    $Data::Dumper::Quotekeys = 0;
42                                                    $Data::Dumper::Indent    = 0;
43                                                    
44    ***      2            50      2            13   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               2                                  6   
               2                                 29   
45                                                    
46                                                    sub new {
47    ***      0                    0             0      bless {}, shift;
48                                                    }
49                                                    
50                                                    sub recurse_to_slaves {
51    ***      0                    0             0      my ( $self, $args, $level ) = @_;
52    ***      0             0                    0      $level ||= 0;
53    ***      0                                  0      my $dp   = $args->{dsn_parser};
54    ***      0                                  0      my $dsn  = $args->{dsn};
55                                                    
56    ***      0                                  0      my $dbh;
57    ***      0                                  0      eval {
58    ***      0             0                    0         $dbh = $args->{dbh} || $dp->get_dbh(
59                                                             $dp->get_cxn_params($dsn), { AutoCommit => 1 });
60    ***      0                                  0         MKDEBUG && _d('Connected to', $dp->as_string($dsn));
61                                                       };
62    ***      0      0                           0      if ( $EVAL_ERROR ) {
63    ***      0      0                           0         print STDERR "Cannot connect to ", $dp->as_string($dsn), "\n"
64                                                             or die "Cannot print: $OS_ERROR";
65    ***      0                                  0         return;
66                                                       }
67                                                    
68    ***      0                                  0      my $sql  = 'SELECT @@SERVER_ID';
69    ***      0                                  0      MKDEBUG && _d($sql);
70    ***      0                                  0      my ($id) = $dbh->selectrow_array($sql);
71    ***      0                                  0      MKDEBUG && _d('Working on server ID', $id);
72    ***      0                                  0      my $master_thinks_i_am = $dsn->{server_id};
73    ***      0      0      0                    0      if ( !defined $id
      ***                    0                        
      ***                    0                        
74                                                           || ( defined $master_thinks_i_am && $master_thinks_i_am != $id )
75                                                           || $args->{server_ids_seen}->{$id}++
76                                                       ) {
77    ***      0                                  0         MKDEBUG && _d('Server ID seen, or not what master said');
78    ***      0      0                           0         if ( $args->{skip_callback} ) {
79    ***      0                                  0            $args->{skip_callback}->($dsn, $dbh, $level, $args->{parent});
80                                                          }
81    ***      0                                  0         return;
82                                                       }
83                                                    
84    ***      0                                  0      $args->{callback}->($dsn, $dbh, $level, $args->{parent});
85                                                    
86    ***      0      0      0                    0      if ( !defined $args->{recurse} || $level < $args->{recurse} ) {
87                                                    
88    ***      0      0                           0         my @slaves =
89    ***      0                                  0            grep { !$_->{master_id} || $_->{master_id} == $id } # Only my slaves.
90                                                             $self->find_slave_hosts($dp, $dbh, $dsn, $args->{method});
91                                                    
92    ***      0                                  0         foreach my $slave ( @slaves ) {
93    ***      0                                  0            MKDEBUG && _d('Recursing from',
94                                                                $dp->as_string($dsn), 'to', $dp->as_string($slave));
95    ***      0                                  0            $self->recurse_to_slaves(
96                                                                { %$args, dsn => $slave, dbh => undef, parent => $dsn }, $level + 1 );
97                                                          }
98                                                       }
99                                                    }
100                                                   
101                                                   sub find_slave_hosts {
102   ***      0                    0             0      my ( $self, $dsn_parser, $dbh, $dsn, $method ) = @_;
103                                                   
104   ***      0                                  0      my @methods = qw(processlist hosts);
105   ***      0      0                           0      if ( $method ) {
106   ***      0                                  0         @methods = grep { $_ ne $method } @methods;
      ***      0                                  0   
107   ***      0                                  0         unshift @methods, $method;
108                                                      }
109                                                      else {
110   ***      0      0      0                    0         if ( ($dsn->{P} || 3306) != 3306 ) {
111   ***      0                                  0            MKDEBUG && _d('Port number is non-standard; using only hosts method');
112   ***      0                                  0            @methods = qw(hosts);
113                                                         }
114                                                      }
115   ***      0                                  0      MKDEBUG && _d('Looking for slaves on', $dsn_parser->as_string($dsn),
116                                                         'using methods', @methods);
117                                                   
118   ***      0                                  0      my @slaves;
119                                                      METHOD:
120   ***      0                                  0      foreach my $method ( @methods ) {
121   ***      0                                  0         my $find_slaves = "_find_slaves_by_$method";
122   ***      0                                  0         MKDEBUG && _d('Finding slaves with', $find_slaves);
123   ***      0                                  0         @slaves = $self->$find_slaves($dsn_parser, $dbh, $dsn);
124   ***      0      0                           0         last METHOD if @slaves;
125                                                      }
126                                                   
127   ***      0                                  0      MKDEBUG && _d('Found', scalar(@slaves), 'slaves');
128   ***      0                                  0      return @slaves;
129                                                   }
130                                                   
131                                                   sub _find_slaves_by_processlist {
132   ***      0                    0             0      my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
133                                                   
134   ***      0                                  0      my @slaves = map  {
135   ***      0                                  0         my $slave        = $dsn_parser->parse("h=$_", $dsn);
136   ***      0                                  0         $slave->{source} = 'processlist';
137   ***      0                                  0         $slave;
138                                                      }
139   ***      0                                  0      grep { $_ }
140                                                      map  {
141   ***      0                                  0         my ( $host ) = $_->{host} =~ m/^([^:]+):/;
142   ***      0      0                           0         if ( $host eq 'localhost' ) {
143   ***      0                                  0            $host = '127.0.0.1'; # Replication never uses sockets.
144                                                         }
145   ***      0                                  0         $host;
146                                                      } $self->get_connected_slaves($dbh);
147                                                   
148   ***      0                                  0      return @slaves;
149                                                   }
150                                                   
151                                                   sub _find_slaves_by_hosts {
152   ***      0                    0             0      my ( $self, $dsn_parser, $dbh, $dsn ) = @_;
153                                                   
154   ***      0                                  0      my @slaves;
155   ***      0                                  0      my $sql = 'SHOW SLAVE HOSTS';
156   ***      0                                  0      MKDEBUG && _d($dbh, $sql);
157   ***      0                                  0      @slaves = @{$dbh->selectall_arrayref($sql, { Slice => {} })};
      ***      0                                  0   
158                                                   
159   ***      0      0                           0      if ( @slaves ) {
160   ***      0                                  0         MKDEBUG && _d('Found some SHOW SLAVE HOSTS info');
161   ***      0                                  0         @slaves = map {
162   ***      0                                  0            my %hash;
163   ***      0                                  0            @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
164   ***      0      0                           0            my $spec = "h=$hash{host},P=$hash{port}"
      ***             0                               
165                                                               . ( $hash{user} ? ",u=$hash{user}" : '')
166                                                               . ( $hash{password} ? ",p=$hash{password}" : '');
167   ***      0                                  0            my $dsn           = $dsn_parser->parse($spec, $dsn);
168   ***      0                                  0            $dsn->{server_id} = $hash{server_id};
169   ***      0                                  0            $dsn->{master_id} = $hash{master_id};
170   ***      0                                  0            $dsn->{source}    = 'hosts';
171   ***      0                                  0            $dsn;
172                                                         } @slaves;
173                                                      }
174                                                   
175   ***      0                                  0      return @slaves;
176                                                   }
177                                                   
178                                                   sub get_connected_slaves {
179   ***      0                    0             0      my ( $self, $dbh ) = @_;
180                                                   
181   ***      0                                  0      my $proc =
182   ***      0                                  0         grep { m/ALL PRIVILEGES.*?\*\.\*|PROCESS/ }
183   ***      0                                  0         @{$dbh->selectcol_arrayref('SHOW GRANTS')};
184   ***      0      0                           0      if ( !$proc ) {
185   ***      0                                  0         die "You do not have the PROCESS privilege";
186                                                      }
187                                                   
188   ***      0                                  0      my $sql = 'SHOW PROCESSLIST';
189   ***      0                                  0      MKDEBUG && _d($dbh, $sql);
190   ***      0                                  0      grep { $_->{command} =~ m/Binlog Dump/i }
      ***      0                                  0   
191                                                      map  { # Lowercase the column names
192   ***      0                                  0         my %hash;
193   ***      0                                  0         @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
194   ***      0                                  0         \%hash;
195                                                      }
196   ***      0                                  0      @{$dbh->selectall_arrayref($sql, { Slice => {} })};
197                                                   }
198                                                   
199                                                   sub is_master_of {
200   ***      0                    0             0      my ( $self, $master, $slave ) = @_;
201   ***      0      0                           0      my $master_status = $self->get_master_status($master)
202                                                         or die "The server specified as a master is not a master";
203   ***      0      0                           0      my $slave_status  = $self->get_slave_status($slave)
204                                                         or die "The server specified as a slave is not a slave";
205   ***      0      0                           0      my @connected     = $self->get_connected_slaves($master)
206                                                         or die "The server specified as a master has no connected slaves";
207   ***      0                                  0      my (undef, $port) = $master->selectrow_array('SHOW VARIABLES LIKE "port"');
208                                                   
209   ***      0      0                           0      if ( $port != $slave_status->{master_port} ) {
210   ***      0                                  0         die "The slave is connected to $slave_status->{master_port} "
211                                                            . "but the master's port is $port";
212                                                      }
213                                                   
214   ***      0      0                           0      if ( !grep { $slave_status->{master_user} eq $_->{user} } @connected ) {
      ***      0                                  0   
215   ***      0                                  0         die "I don't see any slave I/O thread connected with user "
216                                                            . $slave_status->{master_user};
217                                                      }
218                                                   
219   ***      0      0      0                    0      if ( ($slave_status->{slave_io_state} || '')
220                                                         eq 'Waiting for master to send event' )
221                                                      {
222   ***      0                                  0         my ( $master_log_name, $master_log_num )
223                                                            = $master_status->{file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
224   ***      0                                  0         my ( $slave_log_name, $slave_log_num )
225                                                            = $slave_status->{master_log_file} =~ m/^(.*?)\.0*([1-9][0-9]*)$/;
226   ***      0      0      0                    0         if ( $master_log_name ne $slave_log_name
227                                                            || abs($master_log_num - $slave_log_num) > 1 )
228                                                         {
229   ***      0                                  0            die "The slave thinks it is reading from "
230                                                               . "$slave_status->{master_log_file},  but the "
231                                                               . "master is writing to $master_status->{file}";
232                                                         }
233                                                      }
234   ***      0                                  0      return 1;
235                                                   }
236                                                   
237                                                   sub get_master_dsn {
238   ***      0                    0             0      my ( $self, $dbh, $dsn, $dsn_parser ) = @_;
239   ***      0      0                           0      my $master = $self->get_slave_status($dbh) or return undef;
240   ***      0                                  0      my $spec   = "h=$master->{master_host},P=$master->{master_port}";
241   ***      0                                  0      return       $dsn_parser->parse($spec, $dsn);
242                                                   }
243                                                   
244                                                   sub get_slave_status {
245   ***      0                    0             0      my ( $self, $dbh ) = @_;
246   ***      0      0                           0      if ( !$self->{not_a_slave}->{$dbh} ) {
247   ***      0             0                    0         my $sth = $self->{sths}->{$dbh}->{SLAVE_STATUS}
248                                                               ||= $dbh->prepare('SHOW SLAVE STATUS');
249   ***      0                                  0         MKDEBUG && _d($dbh, 'SHOW SLAVE STATUS');
250   ***      0                                  0         $sth->execute();
251   ***      0                                  0         my ($ss) = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
252                                                   
253   ***      0      0      0                    0         if ( $ss && %$ss ) {
254   ***      0                                  0            $ss = { map { lc($_) => $ss->{$_} } keys %$ss }; # lowercase the keys
      ***      0                                  0   
255   ***      0                                  0            return $ss;
256                                                         }
257                                                   
258   ***      0                                  0         MKDEBUG && _d('This server returns nothing for SHOW SLAVE STATUS');
259   ***      0                                  0         $self->{not_a_slave}->{$dbh}++;
260                                                      }
261                                                   }
262                                                   
263                                                   sub get_master_status {
264   ***      0                    0             0      my ( $self, $dbh ) = @_;
265   ***      0      0                           0      if ( !$self->{not_a_master}->{$dbh} ) {
266   ***      0             0                    0         my $sth = $self->{sths}->{$dbh}->{MASTER_STATUS}
267                                                               ||= $dbh->prepare('SHOW MASTER STATUS');
268   ***      0                                  0         MKDEBUG && _d($dbh, 'SHOW MASTER STATUS');
269   ***      0                                  0         $sth->execute();
270   ***      0                                  0         my ($ms) = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
271                                                   
272   ***      0      0      0                    0         if ( $ms && %$ms ) {
273   ***      0                                  0            $ms = { map { lc($_) => $ms->{$_} } keys %$ms }; # lowercase the keys
      ***      0                                  0   
274   ***      0      0      0                    0            if ( $ms->{file} && $ms->{position} ) {
275   ***      0                                  0               return $ms;
276                                                            }
277                                                         }
278                                                   
279   ***      0                                  0         MKDEBUG && _d('This server returns nothing for SHOW MASTER STATUS');
280   ***      0                                  0         $self->{not_a_master}->{$dbh}++;
281                                                      }
282                                                   }
283                                                   
284                                                   sub wait_for_master {
285   ***      0                    0             0      my ( $self, $master, $slave, $time, $timeoutok, $ms ) = @_;
286   ***      0                                  0      my $result;
287   ***      0      0                           0      $time = 60 unless defined $time;
288   ***      0                                  0      MKDEBUG && _d('Waiting for slave to catch up to master timeout ok:',
289                                                         $timeoutok);
290   ***      0             0                    0      $ms ||= $self->get_master_status($master);
291   ***      0      0                           0      if ( $ms ) {
292   ***      0                                  0         my $query = "SELECT MASTER_POS_WAIT('$ms->{file}', $ms->{position}, $time)";
293   ***      0                                  0         MKDEBUG && _d($slave, $query);
294   ***      0                                  0         ($result) = $slave->selectrow_array($query);
295   ***      0      0                           0         my $stat = defined $result ? $result : 'NULL';
296   ***      0                                  0         MKDEBUG && _d('Result of waiting:', $stat);
297   ***      0      0      0                    0         if ( $stat eq 'NULL' || $stat < 0 && !$timeoutok ) {
      ***                    0                        
298   ***      0                                  0            die "MASTER_POS_WAIT returned $stat";
299                                                         }
300                                                      }
301                                                      else {
302   ***      0                                  0         MKDEBUG && _d('Not waiting: this server is not a master');
303                                                      }
304   ***      0                                  0      return $result;
305                                                   }
306                                                   
307                                                   sub stop_slave {
308   ***      0                    0             0      my ( $self, $dbh ) = @_;
309   ***      0             0                    0      my $sth = $self->{sths}->{$dbh}->{STOP_SLAVE}
310                                                            ||= $dbh->prepare('STOP SLAVE');
311   ***      0                                  0      MKDEBUG && _d($dbh, $sth->{Statement});
312   ***      0                                  0      $sth->execute();
313                                                   }
314                                                   
315                                                   sub start_slave {
316   ***      0                    0             0      my ( $self, $dbh, $pos ) = @_;
317   ***      0      0                           0      if ( $pos ) {
318   ***      0                                  0         my $sql = "START SLAVE UNTIL MASTER_LOG_FILE='$pos->{file}', "
319                                                                 . "MASTER_LOG_POS=$pos->{position}";
320   ***      0                                  0         MKDEBUG && _d($dbh, $sql);
321   ***      0                                  0         $dbh->do($sql);
322                                                      }
323                                                      else {
324   ***      0             0                    0         my $sth = $self->{sths}->{$dbh}->{START_SLAVE}
325                                                               ||= $dbh->prepare('START SLAVE');
326   ***      0                                  0         MKDEBUG && _d($dbh, $sth->{Statement});
327   ***      0                                  0         $sth->execute();
328                                                      }
329                                                   }
330                                                   
331                                                   sub catchup_to_master {
332   ***      0                    0             0      my ( $self, $slave, $master, $time ) = @_;
333   ***      0                                  0      $self->stop_slave($master);
334   ***      0                                  0      $self->stop_slave($slave);
335   ***      0                                  0      my $slave_status  = $self->get_slave_status($slave);
336   ***      0                                  0      my $slave_pos     = $self->repl_posn($slave_status);
337   ***      0                                  0      my $master_status = $self->get_master_status($master);
338   ***      0                                  0      my $master_pos    = $self->repl_posn($master_status);
339   ***      0                                  0      MKDEBUG && _d('Master position:', $self->pos_to_string($master_pos),
340                                                         'Slave position:', $self->pos_to_string($slave_pos));
341   ***      0      0                           0      if ( $self->pos_cmp($slave_pos, $master_pos) < 0 ) {
342   ***      0                                  0         MKDEBUG && _d('Waiting for slave to catch up to master');
343   ***      0                                  0         $self->start_slave($slave, $master_pos);
344   ***      0                                  0         eval {
345   ***      0                                  0            $self->wait_for_master($master, $slave, $time, 0, $master_status);
346                                                         };
347   ***      0      0                           0         if ( $EVAL_ERROR ) {
348   ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
349   ***      0      0                           0            if ( $EVAL_ERROR =~ m/MASTER_POS_WAIT returned NULL/ ) {
350   ***      0                                  0               $slave_status = $self->get_slave_status($slave);
351   ***      0      0                           0               if ( !$self->slave_is_running($slave_status) ) {
352   ***      0                                  0                  MKDEBUG && _d('Master position:',
353                                                                     $self->pos_to_string($master_pos),
354                                                                     'Slave position:', $self->pos_to_string($slave_pos));
355   ***      0                                  0                  $slave_pos = $self->repl_posn($slave_status);
356   ***      0      0                           0                  if ( $self->pos_cmp($slave_pos, $master_pos) != 0 ) {
357   ***      0                                  0                     die "$EVAL_ERROR but slave has not caught up to master";
358                                                                  }
359   ***      0                                  0                  MKDEBUG && _d('Slave is caught up to master and stopped');
360                                                               }
361                                                               else {
362   ***      0                                  0                  die "$EVAL_ERROR but slave was still running";
363                                                               }
364                                                            }
365                                                            else {
366   ***      0                                  0               die $EVAL_ERROR;
367                                                            }
368                                                         }
369                                                      }
370                                                   }
371                                                   
372                                                   sub catchup_to_same_pos {
373   ***      0                    0             0      my ( $self, $s1_dbh, $s2_dbh ) = @_;
374   ***      0                                  0      $self->stop_slave($s1_dbh);
375   ***      0                                  0      $self->stop_slave($s2_dbh);
376   ***      0                                  0      my $s1_status = $self->get_slave_status($s1_dbh);
377   ***      0                                  0      my $s2_status = $self->get_slave_status($s2_dbh);
378   ***      0                                  0      my $s1_pos    = $self->repl_posn($s1_status);
379   ***      0                                  0      my $s2_pos    = $self->repl_posn($s2_status);
380   ***      0      0                           0      if ( $self->pos_cmp($s1_pos, $s2_pos) < 0 ) {
      ***             0                               
381   ***      0                                  0         $self->start_slave($s1_dbh, $s2_pos);
382                                                      }
383                                                      elsif ( $self->pos_cmp($s2_pos, $s1_pos) < 0 ) {
384   ***      0                                  0         $self->start_slave($s2_dbh, $s1_pos);
385                                                      }
386                                                   
387   ***      0                                  0      $s1_status = $self->get_slave_status($s1_dbh);
388   ***      0                                  0      $s2_status = $self->get_slave_status($s2_dbh);
389   ***      0                                  0      $s1_pos    = $self->repl_posn($s1_status);
390   ***      0                                  0      $s2_pos    = $self->repl_posn($s2_status);
391                                                   
392   ***      0      0      0                    0      if ( $self->slave_is_running($s1_status)
      ***                    0                        
393                                                        || $self->slave_is_running($s2_status)
394                                                        || $self->pos_cmp($s1_pos, $s2_pos) != 0)
395                                                      {
396   ***      0                                  0         die "The servers aren't both stopped at the same position";
397                                                      }
398                                                   
399                                                   }
400                                                   
401                                                   sub change_master_to {
402   ***      0                    0             0      my ( $self, $dbh, $master_dsn, $master_pos ) = @_;
403   ***      0                                  0      $self->stop_slave($dbh);
404   ***      0                                  0      MKDEBUG && _d(Dumper($master_dsn), Dumper($master_pos));
405   ***      0                                  0      my $sql = "CHANGE MASTER TO MASTER_HOST='$master_dsn->{h}', "
406                                                         . "MASTER_PORT= $master_dsn->{P}, MASTER_LOG_FILE='$master_pos->{file}', "
407                                                         . "MASTER_LOG_POS=$master_pos->{position}";
408   ***      0                                  0      MKDEBUG && _d($dbh, $sql);
409   ***      0                                  0      $dbh->do($sql);
410                                                   }
411                                                   
412                                                   sub make_sibling_of_master {
413   ***      0                    0             0      my ( $self, $slave_dbh, $slave_dsn, $dsn_parser, $timeout) = @_;
414                                                   
415   ***      0      0                           0      my $master_dsn  = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
416                                                         or die "This server is not a slave";
417   ***      0                                  0      my $master_dbh  = $dsn_parser->get_dbh(
418                                                         $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
419   ***      0      0                           0      my $gmaster_dsn
420                                                         = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
421                                                         or die "This server's master is not a slave";
422   ***      0                                  0      my $gmaster_dbh = $dsn_parser->get_dbh(
423                                                         $dsn_parser->get_cxn_params($gmaster_dsn), { AutoCommit => 1 });
424   ***      0      0                           0      if ( $self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn) ) {
425   ***      0                                  0         die "The slave's master's master is the slave: master-master replication";
426                                                      }
427                                                   
428   ***      0                                  0      $self->stop_slave($master_dbh);
429   ***      0                                  0      $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
430   ***      0                                  0      $self->stop_slave($slave_dbh);
431                                                   
432   ***      0                                  0      my $master_status = $self->get_master_status($master_dbh);
433   ***      0                                  0      my $mslave_status = $self->get_slave_status($master_dbh);
434   ***      0                                  0      my $slave_status  = $self->get_slave_status($slave_dbh);
435   ***      0                                  0      my $master_pos    = $self->repl_posn($master_status);
436   ***      0                                  0      my $slave_pos     = $self->repl_posn($slave_status);
437                                                   
438   ***      0      0      0                    0      if ( !$self->slave_is_running($mslave_status)
      ***                    0                        
439                                                        && !$self->slave_is_running($slave_status)
440                                                        && $self->pos_cmp($master_pos, $slave_pos) == 0)
441                                                      {
442   ***      0                                  0         $self->change_master_to($slave_dbh, $gmaster_dsn,
443                                                            $self->repl_posn($mslave_status)); # Note it's not $master_pos!
444                                                      }
445                                                      else {
446   ***      0                                  0         die "The servers aren't both stopped at the same position";
447                                                      }
448                                                   
449   ***      0                                  0      $mslave_status = $self->get_slave_status($master_dbh);
450   ***      0                                  0      $slave_status  = $self->get_slave_status($slave_dbh);
451   ***      0                                  0      my $mslave_pos = $self->repl_posn($mslave_status);
452   ***      0                                  0      $slave_pos     = $self->repl_posn($slave_status);
453   ***      0      0      0                    0      if ( $self->short_host($mslave_status) ne $self->short_host($slave_status)
454                                                        || $self->pos_cmp($mslave_pos, $slave_pos) != 0)
455                                                      {
456   ***      0                                  0         die "The servers don't have the same master/position after the change";
457                                                      }
458                                                   }
459                                                   
460                                                   sub make_slave_of_sibling {
461   ***      0                    0             0      my ( $self, $slave_dbh, $slave_dsn, $sib_dbh, $sib_dsn,
462                                                           $dsn_parser, $timeout) = @_;
463                                                   
464   ***      0      0                           0      if ( $self->short_host($slave_dsn) eq $self->short_host($sib_dsn) ) {
465   ***      0                                  0         die "You are trying to make the slave a slave of itself";
466                                                      }
467                                                   
468   ***      0      0                           0      my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
469                                                         or die "This server is not a slave";
470   ***      0                                  0      my $master_dbh1 = $dsn_parser->get_dbh(
471                                                         $dsn_parser->get_cxn_params($master_dsn1), { AutoCommit => 1 });
472   ***      0      0                           0      my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
473                                                         or die "The sibling is not a slave";
474   ***      0      0                           0      if ( $self->short_host($master_dsn1) ne $self->short_host($master_dsn2) ) {
475   ***      0                                  0         die "This server isn't a sibling of the slave";
476                                                      }
477   ***      0      0                           0      my $sib_master_stat = $self->get_master_status($sib_dbh)
478                                                         or die "Binary logging is not enabled on the sibling";
479   ***      0      0                           0      die "The log_slave_updates option is not enabled on the sibling"
480                                                         unless $self->has_slave_updates($sib_dbh);
481                                                   
482   ***      0                                  0      $self->catchup_to_same_pos($slave_dbh, $sib_dbh);
483                                                   
484   ***      0                                  0      $sib_master_stat = $self->get_master_status($sib_dbh);
485   ***      0                                  0      $self->change_master_to($slave_dbh, $sib_dsn,
486                                                            $self->repl_posn($sib_master_stat));
487                                                   
488   ***      0                                  0      my $slave_status = $self->get_slave_status($slave_dbh);
489   ***      0                                  0      my $slave_pos    = $self->repl_posn($slave_status);
490   ***      0                                  0      $sib_master_stat = $self->get_master_status($sib_dbh);
491   ***      0      0      0                    0      if ( $self->short_host($slave_status) ne $self->short_host($sib_dsn)
492                                                        || $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
493                                                      {
494   ***      0                                  0         die "After changing the slave's master, it isn't a slave of the sibling, "
495                                                            . "or it has a different replication position than the sibling";
496                                                      }
497                                                   }
498                                                   
499                                                   sub make_slave_of_uncle {
500   ***      0                    0             0      my ( $self, $slave_dbh, $slave_dsn, $unc_dbh, $unc_dsn,
501                                                           $dsn_parser, $timeout) = @_;
502                                                   
503   ***      0      0                           0      if ( $self->short_host($slave_dsn) eq $self->short_host($unc_dsn) ) {
504   ***      0                                  0         die "You are trying to make the slave a slave of itself";
505                                                      }
506                                                   
507   ***      0      0                           0      my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
508                                                         or die "This server is not a slave";
509   ***      0                                  0      my $master_dbh = $dsn_parser->get_dbh(
510                                                         $dsn_parser->get_cxn_params($master_dsn), { AutoCommit => 1 });
511   ***      0      0                           0      my $gmaster_dsn
512                                                         = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
513                                                         or die "The master is not a slave";
514   ***      0      0                           0      my $unc_master_dsn
515                                                         = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
516                                                         or die "The uncle is not a slave";
517   ***      0      0                           0      if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn)) {
518   ***      0                                  0         die "The uncle isn't really the slave's uncle";
519                                                      }
520                                                   
521   ***      0      0                           0      my $unc_master_stat = $self->get_master_status($unc_dbh)
522                                                         or die "Binary logging is not enabled on the uncle";
523   ***      0      0                           0      die "The log_slave_updates option is not enabled on the uncle"
524                                                         unless $self->has_slave_updates($unc_dbh);
525                                                   
526   ***      0                                  0      $self->catchup_to_same_pos($master_dbh, $unc_dbh);
527   ***      0                                  0      $self->catchup_to_master($slave_dbh, $master_dbh, $timeout);
528                                                   
529   ***      0                                  0      my $slave_status  = $self->get_slave_status($slave_dbh);
530   ***      0                                  0      my $master_status = $self->get_master_status($master_dbh);
531   ***      0      0                           0      if ( $self->pos_cmp(
532                                                            $self->repl_posn($slave_status),
533                                                            $self->repl_posn($master_status)) != 0 )
534                                                      {
535   ***      0                                  0         die "The slave is not caught up to its master";
536                                                      }
537                                                   
538   ***      0                                  0      $unc_master_stat = $self->get_master_status($unc_dbh);
539   ***      0                                  0      $self->change_master_to($slave_dbh, $unc_dsn,
540                                                         $self->repl_posn($unc_master_stat));
541                                                   
542                                                   
543   ***      0                                  0      $slave_status    = $self->get_slave_status($slave_dbh);
544   ***      0                                  0      my $slave_pos    = $self->repl_posn($slave_status);
545   ***      0      0      0                    0      if ( $self->short_host($slave_status) ne $self->short_host($unc_dsn)
546                                                        || $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
547                                                      {
548   ***      0                                  0         die "After changing the slave's master, it isn't a slave of the uncle, "
549                                                            . "or it has a different replication position than the uncle";
550                                                      }
551                                                   }
552                                                   
553                                                   sub detach_slave {
554   ***      0                    0             0      my ( $self, $dbh ) = @_;
555   ***      0                                  0      $self->stop_slave($dbh);
556   ***      0      0                           0      my $stat = $self->get_slave_status($dbh)
557                                                         or die "This server is not a slave";
558   ***      0                                  0      $dbh->do('CHANGE MASTER TO MASTER_HOST=""');
559   ***      0                                  0      $dbh->do('RESET SLAVE'); # Wipes out master.info, etc etc
560   ***      0                                  0      return $stat;
561                                                   }
562                                                   
563                                                   sub slave_is_running {
564   ***      0                    0             0      my ( $self, $slave_status ) = @_;
565   ***      0             0                    0      return ($slave_status->{slave_sql_running} || 'No') eq 'Yes';
566                                                   }
567                                                   
568                                                   sub has_slave_updates {
569   ***      0                    0             0      my ( $self, $dbh ) = @_;
570   ***      0                                  0      my $sql = q{SHOW VARIABLES LIKE 'log_slave_updates'};
571   ***      0                                  0      MKDEBUG && _d($dbh, $sql);
572   ***      0                                  0      my ($name, $value) = $dbh->selectrow_array($sql);
573   ***      0             0                    0      return $value && $value =~ m/^(1|ON)$/;
574                                                   }
575                                                   
576                                                   sub repl_posn {
577   ***      0                    0             0      my ( $self, $status ) = @_;
578   ***      0      0      0                    0      if ( exists $status->{file} && exists $status->{position} ) {
579                                                         return {
580   ***      0                                  0            file     => $status->{file},
581                                                            position => $status->{position},
582                                                         };
583                                                      }
584                                                      else {
585                                                         return {
586   ***      0                                  0            file     => $status->{relay_master_log_file},
587                                                            position => $status->{exec_master_log_pos},
588                                                         };
589                                                      }
590                                                   }
591                                                   
592                                                   sub get_slave_lag {
593   ***      0                    0             0      my ( $self, $dbh ) = @_;
594   ***      0                                  0      my $stat = $self->get_slave_status($dbh);
595   ***      0                                  0      return $stat->{seconds_behind_master};
596                                                   }
597                                                   
598                                                   sub pos_cmp {
599   ***      0                    0             0      my ( $self, $a, $b ) = @_;
600   ***      0                                  0      return $self->pos_to_string($a) cmp $self->pos_to_string($b);
601                                                   }
602                                                   
603                                                   sub short_host {
604   ***      0                    0             0      my ( $self, $dsn ) = @_;
605   ***      0                                  0      my ($host, $port);
606   ***      0      0                           0      if ( $dsn->{master_host} ) {
607   ***      0                                  0         $host = $dsn->{master_host};
608   ***      0                                  0         $port = $dsn->{master_port};
609                                                      }
610                                                      else {
611   ***      0                                  0         $host = $dsn->{h};
612   ***      0                                  0         $port = $dsn->{P};
613                                                      }
614   ***      0      0      0                    0      return ($host || '[default]') . ( ($port || 3306) == 3306 ? '' : ":$port" );
      ***                    0                        
615                                                   }
616                                                   
617                                                   sub pos_to_string {
618   ***      0                    0             0      my ( $self, $pos ) = @_;
619   ***      0                                  0      my $fmt  = '%s/%020d';
620   ***      0                                  0      return sprintf($fmt, @{$pos}{qw(file position)});
      ***      0                                  0   
621                                                   }
622                                                   
623                                                   sub _d {
624   ***      0                    0             0      my ($package, undef, $line) = caller 0;
625   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
626   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
627                                                           @_;
628   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
629                                                   }
630                                                   
631                                                   1;
632                                                   
633                                                   # ###########################################################################
634                                                   # End MasterSlave package
635                                                   # ###########################################################################
636                                                   
637                                                   # ###########################################################################
638                                                   # OptionParser package 5266
639                                                   # ###########################################################################
640                                                   package OptionParser;
641                                                   
642            2                    2            19   use strict;
               2                                  4   
               2                                 13   
643            2                    2            13   use warnings FATAL => 'all';
               2                                  4   
               2                                 13   
644                                                   
645            2                    2            22   use Getopt::Long;
               2                                  6   
               2                                 13   
646            2                    2            13   use List::Util qw(max);
               2                                  5   
               2                                 18   
647            2                    2            13   use English qw(-no_match_vars);
               2                                  5   
               2                                 13   
648                                                   
649   ***      2            50      2            13   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               2                                  6   
               2                                 30   
650                                                   
651                                                   my $POD_link_re = '[LC]<"?([^">]+)"?>';
652                                                   
653                                                   my %attributes = (
654                                                      'type'       => 1,
655                                                      'short form' => 1,
656                                                      'group'      => 1,
657                                                      'default'    => 1,
658                                                      'cumulative' => 1,
659                                                      'negatable'  => 1,
660                                                   );
661                                                   
662                                                   sub new {
663   ***      0                    0             0      my ( $class, %args ) = @_;
664   ***      0                                  0      foreach my $arg ( qw(description) ) {
665   ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
666                                                      }
667   ***      0                                  0      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
668   ***      0             0                    0      $program_name ||= $PROGRAM_NAME;
669   ***      0             0                    0      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                    0                        
      ***                    0                        
670                                                   
671   ***      0      0      0                    0      my $self = {
      ***                    0                        
672                                                         description    => $args{description},
673                                                         prompt         => $args{prompt} || '<options>',
674                                                         strict         => (exists $args{strict} ? $args{strict} : 1),
675                                                         dp             => $args{dp}     || undef,
676                                                         program_name   => $program_name,
677                                                         opts           => {},
678                                                         got_opts       => 0,
679                                                         short_opts     => {},
680                                                         defaults       => {},
681                                                         groups         => {},
682                                                         allowed_groups => {},
683                                                         errors         => [],
684                                                         rules          => [],  # desc of rules for --help
685                                                         mutex          => [],  # rule: opts are mutually exclusive
686                                                         atleast1       => [],  # rule: at least one opt is required
687                                                         disables       => {},  # rule: opt disables other opts 
688                                                         defaults_to    => {},  # rule: opt defaults to value of other opt
689                                                         default_files  => [
690                                                            "/etc/maatkit/maatkit.conf",
691                                                            "/etc/maatkit/$program_name.conf",
692                                                            "$home/.maatkit.conf",
693                                                            "$home/.$program_name.conf",
694                                                         ],
695                                                      };
696   ***      0                                  0      return bless $self, $class;
697                                                   }
698                                                   
699                                                   sub get_specs {
700   ***      0                    0             0      my ( $self, $file ) = @_;
701   ***      0                                  0      my @specs = $self->_pod_to_specs($file);
702   ***      0                                  0      $self->_parse_specs(@specs);
703   ***      0                                  0      return;
704                                                   }
705                                                   
706                                                   sub get_defaults_files {
707   ***      0                    0             0      my ( $self ) = @_;
708   ***      0                                  0      return @{$self->{default_files}};
      ***      0                                  0   
709                                                   }
710                                                   
711                                                   sub _pod_to_specs {
712   ***      0                    0             0      my ( $self, $file ) = @_;
713   ***      0             0                    0      $file ||= __FILE__;
714   ***      0      0                           0      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
715                                                   
716   ***      0                                  0      my %types = (
717                                                         string => 's', # standard Getopt type
718                                                         'int'  => 'i', # standard Getopt type
719                                                         float  => 'f', # standard Getopt type
720                                                         Hash   => 'H', # hash, formed from a comma-separated list
721                                                         hash   => 'h', # hash as above, but only if a value is given
722                                                         Array  => 'A', # array, similar to Hash
723                                                         array  => 'a', # array, similar to hash
724                                                         DSN    => 'd', # DSN, as provided by a DSNParser which is in $self->{dp}
725                                                         size   => 'z', # size with kMG suffix (powers of 2^10)
726                                                         'time' => 'm', # time, with an optional suffix of s/h/m/d
727                                                      );
728   ***      0                                  0      my @specs = ();
729   ***      0                                  0      my @rules = ();
730   ***      0                                  0      my $para;
731                                                   
732   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
733   ***      0                                  0      while ( $para = <$fh> ) {
734   ***      0      0                           0         next unless $para =~ m/^=head1 OPTIONS/;
735   ***      0                                  0         last;
736                                                      }
737                                                   
738   ***      0                                  0      while ( $para = <$fh> ) {
739   ***      0      0                           0         last if $para =~ m/^=over/;
740   ***      0                                  0         chomp $para;
741   ***      0                                  0         $para =~ s/\s+/ /g;
742   ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
743   ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
744   ***      0                                  0         push @rules, $para;
745                                                      }
746                                                   
747   ***      0      0                           0      die 'POD has no OPTIONS section' unless $para;
748                                                   
749   ***      0                                  0      do {
750   ***      0      0                           0         if ( my ($option) = $para =~ m/^=item --(.*)/ ) {
751   ***      0                                  0            chomp $para;
752   ***      0                                  0            MKDEBUG && _d($para);
753   ***      0                                  0            my %attribs;
754                                                   
755   ***      0                                  0            $para = <$fh>; # read next paragraph, possibly attributes
756                                                   
757   ***      0      0                           0            if ( $para =~ m/: / ) { # attributes
758   ***      0                                  0               $para =~ s/\s+\Z//g;
759   ***      0                                  0               %attribs = map {
760   ***      0                                  0                     my ( $attrib, $val) = split(/: /, $_);
761   ***      0      0                           0                     die "Unrecognized attribute for --$option: $attrib"
762                                                                        unless $attributes{$attrib};
763   ***      0                                  0                     ($attrib, $val);
764                                                                  } split(/; /, $para);
765   ***      0      0                           0               if ( $attribs{'short form'} ) {
766   ***      0                                  0                  $attribs{'short form'} =~ s/-//;
767                                                               }
768   ***      0                                  0               $para = <$fh>; # read next paragraph, probably short help desc
769                                                            }
770                                                            else {
771   ***      0                                  0               MKDEBUG && _d('Option has no attributes');
772                                                            }
773                                                   
774   ***      0                                  0            $para =~ s/\s+\Z//g;
775   ***      0                                  0            $para =~ s/\s+/ /g;
776   ***      0                                  0            $para =~ s/$POD_link_re/$1/go;
777                                                   
778   ***      0                                  0            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
779   ***      0                                  0            MKDEBUG && _d('Short help:', $para);
780                                                   
781   ***      0      0                           0            die "No description after option spec $option" if $para =~ m/^=item/;
782                                                   
783   ***      0      0                           0            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
784   ***      0                                  0               $option = $base_option;
785   ***      0                                  0               $attribs{'negatable'} = 1;
786                                                            }
787                                                   
788   ***      0      0                           0            push @specs, {
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
789                                                               spec  => $option
790                                                                  . ($attribs{'short form'} ? '|' . $attribs{'short form'} : '' )
791                                                                  . ($attribs{'negatable'}  ? '!'                          : '' )
792                                                                  . ($attribs{'cumulative'} ? '+'                          : '' )
793                                                                  . ($attribs{'type'}       ? '=' . $types{$attribs{type}} : '' ),
794                                                               desc  => $para
795                                                                  . ($attribs{default} ? " (default $attribs{default})" : ''),
796                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
797                                                            };
798                                                         }
799   ***      0                                  0         while ( $para = <$fh> ) {
800   ***      0      0                           0            last unless $para;
801                                                   
802                                                   
803   ***      0      0                           0            if ( $para =~ m/^=head1/ ) {
804   ***      0                                  0               $para = undef; # Can't 'last' out of a do {} block.
805   ***      0                                  0               last;
806                                                            }
807   ***      0      0                           0            last if $para =~ m/^=item --/;
808                                                         }
809                                                      } while ( $para );
810                                                   
811   ***      0      0                           0      die 'No valid specs in POD OPTIONS' unless @specs;
812                                                   
813   ***      0                                  0      close $fh;
814   ***      0                                  0      return @specs, @rules;
815                                                   }
816                                                   
817                                                   sub _parse_specs {
818   ***      0                    0             0      my ( $self, @specs ) = @_;
819   ***      0                                  0      my %disables; # special rule that requires deferred checking
820                                                   
821   ***      0                                  0      foreach my $opt ( @specs ) {
822   ***      0      0                           0         if ( ref $opt ) { # It's an option spec, not a rule.
823                                                            MKDEBUG && _d('Parsing opt spec:',
824   ***      0                                  0               map { ($_, '=>', $opt->{$_}) } keys %$opt);
825                                                   
826   ***      0                                  0            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
827   ***      0      0                           0            if ( !$long ) {
828   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
829                                                            }
830   ***      0                                  0            $opt->{long} = $long;
831                                                   
832   ***      0      0                           0            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
833   ***      0                                  0            $self->{opts}->{$long} = $opt;
834                                                   
835   ***      0      0                           0            if ( length $long == 1 ) {
836   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
837   ***      0                                  0               $self->{short_opts}->{$long} = $long;
838                                                            }
839                                                   
840   ***      0      0                           0            if ( $short ) {
841   ***      0      0                           0               die "Duplicate short option -$short"
842                                                                  if exists $self->{short_opts}->{$short};
843   ***      0                                  0               $self->{short_opts}->{$short} = $long;
844   ***      0                                  0               $opt->{short} = $short;
845                                                            }
846                                                            else {
847   ***      0                                  0               $opt->{short} = undef;
848                                                            }
849                                                   
850   ***      0      0                           0            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
851   ***      0      0                           0            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
852   ***      0      0                           0            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
853                                                   
854   ***      0             0                    0            $opt->{group} ||= 'default';
855   ***      0                                  0            $self->{groups}->{ $opt->{group} }->{$long} = 1;
856                                                   
857   ***      0                                  0            $opt->{value} = undef;
858   ***      0                                  0            $opt->{got}   = 0;
859                                                   
860   ***      0                                  0            my ( $type ) = $opt->{spec} =~ m/=(.)/;
861   ***      0                                  0            $opt->{type} = $type;
862   ***      0                                  0            MKDEBUG && _d($long, 'type:', $type);
863                                                   
864   ***      0      0      0                    0            if ( $type && $type eq 'd' && !$self->{dp} ) {
      ***                    0                        
865   ***      0                                  0               die "$opt->{long} is type DSN (d) but no dp argument "
866                                                                  . "was given when this OptionParser object was created";
867                                                            }
868                                                   
869   ***      0      0      0                    0            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
870                                                   
871   ***      0      0                           0            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
872   ***      0      0                           0               $self->{defaults}->{$long} = defined $def ? $def : 1;
873   ***      0                                  0               MKDEBUG && _d($long, 'default:', $def);
874                                                            }
875                                                   
876   ***      0      0                           0            if ( $long eq 'config' ) {
877   ***      0                                  0               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
878                                                            }
879                                                   
880   ***      0      0                           0            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
881   ***      0                                  0               $disables{$long} = $dis;
882   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
883                                                            }
884                                                   
885   ***      0                                  0            $self->{opts}->{$long} = $opt;
886                                                         }
887                                                         else { # It's an option rule, not a spec.
888   ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
889   ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
890   ***      0                                  0            my @participants = $self->_get_participants($opt);
891   ***      0                                  0            my $rule_ok = 0;
892                                                   
893   ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
894   ***      0                                  0               $rule_ok = 1;
895   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
896   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
897                                                            }
898   ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
899   ***      0                                  0               $rule_ok = 1;
900   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
901   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
902                                                            }
903   ***      0      0                           0            if ( $opt =~ m/default to/ ) {
904   ***      0                                  0               $rule_ok = 1;
905   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
906   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
907                                                            }
908   ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
909   ***      0                                  0               $rule_ok = 1;
910   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
911   ***      0                                  0               my @groups = split(',', $groups);
912   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
913   ***      0                                  0                  s/\s+//;
914   ***      0                                  0                  $_ => 1;
915                                                               } @groups;
916                                                            }
917                                                   
918   ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
919                                                         }
920                                                      }
921                                                   
922   ***      0                                  0      foreach my $long ( keys %disables ) {
923   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
924   ***      0                                  0         $self->{disables}->{$long} = \@participants;
925   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
926                                                      }
927                                                   
928   ***      0                                  0      return; 
929                                                   }
930                                                   
931                                                   sub _get_participants {
932   ***      0                    0             0      my ( $self, $str ) = @_;
933   ***      0                                  0      my @participants;
934   ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
935   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
936                                                            unless exists $self->{opts}->{$long};
937   ***      0                                  0         push @participants, $long;
938                                                      }
939   ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
940   ***      0                                  0      return @participants;
941                                                   }
942                                                   
943                                                   sub opts {
944   ***      0                    0             0      my ( $self ) = @_;
945   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
946   ***      0                                  0      return %opts;
947                                                   }
948                                                   
949                                                   sub short_opts {
950   ***      0                    0             0      my ( $self ) = @_;
951   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
952   ***      0                                  0      return %short_opts;
953                                                   }
954                                                   
955                                                   sub set_defaults {
956   ***      0                    0             0      my ( $self, %defaults ) = @_;
957   ***      0                                  0      $self->{defaults} = {};
958   ***      0                                  0      foreach my $long ( keys %defaults ) {
959   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
960                                                            unless exists $self->{opts}->{$long};
961   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
962   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
963                                                      }
964   ***      0                                  0      return;
965                                                   }
966                                                   
967                                                   sub get_defaults {
968   ***      0                    0             0      my ( $self ) = @_;
969   ***      0                                  0      return $self->{defaults};
970                                                   }
971                                                   
972                                                   sub get_groups {
973   ***      0                    0             0      my ( $self ) = @_;
974   ***      0                                  0      return $self->{groups};
975                                                   }
976                                                   
977                                                   sub _set_option {
978   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
979   ***      0      0                           0      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***             0                               
980                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
981                                                               : die "Getopt::Long gave a nonexistent option: $opt";
982                                                   
983   ***      0                                  0      $opt = $self->{opts}->{$long};
984   ***      0      0                           0      if ( $opt->{is_cumulative} ) {
985   ***      0                                  0         $opt->{value}++;
986                                                      }
987                                                      else {
988   ***      0                                  0         $opt->{value} = $val;
989                                                      }
990   ***      0                                  0      $opt->{got} = 1;
991   ***      0                                  0      MKDEBUG && _d('Got option', $long, '=', $val);
992                                                   }
993                                                   
994                                                   sub get_opts {
995   ***      0                    0             0      my ( $self ) = @_; 
996                                                   
997   ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
998   ***      0                                  0         $self->{opts}->{$long}->{got} = 0;
999   ***      0      0                           0         $self->{opts}->{$long}->{value}
      ***             0                               
1000                                                           = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
1001                                                           : $self->{opts}->{$long}->{is_cumulative} ? 0
1002                                                           : undef;
1003                                                     }
1004  ***      0                                  0      $self->{got_opts} = 0;
1005                                                  
1006  ***      0                                  0      $self->{errors} = [];
1007                                                  
1008  ***      0      0      0                    0      if ( @ARGV && $ARGV[0] eq "--config" ) {
1009  ***      0                                  0         shift @ARGV;
1010  ***      0                                  0         $self->_set_option('config', shift @ARGV);
1011                                                     }
1012  ***      0      0                           0      if ( $self->has('config') ) {
1013  ***      0                                  0         my @extra_args;
1014  ***      0                                  0         foreach my $filename ( split(',', $self->get('config')) ) {
1015  ***      0                                  0            eval {
1016  ***      0                                  0               push @extra_args, $self->_read_config_file($filename);
1017                                                           };
1018  ***      0      0                           0            if ( $EVAL_ERROR ) {
1019  ***      0      0                           0               if ( $self->got('config') ) {
1020  ***      0                                  0                  die $EVAL_ERROR;
1021                                                              }
1022                                                              elsif ( MKDEBUG ) {
1023                                                                 _d($EVAL_ERROR);
1024                                                              }
1025                                                           }
1026                                                        }
1027  ***      0                                  0         unshift @ARGV, @extra_args;
1028                                                     }
1029                                                  
1030  ***      0                                  0      Getopt::Long::Configure('no_ignore_case', 'bundling');
1031                                                     GetOptions(
1032  ***      0                    0             0         map    { $_->{spec} => sub { $self->_set_option(@_); } }
      ***      0                                  0   
      ***      0                                  0   
1033  ***      0                                  0         grep   { $_->{long} ne 'config' } # --config is handled specially above.
1034  ***      0      0                           0         values %{$self->{opts}}
1035                                                     ) or $self->save_error('Error parsing options');
1036                                                  
1037  ***      0      0      0                    0      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
1038  ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
1039                                                           $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
1040                                                              or die "Cannot print: $OS_ERROR";
1041  ***      0                                  0         exit 0;
1042                                                     }
1043                                                  
1044  ***      0      0      0                    0      if ( @ARGV && $self->{strict} ) {
1045  ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
1046                                                     }
1047                                                  
1048  ***      0                                  0      foreach my $mutex ( @{$self->{mutex}} ) {
      ***      0                                  0   
1049  ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
1050  ***      0      0                           0         if ( @set > 1 ) {
1051  ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
1052  ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
1053                                                                   . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
1054                                                                   . ' are mutually exclusive.';
1055  ***      0                                  0            $self->save_error($err);
1056                                                        }
1057                                                     }
1058                                                  
1059  ***      0                                  0      foreach my $required ( @{$self->{atleast1}} ) {
      ***      0                                  0   
1060  ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
1061  ***      0      0                           0         if ( @set == 0 ) {
1062  ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
1063  ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
1064                                                                   .' or --'.$self->{opts}->{$required->[-1]}->{long};
1065  ***      0                                  0            $self->save_error("Specify at least one of $err");
1066                                                        }
1067                                                     }
1068                                                  
1069  ***      0                                  0      foreach my $long ( keys %{$self->{opts}} ) {
      ***      0                                  0   
1070  ***      0                                  0         my $opt = $self->{opts}->{$long};
1071  ***      0      0                           0         if ( $opt->{got} ) {
      ***             0                               
1072  ***      0      0                           0            if ( exists $self->{disables}->{$long} ) {
1073  ***      0                                  0               my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
1074  ***      0                                  0               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
1075  ***      0                                  0               MKDEBUG && _d('Unset options', @disable_opts,
1076                                                                 'because', $long,'disables them');
1077                                                           }
1078                                                  
1079  ***      0      0                           0            if ( exists $self->{allowed_groups}->{$long} ) {
1080                                                  
1081  ***      0                                  0               my @restricted_groups = grep {
1082  ***      0                                  0                  !exists $self->{allowed_groups}->{$long}->{$_}
1083  ***      0                                  0               } keys %{$self->{groups}};
1084                                                  
1085  ***      0                                  0               my @restricted_opts;
1086  ***      0                                  0               foreach my $restricted_group ( @restricted_groups ) {
1087  ***      0                                  0                  RESTRICTED_OPT:
1088  ***      0                                  0                  foreach my $restricted_opt (
1089                                                                    keys %{$self->{groups}->{$restricted_group}} )
1090                                                                 {
1091  ***      0      0                           0                     next RESTRICTED_OPT if $restricted_opt eq $long;
1092  ***      0      0                           0                     push @restricted_opts, $restricted_opt
1093                                                                       if $self->{opts}->{$restricted_opt}->{got};
1094                                                                 }
1095                                                              }
1096                                                  
1097  ***      0      0                           0               if ( @restricted_opts ) {
1098  ***      0                                  0                  my $err;
1099  ***      0      0                           0                  if ( @restricted_opts == 1 ) {
1100  ***      0                                  0                     $err = "--$restricted_opts[0]";
1101                                                                 }
1102                                                                 else {
1103  ***      0                                  0                     $err = join(', ',
1104  ***      0                                  0                               map { "--$self->{opts}->{$_}->{long}" }
1105  ***      0                                  0                               grep { $_ } 
1106                                                                              @restricted_opts[0..scalar(@restricted_opts) - 2]
1107                                                                           )
1108                                                                         . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
1109                                                                 }
1110  ***      0                                  0                  $self->save_error("--$long is not allowed with $err");
1111                                                              }
1112                                                           }
1113                                                  
1114                                                        }
1115                                                        elsif ( $opt->{is_required} ) { 
1116  ***      0                                  0            $self->save_error("Required option --$long must be specified");
1117                                                        }
1118                                                  
1119  ***      0                                  0         $self->_validate_type($opt);
1120                                                     }
1121                                                  
1122  ***      0                                  0      $self->{got_opts} = 1;
1123  ***      0                                  0      return;
1124                                                  }
1125                                                  
1126                                                  sub _validate_type {
1127  ***      0                    0             0      my ( $self, $opt ) = @_;
1128  ***      0      0      0                    0      return unless $opt && $opt->{type};
1129  ***      0                                  0      my $val = $opt->{value};
1130                                                  
1131  ***      0      0      0                    0      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***             0      0                        
      ***                    0                        
      ***                    0                        
1132  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
1133  ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
1134  ***      0      0                           0         if ( !$suffix ) {
1135  ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
1136  ***      0             0                    0            $suffix = $s || 's';
1137  ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
1138                                                              $opt->{long}, '(value:', $val, ')');
1139                                                        }
1140  ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
1141  ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
1142                                                                : $suffix eq 'm' ? $num * 60       # Minutes
1143                                                                : $suffix eq 'h' ? $num * 3600     # Hours
1144                                                                :                  $num * 86400;   # Days
1145  ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
1146  ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
1147                                                        }
1148                                                        else {
1149  ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
1150                                                        }
1151                                                     }
1152                                                     elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
1153  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
1154  ***      0                                  0         my $prev = {};
1155  ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
1156  ***      0      0                           0         if ( $from_key ) {
1157  ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
1158  ***      0                                  0            $prev = $self->{opts}->{$from_key}->{value};
1159                                                        }
1160  ***      0                                  0         my $defaults = $self->{dp}->parse_options($self);
1161  ***      0                                  0         $opt->{value} = $self->{dp}->parse($val, $prev, $defaults);
1162                                                     }
1163                                                     elsif ( $val && $opt->{type} eq 'z' ) {  # type size
1164  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
1165  ***      0                                  0         my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
1166  ***      0                                  0         my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
1167  ***      0      0                           0         if ( defined $num ) {
1168  ***      0      0                           0            if ( $factor ) {
1169  ***      0                                  0               $num *= $factor_for{$factor};
1170  ***      0                                  0               MKDEBUG && _d('Setting option', $opt->{y},
1171                                                                 'to num', $num, '* factor', $factor);
1172                                                           }
1173  ***      0             0                    0            $opt->{value} = ($pre || '') . $num;
1174                                                        }
1175                                                        else {
1176  ***      0                                  0            $self->save_error("Invalid size for --$opt->{long}");
1177                                                        }
1178                                                     }
1179                                                     elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
1180  ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
      ***      0                                  0   
1181                                                     }
1182                                                     elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
1183  ***      0             0                    0         $opt->{value} = [ split(/(?<!\\),/, ($val || '')) ];
1184                                                     }
1185                                                     else {
1186  ***      0                                  0         MKDEBUG && _d('Nothing to validate for option',
1187                                                           $opt->{long}, 'type', $opt->{type}, 'value', $val);
1188                                                     }
1189                                                  
1190  ***      0                                  0      return;
1191                                                  }
1192                                                  
1193                                                  sub get {
1194  ***      0                    0             0      my ( $self, $opt ) = @_;
1195  ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1196  ***      0      0      0                    0      die "Option $opt does not exist"
1197                                                        unless $long && exists $self->{opts}->{$long};
1198  ***      0                                  0      return $self->{opts}->{$long}->{value};
1199                                                  }
1200                                                  
1201                                                  sub got {
1202  ***      0                    0             0      my ( $self, $opt ) = @_;
1203  ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1204  ***      0      0      0                    0      die "Option $opt does not exist"
1205                                                        unless $long && exists $self->{opts}->{$long};
1206  ***      0                                  0      return $self->{opts}->{$long}->{got};
1207                                                  }
1208                                                  
1209                                                  sub has {
1210  ***      0                    0             0      my ( $self, $opt ) = @_;
1211  ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1212  ***      0      0                           0      return defined $long ? exists $self->{opts}->{$long} : 0;
1213                                                  }
1214                                                  
1215                                                  sub set {
1216  ***      0                    0             0      my ( $self, $opt, $val ) = @_;
1217  ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1218  ***      0      0      0                    0      die "Option $opt does not exist"
1219                                                        unless $long && exists $self->{opts}->{$long};
1220  ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
1221  ***      0                                  0      return;
1222                                                  }
1223                                                  
1224                                                  sub save_error {
1225  ***      0                    0             0      my ( $self, $error ) = @_;
1226  ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
1227                                                  }
1228                                                  
1229                                                  sub errors {
1230  ***      0                    0             0      my ( $self ) = @_;
1231  ***      0                                  0      return $self->{errors};
1232                                                  }
1233                                                  
1234                                                  sub prompt {
1235  ***      0                    0             0      my ( $self ) = @_;
1236  ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
1237                                                  }
1238                                                  
1239                                                  sub descr {
1240  ***      0                    0             0      my ( $self ) = @_;
1241  ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
1242                                                                . "  For more details, please use the --help option, "
1243                                                                . "or try 'perldoc $PROGRAM_NAME' "
1244                                                                . "for complete documentation.";
1245  ***      0                                  0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g);
1246  ***      0                                  0      $descr =~ s/ +$//mg;
1247  ***      0                                  0      return $descr;
1248                                                  }
1249                                                  
1250                                                  sub usage_or_errors {
1251  ***      0                    0             0      my ( $self ) = @_;
1252  ***      0      0                           0      if ( $self->{opts}->{help}->{got} ) {
      ***      0      0                           0   
1253  ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
1254  ***      0                                  0         exit 0;
1255                                                     }
1256                                                     elsif ( scalar @{$self->{errors}} ) {
1257  ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
1258  ***      0                                  0         exit 0;
1259                                                     }
1260  ***      0                                  0      return;
1261                                                  }
1262                                                  
1263                                                  sub print_errors {
1264  ***      0                    0             0      my ( $self ) = @_;
1265  ***      0                                  0      my $usage = $self->prompt() . "\n";
1266  ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
1267  ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
1268                                                                . "\n";
1269                                                     }
1270  ***      0                                  0      return $usage . "\n" . $self->descr();
1271                                                  }
1272                                                  
1273                                                  sub print_usage {
1274  ***      0                    0             0      my ( $self ) = @_;
1275  ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
1276  ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
1277                                                  
1278  ***      0      0                           0      my $maxl = max(
1279  ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
1280                                                        @opts);
1281                                                  
1282  ***      0      0                           0      my $maxs = max(0,
1283  ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
1284  ***      0                                  0         values %{$self->{short_opts}});
1285                                                  
1286  ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
1287  ***      0                                  0      my $rcol = 80 - $lcol - 6;
1288  ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
1289                                                  
1290  ***      0                                  0      $maxs = max($lcol - 3, $maxs);
1291                                                  
1292  ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
1293                                                  
1294  ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
1295  ***      0                                  0      push @groups, 'default';
1296                                                  
1297  ***      0                                  0      foreach my $group ( reverse @groups ) {
1298  ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
1299  ***      0                                  0         foreach my $opt (
      ***      0                                  0   
1300  ***      0                                  0            sort { $a->{long} cmp $b->{long} }
1301                                                           grep { $_->{group} eq $group }
1302                                                           @opts )
1303                                                        {
1304  ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
1305  ***      0                                  0            my $short = $opt->{short};
1306  ***      0                                  0            my $desc  = $opt->{desc};
1307  ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
1308  ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
1309  ***      0             0                    0               $s    ||= 's';
1310  ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
1311  ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
1312                                                                     . "d=days; if no suffix, $s is used.";
1313                                                           }
1314  ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
1315  ***      0                                  0            $desc =~ s/ +$//mg;
1316  ***      0      0                           0            if ( $short ) {
1317  ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
1318                                                           }
1319                                                           else {
1320  ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
1321                                                           }
1322                                                        }
1323                                                     }
1324                                                  
1325  ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
1326  ***      0                                  0         $usage .= "\nRules:\n\n";
1327  ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
1328                                                     }
1329  ***      0      0                           0      if ( $self->{dp} ) {
1330  ***      0                                  0         $usage .= "\n" . $self->{dp}->usage();
1331                                                     }
1332  ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
1333  ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
1334  ***      0                                  0         my $val   = $opt->{value};
1335  ***      0             0                    0         my $type  = $opt->{type} || '';
1336  ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
1337  ***      0      0                           0         $val      = $bool                     ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
1338                                                                  : !defined $val             ? '(No value)'
1339                                                                  : $type eq 'd'              ? $self->{dp}->as_string($val)
1340                                                                  : $type =~ m/H|h/           ? join(',', sort keys %$val)
1341                                                                  : $type =~ m/A|a/           ? join(',', @$val)
1342                                                                  :                             $val;
1343  ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
1344                                                     }
1345  ***      0                                  0      return $usage;
1346                                                  }
1347                                                  
1348                                                  sub prompt_noecho {
1349  ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
1350  ***      0                                  0      my ( $prompt ) = @_;
1351  ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
1352  ***      0      0                           0      print $prompt
1353                                                        or die "Cannot print: $OS_ERROR";
1354  ***      0                                  0      my $response;
1355  ***      0                                  0      eval {
1356  ***      0                                  0         require Term::ReadKey;
1357  ***      0                                  0         Term::ReadKey::ReadMode('noecho');
1358  ***      0                                  0         chomp($response = <STDIN>);
1359  ***      0                                  0         Term::ReadKey::ReadMode('normal');
1360  ***      0      0                           0         print "\n"
1361                                                           or die "Cannot print: $OS_ERROR";
1362                                                     };
1363  ***      0      0                           0      if ( $EVAL_ERROR ) {
1364  ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
1365                                                     }
1366  ***      0                                  0      return $response;
1367                                                  }
1368                                                  
1369                                                  if ( MKDEBUG ) {
1370                                                     print '# ', $^X, ' ', $], "\n";
1371                                                     my $uname = `uname -a`;
1372                                                     if ( $uname ) {
1373                                                        $uname =~ s/\s+/ /g;
1374                                                        print "# $uname\n";
1375                                                     }
1376                                                     printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
1377                                                        $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
1378                                                        ($main::SVN_REV || ''), __LINE__);
1379                                                     print('# Arguments: ',
1380                                                        join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
1381                                                  }
1382                                                  
1383                                                  sub _read_config_file {
1384  ***      0                    0             0      my ( $self, $filename ) = @_;
1385  ***      0      0                           0      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
1386  ***      0                                  0      my @args;
1387  ***      0                                  0      my $prefix = '--';
1388  ***      0                                  0      my $parse  = 1;
1389                                                  
1390                                                     LINE:
1391  ***      0                                  0      while ( my $line = <$fh> ) {
1392  ***      0                                  0         chomp $line;
1393  ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
1394  ***      0                                  0         $line =~ s/\s+#.*$//g;
1395  ***      0                                  0         $line =~ s/^\s+|\s+$//g;
1396  ***      0      0                           0         if ( $line eq '--' ) {
1397  ***      0                                  0            $prefix = '';
1398  ***      0                                  0            $parse  = 0;
1399  ***      0                                  0            next LINE;
1400                                                        }
1401  ***      0      0      0                    0         if ( $parse
      ***             0                               
1402                                                           && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
1403                                                        ) {
1404  ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
1405                                                        }
1406                                                        elsif ( $line =~ m/./ ) {
1407  ***      0                                  0            push @args, $line;
1408                                                        }
1409                                                        else {
1410  ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
1411                                                        }
1412                                                     }
1413  ***      0                                  0      close $fh;
1414  ***      0                                  0      return @args;
1415                                                  }
1416                                                  
1417                                                  sub read_para_after {
1418  ***      0                    0             0      my ( $self, $file, $regex ) = @_;
1419  ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
1420  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
1421  ***      0                                  0      my $para;
1422  ***      0                                  0      while ( $para = <$fh> ) {
1423  ***      0      0                           0         next unless $para =~ m/^=pod$/m;
1424  ***      0                                  0         last;
1425                                                     }
1426  ***      0                                  0      while ( $para = <$fh> ) {
1427  ***      0      0                           0         next unless $para =~ m/$regex/;
1428  ***      0                                  0         last;
1429                                                     }
1430  ***      0                                  0      $para = <$fh>;
1431  ***      0                                  0      chomp($para);
1432  ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
1433  ***      0                                  0      return $para;
1434                                                  }
1435                                                  
1436                                                  sub clone {
1437  ***      0                    0             0      my ( $self ) = @_;
1438                                                  
1439  ***      0                                  0      my %clone = map {
1440  ***      0                                  0         my $hashref  = $self->{$_};
1441  ***      0                                  0         my $val_copy = {};
1442  ***      0                                  0         foreach my $key ( keys %$hashref ) {
1443  ***      0                                  0            my $ref = ref $hashref->{$key};
1444  ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
1445  ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
1446  ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
1447                                                                             : $hashref->{$key};
1448                                                        }
1449  ***      0                                  0         $_ => $val_copy;
1450                                                     } qw(opts short_opts defaults);
1451                                                  
1452  ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
1453  ***      0                                  0         $clone{$scalar} = $self->{$scalar};
1454                                                     }
1455                                                  
1456  ***      0                                  0      return bless \%clone;     
1457                                                  }
1458                                                  
1459                                                  sub _d {
1460  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1461  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1462  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1463                                                          @_;
1464  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1465                                                  }
1466                                                  
1467                                                  1;
1468                                                  
1469                                                  # ###########################################################################
1470                                                  # End OptionParser package
1471                                                  # ###########################################################################
1472                                                  
1473                                                  # ###########################################################################
1474                                                  # DSNParser package 5266
1475                                                  # ###########################################################################
1476                                                  package DSNParser;
1477                                                  
1478           2                    2            23   use strict;
               2                                  4   
               2                                 18   
1479           2                    2            13   use warnings FATAL => 'all';
               2                                  6   
               2                                 14   
1480           2                    2            12   use English qw(-no_match_vars);
               2                                  4   
               2                                 14   
1481           2                    2            14   use Data::Dumper;
               2                                  4   
               2                                 18   
1482                                                  $Data::Dumper::Indent    = 0;
1483                                                  $Data::Dumper::Quotekeys = 0;
1484                                                  
1485                                                  eval {
1486                                                     require DBI;
1487                                                  };
1488                                                  my $have_dbi = $EVAL_ERROR ? 0 : 1;
1489                                                  
1490  ***      2            50      2            19   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               2                                  5   
               2                                 31   
1491                                                  
1492                                                  sub new {
1493           2                    2            10      my ( $class, @opts ) = @_;
1494           2                                 55      my $self = {
1495                                                        opts => {
1496                                                           A => {
1497                                                              desc => 'Default character set',
1498                                                              dsn  => 'charset',
1499                                                              copy => 1,
1500                                                           },
1501                                                           D => {
1502                                                              desc => 'Database to use',
1503                                                              dsn  => 'database',
1504                                                              copy => 1,
1505                                                           },
1506                                                           F => {
1507                                                              desc => 'Only read default options from the given file',
1508                                                              dsn  => 'mysql_read_default_file',
1509                                                              copy => 1,
1510                                                           },
1511                                                           h => {
1512                                                              desc => 'Connect to host',
1513                                                              dsn  => 'host',
1514                                                              copy => 1,
1515                                                           },
1516                                                           p => {
1517                                                              desc => 'Password to use when connecting',
1518                                                              dsn  => 'password',
1519                                                              copy => 1,
1520                                                           },
1521                                                           P => {
1522                                                              desc => 'Port number to use for connection',
1523                                                              dsn  => 'port',
1524                                                              copy => 1,
1525                                                           },
1526                                                           S => {
1527                                                              desc => 'Socket file to use for connection',
1528                                                              dsn  => 'mysql_socket',
1529                                                              copy => 1,
1530                                                           },
1531                                                           u => {
1532                                                              desc => 'User for login if not current user',
1533                                                              dsn  => 'user',
1534                                                              copy => 1,
1535                                                           },
1536                                                        },
1537                                                     };
1538           2                                 10      foreach my $opt ( @opts ) {
1539  ***      0                                  0         MKDEBUG && _d('Adding extra property', $opt->{key});
1540  ***      0                                  0         $self->{opts}->{$opt->{key}} = { desc => $opt->{desc}, copy => $opt->{copy} };
1541                                                     }
1542           2                                 28      return bless $self, $class;
1543                                                  }
1544                                                  
1545                                                  sub prop {
1546           6                    6            32      my ( $self, $prop, $value ) = @_;
1547  ***      6     50                          32      if ( @_ > 2 ) {
1548  ***      0                                  0         MKDEBUG && _d('Setting', $prop, 'property');
1549  ***      0                                  0         $self->{$prop} = $value;
1550                                                     }
1551           6                                 67      return $self->{$prop};
1552                                                  }
1553                                                  
1554                                                  sub parse {
1555           2                    2            94      my ( $self, $dsn, $prev, $defaults ) = @_;
1556  ***      2     50                          11      if ( !$dsn ) {
1557  ***      0                                  0         MKDEBUG && _d('No DSN to parse');
1558  ***      0                                  0         return;
1559                                                     }
1560           2                                  5      MKDEBUG && _d('Parsing', $dsn);
1561  ***      2            50                   10      $prev     ||= {};
1562  ***      2            50                   10      $defaults ||= {};
1563           2                                  4      my %given_props;
1564           2                                  6      my %final_props;
1565           2                                  7      my %opts = %{$self->{opts}};
               2                                 18   
1566                                                  
1567           2                                 19      foreach my $dsn_part ( split(/,/, $dsn) ) {
1568  ***      8     50                          75         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1569           8                                 40            $given_props{$prop_key} = $prop_val;
1570                                                        }
1571                                                        else {
1572  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1573  ***      0                                  0            $given_props{h} = $dsn_part;
1574                                                        }
1575                                                     }
1576                                                  
1577           2                                 13      foreach my $key ( keys %opts ) {
1578          16                                 33         MKDEBUG && _d('Finding value for', $key);
1579          16                                 58         $final_props{$key} = $given_props{$key};
1580  ***     16     50     66                  236         if (   !defined $final_props{$key}
      ***                   33                        
1581                                                             && defined $prev->{$key} && $opts{$key}->{copy} )
1582                                                        {
1583  ***      0                                  0            $final_props{$key} = $prev->{$key};
1584  ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1585                                                        }
1586          16    100                          75         if ( !defined $final_props{$key} ) {
1587           8                                 25            $final_props{$key} = $defaults->{$key};
1588           8                                 24            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1589                                                        }
1590                                                     }
1591                                                  
1592           2                                 11      foreach my $key ( keys %given_props ) {
1593  ***      8     50                          37         die "Unrecognized DSN part '$key' in '$dsn'\n"
1594                                                           unless exists $opts{$key};
1595                                                     }
1596  ***      2     50                          11      if ( (my $required = $self->prop('required')) ) {
1597  ***      0                                  0         foreach my $key ( keys %$required ) {
1598  ***      0      0                           0            die "Missing DSN part '$key' in '$dsn'\n" unless $final_props{$key};
1599                                                        }
1600                                                     }
1601                                                  
1602           2                                 15      return \%final_props;
1603                                                  }
1604                                                  
1605                                                  sub parse_options {
1606  ***      0                    0             0      my ( $self, $o ) = @_;
1607  ***      0      0                           0      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1608  ***      0                                  0      my $dsn_string
1609                                                        = join(',',
1610  ***      0      0                           0             map  { "$_=".$o->get($_); }
1611  ***      0                                  0             grep { $o->has($_) && $o->get($_) }
1612  ***      0                                  0             keys %{$self->{opts}}
1613                                                          );
1614  ***      0                                  0      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1615  ***      0                                  0      return $self->parse($dsn_string);
1616                                                  }
1617                                                  
1618                                                  sub as_string {
1619  ***      0                    0             0      my ( $self, $dsn ) = @_;
1620  ***      0      0                           0      return $dsn unless ref $dsn;
1621  ***      0      0                           0      return join(',',
1622  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_}) }
1623  ***      0                                  0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1624                                                        sort keys %$dsn );
1625                                                  }
1626                                                  
1627                                                  sub usage {
1628  ***      0                    0             0      my ( $self ) = @_;
1629  ***      0                                  0      my $usage
1630                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1631                                                        . "  KEY  COPY  MEANING\n"
1632                                                        . "  ===  ====  =============================================\n";
1633  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1634  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1635  ***      0      0      0                    0         $usage .= "  $key    "
1636                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1637                                                               .  ($opts{$key}->{desc} || '[No description]')
1638                                                               . "\n";
1639                                                     }
1640  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1641  ***      0                                  0      return $usage;
1642                                                  }
1643                                                  
1644                                                  sub get_cxn_params {
1645           2                    2            28      my ( $self, $info ) = @_;
1646           2                                  5      my $dsn;
1647           2                                  6      my %opts = %{$self->{opts}};
               2                                 17   
1648  ***      2            50                   11      my $driver = $self->prop('dbidriver') || '';
1649  ***      2     50                           9      if ( $driver eq 'Pg' ) {
1650  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1651  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1652  ***      0             0                    0                        grep { defined $info->{$_} }
1653                                                                       qw(h P));
1654                                                     }
1655                                                     else {
1656           4                                 29         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1657          10                                 40            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1658  ***      2            50                   26                        grep { defined $info->{$_} }
1659                                                                       qw(F h P S A))
1660                                                           . ';mysql_read_default_group=client';
1661                                                     }
1662           2                                  8      MKDEBUG && _d($dsn);
1663           2                                 17      return ($dsn, $info->{u}, $info->{p});
1664                                                  }
1665                                                  
1666                                                  sub fill_in_dsn {
1667  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1668  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1669  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1670  ***      0                                  0      $user =~ s/@.*//;
1671  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1672  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1673  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1674  ***      0             0                    0      $dsn->{u} ||= $user;
1675  ***      0             0                    0      $dsn->{D} ||= $db;
1676                                                  }
1677                                                  
1678                                                  sub get_dbh {
1679           2                    2            14      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1680  ***      2            50                   11      $opts ||= {};
1681  ***      2     50                          22      my $defaults = {
1682                                                        AutoCommit         => 0,
1683                                                        RaiseError         => 1,
1684                                                        PrintError         => 0,
1685                                                        ShowErrorStatement => 1,
1686                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1687                                                     };
1688           2                                 11      @{$defaults}{ keys %$opts } = values %$opts;
               2                                  8   
1689                                                  
1690  ***      2     50                          10      if ( !$have_dbi ) {
1691  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1692                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1693                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1694                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1695                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1696                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1697                                                  
1698                                                     }
1699                                                  
1700           2                                  6      my $dbh;
1701           2                                  7      my $tries = 2;
1702  ***      2            66                   22      while ( !$dbh && $tries-- ) {
1703                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1704           2                                  5            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1705                                                  
1706           2                                  6         eval {
1707           2                                 15            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1708                                                  
1709  ***      2     50                          25            if ( $cxn_string =~ m/mysql/i ) {
1710           2                                  7               my $sql;
1711                                                  
1712           2                                  8               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1713                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1714           2                                  5               MKDEBUG && _d($dbh, ':', $sql);
1715           2                                278               $dbh->do($sql);
1716                                                  
1717  ***      2     50                          19               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1718  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1719  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1720  ***      0                                  0                  $dbh->do($sql);
1721  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1722  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1723  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1724                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1725                                                                 }
1726                                                                 else {
1727  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1728                                                                 }
1729                                                              }
1730                                                  
1731  ***      2     50                          13               if ( $self->prop('set-vars') ) {
1732  ***      0                                  0                  $sql = "SET " . $self->prop('set-vars');
1733  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1734  ***      0                                  0                  $dbh->do($sql);
1735                                                              }
1736                                                           }
1737                                                        };
1738  ***      2     50     33                   25         if ( !$dbh && $EVAL_ERROR ) {
1739  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1740  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1741  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1742  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1743                                                           }
1744                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1745  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1746                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1747                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1748                                                                 . "DBD::mysql is not installed, try:\n"
1749                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1750                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1751                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1752                                                           }
1753  ***      0      0                           0            if ( !$tries ) {
1754  ***      0                                  0               die $EVAL_ERROR;
1755                                                           }
1756                                                        }
1757                                                     }
1758                                                  
1759           2                                  5      MKDEBUG && _d('DBH info: ',
1760                                                        $dbh,
1761                                                        Dumper($dbh->selectrow_hashref(
1762                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1763                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1764                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1765                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1766                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1767                                                        '$DBI::VERSION:',        $DBI::VERSION,
1768                                                     );
1769                                                  
1770           2                                 15      return $dbh;
1771                                                  }
1772                                                  
1773                                                  sub get_hostname {
1774  ***      0                    0                    my ( $self, $dbh ) = @_;
1775  ***      0      0      0                           if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1776  ***      0                                            return $host;
1777                                                     }
1778  ***      0                                         my ( $hostname, $one ) = $dbh->selectrow_array(
1779                                                        'SELECT /*!50038 @@hostname, */ 1');
1780  ***      0                                         return $hostname;
1781                                                  }
1782                                                  
1783                                                  sub disconnect {
1784  ***      0                    0                    my ( $self, $dbh ) = @_;
1785  ***      0                                         MKDEBUG && $self->print_active_handles($dbh);
1786  ***      0                                         $dbh->disconnect;
1787                                                  }
1788                                                  
1789                                                  sub print_active_handles {
1790  ***      0                    0                    my ( $self, $thing, $level ) = @_;
1791  ***      0             0                           $level ||= 0;
1792  ***      0      0      0                           printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1793                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1794                                                        or die "Cannot print: $OS_ERROR";
1795  ***      0                                         foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                      
      ***      0                                      
1796  ***      0                                            $self->print_active_handles( $handle, $level + 1 );
1797                                                     }
1798                                                  }
1799                                                  
1800                                                  sub copy {
1801  ***      0                    0                    my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1802  ***      0      0                                  die 'I need a dsn_1 argument' unless $dsn_1;
1803  ***      0      0                                  die 'I need a dsn_2 argument' unless $dsn_2;
1804  ***      0                                         my %new_dsn = map {
1805  ***      0                                            my $key = $_;
1806  ***      0                                            my $val;
1807  ***      0      0                                     if ( $args{overwrite} ) {
1808  ***      0      0                                        $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1809                                                        }
1810                                                        else {
1811  ***      0      0                                        $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1812                                                        }
1813  ***      0                                            $key => $val;
1814  ***      0                                         } keys %{$self->{opts}};
1815  ***      0                                         return \%new_dsn;
1816                                                  }
1817                                                  
1818                                                  sub _d {
1819  ***      0                    0                    my ($package, undef, $line) = caller 0;
1820  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
1821  ***      0                                              map { defined $_ ? $_ : 'undef' }
1822                                                          @_;
1823  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1824                                                  }
1825                                                  
1826                                                  1;
1827                                                  
1828                                                  # ###########################################################################
1829                                                  # End DSNParser package
1830                                                  # ###########################################################################
1831                                                  
1832                                                  # ###########################################################################
1833                                                  # Daemon package 5266
1834                                                  # ###########################################################################
1835                                                  
1836                                                  package Daemon;
1837                                                  
1838           2                    2            17   use strict;
               2                                  4   
               2                                 12   
1839           2                    2            12   use warnings FATAL => 'all';
               2                                  6   
               2                                 10   
1840                                                  
1841           2                    2            13   use POSIX qw(setsid);
               2                                  5   
               2                                 14   
1842           2                    2            12   use English qw(-no_match_vars);
               2                                  5   
               2                                 15   
1843                                                  
1844  ***      2            50      2            12   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               2                                  5   
               2                                 27   
1845                                                  
1846                                                  sub new {
1847  ***      0                    0                    my ( $class, %args ) = @_;
1848  ***      0                                         foreach my $arg ( qw(o) ) {
1849  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
1850                                                     }
1851  ***      0                                         my $o = $args{o};
1852  ***      0      0                                  my $self = {
      ***             0                               
1853                                                        o        => $o,
1854                                                        log_file => $o->has('log') ? $o->get('log') : undef,
1855                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
1856                                                     };
1857                                                  
1858  ***      0                                         check_PID_file(undef, $self->{PID_file});
1859                                                  
1860  ***      0                                         MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
1861  ***      0                                         return bless $self, $class;
1862                                                  }
1863                                                  
1864                                                  sub daemonize {
1865  ***      0                    0                    my ( $self ) = @_;
1866                                                  
1867  ***      0                                         MKDEBUG && _d('About to fork and daemonize');
1868  ***      0      0                                  defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
1869  ***      0      0                                  if ( $pid ) {
1870  ***      0                                            MKDEBUG && _d('I am the parent and now I die');
1871  ***      0                                            exit;
1872                                                     }
1873                                                  
1874  ***      0                                         $self->{child} = 1;
1875                                                  
1876  ***      0      0                                  POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
1877  ***      0      0                                  chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
1878                                                  
1879  ***      0                                         $self->_make_PID_file();
1880                                                  
1881  ***      0                                         $OUTPUT_AUTOFLUSH = 1;
1882                                                  
1883  ***      0      0                                  if ( -t STDIN ) {
1884  ***      0                                            close STDIN;
1885  ***      0      0                                     open  STDIN, '/dev/null'
1886                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
1887                                                     }
1888                                                  
1889  ***      0      0                                  if ( $self->{log_file} ) {
1890  ***      0                                            close STDOUT;
1891  ***      0      0                                     open  STDOUT, '>>', $self->{log_file}
1892                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
1893                                                  
1894  ***      0                                            close STDERR;
1895  ***      0      0                                     open  STDERR, ">&STDOUT"
1896                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
1897                                                     }
1898                                                     else {
1899  ***      0      0                                     if ( -t STDOUT ) {
1900  ***      0                                               close STDOUT;
1901  ***      0      0                                        open  STDOUT, '>', '/dev/null'
1902                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
1903                                                        }
1904  ***      0      0                                     if ( -t STDERR ) {
1905  ***      0                                               close STDERR;
1906  ***      0      0                                        open  STDERR, '>', '/dev/null'
1907                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
1908                                                        }
1909                                                     }
1910                                                  
1911  ***      0                                         MKDEBUG && _d('I am the child and now I live daemonized');
1912  ***      0                                         return;
1913                                                  }
1914                                                  
1915                                                  sub check_PID_file {
1916  ***      0                    0                    my ( $self, $file ) = @_;
1917  ***      0      0                                  my $PID_file = $self ? $self->{PID_file} : $file;
1918  ***      0                                         MKDEBUG && _d('Checking PID file', $PID_file);
1919  ***      0      0      0                           if ( $PID_file && -f $PID_file ) {
1920  ***      0                                            my $pid;
1921  ***      0                                            eval { chomp($pid = `cat $PID_file`); };
      ***      0                                      
1922  ***      0      0                                     die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
1923  ***      0                                            MKDEBUG && _d('PID file exists; it contains PID', $pid);
1924  ***      0      0                                     if ( $pid ) {
1925  ***      0                                               my $pid_is_alive = kill 0, $pid;
1926  ***      0      0                                        if ( $pid_is_alive ) {
1927  ***      0                                                  die "The PID file $PID_file already exists "
1928                                                                 . " and the PID that it contains, $pid, is running";
1929                                                           }
1930                                                           else {
1931  ***      0                                                  warn "Overwriting PID file $PID_file because the PID that it "
1932                                                                 . "contains, $pid, is not running";
1933                                                           }
1934                                                        }
1935                                                        else {
1936  ***      0                                               die "The PID file $PID_file already exists but it does not "
1937                                                              . "contain a PID";
1938                                                        }
1939                                                     }
1940                                                     else {
1941  ***      0                                            MKDEBUG && _d('No PID file');
1942                                                     }
1943  ***      0                                         return;
1944                                                  }
1945                                                  
1946                                                  sub make_PID_file {
1947  ***      0                    0                    my ( $self ) = @_;
1948  ***      0      0                                  if ( exists $self->{child} ) {
1949  ***      0                                            die "Do not call Daemon::make_PID_file() for daemonized scripts";
1950                                                     }
1951  ***      0                                         $self->_make_PID_file();
1952  ***      0                                         $self->{rm_PID_file} = 1;
1953  ***      0                                         return;
1954                                                  }
1955                                                  
1956                                                  sub _make_PID_file {
1957  ***      0                    0                    my ( $self ) = @_;
1958                                                  
1959  ***      0                                         my $PID_file = $self->{PID_file};
1960  ***      0      0                                  if ( !$PID_file ) {
1961  ***      0                                            MKDEBUG && _d('No PID file to create');
1962  ***      0                                            return;
1963                                                     }
1964                                                  
1965  ***      0                                         $self->check_PID_file();
1966                                                  
1967  ***      0      0                                  open my $PID_FH, '>', $PID_file
1968                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
1969  ***      0      0                                  print $PID_FH $PID
1970                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
1971  ***      0      0                                  close $PID_FH
1972                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
1973                                                  
1974  ***      0                                         MKDEBUG && _d('Created PID file:', $self->{PID_file});
1975  ***      0                                         return;
1976                                                  }
1977                                                  
1978                                                  sub _remove_PID_file {
1979  ***      0                    0                    my ( $self ) = @_;
1980  ***      0      0      0                           if ( $self->{PID_file} && -f $self->{PID_file} ) {
1981  ***      0      0                                     unlink $self->{PID_file}
1982                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
1983  ***      0                                            MKDEBUG && _d('Removed PID file');
1984                                                     }
1985                                                     else {
1986  ***      0                                            MKDEBUG && _d('No PID to remove');
1987                                                     }
1988  ***      0                                         return;
1989                                                  }
1990                                                  
1991                                                  sub DESTROY {
1992  ***      0                    0                    my ( $self ) = @_;
1993  ***      0      0      0                           $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
1994  ***      0                                         return;
1995                                                  }
1996                                                  
1997                                                  sub _d {
1998  ***      0                    0                    my ($package, undef, $line) = caller 0;
1999  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2000  ***      0                                              map { defined $_ ? $_ : 'undef' }
2001                                                          @_;
2002  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2003                                                  }
2004                                                  
2005                                                  1;
2006                                                  
2007                                                  # ###########################################################################
2008                                                  # End Daemon package
2009                                                  # ###########################################################################
2010                                                  
2011                                                  # ###########################################################################
2012                                                  # Quoter package 5266
2013                                                  # ###########################################################################
2014           2                    2            13   use strict;
               2                                  6   
               2                                 13   
2015           2                    2            11   use warnings FATAL => 'all';
               2                                  5   
               2                                 14   
2016                                                  
2017                                                  package Quoter;
2018                                                  
2019           2                    2            11   use English qw(-no_match_vars);
               2                                  4   
               2                                 10   
2020                                                  
2021  ***      2            50      2            12   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               2                                  8   
               2                                 27   
2022                                                  
2023                                                  sub new {
2024  ***      0                    0                    my ( $class ) = @_;
2025  ***      0                                         bless {}, $class;
2026                                                  }
2027                                                  
2028                                                  sub quote {
2029  ***      0                    0                    my ( $self, @vals ) = @_;
2030  ***      0                                         foreach my $val ( @vals ) {
2031  ***      0                                            $val =~ s/`/``/g;
2032                                                     }
2033  ***      0                                         return join('.', map { '`' . $_ . '`' } @vals);
      ***      0                                      
2034                                                  }
2035                                                  
2036                                                  sub quote_val {
2037  ***      0                    0                    my ( $self, $val, $is_numeric ) = @_;
2038                                                  
2039  ***      0      0                                  return 'NULL' unless defined $val;  # undef = NULL
2040  ***      0      0                                  return "''" if $val eq '';          # blank string = ''
2041                                                  
2042  ***      0      0                                  if ( !defined $is_numeric ) {
2043  ***      0      0                                     $is_numeric = $val =~ m/^0|\D/ ? 0 : 1;
2044                                                     }
2045                                                  
2046  ***      0      0                                  return $val if $is_numeric;
2047                                                  
2048  ***      0                                         $val =~ s/(['\\])/\\$1/g;
2049  ***      0                                         return "'$val'";
2050                                                  }
2051                                                  
2052                                                  sub split_unquote {
2053  ***      0                    0                    my ( $self, $db_tbl, $default_db ) = @_;
2054  ***      0                                         $db_tbl =~ s/`//g;
2055  ***      0                                         my ( $db, $tbl ) = split(/[.]/, $db_tbl);
2056  ***      0      0                                  if ( !$tbl ) {
2057  ***      0                                            $tbl = $db;
2058  ***      0                                            $db  = $default_db;
2059                                                     }
2060  ***      0                                         return ($db, $tbl);
2061                                                  }
2062                                                  
2063                                                  sub literal_like {
2064  ***      0                    0                    my ( $self, $like ) = @_;
2065  ***      0      0                                  return unless $like;
2066  ***      0                                         $like =~ s/([%_])/\\$1/g;
2067  ***      0                                         return "'$like'";
2068                                                  }
2069                                                  
2070                                                  1;
2071                                                  
2072                                                  # ###########################################################################
2073                                                  # End Quoter package
2074                                                  # ###########################################################################
2075                                                  
2076                                                  # ###########################################################################
2077                                                  # This is a combination of modules and programs in one -- a runnable module.
2078                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
2079                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
2080                                                  #
2081                                                  # Check at the end of this package for the call to main() which actually runs
2082                                                  # the program.
2083                                                  # ###########################################################################
2084                                                  package mk_heartbeat;
2085                                                  
2086           2                    2            16   use English qw(-no_match_vars);
               2                                  7   
               2                                  9   
2087           2                    2            13   use List::Util qw(min max sum);
               2                                  6   
               2                                 11   
2088           2                    2            14   use Time::HiRes qw(usleep gettimeofday);
               2                                  4   
               2                                479   
2089           2                    2            13   use IO::File;
               2                                  5   
               2                                 25   
2090                                                  
2091  ***      2            50      2            23   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               2                                  5   
               2                                 34   
2092                                                  
2093                                                  my @dbhs;  # Holds slave DBHs if --recurse
2094                                                  my @sths;  # Holds [$host, $sth] if --recurse
2095                                                  
2096                                                  sub main {
2097  ***      0                    0                    @ARGV = @_;  # set global ARGV for this package
2098                                                  
2099                                                     # ########################################################################
2100                                                     # Get configuration information.
2101                                                     # ########################################################################
2102  ***      0                                         my $o = new OptionParser(
2103                                                        prompt      => '<options> {--update|--monitor|--check|--stop}',
2104                                                        description => q{measures replication lag on a MySQL or PostgreSQL }
2105                                                                     . q{server.  You can use it to update a master or }
2106                                                                     . q{monitor a slave.  If possible, MySQL connection }
2107                                                                     . q{options are read from your .my.cnf file.},
2108                                                     );
2109  ***      0                                         $o->get_specs();
2110  ***      0                                         $o->get_opts();
2111                                                  
2112  ***      0      0                                  if ( !$o->get('help') ) {
2113                                                  
2114  ***      0                                            my @frames = $o->get('frames') =~ m/(\d+[smhd])/g;
2115  ***      0      0                                     if ( @frames ) {
2116  ***      0                                               my @times;
2117  ***      0                                               foreach my $frame ( @frames ) {
2118  ***      0                                                  my ($num, $suf) = $frame =~ m/(\d+)([smhd])$/;
2119  ***      0      0                                           if ( !$num ) {
2120  ***      0                                                     $o->save_error("Invalid --frames argument");
2121                                                              }
2122                                                              else {
2123  ***      0      0                                              push @times, 
      ***             0                               
      ***             0                               
2124                                                                      $suf eq 's' ? $num            # Seconds
2125                                                                    : $suf eq 'm' ? $num * 60       # Minutes
2126                                                                    : $suf eq 'h' ? $num * 3600     # Hours
2127                                                                    :               $num * 86400;   # Days
2128                                                              }
2129                                                           }
2130  ***      0                                               $o->set('frames', \@times);
2131                                                        }
2132                                                        else {
2133  ***      0                                               $o->save_error("Invalid --frames argument");
2134                                                        }
2135                                                  
2136  ***      0      0      0                              if ( $o->get('create-table')
      ***                    0                        
2137                                                             && !($o->get('database') && $o->get('table'))) {
2138  ***      0                                               $o->save_error('--create-table requires both --database and --table');
2139                                                        }
2140                                                     }
2141                                                  
2142  ***      0                                         $o->set('interval', max($o->get('interval'), 1)); # Prevent 0-second interval
2143                                                  
2144  ***      0                                         $o->usage_or_errors();
2145                                                  
2146                                                     # Frequently used options.
2147  ***      0                                         my $interval = $o->get('interval');
2148  ***      0                                         my $sentinel = $o->get('sentinel');
2149  ***      0                                         my $table    = $o->get('table');
2150  ***      0                                         my $frames   = $o->get('frames');
2151                                                  
2152                                                     # ########################################################################
2153                                                     # First things first: if --stop was given, create the sentinel file.
2154                                                     # ########################################################################
2155  ***      0      0                                  if ( $o->get('stop') ) {
2156  ***      0                                            MKDEBUG && _d('Creating sentinel file', $sentinel);
2157  ***      0      0                                     my $file = IO::File->new($sentinel, ">>")
2158                                                           or die "Cannot open $sentinel: $OS_ERROR\n";
2159  ***      0      0                                     print $file "Remove this file to permit mk-heartbeat to run\n"
2160                                                           or die "Cannot write to $sentinel: $OS_ERROR\n";
2161  ***      0      0                                     close $file
2162                                                           or die "Cannot close $sentinel: $OS_ERROR\n";
2163  ***      0      0                                     print STDOUT "Successfully created file $sentinel\n"
2164                                                           unless $o->get('quiet');
2165                                                        # Exit only if no other action (update, monitor, check) is given.
2166  ***      0      0      0                              if ( !$o->get('update') && !$o->get('check') && !$o->get('monitor') ) {
      ***                    0                        
2167  ***      0                                               MKDEBUG && _d("Nothing more to do, quitting");
2168  ***      0                                               return 0;
2169                                                        }
2170                                                        else {
2171                                                           # Wait for all other running instances to quit, assuming they have the
2172                                                           # same --interval as this invocation.  Then remove the file and
2173                                                           # continue.
2174  ***      0                                               MKDEBUG && _d("Waiting for other instances to quit");
2175  ***      0                                               sleep($interval);
2176  ***      0                                               MKDEBUG && _d("Unlinking", $sentinel);
2177  ***      0      0                                        unlink $sentinel
2178                                                              or die "Cannot unlink $sentinel: $OS_ERROR";
2179                                                        }
2180                                                     }
2181                                                  
2182                                                     # ########################################################################
2183                                                     # Work.
2184                                                     # ########################################################################
2185  ***      0      0                                  my $update_sql = $o->get('replace')
2186                                                                    ? "REPLACE INTO $table(id, ts) VALUES(1, NOW())"
2187                                                                    : "UPDATE $table SET ts = NOW() WHERE id = 1";
2188  ***      0      0                                  my $select_sql = "SELECT "
2189                                                                    . ( $o->get('dbi-driver') eq 'Pg'
2190                                                                       ? "ROUND(DATE_PART('epoch', NOW() - ts)) AS delay"
2191                                                                       : 'UNIX_TIMESTAMP() - UNIX_TIMESTAMP(ts) AS delay/*!50038, @@hostname AS host*/' )
2192                                                                    . " FROM $table WHERE id = 1";
2193                                                  
2194  ***      0                                         MKDEBUG && _d("UPDATE SQL:", $update_sql);
2195  ***      0                                         MKDEBUG && _d("SELECT SQL:", $select_sql);
2196                                                  
2197                                                     # Get the password before daemonizing.
2198  ***      0      0                                  if ( $o->get('ask-pass') ) {
2199  ***      0                                            $o->set('password', OptionParser::prompt_noecho("Enter password: "));
2200                                                     }
2201                                                  
2202  ***      0                                         my $dp = new DSNParser;
2203  ***      0                                         $dp->prop('dbidriver', $o->get('dbi-driver'));
2204  ***      0                                         $dp->prop('set-vars', $o->get('set-vars'));
2205  ***      0                                         my $dsn = $dp->parse_options($o);
2206  ***      0                                         my $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), { AutoCommit => 1 });
2207  ***      0      0                                  my $sth = $dbh->prepare($o->get('update') ? $update_sql : $select_sql);
2208                                                  
2209  ***      0                                         $dbh->{InactiveDestroy}  = 1; # Don't disconnect on fork
2210                                                  
2211                                                     # Create the heartbeat table if desired.
2212  ***      0      0                                  if ( $o->get('create-table') ) {
2213  ***      0                                            my $q      = new Quoter();
2214  ***      0                                            my $db_tbl = $q->quote($o->get('database'), $o->get('table'));
2215  ***      0                                            my $sql    = $o->read_para_after(
2216                                                           __FILE__, qr/MAGIC_create_heartbeat/);
2217  ***      0                                            $sql =~ s/heartbeat/IF NOT EXISTS $db_tbl/;
2218  ***      0                                            MKDEBUG && _d($sql);
2219  ***      0                                            $dbh->do($sql);
2220                                                  
2221  ***      0                                            $sql = "INSERT INTO $db_tbl (id) VALUES (1)";
2222  ***      0                                            MKDEBUG && _d($sql);
2223                                                        # This may fail if the table already existed and already had this row.
2224                                                        # We eval to ignore this possibility.
2225  ***      0                                            eval { $dbh->do($sql); };
      ***      0                                      
2226                                                     }
2227                                                  
2228                                                     # Do a little check just to make sure the table is there, so there's one last
2229                                                     # chance to catch errors before daemonizing.
2230  ***      0                                         $sth->execute();
2231  ***      0                                         $sth->finish();
2232                                                  
2233                                                     # Check that heartbeat table has at least 1 row.
2234  ***      0                                         my $row = $dbh->selectall_arrayref("SELECT id FROM $table LIMIT 1");
2235  ***      0      0                                  if ( scalar @$row == 0 ) {
2236  ***      0                                            die "The heartbeat table is empty.\n"
2237                                                           . "At least one row must be inserted into the heartbeat table.\n"
2238                                                           . "Please read the DESCRIPTION section of the mk-heartbeat POD.\n";
2239                                                     }
2240                                                  
2241  ***      0                                         my $daemon;
2242  ***      0      0                                  if ( $o->get('daemonize') ) {
      ***             0                               
2243  ***      0                                            $daemon = new Daemon(o=>$o);
2244  ***      0                                            $daemon->daemonize();
2245  ***      0                                            MKDEBUG && _d('I am a daemon now');
2246                                                     }
2247                                                     elsif ( $o->get('pid') ) {
2248                                                        # We're not daemoninzing, it just handles PID stuff.
2249  ***      0                                            $daemon = new Daemon(o=>$o);
2250  ***      0                                            $daemon->make_PID_file();
2251                                                     }
2252                                                  
2253                                                     # Setup for moving averages.
2254  ***      0                                         my @samples;
2255  ***      0                                         my $limit  = max(@$frames);
2256  ***      0                                         my $format = "%4ds [ " . join(", ", map { "%5.2fs" } @$frames) . " ]\n";
      ***      0                                      
2257                                                  
2258  ***      0                                         my $now = time();
2259  ***      0             0                           my $end = $now + ($o->get('run-time') || 0);    # When to exit
2260  ***      0                                         MKDEBUG && _d('Will exit at', $end);
2261                                                  
2262                                                     # --monitor and --update run in a loop, but --check only checks once and
2263                                                     # exits.
2264  ***      0      0                                  if ( $o->get('check') ) { 
2265  ***      0                                            check_delay(
2266                                                           o          => $o,
2267                                                           dp         => $dp,
2268                                                           dsn        => $dsn,
2269                                                           dbh        => $dbh,
2270                                                           sth        => $sth,
2271                                                           select_sql => $select_sql,
2272                                                        );
2273  ***      0                                            disconnect($dbh, $sth);
2274  ***      0                                            return 0;
2275                                                     }
2276                                                  
2277                                                     # Quit if time is exceeded or sentinel exists.
2278  ***      0             0                           while ( (!$o->get('run-time') || $now < $end) && !-f $sentinel ) {
      ***                    0                        
2279  ***      0                                            eval {
2280                                                  
2281  ***      0                                               my @now = gettimeofday();
2282  ***      0      0                                        usleep(
2283                                                              (($interval - ($now[0] % $interval)) * 1_000_000) - $now[1]
2284                                                              # --update happens at the second boundary, but --monitor and --check
2285                                                              # are delayed to avoid spurious results.
2286                                                              + ($o->get('update') ? 0 : $o->get('skew') ));
2287  ***      0                                               MKDEBUG && _d('Woke up at', gettimeofday());
2288                                                  
2289                                                           # Connect or reconnect if necessary.
2290  ***      0      0                                        if ( !$dbh->ping() ) {
2291  ***      0                                                  $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), { AutoCommit => 1 });
2292  ***      0                                                  $sth = undef;
2293                                                           }
2294                                                  
2295  ***      0      0                                        if ( $o->get('monitor') ) {
2296                                                              # Get the data
2297  ***      0             0                                    $sth ||= $dbh->prepare($select_sql);
2298  ***      0                                                  $sth->execute();
2299  ***      0                                                  MKDEBUG && _d($sth->{Statement});
2300  ***      0                                                  my ( $delay ) = $sth->fetchrow_array();
2301  ***      0                                                  MKDEBUG && _d('Found delay of', $delay);
2302  ***      0                                                  unshift @samples, $delay;
2303  ***      0      0                                           pop @samples if @samples > $limit;
2304                                                  
2305                                                              # Calculate and print results
2306  ***      0                                                  my @vals = map {
2307  ***      0                                                     my $bound = min($_, scalar(@samples));
2308  ***      0                                                     sum(@samples[0 .. $bound-1]) / $_;
2309                                                              } @$frames;
2310  ***      0                                                  my $output = sprintf($format, $delay, @vals);
2311  ***      0      0                                           if ( my $file = $o->get('file') ) { 
2312  ***      0      0                                              open my $file, '>', $file
2313                                                                    or die "Can't open $file: $OS_ERROR";
2314  ***      0      0                                              print $file $output
2315                                                                    or die "Can't print to $file: $OS_ERROR";
2316  ***      0      0                                              close $file
2317                                                                    or die "Can't close $file: $OS_ERROR";
2318                                                              }
2319                                                              else {
2320  ***      0      0                                              print $output unless $o->get('quiet');
2321                                                              }
2322                                                           }
2323                                                           else { # --update mode
2324  ***      0             0                                    $sth ||= $dbh->prepare($update_sql);
2325  ***      0                                                  $sth->execute();
2326  ***      0                                                  MKDEBUG && _d($sth->{Statement});
2327                                                           }
2328                                                        };
2329  ***      0      0                                     if ( $EVAL_ERROR ) {
2330  ***      0                                               my ( $err ) = $EVAL_ERROR =~ m/^(?:DBI|DBD).*failed: (.*?)\s*at \S+ line .*/;
2331  ***      0      0                                        if ( $err ) {
2332  ***      0                                                  print STDERR $err, "\n";
2333                                                           }
2334                                                           else {
2335  ***      0                                                  die $EVAL_ERROR;
2336                                                           }
2337                                                        }
2338  ***      0                                            $now = time();
2339                                                     }
2340                                                  
2341  ***      0                                         disconnect($dbh, $sth);
2342  ***      0                                         return 0;
2343                                                  }
2344                                                  
2345                                                  # ############################################################################
2346                                                  # Subroutines.
2347                                                  # ############################################################################
2348                                                  
2349                                                  # Check the delay on a single server.  Optionally recurse to all its slaves.
2350                                                  sub check_delay {
2351  ***      0                    0                    my ( %args ) = @_;
2352  ***      0                                         foreach my $arg ( qw(dp dsn dbh) ) {
2353  ***      0      0                                     die "I need a $arg argument" unless $args{$arg};
2354                                                     }
2355  ***      0                                         my $o = $args{o};
2356                                                  
2357  ***      0                                         MKDEBUG && _d('Checking slave delay');
2358                                                  
2359                                                     # Collect a list of connections to the slaves.
2360  ***      0      0                                  if ( $o->get('recurse') ) {
2361  ***      0                                            MKDEBUG && _d('Recursing to slaves');
2362  ***      0                                            my $ms = new MasterSlave();
2363                                                        $ms->recurse_to_slaves(
2364                                                           {  dbh => $args{dbh},
2365                                                              dsn => $args{dsn},
2366                                                              dsn_parser => $args{dp},
2367                                                              recurse    => $o->get('recurse'),
2368                                                              callback   => sub {
2369  ***      0                    0                                my ( $dsn, $dbh, $level ) = @_;
2370  ***      0                                                     push @dbhs, $dbh;
2371  ***      0                                                     push @sths, [ $dsn, $dbh->prepare($args{select_sql}) ];
2372                                                              },
2373  ***      0                                                  method => $o->get('recursion-method'),
2374                                                           },
2375                                                        );
2376                                                     }
2377                                                     else {
2378  ***      0                                            push @sths, [ $args{dsn}, $args{sth} ];
2379                                                     }
2380                                                  
2381                                                     # Assume that each query will be very fast, so there's no real need to
2382                                                     # sleep between EACH server checked.
2383  ***      0                                         my @now = gettimeofday();
2384  ***      0                                         usleep((($o->get('interval') - ($now[0] % $o->get('interval'))) * 1_000_000)
2385                                                        - $now[1] + $o->get('skew'));
2386  ***      0                                         MKDEBUG && _d('Woke up at', gettimeofday());
2387                                                  
2388  ***      0                                         foreach my $thing ( @sths ) {
2389  ***      0                                            my ( $dsn, $sth ) = @$thing;
2390  ***      0             0                              my $host = $dsn->{h} || '';
2391  ***      0      0      0                              if ( $dsn->{P} && $dsn->{P} ne '3306' ) {
2392  ***      0                                               $host .= ":$dsn->{P}";
2393                                                        }
2394  ***      0                                            $sth->execute();
2395  ***      0                                            my ( $delay, $hostname ) = $sth->fetchrow_array();
2396  ***      0             0                              $host ||= $hostname || '';
      ***                    0                        
2397  ***      0                                            MKDEBUG && _d('Found delay of', $delay, 'on', $host);
2398                                                  
2399  ***      0      0      0                              if ( $o->get('recurse') && $host ) {
2400                                                           # Must print not only the delay, but the server's hostname if
2401                                                           # available.
2402  ***      0      0                                        printf("%-20s %5d\n", $host, $delay) unless $o->get('quiet');
2403                                                        }
2404                                                        else {
2405                                                           # Just print the delay.
2406  ***      0      0                                        printf("%d\n", $delay) unless $o->get('quiet');
2407                                                        }
2408                                                     }
2409  ***      0                                         return;
2410                                                  }
2411                                                  
2412                                                  sub disconnect {
2413  ***      0                    0                    my ( $dbh, $sth ) = @_;
2414  ***      0                                         MKDEBUG && _d('Disconnecting');
2415  ***      0      0                                  $sth->finish() if $sth;
2416  ***      0                                         foreach my $handle ( @sths ) {
2417  ***      0                                            my $sth = $handle->[1];
2418  ***      0      0                                     $sth->finish() if $sth;
2419                                                     }
2420  ***      0                                         foreach my $handle ( $dbh, @dbhs ) {
2421  ***      0      0                                     $handle->disconnect() if $handle;
2422                                                     }
2423  ***      0                                         return;
2424                                                  }
2425                                                  
2426                                                  sub _d {
2427  ***      0                    0                    my ($package, undef, $line) = caller 0;
2428  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2429  ***      0                                              map { defined $_ ? $_ : 'undef' }
2430                                                          @_;
2431  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2432                                                  }
2433                                                  
2434                                                  # ############################################################################
2435                                                  # Run the program.
2436                                                  # ############################################################################
2437                                                  if ( !caller ) { exit main(@ARGV); }
2438                                                  
2439                                                  1; # Because this is a module as well as a script.
2440                                                  
2441                                                  # ############################################################################
2442                                                  # Documentation.
2443                                                  # ############################################################################
2444                                                  
2445                                                  =pod
2446                                                  
2447                                                  =head1 NAME
2448                                                  
2449                                                  mk-heartbeat - Monitor MySQL replication delay.
2450                                                  
2451                                                  =head1 SYNOPSIS
2452                                                  
2453                                                   mk-heartbeat -D test --update -h master-server
2454                                                   mk-heartbeat -D test --monitor -h slave-server
2455                                                   mk-heartbeat -D test --monitor -h slave-server --dbi-driver Pg
2456                                                  
2457                                                  =head1 RISKS
2458                                                  
2459                                                  The following section is included to inform users about the potential risks,
2460                                                  whether known or unknown, of using this tool.  The two main categories of risks
2461                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
2462                                                  tools) and those created by bugs.
2463                                                  
2464                                                  mk-heartbeat merely reads and writes a single record in a table.  It should be
2465                                                  very low-risk.
2466                                                  
2467                                                  At the time of this release, we know of no bugs that could cause serious harm to
2468                                                  users.
2469                                                  
2470                                                  The authoritative source for updated information is always the online issue
2471                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
2472                                                  see a list of such issues at the following URL:
2473                                                  L<http://www.maatkit.org/bugs/mk-heartbeat>.
2474                                                  
2475                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
2476                                                  
2477                                                  =head1 DESCRIPTION
2478                                                  
2479                                                  mk-heartbeat is a two-part MySQL and PostgreSQL replication delay monitoring
2480                                                  system that measures delay by looking at actual replicated data.  This
2481                                                  avoids reliance on the replication mechanism itself, which is unreliable.  (For
2482                                                  example, C<SHOW SLAVE STATUS> on MySQL).
2483                                                  
2484                                                  The first part is an instance of mk-heartbeat that connects to the master and
2485                                                  updates a timestamp ("heartbeat record") every second with L<"--update">.  The
2486                                                  second part is another mk-heartbeat instance that connects to the slave,
2487                                                  examines the replicated heartbeat with L<"--monitor"> or L<"--check">, and
2488                                                  computes the difference from the current system time.  If the slave's
2489                                                  replication is delayed or broken, the heartbeat will become stale.
2490                                                  
2491                                                  You must either manually create a heartbeat table on the master and insert one
2492                                                  row, or use L<"--create-table">.  See L<"--create-table"> for the proper
2493                                                  heartbeat table structure.  The C<MEMORY> storage engine is suggested, but not
2494                                                  required of course, for MySQL.
2495                                                  
2496                                                  mk-heartbeat depends only on the heartbeat record being replicated to the slave,
2497                                                  so it works regardless of the replication mechanism (built-in replication, a
2498                                                  system such as Continuent Tungsten, etc).  It works at any depth in the
2499                                                  replication hierarchy; for example, it will reliably report how far a slave lags
2500                                                  its master's master's master.  And if replication is stopped, it will continue
2501                                                  to work and report (accurately!) that the slave is falling further and further
2502                                                  behind the master.
2503                                                  
2504                                                  mk-heartbeat has a one-second resolution.  It depends on the clocks on the
2505                                                  master and slave servers being closely synchronized via NTP.  L<"--update">
2506                                                  checks happen on the edge of the second, and L<"--monitor"> checks happen
2507                                                  halfway between seconds.  As long as the servers' clocks aren't skewed much
2508                                                  and the replication events are propagating in less than half a second,
2509                                                  mk-heartbeat will report zero seconds of delay.
2510                                                  
2511                                                  mk-heartbeat will try to reconnect if the connection has an error, but will
2512                                                  not retry if it can't get a connection when it first starts.
2513                                                  
2514                                                  The L<"--dbi-driver"> option lets you use mk-heartbeat to monitor PostgreSQL
2515                                                  as well.  It is reported to work well with Slony-1 replication.
2516                                                  
2517                                                  =head1 OPTIONS
2518                                                  
2519                                                  Specify at least one of L<"--stop">, L<"--update">, L<"--monitor">, or L<"--check">.
2520                                                  
2521                                                  L<"--update">, L<"--monitor">, and L<"--check"> are mutually exclusive.
2522                                                  
2523                                                  L<"--daemonize"> and L<"--check"> are mutually exclusive.
2524                                                  
2525                                                  =over
2526                                                  
2527                                                  =item --ask-pass
2528                                                  
2529                                                  Prompt for a password when connecting to MySQL.
2530                                                  
2531                                                  =item --charset
2532                                                  
2533                                                  short form: -A; type: string
2534                                                  
2535                                                  Default character set.  If the value is utf8, sets Perl's binmode on STDOUT to
2536                                                  utf8, passes the mysql_enable_utf8 option to DBD::mysql, and runs SET NAMES UTF8
2537                                                  after connecting to MySQL.  Any other value sets binmode on STDOUT without the
2538                                                  utf8 layer, and runs SET NAMES after connecting to MySQL.
2539                                                  
2540                                                  =item --check
2541                                                  
2542                                                  Check slave delay once and exit.
2543                                                  
2544                                                  =item --config
2545                                                  
2546                                                  type: Array
2547                                                  
2548                                                  Read this comma-separated list of config files; if specified, this must be the
2549                                                  first option on the command line.
2550                                                  
2551                                                  =item --create-table
2552                                                  
2553                                                  Create the heartbeat L<"--table"> if it does not exist.
2554                                                  
2555                                                  This option causes the table specified by L<"--database"> and L<"--table"> to
2556                                                  be created with the following MAGIC_create_heartbeat table definition:
2557                                                  
2558                                                   CREATE TABLE heartbeat (
2559                                                     id int NOT NULL PRIMARY KEY,
2560                                                     ts datetime NOT NULL
2561                                                   );
2562                                                  
2563                                                  The heartbeat table requires at least one row.  If you manually create the
2564                                                  heartbeat table, then you must insert a row by doing:
2565                                                  
2566                                                   INSERT INTO heartbeat (id) VALUES (1);
2567                                                  
2568                                                  This is done automatically by --create-table.
2569                                                  
2570                                                  =item --daemonize
2571                                                  
2572                                                  Fork to the background and detach from the shell.  POSIX operating systems only.
2573                                                  
2574                                                  =item --database
2575                                                  
2576                                                  short form: -D; type: string
2577                                                  
2578                                                  The database to use for the connection.
2579                                                  
2580                                                  =item --dbi-driver
2581                                                  
2582                                                  default: mysql; type: string
2583                                                  
2584                                                  Specify a driver for the connection; C<mysql> and C<Pg> are supported.
2585                                                  
2586                                                  =item --defaults-file
2587                                                  
2588                                                  short form: -F; type: string
2589                                                  
2590                                                  Only read mysql options from the given file.  You must give an absolute
2591                                                  pathname.
2592                                                  
2593                                                  =item --file
2594                                                  
2595                                                  type: string
2596                                                  
2597                                                  Print latest L<"--monitor"> output to this file.
2598                                                  
2599                                                  When L<"--monitor"> is given, prints output to the specified file instead of to
2600                                                  STDOUT.  The file is opened, truncated, and closed every interval, so it will
2601                                                  only contain the most recent statistics.  Useful when L<"--daemonize"> is given.
2602                                                  
2603                                                  =item --frames
2604                                                  
2605                                                  type: string; default: 1m,5m,15m
2606                                                  
2607                                                  Timeframes for averages.
2608                                                  
2609                                                  Specifies the timeframes over which to calculate moving averages when
2610                                                  L<"--monitor"> is given.  Specify as a comma-separated list of numbers with
2611                                                  suffixes.  The suffix can be s for seconds, m for minutes, h for hours, or d for
2612                                                  days.  The size of the largest frame determines the maximum memory usage, as up
2613                                                  to the specified number of per-second samples are kept in memory to calculate
2614                                                  the averages.  You can specify as many timeframes as you like.
2615                                                  
2616                                                  =item --help
2617                                                  
2618                                                  Show help and exit.
2619                                                  
2620                                                  =item --host
2621                                                  
2622                                                  short form: -h; type: string
2623                                                  
2624                                                  Connect to host.
2625                                                  
2626                                                  =item --interval
2627                                                  
2628                                                  type: time; default: 1s
2629                                                  
2630                                                  Interval between updates and checks.
2631                                                  
2632                                                  How often to check or update values.  The updates and checks will happen when
2633                                                  the Unix time (seconds since epoch) is an even multiple of this value.  The
2634                                                  suffix is similar to L<"--frames">.
2635                                                  
2636                                                  =item --log
2637                                                  
2638                                                  type: string
2639                                                  
2640                                                  Print all output to this file when daemonized.
2641                                                  
2642                                                  =item --monitor
2643                                                  
2644                                                  Monitor slave delay continuously.
2645                                                  
2646                                                  Specifies that mk-heartbeat should check the slave's delay every second and
2647                                                  report to STDOUT (or if L<"--file"> is given, to the file instead).  The output
2648                                                  is the current delay followed by moving averages over the timeframe given in
2649                                                  L<"--frames">.  For example,
2650                                                  
2651                                                   5s [  0.25s,  0.05s,  0.02s ]
2652                                                  
2653                                                  =item --password
2654                                                  
2655                                                  short form: -p; type: string
2656                                                  
2657                                                  Password to use when connecting.
2658                                                  
2659                                                  =item --pid
2660                                                  
2661                                                  type: string
2662                                                  
2663                                                  Create the given PID file when daemonized.  The file contains the process ID of
2664                                                  the daemonized instance.  The PID file is removed when the daemonized instance
2665                                                  exits.  The program checks for the existence of the PID file when starting; if
2666                                                  it exists and the process with the matching PID exists, the program exits.
2667                                                  
2668                                                  =item --port
2669                                                  
2670                                                  short form: -P; type: int
2671                                                  
2672                                                  Port number to use for connection.
2673                                                  
2674                                                  =item --quiet
2675                                                  
2676                                                  short form: -q
2677                                                  
2678                                                  Suppresses normal output.
2679                                                  
2680                                                  =item --recurse
2681                                                  
2682                                                  type: int
2683                                                  
2684                                                  Check slaves recursively to this depth in L<"--check"> mode.
2685                                                  
2686                                                  Try to discover slave servers recursively, to the specified depth.  After
2687                                                  discovering servers, run the check on each one of them and print the hostname
2688                                                  (if possible), followed by the slave delay.
2689                                                  
2690                                                  This currently works only with MySQL.  See L<"--recursion-method">.
2691                                                  
2692                                                  =item --recursion-method
2693                                                  
2694                                                  type: string
2695                                                  
2696                                                  Preferred recursion method used to find slaves.
2697                                                  
2698                                                  Possible methods are:
2699                                                  
2700                                                    METHOD       USES
2701                                                    ===========  ================
2702                                                    processlist  SHOW PROCESSLIST
2703                                                    hosts        SHOW SLAVE HOSTS
2704                                                  
2705                                                  The processlist method is preferred because SHOW SLAVE HOSTS is not reliable.
2706                                                  However, the hosts method is required if the server uses a non-standard
2707                                                  port (not 3306).  Usually mk-heartbeat does the right thing and finds
2708                                                  the slaves, but you may give a preferred method and it will be used first.
2709                                                  If it doesn't find any slaves, the other methods will be tried.
2710                                                  
2711                                                  =item --replace
2712                                                  
2713                                                  Use C<REPLACE> instead of C<UPDATE> for --update.
2714                                                  
2715                                                  When running in L<"--update"> mode, use C<REPLACE> instead of C<UPDATE> to set
2716                                                  the heartbeat table's timestamp.  The C<REPLACE> statement is a MySQL extension
2717                                                  to SQL.  This option is useful when you don't know whether the table contains
2718                                                  any rows or not.
2719                                                  
2720                                                  =item --run-time
2721                                                  
2722                                                  type: time
2723                                                  
2724                                                  Time to run before exiting.
2725                                                  
2726                                                  =item --sentinel
2727                                                  
2728                                                  type: string; default: /tmp/mk-heartbeat-sentinel
2729                                                  
2730                                                  Exit if this file exists.
2731                                                  
2732                                                  =item --set-vars
2733                                                  
2734                                                  type: string; default: wait_timeout=10000
2735                                                  
2736                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this string
2737                                                  will be appended to SET and executed.
2738                                                  
2739                                                  =item --skew
2740                                                  
2741                                                  type: int; default: 500000
2742                                                  
2743                                                  How long to delay checks, in milliseconds.
2744                                                  
2745                                                  The default is to delay checks one half second.  Since the update happens as
2746                                                  soon as possible after the beginning of the second on the master, this allows
2747                                                  one half second of replication delay before reporting that the slave lags the
2748                                                  master by one second.  If your clocks are not completely accurate or there is
2749                                                  some other reason you'd like to delay the slave more or less, you can tweak this
2750                                                  value.  Try setting the C<MKDEBUG> environment variable to see the effect this
2751                                                  has.
2752                                                  
2753                                                  =item --socket
2754                                                  
2755                                                  short form: -S; type: string
2756                                                  
2757                                                  Socket file to use for connection.
2758                                                  
2759                                                  =item --stop
2760                                                  
2761                                                  Stop running instances by creating the sentinel file.
2762                                                  
2763                                                  This should have the effect of stopping all running
2764                                                  instances which are watching the same sentinel file.  If none of
2765                                                  L<"--update">, L<"--monitor"> or L<"--check"> is specified, C<mk-heartbeat>
2766                                                  will exit after creating the file.  If one of these is specified,
2767                                                  C<mk-heartbeat> will wait the interval given by L<"--interval">, then remove
2768                                                  the file and continue working.
2769                                                  
2770                                                  You might find this handy to stop cron jobs gracefully if necessary, or to
2771                                                  replace one running instance with another.  For example, if you want to stop
2772                                                  and restart C<mk-heartbeat> every hour (just to make sure that it is restarted
2773                                                  every hour, in case of a server crash or some other problem), you could use a
2774                                                  C<crontab> line like this:
2775                                                  
2776                                                   0 * * * * mk-heartbeat --update -D test --stop --sentinel /tmp/mk-heartbeatup
2777                                                  
2778                                                  The non-default L<"--sentinel"> will make sure the hourly C<cron> job stops
2779                                                  only instances previously started with the same options (that is, from the
2780                                                  same C<cron> job).
2781                                                  
2782                                                  See also L<"--sentinel">.
2783                                                  
2784                                                  =item --table
2785                                                  
2786                                                  type: string; default: heartbeat
2787                                                  
2788                                                  The table to use for the heartbeat.
2789                                                  
2790                                                  Don't specify database.table; use L<"--database"> to specify the database.
2791                                                  
2792                                                  =item --update
2793                                                  
2794                                                  Update a master's heartbeat.
2795                                                  
2796                                                  =item --user
2797                                                  
2798                                                  short form: -u; type: string
2799                                                  
2800                                                  User for login if not current user.
2801                                                  
2802                                                  =item --version
2803                                                  
2804                                                  Show version and exit.
2805                                                  
2806                                                  =back
2807                                                  
2808                                                  =head1 DOWNLOADING
2809                                                  
2810                                                  You can download Maatkit from Google Code at
2811                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
2812                                                  easily with a command like the following:
2813                                                  
2814                                                     wget http://www.maatkit.org/get/toolname
2815                                                     or
2816                                                     wget http://www.maatkit.org/trunk/toolname
2817                                                  
2818                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
2819                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
2820                                                  needed.  The first URL gets the latest released version of the tool, and the
2821                                                  second gets the latest trunk code from Subversion.
2822                                                  
2823                                                  =head1 ENVIRONMENT
2824                                                  
2825                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of the
2826                                                  Maatkit tools:
2827                                                  
2828                                                     MKDEBUG=1 mk-....
2829                                                  
2830                                                  =head1 SYSTEM REQUIREMENTS
2831                                                  
2832                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
2833                                                  installed in any reasonably new version of Perl.
2834                                                  
2835                                                  =head1 BUGS
2836                                                  
2837                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-heartbeat>.
2838                                                  
2839                                                  Please use Google Code Issues and Groups to report bugs or request support:
2840                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
2841                                                  discuss Maatkit.
2842                                                  
2843                                                  Please include the complete command-line used to reproduce the problem you are
2844                                                  seeing, the version of all MySQL servers involved, the complete output of the
2845                                                  tool when run with L<"--version">, and if possible, debugging output produced by
2846                                                  running with the C<MKDEBUG=1> environment variable.
2847                                                  
2848                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
2849                                                  
2850                                                  This program is copyright 2007-@CURRENTYEAR@ Percona Inc.
2851                                                  and copyright 2006 Proven Scaling LLC and Six Apart Ltd.
2852                                                  Feedback and improvements are welcome.
2853                                                  
2854                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
2855                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
2856                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
2857                                                  
2858                                                  This program is free software; you can redistribute it and/or modify it under
2859                                                  the terms of the GNU General Public License as published by the Free Software
2860                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
2861                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
2862                                                  licenses.
2863                                                  
2864                                                  You should have received a copy of the GNU General Public License along with
2865                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
2866                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
2867                                                  
2868                                                  =head1 SEE ALSO
2869                                                  
2870                                                  See also L<mk-slave-delay> and L<mk-slave-restart>.
2871                                                  
2872                                                  =head1 AUTHOR
2873                                                  
2874                                                  Proven Scaling LLC, SixApart Ltd, and Baron Schwartz
2875                                                  
2876                                                  =head1 ABOUT MAATKIT
2877                                                  
2878                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
2879                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
2880                                                  code contributors.  Both are employed by Percona.  Financial support for
2881                                                  Maatkit development is primarily provided by Percona and its clients. 
2882                                                  
2883                                                  =head1 VERSION
2884                                                  
2885                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 5425 $.
2886                                                  
2887                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
62    ***      0      0      0   if ($EVAL_ERROR)
63    ***      0      0      0   unless print STDERR 'Cannot connect to ', $dp->as_string($dsn), "\n"
73    ***      0      0      0   if (not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++)
78    ***      0      0      0   if ($$args{'skip_callback'})
86    ***      0      0      0   if (not defined $$args{'recurse'} or $level < $$args{'recurse'})
88    ***      0      0      0   unless not $$_{'master_id'}
105   ***      0      0      0   if ($method) { }
110   ***      0      0      0   if (($$dsn{'P'} || 3306) != 3306)
124   ***      0      0      0   if @slaves
142   ***      0      0      0   if ($host eq 'localhost')
159   ***      0      0      0   if (@slaves)
164   ***      0      0      0   $hash{'user'} ? :
      ***      0      0      0   $hash{'password'} ? :
184   ***      0      0      0   if (not $proc)
201   ***      0      0      0   unless my $master_status = $self->get_master_status($master)
203   ***      0      0      0   unless my $slave_status = $self->get_slave_status($slave)
205   ***      0      0      0   unless my(@connected) = $self->get_connected_slaves($master)
209   ***      0      0      0   if ($port != $$slave_status{'master_port'})
214   ***      0      0      0   if (not grep {$$slave_status{'master_user'} eq $$_{'user'};} @connected)
219   ***      0      0      0   if (($$slave_status{'slave_io_state'} || '') eq 'Waiting for master to send event')
226   ***      0      0      0   if ($master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1)
239   ***      0      0      0   unless my $master = $self->get_slave_status($dbh)
246   ***      0      0      0   if (not $$self{'not_a_slave'}{$dbh})
253   ***      0      0      0   if ($ss and %$ss)
265   ***      0      0      0   if (not $$self{'not_a_master'}{$dbh})
272   ***      0      0      0   if ($ms and %$ms)
274   ***      0      0      0   if ($$ms{'file'} and $$ms{'position'})
287   ***      0      0      0   unless defined $time
291   ***      0      0      0   if ($ms) { }
295   ***      0      0      0   defined $result ? :
297   ***      0      0      0   if ($stat eq 'NULL' or $stat < 0 and not $timeoutok)
317   ***      0      0      0   if ($pos) { }
341   ***      0      0      0   if ($self->pos_cmp($slave_pos, $master_pos) < 0)
347   ***      0      0      0   if ($EVAL_ERROR)
349   ***      0      0      0   if ($EVAL_ERROR =~ /MASTER_POS_WAIT returned NULL/) { }
351   ***      0      0      0   if (not $self->slave_is_running($slave_status)) { }
356   ***      0      0      0   if ($self->pos_cmp($slave_pos, $master_pos) != 0)
380   ***      0      0      0   if ($self->pos_cmp($s1_pos, $s2_pos) < 0) { }
      ***      0      0      0   elsif ($self->pos_cmp($s2_pos, $s1_pos) < 0) { }
392   ***      0      0      0   if ($self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0)
415   ***      0      0      0   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
419   ***      0      0      0   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
424   ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($gmaster_dsn))
438   ***      0      0      0   if (not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0) { }
453   ***      0      0      0   if ($self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0)
464   ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($sib_dsn))
468   ***      0      0      0   unless my $master_dsn1 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
472   ***      0      0      0   unless my $master_dsn2 = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
474   ***      0      0      0   if ($self->short_host($master_dsn1) ne $self->short_host($master_dsn2))
477   ***      0      0      0   unless my $sib_master_stat = $self->get_master_status($sib_dbh)
479   ***      0      0      0   unless $self->has_slave_updates($sib_dbh)
491   ***      0      0      0   if ($self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0)
503   ***      0      0      0   if ($self->short_host($slave_dsn) eq $self->short_host($unc_dsn))
507   ***      0      0      0   unless my $master_dsn = $self->get_master_dsn($slave_dbh, $slave_dsn, $dsn_parser)
511   ***      0      0      0   unless my $gmaster_dsn = $self->get_master_dsn($master_dbh, $master_dsn, $dsn_parser)
514   ***      0      0      0   unless my $unc_master_dsn = $self->get_master_dsn($unc_dbh, $unc_dsn, $dsn_parser)
517   ***      0      0      0   if ($self->short_host($gmaster_dsn) ne $self->short_host($unc_master_dsn))
521   ***      0      0      0   unless my $unc_master_stat = $self->get_master_status($unc_dbh)
523   ***      0      0      0   unless $self->has_slave_updates($unc_dbh)
531   ***      0      0      0   if ($self->pos_cmp($self->repl_posn($slave_status), $self->repl_posn($master_status)) != 0)
545   ***      0      0      0   if ($self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0)
556   ***      0      0      0   unless my $stat = $self->get_slave_status($dbh)
578   ***      0      0      0   if (exists $$status{'file'} and exists $$status{'position'}) { }
606   ***      0      0      0   if ($$dsn{'master_host'}) { }
614   ***      0      0      0   ($port || 3306) == 3306 ? :
625   ***      0      0      0   defined $_ ? :
665   ***      0      0      0   unless $args{$arg}
671   ***      0      0      0   exists $args{'strict'} ? :
714   ***      0      0      0   unless open my $fh, '<', $file
734   ***      0      0      0   unless $para =~ /^=head1 OPTIONS/
739   ***      0      0      0   if $para =~ /^=over/
747   ***      0      0      0   unless $para
750   ***      0      0      0   if (my($option) = $para =~ /^=item --(.*)/)
757   ***      0      0      0   if ($para =~ /: /) { }
761   ***      0      0      0   unless $attributes{$attrib}
765   ***      0      0      0   if ($attribs{'short form'})
781   ***      0      0      0   if $para =~ /^=item/
783   ***      0      0      0   if (my($base_option) = $option =~ /^\[no\](.*)/)
788   ***      0      0      0   $attribs{'short form'} ? :
      ***      0      0      0   $attribs{'negatable'} ? :
      ***      0      0      0   $attribs{'cumulative'} ? :
      ***      0      0      0   $attribs{'type'} ? :
      ***      0      0      0   $attribs{'default'} ? :
      ***      0      0      0   $attribs{'group'} ? :
800   ***      0      0      0   unless $para
803   ***      0      0      0   if ($para =~ /^=head1/)
807   ***      0      0      0   if $para =~ /^=item --/
811   ***      0      0      0   unless @specs
822   ***      0      0      0   if (ref $opt) { }
827   ***      0      0      0   if (not $long)
832   ***      0      0      0   if exists $$self{'opts'}{$long}
835   ***      0      0      0   if (length $long == 1)
840   ***      0      0      0   if ($short) { }
841   ***      0      0      0   if exists $$self{'short_opts'}{$short}
850   ***      0      0      0   $$opt{'spec'} =~ /!/ ? :
851   ***      0      0      0   $$opt{'spec'} =~ /\+/ ? :
852   ***      0      0      0   $$opt{'desc'} =~ /required/ ? :
864   ***      0      0      0   if ($type and $type eq 'd' and not $$self{'dp'})
869   ***      0      0      0   if $type and $type =~ /[HhAadzm]/
871   ***      0      0      0   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
872   ***      0      0      0   defined $def ? :
876   ***      0      0      0   if ($long eq 'config')
880   ***      0      0      0   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
893   ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
898   ***      0      0      0   if ($opt =~ /at least one|one and only one/)
903   ***      0      0      0   if ($opt =~ /default to/)
908   ***      0      0      0   if ($opt =~ /restricted to option groups/)
918   ***      0      0      0   unless $rule_ok
935   ***      0      0      0   unless exists $$self{'opts'}{$long}
959   ***      0      0      0   unless exists $$self{'opts'}{$long}
979   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***      0      0      0   exists $$self{'opts'}{$opt} ? :
984   ***      0      0      0   if ($$opt{'is_cumulative'}) { }
999   ***      0      0      0   $$self{'opts'}{$long}{'is_cumulative'} ? :
      ***      0      0      0   exists $$self{'defaults'}{$long} ? :
1008  ***      0      0      0   if (@ARGV and $ARGV[0] eq '--config')
1012  ***      0      0      0   if ($self->has('config'))
1018  ***      0      0      0   if ($EVAL_ERROR)
1019  ***      0      0      0   $self->got('config') ? :
1034  ***      0      0      0   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
1037  ***      0      0      0   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
1038  ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
1044  ***      0      0      0   if (@ARGV and $$self{'strict'})
1050  ***      0      0      0   if (@set > 1)
1061  ***      0      0      0   if (@set == 0)
1071  ***      0      0      0   if ($$opt{'got'}) { }
      ***      0      0      0   elsif ($$opt{'is_required'}) { }
1072  ***      0      0      0   if (exists $$self{'disables'}{$long})
1079  ***      0      0      0   if (exists $$self{'allowed_groups'}{$long})
1091  ***      0      0      0   if $restricted_opt eq $long
1092  ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
1097  ***      0      0      0   if (@restricted_opts)
1099  ***      0      0      0   if (@restricted_opts == 1) { }
1128  ***      0      0      0   unless $opt and $$opt{'type'}
1131  ***      0      0      0   if ($val and $$opt{'type'} eq 'm') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'd') { }
      ***      0      0      0   elsif ($val and $$opt{'type'} eq 'z') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
      ***      0      0      0   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
1134  ***      0      0      0   if (not $suffix)
1140  ***      0      0      0   if ($suffix =~ /[smhd]/) { }
1141  ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1156  ***      0      0      0   if ($from_key)
1167  ***      0      0      0   if (defined $num) { }
1168  ***      0      0      0   if ($factor)
1195  ***      0      0      0   length $opt == 1 ? :
1196  ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
1203  ***      0      0      0   length $opt == 1 ? :
1204  ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
1211  ***      0      0      0   length $opt == 1 ? :
1212  ***      0      0      0   defined $long ? :
1217  ***      0      0      0   length $opt == 1 ? :
1218  ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
1252  ***      0      0      0   if ($$self{'opts'}{'help'}{'got'}) { }
      ***      0      0      0   elsif (scalar @{$$self{'errors'};}) { }
1253  ***      0      0      0   unless print $self->print_usage
1257  ***      0      0      0   unless print $self->print_errors
1266  ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
1275  ***      0      0      0   unless $$self{'got_opts'}
1278  ***      0      0      0   $$_{'is_negatable'} ? :
1282  ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
1298  ***      0      0      0   $group eq 'default' ? :
1304  ***      0      0      0   $$opt{'is_negatable'} ? :
1307  ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
1316  ***      0      0      0   if ($short) { }
1325  ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
1329  ***      0      0      0   if ($$self{'dp'})
1337  ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
1349  ***      0      0      0   if ref $_[0] eq 'OptionParser'
1352  ***      0      0      0   unless print $prompt
1360  ***      0      0      0   unless print "\n"
1363  ***      0      0      0   if ($EVAL_ERROR)
1385  ***      0      0      0   unless open my $fh, '<', $filename
1393  ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
1396  ***      0      0      0   if ($line eq '--')
1401  ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
1419  ***      0      0      0   unless open my $fh, '<', $file
1423  ***      0      0      0   unless $para =~ /^=pod$/m
1427  ***      0      0      0   unless $para =~ /$regex/
1432  ***      0      0      0   unless close $fh
1446  ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
1461  ***      0      0      0   defined $_ ? :
1547  ***     50      0      6   if (@_ > 2)
1556  ***     50      0      2   if (not $dsn)
1568  ***     50      8      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1580  ***     50      0     16   if (not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'})
1586         100      8      8   if (not defined $final_props{$key})
1593  ***     50      0      8   unless exists $opts{$key}
1596  ***     50      0      2   if (my $required = $self->prop('required'))
1598  ***      0      0      0   unless $final_props{$key}
1607  ***      0      0      0   unless ref $o eq 'OptionParser'
1610  ***      0      0      0   if $o->has($_)
1620  ***      0      0      0   unless ref $dsn
1621  ***      0      0      0   $_ eq 'p' ? :
1622  ***      0      0      0   if defined $$dsn{$_}
1635  ***      0      0      0   $opts{$key}{'copy'} ? :
1649  ***     50      0      2   if ($driver eq 'Pg') { }
1681  ***     50      0      2   $cxn_string =~ /charset=utf8/ ? :
1690  ***     50      0      2   if (not $have_dbi)
1709  ***     50      2      0   if ($cxn_string =~ /mysql/i)
1717  ***     50      0      2   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1722  ***      0      0      0   if ($charset eq 'utf8') { }
1723  ***      0      0      0   unless binmode STDOUT, ':utf8'
1727  ***      0      0      0   unless binmode STDOUT
1731  ***     50      0      2   if ($self->prop('set-vars'))
1738  ***     50      0      2   if (not $dbh and $EVAL_ERROR)
1740  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1753  ***      0      0      0   if (not $tries)
1775  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1792  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1802  ***      0      0      0   unless $dsn_1
1803  ***      0      0      0   unless $dsn_2
1807  ***      0      0      0   if ($args{'overwrite'}) { }
1808  ***      0      0      0   defined $$dsn_1{$key} ? :
1811  ***      0      0      0   defined $$dsn_2{$key} ? :
1820  ***      0      0      0   defined $_ ? :
1849  ***      0      0      0   unless $args{$arg}
1852  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
1868  ***      0      0      0   unless defined(my $pid = fork)
1869  ***      0      0      0   if ($pid)
1876  ***      0      0      0   unless POSIX::setsid()
1877  ***      0      0      0   unless chdir '/'
1883  ***      0      0      0   if (-t STDIN)
1885  ***      0      0      0   unless open STDIN, '/dev/null'
1889  ***      0      0      0   if ($$self{'log_file'}) { }
1891  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
1895  ***      0      0      0   unless open STDERR, '>&STDOUT'
1899  ***      0      0      0   if (-t STDOUT)
1901  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
1904  ***      0      0      0   if (-t STDERR)
1906  ***      0      0      0   unless open STDERR, '>', '/dev/null'
1917  ***      0      0      0   $self ? :
1919  ***      0      0      0   if ($PID_file and -f $PID_file) { }
1922  ***      0      0      0   if $EVAL_ERROR
1924  ***      0      0      0   if ($pid) { }
1926  ***      0      0      0   if ($pid_is_alive) { }
1948  ***      0      0      0   if (exists $$self{'child'})
1960  ***      0      0      0   if (not $PID_file)
1967  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
1969  ***      0      0      0   unless print $PID_FH $PID
1971  ***      0      0      0   unless close $PID_FH
1980  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
1981  ***      0      0      0   unless unlink $$self{'PID_file'}
1993  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
1999  ***      0      0      0   defined $_ ? :
2039  ***      0      0      0   unless defined $val
2040  ***      0      0      0   if $val eq ''
2042  ***      0      0      0   if (not defined $is_numeric)
2043  ***      0      0      0   $val =~ /^0|\D/ ? :
2046  ***      0      0      0   if $is_numeric
2056  ***      0      0      0   if (not $tbl)
2065  ***      0      0      0   unless $like
2112  ***      0      0      0   if (not $o->get('help'))
2115  ***      0      0      0   if (@frames) { }
2119  ***      0      0      0   if (not $num) { }
2123  ***      0      0      0   $suf eq 'h' ? :
      ***      0      0      0   $suf eq 'm' ? :
      ***      0      0      0   $suf eq 's' ? :
2136  ***      0      0      0   if ($o->get('create-table') and not $o->get('database') && $o->get('table'))
2155  ***      0      0      0   if ($o->get('stop'))
2157  ***      0      0      0   unless my $file = 'IO::File'->new($sentinel, '>>')
2159  ***      0      0      0   unless print $file "Remove this file to permit mk-heartbeat to run\n"
2161  ***      0      0      0   unless close $file
2163  ***      0      0      0   unless $o->get('quiet')
2166  ***      0      0      0   if (not $o->get('update') and not $o->get('check') and not $o->get('monitor')) { }
2177  ***      0      0      0   unless unlink $sentinel
2185  ***      0      0      0   $o->get('replace') ? :
2188  ***      0      0      0   $o->get('dbi-driver') eq 'Pg' ? :
2198  ***      0      0      0   if ($o->get('ask-pass'))
2207  ***      0      0      0   $o->get('update') ? :
2212  ***      0      0      0   if ($o->get('create-table'))
2235  ***      0      0      0   if (scalar @$row == 0)
2242  ***      0      0      0   if ($o->get('daemonize')) { }
      ***      0      0      0   elsif ($o->get('pid')) { }
2264  ***      0      0      0   if ($o->get('check'))
2282  ***      0      0      0   $o->get('update') ? :
2290  ***      0      0      0   if (not $dbh->ping)
2295  ***      0      0      0   if ($o->get('monitor')) { }
2303  ***      0      0      0   if @samples > $limit
2311  ***      0      0      0   if (my $file = $o->get('file')) { }
2312  ***      0      0      0   unless open my $file, '>', $file
2314  ***      0      0      0   unless print $file $output
2316  ***      0      0      0   unless close $file
2320  ***      0      0      0   unless $o->get('quiet')
2329  ***      0      0      0   if ($EVAL_ERROR)
2331  ***      0      0      0   if ($err) { }
2353  ***      0      0      0   unless $args{$arg}
2360  ***      0      0      0   if ($o->get('recurse')) { }
2391  ***      0      0      0   if ($$dsn{'P'} and $$dsn{'P'} ne '3306')
2399  ***      0      0      0   if ($o->get('recurse') and $host) { }
2402  ***      0      0      0   unless $o->get('quiet')
2406  ***      0      0      0   unless $o->get('quiet')
2415  ***      0      0      0   if $sth
2418  ***      0      0      0   if $sth
2421  ***      0      0      0   if $handle
2428  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
73    ***      0      0      0      0   defined $master_thinks_i_am and $master_thinks_i_am != $id
253   ***      0      0      0      0   $ss and %$ss
272   ***      0      0      0      0   $ms and %$ms
274   ***      0      0      0      0   $$ms{'file'} and $$ms{'position'}
297   ***      0      0      0      0   $stat < 0 and not $timeoutok
438   ***      0      0      0      0   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status)
      ***      0      0      0      0   not $self->slave_is_running($mslave_status) and not $self->slave_is_running($slave_status) and $self->pos_cmp($master_pos, $slave_pos) == 0
573   ***      0      0      0      0   $value && $value =~ /^(1|ON)$/
578   ***      0      0      0      0   exists $$status{'file'} and exists $$status{'position'}
864   ***      0      0      0      0   $type and $type eq 'd'
      ***      0      0      0      0   $type and $type eq 'd' and not $$self{'dp'}
869   ***      0      0      0      0   $type and $type =~ /[HhAadzm]/
1008  ***      0      0      0      0   @ARGV and $ARGV[0] eq '--config'
1037  ***      0      0      0      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
1044  ***      0      0      0      0   @ARGV and $$self{'strict'}
1128  ***      0      0      0      0   $opt and $$opt{'type'}
1131  ***      0      0      0      0   $val and $$opt{'type'} eq 'm'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'd'
      ***      0      0      0      0   $val and $$opt{'type'} eq 'z'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   defined $val and $$opt{'type'} eq 'a'
1196  ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
1204  ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
1218  ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
1307  ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
1401  ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1580  ***     66      8      8      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33     16      0      0   not defined $final_props{$key} and defined $$prev{$key} and $opts{$key}{'copy'}
1702  ***     66      2      0      2   not $dbh and $tries--
1738  ***     33      2      0      0   not $dbh and $EVAL_ERROR
1919  ***      0      0      0      0   $PID_file and -f $PID_file
1980  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
2136  ***      0      0      0      0   $o->get('database') && $o->get('table')
      ***      0      0      0      0   $o->get('create-table') and not $o->get('database') && $o->get('table')
2166  ***      0      0      0      0   not $o->get('update') and not $o->get('check')
      ***      0      0      0      0   not $o->get('update') and not $o->get('check') and not $o->get('monitor')
2278  ***      0      0      0      0   !$o->get('run-time') || $now < $end and not -f $sentinel
2391  ***      0      0      0      0   $$dsn{'P'} and $$dsn{'P'} ne '3306'
2399  ***      0      0      0      0   $o->get('recurse') and $host

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
44    ***     50      0      2   $ENV{'MKDEBUG'} || 0
52    ***      0      0      0   $level ||= 0
110   ***      0      0      0   $$dsn{'P'} || 3306
219   ***      0      0      0   $$slave_status{'slave_io_state'} || ''
565   ***      0      0      0   $$slave_status{'slave_sql_running'} || 'No'
614   ***      0      0      0   $host || '[default]'
      ***      0      0      0   $port || 3306
649   ***     50      0      2   $ENV{'MKDEBUG'} || 0
669   ***      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
671   ***      0      0      0   $args{'prompt'} || '<options>'
      ***      0      0      0   $args{'dp'} || undef
713   ***      0      0      0   $file ||= '/home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat'
854   ***      0      0      0   $$opt{'group'} ||= 'default'
1136  ***      0      0      0   $s || 's'
1145  ***      0      0      0   $prefix || ''
1173  ***      0      0      0   $pre || ''
1180  ***      0      0      0   $val || ''
1183  ***      0      0      0   $val || ''
1241  ***      0      0      0   $$self{'description'} || ''
1309  ***      0      0      0   $s ||= 's'
1335  ***      0      0      0   $$opt{'type'} || ''
1490  ***     50      0      2   $ENV{'MKDEBUG'} || 0
1561  ***     50      0      2   $prev ||= {}
1562  ***     50      0      2   $defaults ||= {}
1635  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1648  ***     50      0      2   $self->prop('dbidriver') || ''
1652  ***      0      0      0   $$info{'D'} || ''
1658  ***     50      0      2   $$info{'D'} || ''
1680  ***     50      2      0   $opts ||= {}
1775  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1791  ***      0      0      0   $level ||= 0
1792  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1844  ***     50      0      2   $ENV{'MKDEBUG'} || 0
2021  ***     50      0      2   $ENV{'MKDEBUG'} || 0
2091  ***     50      0      2   $ENV{'MKDEBUG'} || 0
2259  ***      0      0      0   $o->get('run-time') || 0
2390  ***      0      0      0   $$dsn{'h'} || ''
2396  ***      0      0      0   $hostname || ''

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
58    ***      0      0      0      0   $$args{'dbh'} || $dp->get_dbh($dp->get_cxn_params($dsn), {'AutoCommit', 1})
73    ***      0      0      0      0   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id
      ***      0      0      0      0   not defined $id or defined $master_thinks_i_am and $master_thinks_i_am != $id or $$args{'server_ids_seen'}{$id}++
86    ***      0      0      0      0   not defined $$args{'recurse'} or $level < $$args{'recurse'}
226   ***      0      0      0      0   $master_log_name ne $slave_log_name or abs $master_log_num - $slave_log_num > 1
247   ***      0      0      0      0   $$self{'sths'}{$dbh}{'SLAVE_STATUS'} ||= $dbh->prepare('SHOW SLAVE STATUS')
266   ***      0      0      0      0   $$self{'sths'}{$dbh}{'MASTER_STATUS'} ||= $dbh->prepare('SHOW MASTER STATUS')
290   ***      0      0      0      0   $ms ||= $self->get_master_status($master)
297   ***      0      0      0      0   $stat eq 'NULL' or $stat < 0 and not $timeoutok
309   ***      0      0      0      0   $$self{'sths'}{$dbh}{'STOP_SLAVE'} ||= $dbh->prepare('STOP SLAVE')
324   ***      0      0      0      0   $$self{'sths'}{$dbh}{'START_SLAVE'} ||= $dbh->prepare('START SLAVE')
392   ***      0      0      0      0   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status)
      ***      0      0      0      0   $self->slave_is_running($s1_status) or $self->slave_is_running($s2_status) or $self->pos_cmp($s1_pos, $s2_pos) != 0
453   ***      0      0      0      0   $self->short_host($mslave_status) ne $self->short_host($slave_status) or $self->pos_cmp($mslave_pos, $slave_pos) != 0
491   ***      0      0      0      0   $self->short_host($slave_status) ne $self->short_host($sib_dsn) or $self->pos_cmp($self->repl_posn($sib_master_stat), $slave_pos) != 0
545   ***      0      0      0      0   $self->short_host($slave_status) ne $self->short_host($unc_dsn) or $self->pos_cmp($self->repl_posn($unc_master_stat), $slave_pos) != 0
668   ***      0      0      0      0   $program_name ||= $PROGRAM_NAME
669   ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***      0      0      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
1131  ***      0      0      0      0   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***      0      0      0      0   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
1671  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1672  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1673  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1674  ***      0      0      0      0   $$dsn{'u'} ||= $user
1675  ***      0      0      0      0   $$dsn{'D'} ||= $db
1993  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
2278  ***      0      0      0      0   !$o->get('run-time') || $now < $end
2297  ***      0      0      0      0   $sth ||= $dbh->prepare($select_sql)
2324  ***      0      0      0      0   $sth ||= $dbh->prepare($update_sql)
2396  ***      0      0      0      0   $host ||= $hostname || ''


Covered Subroutines
-------------------

Subroutine                  Count Location                                               
--------------------------- ----- -------------------------------------------------------
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1478
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1479
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1480
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1481
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1490
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1838
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1839
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1841
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1842
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1844
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:2014
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:2015
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:2019
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:2021
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:2086
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:2087
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:2088
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:2089
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:2091
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:23  
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:24  
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:33  
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:34  
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:38  
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:39  
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:40  
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:44  
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:642 
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:643 
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:645 
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:646 
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:647 
BEGIN                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:649 
get_cxn_params                  2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1645
get_dbh                         2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1679
new                             2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1493
parse                           2 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1555
prop                            6 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1546

Uncovered Subroutines
---------------------

Subroutine                  Count Location                                               
--------------------------- ----- -------------------------------------------------------
DESTROY                         0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1992
__ANON__                        0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1032
__ANON__                        0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:2369
_d                              0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1460
_d                              0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1819
_d                              0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1998
_d                              0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:2427
_d                              0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:624 
_find_slaves_by_hosts           0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:152 
_find_slaves_by_processlist     0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:132 
_get_participants               0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:932 
_make_PID_file                  0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1957
_parse_specs                    0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:818 
_pod_to_specs                   0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:712 
_read_config_file               0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1384
_remove_PID_file                0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1979
_set_option                     0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:978 
_validate_type                  0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1127
as_string                       0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1619
catchup_to_master               0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:332 
catchup_to_same_pos             0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:373 
change_master_to                0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:402 
check_PID_file                  0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1916
check_delay                     0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:2351
clone                           0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1437
copy                            0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1801
daemonize                       0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1865
descr                           0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1240
detach_slave                    0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:554 
disconnect                      0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1784
disconnect                      0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:2413
errors                          0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1230
fill_in_dsn                     0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1667
find_slave_hosts                0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:102 
get                             0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1194
get_connected_slaves            0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:179 
get_defaults                    0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:968 
get_defaults_files              0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:707 
get_groups                      0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:973 
get_hostname                    0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1774
get_master_dsn                  0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:238 
get_master_status               0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:264 
get_opts                        0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:995 
get_slave_lag                   0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:593 
get_slave_status                0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:245 
get_specs                       0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:700 
got                             0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1202
has                             0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1210
has_slave_updates               0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:569 
is_master_of                    0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:200 
literal_like                    0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:2064
main                            0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:2097
make_PID_file                   0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1947
make_sibling_of_master          0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:413 
make_slave_of_sibling           0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:461 
make_slave_of_uncle             0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:500 
new                             0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1847
new                             0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:2024
new                             0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:47  
new                             0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:663 
opts                            0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:944 
parse_options                   0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1606
pos_cmp                         0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:599 
pos_to_string                   0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:618 
print_active_handles            0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1790
print_errors                    0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1264
print_usage                     0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1274
prompt                          0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1235
prompt_noecho                   0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1349
quote                           0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:2029
quote_val                       0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:2037
read_para_after                 0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1418
recurse_to_slaves               0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:51  
repl_posn                       0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:577 
save_error                      0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1225
set                             0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1216
set_defaults                    0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:956 
short_host                      0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:604 
short_opts                      0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:950 
slave_is_running                0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:564 
split_unquote                   0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:2053
start_slave                     0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:316 
stop_slave                      0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:308 
usage                           0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1628
usage_or_errors                 0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:1251
wait_for_master                 0 /home/daniel/dev/maatkit/mk-heartbeat/mk-heartbeat:285 


