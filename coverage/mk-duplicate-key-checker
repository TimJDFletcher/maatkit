---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
.../mk-duplicate-key-checker   53.2   33.2   30.6   62.1    n/a  100.0   45.9
Total                          53.2   33.2   30.6   62.1    n/a  100.0   45.9
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Apr 30 14:58:36 2010
Finish:       Fri Apr 30 14:58:36 2010

Run:          ./101_basics.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Apr 30 14:58:38 2010
Finish:       Fri Apr 30 14:58:39 2010

Run:          ./102_clustered_keys.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Apr 30 14:58:42 2010
Finish:       Fri Apr 30 14:58:42 2010

Run:          ./103_standard_options.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Apr 30 14:58:45 2010
Finish:       Fri Apr 30 14:58:46 2010

Run:          ./201_issue_298.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Apr 30 14:58:49 2010
Finish:       Fri Apr 30 14:58:49 2010

Run:          ./202_issue_331.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Apr 30 14:58:52 2010
Finish:       Fri Apr 30 14:58:53 2010

Run:          ./203_issue_663.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Fri Apr 30 14:58:56 2010
Finish:       Fri Apr 30 14:58:56 2010

/home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This is mk-duplicate-key-checker, a program to analyze MySQL tables for
4                                                     # duplicated or redundant indexes and foreign key constraints.
5                                                     # 
6                                                     # This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
7                                                     # Feedback and improvements are welcome.
8                                                     #
9                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
10                                                    # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
11                                                    # MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
12                                                    #
13                                                    # This program is free software; you can redistribute it and/or modify it under
14                                                    # the terms of the GNU General Public License as published by the Free Software
15                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
16                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
17                                                    # licenses.
18                                                    #
19                                                    # You should have received a copy of the GNU General Public License along with
20                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
21                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
22                                                    
23             6                    6            48   use strict;
               6                                 17   
               6                                 45   
24             6                    6            38   use warnings FATAL => 'all';
               6                                 14   
               6                                 47   
25                                                    
26                                                    our $VERSION = '@VERSION@';
27                                                    our $DISTRIB = '@DISTRIB@';
28                                                    our $SVN_REV = sprintf("%d", (q$Revision: 6067 $ =~ m/(\d+)/g, 0));
29                                                    
30                                                    # ###########################################################################
31                                                    # VersionParser package 5266
32                                                    # ###########################################################################
33                                                    package VersionParser;
34                                                    
35             6                    6            40   use strict;
               6                                 14   
               6                                 28   
36             6                    6            34   use warnings FATAL => 'all';
               6                                 17   
               6                                 27   
37                                                    
38             6                    6            35   use English qw(-no_match_vars);
               6                                 20   
               6                                 39   
39                                                    
40    ***      6            50      6            42   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 15   
               6                                102   
41                                                    
42                                                    sub new {
43             8                    8            58      my ( $class ) = @_;
44             8                                155      bless {}, $class;
45                                                    }
46                                                    
47                                                    sub parse {
48             8                    8          1642      my ( $self, $str ) = @_;
49             8                                207      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
50             8                                 36      MKDEBUG && _d($str, 'parses to', $result);
51             8                                 55      return $result;
52                                                    }
53                                                    
54                                                    sub version_ge {
55    ***      0                    0             0      my ( $self, $dbh, $target ) = @_;
56    ***      0      0                           0      if ( !$self->{$dbh} ) {
57    ***      0                                  0         $self->{$dbh} = $self->parse(
58                                                             $dbh->selectrow_array('SELECT VERSION()'));
59                                                       }
60    ***      0      0                           0      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
61    ***      0                                  0      MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
62    ***      0                                  0      return $result;
63                                                    }
64                                                    
65                                                    sub _d {
66    ***      0                    0             0      my ($package, undef, $line) = caller 0;
67    ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
68    ***      0                                  0           map { defined $_ ? $_ : 'undef' }
69                                                            @_;
70    ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
71                                                    }
72                                                    
73                                                    1;
74                                                    
75                                                    # ###########################################################################
76                                                    # End VersionParser package
77                                                    # ###########################################################################
78                                                    
79                                                    # ###########################################################################
80                                                    # Quoter package 5697
81                                                    # ###########################################################################
82                                                    package Quoter;
83                                                    
84             6                    6            45   use strict;
               6                                 13   
               6                                 34   
85             6                    6            37   use warnings FATAL => 'all';
               6                                 16   
               6                                 32   
86             6                    6            33   use English qw(-no_match_vars);
               6                                 15   
               6                                 28   
87                                                    
88    ***      6            50      6            42   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 18   
               6                                 77   
89                                                    
90                                                    sub new {
91             8                    8            73      my ( $class ) = @_;
92             8                                259      return bless {}, $class;
93                                                    }
94                                                    
95                                                    sub quote {
96            32                   32           274      my ( $self, @vals ) = @_;
97            32                                205      foreach my $val ( @vals ) {
98            50                                323         $val =~ s/`/``/g;
99                                                       }
100           32                                187      return join('.', map { '`' . $_ . '`' } @vals);
              50                                526   
101                                                   }
102                                                   
103                                                   sub quote_val {
104   ***      0                    0             0      my ( $self, $val, $is_numeric ) = @_;
105                                                   
106   ***      0      0                           0      return 'NULL' unless defined $val;  # undef = NULL
107   ***      0      0                           0      return "''" if $val eq '';          # blank string = ''
108                                                   
109   ***      0      0                           0      if ( !defined $is_numeric ) {
110   ***      0      0                           0         $is_numeric = $val =~ m/^0|\D/ ? 0 : 1;
111                                                      }
112                                                   
113   ***      0      0                           0      return $val if $is_numeric;
114                                                   
115   ***      0                                  0      $val =~ s/(['\\])/\\$1/g;
116   ***      0                                  0      return "'$val'";
117                                                   }
118                                                   
119                                                   sub split_unquote {
120            6                    6            43      my ( $self, $db_tbl, $default_db ) = @_;
121            6                                 70      $db_tbl =~ s/`//g;
122            6                                 59      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
123   ***      6     50                          45      if ( !$tbl ) {
124            6                                 26         $tbl = $db;
125            6                                 26         $db  = $default_db;
126                                                      }
127            6                                 47      return ($db, $tbl);
128                                                   }
129                                                   
130                                                   sub literal_like {
131   ***      0                    0             0      my ( $self, $like ) = @_;
132   ***      0      0                           0      return unless $like;
133   ***      0                                  0      $like =~ s/([%_])/\\$1/g;
134   ***      0                                  0      return "'$like'";
135                                                   }
136                                                   
137                                                   1;
138                                                   
139                                                   # ###########################################################################
140                                                   # End Quoter package
141                                                   # ###########################################################################
142                                                   
143                                                   # ###########################################################################
144                                                   # TableParser package 5980
145                                                   # ###########################################################################
146                                                   package TableParser;
147                                                   
148            6                    6            43   use strict;
               6                                 16   
               6                                 42   
149            6                    6            36   use warnings FATAL => 'all';
               6                                 14   
               6                                 30   
150            6                    6            37   use English qw(-no_match_vars);
               6                                 18   
               6                                 30   
151            6                    6            41   use Data::Dumper;
               6                                 13   
               6                                 51   
152                                                   $Data::Dumper::Indent    = 1;
153                                                   $Data::Dumper::Sortkeys  = 1;
154                                                   $Data::Dumper::Quotekeys = 0;
155                                                   
156   ***      6            50      6            40   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 17   
               6                                 92   
157                                                   
158                                                   
159                                                   sub new {
160            8                    8           125      my ( $class, %args ) = @_;
161            8                                 64      my @required_args = qw(Quoter);
162            8                                 85      foreach my $arg ( @required_args ) {
163   ***      8     50                         124         die "I need a $arg argument" unless $args{$arg};
164                                                      }
165            8                                107      my $self = { %args };
166            8                                164      return bless $self, $class;
167                                                   }
168                                                   
169                                                   
170                                                   sub parse {
171            6                    6            59      my ( $self, $ddl, $opts ) = @_;
172   ***      6     50                          41      return unless $ddl;
173   ***      6     50                          48      if ( ref $ddl eq 'ARRAY' ) {
174   ***      0      0                           0         if ( lc $ddl->[0] eq 'table' ) {
175   ***      0                                  0            $ddl = $ddl->[1];
176                                                         }
177                                                         else {
178                                                            return {
179   ***      0                                  0               engine => 'VIEW',
180                                                            };
181                                                         }
182                                                      }
183                                                   
184   ***      6     50                         164      if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
185   ***      0                                  0         die "Cannot parse table definition; is ANSI quoting "
186                                                            . "enabled or SQL_QUOTE_SHOW_CREATE disabled?";
187                                                      }
188                                                   
189            6                                 93      my ($name)     = $ddl =~ m/CREATE (?:TEMPORARY )?TABLE\s+(`.+?`)/;
190   ***      6     50                         104      (undef, $name) = $self->{Quoter}->split_unquote($name) if $name;
191                                                   
192            6                                289      $ddl =~ s/(`[^`]+`)/\L$1/g;
193                                                   
194            6                                 50      my $engine = $self->get_engine($ddl);
195                                                   
196            6                                209      my @defs   = $ddl =~ m/^(\s+`.*?),?$/gm;
197            6                                 38      my @cols   = map { $_ =~ m/`([^`]+)`/ } @defs;
              14                                132   
198            6                                 37      MKDEBUG && _d('Table cols:', join(', ', map { "`$_`" } @cols));
199                                                   
200            6                                 22      my %def_for;
201            6                                 64      @def_for{@cols} = @defs;
202                                                   
203            6                                 26      my (@nums, @null);
204            6                                 29      my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
205            6                                 53      foreach my $col ( @cols ) {
206           14                                 75         my $def = $def_for{$col};
207           14                                175         my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
208   ***     14     50                          90         die "Can't determine column type for $def" unless $type;
209           14                                 75         $type_for{$col} = $type;
210   ***     14     50                         143         if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
211           14                                 72            push @nums, $col;
212           14                                 74            $is_numeric{$col} = 1;
213                                                         }
214           14    100                         125         if ( $def !~ m/NOT NULL/ ) {
215            9                                 42            push @null, $col;
216            9                                 47            $is_nullable{$col} = 1;
217                                                         }
218   ***     14     50                         151         $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
219                                                      }
220                                                   
221            6                                 54      my ($keys, $clustered_key) = $self->get_keys($ddl, $opts, \%is_nullable);
222                                                   
223                                                      return {
224           14                                117         name           => $name,
225                                                         cols           => \@cols,
226           14                                257         col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
227            6                                 94         is_col         => { map { $_ => 1 } @cols },
228                                                         null_cols      => \@null,
229                                                         is_nullable    => \%is_nullable,
230                                                         is_autoinc     => \%is_autoinc,
231                                                         clustered_key  => $clustered_key,
232                                                         keys           => $keys,
233                                                         defs           => \%def_for,
234                                                         numeric_cols   => \@nums,
235                                                         is_numeric     => \%is_numeric,
236                                                         engine         => $engine,
237                                                         type_for       => \%type_for,
238                                                      };
239                                                   }
240                                                   
241                                                   sub sort_indexes {
242   ***      0                    0             0      my ( $self, $tbl ) = @_;
243                                                   
244                                                      my @indexes
245   ***      0                                  0         = sort {
246   ***      0                                  0            (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
247                                                            || ( !$tbl->{keys}->{$a}->{is_unique} <=> !$tbl->{keys}->{$b}->{is_unique} )
248                                                            || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
249   ***      0      0      0                    0            || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      ***      0             0                    0   
250                                                         }
251                                                         grep {
252   ***      0                                  0            $tbl->{keys}->{$_}->{type} eq 'BTREE'
253                                                         }
254   ***      0                                  0         sort keys %{$tbl->{keys}};
255                                                   
256   ***      0                                  0      MKDEBUG && _d('Indexes sorted best-first:', join(', ', @indexes));
257   ***      0                                  0      return @indexes;
258                                                   }
259                                                   
260                                                   sub find_best_index {
261   ***      0                    0             0      my ( $self, $tbl, $index ) = @_;
262   ***      0                                  0      my $best;
263   ***      0      0                           0      if ( $index ) {
264   ***      0                                  0         ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
      ***      0                                  0   
      ***      0                                  0   
265                                                      }
266   ***      0      0                           0      if ( !$best ) {
267   ***      0      0                           0         if ( $index ) {
268   ***      0                                  0            die "Index '$index' does not exist in table";
269                                                         }
270                                                         else {
271   ***      0                                  0            ($best) = $self->sort_indexes($tbl);
272                                                         }
273                                                      }
274   ***      0                                  0      MKDEBUG && _d('Best index found is', $best);
275   ***      0                                  0      return $best;
276                                                   }
277                                                   
278                                                   sub find_possible_keys {
279   ***      0                    0             0      my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
280   ***      0      0                           0      return () unless $where;
281   ***      0                                  0      my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
282                                                         . ' WHERE ' . $where;
283   ***      0                                  0      MKDEBUG && _d($sql);
284   ***      0                                  0      my $expl = $dbh->selectrow_hashref($sql);
285   ***      0                                  0      $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
      ***      0                                  0   
286   ***      0      0                           0      if ( $expl->{possible_keys} ) {
287   ***      0                                  0         MKDEBUG && _d('possible_keys =', $expl->{possible_keys});
288   ***      0                                  0         my @candidates = split(',', $expl->{possible_keys});
289   ***      0                                  0         my %possible   = map { $_ => 1 } @candidates;
      ***      0                                  0   
290   ***      0      0                           0         if ( $expl->{key} ) {
291   ***      0                                  0            MKDEBUG && _d('MySQL chose', $expl->{key});
292   ***      0                                  0            unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
      ***      0                                  0   
293   ***      0                                  0            MKDEBUG && _d('Before deduping:', join(', ', @candidates));
294   ***      0                                  0            my %seen;
295   ***      0                                  0            @candidates = grep { !$seen{$_}++ } @candidates;
      ***      0                                  0   
296                                                         }
297   ***      0                                  0         MKDEBUG && _d('Final list:', join(', ', @candidates));
298   ***      0                                  0         return @candidates;
299                                                      }
300                                                      else {
301   ***      0                                  0         MKDEBUG && _d('No keys in possible_keys');
302   ***      0                                  0         return ();
303                                                      }
304                                                   }
305                                                   
306                                                   sub check_table {
307   ***      0                    0             0      my ( $self, %args ) = @_;
308   ***      0                                  0      my @required_args = qw(dbh db tbl);
309   ***      0                                  0      foreach my $arg ( @required_args ) {
310   ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
311                                                      }
312   ***      0                                  0      my ($dbh, $db, $tbl) = @args{@required_args};
313   ***      0                                  0      my $q      = $self->{Quoter};
314   ***      0                                  0      my $db_tbl = $q->quote($db, $tbl);
315   ***      0                                  0      MKDEBUG && _d('Checking', $db_tbl);
316                                                   
317   ***      0                                  0      my $sql = "SHOW TABLES FROM " . $q->quote($db)
318                                                              . ' LIKE ' . $q->literal_like($tbl);
319   ***      0                                  0      MKDEBUG && _d($sql);
320   ***      0                                  0      my $row;
321   ***      0                                  0      eval {
322   ***      0                                  0         $row = $dbh->selectrow_arrayref($sql);
323                                                      };
324   ***      0      0                           0      if ( $EVAL_ERROR ) {
325   ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
326   ***      0                                  0         return 0;
327                                                      }
328   ***      0      0      0                    0      if ( !$row->[0] || $row->[0] ne $tbl ) {
329   ***      0                                  0         MKDEBUG && _d('Table does not exist');
330   ***      0                                  0         return 0;
331                                                      }
332                                                   
333   ***      0                                  0      MKDEBUG && _d('Table exists; no privs to check');
334   ***      0      0                           0      return 1 unless $args{all_privs};
335                                                   
336   ***      0                                  0      $sql = "SHOW FULL COLUMNS FROM $db_tbl";
337   ***      0                                  0      MKDEBUG && _d($sql);
338   ***      0                                  0      eval {
339   ***      0                                  0         $row = $dbh->selectrow_hashref($sql);
340                                                      };
341   ***      0      0                           0      if ( $EVAL_ERROR ) {
342   ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
343   ***      0                                  0         return 0;
344                                                      }
345   ***      0      0                           0      if ( !scalar keys %$row ) {
346   ***      0                                  0         MKDEBUG && _d('Table has no columns:', Dumper($row));
347   ***      0                                  0         return 0;
348                                                      }
349   ***      0             0                    0      my $privs = $row->{privileges} || $row->{Privileges};
350                                                   
351   ***      0                                  0      $sql = "DELETE FROM $db_tbl LIMIT 0";
352   ***      0                                  0      MKDEBUG && _d($sql);
353   ***      0                                  0      eval {
354   ***      0                                  0         $dbh->do($sql);
355                                                      };
356   ***      0      0                           0      my $can_delete = $EVAL_ERROR ? 0 : 1;
357                                                   
358   ***      0                                  0      MKDEBUG && _d('User privs on', $db_tbl, ':', $privs,
359                                                         ($can_delete ? 'delete' : ''));
360                                                   
361   ***      0      0      0                    0      if ( !($privs =~ m/select/ && $privs =~ m/insert/ && $privs =~ m/update/
      ***                    0                        
      ***                    0                        
362                                                             && $can_delete) ) {
363   ***      0                                  0         MKDEBUG && _d('User does not have all privs');
364   ***      0                                  0         return 0;
365                                                      }
366                                                   
367   ***      0                                  0      MKDEBUG && _d('User has all privs');
368   ***      0                                  0      return 1;
369                                                   }
370                                                   
371                                                   sub get_engine {
372           28                   28           215      my ( $self, $ddl, $opts ) = @_;
373           28                                633      my ( $engine ) = $ddl =~ m/\).*?(?:ENGINE|TYPE)=(\w+)/;
374           28                                114      MKDEBUG && _d('Storage engine:', $engine);
375   ***     28            50                  262      return $engine || undef;
376                                                   }
377                                                   
378                                                   sub get_keys {
379           14                   14           129      my ( $self, $ddl, $opts, $is_nullable ) = @_;
380           14                                 98      my $engine        = $self->get_engine($ddl);
381           14                                 73      my $keys          = {};
382           14                                 55      my $clustered_key = undef;
383                                                   
384                                                      KEY:
385           14                                328      foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {
386                                                   
387   ***     25     50                         181         next KEY if $key =~ m/FOREIGN/;
388                                                   
389           25                                109         my $key_ddl = $key;
390           25                                 76         MKDEBUG && _d('Parsed key:', $key_ddl);
391                                                   
392   ***     25     50                         228         if ( $engine !~ m/MEMORY|HEAP/ ) {
393           25                                141            $key =~ s/USING HASH/USING BTREE/;
394                                                         }
395                                                   
396           25                                315         my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
397           25                                208         my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
398   ***     25            33                  515         $type = $type || $special || 'BTREE';
      ***                   50                        
399   ***     25     50     33                  282         if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
      ***                   33                        
400                                                            && $engine =~ m/HEAP|MEMORY/i )
401                                                         {
402   ***      0                                  0            $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
403                                                         }
404                                                   
405           25                                323         my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
406           25    100                         210         my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
407           25                                 94         my @cols;
408           25                                 82         my @col_prefixes;
409           25                                283         foreach my $col_def ( $cols =~ m/`[^`]+`(?:\(\d+\))?/g ) {
410           34                                326            my ($name, $prefix) = $col_def =~ m/`([^`]+)`(?:\((\d+)\))?/;
411           34                                192            push @cols, $name;
412           34                                211            push @col_prefixes, $prefix;
413                                                         }
414           25                                226         $name =~ s/`//g;
415                                                   
416           25                                 81         MKDEBUG && _d( $name, 'key cols:', join(', ', map { "`$_`" } @cols));
417                                                   
418           34                                233         $keys->{$name} = {
419                                                            name         => $name,
420                                                            type         => $type,
421                                                            colnames     => $cols,
422                                                            cols         => \@cols,
423                                                            col_prefixes => \@col_prefixes,
424                                                            is_unique    => $unique,
425           34                                535            is_nullable  => scalar(grep { $is_nullable->{$_} } @cols),
426           25                                239            is_col       => { map { $_ => 1 } @cols },
427                                                            ddl          => $key_ddl,
428                                                         };
429                                                   
430           25    100    100                  370         if ( $engine =~ m/InnoDB/i && !$clustered_key ) {
431            5                                 24            my $this_key = $keys->{$name};
432   ***      5     50      0                   38            if ( $this_key->{name} eq 'PRIMARY' ) {
      ***             0                               
433            5                                 21               $clustered_key = 'PRIMARY';
434                                                            }
435                                                            elsif ( $this_key->{is_unique} && !$this_key->{is_nullable} ) {
436   ***      0                                  0               $clustered_key = $this_key->{name};
437                                                            }
438            5                                 27            MKDEBUG && $clustered_key && _d('This key is the clustered key');
439                                                         }
440                                                      }
441                                                   
442           14                                130      return $keys, $clustered_key;
443                                                   }
444                                                   
445                                                   sub get_fks {
446            8                    8            71      my ( $self, $ddl, $opts ) = @_;
447            8                                 47      my $fks = {};
448                                                   
449            8                                114      foreach my $fk (
450                                                         $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg )
451                                                      {
452            2                                 25         my ( $name ) = $fk =~ m/CONSTRAINT `(.*?)`/;
453            2                                 20         my ( $cols ) = $fk =~ m/FOREIGN KEY \(([^\)]+)\)/;
454            2                                 23         my ( $parent, $parent_cols ) = $fk =~ m/REFERENCES (\S+) \(([^\)]+)\)/;
455                                                   
456   ***      2     50     33                   44         if ( $parent !~ m/\./ && $opts->{database} ) {
457            2                                 19            $parent = "`$opts->{database}`.$parent";
458                                                         }
459                                                   
460            2                                 15         $fks->{$name} = {
461                                                            name           => $name,
462                                                            colnames       => $cols,
463            2                                 31            cols           => [ map { s/[ `]+//g; $_; } split(',', $cols) ],
               2                                 12   
464                                                            parent_tbl     => $parent,
465                                                            parent_colnames=> $parent_cols,
466            2                                 20            parent_cols    => [ map { s/[ `]+//g; $_; } split(',', $parent_cols) ],
               2                                 37   
467                                                            ddl            => $fk,
468                                                         };
469                                                      }
470                                                   
471            8                                 53      return $fks;
472                                                   }
473                                                   
474                                                   sub remove_auto_increment {
475   ***      0                    0             0      my ( $self, $ddl ) = @_;
476   ***      0                                  0      $ddl =~ s/(^\).*?) AUTO_INCREMENT=\d+\b/$1/m;
477   ***      0                                  0      return $ddl;
478                                                   }
479                                                   
480                                                   sub remove_secondary_indexes {
481   ***      0                    0             0      my ( $self, $ddl ) = @_;
482   ***      0                                  0      my $sec_indexes_ddl;
483   ***      0                                  0      my $tbl_struct = $self->parse($ddl);
484                                                   
485   ***      0      0      0                    0      if ( ($tbl_struct->{engine} || '') =~ m/InnoDB/i ) {
486   ***      0                                  0         my $clustered_key = $tbl_struct->{clustered_key};
487   ***      0             0                    0         $clustered_key  ||= '';
488                                                   
489   ***      0                                  0         my @sec_indexes   = map {
490   ***      0                                  0            my $key_def = $_->{ddl};
491   ***      0                                  0            $key_def =~ s/([\(\)])/\\$1/g;
492   ***      0                                  0            $ddl =~ s/\s+$key_def//i;
493                                                   
494   ***      0                                  0            my $key_ddl = "ADD $_->{ddl}";
495   ***      0      0                           0            $key_ddl   .= ',' unless $key_ddl =~ m/,$/;
496   ***      0                                  0            $key_ddl;
497                                                         }
498   ***      0                                  0         grep { $_->{name} ne $clustered_key }
499   ***      0                                  0         values %{$tbl_struct->{keys}};
500   ***      0                                  0         MKDEBUG && _d('Secondary indexes:', Dumper(\@sec_indexes));
501                                                   
502   ***      0      0                           0         if ( @sec_indexes ) {
503   ***      0                                  0            $sec_indexes_ddl = join(' ', @sec_indexes);
504   ***      0                                  0            $sec_indexes_ddl =~ s/,$//;
505                                                         }
506                                                   
507   ***      0                                  0         $ddl =~ s/,(\n\) )/$1/s;
508                                                      }
509                                                      else {
510   ***      0                                  0         MKDEBUG && _d('Not removing secondary indexes from',
511                                                            $tbl_struct->{engine}, 'table');
512                                                      }
513                                                   
514   ***      0                                  0      return $ddl, $sec_indexes_ddl, $tbl_struct;
515                                                   }
516                                                   
517                                                   sub _d {
518   ***      0                    0             0      my ($package, undef, $line) = caller 0;
519   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
520   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
521                                                           @_;
522   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
523                                                   }
524                                                   
525                                                   1;
526                                                   
527                                                   # ###########################################################################
528                                                   # End TableParser package
529                                                   # ###########################################################################
530                                                   
531                                                   # ###########################################################################
532                                                   # MySQLDump package 5998
533                                                   # ###########################################################################
534                                                   package MySQLDump;
535                                                   
536            6                    6            56   use strict;
               6                                 17   
               6                                 35   
537            6                    6            36   use warnings FATAL => 'all';
               6                                 17   
               6                                 34   
538                                                   
539            6                    6            37   use English qw(-no_match_vars);
               6                                 13   
               6                                 32   
540                                                   
541   ***      6            50      6            38   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 14   
               6                                 82   
542                                                   
543                                                   ( our $before = <<'EOF') =~ s/^   //gm;
544                                                      /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
545                                                      /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
546                                                      /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
547                                                      /*!40101 SET NAMES utf8 */;
548                                                      /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
549                                                      /*!40103 SET TIME_ZONE='+00:00' */;
550                                                      /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
551                                                      /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
552                                                      /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
553                                                      /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
554                                                   EOF
555                                                   
556                                                   ( our $after = <<'EOF') =~ s/^   //gm;
557                                                      /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
558                                                      /*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
559                                                      /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
560                                                      /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
561                                                      /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
562                                                      /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
563                                                      /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
564                                                      /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
565                                                   EOF
566                                                   
567                                                   sub new {
568            8                    8            59      my ( $class, %args ) = @_;
569            8                                 57      my $self = {
570                                                         cache => 0,  # Afaik no script uses this cache any longer because
571                                                      };
572            8                                105      return bless $self, $class;
573                                                   }
574                                                   
575                                                   sub dump {
576   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl, $what ) = @_;
577                                                   
578   ***      0      0                           0      if ( $what eq 'table' ) {
      ***             0                               
      ***             0                               
579   ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
580   ***      0      0                           0         return unless $ddl;
581   ***      0      0                           0         if ( $ddl->[0] eq 'table' ) {
582   ***      0                                  0            return $before
583                                                               . 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
584                                                               . $ddl->[1] . ";\n";
585                                                         }
586                                                         else {
587   ***      0                                  0            return 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
588                                                               . '/*!50001 DROP VIEW IF EXISTS '
589                                                               . $quoter->quote($tbl) . "*/;\n/*!50001 "
590                                                               . $self->get_tmp_table($dbh, $quoter, $db, $tbl) . "*/;\n";
591                                                         }
592                                                      }
593                                                      elsif ( $what eq 'triggers' ) {
594   ***      0                                  0         my $trgs = $self->get_triggers($dbh, $quoter, $db, $tbl);
595   ***      0      0      0                    0         if ( $trgs && @$trgs ) {
596   ***      0                                  0            my $result = $before . "\nDELIMITER ;;\n";
597   ***      0                                  0            foreach my $trg ( @$trgs ) {
598   ***      0      0                           0               if ( $trg->{sql_mode} ) {
599   ***      0                                  0                  $result .= qq{/*!50003 SET SESSION SQL_MODE='$trg->{sql_mode}' */;;\n};
600                                                               }
601   ***      0                                  0               $result .= "/*!50003 CREATE */ ";
602   ***      0      0                           0               if ( $trg->{definer} ) {
603   ***      0                                  0                  my ( $user, $host )
604   ***      0                                  0                     = map { s/'/''/g; "'$_'"; }
      ***      0                                  0   
605                                                                       split('@', $trg->{definer}, 2);
606   ***      0                                  0                  $result .= "/*!50017 DEFINER=$user\@$host */ ";
607                                                               }
608   ***      0                                  0               $result .= sprintf("/*!50003 TRIGGER %s %s %s ON %s\nFOR EACH ROW %s */;;\n\n",
609                                                                  $quoter->quote($trg->{trigger}),
610   ***      0                                  0                  @{$trg}{qw(timing event)},
611                                                                  $quoter->quote($trg->{table}),
612                                                                  $trg->{statement});
613                                                            }
614   ***      0                                  0            $result .= "DELIMITER ;\n\n/*!50003 SET SESSION SQL_MODE=\@OLD_SQL_MODE */;\n\n";
615   ***      0                                  0            return $result;
616                                                         }
617                                                         else {
618   ***      0                                  0            return undef;
619                                                         }
620                                                      }
621                                                      elsif ( $what eq 'view' ) {
622   ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
623   ***      0                                  0         return '/*!50001 DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
624                                                            . '/*!50001 DROP VIEW IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
625                                                            . '/*!50001 ' . $ddl->[1] . "*/;\n";
626                                                      }
627                                                      else {
628   ***      0                                  0         die "You didn't say what to dump.";
629                                                      }
630                                                   }
631                                                   
632                                                   sub _use_db {
633           16                   16           141      my ( $self, $dbh, $quoter, $new ) = @_;
634           16    100                         116      if ( !$new ) {
635            7                                 24         MKDEBUG && _d('No new DB to use');
636            7                                 51         return;
637                                                      }
638            9                                 44      my $sql = 'SELECT DATABASE()';
639            9                                 30      MKDEBUG && _d($sql);
640            9                                 28      my $curr = $dbh->selectrow_array($sql);
641   ***      9    100     66                 1889      if ( $curr && $new && $curr eq $new ) {
      ***                   66                        
642            2                                  8         MKDEBUG && _d('Current and new DB are the same');
643            2                                 15         return $curr;
644                                                      }
645            7                                 55      $sql = 'USE ' . $quoter->quote($new);
646            7                                 25      MKDEBUG && _d($sql);
647            7                               1022      $dbh->do($sql);
648            7                                 83      return $curr;
649                                                   }
650                                                   
651                                                   sub get_create_table {
652            8                    8            74      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
653   ***      8     50     33                   97      if ( !$self->{cache} || !$self->{tables}->{$db}->{$tbl} ) {
654            8                                 41         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
655                                                            . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
656                                                            . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
657                                                            . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
658            8                                 26         MKDEBUG && _d($sql);
659            8                                 31         eval { $dbh->do($sql); };
               8                               1899   
660            8                                 38         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
661            8                                100         my $curr_db = $self->_use_db($dbh, $quoter, $db);
662            8                                 62         $sql = "SHOW CREATE TABLE " . $quoter->quote($db, $tbl);
663            8                                 32         MKDEBUG && _d($sql);
664            8                                 29         my $href;
665            8                                 31         eval { $href = $dbh->selectrow_hashref($sql); };
               8                                 30   
666   ***      8     50                          97         if ( $EVAL_ERROR ) {
667   ***      0                                  0            warn "Failed to $sql.  The table may be damaged.\nError: $EVAL_ERROR";
668   ***      0                                  0            return;
669                                                         }
670            8                                 59         $self->_use_db($dbh, $quoter, $curr_db);
671            8                                 35         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
672                                                            . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
673            8                                 90         MKDEBUG && _d($sql);
674            8                               1306         $dbh->do($sql);
675            8                                 89         my ($key) = grep { m/create table/i } keys %$href;
              16                                205   
676   ***      8     50                          59         if ( $key ) {
677            8                                 27            MKDEBUG && _d('This table is a base table');
678            8                                178            $self->{tables}->{$db}->{$tbl} = [ 'table', $href->{$key} ];
679                                                         }
680                                                         else {
681   ***      0                                  0            MKDEBUG && _d('This table is a view');
682   ***      0                                  0            ($key) = grep { m/create view/i } keys %$href;
      ***      0                                  0   
683   ***      0                                  0            $self->{tables}->{$db}->{$tbl} = [ 'view', $href->{$key} ];
684                                                         }
685                                                      }
686            8                                 97      return $self->{tables}->{$db}->{$tbl};
687                                                   }
688                                                   
689                                                   sub get_columns {
690   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
691   ***      0                                  0      MKDEBUG && _d('Get columns for', $db, $tbl);
692   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{columns}->{$db}->{$tbl} ) {
693   ***      0                                  0         my $curr_db = $self->_use_db($dbh, $quoter, $db);
694   ***      0                                  0         my $sql = "SHOW COLUMNS FROM " . $quoter->quote($db, $tbl);
695   ***      0                                  0         MKDEBUG && _d($sql);
696   ***      0                                  0         my $cols = $dbh->selectall_arrayref($sql, { Slice => {} });
697   ***      0                                  0         $self->_use_db($dbh, $quoter, $curr_db);
698   ***      0                                  0         $self->{columns}->{$db}->{$tbl} = [
699                                                            map {
700   ***      0                                  0               my %row;
701   ***      0                                  0               @row{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
702   ***      0                                  0               \%row;
703                                                            } @$cols
704                                                         ];
705                                                      }
706   ***      0                                  0      return $self->{columns}->{$db}->{$tbl};
707                                                   }
708                                                   
709                                                   sub get_tmp_table {
710   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
711   ***      0                                  0      my $result = 'CREATE TABLE ' . $quoter->quote($tbl) . " (\n";
712   ***      0                                  0      $result .= join(",\n",
713   ***      0                                  0         map { '  ' . $quoter->quote($_->{field}) . ' ' . $_->{type} }
714   ***      0                                  0         @{$self->get_columns($dbh, $quoter, $db, $tbl)});
715   ***      0                                  0      $result .= "\n)";
716   ***      0                                  0      MKDEBUG && _d($result);
717   ***      0                                  0      return $result;
718                                                   }
719                                                   
720                                                   sub get_triggers {
721   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
722   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{triggers}->{$db} ) {
723   ***      0                                  0         $self->{triggers}->{$db} = {};
724   ***      0                                  0         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
725                                                            . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
726                                                            . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
727                                                            . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
728   ***      0                                  0         MKDEBUG && _d($sql);
729   ***      0                                  0         eval { $dbh->do($sql); };
      ***      0                                  0   
730   ***      0                                  0         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
731   ***      0                                  0         $sql = "SHOW TRIGGERS FROM " . $quoter->quote($db);
732   ***      0                                  0         MKDEBUG && _d($sql);
733   ***      0                                  0         my $sth = $dbh->prepare($sql);
734   ***      0                                  0         $sth->execute();
735   ***      0      0                           0         if ( $sth->rows ) {
736   ***      0                                  0            my $trgs = $sth->fetchall_arrayref({});
737   ***      0                                  0            foreach my $trg (@$trgs) {
738   ***      0                                  0               my %trg;
739   ***      0                                  0               @trg{ map { lc $_ } keys %$trg } = values %$trg;
      ***      0                                  0   
740   ***      0                                  0               push @{ $self->{triggers}->{$db}->{ $trg{table} } }, \%trg;
      ***      0                                  0   
741                                                            }
742                                                         }
743   ***      0                                  0         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
744                                                            . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
745   ***      0                                  0         MKDEBUG && _d($sql);
746   ***      0                                  0         $dbh->do($sql);
747                                                      }
748   ***      0      0                           0      if ( $tbl ) {
749   ***      0                                  0         return $self->{triggers}->{$db}->{$tbl};
750                                                      }
751   ***      0                                  0      return values %{$self->{triggers}->{$db}};
      ***      0                                  0   
752                                                   }
753                                                   
754                                                   sub get_databases {
755   ***      0                    0             0      my ( $self, $dbh, $quoter, $like ) = @_;
756   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{databases} || $like ) {
      ***                    0                        
757   ***      0                                  0         my $sql = 'SHOW DATABASES';
758   ***      0                                  0         my @params;
759   ***      0      0                           0         if ( $like ) {
760   ***      0                                  0            $sql .= ' LIKE ?';
761   ***      0                                  0            push @params, $like;
762                                                         }
763   ***      0                                  0         my $sth = $dbh->prepare($sql);
764   ***      0                                  0         MKDEBUG && _d($sql, @params);
765   ***      0                                  0         $sth->execute( @params );
766   ***      0                                  0         my @dbs = map { $_->[0] } @{$sth->fetchall_arrayref()};
      ***      0                                  0   
      ***      0                                  0   
767   ***      0      0                           0         $self->{databases} = \@dbs unless $like;
768   ***      0                                  0         return @dbs;
769                                                      }
770   ***      0                                  0      return @{$self->{databases}};
      ***      0                                  0   
771                                                   }
772                                                   
773                                                   sub get_table_status {
774   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
775   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_status}->{$db} || $like ) {
      ***                    0                        
776   ***      0                                  0         my $sql = "SHOW TABLE STATUS FROM " . $quoter->quote($db);
777   ***      0                                  0         my @params;
778   ***      0      0                           0         if ( $like ) {
779   ***      0                                  0            $sql .= ' LIKE ?';
780   ***      0                                  0            push @params, $like;
781                                                         }
782   ***      0                                  0         MKDEBUG && _d($sql, @params);
783   ***      0                                  0         my $sth = $dbh->prepare($sql);
784   ***      0                                  0         $sth->execute(@params);
785   ***      0                                  0         my @tables = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
786   ***      0                                  0         @tables = map {
787   ***      0                                  0            my %tbl; # Make a copy with lowercased keys
788   ***      0                                  0            @tbl{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
789   ***      0             0                    0            $tbl{engine} ||= $tbl{type} || $tbl{comment};
      ***                    0                        
790   ***      0                                  0            delete $tbl{type};
791   ***      0                                  0            \%tbl;
792                                                         } @tables;
793   ***      0      0                           0         $self->{table_status}->{$db} = \@tables unless $like;
794   ***      0                                  0         return @tables;
795                                                      }
796   ***      0                                  0      return @{$self->{table_status}->{$db}};
      ***      0                                  0   
797                                                   }
798                                                   
799                                                   sub get_table_list {
800   ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
801   ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_list}->{$db} || $like ) {
      ***                    0                        
802   ***      0                                  0         my $sql = "SHOW /*!50002 FULL*/ TABLES FROM " . $quoter->quote($db);
803   ***      0                                  0         my @params;
804   ***      0      0                           0         if ( $like ) {
805   ***      0                                  0            $sql .= ' LIKE ?';
806   ***      0                                  0            push @params, $like;
807                                                         }
808   ***      0                                  0         MKDEBUG && _d($sql, @params);
809   ***      0                                  0         my $sth = $dbh->prepare($sql);
810   ***      0                                  0         $sth->execute(@params);
811   ***      0                                  0         my @tables = @{$sth->fetchall_arrayref()};
      ***      0                                  0   
812   ***      0      0      0                    0         @tables = map {
813   ***      0                                  0            my %tbl = (
814                                                               name   => $_->[0],
815                                                               engine => ($_->[1] || '') eq 'VIEW' ? 'VIEW' : '',
816                                                            );
817   ***      0                                  0            \%tbl;
818                                                         } @tables;
819   ***      0      0                           0         $self->{table_list}->{$db} = \@tables unless $like;
820   ***      0                                  0         return @tables;
821                                                      }
822   ***      0                                  0      return @{$self->{table_list}->{$db}};
      ***      0                                  0   
823                                                   }
824                                                   
825                                                   sub _d {
826   ***      0                    0             0      my ($package, undef, $line) = caller 0;
827   ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
828   ***      0                                  0           map { defined $_ ? $_ : 'undef' }
829                                                           @_;
830   ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
831                                                   }
832                                                   
833                                                   1;
834                                                   
835                                                   # ###########################################################################
836                                                   # End MySQLDump package
837                                                   # ###########################################################################
838                                                   
839                                                   # ###########################################################################
840                                                   # DSNParser package 6057
841                                                   # ###########################################################################
842                                                   package DSNParser;
843                                                   
844            6                    6            48   use strict;
               6                                 16   
               6                                 51   
845            6                    6            38   use warnings FATAL => 'all';
               6                                 12   
               6                                 32   
846            6                    6            35   use English qw(-no_match_vars);
               6                                 15   
               6                                 29   
847            6                    6            39   use Data::Dumper;
               6                                 15   
               6                                 34   
848                                                   $Data::Dumper::Indent    = 0;
849                                                   $Data::Dumper::Quotekeys = 0;
850                                                   
851                                                   eval {
852                                                      require DBI;
853                                                   };
854                                                   my $have_dbi = $EVAL_ERROR ? 0 : 1;
855                                                   
856   ***      6            50      6            41   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 13   
               6                                 80   
857                                                   
858                                                   sub new {
859           13                   13           268      my ( $class, %args ) = @_;
860           13                                169      foreach my $arg ( qw(opts) ) {
861   ***     13     50                         216         die "I need a $arg argument" unless $args{$arg};
862                                                      }
863           13                                 99      my $self = {
864                                                         opts => {}  # h, P, u, etc.  Should come from DSN OPTIONS section in POD.
865                                                      };
866           13                                 94      foreach my $opt ( @{$args{opts}} ) {
              13                                126   
867   ***    109     50     33                 1450         if ( !$opt->{key} || !$opt->{desc} ) {
868   ***      0                                  0            die "Invalid DSN option: ", Dumper($opt);
869                                                         }
870                                                         MKDEBUG && _d('DSN option:',
871                                                            join(', ',
872          109                                308               map { "$_=" . (defined $opt->{$_} ? ($opt->{$_} || '') : 'undef') }
873                                                                  keys %$opt
874                                                            )
875                                                         );
876   ***    109            50                 1545         $self->{opts}->{$opt->{key}} = {
877                                                            dsn  => $opt->{dsn},
878                                                            desc => $opt->{desc},
879                                                            copy => $opt->{copy} || 0,
880                                                         };
881                                                      }
882           13                                433      return bless $self, $class;
883                                                   }
884                                                   
885                                                   sub prop {
886           55                   55           385      my ( $self, $prop, $value ) = @_;
887           55    100                         381      if ( @_ > 2 ) {
888            8                                 28         MKDEBUG && _d('Setting', $prop, 'property');
889            8                                 53         $self->{$prop} = $value;
890                                                      }
891           55                                545      return $self->{$prop};
892                                                   }
893                                                   
894                                                   sub parse {
895           13                   13           508      my ( $self, $dsn, $prev, $defaults ) = @_;
896   ***     13     50                          93      if ( !$dsn ) {
897   ***      0                                  0         MKDEBUG && _d('No DSN to parse');
898   ***      0                                  0         return;
899                                                      }
900           13                                 53      MKDEBUG && _d('Parsing', $dsn);
901   ***     13            50                   97      $prev     ||= {};
902   ***     13            50                   84      $defaults ||= {};
903           13                                 58      my %given_props;
904           13                                 59      my %final_props;
905           13                                 75      my $opts = $self->{opts};
906                                                   
907           13                                166      foreach my $dsn_part ( split(/,/, $dsn) ) {
908   ***     36     50                         502         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
909           36                                246            $given_props{$prop_key} = $prop_val;
910                                                         }
911                                                         else {
912   ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
913   ***      0                                  0            $given_props{h} = $dsn_part;
914                                                         }
915                                                      }
916                                                   
917           13                                106      foreach my $key ( keys %$opts ) {
918          109                                312         MKDEBUG && _d('Finding value for', $key);
919          109                                512         $final_props{$key} = $given_props{$key};
920   ***    109     50     66                 1322         if (   !defined $final_props{$key}
      ***                   33                        
921                                                              && defined $prev->{$key} && $opts->{$key}->{copy} )
922                                                         {
923   ***      0                                  0            $final_props{$key} = $prev->{$key};
924   ***      0                                  0            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
925                                                         }
926          109    100                         618         if ( !defined $final_props{$key} ) {
927           73                                330            $final_props{$key} = $defaults->{$key};
928           73                                289            MKDEBUG && _d('Copying value for', $key, 'from defaults');
929                                                         }
930                                                      }
931                                                   
932           13                                100      foreach my $key ( keys %given_props ) {
933   ***     36     50                         224         die "Unknown DSN option '$key' in '$dsn'.  For more details, "
934                                                               . "please use the --help option, or try 'perldoc $PROGRAM_NAME' "
935                                                               . "for complete documentation."
936                                                            unless exists $opts->{$key};
937                                                      }
938   ***     13     50                          93      if ( (my $required = $self->prop('required')) ) {
939   ***      0                                  0         foreach my $key ( keys %$required ) {
940   ***      0      0                           0            die "Missing required DSN option '$key' in '$dsn'.  For more details, "
941                                                                  . "please use the --help option, or try 'perldoc $PROGRAM_NAME' "
942                                                                  . "for complete documentation."
943                                                               unless $final_props{$key};
944                                                         }
945                                                      }
946                                                   
947           13                                119      return \%final_props;
948                                                   }
949                                                   
950                                                   sub parse_options {
951            8                    8            61      my ( $self, $o ) = @_;
952   ***      8     50                          93      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
953           16                                114      my $dsn_string
954                                                         = join(',',
955           64    100                         384             map  { "$_=".$o->get($_); }
956            8                                 97             grep { $o->has($_) && $o->get($_) }
957            8                                 44             keys %{$self->{opts}}
958                                                           );
959            8                                 52      MKDEBUG && _d('DSN string made from options:', $dsn_string);
960            8                                 90      return $self->parse($dsn_string);
961                                                   }
962                                                   
963                                                   sub as_string {
964   ***      0                    0             0      my ( $self, $dsn, $props ) = @_;
965   ***      0      0                           0      return $dsn unless ref $dsn;
966   ***      0      0                           0      my %allowed = $props ? map { $_=>1 } @$props : ();
      ***      0                                  0   
967   ***      0      0                           0      return join(',',
968   ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_})  }
969   ***      0      0                           0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
970   ***      0                                  0         grep { !$props || $allowed{$_}                   }
971                                                         sort keys %$dsn );
972                                                   }
973                                                   
974                                                   sub usage {
975   ***      0                    0             0      my ( $self ) = @_;
976   ***      0                                  0      my $usage
977                                                         = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
978                                                         . "  KEY  COPY  MEANING\n"
979                                                         . "  ===  ====  =============================================\n";
980   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
981   ***      0                                  0      foreach my $key ( sort keys %opts ) {
982   ***      0      0      0                    0         $usage .= "  $key    "
983                                                                .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
984                                                                .  ($opts{$key}->{desc} || '[No description]')
985                                                                . "\n";
986                                                      }
987   ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
988   ***      0                                  0      return $usage;
989                                                   }
990                                                   
991                                                   sub get_cxn_params {
992           13                   13           117      my ( $self, $info ) = @_;
993           13                                 50      my $dsn;
994           13                                 54      my %opts = %{$self->{opts}};
              13                                214   
995   ***     13            50                  108      my $driver = $self->prop('dbidriver') || '';
996   ***     13     50                         134      if ( $driver eq 'Pg' ) {
997   ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
998   ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
999   ***      0             0                    0                        grep { defined $info->{$_} }
1000                                                                       qw(h P));
1001                                                     }
1002                                                     else {
1003          26                                303         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1004          65                                336            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1005  ***     13            50                  272                        grep { defined $info->{$_} }
1006                                                                       qw(F h P S A))
1007                                                           . ';mysql_read_default_group=client';
1008                                                     }
1009          13                                 55      MKDEBUG && _d($dsn);
1010          13                                221      return ($dsn, $info->{u}, $info->{p});
1011                                                  }
1012                                                  
1013                                                  sub fill_in_dsn {
1014  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1015  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1016  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1017  ***      0                                  0      $user =~ s/@.*//;
1018  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1019  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1020  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1021  ***      0             0                    0      $dsn->{u} ||= $user;
1022  ***      0             0                    0      $dsn->{D} ||= $db;
1023                                                  }
1024                                                  
1025                                                  sub get_dbh {
1026          13                   13           124      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1027  ***     13            50                   84      $opts ||= {};
1028  ***     13     50                         243      my $defaults = {
1029                                                        AutoCommit         => 0,
1030                                                        RaiseError         => 1,
1031                                                        PrintError         => 0,
1032                                                        ShowErrorStatement => 1,
1033                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
1034                                                     };
1035          13                                 91      @{$defaults}{ keys %$opts } = values %$opts;
              13                                 74   
1036                                                  
1037  ***     13     50                          91      if ( $opts->{mysql_use_result} ) {
1038  ***      0                                  0         $defaults->{mysql_use_result} = 1;
1039                                                     }
1040                                                  
1041  ***     13     50                         100      if ( !$have_dbi ) {
1042  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1043                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1044                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1045                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1046                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1047                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1048                                                  
1049                                                     }
1050                                                  
1051          13                                 46      my $dbh;
1052          13                                 53      my $tries = 2;
1053  ***     13            66                  219      while ( !$dbh && $tries-- ) {
1054                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1055          13                                 45            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1056                                                  
1057          13                                 53         eval {
1058          13                                263            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1059                                                  
1060  ***     13     50                         186            if ( $cxn_string =~ m/mysql/i ) {
1061          13                                 49               my $sql;
1062                                                  
1063          13                                 68               $sql = q{SET @@SQL_QUOTE_SHOW_CREATE = 1}
1064                                                                   . q{/*!40101, @@SQL_MODE='NO_AUTO_VALUE_ON_ZERO'*/};
1065          13                                 40               MKDEBUG && _d($dbh, ':', $sql);
1066          13                               1940               $dbh->do($sql);
1067                                                  
1068  ***     13     50                         142               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1069  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1070  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1071  ***      0                                  0                  $dbh->do($sql);
1072  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1073  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1074  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1075                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1076                                                                 }
1077                                                                 else {
1078  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1079                                                                 }
1080                                                              }
1081                                                  
1082          13    100                         106               if ( $self->prop('set-vars') ) {
1083           8                                 57                  $sql = "SET " . $self->prop('set-vars');
1084           8                                 31                  MKDEBUG && _d($dbh, ':', $sql);
1085           8                               1077                  $dbh->do($sql);
1086                                                              }
1087                                                           }
1088                                                        };
1089  ***     13     50     33                  189         if ( !$dbh && $EVAL_ERROR ) {
1090  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1091  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1092  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1093  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1094                                                           }
1095                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1096  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1097                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1098                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1099                                                                 . "DBD::mysql is not installed, try:\n"
1100                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1101                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1102                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1103                                                           }
1104  ***      0      0                           0            if ( !$tries ) {
1105  ***      0                                  0               die $EVAL_ERROR;
1106                                                           }
1107                                                        }
1108                                                     }
1109                                                  
1110          13                                 45      MKDEBUG && _d('DBH info: ',
1111                                                        $dbh,
1112                                                        Dumper($dbh->selectrow_hashref(
1113                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1114                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1115                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1116                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1117                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1118                                                        '$DBI::VERSION:',        $DBI::VERSION,
1119                                                     );
1120                                                  
1121          13                                 97      return $dbh;
1122                                                  }
1123                                                  
1124                                                  sub get_hostname {
1125  ***      0                    0             0      my ( $self, $dbh ) = @_;
1126  ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1127  ***      0                                  0         return $host;
1128                                                     }
1129  ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
1130                                                        'SELECT /*!50038 @@hostname, */ 1');
1131  ***      0                                  0      return $hostname;
1132                                                  }
1133                                                  
1134                                                  sub disconnect {
1135  ***      0                    0             0      my ( $self, $dbh ) = @_;
1136  ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
1137  ***      0                                  0      $dbh->disconnect;
1138                                                  }
1139                                                  
1140                                                  sub print_active_handles {
1141  ***      0                    0             0      my ( $self, $thing, $level ) = @_;
1142  ***      0             0                    0      $level ||= 0;
1143  ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1144                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1145                                                        or die "Cannot print: $OS_ERROR";
1146  ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
1147  ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
1148                                                     }
1149                                                  }
1150                                                  
1151                                                  sub copy {
1152  ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1153  ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
1154  ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
1155  ***      0                                  0      my %new_dsn = map {
1156  ***      0                                  0         my $key = $_;
1157  ***      0                                  0         my $val;
1158  ***      0      0                           0         if ( $args{overwrite} ) {
1159  ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1160                                                        }
1161                                                        else {
1162  ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1163                                                        }
1164  ***      0                                  0         $key => $val;
1165  ***      0                                  0      } keys %{$self->{opts}};
1166  ***      0                                  0      return \%new_dsn;
1167                                                  }
1168                                                  
1169                                                  sub _d {
1170  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1171  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1172  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1173                                                          @_;
1174  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1175                                                  }
1176                                                  
1177                                                  1;
1178                                                  
1179                                                  # ###########################################################################
1180                                                  # End DSNParser package
1181                                                  # ###########################################################################
1182                                                  
1183                                                  # ###########################################################################
1184                                                  # OptionParser package 5985
1185                                                  # ###########################################################################
1186                                                  package OptionParser;
1187                                                  
1188           6                    6            47   use strict;
               6                                 24   
               6                                 33   
1189           6                    6            38   use warnings FATAL => 'all';
               6                                 15   
               6                                 33   
1190                                                  
1191           6                    6            73   use Getopt::Long;
               6                                 20   
               6                                 41   
1192           6                    6            40   use List::Util qw(max);
               6                                 14   
               6                                 67   
1193           6                    6            41   use English qw(-no_match_vars);
               6                                 14   
               6                                 37   
1194                                                  
1195  ***      6            50      6            39   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 14   
               6                                 95   
1196                                                  
1197                                                  my $POD_link_re = '[LC]<"?([^">]+)"?>';
1198                                                  
1199                                                  sub new {
1200          16                   16           419      my ( $class, %args ) = @_;
1201          16                                191      foreach my $arg ( qw(description) ) {
1202  ***     16     50                         204         die "I need a $arg argument" unless $args{$arg};
1203                                                     }
1204                                                  
1205          16                                416      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
1206  ***     16            33                  129      $program_name ||= $PROGRAM_NAME;
1207  ***     16            33                  256      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                   33                        
      ***                   50                        
1208                                                  
1209          16                                367      my %attributes = (
1210                                                        'type'       => 1,
1211                                                        'short form' => 1,
1212                                                        'group'      => 1,
1213                                                        'default'    => 1,
1214                                                        'cumulative' => 1,
1215                                                        'negatable'  => 1,
1216                                                     );
1217                                                  
1218          16                               2169      my $self = {
1219                                                        strict            => 1,
1220                                                        prompt            => '<options>',
1221                                                        head1             => 'OPTIONS',
1222                                                        skip_rules        => 0,
1223                                                        item              => '--(.*)',
1224                                                        attributes        => \%attributes,
1225                                                        parse_attributes  => \&_parse_attribs,
1226                                                  
1227                                                        %args,
1228                                                  
1229                                                        program_name      => $program_name,
1230                                                        opts              => {},
1231                                                        got_opts          => 0,
1232                                                        short_opts        => {},
1233                                                        defaults          => {},
1234                                                        groups            => {},
1235                                                        allowed_groups    => {},
1236                                                        errors            => [],
1237                                                        rules             => [],  # desc of rules for --help
1238                                                        mutex             => [],  # rule: opts are mutually exclusive
1239                                                        atleast1          => [],  # rule: at least one opt is required
1240                                                        disables          => {},  # rule: opt disables other opts 
1241                                                        defaults_to       => {},  # rule: opt defaults to value of other opt
1242                                                        DSNParser         => undef,
1243                                                        default_files     => [
1244                                                           "/etc/maatkit/maatkit.conf",
1245                                                           "/etc/maatkit/$program_name.conf",
1246                                                           "$home/.maatkit.conf",
1247                                                           "$home/.$program_name.conf",
1248                                                        ],
1249                                                        types             => {
1250                                                           string => 's', # standard Getopt type
1251                                                           int    => 'i', # standard Getopt type
1252                                                           float  => 'f', # standard Getopt type
1253                                                           Hash   => 'H', # hash, formed from a comma-separated list
1254                                                           hash   => 'h', # hash as above, but only if a value is given
1255                                                           Array  => 'A', # array, similar to Hash
1256                                                           array  => 'a', # array, similar to hash
1257                                                           DSN    => 'd', # DSN
1258                                                           size   => 'z', # size with kMG suffix (powers of 2^10)
1259                                                           time   => 'm', # time, with an optional suffix of s/h/m/d
1260                                                        },
1261                                                     };
1262                                                  
1263          16                                311      return bless $self, $class;
1264                                                  }
1265                                                  
1266                                                  sub get_specs {
1267           8                    8            58      my ( $self, $file ) = @_;
1268  ***      8            50                   81      $file ||= __FILE__;
1269           8                                152      my @specs = $self->_pod_to_specs($file);
1270           8                                383      $self->_parse_specs(@specs);
1271                                                  
1272  ***      8     50                         407      open my $fh, "<", $file or die "Cannot open $file: $OS_ERROR";
1273           8                                 36      my $contents = do { local $/ = undef; <$fh> };
               8                                 89   
               8                               3287   
1274           8                                 75      close $file;
1275  ***      8     50                         775      if ( $contents =~ m/^=head1 DSN OPTIONS/m ) {
1276           8                                 32         MKDEBUG && _d('Parsing DSN OPTIONS');
1277           8                                108         my $dsn_attribs = {
1278                                                           dsn  => 1,
1279                                                           copy => 1,
1280                                                        };
1281                                                        my $parse_dsn_attribs = sub {
1282          64                   64           465            my ( $self, $option, $attribs ) = @_;
1283         128                                660            map {
1284          64                                495               my $val = $attribs->{$_};
1285  ***    128     50                         973               if ( $val ) {
1286  ***    128     50                         943                  $val    = $val eq 'yes' ? 1
                    100                               
1287                                                                         : $val eq 'no'  ? 0
1288                                                                         :                 $val;
1289         128                               1380                  $attribs->{$_} = $val;
1290                                                              }
1291                                                           } keys %$attribs;
1292                                                           return {
1293          64                               1411               key => $option,
1294                                                              %$attribs,
1295                                                           };
1296           8                                212         };
1297           8                                145         my $dsn_o = new OptionParser(
1298                                                           description       => 'DSN OPTIONS',
1299                                                           head1             => 'DSN OPTIONS',
1300                                                           dsn               => 0,         # XXX don't infinitely recurse!
1301                                                           item              => '\* (.)',  # key opts are a single character
1302                                                           skip_rules        => 1,         # no rules before opts
1303                                                           attributes        => $dsn_attribs,
1304                                                           parse_attributes  => $parse_dsn_attribs,
1305                                                        );
1306          64                               1105         my @dsn_opts = map {
1307           8                                 75            my $opts = {
1308                                                              key  => $_->{spec}->{key},
1309                                                              dsn  => $_->{spec}->{dsn},
1310                                                              copy => $_->{spec}->{copy},
1311                                                              desc => $_->{desc},
1312                                                           };
1313          64                                403            $opts;
1314                                                        } $dsn_o->_pod_to_specs($file);
1315           8                                370         $self->{DSNParser} = DSNParser->new(opts => \@dsn_opts);
1316                                                     }
1317                                                  
1318           8                                 30      return;
1319                                                  }
1320                                                  
1321                                                  sub DSNParser {
1322           8                    8            49      my ( $self ) = @_;
1323           8                                 56      return $self->{DSNParser};
1324                                                  };
1325                                                  
1326                                                  sub get_defaults_files {
1327           8                    8            57      my ( $self ) = @_;
1328           8                                 37      return @{$self->{default_files}};
               8                                141   
1329                                                  }
1330                                                  
1331                                                  sub _pod_to_specs {
1332          16                   16           134      my ( $self, $file ) = @_;
1333  ***     16            50                  120      $file ||= __FILE__;
1334  ***     16     50                         958      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
1335                                                  
1336          16                                100      my @specs = ();
1337          16                                 79      my @rules = ();
1338          16                                 59      my $para;
1339                                                  
1340          16                                228      local $INPUT_RECORD_SEPARATOR = '';
1341          16                                503      while ( $para = <$fh> ) {
1342        8344    100                      121560         next unless $para =~ m/^=head1 $self->{head1}/;
1343          16                                 85         last;
1344                                                     }
1345                                                  
1346          16                                170      while ( $para = <$fh> ) {
1347          24    100                         266         last if $para =~ m/^=over/;
1348  ***      8     50                         111         next if $self->{skip_rules};
1349  ***      0                                  0         chomp $para;
1350  ***      0                                  0         $para =~ s/\s+/ /g;
1351  ***      0                                  0         $para =~ s/$POD_link_re/$1/go;
1352  ***      0                                  0         MKDEBUG && _d('Option rule:', $para);
1353  ***      0                                  0         push @rules, $para;
1354                                                     }
1355                                                  
1356  ***     16     50                         114      die "POD has no $self->{head1} section" unless $para;
1357                                                  
1358          16                                 69      do {
1359         288    100                        4754         if ( my ($option) = $para =~ m/^=item $self->{item}/ ) {
1360         272                               1155            chomp $para;
1361         272                                869            MKDEBUG && _d($para);
1362         272                                984            my %attribs;
1363                                                  
1364         272                               1584            $para = <$fh>; # read next paragraph, possibly attributes
1365                                                  
1366         272    100                        1908            if ( $para =~ m/: / ) { # attributes
1367         232                               1920               $para =~ s/\s+\Z//g;
1368         392                               3112               %attribs = map {
1369         232                               1854                     my ( $attrib, $val) = split(/: /, $_);
1370  ***    392     50                        3358                     die "Unrecognized attribute for --$option: $attrib"
1371                                                                       unless $self->{attributes}->{$attrib};
1372         392                               3544                     ($attrib, $val);
1373                                                                 } split(/; /, $para);
1374         232    100                        1917               if ( $attribs{'short form'} ) {
1375          88                                734                  $attribs{'short form'} =~ s/-//;
1376                                                              }
1377         232                               1654               $para = <$fh>; # read next paragraph, probably short help desc
1378                                                           }
1379                                                           else {
1380          40                                156               MKDEBUG && _d('Option has no attributes');
1381                                                           }
1382                                                  
1383         272                               3112            $para =~ s/\s+\Z//g;
1384         272                               3105            $para =~ s/\s+/ /g;
1385         272                               1527            $para =~ s/$POD_link_re/$1/go;
1386                                                  
1387         272                               1657            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
1388         272                                886            MKDEBUG && _d('Short help:', $para);
1389                                                  
1390  ***    272     50                        1895            die "No description after option spec $option" if $para =~ m/^=item/;
1391                                                  
1392         272    100                        2187            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
1393          24                                113               $option = $base_option;
1394          24                                180               $attribs{'negatable'} = 1;
1395                                                           }
1396                                                  
1397         272    100                        2749            push @specs, {
      ***            50                               
1398                                                              spec  => $self->{parse_attributes}->($self, $option, \%attribs), 
1399                                                              desc  => $para
1400                                                                 . ($attribs{default} ? " (default $attribs{default})" : ''),
1401                                                              group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
1402                                                           };
1403                                                        }
1404         288                               3361         while ( $para = <$fh> ) {
1405  ***    392     50                        2238            last unless $para;
1406         392    100                        3974            if ( $para =~ m/^=head1/ ) {
1407          16                                 78               $para = undef; # Can't 'last' out of a do {} block.
1408          16                                144               last;
1409                                                           }
1410         376    100                        4336            last if $para =~ m/^=item /;
1411                                                        }
1412                                                     } while ( $para );
1413                                                  
1414  ***     16     50                         110      die "No valid specs in $self->{head1}" unless @specs;
1415                                                  
1416          16                                301      close $fh;
1417          16                                 83      return @specs, @rules;
1418                                                  }
1419                                                  
1420                                                  sub _parse_specs {
1421           8                    8           106      my ( $self, @specs ) = @_;
1422           8                                 47      my %disables; # special rule that requires deferred checking
1423                                                  
1424           8                                 77      foreach my $opt ( @specs ) {
1425  ***    208     50                        1229         if ( ref $opt ) { # It's an option spec, not a rule.
1426                                                           MKDEBUG && _d('Parsing opt spec:',
1427         208                                701               map { ($_, '=>', $opt->{$_}) } keys %$opt);
1428                                                  
1429         208                               2696            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
1430  ***    208     50                        1416            if ( !$long ) {
1431  ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
1432                                                           }
1433         208                               1188            $opt->{long} = $long;
1434                                                  
1435  ***    208     50                        1596            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
1436         208                               1697            $self->{opts}->{$long} = $opt;
1437                                                  
1438  ***    208     50                        1404            if ( length $long == 1 ) {
1439  ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
1440  ***      0                                  0               $self->{short_opts}->{$long} = $long;
1441                                                           }
1442                                                  
1443         208    100                        1092            if ( $short ) {
1444  ***     88     50                         742               die "Duplicate short option -$short"
1445                                                                 if exists $self->{short_opts}->{$short};
1446          88                                726               $self->{short_opts}->{$short} = $long;
1447          88                                521               $opt->{short} = $short;
1448                                                           }
1449                                                           else {
1450         120                                704               $opt->{short} = undef;
1451                                                           }
1452                                                  
1453         208    100                        1884            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
1454  ***    208     50                        1763            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
1455  ***    208     50                        2036            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
1456                                                  
1457  ***    208            50                 1434            $opt->{group} ||= 'default';
1458         208                               1762            $self->{groups}->{ $opt->{group} }->{$long} = 1;
1459                                                  
1460         208                               1100            $opt->{value} = undef;
1461         208                               1132            $opt->{got}   = 0;
1462                                                  
1463         208                               1923            my ( $type ) = $opt->{spec} =~ m/=(.)/;
1464         208                               1202            $opt->{type} = $type;
1465         208                                675            MKDEBUG && _d($long, 'type:', $type);
1466                                                  
1467                                                  
1468         208    100    100                 2950            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
1469                                                  
1470         208    100                        2156            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
1471  ***     40     50                         382               $self->{defaults}->{$long} = defined $def ? $def : 1;
1472          40                                148               MKDEBUG && _d($long, 'default:', $def);
1473                                                           }
1474                                                  
1475         208    100                        1314            if ( $long eq 'config' ) {
1476           8                                 76               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
1477                                                           }
1478                                                  
1479  ***    208     50                        1788            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
1480  ***      0                                  0               $disables{$long} = $dis;
1481  ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
1482                                                           }
1483                                                  
1484         208                               1686            $self->{opts}->{$long} = $opt;
1485                                                        }
1486                                                        else { # It's an option rule, not a spec.
1487  ***      0                                  0            MKDEBUG && _d('Parsing rule:', $opt); 
1488  ***      0                                  0            push @{$self->{rules}}, $opt;
      ***      0                                  0   
1489  ***      0                                  0            my @participants = $self->_get_participants($opt);
1490  ***      0                                  0            my $rule_ok = 0;
1491                                                  
1492  ***      0      0                           0            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
1493  ***      0                                  0               $rule_ok = 1;
1494  ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
1495  ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
1496                                                           }
1497  ***      0      0                           0            if ( $opt =~ m/at least one|one and only one/ ) {
1498  ***      0                                  0               $rule_ok = 1;
1499  ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
1500  ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
1501                                                           }
1502  ***      0      0                           0            if ( $opt =~ m/default to/ ) {
1503  ***      0                                  0               $rule_ok = 1;
1504  ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
1505  ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
1506                                                           }
1507  ***      0      0                           0            if ( $opt =~ m/restricted to option groups/ ) {
1508  ***      0                                  0               $rule_ok = 1;
1509  ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
1510  ***      0                                  0               my @groups = split(',', $groups);
1511  ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
1512  ***      0                                  0                  s/\s+//;
1513  ***      0                                  0                  $_ => 1;
1514                                                              } @groups;
1515                                                           }
1516                                                  
1517  ***      0      0                           0            die "Unrecognized option rule: $opt" unless $rule_ok;
1518                                                        }
1519                                                     }
1520                                                  
1521           8                                 84      foreach my $long ( keys %disables ) {
1522  ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
1523  ***      0                                  0         $self->{disables}->{$long} = \@participants;
1524  ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
1525                                                     }
1526                                                  
1527           8                                 66      return; 
1528                                                  }
1529                                                  
1530                                                  sub _get_participants {
1531  ***      0                    0             0      my ( $self, $str ) = @_;
1532  ***      0                                  0      my @participants;
1533  ***      0                                  0      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
1534  ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
1535                                                           unless exists $self->{opts}->{$long};
1536  ***      0                                  0         push @participants, $long;
1537                                                     }
1538  ***      0                                  0      MKDEBUG && _d('Participants for', $str, ':', @participants);
1539  ***      0                                  0      return @participants;
1540                                                  }
1541                                                  
1542                                                  sub opts {
1543  ***      0                    0             0      my ( $self ) = @_;
1544  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1545  ***      0                                  0      return %opts;
1546                                                  }
1547                                                  
1548                                                  sub short_opts {
1549  ***      0                    0             0      my ( $self ) = @_;
1550  ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
1551  ***      0                                  0      return %short_opts;
1552                                                  }
1553                                                  
1554                                                  sub set_defaults {
1555  ***      0                    0             0      my ( $self, %defaults ) = @_;
1556  ***      0                                  0      $self->{defaults} = {};
1557  ***      0                                  0      foreach my $long ( keys %defaults ) {
1558  ***      0      0                           0         die "Cannot set default for nonexistent option $long"
1559                                                           unless exists $self->{opts}->{$long};
1560  ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
1561  ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
1562                                                     }
1563  ***      0                                  0      return;
1564                                                  }
1565                                                  
1566                                                  sub get_defaults {
1567  ***      0                    0             0      my ( $self ) = @_;
1568  ***      0                                  0      return $self->{defaults};
1569                                                  }
1570                                                  
1571                                                  sub get_groups {
1572  ***      0                    0             0      my ( $self ) = @_;
1573  ***      0                                  0      return $self->{groups};
1574                                                  }
1575                                                  
1576                                                  sub _set_option {
1577          28                   28           200      my ( $self, $opt, $val ) = @_;
1578  ***     28      0                          90      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
1579                                                              : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
1580                                                              : die "Getopt::Long gave a nonexistent option: $opt";
1581                                                  
1582          28                                 74      $opt = $self->{opts}->{$long};
1583  ***     28     50                         254      if ( $opt->{is_cumulative} ) {
1584  ***      0                                  0         $opt->{value}++;
1585                                                     }
1586                                                     else {
1587          28                                163         $opt->{value} = $val;
1588                                                     }
1589          28                                143      $opt->{got} = 1;
1590          28                                163      MKDEBUG && _d('Got option', $long, '=', $val);
1591                                                  }
1592                                                  
1593                                                  sub get_opts {
1594           8                    8            59      my ( $self ) = @_; 
1595                                                  
1596           8                                 37      foreach my $long ( keys %{$self->{opts}} ) {
               8                                186   
1597         208                               1446         $self->{opts}->{$long}->{got} = 0;
1598  ***    208     50                        3022         $self->{opts}->{$long}->{value}
                    100                               
1599                                                           = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
1600                                                           : $self->{opts}->{$long}->{is_cumulative} ? 0
1601                                                           : undef;
1602                                                     }
1603           8                                 74      $self->{got_opts} = 0;
1604                                                  
1605           8                                 58      $self->{errors} = [];
1606                                                  
1607  ***      8     50     33                  205      if ( @ARGV && $ARGV[0] eq "--config" ) {
1608  ***      0                                  0         shift @ARGV;
1609  ***      0                                  0         $self->_set_option('config', shift @ARGV);
1610                                                     }
1611  ***      8     50                         133      if ( $self->has('config') ) {
1612           8                                 35         my @extra_args;
1613           8                                118         foreach my $filename ( split(',', $self->get('config')) ) {
1614          32                                139            eval {
1615          32                                281               push @extra_args, $self->_read_config_file($filename);
1616                                                           };
1617  ***     32     50                         285            if ( $EVAL_ERROR ) {
1618  ***     32     50                         256               if ( $self->got('config') ) {
1619  ***      0                                  0                  die $EVAL_ERROR;
1620                                                              }
1621                                                              elsif ( MKDEBUG ) {
1622                                                                 _d($EVAL_ERROR);
1623                                                              }
1624                                                           }
1625                                                        }
1626           8                                 67         unshift @ARGV, @extra_args;
1627                                                     }
1628                                                  
1629           8                                163      Getopt::Long::Configure('no_ignore_case', 'bundling');
1630                                                     GetOptions(
1631         200                   28          2380         map    { $_->{spec} => sub { $self->_set_option(@_); } }
              28                                257   
             208                               1325   
1632           8                                 85         grep   { $_->{long} ne 'config' } # --config is handled specially above.
1633  ***      8     50                          48         values %{$self->{opts}}
1634                                                     ) or $self->save_error('Error parsing options');
1635                                                  
1636  ***      8     50     33                  659      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
1637  ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
1638                                                           $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
1639                                                              or die "Cannot print: $OS_ERROR";
1640  ***      0                                  0         exit 0;
1641                                                     }
1642                                                  
1643  ***      8     50     33                   74      if ( @ARGV && $self->{strict} ) {
1644  ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
1645                                                     }
1646                                                  
1647           8                                 35      foreach my $mutex ( @{$self->{mutex}} ) {
               8                                 76   
1648  ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
1649  ***      0      0                           0         if ( @set > 1 ) {
1650  ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
1651  ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
1652                                                                   . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
1653                                                                   . ' are mutually exclusive.';
1654  ***      0                                  0            $self->save_error($err);
1655                                                        }
1656                                                     }
1657                                                  
1658           8                                 36      foreach my $required ( @{$self->{atleast1}} ) {
               8                                 87   
1659  ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
1660  ***      0      0                           0         if ( @set == 0 ) {
1661  ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
1662  ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
1663                                                                   .' or --'.$self->{opts}->{$required->[-1]}->{long};
1664  ***      0                                  0            $self->save_error("Specify at least one of $err");
1665                                                        }
1666                                                     }
1667                                                  
1668           8                                 37      $self->_check_opts( keys %{$self->{opts}} );
               8                                242   
1669           8                                 71      $self->{got_opts} = 1;
1670           8                                 36      return;
1671                                                  }
1672                                                  
1673                                                  sub _check_opts {
1674           8                    8           159      my ( $self, @long ) = @_;
1675           8                                 62      my $long_last = scalar @long;
1676           8                                 54      while ( @long ) {
1677           8                                126         foreach my $i ( 0..$#long ) {
1678         208                                996            my $long = $long[$i];
1679  ***    208     50                        1097            next unless $long;
1680         208                               1362            my $opt  = $self->{opts}->{$long};
1681         208    100                        2349            if ( $opt->{got} ) {
      ***            50                               
1682  ***     28     50                         210               if ( exists $self->{disables}->{$long} ) {
1683  ***      0                                  0                  my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
1684  ***      0                                  0                  map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
1685  ***      0                                  0                  MKDEBUG && _d('Unset options', @disable_opts,
1686                                                                    'because', $long,'disables them');
1687                                                              }
1688                                                  
1689  ***     28     50                         219               if ( exists $self->{allowed_groups}->{$long} ) {
1690                                                  
1691  ***      0                                  0                  my @restricted_groups = grep {
1692  ***      0                                  0                     !exists $self->{allowed_groups}->{$long}->{$_}
1693  ***      0                                  0                  } keys %{$self->{groups}};
1694                                                  
1695  ***      0                                  0                  my @restricted_opts;
1696  ***      0                                  0                  foreach my $restricted_group ( @restricted_groups ) {
1697  ***      0                                  0                     RESTRICTED_OPT:
1698  ***      0                                  0                     foreach my $restricted_opt (
1699                                                                       keys %{$self->{groups}->{$restricted_group}} )
1700                                                                    {
1701  ***      0      0                           0                        next RESTRICTED_OPT if $restricted_opt eq $long;
1702  ***      0      0                           0                        push @restricted_opts, $restricted_opt
1703                                                                          if $self->{opts}->{$restricted_opt}->{got};
1704                                                                    }
1705                                                                 }
1706                                                  
1707  ***      0      0                           0                  if ( @restricted_opts ) {
1708  ***      0                                  0                     my $err;
1709  ***      0      0                           0                     if ( @restricted_opts == 1 ) {
1710  ***      0                                  0                        $err = "--$restricted_opts[0]";
1711                                                                    }
1712                                                                    else {
1713  ***      0                                  0                        $err = join(', ',
1714  ***      0                                  0                                  map { "--$self->{opts}->{$_}->{long}" }
1715  ***      0                                  0                                  grep { $_ } 
1716                                                                                 @restricted_opts[0..scalar(@restricted_opts) - 2]
1717                                                                              )
1718                                                                            . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
1719                                                                    }
1720  ***      0                                  0                     $self->save_error("--$long is not allowed with $err");
1721                                                                 }
1722                                                              }
1723                                                  
1724                                                           }
1725                                                           elsif ( $opt->{is_required} ) { 
1726  ***      0                                  0               $self->save_error("Required option --$long must be specified");
1727                                                           }
1728                                                  
1729         208                               1224            $self->_validate_type($opt);
1730  ***    208     50                        1200            if ( $opt->{parsed} ) {
1731         208                               1181               delete $long[$i];
1732                                                           }
1733                                                           else {
1734  ***      0                                  0               MKDEBUG && _d('Temporarily failed to parse', $long);
1735                                                           }
1736                                                        }
1737                                                  
1738  ***      8     50                          70         die "Failed to parse options, possibly due to circular dependencies"
1739                                                           if @long == $long_last;
1740           8                                 67         $long_last = @long;
1741                                                     }
1742                                                  
1743           8                                 49      return;
1744                                                  }
1745                                                  
1746                                                  sub _validate_type {
1747         208                  208          1141      my ( $self, $opt ) = @_;
1748  ***    208     50                        1194      return unless $opt;
1749                                                  
1750         208    100                        1585      if ( !$opt->{type} ) {
1751          72                                967         $opt->{parsed} = 1;
1752          72                                309         return;
1753                                                     }
1754                                                  
1755         136                                687      my $val = $opt->{value};
1756                                                  
1757  ***    136     50     66                 5856      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***            50     66                        
      ***            50     66                        
                    100    100                        
                    100    100                        
      ***                   66                        
      ***                   66                        
1758  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
1759  ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
1760  ***      0      0                           0         if ( !$suffix ) {
1761  ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
1762  ***      0             0                    0            $suffix = $s || 's';
1763  ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
1764                                                              $opt->{long}, '(value:', $val, ')');
1765                                                        }
1766  ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
1767  ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
1768                                                                : $suffix eq 'm' ? $num * 60       # Minutes
1769                                                                : $suffix eq 'h' ? $num * 3600     # Hours
1770                                                                :                  $num * 86400;   # Days
1771  ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
1772  ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
1773                                                        }
1774                                                        else {
1775  ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
1776                                                        }
1777                                                     }
1778                                                     elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
1779  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
1780  ***      0                                  0         my $prev = {};
1781  ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
1782  ***      0      0                           0         if ( $from_key ) {
1783  ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
1784  ***      0      0                           0            if ( $self->{opts}->{$from_key}->{parsed} ) {
1785  ***      0                                  0               $prev = $self->{opts}->{$from_key}->{value};
1786                                                           }
1787                                                           else {
1788  ***      0                                  0               MKDEBUG && _d('Cannot parse', $opt->{long}, 'until',
1789                                                                 $from_key, 'parsed');
1790  ***      0                                  0               return;
1791                                                           }
1792                                                        }
1793  ***      0                                  0         my $defaults = $self->{DSNParser}->parse_options($self);
1794  ***      0                                  0         $opt->{value} = $self->{DSNParser}->parse($val, $prev, $defaults);
1795                                                     }
1796                                                     elsif ( $val && $opt->{type} eq 'z' ) {  # type size
1797  ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
1798  ***      0                                  0         $self->_parse_size($opt, $val);
1799                                                     }
1800                                                     elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
1801          34           100                  502         $opt->{value} = { map { $_ => 1 } split(',', ($val || '')) };
              10                                131   
1802                                                     }
1803                                                     elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
1804  ***      8            50                  220         $opt->{value} = [ split(/(?<!\\),\s*/, ($val || '')) ];
1805                                                     }
1806                                                     else {
1807          94                                319         MKDEBUG && _d('Nothing to validate for option',
1808                                                           $opt->{long}, 'type', $opt->{type}, 'value', $val);
1809                                                     }
1810                                                  
1811         136                                723      $opt->{parsed} = 1;
1812         136                                569      return;
1813                                                  }
1814                                                  
1815                                                  sub get {
1816         238                  238          1476      my ( $self, $opt ) = @_;
1817         238    100                        1886      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1818  ***    238     50     33                 3597      die "Option $opt does not exist"
1819                                                        unless $long && exists $self->{opts}->{$long};
1820         238                               3536      return $self->{opts}->{$long}->{value};
1821                                                  }
1822                                                  
1823                                                  sub got {
1824          48                   48           368      my ( $self, $opt ) = @_;
1825  ***     48     50                         370      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1826  ***     48     50     33                  823      die "Option $opt does not exist"
1827                                                        unless $long && exists $self->{opts}->{$long};
1828          48                                539      return $self->{opts}->{$long}->{got};
1829                                                  }
1830                                                  
1831                                                  sub has {
1832         144                  144           904      my ( $self, $opt ) = @_;
1833         144    100                        1145      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1834         144    100                        2198      return defined $long ? exists $self->{opts}->{$long} : 0;
1835                                                  }
1836                                                  
1837                                                  sub set {
1838  ***      0                    0             0      my ( $self, $opt, $val ) = @_;
1839  ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
1840  ***      0      0      0                    0      die "Option $opt does not exist"
1841                                                        unless $long && exists $self->{opts}->{$long};
1842  ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
1843  ***      0                                  0      return;
1844                                                  }
1845                                                  
1846                                                  sub save_error {
1847  ***      0                    0             0      my ( $self, $error ) = @_;
1848  ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
1849                                                  }
1850                                                  
1851                                                  sub errors {
1852  ***      0                    0             0      my ( $self ) = @_;
1853  ***      0                                  0      return $self->{errors};
1854                                                  }
1855                                                  
1856                                                  sub prompt {
1857  ***      0                    0             0      my ( $self ) = @_;
1858  ***      0                                  0      return "Usage: $PROGRAM_NAME $self->{prompt}\n";
1859                                                  }
1860                                                  
1861                                                  sub descr {
1862  ***      0                    0             0      my ( $self ) = @_;
1863  ***      0             0                    0      my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
1864                                                                . "  For more details, please use the --help option, "
1865                                                                . "or try 'perldoc $PROGRAM_NAME' "
1866                                                                . "for complete documentation.";
1867  ***      0      0                           0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g)
1868                                                        unless $ENV{DONT_BREAK_LINES};
1869  ***      0                                  0      $descr =~ s/ +$//mg;
1870  ***      0                                  0      return $descr;
1871                                                  }
1872                                                  
1873                                                  sub usage_or_errors {
1874           8                    8            47      my ( $self ) = @_;
1875  ***      8     50                          77      if ( $self->{opts}->{help}->{got} ) {
      ***      8     50                          73   
1876  ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
1877  ***      0                                  0         exit 0;
1878                                                     }
1879                                                     elsif ( scalar @{$self->{errors}} ) {
1880  ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
1881  ***      0                                  0         exit 0;
1882                                                     }
1883           8                                 33      return;
1884                                                  }
1885                                                  
1886                                                  sub print_errors {
1887  ***      0                    0             0      my ( $self ) = @_;
1888  ***      0                                  0      my $usage = $self->prompt() . "\n";
1889  ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
1890  ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
1891                                                                . "\n";
1892                                                     }
1893  ***      0                                  0      return $usage . "\n" . $self->descr();
1894                                                  }
1895                                                  
1896                                                  sub print_usage {
1897  ***      0                    0             0      my ( $self ) = @_;
1898  ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
1899  ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
1900                                                  
1901  ***      0      0                           0      my $maxl = max(
1902  ***      0                                  0         map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
1903                                                        @opts);
1904                                                  
1905  ***      0      0                           0      my $maxs = max(0,
1906  ***      0                                  0         map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
1907  ***      0                                  0         values %{$self->{short_opts}});
1908                                                  
1909  ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
1910  ***      0                                  0      my $rcol = 80 - $lcol - 6;
1911  ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
1912                                                  
1913  ***      0                                  0      $maxs = max($lcol - 3, $maxs);
1914                                                  
1915  ***      0                                  0      my $usage = $self->descr() . "\n" . $self->prompt();
1916                                                  
1917  ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
1918  ***      0                                  0      push @groups, 'default';
1919                                                  
1920  ***      0                                  0      foreach my $group ( reverse @groups ) {
1921  ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
1922  ***      0                                  0         foreach my $opt (
      ***      0                                  0   
1923  ***      0                                  0            sort { $a->{long} cmp $b->{long} }
1924                                                           grep { $_->{group} eq $group }
1925                                                           @opts )
1926                                                        {
1927  ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
1928  ***      0                                  0            my $short = $opt->{short};
1929  ***      0                                  0            my $desc  = $opt->{desc};
1930  ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
1931  ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
1932  ***      0             0                    0               $s    ||= 's';
1933  ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
1934  ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
1935                                                                     . "d=days; if no suffix, $s is used.";
1936                                                           }
1937  ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
1938  ***      0                                  0            $desc =~ s/ +$//mg;
1939  ***      0      0                           0            if ( $short ) {
1940  ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
1941                                                           }
1942                                                           else {
1943  ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
1944                                                           }
1945                                                        }
1946                                                     }
1947                                                  
1948  ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
1949  ***      0                                  0         $usage .= "\nRules:\n\n";
1950  ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
1951                                                     }
1952  ***      0      0                           0      if ( $self->{DSNParser} ) {
1953  ***      0                                  0         $usage .= "\n" . $self->{DSNParser}->usage();
1954                                                     }
1955  ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
1956  ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
1957  ***      0                                  0         my $val   = $opt->{value};
1958  ***      0             0                    0         my $type  = $opt->{type} || '';
1959  ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
1960  ***      0      0                           0         $val      = $bool              ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
1961                                                                  : !defined $val      ? '(No value)'
1962                                                                  : $type eq 'd'       ? $self->{DSNParser}->as_string($val)
1963                                                                  : $type =~ m/H|h/    ? join(',', sort keys %$val)
1964                                                                  : $type =~ m/A|a/    ? join(',', @$val)
1965                                                                  :                    $val;
1966  ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
1967                                                     }
1968  ***      0                                  0      return $usage;
1969                                                  }
1970                                                  
1971                                                  sub prompt_noecho {
1972  ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
1973  ***      0                                  0      my ( $prompt ) = @_;
1974  ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
1975  ***      0      0                           0      print $prompt
1976                                                        or die "Cannot print: $OS_ERROR";
1977  ***      0                                  0      my $response;
1978  ***      0                                  0      eval {
1979  ***      0                                  0         require Term::ReadKey;
1980  ***      0                                  0         Term::ReadKey::ReadMode('noecho');
1981  ***      0                                  0         chomp($response = <STDIN>);
1982  ***      0                                  0         Term::ReadKey::ReadMode('normal');
1983  ***      0      0                           0         print "\n"
1984                                                           or die "Cannot print: $OS_ERROR";
1985                                                     };
1986  ***      0      0                           0      if ( $EVAL_ERROR ) {
1987  ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
1988                                                     }
1989  ***      0                                  0      return $response;
1990                                                  }
1991                                                  
1992                                                  if ( MKDEBUG ) {
1993                                                     print '# ', $^X, ' ', $], "\n";
1994                                                     my $uname = `uname -a`;
1995                                                     if ( $uname ) {
1996                                                        $uname =~ s/\s+/ /g;
1997                                                        print "# $uname\n";
1998                                                     }
1999                                                     printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
2000                                                        $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
2001                                                        ($main::SVN_REV || ''), __LINE__);
2002                                                     print('# Arguments: ',
2003                                                        join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
2004                                                  }
2005                                                  
2006                                                  sub _read_config_file {
2007          32                   32           224      my ( $self, $filename ) = @_;
2008  ***     32     50                         113      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
2009  ***      0                                  0      my @args;
2010  ***      0                                  0      my $prefix = '--';
2011  ***      0                                  0      my $parse  = 1;
2012                                                  
2013                                                     LINE:
2014  ***      0                                  0      while ( my $line = <$fh> ) {
2015  ***      0                                  0         chomp $line;
2016  ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
2017  ***      0                                  0         $line =~ s/\s+#.*$//g;
2018  ***      0                                  0         $line =~ s/^\s+|\s+$//g;
2019  ***      0      0                           0         if ( $line eq '--' ) {
2020  ***      0                                  0            $prefix = '';
2021  ***      0                                  0            $parse  = 0;
2022  ***      0                                  0            next LINE;
2023                                                        }
2024  ***      0      0      0                    0         if ( $parse
      ***             0                               
2025                                                           && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
2026                                                        ) {
2027  ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
2028                                                        }
2029                                                        elsif ( $line =~ m/./ ) {
2030  ***      0                                  0            push @args, $line;
2031                                                        }
2032                                                        else {
2033  ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
2034                                                        }
2035                                                     }
2036  ***      0                                  0      close $fh;
2037  ***      0                                  0      return @args;
2038                                                  }
2039                                                  
2040                                                  sub read_para_after {
2041  ***      0                    0             0      my ( $self, $file, $regex ) = @_;
2042  ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
2043  ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
2044  ***      0                                  0      my $para;
2045  ***      0                                  0      while ( $para = <$fh> ) {
2046  ***      0      0                           0         next unless $para =~ m/^=pod$/m;
2047  ***      0                                  0         last;
2048                                                     }
2049  ***      0                                  0      while ( $para = <$fh> ) {
2050  ***      0      0                           0         next unless $para =~ m/$regex/;
2051  ***      0                                  0         last;
2052                                                     }
2053  ***      0                                  0      $para = <$fh>;
2054  ***      0                                  0      chomp($para);
2055  ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
2056  ***      0                                  0      return $para;
2057                                                  }
2058                                                  
2059                                                  sub clone {
2060  ***      0                    0             0      my ( $self ) = @_;
2061                                                  
2062  ***      0                                  0      my %clone = map {
2063  ***      0                                  0         my $hashref  = $self->{$_};
2064  ***      0                                  0         my $val_copy = {};
2065  ***      0                                  0         foreach my $key ( keys %$hashref ) {
2066  ***      0                                  0            my $ref = ref $hashref->{$key};
2067  ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
2068  ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
2069  ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
2070                                                                             : $hashref->{$key};
2071                                                        }
2072  ***      0                                  0         $_ => $val_copy;
2073                                                     } qw(opts short_opts defaults);
2074                                                  
2075  ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
2076  ***      0                                  0         $clone{$scalar} = $self->{$scalar};
2077                                                     }
2078                                                  
2079  ***      0                                  0      return bless \%clone;     
2080                                                  }
2081                                                  
2082                                                  sub _parse_size {
2083  ***      0                    0             0      my ( $self, $opt, $val ) = @_;
2084                                                  
2085  ***      0      0      0                    0      if ( lc($val || '') eq 'null' ) {
2086  ***      0                                  0         MKDEBUG && _d('NULL size for', $opt->{long});
2087  ***      0                                  0         $opt->{value} = 'null';
2088  ***      0                                  0         return;
2089                                                     }
2090                                                  
2091  ***      0                                  0      my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
2092  ***      0                                  0      my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
2093  ***      0      0                           0      if ( defined $num ) {
2094  ***      0      0                           0         if ( $factor ) {
2095  ***      0                                  0            $num *= $factor_for{$factor};
2096  ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{y},
2097                                                              'to num', $num, '* factor', $factor);
2098                                                        }
2099  ***      0             0                    0         $opt->{value} = ($pre || '') . $num;
2100                                                     }
2101                                                     else {
2102  ***      0                                  0         $self->save_error("Invalid size for --$opt->{long}");
2103                                                     }
2104  ***      0                                  0      return;
2105                                                  }
2106                                                  
2107                                                  sub _parse_attribs {
2108         208                  208          1534      my ( $self, $option, $attribs ) = @_;
2109         208                               1248      my $types = $self->{types};
2110         208    100                        6788      return $option
                    100                               
      ***            50                               
                    100                               
2111                                                        . ($attribs->{'short form'} ? '|' . $attribs->{'short form'}   : '' )
2112                                                        . ($attribs->{'negatable'}  ? '!'                              : '' )
2113                                                        . ($attribs->{'cumulative'} ? '+'                              : '' )
2114                                                        . ($attribs->{'type'}       ? '=' . $types->{$attribs->{type}} : '' );
2115                                                  }
2116                                                  
2117                                                  sub _d {
2118  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2119  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2120  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2121                                                          @_;
2122  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2123                                                  }
2124                                                  
2125                                                  1;
2126                                                  
2127                                                  # ###########################################################################
2128                                                  # End OptionParser package
2129                                                  # ###########################################################################
2130                                                  
2131                                                  # ###########################################################################
2132                                                  # KeySize package 5266
2133                                                  # ###########################################################################
2134                                                  package KeySize;
2135                                                  
2136           6                    6            77   use strict;
               6                                 15   
               6                                 51   
2137           6                    6            40   use warnings FATAL => 'all';
               6                                 14   
               6                                 50   
2138           6                    6            45   use English qw(-no_match_vars);
               6                                 17   
               6                                 37   
2139                                                  
2140  ***      6            50      6            39   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 15   
               6                                 93   
2141                                                  
2142                                                  sub new {
2143           7                    7            93      my ( $class, %args ) = @_;
2144           7                                 76      my $self = { %args };
2145           7                                143      return bless $self, $class;
2146                                                  }
2147                                                  
2148                                                  sub get_key_size {
2149           5                    5            77      my ( $self, %args ) = @_;
2150           5                                 56      foreach my $arg ( qw(name cols tbl_name tbl_struct dbh) ) {
2151  ***     25     50                         178         die "I need a $arg argument" unless $args{$arg};
2152                                                     }
2153           5                                 28      my $name = $args{name};
2154           5                                 20      my @cols = @{$args{cols}};
               5                                 41   
2155           5                                 26      my $dbh  = $args{dbh};
2156                                                  
2157           5                                 47      $self->{explain} = '';
2158           5                                 29      $self->{query}   = '';
2159           5                                 42      $self->{error}   = '';
2160                                                  
2161  ***      5     50                          36      if ( @cols == 0 ) {
2162  ***      0                                  0         $self->{error} = "No columns for key $name";
2163  ***      0                                  0         return;
2164                                                     }
2165                                                  
2166           5                                 64      my $key_exists = $self->_key_exists(%args);
2167           5                                 23      MKDEBUG && _d('Key', $name, 'exists in', $args{tbl_name}, ':',
2168                                                        $key_exists ? 'yes': 'no');
2169                                                  
2170           5    100                          72      my $sql = 'EXPLAIN SELECT ' . join(', ', @cols)
2171                                                             . ' FROM ' . $args{tbl_name}
2172                                                             . ($key_exists ? " FORCE INDEX (`$name`)" : '')
2173                                                             . ' WHERE ';
2174           5                                 18      my @where_cols;
2175           5                                 27      foreach my $col ( @cols ) {
2176           6                                 50         push @where_cols, "$col=1";
2177                                                     }
2178           5    100                          42      if ( scalar @cols == 1 ) {
2179           4                                 27         push @where_cols, "$cols[0]<>1";
2180                                                     }
2181           5                                 30      $sql .= join(' OR ', @where_cols);
2182           5                                 30      $self->{query} = $sql;
2183           5                                 16      MKDEBUG && _d('sql:', $sql);
2184                                                  
2185           5                                 18      my $explain;
2186           5                                 20      my $sth = $dbh->prepare($sql);
2187           5                                 46      eval { $sth->execute(); };
               5                               1858   
2188  ***      5     50                          42      if ( $EVAL_ERROR ) {
2189  ***      0                                  0         chomp $EVAL_ERROR;
2190  ***      0                                  0         $self->{error} = "Cannot get size of $name key: $EVAL_ERROR";
2191  ***      0                                  0         return;
2192                                                     }
2193           5                                105      $explain = $sth->fetchrow_hashref();
2194                                                  
2195           5                                214      $self->{explain} = $explain;
2196           5                                 27      my $key_len      = $explain->{key_len};
2197           5                                 26      my $rows         = $explain->{rows};
2198           5                                 24      my $chosen_key   = $explain->{key};  # May differ from $name
2199           5                                 17      MKDEBUG && _d('MySQL chose key:', $chosen_key, 'len:', $key_len,
2200                                                        'rows:', $rows);
2201                                                  
2202           5                                 23      my $key_size = 0;
2203  ***      5    100     66                   63      if ( $key_len && $rows ) {
2204  ***      2     50     33                   23         if ( $chosen_key =~ m/,/ && $key_len =~ m/,/ ) {
2205  ***      0                                  0            $self->{error} = "MySQL chose multiple keys: $chosen_key";
2206  ***      0                                  0            return;
2207                                                        }
2208           2                                 14         $key_size = $key_len * $rows;
2209                                                     }
2210                                                     else {
2211           3                                 20         $self->{error} = "key_len or rows NULL in EXPLAIN:\n"
2212                                                                       . _explain_to_text($explain);
2213           3                                133         return;
2214                                                     }
2215                                                  
2216  ***      2     50                          76      return wantarray ? ($key_size, $chosen_key) : $key_size;
2217                                                  }
2218                                                  
2219                                                  sub query {
2220  ***      0                    0             0      my ( $self ) = @_;
2221  ***      0                                  0      return $self->{query};
2222                                                  }
2223                                                  
2224                                                  sub explain {
2225  ***      0                    0             0      my ( $self ) = @_;
2226  ***      0                                  0      return _explain_to_text($self->{explain});
2227                                                  }
2228                                                  
2229                                                  sub error {
2230  ***      0                    0             0      my ( $self ) = @_;
2231  ***      0                                  0      return $self->{error};
2232                                                  }
2233                                                  
2234                                                  sub _key_exists {
2235           5                    5            59      my ( $self, %args ) = @_;
2236           5    100                          82      return exists $args{tbl_struct}->{keys}->{ lc $args{name} } ? 1 : 0;
2237                                                  }
2238                                                  
2239                                                  sub _explain_to_text {
2240           3                    3            20      my ( $explain ) = @_;
2241          30    100                         303      return join("\n",
2242           3                                 64         map { "$_: ".($explain->{$_} ? $explain->{$_} : 'NULL') }
2243                                                        sort keys %$explain
2244                                                     );
2245                                                  }
2246                                                  
2247                                                  sub _d {
2248  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2249  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2250  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2251                                                          @_;
2252  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2253                                                  }
2254                                                  
2255                                                  1;
2256                                                  
2257                                                  # ###########################################################################
2258                                                  # End KeySize package
2259                                                  # ###########################################################################
2260                                                  
2261                                                  # ###########################################################################
2262                                                  # DuplicateKeyFinder package 5798
2263                                                  # ###########################################################################
2264                                                  package DuplicateKeyFinder;
2265                                                  
2266           6                    6            42   use strict;
               6                                 15   
               6                                 41   
2267           6                    6            36   use warnings FATAL => 'all';
               6                                 15   
               6                                 29   
2268           6                    6            37   use English qw(-no_match_vars);
               6                                 14   
               6                                 29   
2269                                                  
2270           6                    6            50   use List::Util qw(min);
               6                                 19   
               6                                 32   
2271                                                  
2272  ***      6            50      6            39   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 15   
               6                                 75   
2273                                                  
2274                                                  sub new {
2275           8                    8            77      my ( $class, %args ) = @_;
2276           8                                 44      my $self = {};
2277           8                                139      return bless $self, $class;
2278                                                  }
2279                                                  
2280                                                  sub get_duplicate_keys {
2281           8                    8           229      my ( $self, $keys,  %args ) = @_;
2282  ***      8     50                          81      die "I need a keys argument" unless $keys;
2283           8                                 71      my %keys = %$keys;  # Copy keys because we remove non-duplicates.
2284           8                                 33      my $primary_key;
2285           8                                 30      my @unique_keys;
2286           8                                 26      my @normal_keys;
2287           8                                 32      my @fulltext_keys;
2288           8                                 30      my @dupes;
2289                                                  
2290                                                     KEY:
2291           8                                 77      foreach my $key ( values %keys ) {
2292          14                                 55         $key->{real_cols} = [ @{$key->{cols}} ];
              14                                140   
2293                                                  
2294          14                                128         $key->{len_cols}  = length $key->{colnames};
2295                                                  
2296  ***     14    100     66                  262         if ( $key->{name} eq 'PRIMARY'
      ***                   66                        
2297                                                             || ($args{clustered_key} && $key->{name} eq $args{clustered_key}) ) {
2298           4                                 21            $primary_key = $key;
2299           4                                 29            MKDEBUG && _d('primary key:', $key->{name});
2300           4                                 25            next KEY;
2301                                                        }
2302                                                  
2303  ***     10     50                          78         my $is_fulltext = $key->{type} eq 'FULLTEXT' ? 1 : 0;
2304  ***     10     50     33                  220         if ( $args{ignore_order} || $is_fulltext  ) {
2305  ***      0                                  0            my $ordered_cols = join(',', sort(split(/,/, $key->{colnames})));
2306  ***      0                                  0            MKDEBUG && _d('Reordered', $key->{name}, 'cols from',
2307                                                              $key->{colnames}, 'to', $ordered_cols); 
2308  ***      0                                  0            $key->{colnames} = $ordered_cols;
2309                                                        }
2310                                                  
2311          10    100                          97         my $push_to = $key->{is_unique} ? \@unique_keys : \@normal_keys;
2312  ***     10     50                          80         if ( !$args{ignore_structure} ) {
2313  ***     10     50                          70            $push_to = \@fulltext_keys if $is_fulltext;
2314                                                        }
2315          10                                 69         push @$push_to, $key; 
2316                                                     }
2317                                                  
2318           8                                142      push @normal_keys, $self->unconstrain_keys($primary_key, \@unique_keys);
2319                                                  
2320           8    100                          50      if ( $primary_key ) {
2321           4                                 15         MKDEBUG && _d('Comparing PRIMARY KEY to UNIQUE keys');
2322           4                                 82         push @dupes,
2323                                                           $self->remove_prefix_duplicates([$primary_key], \@unique_keys, %args);
2324                                                  
2325           4                                 20         MKDEBUG && _d('Comparing PRIMARY KEY to normal keys');
2326           4                                 45         push @dupes,
2327                                                           $self->remove_prefix_duplicates([$primary_key], \@normal_keys, %args);
2328                                                     }
2329                                                  
2330           8                                 39      MKDEBUG && _d('Comparing UNIQUE keys to normal keys');
2331           8                                137      push @dupes,
2332                                                        $self->remove_prefix_duplicates(\@unique_keys, \@normal_keys, %args);
2333                                                  
2334           8                                 40      MKDEBUG && _d('Comparing normal keys');
2335           8                                 93      push @dupes,
2336                                                        $self->remove_prefix_duplicates(\@normal_keys, \@normal_keys, %args);
2337                                                  
2338           8                                 42      MKDEBUG && _d('Comparing FULLTEXT keys');
2339           8                                105      push @dupes,
2340                                                        $self->remove_prefix_duplicates(\@fulltext_keys, \@fulltext_keys, %args, exact_duplicates => 1);
2341                                                  
2342                                                  
2343           8    100                          77      my $clustered_key = $args{clustered_key} ? $keys{$args{clustered_key}}
2344                                                                       : undef;
2345           8                                 27      MKDEBUG && _d('clustered key:', $clustered_key->{name},
2346                                                        $clustered_key->{colnames});
2347  ***      8    100     66                  234      if ( $clustered_key
      ***                   66                        
      ***                   66                        
2348                                                          && $args{clustered}
2349                                                          && $args{tbl_info}->{engine}
2350                                                          && $args{tbl_info}->{engine} =~ m/InnoDB/i )
2351                                                     {
2352           3                                 10         MKDEBUG && _d('Removing UNIQUE dupes of clustered key');
2353           3                                 50         push @dupes,
2354                                                           $self->remove_clustered_duplicates($clustered_key, \@unique_keys, %args);
2355                                                  
2356           3                                 12         MKDEBUG && _d('Removing ordinary dupes of clustered key');
2357           3                                 30         push @dupes,
2358                                                           $self->remove_clustered_duplicates($clustered_key, \@normal_keys, %args);
2359                                                     }
2360                                                  
2361           8                                 88      return \@dupes;
2362                                                  }
2363                                                  
2364                                                  sub get_duplicate_fks {
2365           8                    8           157      my ( $self, $fks, %args ) = @_;
2366  ***      8     50                          74      die "I need a fks argument" unless $fks;
2367           8                                 55      my @fks = values %$fks;
2368           8                                 29      my @dupes;
2369                                                  
2370           8                                123      foreach my $i ( 0..$#fks - 1 ) {
2371  ***      1     50                           9         next unless $fks[$i];
2372           1                                 10         foreach my $j ( $i+1..$#fks ) {
2373  ***      1     50                           8            next unless $fks[$j];
2374                                                  
2375           1                                  5            my $i_cols  = join(',', sort @{$fks[$i]->{cols}} );
               1                                 25   
2376           1                                  6            my $j_cols  = join(',', sort @{$fks[$j]->{cols}} );
               1                                  9   
2377           1                                  5            my $i_pcols = join(',', sort @{$fks[$i]->{parent_cols}} );
               1                                  9   
2378           1                                  5            my $j_pcols = join(',', sort @{$fks[$j]->{parent_cols}} );
               1                                  9   
2379                                                  
2380  ***      1     50     33                   43            if ( $fks[$i]->{parent_tbl} eq $fks[$j]->{parent_tbl}
      ***                   33                        
2381                                                                && $i_cols  eq $j_cols
2382                                                                && $i_pcols eq $j_pcols ) {
2383           1                                 13               my $dupe = {
2384                                                                 key               => $fks[$j]->{name},
2385           1                                 51                  cols              => [ @{$fks[$j]->{cols}} ],
2386                                                                 ddl               => $fks[$j]->{ddl},
2387                                                                 duplicate_of      => $fks[$i]->{name},
2388           1                                  8                  duplicate_of_cols => [ @{$fks[$i]->{cols}} ],
2389                                                                 duplicate_of_ddl  => $fks[$i]->{ddl},
2390                                                                 reason            =>
2391                                                                      "FOREIGN KEY $fks[$j]->{name} ($fks[$j]->{colnames}) "
2392                                                                    . "REFERENCES $fks[$j]->{parent_tbl} "
2393                                                                    . "($fks[$j]->{parent_colnames}) "
2394                                                                    . 'is a duplicate of '
2395                                                                    . "FOREIGN KEY $fks[$i]->{name} ($fks[$i]->{colnames}) "
2396                                                                    . "REFERENCES $fks[$i]->{parent_tbl} "
2397                                                                    ."($fks[$i]->{parent_colnames})",
2398                                                                 dupe_type         => 'fk',
2399                                                              };
2400           1                                  6               push @dupes, $dupe;
2401           1                                  5               delete $fks[$j];
2402  ***      1     50                          25               $args{callback}->($dupe, %args) if $args{callback};
2403                                                           }
2404                                                        }
2405                                                     }
2406           8                                 91      return \@dupes;
2407                                                  }
2408                                                  
2409                                                  sub remove_prefix_duplicates {
2410          32                   32           521      my ( $self, $left_keys, $right_keys, %args ) = @_;
2411          32                                202      my @dupes;
2412          32                                106      my $right_offset;
2413          32                                107      my $last_left_key;
2414          32                                173      my $last_right_key = scalar(@$right_keys) - 1;
2415                                                  
2416                                                  
2417          32    100                         193      if ( $right_keys != $left_keys ) {
2418                                                  
2419  ***      0                                  0         @$left_keys = sort { $a->{colnames} cmp $b->{colnames} }
               9                                 89   
2420          16                                116                       grep { defined $_; }
2421                                                                      @$left_keys;
2422           3                                 29         @$right_keys = sort { $a->{colnames} cmp $b->{colnames} }
              10                                 56   
2423          16                                104                        grep { defined $_; }
2424                                                                      @$right_keys;
2425                                                  
2426          16                                 88         $last_left_key = scalar(@$left_keys) - 1;
2427                                                  
2428          16                                 79         $right_offset = 0;
2429                                                     }
2430                                                     else {
2431                                                  
2432           3                                 21         @$left_keys = reverse sort { $a->{colnames} cmp $b->{colnames} }
               8                                 40   
2433          16                                125                       grep { defined $_; }
2434                                                                      @$left_keys;
2435                                                        
2436          16                                 90         $last_left_key = scalar(@$left_keys) - 2;
2437                                                  
2438          16                                 73         $right_offset = 1;
2439                                                     }
2440                                                  
2441                                                     LEFT_KEY:
2442          32                                227      foreach my $left_index ( 0..$last_left_key ) {
2443  ***     12     50                          97         next LEFT_KEY unless defined $left_keys->[$left_index];
2444                                                  
2445                                                        RIGHT_KEY:
2446          12                                 91         foreach my $right_index ( $left_index+$right_offset..$last_right_key ) {
2447  ***      6     50                          42            next RIGHT_KEY unless defined $right_keys->[$right_index];
2448                                                  
2449           6                                 38            my $left_name      = $left_keys->[$left_index]->{name};
2450           6                                 42            my $left_cols      = $left_keys->[$left_index]->{colnames};
2451           6                                 35            my $left_len_cols  = $left_keys->[$left_index]->{len_cols};
2452           6                                 33            my $right_name     = $right_keys->[$right_index]->{name};
2453           6                                 36            my $right_cols     = $right_keys->[$right_index]->{colnames};
2454           6                                 52            my $right_len_cols = $right_keys->[$right_index]->{len_cols};
2455                                                  
2456           6                                 22            MKDEBUG && _d('Comparing left', $left_name, '(',$left_cols,')',
2457                                                              'to right', $right_name, '(',$right_cols,')');
2458                                                  
2459           6    100                          65            if (    substr($left_cols,  0, $right_len_cols)
2460                                                                eq substr($right_cols, 0, $right_len_cols) ) {
2461                                                  
2462  ***      4     50     33                   39               if ( $args{exact_duplicates} && ($right_len_cols<$left_len_cols) ) {
2463  ***      0                                  0                  MKDEBUG && _d($right_name, 'not exact duplicate of', $left_name);
2464  ***      0                                  0                  next RIGHT_KEY;
2465                                                              }
2466                                                  
2467  ***      4     50                          33               if ( exists $right_keys->[$right_index]->{unique_col} ) {
2468  ***      0                                  0                  MKDEBUG && _d('Cannot remove', $right_name,
2469                                                                    'because is constrains col',
2470                                                                    $right_keys->[$right_index]->{cols}->[0]);
2471  ***      0                                  0                  next RIGHT_KEY;
2472                                                              }
2473                                                  
2474           4                                 14               MKDEBUG && _d('Remove', $right_name);
2475           4                                335               my $reason;
2476  ***      4     50                          36               if ( $right_keys->[$right_index]->{unconstrained} ) {
2477  ***      0                                  0                  $reason .= "Uniqueness of $right_name ignored because "
2478                                                                    . $right_keys->[$right_index]->{constraining_key}->{name}
2479                                                                    . " is a stronger constraint\n"; 
2480                                                              }
2481           4    100                          38               my $exact_dupe = $right_len_cols < $left_len_cols ? 0 : 1;
2482           4    100                          36               $reason .= $right_name
2483                                                                       . ($exact_dupe ? ' is a duplicate of '
2484                                                                                      : ' is a left-prefix of ')
2485                                                                       . $left_name;
2486           4    100                         112               my $dupe = {
2487                                                                 key               => $right_name,
2488                                                                 cols              => $right_keys->[$right_index]->{real_cols},
2489                                                                 ddl               => $right_keys->[$right_index]->{ddl},
2490                                                                 duplicate_of      => $left_name,
2491                                                                 duplicate_of_cols => $left_keys->[$left_index]->{real_cols},
2492                                                                 duplicate_of_ddl  => $left_keys->[$left_index]->{ddl},
2493                                                                 reason            => $reason,
2494                                                                 dupe_type         => $exact_dupe ? 'exact' : 'prefix',
2495                                                              };
2496           4                                 39               push @dupes, $dupe;
2497           4                                 24               delete $right_keys->[$right_index];
2498                                                  
2499  ***      4     50                         103               $args{callback}->($dupe, %args) if $args{callback};
2500                                                           }
2501                                                           else {
2502           2                                  6               MKDEBUG && _d($right_name, 'not left-prefix of', $left_name);
2503           2                                 12               next LEFT_KEY;
2504                                                           }
2505                                                        } # RIGHT_KEY
2506                                                     } # LEFT_KEY
2507          32                                109      MKDEBUG && _d('No more keys');
2508                                                  
2509          32                                173      @$left_keys  = grep { defined $_; } @$left_keys;
              14                                 91   
2510          32                                166      @$right_keys = grep { defined $_; } @$right_keys;
              14                                 83   
2511                                                  
2512          32                                287      return @dupes;
2513                                                  }
2514                                                  
2515                                                  sub remove_clustered_duplicates {
2516           6                    6            84      my ( $self, $ck, $keys, %args ) = @_;
2517  ***      6     50                          50      die "I need a ck argument"   unless $ck;
2518  ***      6     50                          32      die "I need a keys argument" unless $keys;
2519           6                                 27      my $ck_cols = $ck->{colnames};
2520                                                  
2521           6                                 21      my @dupes;
2522                                                     KEY:
2523           6                                 39      for my $i ( 0 .. @$keys - 1 ) {
2524           1                                  5         my $key = $keys->[$i]->{colnames};
2525  ***      1     50                          21         if ( $key =~ m/$ck_cols$/ ) {
2526           1                                  6            MKDEBUG && _d("clustered key dupe:", $keys->[$i]->{name},
2527                                                              $keys->[$i]->{colnames});
2528           2                                 10            my $dupe = {
2529                                                              key               => $keys->[$i]->{name},
2530                                                              cols              => $keys->[$i]->{real_cols},
2531                                                              ddl               => $keys->[$i]->{ddl},
2532                                                              duplicate_of      => $ck->{name},
2533                                                              duplicate_of_cols => $ck->{real_cols},
2534                                                              duplicate_of_ddl  => $ck->{ddl},
2535                                                              reason            => "Key $keys->[$i]->{name} ends with a "
2536                                                                                 . "prefix of the clustered index",
2537                                                              dupe_type         => 'clustered',
2538                                                              short_key         => $self->shorten_clustered_duplicate(
2539                                                                                      $ck_cols,
2540           1                                  6                                       join(',', map { "`$_`" }
2541           1                                 13                                          @{$keys->[$i]->{real_cols}})
2542                                                                                   ),
2543                                                           };
2544           1                                  4            push @dupes, $dupe;
2545           1                                  4            delete $keys->[$i];
2546  ***      1     50                          18            $args{callback}->($dupe, %args) if $args{callback};
2547                                                        }
2548                                                     }
2549           6                                 20      MKDEBUG && _d('No more keys');
2550                                                  
2551           6                                 32      @$keys = grep { defined $_; } @$keys;
      ***      0                                  0   
2552                                                  
2553           6                                 43      return @dupes;
2554                                                  }
2555                                                  
2556                                                  sub shorten_clustered_duplicate {
2557           1                    1             5      my ( $self, $ck_cols, $dupe_key_cols ) = @_;
2558  ***      1     50                           6      return $ck_cols if $ck_cols eq $dupe_key_cols;
2559           1                                 11      $dupe_key_cols =~ s/$ck_cols$//;
2560           1                                  5      $dupe_key_cols =~ s/,+$//;
2561           1                                  9      return $dupe_key_cols;
2562                                                  }
2563                                                  
2564                                                  sub unconstrain_keys {
2565           8                    8            58      my ( $self, $primary_key, $unique_keys ) = @_;
2566  ***      8     50                          54      die "I need a unique_keys argument" unless $unique_keys;
2567           8                                 58      my %unique_cols;
2568           8                                 30      my @unique_sets;
2569           8                                 31      my %unconstrain;
2570           8                                 28      my @unconstrained_keys;
2571                                                  
2572           8                                 25      MKDEBUG && _d('Unconstraining redundantly unique keys');
2573                                                  
2574                                                     UNIQUE_KEY:
2575           8                                 53      foreach my $unique_key ( $primary_key, @$unique_keys ) {
2576          10    100                          73         next unless $unique_key; # primary key may be undefined
2577           6                                 32         my $cols = $unique_key->{cols};
2578           6    100                          42         if ( @$cols == 1 ) {
2579           5                                 18            MKDEBUG && _d($unique_key->{name},'defines unique column:',$cols->[0]);
2580  ***      5     50                          43            if ( !exists $unique_cols{$cols->[0]} ) {
2581           5                                 29               $unique_cols{$cols->[0]}  = $unique_key;
2582           5                                 43               $unique_key->{unique_col} = 1;
2583                                                           }
2584                                                        }
2585                                                        else {
2586           1                                 16            local $LIST_SEPARATOR = '-';
2587           1                                  4            MKDEBUG && _d($unique_key->{name}, 'defines unique set:', @$cols);
2588           1                                 16            push @unique_sets, { cols => $cols, key => $unique_key };
2589                                                        }
2590                                                     }
2591                                                  
2592                                                     UNIQUE_SET:
2593           8                                 53      foreach my $unique_set ( @unique_sets ) {
2594           1                                  4         my $n_unique_cols = 0;
2595           1                                  8         COL:
2596           1                                  6         foreach my $col ( @{$unique_set->{cols}} ) {
2597           2    100                          18            if ( exists $unique_cols{$col} ) {
2598           1                                  4               MKDEBUG && _d('Unique set', $unique_set->{key}->{name},
2599                                                                 'has unique col', $col);
2600  ***      1     50                           8               last COL if ++$n_unique_cols > 1;
2601           1                                  9               $unique_set->{constraining_key} = $unique_cols{$col};
2602                                                           }
2603                                                        }
2604  ***      1     50     33                   28         if ( $n_unique_cols && $unique_set->{key}->{name} ne 'PRIMARY' ) {
2605           1                                  4            MKDEBUG && _d('Will unconstrain unique set',
2606                                                              $unique_set->{key}->{name},
2607                                                              'because it is redundantly constrained by key',
2608                                                              $unique_set->{constraining_key}->{name},
2609                                                              '(',$unique_set->{constraining_key}->{colnames},')');
2610           1                                 13            $unconstrain{$unique_set->{key}->{name}}
2611                                                              = $unique_set->{constraining_key};
2612                                                        }
2613                                                     }
2614                                                  
2615           8                                 79      for my $i ( 0..(scalar @$unique_keys-1) ) {
2616           2    100                          19         if ( exists $unconstrain{$unique_keys->[$i]->{name}} ) {
2617           1                                  4            MKDEBUG && _d('Unconstraining', $unique_keys->[$i]->{name});
2618           1                                  9            $unique_keys->[$i]->{unconstrained} = 1;
2619           1                                  9            $unique_keys->[$i]->{constraining_key}
2620                                                              = $unconstrain{$unique_keys->[$i]->{name}};
2621           1                                  7            push @unconstrained_keys, $unique_keys->[$i];
2622           1                                  9            delete $unique_keys->[$i];
2623                                                        }
2624                                                     }
2625                                                  
2626           8                                 26      MKDEBUG && _d('No more keys');
2627           8                                 59      return @unconstrained_keys;
2628                                                  }
2629                                                  
2630                                                  sub _d {
2631  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2632  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2633  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2634                                                          @_;
2635  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2636                                                  }
2637                                                  
2638                                                  1;
2639                                                  # ###########################################################################
2640                                                  # End DuplicateKeyFinder package
2641                                                  # ###########################################################################
2642                                                  
2643                                                  # ###########################################################################
2644                                                  # Transformers package 5715
2645                                                  # ###########################################################################
2646                                                  
2647                                                  package Transformers;
2648                                                  
2649           6                    6            51   use strict;
               6                                 16   
               6                                 33   
2650           6                    6            35   use warnings FATAL => 'all';
               6                                 18   
               6                                 39   
2651           6                    6            35   use English qw(-no_match_vars);
               6                                 14   
               6                                 47   
2652           6                    6            79   use Time::Local qw(timegm timelocal);
               6                                 17   
               6                                 86   
2653           6                    6            44   use Digest::MD5 qw(md5_hex);
               6                                 13   
               6                                 45   
2654                                                  
2655  ***      6            50      6            36   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 16   
               6                                 76   
2656                                                  
2657                                                  require Exporter;
2658                                                  our @ISA         = qw(Exporter);
2659                                                  our %EXPORT_TAGS = ();
2660                                                  our @EXPORT      = ();
2661                                                  our @EXPORT_OK   = qw(
2662                                                     micro_t
2663                                                     percentage_of
2664                                                     secs_to_time
2665                                                     time_to_secs
2666                                                     shorten
2667                                                     ts
2668                                                     parse_timestamp
2669                                                     unix_timestamp
2670                                                     any_unix_timestamp
2671                                                     make_checksum
2672                                                  );
2673                                                  
2674                                                  our $mysql_ts  = qr/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?/;
2675                                                  our $proper_ts = qr/(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(\.\d+)?/;
2676                                                  our $n_ts      = qr/(\d{1,5})([shmd]?)/; # Limit \d{1,5} because \d{6} looks
2677                                                  
2678                                                  sub micro_t {
2679  ***      0                    0             0      my ( $t, %args ) = @_;
2680  ***      0      0                           0      my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
2681  ***      0      0                           0      my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
2682  ***      0                                  0      my $f;
2683                                                  
2684  ***      0      0                           0      $t = 0 if $t < 0;
2685                                                  
2686  ***      0      0                           0      $t = sprintf('%.17f', $t) if $t =~ /e/;
2687                                                  
2688  ***      0                                  0      $t =~ s/\.(\d{1,6})\d*/\.$1/;
2689                                                  
2690  ***      0      0      0                    0      if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
2691  ***      0                                  0         $f = ($t * 1000000) . 'us';
2692                                                     }
2693                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
2694  ***      0                                  0         $f = sprintf("%.${p_ms}f", $t * 1000);
2695  ***      0                                  0         $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
2696                                                     }
2697                                                     elsif ($t >= 1) {
2698  ***      0                                  0         $f = sprintf("%.${p_s}f", $t);
2699  ***      0                                  0         $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
2700                                                     }
2701                                                     else {
2702  ***      0                                  0         $f = 0;  # $t should = 0 at this point
2703                                                     }
2704                                                  
2705  ***      0                                  0      return $f;
2706                                                  }
2707                                                  
2708                                                  sub percentage_of {
2709  ***      0                    0             0      my ( $is, $of, %args ) = @_;
2710  ***      0             0                    0      my $p   = $args{p} || 0; # float precision
2711  ***      0      0                           0      my $fmt = $p ? "%.${p}f" : "%d";
2712  ***      0             0                    0      return sprintf $fmt, ($is * 100) / ($of ||= 1);
2713                                                  }
2714                                                  
2715                                                  sub secs_to_time {
2716  ***      0                    0             0      my ( $secs, $fmt ) = @_;
2717  ***      0             0                    0      $secs ||= 0;
2718  ***      0      0                           0      return '00:00' unless $secs;
2719                                                  
2720  ***      0      0      0                    0      $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
2721                                                            : $secs >= 3_600  ? 'h'
2722                                                            :                   'm';
2723                                                  
2724                                                     return
2725  ***      0      0                           0         $fmt eq 'd' ? sprintf(
      ***             0                               
2726                                                           "%d+%02d:%02d:%02d",
2727                                                           int($secs / 86_400),
2728                                                           int(($secs % 86_400) / 3_600),
2729                                                           int(($secs % 3_600) / 60),
2730                                                           $secs % 60)
2731                                                        : $fmt eq 'h' ? sprintf(
2732                                                           "%02d:%02d:%02d",
2733                                                           int(($secs % 86_400) / 3_600),
2734                                                           int(($secs % 3_600) / 60),
2735                                                           $secs % 60)
2736                                                        : sprintf(
2737                                                           "%02d:%02d",
2738                                                           int(($secs % 3_600) / 60),
2739                                                           $secs % 60);
2740                                                  }
2741                                                  
2742                                                  sub time_to_secs {
2743  ***      0                    0             0      my ( $val, $default_suffix ) = @_;
2744  ***      0      0                           0      die "I need a val argument" unless defined $val;
2745  ***      0                                  0      my $t = 0;
2746  ***      0                                  0      my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
2747  ***      0             0                    0      $suffix = $suffix || $default_suffix || 's';
      ***                    0                        
2748  ***      0      0                           0      if ( $suffix =~ m/[smhd]/ ) {
2749  ***      0      0                           0         $t = $suffix eq 's' ? $num * 1        # Seconds
      ***             0                               
      ***             0                               
2750                                                           : $suffix eq 'm' ? $num * 60       # Minutes
2751                                                           : $suffix eq 'h' ? $num * 3600     # Hours
2752                                                           :                  $num * 86400;   # Days
2753                                                  
2754  ***      0      0      0                    0         $t *= -1 if $prefix && $prefix eq '-';
2755                                                     }
2756                                                     else {
2757  ***      0                                  0         die "Invalid suffix for $val: $suffix";
2758                                                     }
2759  ***      0                                  0      return $t;
2760                                                  }
2761                                                  
2762                                                  sub shorten {
2763  ***      0                    0             0      my ( $num, %args ) = @_;
2764  ***      0      0                           0      my $p = defined $args{p} ? $args{p} : 2;     # float precision
2765  ***      0      0                           0      my $d = defined $args{d} ? $args{d} : 1_024; # divisor
2766  ***      0                                  0      my $n = 0;
2767  ***      0                                  0      my @units = ('', qw(k M G T P E Z Y));
2768  ***      0             0                    0      while ( $num >= $d && $n < @units - 1 ) {
2769  ***      0                                  0         $num /= $d;
2770  ***      0                                  0         ++$n;
2771                                                     }
2772  ***      0      0      0                    0      return sprintf(
2773                                                        $num =~ m/\./ || $n
2774                                                           ? "%.${p}f%s"
2775                                                           : '%d',
2776                                                        $num, $units[$n]);
2777                                                  }
2778                                                  
2779                                                  sub ts {
2780  ***      0                    0             0      my ( $time, $gmt ) = @_;
2781  ***      0      0                           0      my ( $sec, $min, $hour, $mday, $mon, $year )
2782                                                        = $gmt ? gmtime($time) : localtime($time);
2783  ***      0                                  0      $mon  += 1;
2784  ***      0                                  0      $year += 1900;
2785  ***      0                                  0      my $val = sprintf("%d-%02d-%02dT%02d:%02d:%02d",
2786                                                        $year, $mon, $mday, $hour, $min, $sec);
2787  ***      0      0                           0      if ( my ($us) = $time =~ m/(\.\d+)$/ ) {
2788  ***      0                                  0         $us = sprintf("%.6f", $us);
2789  ***      0                                  0         $us =~ s/^0\././;
2790  ***      0                                  0         $val .= $us;
2791                                                     }
2792  ***      0                                  0      return $val;
2793                                                  }
2794                                                  
2795                                                  sub parse_timestamp {
2796  ***      0                    0             0      my ( $val ) = @_;
2797  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $f)
2798                                                           = $val =~ m/^$mysql_ts$/ )
2799                                                     {
2800  ***      0      0                           0         return sprintf "%d-%02d-%02d %02d:%02d:"
      ***             0                               
2801                                                                       . (defined $f ? '%02.6f' : '%02d'),
2802                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
2803                                                     }
2804  ***      0                                  0      return $val;
2805                                                  }
2806                                                  
2807                                                  sub unix_timestamp {
2808  ***      0                    0             0      my ( $val, $gmt ) = @_;
2809  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $us) = $val =~ m/^$proper_ts$/ ) {
2810  ***      0      0                           0         $val = $gmt
2811                                                           ? timegm($s, $i, $h, $d, $m - 1, $y)
2812                                                           : timelocal($s, $i, $h, $d, $m - 1, $y);
2813  ***      0      0                           0         if ( defined $us ) {
2814  ***      0                                  0            $us = sprintf('%.6f', $us);
2815  ***      0                                  0            $us =~ s/^0\././;
2816  ***      0                                  0            $val .= $us;
2817                                                        }
2818                                                     }
2819  ***      0                                  0      return $val;
2820                                                  }
2821                                                  
2822                                                  sub any_unix_timestamp {
2823  ***      0                    0             0      my ( $val, $callback ) = @_;
2824                                                  
2825  ***      0      0                           0      if ( my ($n, $suffix) = $val =~ m/^$n_ts$/ ) {
      ***             0                               
      ***             0                               
      ***             0                               
2826  ***      0      0                           0         $n = $suffix eq 's' ? $n            # Seconds
      ***             0                               
      ***             0                               
      ***             0                               
2827                                                           : $suffix eq 'm' ? $n * 60       # Minutes
2828                                                           : $suffix eq 'h' ? $n * 3600     # Hours
2829                                                           : $suffix eq 'd' ? $n * 86400    # Days
2830                                                           :                  $n;           # default: Seconds
2831  ***      0                                  0         MKDEBUG && _d('ts is now - N[shmd]:', $n);
2832  ***      0                                  0         return time - $n;
2833                                                     }
2834                                                     elsif ( $val =~ m/^\d{9,}/ ) {
2835  ***      0                                  0         MKDEBUG && _d('ts is already a unix timestamp');
2836  ***      0                                  0         return $val;
2837                                                     }
2838                                                     elsif ( my ($ymd, $hms) = $val =~ m/^(\d{6})(?:\s+(\d+:\d+:\d+))?/ ) {
2839  ***      0                                  0         MKDEBUG && _d('ts is MySQL slow log timestamp');
2840  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
2841  ***      0                                  0         return unix_timestamp(parse_timestamp($val));
2842                                                     }
2843                                                     elsif ( ($ymd, $hms) = $val =~ m/^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) {
2844  ***      0                                  0         MKDEBUG && _d('ts is properly formatted timestamp');
2845  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
2846  ***      0                                  0         return unix_timestamp($val);
2847                                                     }
2848                                                     else {
2849  ***      0                                  0         MKDEBUG && _d('ts is MySQL expression');
2850  ***      0      0      0                    0         return $callback->($val) if $callback && ref $callback eq 'CODE';
2851                                                     }
2852                                                  
2853  ***      0                                  0      MKDEBUG && _d('Unknown ts type:', $val);
2854  ***      0                                  0      return;
2855                                                  }
2856                                                  
2857                                                  sub make_checksum {
2858  ***      0                    0             0      my ( $val ) = @_;
2859  ***      0                                  0      my $checksum = uc substr(md5_hex($val), -16);
2860  ***      0                                  0      MKDEBUG && _d($checksum, 'checksum for', $val);
2861  ***      0                                  0      return $checksum;
2862                                                  }
2863                                                  
2864                                                  sub _d {
2865  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2866  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2867  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2868                                                          @_;
2869  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2870                                                  }
2871                                                  
2872                                                  1;
2873                                                  
2874                                                  # ###########################################################################
2875                                                  # End Transformers package
2876                                                  # ###########################################################################
2877                                                  
2878                                                  # ###########################################################################
2879                                                  # Daemon package 5266
2880                                                  # ###########################################################################
2881                                                  
2882                                                  package Daemon;
2883                                                  
2884           6                    6            42   use strict;
               6                                 15   
               6                                 33   
2885           6                    6            37   use warnings FATAL => 'all';
               6                                 13   
               6                                 44   
2886                                                  
2887           6                    6            35   use POSIX qw(setsid);
               6                                 16   
               6                                 60   
2888           6                    6            38   use English qw(-no_match_vars);
               6                                 21   
               6                                 38   
2889                                                  
2890  ***      6            50      6            46   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 19   
               6                                 82   
2891                                                  
2892                                                  sub new {
2893  ***      0                    0             0      my ( $class, %args ) = @_;
2894  ***      0                                  0      foreach my $arg ( qw(o) ) {
2895  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
2896                                                     }
2897  ***      0                                  0      my $o = $args{o};
2898  ***      0      0                           0      my $self = {
      ***             0                               
2899                                                        o        => $o,
2900                                                        log_file => $o->has('log') ? $o->get('log') : undef,
2901                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
2902                                                     };
2903                                                  
2904  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
2905                                                  
2906  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
2907  ***      0                                  0      return bless $self, $class;
2908                                                  }
2909                                                  
2910                                                  sub daemonize {
2911  ***      0                    0             0      my ( $self ) = @_;
2912                                                  
2913  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
2914  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
2915  ***      0      0                           0      if ( $pid ) {
2916  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
2917  ***      0                                  0         exit;
2918                                                     }
2919                                                  
2920  ***      0                                  0      $self->{child} = 1;
2921                                                  
2922  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
2923  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
2924                                                  
2925  ***      0                                  0      $self->_make_PID_file();
2926                                                  
2927  ***      0                                  0      $OUTPUT_AUTOFLUSH = 1;
2928                                                  
2929  ***      0      0                           0      if ( -t STDIN ) {
2930  ***      0                                  0         close STDIN;
2931  ***      0      0                           0         open  STDIN, '/dev/null'
2932                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
2933                                                     }
2934                                                  
2935  ***      0      0                           0      if ( $self->{log_file} ) {
2936  ***      0                                  0         close STDOUT;
2937  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
2938                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
2939                                                  
2940  ***      0                                  0         close STDERR;
2941  ***      0      0                           0         open  STDERR, ">&STDOUT"
2942                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
2943                                                     }
2944                                                     else {
2945  ***      0      0                           0         if ( -t STDOUT ) {
2946  ***      0                                  0            close STDOUT;
2947  ***      0      0                           0            open  STDOUT, '>', '/dev/null'
2948                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
2949                                                        }
2950  ***      0      0                           0         if ( -t STDERR ) {
2951  ***      0                                  0            close STDERR;
2952  ***      0      0                           0            open  STDERR, '>', '/dev/null'
2953                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
2954                                                        }
2955                                                     }
2956                                                  
2957  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
2958  ***      0                                  0      return;
2959                                                  }
2960                                                  
2961                                                  sub check_PID_file {
2962  ***      0                    0             0      my ( $self, $file ) = @_;
2963  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
2964  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
2965  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
2966  ***      0                                  0         my $pid;
2967  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
2968  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
2969  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
2970  ***      0      0                           0         if ( $pid ) {
2971  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
2972  ***      0      0                           0            if ( $pid_is_alive ) {
2973  ***      0                                  0               die "The PID file $PID_file already exists "
2974                                                                 . " and the PID that it contains, $pid, is running";
2975                                                           }
2976                                                           else {
2977  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
2978                                                                 . "contains, $pid, is not running";
2979                                                           }
2980                                                        }
2981                                                        else {
2982  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
2983                                                              . "contain a PID";
2984                                                        }
2985                                                     }
2986                                                     else {
2987  ***      0                                  0         MKDEBUG && _d('No PID file');
2988                                                     }
2989  ***      0                                  0      return;
2990                                                  }
2991                                                  
2992                                                  sub make_PID_file {
2993  ***      0                    0             0      my ( $self ) = @_;
2994  ***      0      0                           0      if ( exists $self->{child} ) {
2995  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
2996                                                     }
2997  ***      0                                  0      $self->_make_PID_file();
2998  ***      0                                  0      $self->{rm_PID_file} = 1;
2999  ***      0                                  0      return;
3000                                                  }
3001                                                  
3002                                                  sub _make_PID_file {
3003  ***      0                    0             0      my ( $self ) = @_;
3004                                                  
3005  ***      0                                  0      my $PID_file = $self->{PID_file};
3006  ***      0      0                           0      if ( !$PID_file ) {
3007  ***      0                                  0         MKDEBUG && _d('No PID file to create');
3008  ***      0                                  0         return;
3009                                                     }
3010                                                  
3011  ***      0                                  0      $self->check_PID_file();
3012                                                  
3013  ***      0      0                           0      open my $PID_FH, '>', $PID_file
3014                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
3015  ***      0      0                           0      print $PID_FH $PID
3016                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
3017  ***      0      0                           0      close $PID_FH
3018                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
3019                                                  
3020  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
3021  ***      0                                  0      return;
3022                                                  }
3023                                                  
3024                                                  sub _remove_PID_file {
3025  ***      0                    0             0      my ( $self ) = @_;
3026  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
3027  ***      0      0                           0         unlink $self->{PID_file}
3028                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
3029  ***      0                                  0         MKDEBUG && _d('Removed PID file');
3030                                                     }
3031                                                     else {
3032  ***      0                                  0         MKDEBUG && _d('No PID to remove');
3033                                                     }
3034  ***      0                                  0      return;
3035                                                  }
3036                                                  
3037                                                  sub DESTROY {
3038  ***      0                    0             0      my ( $self ) = @_;
3039  ***      0      0      0                    0      $self->_remove_PID_file() if $self->{child} || $self->{rm_PID_file};
3040  ***      0                                  0      return;
3041                                                  }
3042                                                  
3043                                                  sub _d {
3044  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3045  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3046  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3047                                                          @_;
3048  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3049                                                  }
3050                                                  
3051                                                  1;
3052                                                  
3053                                                  # ###########################################################################
3054                                                  # End Daemon package
3055                                                  # ###########################################################################
3056                                                  
3057                                                  # ###########################################################################
3058                                                  # SchemaIterator package 5473
3059                                                  # ###########################################################################
3060                                                  package SchemaIterator;
3061                                                  
3062           6                    6            45   use strict;
               6                                 14   
               6                                 29   
3063           6                    6            36   use warnings FATAL => 'all';
               6                                 19   
               6                                 35   
3064                                                  
3065           6                    6            36   use English qw(-no_match_vars);
               6                                 14   
               6                                 47   
3066           6                    6            39   use Data::Dumper;
               6                                 15   
               6                                 37   
3067                                                  $Data::Dumper::Indent    = 1;
3068                                                  $Data::Dumper::Sortkeys  = 1;
3069                                                  $Data::Dumper::Quotekeys = 0;
3070                                                  
3071  ***      6            50      6            38   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 12   
               6                                 80   
3072                                                  
3073                                                  sub new {
3074           8                    8           101      my ( $class, %args ) = @_;
3075           8                                 84      foreach my $arg ( qw(Quoter) ) {
3076  ***      8     50                          87         die "I need a $arg argument" unless $args{$arg};
3077                                                     }
3078           8                                 94      my $self = {
3079                                                        %args,
3080                                                        filter => undef,
3081                                                        dbs    => [],
3082                                                     };
3083           8                                147      return bless $self, $class;
3084                                                  }
3085                                                  
3086                                                  sub make_filter {
3087           8                    8            50      my ( $self, $o ) = @_;
3088           8                                 76      my @lines = (
3089                                                        'sub {',
3090                                                        '   my ( $dbh, $db, $tbl ) = @_;',
3091                                                        '   my $engine = undef;',
3092                                                     );
3093                                                  
3094                                                  
3095  ***      8     50                          58      my @permit_dbs = _make_filter('unless', '$db', $o->get('databases'))
3096                                                        if $o->has('databases');
3097  ***      8     50                          64      my @reject_dbs = _make_filter('if', '$db', $o->get('ignore-databases'))
3098                                                        if $o->has('ignore-databases');
3099           8                                 37      my @dbs_regex;
3100  ***      8     50     33                   48      if ( $o->has('databases-regex') && (my $p = $o->get('databases-regex')) ) {
3101  ***      0                                  0         push @dbs_regex, "      return 0 unless \$db && (\$db =~ m/$p/o);";
3102                                                     }
3103           8                                 34      my @reject_dbs_regex;
3104  ***      8     50     33                   53      if ( $o->has('ignore-databases-regex')
3105                                                          && (my $p = $o->get('ignore-databases-regex')) ) {
3106  ***      0                                  0         push @reject_dbs_regex, "      return 0 if \$db && (\$db =~ m/$p/o);";
3107                                                     }
3108  ***      8     50     33                  108      if ( @permit_dbs || @reject_dbs || @dbs_regex || @reject_dbs_regex ) {
      ***                   33                        
      ***                   33                        
3109  ***      8     50                         118         push @lines,
      ***            50                               
      ***            50                               
      ***            50                               
3110                                                           '   if ( $db ) {',
3111                                                              (@permit_dbs        ? @permit_dbs       : ()),
3112                                                              (@reject_dbs        ? @reject_dbs       : ()),
3113                                                              (@dbs_regex         ? @dbs_regex        : ()),
3114                                                              (@reject_dbs_regex  ? @reject_dbs_regex : ()),
3115                                                           '   }';
3116                                                     }
3117                                                  
3118  ***      8     50     33                   73      if ( $o->has('tables') || $o->has('ignore-tables')
      ***                   33                        
3119                                                          || $o->has('ignore-tables-regex') ) {
3120                                                  
3121           8                                 37         my $have_qtbl       = 0;
3122           8                                 32         my $have_only_qtbls = 0;
3123           8                                 28         my %qtbls;
3124                                                  
3125           8                                 28         my @permit_tbls;
3126           8                                 29         my @permit_qtbls;
3127           8                                 33         my %permit_qtbls;
3128           8    100                          77         if ( $o->get('tables') ) {
3129           2                                 18            my %tbls;
3130                                                           map {
3131  ***      2     50                          37               if ( $_ =~ m/\./ ) {
               2                                 24   
3132  ***      0                                  0                  $permit_qtbls{$_} = 1;
3133                                                              }
3134                                                              else {
3135           2                                 17                  $tbls{$_} = 1;
3136                                                              }
3137           2                                 23            } keys %{ $o->get('tables') };
3138           2                                 22            @permit_tbls  = _make_filter('unless', '$tbl', \%tbls);
3139           2                                 16            @permit_qtbls = _make_filter('unless', '$qtbl', \%permit_qtbls);
3140                                                  
3141  ***      2     50                          28            if ( @permit_qtbls ) {
3142  ***      0                                  0               push @lines,
3143                                                                 '   my $qtbl   = ($db ? "$db." : "") . ($tbl ? $tbl : "");';
3144  ***      0                                  0               $have_qtbl = 1;
3145                                                           }
3146                                                        }
3147                                                  
3148           8                                 33         my @reject_tbls;
3149           8                                 27         my @reject_qtbls;
3150           8                                 31         my %reject_qtbls;
3151  ***      8     50                          53         if ( $o->get('ignore-tables') ) {
3152           8                                 32            my %tbls;
3153                                                           map {
3154  ***      0      0                           0               if ( $_ =~ m/\./ ) {
               8                                 51   
3155  ***      0                                  0                  $reject_qtbls{$_} = 1;
3156                                                              }
3157                                                              else {
3158  ***      0                                  0                  $tbls{$_} = 1;
3159                                                              }
3160           8                                 33            } keys %{ $o->get('ignore-tables') };
3161           8                                 72            @reject_tbls= _make_filter('if', '$tbl', \%tbls);
3162           8                                 60            @reject_qtbls = _make_filter('if', '$qtbl', \%reject_qtbls);
3163                                                  
3164  ***      8     50     33                   98            if ( @reject_qtbls && !$have_qtbl ) {
3165  ***      0                                  0               push @lines,
3166                                                                 '   my $qtbl   = ($db ? "$db." : "") . ($tbl ? $tbl : "");';
3167                                                           }
3168                                                        }
3169                                                  
3170  ***      8     50     33                   95         if ( keys %permit_qtbls  && !@permit_dbs ) {
3171  ***      0                                  0            my $dbs = {};
3172  ***      0                                  0            map {
3173  ***      0                                  0               my ($db, undef) = split(/\./, $_);
3174  ***      0                                  0               $dbs->{$db} = 1;
3175                                                           } keys %permit_qtbls;
3176  ***      0                                  0            MKDEBUG && _d('Adding restriction "--databases',
3177                                                                 (join(',', keys %$dbs) . '"'));
3178  ***      0      0                           0            if ( keys %$dbs ) {
3179  ***      0                                  0               $o->set('databases', $dbs);
3180  ***      0                                  0               return $self->make_filter($o);
3181                                                           }
3182                                                        }
3183                                                  
3184           8                                 31         my @tbls_regex;
3185  ***      8     50     33                   52         if ( $o->has('tables-regex') && (my $p = $o->get('tables-regex')) ) {
3186  ***      0                                  0            push @tbls_regex, "      return 0 unless \$tbl && (\$tbl =~ m/$p/o);";
3187                                                        }
3188           8                                 31         my @reject_tbls_regex;
3189  ***      8     50     33                   50         if ( $o->has('ignore-tables-regex')
3190                                                             && (my $p = $o->get('ignore-tables-regex')) ) {
3191  ***      0                                  0            push @reject_tbls_regex,
3192                                                              "      return 0 if \$tbl && (\$tbl =~ m/$p/o);";
3193                                                        }
3194                                                  
3195           8                                 30         my @get_eng;
3196           8                                 29         my @permit_engs;
3197           8                                 29         my @reject_engs;
3198  ***      8     50     33                   50         if ( ($o->has('engines') && $o->get('engines'))
      ***                   33                        
      ***                   33                        
3199                                                             || ($o->has('ignore-engines') && $o->get('ignore-engines')) ) {
3200           8                                 95            push @get_eng,
3201                                                              '      my $sql = "SHOW TABLE STATUS "',
3202                                                              '              . ($db ? "FROM `$db`" : "")',
3203                                                              '              . " LIKE \'$tbl\'";',
3204                                                              '      MKDEBUG && _d($sql);',
3205                                                              '      eval {',
3206                                                              '         $engine = $dbh->selectrow_hashref($sql)->{engine};',
3207                                                              '      };',
3208                                                              '      MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);',
3209                                                              '      MKDEBUG && _d($tbl, "uses engine", $engine);',
3210                                                              '      $engine = lc $engine if $engine;',
3211                                                           @permit_engs
3212                                                              = _make_filter('unless', '$engine', $o->get('engines'), 1);
3213                                                           @reject_engs
3214           8                                 74               = _make_filter('if', '$engine', $o->get('ignore-engines'), 1)
3215                                                        }
3216                                                  
3217  ***      8    100     66                  493         if ( @permit_tbls || @reject_tbls || @tbls_regex || @reject_tbls_regex
      ***                   66                        
      ***                   66                        
      ***                   66                        
      ***                   66                        
3218                                                             || @permit_engs || @reject_engs ) {
3219  ***      2     50                          86            push @lines,
      ***            50                               
      ***            50                               
      ***            50                               
      ***            50                               
      ***            50                               
      ***            50                               
      ***            50                               
      ***            50                               
3220                                                              '   if ( $tbl ) {',
3221                                                                 (@permit_tbls       ? @permit_tbls        : ()),
3222                                                                 (@reject_tbls       ? @reject_tbls        : ()),
3223                                                                 (@tbls_regex        ? @tbls_regex         : ()),
3224                                                                 (@reject_tbls_regex ? @reject_tbls_regex  : ()),
3225                                                                 (@permit_qtbls      ? @permit_qtbls       : ()),
3226                                                                 (@reject_qtbls      ? @reject_qtbls       : ()),
3227                                                                 (@get_eng           ? @get_eng            : ()),
3228                                                                 (@permit_engs       ? @permit_engs        : ()),
3229                                                                 (@reject_engs       ? @reject_engs        : ()),
3230                                                              '   }';
3231                                                        }
3232                                                     }
3233                                                  
3234           8                                 60      push @lines,
3235                                                        '   MKDEBUG && _d(\'Passes filters:\', $db, $tbl, $engine, $dbh);',
3236                                                        '   return 1;',  '}';
3237                                                  
3238           8                                 84      my $code = join("\n", @lines);
3239           8                                 24      MKDEBUG && _d('filter sub:', $code);
3240  ***      8     50                        2177      my $filter_sub= eval $code
3241                                                        or die "Error compiling subroutine code:\n$code\n$EVAL_ERROR";
3242                                                  
3243           8                                104      return $filter_sub;
3244                                                  }
3245                                                  
3246                                                  sub set_filter {
3247           8                    8            55      my ( $self, $filter_sub ) = @_;
3248           8                                 46      $self->{filter} = $filter_sub;
3249           8                                 26      MKDEBUG && _d('Set filter sub');
3250           8                                 31      return;
3251                                                  }
3252                                                  
3253                                                  sub get_db_itr {
3254           8                    8            75      my ( $self, %args ) = @_;
3255           8                                 54      my @required_args = qw(dbh);
3256           8                                 52      foreach my $arg ( @required_args ) {
3257  ***      8     50                          80         die "I need a $arg argument" unless $args{$arg};
3258                                                     }
3259           8                                 56      my ($dbh) = @args{@required_args};
3260                                                  
3261           8                                 42      my $filter = $self->{filter};
3262           8                                 30      my @dbs;
3263           8                                 37      eval {
3264           8                                 35         my $sql = 'SHOW DATABASES';
3265           8                                 26         MKDEBUG && _d($sql);
3266  ***     33     50                         333         @dbs =  grep {
3267           8                                 27            my $ok = $filter ? $filter->($dbh, $_, undef) : 1;
3268          33    100                         360            $ok = 0 if $_ =~ m/information_schema|lost\+found/;
3269          33                                170            $ok;
3270           8                                 39         } @{ $dbh->selectcol_arrayref($sql) };
3271           8                                 50         MKDEBUG && _d('Found', scalar @dbs, 'databases');
3272                                                     };
3273           8                                 29      MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
3274                                                     return sub {
3275          15                   15           135         return shift @dbs;
3276           8                                116      };
3277                                                  }
3278                                                  
3279                                                  sub get_tbl_itr {
3280           7                    7           101      my ( $self, %args ) = @_;
3281           7                                 52      my @required_args = qw(dbh db);
3282           7                                 63      foreach my $arg ( @required_args ) {
3283  ***     14     50                         118         die "I need a $arg argument" unless $args{$arg};
3284                                                     }
3285           7                                 64      my ($dbh, $db, $views) = @args{@required_args, 'views'};
3286                                                  
3287           7                                 39      my $filter = $self->{filter};
3288           7                                 27      my @tbls;
3289  ***      7     50                          40      if ( $db ) {
3290           7                                 32         eval {
3291           7                                 92            my $sql = 'SHOW /*!50002 FULL*/ TABLES FROM '
3292                                                                   . $self->{Quoter}->quote($db);
3293           7                                 28            MKDEBUG && _d($sql);
3294           8                                 73            @tbls = map {
3295          11                               2663               $_->[0]
3296                                                           }
3297                                                           grep {
3298           7                                 39               my ($tbl, $type) = @$_;
3299  ***     11     50                         123               my $ok = $filter ? $filter->($dbh, $db, $tbl) : 1;
3300  ***     11     50                          77               if ( !$views ) {
3301  ***     11     50     50                  109                  $ok = 0 if ($type || '') eq 'VIEW';
3302                                                              }
3303          11                                 62               $ok;
3304                                                           }
3305           7                                 33            @{ $dbh->selectall_arrayref($sql) };
3306           7                                184            MKDEBUG && _d('Found', scalar @tbls, 'tables in', $db);
3307                                                        };
3308           7                                 32         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
3309                                                     }
3310                                                     else {
3311  ***      0                                  0         MKDEBUG && _d('No db given so no tables');
3312                                                     }
3313                                                     return sub {
3314          15                   15           213         return shift @tbls;
3315           7                                131      };
3316                                                  }
3317                                                  
3318                                                  sub _make_filter {
3319          52                   52           445      my ( $cond, $var_name, $objs, $lc ) = @_;
3320          52                                238      my @lines;
3321          52    100                         377      if ( scalar keys %$objs ) {
3322  ***     10     50                         128         my $test = join(' || ',
3323          10                                 65            map { "$var_name eq '" . ($lc ? lc $_ : $_) ."'" } keys %$objs);
3324          10                                126         push @lines, "      return 0 $cond $var_name && ($test);",
3325                                                     }
3326          52                                395      return @lines;
3327                                                  }
3328                                                  
3329                                                  sub _d {
3330  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3331  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3332  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3333                                                          @_;
3334  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3335                                                  }
3336                                                  
3337                                                  1;
3338                                                  
3339                                                  # ###########################################################################
3340                                                  # End SchemaIterator package
3341                                                  # ###########################################################################
3342                                                  
3343                                                  # #############################################################################
3344                                                  # This is a combination of modules and programs in one -- a runnable module.
3345                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
3346                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
3347                                                  #
3348                                                  # Check at the end of this package for the call to main() which actually runs
3349                                                  # the program.
3350                                                  # #############################################################################
3351                                                  package mk_duplicate_key_checker;
3352                                                  
3353           6                    6            45   use English qw(-no_match_vars);
               6                                 16   
               6                                 48   
3354           6                    6            46   use Getopt::Long;
               6                                 19   
               6                                 39   
3355           6                    6            44   use List::Util qw(max);
               6                                 14   
               6                                 39   
3356                                                  
3357                                                  Transformers->import(qw(shorten));
3358                                                  
3359  ***      6            50      6            37   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               6                                 18   
               6                                 81   
3360                                                  
3361                                                  $OUTPUT_AUTOFLUSH = 1;
3362                                                  
3363                                                  my $max_width = 74;
3364                                                  my $hdr_width = $max_width - 2;  # for '# '
3365                                                  my $hdr_fmt   = "# %-${hdr_width}s\n";
3366                                                  
3367                                                  sub main {
3368           8                    8        911530      @ARGV = @_;  # set global ARGV for this package
3369                                                  
3370           8                                194      my %summary = ( 'Total Indexes' => 0 );
3371           8                                 56      my %seen_tbl;
3372                                                  
3373           8                                360      my $q  = new Quoter();
3374           8                                271      my $tp = new TableParser(Quoter => $q);
3375                                                  
3376                                                     # #######################################################################
3377                                                     # Get configuration information and parse command line options.
3378                                                     # #######################################################################
3379           8                                312      my $o  = new OptionParser(
3380                                                        strict      => 0,
3381                                                        prompt      => '[OPTION...] [DSN]',
3382                                                        description => q{examines MySQL tables for duplicate or redundant }
3383                                                                     . q{indexes and foreign keys.  Connection options }
3384                                                                     . q{are read from MySQL option files.},
3385                                                     );
3386           8                                118      $o->get_specs();
3387           8                                281      $o->get_opts();
3388                                                  
3389           8                                 68      my $dp = $o->DSNParser();
3390           8                                 63      $dp->prop('set-vars', $o->get('set-vars'));
3391                                                  
3392           8                                108      $o->usage_or_errors();
3393                                                  
3394                                                     # ########################################################################
3395                                                     # If --pid, check it first since we'll die if it already exits.
3396                                                     # ########################################################################
3397           8                                 30      my $daemon;
3398  ***      8     50                          50      if ( $o->get('pid') ) {
3399                                                        # We're not daemoninzing, it just handles PID stuff.  Keep $daemon
3400                                                        # in the the scope of main() because when it's destroyed it automatically
3401                                                        # removes the PID file.
3402  ***      0                                  0         $daemon = new Daemon(o=>$o);
3403  ***      0                                  0         $daemon->make_PID_file();
3404                                                     }
3405                                                  
3406                                                     # #######################################################################
3407                                                     # Get ready to do the main work.
3408                                                     # #######################################################################
3409  ***      8     50                          56      my $get_keys = $o->get('key-types') =~ m/k/ ? 1 : 0;
3410  ***      8     50                          84      my $get_fks  = $o->get('key-types') =~ m/f/ ? 1 : 0;
3411                                                  
3412                                                     # Connect to the database
3413  ***      8     50                          59      if ( $o->got('ask-pass') ) {
3414  ***      0                                  0         $o->set('password', OptionParser::prompt_noecho("Enter password: "));
3415                                                     }
3416           8                                112      my $dsn_defaults = $dp->parse_options($o);
3417  ***      8     50                          57      my $dsn          = @ARGV ? $dp->parse(shift @ARGV, $dsn_defaults)
3418                                                                      :         $dsn_defaults;
3419           8                                115      my $dbh          = $dp->get_dbh($dp->get_cxn_params($dsn),
3420                                                                                { AutoCommit => 1, });
3421                                                  
3422           8                                249      my $vp = new VersionParser();
3423           8                                 32      my $version = $vp->parse($dbh->selectrow_array('SELECT VERSION()'));
3424                                                  
3425           8    100                         264      my $ks = $o->get('summary') ? new KeySize(q=>$q) : undef;
3426           8                                203      my $dk = new DuplicateKeyFinder();
3427           8                                150      my $du = new MySQLDump();
3428                                                  
3429           8                                 64      my %tp_opts = (
3430                                                        ignore_type  => $o->get('all-structs'),
3431                                                        ignore_order => $o->get('ignore-order'),
3432                                                        clustered    => $o->get('clustered'),
3433                                                     );
3434                                                  
3435                                                     # #######################################################################
3436                                                     # Do the main work.
3437                                                     # #######################################################################
3438                                                  
3439           8                                227      my $si = new SchemaIterator(
3440                                                        Quoter => $q,
3441                                                     );
3442           8                                115      $si->set_filter($si->make_filter($o));
3443           8                                 89      my $next_db = $si->get_db_itr(dbh => $dbh);
3444                                                     DATABASE:
3445           8                                 54      while ( my $database = $next_db->() ) {
3446           7                                 23         MKDEBUG && _d('Getting tables from', $database);
3447           7                                 70         my $next_tbl = $si->get_tbl_itr(
3448                                                           dbh   => $dbh,
3449                                                           db    => $database,
3450                                                           views => 0,
3451                                                        );
3452                                                        TABLE:
3453           7                                 46         while ( my $table = $next_tbl->() ) {
3454           8                                 27            MKDEBUG && _d('Got table', $table);
3455           8                                136            my $ddl      = $du->get_create_table($dbh, $q, $database, $table)->[1];
3456  ***      8            33                  126            my $engine   = $tp->get_engine($ddl) || next TABLE;
3457           8                               1624            my $tbl_info = {
3458                                                              db     => $database,
3459                                                              tbl    => $table,
3460                                                              engine => $engine,
3461                                                              ddl    => $ddl,
3462                                                           };
3463                                                  
3464  ***      8     50                         169            my ($keys, $clustered_key)
3465                                                                    = $tp->get_keys($ddl, {version => $version })  if $get_keys;
3466  ***      8     50                         147            my $fks  = $tp->get_fks($ddl,  {database => $database}) if $get_fks;
3467                                                  
3468  ***      8     50     33                  155            next TABLE unless %$keys || %$fks;
3469                                                  
3470  ***      8     50                          76            if ( $o->got('verbose') ) {
3471  ***      0      0                           0               print_all_keys($keys, $tbl_info, \%seen_tbl) if $keys;
3472  ***      0      0                           0               print_all_keys($fks,  $tbl_info, \%seen_tbl) if $fks;
3473                                                           }
3474                                                           else {
3475           8                                 26               MKDEBUG && _d('Getting duplicate keys on', $database, $table);
3476  ***      8     50                         218               $dk->get_duplicate_keys(
3477                                                                 $keys,
3478                                                                 clustered_key => $clustered_key,
3479                                                                 tbl_info      => $tbl_info,
3480                                                                 callback      => \&print_duplicate_key,
3481                                                                 %tp_opts,
3482                                                                 # get_duplicate_keys() ignores these args but passes them
3483                                                                 # to the callback:
3484                                                                    dbh      => $dbh,
3485                                                                    is_fk    => 0,
3486                                                                    o        => $o,
3487                                                                    ks       => $ks,
3488                                                                    tp       => $tp,
3489                                                                    q        => $q,
3490                                                                    seen_tbl => \%seen_tbl,
3491                                                                    summary  => \%summary,
3492                                                              ) if $keys;
3493                                                  
3494  ***      8     50                         195               $dk->get_duplicate_fks(
3495                                                                 $fks,
3496                                                                 tbl_info => $tbl_info,
3497                                                                 callback => \&print_duplicate_key,
3498                                                                 %tp_opts,
3499                                                                 # get_duplicate_fks() ignores these args but passes them
3500                                                                 # to the callback:
3501                                                                    dbh   => $dbh,
3502                                                                    is_fk => 1,
3503                                                                    o     => $o,
3504                                                                    ks    => $ks,
3505                                                                    tp       => $tp,
3506                                                                    q        => $q,
3507                                                                    seen_tbl => \%seen_tbl,
3508                                                                    summary  => \%summary,
3509                                                              ) if $fks;
3510                                                           }
3511                                                  
3512                                                           # Always count Total Keys so print_key_summary won't die
3513                                                           # because %summary is empty.
3514           8                                292            $summary{'Total Indexes'} += (scalar keys %$keys) + (scalar keys %$fks)
3515                                                        }  # TABLE
3516                                                     }  # DATABASE
3517                                                  
3518           8    100                          66      print_key_summary(%summary) if $o->get('summary');
3519                                                  
3520           8                               3427      return 0;
3521                                                  }
3522                                                  
3523                                                  # ##########################################################################
3524                                                  # Subroutines
3525                                                  # ##########################################################################
3526                                                  
3527                                                  sub print_all_keys {
3528  ***      0                    0             0      my ( $keys, $tbl_info, $seen_tbl ) = @_;
3529  ***      0      0                           0      return unless $keys;
3530  ***      0                                  0      my $db  = $tbl_info->{db};
3531  ***      0                                  0      my $tbl = $tbl_info->{tbl};
3532  ***      0      0                           0      if ( !$seen_tbl->{"$db$tbl"}++ ) {
3533  ***      0                                  0         printf $hdr_fmt, ('#' x $hdr_width);
3534  ***      0                                  0         printf $hdr_fmt, "$db.$tbl";
3535  ***      0                                  0         printf $hdr_fmt, ('#' x $hdr_width);
3536                                                     }
3537  ***      0                                  0      foreach my $key ( values %$keys ) {
3538  ***      0                                  0         print "\n# $key->{name} ($key->{colnames})";
3539                                                     }
3540  ***      0                                  0      print "\n";
3541  ***      0                                  0      return;
3542                                                  }
3543                                                  
3544                                                  sub print_duplicate_key {
3545           6                    6           146      my ( $dupe, %args ) = @_;
3546  ***      6     50                          58      return unless $dupe;
3547           6                                 62      foreach my $arg ( qw(tbl_info dbh is_fk o ks q tp seen_tbl) ) {
3548  ***     48     50                         328         die "I need a $arg argument" unless exists $args{$arg};
3549                                                     }
3550           6                                 21      MKDEBUG && _d('Printing duplicate key', $dupe->{key});
3551           6                                 42      my $db       = $args{tbl_info}->{db};
3552           6                                 49      my $tbl      = $args{tbl_info}->{tbl};
3553           6                                 29      my $dbh      = $args{dbh};
3554           6                                 33      my $o        = $args{o};
3555           6                                 30      my $ks       = $args{ks};
3556           6                                 29      my $seen_tbl = $args{seen_tbl};
3557           6                                 42      my $q        = $args{q};
3558           6                                 29      my $tp       = $args{tp};
3559           6                                 30      my $summary  = $args{summary};
3560           6                                 86      my $struct   = $tp->parse($args{tbl_info}->{ddl});
3561                                                  
3562  ***      6     50                          88      if ( !$seen_tbl->{"$db$tbl"}++ ) {
3563           6                                170         printf $hdr_fmt, ('#' x $hdr_width);
3564           6                                 59         printf $hdr_fmt, "$db.$tbl";
3565           6                                 54         printf $hdr_fmt, ('#' x $hdr_width);
3566           6                                 33         print "\n";
3567                                                     }
3568                                                  
3569           6                                 61      $dupe->{reason} =~ s/\n/\n# /g;
3570           6                                 49      print "# $dupe->{reason}\n";
3571                                                  
3572           6                                 27      print "# Key definitions:\n";
3573  ***      6            50                   60      print "#   " . ($dupe->{ddl} || '') . "\n";
3574  ***      6            50                   62      print "#   " . ($dupe->{duplicate_of_ddl} || '') . "\n";
3575                                                  
3576           6                                 26      print "# Column types:\n";
3577           6                                 21      my %seen;  # print each column only once
3578           6                                 27      foreach my $col ( @{$dupe->{cols}}, @{$dupe->{duplicate_of_cols}} ) {
               6                                 38   
               6                                 44   
3579          16    100                         121         next if $seen{$col}++;
3580          10                                 34         MKDEBUG && _d('col', $col);
3581          10                                116         print "#\t" . lc($struct->{defs}->{lc $col}) . "\n";
3582                                                     }
3583                                                  
3584           6    100                          60      if ( $o->get('sql') ) {
3585           5    100                          40         if ( $dupe->{dupe_type} ne 'clustered' ) {
3586           4    100                          54            print "# To remove this duplicate "
                    100                               
3587                                                              . ($args{is_fk} ? 'foreign key' : 'index')
3588                                                              . ", execute:\n"
3589                                                              . 'ALTER TABLE ' . $q->quote($db, $tbl)
3590                                                              . ($args{is_fk} ? ' DROP FOREIGN KEY ' : ' DROP INDEX ')
3591                                                              . "`$dupe->{key}`;\n";
3592                                                        }
3593                                                        else {
3594                                                           # Suggest shortening clustered dupes instead of
3595                                                           # removing them (issue 295).
3596           1                                  5            print "# To shorten this duplicate clustered index, execute:\n"
3597                                                              . 'ALTER TABLE '.$q->quote($db, $tbl)." DROP INDEX `$dupe->{key}`, "
3598                                                              . "ADD INDEX `$dupe->{key}` ($dupe->{short_key});\n";
3599                                                        }
3600                                                     }
3601           6                                 33      print "\n";
3602                                                  
3603  ***      6    100     66                   40      if ( $o->get('summary') && $summary ) {
3604           5                                 34         $summary->{'Total Duplicate Indexes'} += 1;
3605           5                                 54         my ($size, $chosen_key) = $ks->get_key_size(
3606                                                           name        => $dupe->{key},
3607                                                           cols        => $dupe->{cols},
3608                                                           tbl_name    => $q->quote($db, $tbl),
3609                                                           tbl_struct  => $struct,
3610                                                           dbh         => $dbh,
3611                                                        );
3612           5    100                          41         if ( $args{is_fk} ) {
3613                                                           # Foreign keys have no size because they're just constraints.
3614           1                                 16            print "# MySQL uses the $chosen_key index for this "
3615                                                              . "foreign key constraint\n\n";
3616                                                        }
3617                                                        else {
3618           4           100                   29            $size ||= 0;
3619                                                  
3620                                                           # Create Size Duplicate Keys summary even if there's no valid keys.
3621           4                                 28            $summary->{'Size Duplicate Indexes'} += $size;
3622                                                  
3623           4    100                          26            if ( $size ) {
3624  ***      1     50     33                   15               if ( $chosen_key && $chosen_key ne $dupe->{key} ) {
3625                                                                 # This shouldn't happen. But in case it does, we should know.
3626  ***      0                                  0                  print "# MySQL chose the $chosen_key index despite FORCE INDEX\n\n";
3627                                                              }
3628                                                           }
3629                                                        }
3630                                                     }
3631           6                                211      return;
3632                                                  }
3633                                                  
3634                                                  sub print_key_summary {
3635           7                    7            65      my ( %summary ) = @_;
3636           7                                111      printf $hdr_fmt, ('#' x $hdr_width);
3637           7                                 44      printf $hdr_fmt, 'Summary of indexes';
3638           7                                 49      printf $hdr_fmt, ('#' x $hdr_width);
3639           7                                 34      print "\n";
3640           7                                 50      my $max_item = max(map { length($_) } keys %summary);
              16                                132   
3641           7                                 58      my $line_fmt = "# %-${max_item}s  %-s\n";
3642           7                                128      foreach my $item ( sort keys %summary ) {
3643          16                               9272         printf $line_fmt, $item, $summary{$item};
3644                                                     }
3645           7                                 70      return;
3646                                                  }
3647                                                  
3648                                                  sub _d {
3649  ***      0                    0                    my ($package, undef, $line) = caller 0;
3650  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
3651  ***      0                                              map { defined $_ ? $_ : 'undef' }
3652                                                          @_;
3653  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3654                                                  }
3655                                                  
3656                                                  # ############################################################################
3657                                                  # Run the program.
3658                                                  # ############################################################################
3659                                                  if ( !caller ) { exit main(@ARGV); }
3660                                                  
3661                                                  1; # Because this is a module as well as a script.
3662                                                  
3663                                                  # ############################################################################
3664                                                  # Documentation
3665                                                  # ############################################################################
3666                                                  
3667                                                  =pod
3668                                                  
3669                                                  =head1 NAME
3670                                                  
3671                                                  mk-duplicate-key-checker - Find duplicate indexes and foreign keys on MySQL tables.
3672                                                  
3673                                                  =head1 SYNOPSIS
3674                                                  
3675                                                     mk-duplicate-key-checker --host host1
3676                                                  
3677                                                  =head1 RISKS
3678                                                  
3679                                                  The following section is included to inform users about the potential risks,
3680                                                  whether known or unknown, of using this tool.  The two main categories of risks
3681                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
3682                                                  tools) and those created by bugs.
3683                                                  
3684                                                  mk-duplicate-key-checker is a read-only tool that executes SHOW CREATE TABLE and
3685                                                  related queries to inspect table structures, and thus is very low-risk.
3686                                                  
3687                                                  At the time of this release, there is an unconfirmed bug that causes the tool
3688                                                  to crash.
3689                                                  
3690                                                  The authoritative source for updated information is always the online issue
3691                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
3692                                                  see a list of such issues at the following URL:
3693                                                  L<http://www.maatkit.org/bugs/mk-duplicate-key-checker>.
3694                                                  
3695                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
3696                                                  
3697                                                  =head1 DESCRIPTION
3698                                                  
3699                                                  This program examines the output of SHOW CREATE TABLE on MySQL tables, and if
3700                                                  it finds indexes that cover the same columns as another index in the same
3701                                                  order, or cover an exact leftmost prefix of another index, it prints out
3702                                                  the suspicious indexes.  By default, indexes must be of the same type, so a
3703                                                  BTREE index is not a duplicate of a FULLTEXT index, even if they have the same
3704                                                  colums.  You can override this.
3705                                                  
3706                                                  It also looks for duplicate foreign keys.  A duplicate foreign key covers the
3707                                                  same columns as another in the same table, and references the same parent
3708                                                  table.
3709                                                  
3710                                                  =head1 OPTIONS
3711                                                  
3712                                                  =over
3713                                                  
3714                                                  =item --all-structs
3715                                                  
3716                                                  Compare indexes with different structs (BTREE, HASH, etc).
3717                                                  
3718                                                  By default this is disabled, because a BTREE index that covers the same columns
3719                                                  as a FULLTEXT index is not really a duplicate, for example.
3720                                                  
3721                                                  =item --ask-pass
3722                                                  
3723                                                  Prompt for a password when connecting to MySQL.
3724                                                  
3725                                                  =item --charset
3726                                                  
3727                                                  short form: -A; type: string
3728                                                  
3729                                                  Default character set.  If the value is utf8, sets Perl's binmode on
3730                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and runs SET
3731                                                  NAMES UTF8 after connecting to MySQL.  Any other value sets binmode on STDOUT
3732                                                  without the utf8 layer, and runs SET NAMES after connecting to MySQL.
3733                                                  
3734                                                  =item --[no]clustered
3735                                                  
3736                                                  default: yes
3737                                                  
3738                                                  PK columns appended to secondary key is duplicate.
3739                                                  
3740                                                  Detects when a suffix of a secondary key is a leftmost prefix of the primary
3741                                                  key, and treats it as a duplicate key.  Only detects this condition on storage
3742                                                  engines whose primary keys are clustered (currently InnoDB and solidDB).
3743                                                  
3744                                                  Clustered storage engines append the primary key columns to the leaf nodes of
3745                                                  all secondary keys anyway, so you might consider it redundant to have them
3746                                                  appear in the internal nodes as well.  Of course, you may also want them in the
3747                                                  internal nodes, because just having them at the leaf nodes won't help for some
3748                                                  queries.  It does help for covering index queries, however.
3749                                                  
3750                                                  Here's an example of a key that is considered redundant with this option:
3751                                                  
3752                                                    PRIMARY KEY  (`a`)
3753                                                    KEY `b` (`b`,`a`)
3754                                                  
3755                                                  The use of such indexes is rather subtle.  For example, suppose you have the
3756                                                  following query:
3757                                                  
3758                                                    SELECT ... WHERE b=1 ORDER BY a;
3759                                                  
3760                                                  This query will do a filesort if we remove the index on C<b,a>.  But if we
3761                                                  shorten the index on C<b,a> to just C<b> and also remove the ORDER BY, the query
3762                                                  should return the same results.
3763                                                  
3764                                                  The tool suggests shortening duplicate clustered keys by dropping the key
3765                                                  and re-adding it without the primary key prefix.  The shortened clustered
3766                                                  key may still duplicate another key, but the tool cannot currently detect
3767                                                  when this happens without being ran a second time to re-check the newly
3768                                                  shortened clustered keys.  Therefore, if you shorten any duplicate clusterted
3769                                                  keys, you should run the tool again.
3770                                                  
3771                                                  =item --config
3772                                                  
3773                                                  type: Array
3774                                                  
3775                                                  Read this comma-separated list of config files; if specified, this must be the
3776                                                  first option on the command line.
3777                                                  
3778                                                  =item --databases
3779                                                  
3780                                                  short form: -d; type: hash
3781                                                  
3782                                                  Check only this comma-separated list of databases.
3783                                                  
3784                                                  =item --defaults-file
3785                                                  
3786                                                  short form: -F; type: string
3787                                                  
3788                                                  Only read mysql options from the given file.  You must give an absolute pathname.
3789                                                  
3790                                                  =item --engines
3791                                                  
3792                                                  short form: -e; type: hash
3793                                                  
3794                                                  Check only tables whose storage engine is in this comma-separated list.
3795                                                  
3796                                                  =item --help
3797                                                  
3798                                                  Show help and exit.
3799                                                  
3800                                                  =item --host
3801                                                  
3802                                                  short form: -h; type: string
3803                                                  
3804                                                  Connect to host.
3805                                                  
3806                                                  =item --ignore-databases
3807                                                  
3808                                                  type: Hash
3809                                                  
3810                                                  Ignore this comma-separated list of databases.
3811                                                  
3812                                                  =item --ignore-engines
3813                                                  
3814                                                  type: Hash
3815                                                  
3816                                                  Ignore this comma-separated list of storage engines.
3817                                                  
3818                                                  =item --ignore-order
3819                                                  
3820                                                  Ignore index order so KEY(a,b) duplicates KEY(b,a).
3821                                                  
3822                                                  =item --ignore-tables
3823                                                  
3824                                                  type: Hash
3825                                                  
3826                                                  Ignore this comma-separated list of tables.  Table names may be qualified with
3827                                                  the database name.
3828                                                  
3829                                                  =item --key-types
3830                                                  
3831                                                  type: string; default: fk
3832                                                  
3833                                                  Check for duplicate f=foreign keys, k=keys or fk=both.
3834                                                  
3835                                                  =item --password
3836                                                  
3837                                                  short form: -p; type: string
3838                                                  
3839                                                  Password to use when connecting.
3840                                                  
3841                                                  =item --pid
3842                                                  
3843                                                  type: string
3844                                                  
3845                                                  Create the given PID file.  The file contains the process ID of the script.
3846                                                  The PID file is removed when the script exits.  Before starting, the script
3847                                                  checks if the PID file already exists.  If it does not, then the script creates
3848                                                  and writes its own PID to it.  If it does, then the script checks the following:
3849                                                  if the file contains a PID and a process is running with that PID, then
3850                                                  the script dies; or, if there is no process running with that PID, then the
3851                                                  script overwrites the file with its own PID and starts; else, if the file
3852                                                  contains no PID, then the script dies.
3853                                                  
3854                                                  =item --port
3855                                                  
3856                                                  short form: -P; type: int
3857                                                  
3858                                                  Port number to use for connection.
3859                                                  
3860                                                  =item --set-vars
3861                                                  
3862                                                  type: string; default: wait_timeout=10000
3863                                                  
3864                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this string
3865                                                  will be appended to SET and executed.
3866                                                  
3867                                                  =item --socket
3868                                                  
3869                                                  short form: -S; type: string
3870                                                  
3871                                                  Socket file to use for connection.
3872                                                  
3873                                                  =item --[no]sql
3874                                                  
3875                                                  default: yes
3876                                                  
3877                                                  Print DROP KEY statement for each duplicate key.  By default an ALTER TABLE
3878                                                  DROP KEY statement is printed below each duplicate key so that, if you want to
3879                                                  remove the duplicate key, you can copy-paste the statement into MySQL.
3880                                                  
3881                                                  To disable printing these statements, specify --nosql.
3882                                                  
3883                                                  =item --[no]summary
3884                                                  
3885                                                  default: yes
3886                                                  
3887                                                  Print summary of indexes at end of output.
3888                                                  
3889                                                  =item --tables
3890                                                  
3891                                                  short form: -t; type: hash
3892                                                  
3893                                                  Check only this comma-separated list of tables.
3894                                                  
3895                                                  Table names may be qualified with the database name.
3896                                                  
3897                                                  =item --user
3898                                                  
3899                                                  short form: -u; type: string
3900                                                  
3901                                                  User for login if not current user.
3902                                                  
3903                                                  =item --verbose
3904                                                  
3905                                                  short form: -v
3906                                                  
3907                                                  Output all keys and/or foreign keys found, not just redundant ones.
3908                                                  
3909                                                  =item --version
3910                                                  
3911                                                  Show version and exit.
3912                                                  
3913                                                  =back
3914                                                  
3915                                                  =head1 DSN OPTIONS
3916                                                  
3917                                                  These DSN options are used to create a DSN.  Each option is given like
3918                                                  C<option=value>.  The options are case-sensitive, so P and p are not the
3919                                                  same option.  There cannot be whitespace before or after the C<=> and
3920                                                  if the value contains whitespace it must be quoted.  DSN options are
3921                                                  comma-separated.  See the L<maatkit> manpage for full details.
3922                                                  
3923                                                  =over
3924                                                  
3925                                                  =item * A
3926                                                  
3927                                                  dsn: charset; copy: yes
3928                                                  
3929                                                  Default character set.
3930                                                  
3931                                                  =item * D
3932                                                  
3933                                                  dsn: database; copy: yes
3934                                                  
3935                                                  Default database.
3936                                                  
3937                                                  =item * F
3938                                                  
3939                                                  dsn: mysql_read_default_file; copy: yes
3940                                                  
3941                                                  Only read default options from the given file
3942                                                  
3943                                                  =item * h
3944                                                  
3945                                                  dsn: host; copy: yes
3946                                                  
3947                                                  Connect to host.
3948                                                  
3949                                                  =item * p
3950                                                  
3951                                                  dsn: password; copy: yes
3952                                                  
3953                                                  Password to use when connecting.
3954                                                  
3955                                                  =item * P
3956                                                  
3957                                                  dsn: port; copy: yes
3958                                                  
3959                                                  Port number to use for connection.
3960                                                  
3961                                                  =item * S
3962                                                  
3963                                                  dsn: mysql_socket; copy: yes
3964                                                  
3965                                                  Socket file to use for connection.
3966                                                  
3967                                                  =item * u
3968                                                  
3969                                                  dsn: user; copy: yes
3970                                                  
3971                                                  User for login if not current user.
3972                                                  
3973                                                  =back
3974                                                  
3975                                                  =head1 DOWNLOADING
3976                                                  
3977                                                  You can download Maatkit from Google Code at
3978                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
3979                                                  easily with a command like the following:
3980                                                  
3981                                                     wget http://www.maatkit.org/get/toolname
3982                                                     or
3983                                                     wget http://www.maatkit.org/trunk/toolname
3984                                                  
3985                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
3986                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
3987                                                  needed.  The first URL gets the latest released version of the tool, and the
3988                                                  second gets the latest trunk code from Subversion.
3989                                                  
3990                                                  =head1 ENVIRONMENT
3991                                                  
3992                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
3993                                                  the Maatkit tools:
3994                                                  
3995                                                     MKDEBUG=1 mk-....
3996                                                  
3997                                                  =head1 SYSTEM REQUIREMENTS
3998                                                  
3999                                                  You need the following Perl modules: DBI and DBD::mysql.
4000                                                  
4001                                                  =head1 BUGS
4002                                                  
4003                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-duplicate-key-checker>.
4004                                                  
4005                                                  Please use Google Code Issues and Groups to report bugs or request support:
4006                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
4007                                                  discuss Maatkit.
4008                                                  
4009                                                  Please include the complete command-line used to reproduce the problem you are
4010                                                  seeing, the version of all MySQL servers involved, the complete output of the
4011                                                  tool when run with L<"--version">, and if possible, debugging output produced by
4012                                                  running with the C<MKDEBUG=1> environment variable.
4013                                                  
4014                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
4015                                                  
4016                                                  This program is copyright 2007-@CURRENTYEAR@ Baron Schwartz.
4017                                                  Feedback and improvements are welcome.
4018                                                  
4019                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
4020                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
4021                                                  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
4022                                                  
4023                                                  This program is free software; you can redistribute it and/or modify it under
4024                                                  the terms of the GNU General Public License as published by the Free Software
4025                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
4026                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
4027                                                  licenses.
4028                                                  
4029                                                  You should have received a copy of the GNU General Public License along with
4030                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
4031                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
4032                                                  
4033                                                  =head1 AUTHOR
4034                                                  
4035                                                  Baron Schwartz, Daniel Nichter
4036                                                  
4037                                                  =head1 ABOUT MAATKIT
4038                                                  
4039                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
4040                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
4041                                                  code contributors.  Both are employed by Percona.  Financial support for
4042                                                  Maatkit development is primarily provided by Percona and its clients. 
4043                                                  
4044                                                  =head1 VERSION
4045                                                  
4046                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 6067 $.
4047                                                  
4048                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
56    ***      0      0      0   if (not $$self{$dbh})
60    ***      0      0      0   $$self{$dbh} ge $self->parse($target) ? :
67    ***      0      0      0   defined $_ ? :
106   ***      0      0      0   unless defined $val
107   ***      0      0      0   if $val eq ''
109   ***      0      0      0   if (not defined $is_numeric)
110   ***      0      0      0   $val =~ /^0|\D/ ? :
113   ***      0      0      0   if $is_numeric
123   ***     50      6      0   if (not $tbl)
132   ***      0      0      0   unless $like
163   ***     50      0      8   unless $args{$arg}
172   ***     50      0      6   unless $ddl
173   ***     50      0      6   if (ref $ddl eq 'ARRAY')
174   ***      0      0      0   if (lc $$ddl[0] eq 'table') { }
184   ***     50      0      6   if (not $ddl =~ /CREATE (?:TEMPORARY )?TABLE `/)
190   ***     50      6      0   if $name
208   ***     50      0     14   unless $type
210   ***     50     14      0   if ($type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/)
214          100      9      5   if (not $def =~ /NOT NULL/)
218   ***     50      0     14   $def =~ /AUTO_INCREMENT/i ? :
249   ***      0      0      0   unless ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
263   ***      0      0      0   if ($index)
266   ***      0      0      0   if (not $best)
267   ***      0      0      0   if ($index) { }
280   ***      0      0      0   unless $where
286   ***      0      0      0   if ($$expl{'possible_keys'}) { }
290   ***      0      0      0   if ($$expl{'key'})
310   ***      0      0      0   unless $args{$arg}
324   ***      0      0      0   if ($EVAL_ERROR)
328   ***      0      0      0   if (not $$row[0] or $$row[0] ne $tbl)
334   ***      0      0      0   unless $args{'all_privs'}
341   ***      0      0      0   if ($EVAL_ERROR)
345   ***      0      0      0   if (not scalar keys %$row)
356   ***      0      0      0   $EVAL_ERROR ? :
361   ***      0      0      0   if (not $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete)
387   ***     50      0     25   if $key =~ /FOREIGN/
392   ***     50     25      0   if (not $engine =~ /MEMORY|HEAP/)
399   ***     50      0     25   if ($$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i)
406          100      9     16   $key =~ /PRIMARY|UNIQUE/ ? :
430          100      5     20   if ($engine =~ /InnoDB/i and not $clustered_key)
432   ***     50      5      0   if ($$this_key{'name'} eq 'PRIMARY') { }
      ***      0      0      0   elsif ($$this_key{'is_unique'} and not $$this_key{'is_nullable'}) { }
456   ***     50      2      0   if (not $parent =~ /\./ and $$opts{'database'})
485   ***      0      0      0   if (($$tbl_struct{'engine'} || '') =~ /InnoDB/i) { }
495   ***      0      0      0   unless $key_ddl =~ /,$/
502   ***      0      0      0   if (@sec_indexes)
519   ***      0      0      0   defined $_ ? :
578   ***      0      0      0   if ($what eq 'table') { }
      ***      0      0      0   elsif ($what eq 'triggers') { }
      ***      0      0      0   elsif ($what eq 'view') { }
580   ***      0      0      0   unless $ddl
581   ***      0      0      0   if ($$ddl[0] eq 'table') { }
595   ***      0      0      0   if ($trgs and @$trgs) { }
598   ***      0      0      0   if ($$trg{'sql_mode'})
602   ***      0      0      0   if ($$trg{'definer'})
634          100      7      9   if (not $new)
641          100      2      7   if ($curr and $new and $curr eq $new)
653   ***     50      8      0   if (not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl})
666   ***     50      0      8   if ($EVAL_ERROR)
676   ***     50      8      0   if ($key) { }
692   ***      0      0      0   if (not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl})
722   ***      0      0      0   if (not $$self{'cache'} or not $$self{'triggers'}{$db})
735   ***      0      0      0   if ($sth->rows)
748   ***      0      0      0   if ($tbl)
756   ***      0      0      0   if (not $$self{'cache'} or not $$self{'databases'} or $like)
759   ***      0      0      0   if ($like)
767   ***      0      0      0   unless $like
775   ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_status'}{$db} or $like)
778   ***      0      0      0   if ($like)
793   ***      0      0      0   unless $like
801   ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_list'}{$db} or $like)
804   ***      0      0      0   if ($like)
812   ***      0      0      0   ($$_[1] || '') eq 'VIEW' ? :
819   ***      0      0      0   unless $like
827   ***      0      0      0   defined $_ ? :
861   ***     50      0     13   unless $args{$arg}
867   ***     50      0    109   if (not $$opt{'key'} or not $$opt{'desc'})
887          100      8     47   if (@_ > 2)
896   ***     50      0     13   if (not $dsn)
908   ***     50     36      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
920   ***     50      0    109   if (not defined $final_props{$key} and defined $$prev{$key} and $$opts{$key}{'copy'})
926          100     73     36   if (not defined $final_props{$key})
933   ***     50      0     36   unless exists $$opts{$key}
938   ***     50      0     13   if (my $required = $self->prop('required'))
940   ***      0      0      0   unless $final_props{$key}
952   ***     50      0      8   unless ref $o eq 'OptionParser'
955          100     56      8   if $o->has($_)
965   ***      0      0      0   unless ref $dsn
966   ***      0      0      0   $props ? :
967   ***      0      0      0   $_ eq 'p' ? :
968   ***      0      0      0   if defined $$dsn{$_}
969   ***      0      0      0   unless not $props
982   ***      0      0      0   $opts{$key}{'copy'} ? :
996   ***     50      0     13   if ($driver eq 'Pg') { }
1028  ***     50      0     13   $cxn_string =~ /charset=utf8/ ? :
1037  ***     50      0     13   if ($$opts{'mysql_use_result'})
1041  ***     50      0     13   if (not $have_dbi)
1060  ***     50     13      0   if ($cxn_string =~ /mysql/i)
1068  ***     50      0     13   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1073  ***      0      0      0   if ($charset eq 'utf8') { }
1074  ***      0      0      0   unless binmode STDOUT, ':utf8'
1078  ***      0      0      0   unless binmode STDOUT
1082         100      8      5   if ($self->prop('set-vars'))
1089  ***     50      0     13   if (not $dbh and $EVAL_ERROR)
1091  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1104  ***      0      0      0   if (not $tries)
1126  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1143  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1153  ***      0      0      0   unless $dsn_1
1154  ***      0      0      0   unless $dsn_2
1158  ***      0      0      0   if ($args{'overwrite'}) { }
1159  ***      0      0      0   defined $$dsn_1{$key} ? :
1162  ***      0      0      0   defined $$dsn_2{$key} ? :
1171  ***      0      0      0   defined $_ ? :
1202  ***     50      0     16   unless $args{$arg}
1272  ***     50      0      8   unless open my $fh, '<', $file
1275  ***     50      8      0   if ($contents =~ /^=head1 DSN OPTIONS/m)
1285  ***     50    128      0   if ($val)
1286  ***     50      0     64   $val eq 'no' ? :
             100     64     64   $val eq 'yes' ? :
1334  ***     50      0     16   unless open my $fh, '<', $file
1342         100   8328     16   unless $para =~ /^=head1 $$self{'head1'}/
1347         100     16      8   if $para =~ /^=over/
1348  ***     50      8      0   if $$self{'skip_rules'}
1356  ***     50      0     16   unless $para
1359         100    272     16   if (my($option) = $para =~ /^=item $$self{'item'}/)
1366         100    232     40   if ($para =~ /: /) { }
1370  ***     50      0    392   unless $$self{'attributes'}{$attrib}
1374         100     88    144   if ($attribs{'short form'})
1390  ***     50      0    272   if $para =~ /^=item/
1392         100     24    248   if (my($base_option) = $option =~ /^\[no\](.*)/)
1397         100     40    232   $attribs{'default'} ? :
      ***     50      0    272   $attribs{'group'} ? :
1405  ***     50      0    392   unless $para
1406         100     16    376   if ($para =~ /^=head1/)
1410         100    272    104   if $para =~ /^=item /
1414  ***     50      0     16   unless @specs
1425  ***     50    208      0   if (ref $opt) { }
1430  ***     50      0    208   if (not $long)
1435  ***     50      0    208   if exists $$self{'opts'}{$long}
1438  ***     50      0    208   if (length $long == 1)
1443         100     88    120   if ($short) { }
1444  ***     50      0     88   if exists $$self{'short_opts'}{$short}
1453         100     24    184   $$opt{'spec'} =~ /!/ ? :
1454  ***     50      0    208   $$opt{'spec'} =~ /\+/ ? :
1455  ***     50      0    208   $$opt{'desc'} =~ /required/ ? :
1468         100     56    152   if $type and $type =~ /[HhAadzm]/
1470         100     40    168   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
1471  ***     50     40      0   defined $def ? :
1475         100      8    200   if ($long eq 'config')
1479  ***     50      0    208   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
1492  ***      0      0      0   if ($opt =~ /mutually exclusive|one and only one/)
1497  ***      0      0      0   if ($opt =~ /at least one|one and only one/)
1502  ***      0      0      0   if ($opt =~ /default to/)
1507  ***      0      0      0   if ($opt =~ /restricted to option groups/)
1517  ***      0      0      0   unless $rule_ok
1534  ***      0      0      0   unless exists $$self{'opts'}{$long}
1558  ***      0      0      0   unless exists $$self{'opts'}{$long}
1578  ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50     28      0   exists $$self{'opts'}{$opt} ? :
1583  ***     50      0     28   if ($$opt{'is_cumulative'}) { }
1598  ***     50      0    160   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100     48    160   exists $$self{'defaults'}{$long} ? :
1607  ***     50      0      8   if (@ARGV and $ARGV[0] eq '--config')
1611  ***     50      8      0   if ($self->has('config'))
1617  ***     50     32      0   if ($EVAL_ERROR)
1618  ***     50      0     32   $self->got('config') ? :
1633  ***     50      0      8   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
1636  ***     50      0      8   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
1637  ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
1643  ***     50      0      8   if (@ARGV and $$self{'strict'})
1649  ***      0      0      0   if (@set > 1)
1660  ***      0      0      0   if (@set == 0)
1679  ***     50      0    208   unless $long
1681         100     28    180   if ($$opt{'got'}) { }
      ***     50      0    180   elsif ($$opt{'is_required'}) { }
1682  ***     50      0     28   if (exists $$self{'disables'}{$long})
1689  ***     50      0     28   if (exists $$self{'allowed_groups'}{$long})
1701  ***      0      0      0   if $restricted_opt eq $long
1702  ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
1707  ***      0      0      0   if (@restricted_opts)
1709  ***      0      0      0   if (@restricted_opts == 1) { }
1730  ***     50    208      0   if ($$opt{'parsed'}) { }
1738  ***     50      0      8   if @long == $long_last
1748  ***     50      0    208   unless $opt
1750         100     72    136   if (not $$opt{'type'})
1757  ***     50      0    136   if ($val and $$opt{'type'} eq 'm') { }
      ***     50      0    136   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0    136   elsif ($val and $$opt{'type'} eq 'z') { }
             100     34    102   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100      8     94   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
1760  ***      0      0      0   if (not $suffix)
1766  ***      0      0      0   if ($suffix =~ /[smhd]/) { }
1767  ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1782  ***      0      0      0   if ($from_key)
1784  ***      0      0      0   if ($$self{'opts'}{$from_key}{'parsed'}) { }
1817         100     72    166   length $opt == 1 ? :
1818  ***     50      0    238   unless $long and exists $$self{'opts'}{$long}
1825  ***     50      0     48   length $opt == 1 ? :
1826  ***     50      0     48   unless $long and exists $$self{'opts'}{$long}
1833         100     64     80   length $opt == 1 ? :
1834         100    136      8   defined $long ? :
1839  ***      0      0      0   length $opt == 1 ? :
1840  ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
1867  ***      0      0      0   unless $ENV{'DONT_BREAK_LINES'}
1875  ***     50      0      8   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0      8   elsif (scalar @{$$self{'errors'};}) { }
1876  ***      0      0      0   unless print $self->print_usage
1880  ***      0      0      0   unless print $self->print_errors
1889  ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
1898  ***      0      0      0   unless $$self{'got_opts'}
1901  ***      0      0      0   $$_{'is_negatable'} ? :
1905  ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
1921  ***      0      0      0   $group eq 'default' ? :
1927  ***      0      0      0   $$opt{'is_negatable'} ? :
1930  ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
1939  ***      0      0      0   if ($short) { }
1948  ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
1952  ***      0      0      0   if ($$self{'DSNParser'})
1960  ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
1972  ***      0      0      0   if ref $_[0] eq 'OptionParser'
1975  ***      0      0      0   unless print $prompt
1983  ***      0      0      0   unless print "\n"
1986  ***      0      0      0   if ($EVAL_ERROR)
2008  ***     50     32      0   unless open my $fh, '<', $filename
2016  ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
2019  ***      0      0      0   if ($line eq '--')
2024  ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
2042  ***      0      0      0   unless open my $fh, '<', $file
2046  ***      0      0      0   unless $para =~ /^=pod$/m
2050  ***      0      0      0   unless $para =~ /$regex/
2055  ***      0      0      0   unless close $fh
2069  ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
2085  ***      0      0      0   if (lc($val || '') eq 'null')
2093  ***      0      0      0   if (defined $num) { }
2094  ***      0      0      0   if ($factor)
2110         100     88    120   $$attribs{'short form'} ? :
             100     24    184   $$attribs{'negatable'} ? :
      ***     50      0    208   $$attribs{'cumulative'} ? :
             100    136     72   $$attribs{'type'} ? :
2119  ***      0      0      0   defined $_ ? :
2151  ***     50      0     25   unless $args{$arg}
2161  ***     50      0      5   if (@cols == 0)
2170         100      4      1   $key_exists ? :
2178         100      4      1   if (scalar @cols == 1)
2188  ***     50      0      5   if ($EVAL_ERROR)
2203         100      2      3   if ($key_len and $rows) { }
2204  ***     50      0      2   if ($chosen_key =~ /,/ and $key_len =~ /,/)
2216  ***     50      2      0   wantarray ? :
2236         100      4      1   exists $args{'tbl_struct'}{'keys'}{lc $args{'name'}} ? :
2241         100      9     21   $$explain{$_} ? :
2249  ***      0      0      0   defined $_ ? :
2282  ***     50      0      8   unless $keys
2296         100      4     10   if ($$key{'name'} eq 'PRIMARY' or $args{'clustered_key'} and $$key{'name'} eq $args{'clustered_key'})
2303  ***     50      0     10   $$key{'type'} eq 'FULLTEXT' ? :
2304  ***     50      0     10   if ($args{'ignore_order'} or $is_fulltext)
2311         100      2      8   $$key{'is_unique'} ? :
2312  ***     50     10      0   if (not $args{'ignore_structure'})
2313  ***     50      0     10   if $is_fulltext
2320         100      4      4   if ($primary_key)
2343         100      3      5   $args{'clustered_key'} ? :
2347         100      3      5   if ($clustered_key and $args{'clustered'} and $args{'tbl_info'}{'engine'} and $args{'tbl_info'}{'engine'} =~ /InnoDB/i)
2366  ***     50      0      8   unless $fks
2371  ***     50      0      1   unless $fks[$i]
2373  ***     50      0      1   unless $fks[$j]
2380  ***     50      1      0   if ($fks[$i]{'parent_tbl'} eq $fks[$j]{'parent_tbl'} and $i_cols eq $j_cols and $i_pcols eq $j_pcols)
2402  ***     50      1      0   if $args{'callback'}
2417         100     16     16   if ($right_keys != $left_keys) { }
2443  ***     50      0     12   unless defined $$left_keys[$left_index]
2447  ***     50      0      6   unless defined $$right_keys[$right_index]
2459         100      4      2   if (substr($left_cols, 0, $right_len_cols) eq substr($right_cols, 0, $right_len_cols)) { }
2462  ***     50      0      4   if ($args{'exact_duplicates'} and $right_len_cols < $left_len_cols)
2467  ***     50      0      4   if (exists $$right_keys[$right_index]{'unique_col'})
2476  ***     50      0      4   if ($$right_keys[$right_index]{'unconstrained'})
2481         100      3      1   $right_len_cols < $left_len_cols ? :
2482         100      1      3   $exact_dupe ? :
2486         100      1      3   $exact_dupe ? :
2499  ***     50      4      0   if $args{'callback'}
2517  ***     50      0      6   unless $ck
2518  ***     50      0      6   unless $keys
2525  ***     50      1      0   if ($key =~ /$ck_cols$/)
2546  ***     50      1      0   if $args{'callback'}
2558  ***     50      0      1   if $ck_cols eq $dupe_key_cols
2566  ***     50      0      8   unless $unique_keys
2576         100      4      6   unless $unique_key
2578         100      5      1   if (@$cols == 1) { }
2580  ***     50      5      0   if (not exists $unique_cols{$$cols[0]})
2597         100      1      1   if (exists $unique_cols{$col})
2600  ***     50      0      1   if ++$n_unique_cols > 1
2604  ***     50      1      0   if ($n_unique_cols and $$unique_set{'key'}{'name'} ne 'PRIMARY')
2616         100      1      1   if (exists $unconstrain{$$unique_keys[$i]{'name'}})
2632  ***      0      0      0   defined $_ ? :
2680  ***      0      0      0   defined $args{'p_ms'} ? :
2681  ***      0      0      0   defined $args{'p_s'} ? :
2684  ***      0      0      0   if $t < 0
2686  ***      0      0      0   if $t =~ /e/
2690  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
2711  ***      0      0      0   $p ? :
2718  ***      0      0      0   unless $secs
2720  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
2725  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
2744  ***      0      0      0   unless defined $val
2748  ***      0      0      0   if ($suffix =~ /[smhd]/) { }
2749  ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
2754  ***      0      0      0   if $prefix and $prefix eq '-'
2764  ***      0      0      0   defined $args{'p'} ? :
2765  ***      0      0      0   defined $args{'d'} ? :
2772  ***      0      0      0   $num =~ /\./ || $n ? :
2781  ***      0      0      0   $gmt ? :
2787  ***      0      0      0   if (my($us) = $time =~ /(\.\d+)$/)
2797  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^$mysql_ts$/)
2800  ***      0      0      0   defined $f ? :
      ***      0      0      0   defined $f ? :
2809  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $us) = $val =~ /^$proper_ts$/)
2810  ***      0      0      0   $gmt ? :
2813  ***      0      0      0   if (defined $us)
2825  ***      0      0      0   if (my($n, $suffix) = $val =~ /^$n_ts$/) { }
      ***      0      0      0   elsif ($val =~ /^\d{9,}/) { }
      ***      0      0      0   elsif (my($ymd, $hms) = $val =~ /^(\d{6})(?:\s+(\d+:\d+:\d+))?/) { }
      ***      0      0      0   elsif (($ymd, $hms) = $val =~ /^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) { }
2826  ***      0      0      0   $suffix eq 'd' ? :
      ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
2840  ***      0      0      0   unless $hms
2845  ***      0      0      0   unless $hms
2850  ***      0      0      0   if $callback and ref $callback eq 'CODE'
2866  ***      0      0      0   defined $_ ? :
2895  ***      0      0      0   unless $args{$arg}
2898  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
2914  ***      0      0      0   unless defined(my $pid = fork)
2915  ***      0      0      0   if ($pid)
2922  ***      0      0      0   unless POSIX::setsid()
2923  ***      0      0      0   unless chdir '/'
2929  ***      0      0      0   if (-t STDIN)
2931  ***      0      0      0   unless open STDIN, '/dev/null'
2935  ***      0      0      0   if ($$self{'log_file'}) { }
2937  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
2941  ***      0      0      0   unless open STDERR, '>&STDOUT'
2945  ***      0      0      0   if (-t STDOUT)
2947  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
2950  ***      0      0      0   if (-t STDERR)
2952  ***      0      0      0   unless open STDERR, '>', '/dev/null'
2963  ***      0      0      0   $self ? :
2965  ***      0      0      0   if ($PID_file and -f $PID_file) { }
2968  ***      0      0      0   if $EVAL_ERROR
2970  ***      0      0      0   if ($pid) { }
2972  ***      0      0      0   if ($pid_is_alive) { }
2994  ***      0      0      0   if (exists $$self{'child'})
3006  ***      0      0      0   if (not $PID_file)
3013  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
3015  ***      0      0      0   unless print $PID_FH $PID
3017  ***      0      0      0   unless close $PID_FH
3026  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
3027  ***      0      0      0   unless unlink $$self{'PID_file'}
3039  ***      0      0      0   if $$self{'child'} or $$self{'rm_PID_file'}
3045  ***      0      0      0   defined $_ ? :
3076  ***     50      0      8   unless $args{$arg}
3095  ***     50      8      0   if $o->has('databases')
3097  ***     50      8      0   if $o->has('ignore-databases')
3100  ***     50      0      8   if ($o->has('databases-regex') and my $p = $o->get('databases-regex'))
3104  ***     50      0      8   if ($o->has('ignore-databases-regex') and my $p = $o->get('ignore-databases-regex'))
3108  ***     50      8      0   if (@permit_dbs or @reject_dbs or @dbs_regex or @reject_dbs_regex)
3109  ***     50      8      0   @permit_dbs ? :
      ***     50      0      8   @reject_dbs ? :
      ***     50      0      8   @dbs_regex ? :
      ***     50      0      8   @reject_dbs_regex ? :
3118  ***     50      8      0   if ($o->has('tables') or $o->has('ignore-tables') or $o->has('ignore-tables-regex'))
3128         100      2      6   if ($o->get('tables'))
3131  ***     50      0      2   if ($_ =~ /\./) { }
3141  ***     50      0      2   if (@permit_qtbls)
3151  ***     50      8      0   if ($o->get('ignore-tables'))
3154  ***      0      0      0   if ($_ =~ /\./) { }
3164  ***     50      0      8   if (@reject_qtbls and not $have_qtbl)
3170  ***     50      0      8   if (keys %permit_qtbls and not @permit_dbs)
3178  ***      0      0      0   if (keys %$dbs)
3185  ***     50      0      8   if ($o->has('tables-regex') and my $p = $o->get('tables-regex'))
3189  ***     50      0      8   if ($o->has('ignore-tables-regex') and my $p = $o->get('ignore-tables-regex'))
3198  ***     50      8      0   if ($o->has('engines') and $o->get('engines') or $o->has('ignore-engines') and $o->get('ignore-engines'))
3217         100      2      6   if (@permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs or @reject_engs)
3219  ***     50      2      0   @permit_tbls ? :
      ***     50      0      2   @reject_tbls ? :
      ***     50      0      2   @tbls_regex ? :
      ***     50      0      2   @reject_tbls_regex ? :
      ***     50      0      2   @permit_qtbls ? :
      ***     50      0      2   @reject_qtbls ? :
      ***     50      2      0   @get_eng ? :
      ***     50      0      2   @permit_engs ? :
      ***     50      0      2   @reject_engs ? :
3240  ***     50      0      8   unless my $filter_sub = eval $code
3257  ***     50      0      8   unless $args{$arg}
3266  ***     50     33      0   $filter ? :
3268         100      8     25   if $_ =~ /information_schema|lost\+found/
3283  ***     50      0     14   unless $args{$arg}
3289  ***     50      7      0   if ($db) { }
3299  ***     50     11      0   $filter ? :
3300  ***     50     11      0   if (not $views)
3301  ***     50      0     11   if ($type || '') eq 'VIEW'
3321         100     10     42   if (scalar keys %$objs)
3322  ***     50      0     10   $lc ? :
3331  ***      0      0      0   defined $_ ? :
3398  ***     50      0      8   if ($o->get('pid'))
3409  ***     50      8      0   $o->get('key-types') =~ /k/ ? :
3410  ***     50      8      0   $o->get('key-types') =~ /f/ ? :
3413  ***     50      0      8   if ($o->got('ask-pass'))
3417  ***     50      0      8   @ARGV ? :
3425         100      7      1   $o->get('summary') ? :
3464  ***     50      8      0   if $get_keys
3466  ***     50      8      0   if $get_fks
3468  ***     50      0      8   unless %$keys or %$fks
3470  ***     50      0      8   if ($o->got('verbose')) { }
3471  ***      0      0      0   if $keys
3472  ***      0      0      0   if $fks
3476  ***     50      8      0   if $keys
3494  ***     50      8      0   if $fks
3518         100      7      1   if $o->get('summary')
3529  ***      0      0      0   unless $keys
3532  ***      0      0      0   if (not $$seen_tbl{"$db$tbl"}++)
3546  ***     50      0      6   unless $dupe
3548  ***     50      0     48   unless exists $args{$arg}
3562  ***     50      6      0   if (not $$seen_tbl{"$db$tbl"}++)
3579         100      6     10   if $seen{$col}++
3584         100      5      1   if ($o->get('sql'))
3585         100      4      1   if ($$dupe{'dupe_type'} ne 'clustered') { }
3586         100      1      3   $args{'is_fk'} ? :
             100      1      3   $args{'is_fk'} ? :
3603         100      5      1   if ($o->get('summary') and $summary)
3612         100      1      4   if ($args{'is_fk'}) { }
3623         100      1      3   if ($size)
3624  ***     50      0      1   if ($chosen_key and $chosen_key ne $$dupe{'key'})
3650  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
361   ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete
399   ***     33     25      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000'
      ***     33     25      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i
430          100     18      2      5   $engine =~ /InnoDB/i and not $clustered_key
432   ***      0      0      0      0   $$this_key{'is_unique'} and not $$this_key{'is_nullable'}
456   ***     33      0      0      2   not $parent =~ /\./ and $$opts{'database'}
595   ***      0      0      0      0   $trgs and @$trgs
641   ***     66      7      0      2   $curr and $new
      ***     66      7      0      2   $curr and $new and $curr eq $new
920   ***     66     36     73      0   not defined $final_props{$key} and defined $$prev{$key}
      ***     33    109      0      0   not defined $final_props{$key} and defined $$prev{$key} and $$opts{$key}{'copy'}
1053  ***     66     13      0     13   not $dbh and $tries--
1089  ***     33     13      0      0   not $dbh and $EVAL_ERROR
1468         100     72     80     56   $type and $type =~ /[HhAadzm]/
1607  ***     33      0      8      0   @ARGV and $ARGV[0] eq '--config'
1636  ***     33      0      8      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
1643  ***     33      8      0      0   @ARGV and $$self{'strict'}
1757  ***     66     86     50      0   $val and $$opt{'type'} eq 'm'
      ***     66     86     50      0   $val and $$opt{'type'} eq 'd'
      ***     66     86     50      0   $val and $$opt{'type'} eq 'z'
             100     62     40     10   defined $val and $$opt{'type'} eq 'h'
      ***     66     62     32      0   defined $val and $$opt{'type'} eq 'a'
1818  ***     33      0      0    238   $long and exists $$self{'opts'}{$long}
1826  ***     33      0      0     48   $long and exists $$self{'opts'}{$long}
1840  ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
1930  ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
2024  ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
2203  ***     66      3      0      2   $key_len and $rows
2204  ***     33      2      0      0   $chosen_key =~ /,/ and $key_len =~ /,/
2296  ***     66      9      1      0   $args{'clustered_key'} and $$key{'name'} eq $args{'clustered_key'}
2347  ***     66      5      0      3   $clustered_key and $args{'clustered'}
      ***     66      5      0      3   $clustered_key and $args{'clustered'} and $args{'tbl_info'}{'engine'}
      ***     66      5      0      3   $clustered_key and $args{'clustered'} and $args{'tbl_info'}{'engine'} and $args{'tbl_info'}{'engine'} =~ /InnoDB/i
2380  ***     33      0      0      1   $fks[$i]{'parent_tbl'} eq $fks[$j]{'parent_tbl'} and $i_cols eq $j_cols
      ***     33      0      0      1   $fks[$i]{'parent_tbl'} eq $fks[$j]{'parent_tbl'} and $i_cols eq $j_cols and $i_pcols eq $j_pcols
2462  ***     33      4      0      0   $args{'exact_duplicates'} and $right_len_cols < $left_len_cols
2604  ***     33      0      0      1   $n_unique_cols and $$unique_set{'key'}{'name'} ne 'PRIMARY'
2690  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
2754  ***      0      0      0      0   $prefix and $prefix eq '-'
2768  ***      0      0      0      0   $num >= $d and $n < @units - 1
2850  ***      0      0      0      0   $callback and ref $callback eq 'CODE'
2965  ***      0      0      0      0   $PID_file and -f $PID_file
3026  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
3100  ***     33      8      0      0   $o->has('databases-regex') and my $p = $o->get('databases-regex')
3104  ***     33      8      0      0   $o->has('ignore-databases-regex') and my $p = $o->get('ignore-databases-regex')
3164  ***     33      8      0      0   @reject_qtbls and not $have_qtbl
3170  ***     33      8      0      0   keys %permit_qtbls and not @permit_dbs
3185  ***     33      8      0      0   $o->has('tables-regex') and my $p = $o->get('tables-regex')
3189  ***     33      8      0      0   $o->has('ignore-tables-regex') and my $p = $o->get('ignore-tables-regex')
3198  ***     33      0      8      0   $o->has('engines') and $o->get('engines')
      ***     33      0      0      8   $o->has('ignore-engines') and $o->get('ignore-engines')
3603  ***     66      1      0      5   $o->get('summary') and $summary
3624  ***     33      0      1      0   $chosen_key and $chosen_key ne $$dupe{'key'}

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
40    ***     50      0      6   $ENV{'MKDEBUG'} || 0
88    ***     50      0      6   $ENV{'MKDEBUG'} || 0
156   ***     50      0      6   $ENV{'MKDEBUG'} || 0
375   ***     50     28      0   $engine || undef
398   ***     50      0     25   $type || $special || 'BTREE'
485   ***      0      0      0   $$tbl_struct{'engine'} || ''
487   ***      0      0      0   $clustered_key ||= ''
541   ***     50      0      6   $ENV{'MKDEBUG'} || 0
812   ***      0      0      0   $$_[1] || ''
856   ***     50      0      6   $ENV{'MKDEBUG'} || 0
876   ***     50    109      0   $$opt{'copy'} || 0
901   ***     50      0     13   $prev ||= {}
902   ***     50      0     13   $defaults ||= {}
982   ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
995   ***     50      0     13   $self->prop('dbidriver') || ''
999   ***      0      0      0   $$info{'D'} || ''
1005  ***     50      0     13   $$info{'D'} || ''
1027  ***     50     13      0   $opts ||= {}
1126  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1142  ***      0      0      0   $level ||= 0
1143  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1195  ***     50      0      6   $ENV{'MKDEBUG'} || 0
1206  ***     33     16      0   0
1207  ***     50     16      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
1268  ***     50      0      8   $file ||= '/home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker'
1333  ***     50     16      0   $file ||= '/home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker'
1457  ***     50    208      0   $$opt{'group'} ||= 'default'
1762  ***      0      0      0   $s || 's'
1771  ***      0      0      0   $prefix || ''
1801         100     10     24   $val || ''
1804  ***     50      8      0   $val || ''
1863  ***      0      0      0   $$self{'description'} || ''
1932  ***      0      0      0   $s ||= 's'
1958  ***      0      0      0   $$opt{'type'} || ''
2085  ***      0      0      0   $val || ''
2099  ***      0      0      0   $pre || ''
2140  ***     50      0      6   $ENV{'MKDEBUG'} || 0
2272  ***     50      0      6   $ENV{'MKDEBUG'} || 0
2655  ***     50      0      6   $ENV{'MKDEBUG'} || 0
2710  ***      0      0      0   $args{'p'} || 0
2712  ***      0      0      0   $of ||= 1
2717  ***      0      0      0   $secs ||= 0
2747  ***      0      0      0   $suffix || $default_suffix || 's'
2890  ***     50      0      6   $ENV{'MKDEBUG'} || 0
3071  ***     50      0      6   $ENV{'MKDEBUG'} || 0
3301  ***     50     11      0   $type || ''
3359  ***     50      0      6   $ENV{'MKDEBUG'} || 0
3573  ***     50      6      0   $$dupe{'ddl'} || ''
3574  ***     50      6      0   $$dupe{'duplicate_of_ddl'} || ''
3618         100      1      3   $size ||= 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
249   ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'}
      ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
328   ***      0      0      0      0   not $$row[0] or $$row[0] ne $tbl
349   ***      0      0      0      0   $$row{'privileges'} || $$row{'Privileges'}
398   ***     33      0      0     25   $type || $special
653   ***     33      8      0      0   not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl}
692   ***      0      0      0      0   not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl}
722   ***      0      0      0      0   not $$self{'cache'} or not $$self{'triggers'}{$db}
756   ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'} or $like
775   ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db} or $like
789   ***      0      0      0      0   $tbl{'type'} || $tbl{'comment'}
      ***      0      0      0      0   $tbl{'engine'} ||= $tbl{'type'} || $tbl{'comment'}
801   ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db} or $like
867   ***     33      0      0    109   not $$opt{'key'} or not $$opt{'desc'}
1018  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1019  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1020  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1021  ***      0      0      0      0   $$dsn{'u'} ||= $user
1022  ***      0      0      0      0   $$dsn{'D'} ||= $db
1207  ***     33     16      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***     33     16      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
1757         100     24     10    102   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
      ***     66      8      0     94   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
2296  ***     66      4      0     10   $$key{'name'} eq 'PRIMARY' or $args{'clustered_key'} and $$key{'name'} eq $args{'clustered_key'}
2304  ***     33      0      0     10   $args{'ignore_order'} or $is_fulltext
2720  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
2747  ***      0      0      0      0   $suffix || $default_suffix
2772  ***      0      0      0      0   $num =~ /\./ || $n
3039  ***      0      0      0      0   $$self{'child'} or $$self{'rm_PID_file'}
3108  ***     33      8      0      0   @permit_dbs or @reject_dbs
      ***     33      8      0      0   @permit_dbs or @reject_dbs or @dbs_regex
      ***     33      8      0      0   @permit_dbs or @reject_dbs or @dbs_regex or @reject_dbs_regex
3118  ***     33      8      0      0   $o->has('tables') or $o->has('ignore-tables')
      ***     33      8      0      0   $o->has('tables') or $o->has('ignore-tables') or $o->has('ignore-tables-regex')
3198  ***     33      0      8      0   $o->has('engines') and $o->get('engines') or $o->has('ignore-engines') and $o->get('ignore-engines')
3217  ***     66      2      0      6   @permit_tbls or @reject_tbls
      ***     66      2      0      6   @permit_tbls or @reject_tbls or @tbls_regex
      ***     66      2      0      6   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex
      ***     66      2      0      6   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs
      ***     66      2      0      6   @permit_tbls or @reject_tbls or @tbls_regex or @reject_tbls_regex or @permit_engs or @reject_engs
3456  ***     33      8      0      0   $tp->get_engine($ddl) || next TABLE
3468  ***     33      8      0      0   %$keys or %$fks


Covered Subroutines
-------------------

Subroutine                  Count Location                                                                       
--------------------------- ----- -------------------------------------------------------------------------------
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1188
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1189
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1191
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1192
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1193
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1195
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:148 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:149 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:150 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:151 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:156 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2136
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2137
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2138
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2140
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2266
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2267
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2268
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2270
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2272
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:23  
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:24  
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2649
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2650
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2651
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2652
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2653
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2655
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2884
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2885
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2887
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2888
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2890
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3062
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3063
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3065
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3066
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3071
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3353
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3354
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3355
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3359
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:35  
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:36  
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:38  
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:40  
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:536 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:537 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:539 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:541 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:84  
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:844 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:845 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:846 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:847 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:85  
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:856 
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:86  
BEGIN                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:88  
DSNParser                       8 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1322
__ANON__                       64 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1282
__ANON__                       28 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1631
__ANON__                       15 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3275
__ANON__                       15 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3314
_check_opts                     8 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1674
_explain_to_text                3 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2240
_key_exists                     5 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2235
_make_filter                   52 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3319
_parse_attribs                208 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2108
_parse_specs                    8 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1421
_pod_to_specs                  16 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1332
_read_config_file              32 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2007
_set_option                    28 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1577
_use_db                        16 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:633 
_validate_type                208 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1747
get                           238 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1816
get_create_table                8 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:652 
get_cxn_params                 13 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:992 
get_db_itr                      8 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3254
get_dbh                        13 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1026
get_defaults_files              8 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1327
get_duplicate_fks               8 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2365
get_duplicate_keys              8 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2281
get_engine                     28 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:372 
get_fks                         8 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:446 
get_key_size                    5 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2149
get_keys                       14 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:379 
get_opts                        8 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1594
get_specs                       8 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1267
get_tbl_itr                     7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3280
got                            48 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1824
has                           144 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1832
main                            8 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3368
make_filter                     8 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3087
new                            16 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1200
new                             8 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:160 
new                             7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2143
new                             8 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2275
new                             8 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3074
new                             8 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:43  
new                             8 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:568 
new                            13 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:859 
new                             8 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:91  
parse                           6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:171 
parse                           8 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:48  
parse                          13 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:895 
parse_options                   8 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:951 
print_duplicate_key             6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3545
print_key_summary               7 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3635
prop                           55 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:886 
quote                          32 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:96  
remove_clustered_duplicates     6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2516
remove_prefix_duplicates       32 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2410
set_filter                      8 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3247
shorten_clustered_duplicate     1 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2557
split_unquote                   6 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:120 
unconstrain_keys                8 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2565
usage_or_errors                 8 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1874

Uncovered Subroutines
---------------------

Subroutine                  Count Location                                                                       
--------------------------- ----- -------------------------------------------------------------------------------
DESTROY                         0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3038
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1170
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2118
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2248
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2631
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2865
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3044
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3330
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3649
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:518 
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:66  
_d                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:826 
_get_participants               0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1531
_make_PID_file                  0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3003
_parse_size                     0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2083
_remove_PID_file                0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3025
any_unix_timestamp              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2823
as_string                       0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:964 
check_PID_file                  0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2962
check_table                     0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:307 
clone                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2060
copy                            0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1152
daemonize                       0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2911
descr                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1862
disconnect                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1135
dump                            0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:576 
error                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2230
errors                          0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1852
explain                         0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2225
fill_in_dsn                     0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1014
find_best_index                 0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:261 
find_possible_keys              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:279 
get_columns                     0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:690 
get_databases                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:755 
get_defaults                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1567
get_groups                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1572
get_hostname                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1125
get_table_list                  0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:800 
get_table_status                0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:774 
get_tmp_table                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:710 
get_triggers                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:721 
literal_like                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:131 
make_PID_file                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2993
make_checksum                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2858
micro_t                         0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2679
new                             0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2893
opts                            0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1543
parse_timestamp                 0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2796
percentage_of                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2709
print_active_handles            0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1141
print_all_keys                  0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:3528
print_errors                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1887
print_usage                     0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1897
prompt                          0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1857
prompt_noecho                   0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1972
query                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2220
quote_val                       0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:104 
read_para_after                 0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2041
remove_auto_increment           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:475 
remove_secondary_indexes        0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:481 
save_error                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1847
secs_to_time                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2716
set                             0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1838
set_defaults                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1555
short_opts                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:1549
shorten                         0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2763
sort_indexes                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:242 
time_to_secs                    0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2743
ts                              0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2780
unix_timestamp                  0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:2808
usage                           0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:975 
version_ge                      0 /home/daniel/dev/maatkit/mk-duplicate-key-checker/mk-duplicate-key-checker:55  


